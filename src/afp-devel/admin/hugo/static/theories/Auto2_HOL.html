<div id="HOL_Base">
<div class="head">
<h1>Theory HOL_Base</h1>
</div>
<pre class="source"><span class="comment1">(*
  File: HOL_Base.thy
  Author: Bohua Zhan

  Extra theorems in logic used by auto2.
*)</span>

<span class="keyword1"><span class="command">theory</span></span> HOL_Base
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">theorem</span></span> to_contra_form<span class="main">:</span> <span class="quoted"><span class="quoted">"Trueprop <span class="free">A</span> <span class="main">≡</span> <span class="main">(</span><span class="main">¬</span><span class="free">A</span> <span class="main">⟹</span> False<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> equal_intr_rule<span class="main">)</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">theorem</span></span> to_contra_form'<span class="main">:</span> <span class="quoted"><span class="quoted">"Trueprop <span class="main">(</span><span class="main">¬</span><span class="free">A</span><span class="main">)</span> <span class="main">≡</span> <span class="main">(</span><span class="free">A</span> <span class="main">⟹</span> False<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> equal_intr_rule<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">theorem</span></span> contra_triv<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="free">A</span> <span class="main">⟹</span> <span class="free">A</span> <span class="main">⟹</span> False"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">theorem</span></span> or_intro1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="main">(</span><span class="free">P</span> <span class="main">∨</span> <span class="free">Q</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">¬</span> <span class="free">P</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">theorem</span></span> or_intro2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="main">(</span><span class="free">P</span> <span class="main">∨</span> <span class="free">Q</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">¬</span> <span class="free">Q</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">theorem</span></span> or_cancel1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="free">Q</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">P</span> <span class="main">∨</span> <span class="free">Q</span><span class="main">)</span> <span class="main">=</span> <span class="free">P</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">theorem</span></span> or_cancel2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="free">P</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">P</span> <span class="main">∨</span> <span class="free">Q</span><span class="main">)</span> <span class="main">=</span> <span class="free">Q</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">theorem</span></span> exE'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span> <span class="main">⟹</span> <span class="free">Q</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span> <span class="main">⟹</span> <span class="free">Q</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">theorem</span></span> nn_create<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⟹</span> <span class="main">¬</span><span class="main">¬</span><span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">theorem</span></span> iffD<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⟷</span> <span class="free">B</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">A</span> <span class="main">⟶</span> <span class="free">B</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="free">B</span> <span class="main">⟶</span> <span class="free">A</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">theorem</span></span> obj_sym<span class="main">:</span> <span class="quoted"><span class="quoted">"Trueprop <span class="main">(</span><span class="free">t</span> <span class="main">=</span> <span class="free">s</span><span class="main">)</span> <span class="main">≡</span> Trueprop <span class="main">(</span><span class="free">s</span> <span class="main">=</span> <span class="free">t</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> equal_intr_rule<span class="main">)</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">theorem</span></span> to_meta_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"Trueprop <span class="main">(</span><span class="free">t</span> <span class="main">=</span> <span class="free">s</span><span class="main">)</span> <span class="main">≡</span> <span class="main">(</span><span class="free">t</span> <span class="main">≡</span> <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> equal_intr_rule<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">theorem</span></span> inv_backward<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⟷</span> <span class="free">B</span> <span class="main">⟹</span> <span class="main">¬</span><span class="free">A</span> <span class="main">⟹</span> <span class="main">¬</span><span class="free">B</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">theorem</span></span> backward_conv<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">A</span> <span class="main">⟹</span> <span class="free">B</span><span class="main">)</span> <span class="main">≡</span> <span class="main">(</span><span class="main">¬</span><span class="free">B</span> <span class="main">⟹</span> <span class="main">¬</span><span class="free">A</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> equal_intr_rule<span class="main">)</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">theorem</span></span> backward1_conv<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">A</span> <span class="main">⟹</span> <span class="free">B</span> <span class="main">⟹</span> <span class="free">C</span><span class="main">)</span> <span class="main">≡</span> <span class="main">(</span><span class="main">¬</span><span class="free">C</span> <span class="main">⟹</span> <span class="free">B</span> <span class="main">⟹</span> <span class="main">¬</span><span class="free">A</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> equal_intr_rule<span class="main">)</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">theorem</span></span> backward2_conv<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">A</span> <span class="main">⟹</span> <span class="free">B</span> <span class="main">⟹</span> <span class="free">C</span><span class="main">)</span> <span class="main">≡</span> <span class="main">(</span><span class="main">¬</span><span class="free">C</span> <span class="main">⟹</span> <span class="free">A</span> <span class="main">⟹</span> <span class="main">¬</span><span class="free">B</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> equal_intr_rule<span class="main">)</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">theorem</span></span> resolve_conv<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">A</span> <span class="main">⟹</span> <span class="free">B</span><span class="main">)</span> <span class="main">≡</span> <span class="main">(</span><span class="main">¬</span><span class="free">B</span> <span class="main">⟹</span> <span class="free">A</span> <span class="main">⟹</span> False<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> equal_intr_rule<span class="main">)</span> <span class="operator">auto</span>

<span class="comment1">(* Quantifiers: swapping out of ALL or EX *)</span>
<span class="keyword1"><span class="command">theorem</span></span> swap_ex_conj<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">P</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="main">∧</span> <span class="free">Q</span> <span class="bound">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">theorem</span></span> swap_all_disj<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">P</span> <span class="main">∨</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="main">∨</span> <span class="free">Q</span> <span class="bound">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="comment1">(* Use these instead of original versions to keep names in abstractions. *)</span>
<span class="keyword1"><span class="command">theorem</span></span> Bex_def'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∃</span><span class="bound">x</span><span class="main">∈</span><span class="free">S</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">S</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">theorem</span></span> Ball_def'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">∈</span><span class="free">S</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">S</span> <span class="main">⟶</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="comment1">(* Taking conjunction of assumptions *)</span>
<span class="keyword1"><span class="command">lemma</span></span> atomize_conjL<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">A</span> <span class="main">⟹</span> <span class="free">B</span> <span class="main">⟹</span> <span class="keyword1">PROP</span> <span class="free">C</span><span class="main">)</span> <span class="main">≡</span> <span class="main">(</span><span class="free">A</span> <span class="main">∧</span> <span class="free">B</span> <span class="main">⟹</span> <span class="keyword1">PROP</span> <span class="free">C</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> equal_intr_rule<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Auto2_HOL">
<div class="head">
<h1>Theory Auto2_HOL</h1>
</div>
<pre class="source"><span class="comment1">(*
  File: Auto2_HOL.thy
  Author: Bohua Zhan

  Main file for auto2 setup in HOL.
*)</span>

<span class="keyword1"><span class="command">theory</span></span> Auto2_HOL
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="HOL_Base.html">HOL_Base</a>
  <span class="keyword2"><span class="keyword">keywords</span></span> <span class="quoted">"@proof"</span> <span class="main">::</span> prf_block <span class="main">%</span> <span class="quoted">"proof"</span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted">"@have"</span> <span class="quoted">"@case"</span> <span class="quoted">"@obtain"</span> <span class="quoted">"@let"</span> <span class="quoted">"@contradiction"</span> <span class="quoted">"@strong_induct"</span> <span class="main">::</span> prf_decl <span class="main">%</span> <span class="quoted">"proof"</span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted">"@unfold"</span> <span class="main">::</span> prf_decl <span class="main">%</span> <span class="quoted">"proof"</span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted">"@induct"</span> <span class="quoted">"@fun_induct"</span> <span class="quoted">"@case_induct"</span> <span class="quoted">"@prop_induct"</span> <span class="quoted">"@cases"</span> <span class="main">::</span> prf_decl <span class="main">%</span> <span class="quoted">"proof"</span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted">"@apply_induct_hyp"</span> <span class="main">::</span> prf_decl <span class="main">%</span> <span class="quoted">"proof"</span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted">"@subgoal"</span> <span class="quoted">"@endgoal"</span> <span class="quoted">"@end"</span> <span class="main">::</span> prf_decl <span class="main">%</span> <span class="quoted">"proof"</span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted">"@qed"</span> <span class="main">::</span> qed_block <span class="main">%</span> <span class="quoted">"proof"</span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted">"@with"</span> <span class="quoted">"where"</span> <span class="quoted">"arbitrary"</span> <span class="quoted">"@rule"</span> <span class="main">::</span> quasi_command
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹../util.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹../util_base.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹auto2_hol.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹../util_logic.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹../box_id.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹../consts.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹../property.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹../wellform.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹../wfterm.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹../rewrite.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹../propertydata.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹../matcher.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹../items.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹../wfdata.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹../auto2_data.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹../status.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹../normalize.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹../proofsteps.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹../auto2_state.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹../logic_steps.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹../auto2.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹../auto2_outer.ML›</span>

<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹acdata.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹ac_steps.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹unfolding.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹induct_outer.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹extra_hol.ML›</span>

<span class="keyword1"><span class="command">method_setup</span></span> auto2 <span class="main">=</span> <span class="quoted">‹Scan.succeed <span class="main">(</span><span class="entity">SIMPLE_METHOD</span> o <span class="entity">Auto2.auto2_tac</span><span class="main">)</span>›</span> <span class="quoted">"auto2 prover"</span>

<span class="keyword1"><span class="command">attribute_setup</span></span> forward <span class="main">=</span> <span class="quoted">‹<span class="entity">setup_attrib</span> <span class="entity">add_forward_prfstep</span>›</span>
<span class="keyword1"><span class="command">attribute_setup</span></span> backward <span class="main">=</span> <span class="quoted">‹<span class="entity">setup_attrib</span> <span class="entity">add_backward_prfstep</span>›</span>
<span class="keyword1"><span class="command">attribute_setup</span></span> backward1 <span class="main">=</span> <span class="quoted">‹<span class="entity">setup_attrib</span> <span class="entity">add_backward1_prfstep</span>›</span>
<span class="keyword1"><span class="command">attribute_setup</span></span> backward2 <span class="main">=</span> <span class="quoted">‹<span class="entity">setup_attrib</span> <span class="entity">add_backward2_prfstep</span>›</span>
<span class="keyword1"><span class="command">attribute_setup</span></span> resolve <span class="main">=</span> <span class="quoted">‹<span class="entity">setup_attrib</span> <span class="entity">add_resolve_prfstep</span>›</span>
<span class="keyword1"><span class="command">attribute_setup</span></span> rewrite <span class="main">=</span> <span class="quoted">‹<span class="entity">setup_attrib</span> <span class="entity">add_rewrite_rule</span>›</span>
<span class="keyword1"><span class="command">attribute_setup</span></span> rewrite_back <span class="main">=</span> <span class="quoted">‹<span class="entity">setup_attrib</span> <span class="entity">add_rewrite_rule_back</span>›</span>
<span class="keyword1"><span class="command">attribute_setup</span></span> rewrite_bidir <span class="main">=</span> <span class="quoted">‹<span class="entity">setup_attrib</span> <span class="entity">add_rewrite_rule_bidir</span>›</span>
<span class="keyword1"><span class="command">attribute_setup</span></span> forward_arg1 <span class="main">=</span> <span class="quoted">‹<span class="entity">setup_attrib</span> <span class="entity">add_forward_arg1_prfstep</span>›</span>
<span class="keyword1"><span class="command">attribute_setup</span></span> forward_arg <span class="main">=</span> <span class="quoted">‹<span class="entity">setup_attrib</span> <span class="entity">add_forward_arg_prfstep</span>›</span>
<span class="keyword1"><span class="command">attribute_setup</span></span> rewrite_arg <span class="main">=</span> <span class="quoted">‹<span class="entity">setup_attrib</span> <span class="entity">add_rewrite_arg_rule</span>›</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="files/AFP/Auto2_HOL/util.ML">
<div class="head">
<h1>File ‹$AFP/Auto2_HOL/util.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*
  File: util.ML
  Author: Bohua Zhan

  Utility functions.
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">BASIC_UTIL</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="comment1">(* Exceptions *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> assert<span class="main">:</span> bool <span class="main">-&gt;</span> string <span class="main">-&gt;</span> unit

  <span class="comment1">(* Types *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> propT<span class="main">:</span> typ

  <span class="comment1">(* Lists *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> the_pair<span class="main">:</span> 'a list <span class="main">-&gt;</span> 'a * 'a
  <span class="keyword1"><span class="keyword">val</span></span> the_triple<span class="main">:</span> 'a list <span class="main">-&gt;</span> 'a * 'a * 'a
  <span class="keyword1"><span class="keyword">val</span></span> filter_split<span class="main">:</span> <span class="main">(</span>'a <span class="main">-&gt;</span> bool<span class="main">)</span> <span class="main">-&gt;</span> 'a list <span class="main">-&gt;</span> 'a list * 'a list

  <span class="comment1">(* Managing matching environments. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> fo_init<span class="main">:</span> Type.tyenv * Envir.tenv
  <span class="keyword1"><span class="keyword">val</span></span> lookup_instn<span class="main">:</span> Type.tyenv * Envir.tenv <span class="main">-&gt;</span> string * int <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> lookup_inst<span class="main">:</span> Type.tyenv * Envir.tenv <span class="main">-&gt;</span> string <span class="main">-&gt;</span> term

  <span class="comment1">(* Tracing functions. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> trace_t<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string <span class="main">-&gt;</span> term <span class="main">-&gt;</span> unit
  <span class="keyword1"><span class="keyword">val</span></span> trace_tlist<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> unit
  <span class="keyword1"><span class="keyword">val</span></span> trace_thm<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> unit
  <span class="keyword1"><span class="keyword">val</span></span> trace_fullthm<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> unit
  <span class="keyword1"><span class="keyword">val</span></span> trace_thm_global<span class="main">:</span> string <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> unit
  <span class="keyword1"><span class="keyword">val</span></span> trace_fullthm_global<span class="main">:</span> string <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> unit

  <span class="comment1">(* Terms *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> dest_arg<span class="main">:</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> dest_arg1<span class="main">:</span> term <span class="main">-&gt;</span> term

  <span class="comment1">(* Theorems *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> apply_to_thm<span class="main">:</span> conv <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> meta_sym<span class="main">:</span> thm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> apply_to_lhs<span class="main">:</span> conv <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> apply_to_rhs<span class="main">:</span> conv <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">UTIL</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">include</span></span> <span class="entity">BASIC_UTIL</span>

  <span class="comment1">(* Lists *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> max<span class="main">:</span> <span class="main">(</span>'a * 'a <span class="main">-&gt;</span> order<span class="main">)</span> <span class="main">-&gt;</span> 'a list <span class="main">-&gt;</span> 'a
  <span class="keyword1"><span class="keyword">val</span></span> max_partial<span class="main">:</span> <span class="main">(</span>'a <span class="main">-&gt;</span> 'a <span class="main">-&gt;</span> bool<span class="main">)</span> <span class="main">-&gt;</span> 'a list <span class="main">-&gt;</span> 'a list
  <span class="keyword1"><span class="keyword">val</span></span> subsets<span class="main">:</span> 'a list <span class="main">-&gt;</span> 'a list list
  <span class="keyword1"><span class="keyword">val</span></span> all_permutes<span class="main">:</span> 'a list <span class="main">-&gt;</span> 'a list list
  <span class="keyword1"><span class="keyword">val</span></span> all_pairs<span class="main">:</span> 'a list * 'b list <span class="main">-&gt;</span> <span class="main">(</span>'a * 'b<span class="main">)</span> list
  <span class="keyword1"><span class="keyword">val</span></span> remove_dup_lists<span class="main">:</span> <span class="main">(</span>'a * 'a <span class="main">-&gt;</span> order<span class="main">)</span> <span class="main">-&gt;</span> 'a list * 'a list <span class="main">-&gt;</span> 'a list * 'a list
  <span class="keyword1"><span class="keyword">val</span></span> is_subseq<span class="main">:</span> <span class="main">(</span>'a * 'a <span class="main">-&gt;</span> bool<span class="main">)</span> <span class="main">-&gt;</span> 'a list * 'a list <span class="main">-&gt;</span> bool

  <span class="comment1">(* Strings. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> is_prefix_str<span class="main">:</span> string <span class="main">-&gt;</span> string <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> is_just_internal<span class="main">:</span> string <span class="main">-&gt;</span> bool

  <span class="comment1">(* Managing matching environments. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> defined_instn<span class="main">:</span> Type.tyenv * Envir.tenv <span class="main">-&gt;</span> string * int <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> lookup_tyinst<span class="main">:</span> Type.tyenv * Envir.tenv <span class="main">-&gt;</span> string <span class="main">-&gt;</span> typ
  <span class="keyword1"><span class="keyword">val</span></span> update_env<span class="main">:</span> indexname * term <span class="main">-&gt;</span> Type.tyenv * Envir.tenv <span class="main">-&gt;</span>
                  Type.tyenv * Envir.tenv
  <span class="keyword1"><span class="keyword">val</span></span> eq_env<span class="main">:</span> <span class="main">(</span>Type.tyenv * Envir.tenv<span class="main">)</span> * <span class="main">(</span>Type.tyenv * Envir.tenv<span class="main">)</span> <span class="main">-&gt;</span> bool

  <span class="comment1">(* Matching. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> first_order_match_list<span class="main">:</span>
      theory <span class="main">-&gt;</span> <span class="main">(</span>term * term<span class="main">)</span> list <span class="main">-&gt;</span> Type.tyenv * Envir.tenv <span class="main">-&gt;</span> Type.tyenv * Envir.tenv

  <span class="comment1">(* Printing functions, mostly from Isabelle Cookbook. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> string_of_terms<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> string
  <span class="keyword1"><span class="keyword">val</span></span> string_of_terms_global<span class="main">:</span> theory <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> string
  <span class="keyword1"><span class="keyword">val</span></span> string_of_tyenv<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> Type.tyenv <span class="main">-&gt;</span> string
  <span class="keyword1"><span class="keyword">val</span></span> string_of_env<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> Envir.tenv <span class="main">-&gt;</span> string
  <span class="keyword1"><span class="keyword">val</span></span> string_of_list<span class="main">:</span> <span class="main">(</span>'a <span class="main">-&gt;</span> string<span class="main">)</span> <span class="main">-&gt;</span> 'a list <span class="main">-&gt;</span> string
  <span class="keyword1"><span class="keyword">val</span></span> string_of_list'<span class="main">:</span> <span class="main">(</span>'a <span class="main">-&gt;</span> string<span class="main">)</span> <span class="main">-&gt;</span> 'a list <span class="main">-&gt;</span> string
  <span class="keyword1"><span class="keyword">val</span></span> string_of_bool<span class="main">:</span> bool <span class="main">-&gt;</span> string

  <span class="comment1">(* Managing context. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> declare_free_term<span class="main">:</span> term <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span>

  <span class="comment1">(* Terms. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> is_abs<span class="main">:</span> term <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> is_implies<span class="main">:</span> term <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> dest_binop<span class="main">:</span> term <span class="main">-&gt;</span> term * <span class="main">(</span>term * term<span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> dest_binop_head<span class="main">:</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> dest_binop_args<span class="main">:</span> term <span class="main">-&gt;</span> term * term
  <span class="keyword1"><span class="keyword">val</span></span> dest_args<span class="main">:</span> term <span class="main">-&gt;</span> term list
  <span class="keyword1"><span class="keyword">val</span></span> dest_argn<span class="main">:</span> int <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> get_head_name<span class="main">:</span> term <span class="main">-&gt;</span> string
  <span class="keyword1"><span class="keyword">val</span></span> is_meta_eq<span class="main">:</span> term <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> occurs_frees<span class="main">:</span> term list <span class="main">-&gt;</span> term <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> occurs_free<span class="main">:</span> term <span class="main">-&gt;</span> term <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> has_vars<span class="main">:</span> term <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> is_subterm<span class="main">:</span> term <span class="main">-&gt;</span> term <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> has_subterm<span class="main">:</span> term list <span class="main">-&gt;</span> term <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> is_head<span class="main">:</span> term <span class="main">-&gt;</span> term <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> lambda_abstract<span class="main">:</span> term <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> is_pattern_list<span class="main">:</span> term list <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> is_pattern<span class="main">:</span> term <span class="main">-&gt;</span> bool

  <span class="keyword1"><span class="keyword">val</span></span> normalize_meta_all_imp<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> conv
  <span class="keyword1"><span class="keyword">val</span></span> swap_meta_imp_alls<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> conv
  <span class="keyword1"><span class="keyword">val</span></span> normalize_meta_horn<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> conv
  <span class="keyword1"><span class="keyword">val</span></span> strip_meta_horn<span class="main">:</span> term <span class="main">-&gt;</span> term list * <span class="main">(</span>term list * term<span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> list_meta_horn<span class="main">:</span> term list * <span class="main">(</span>term list * term<span class="main">)</span> <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> to_internal_vars<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term list * term <span class="main">-&gt;</span> term list * term
  <span class="keyword1"><span class="keyword">val</span></span> rename_abs_term<span class="main">:</span> term list <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> print_term_detail<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> string

  <span class="comment1">(* cterms. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> dest_cargs<span class="main">:</span> cterm <span class="main">-&gt;</span> cterm list
  <span class="keyword1"><span class="keyword">val</span></span> dest_binop_cargs<span class="main">:</span> cterm <span class="main">-&gt;</span> cterm * cterm

  <span class="comment1">(* Theorems. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> arg_backn_conv<span class="main">:</span> int <span class="main">-&gt;</span> conv <span class="main">-&gt;</span> conv
  <span class="keyword1"><span class="keyword">val</span></span> argn_conv<span class="main">:</span> int <span class="main">-&gt;</span> conv <span class="main">-&gt;</span> conv
  <span class="keyword1"><span class="keyword">val</span></span> comb_equiv<span class="main">:</span> cterm * thm list <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> name_of_thm<span class="main">:</span> thm <span class="main">-&gt;</span> string
  <span class="keyword1"><span class="keyword">val</span></span> update_name_of_thm<span class="main">:</span> thm <span class="main">-&gt;</span> string <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> lhs_of<span class="main">:</span> thm <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> rhs_of<span class="main">:</span> thm <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> assume_meta_eq<span class="main">:</span> theory <span class="main">-&gt;</span> term * term <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> assume_thm<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> subst_thm_thy<span class="main">:</span> theory <span class="main">-&gt;</span> Type.tyenv * Envir.tenv <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> subst_thm<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> Type.tyenv * Envir.tenv <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> send_first_to_hyps<span class="main">:</span> thm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> send_all_to_hyps<span class="main">:</span> thm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> subst_thm_atomic<span class="main">:</span> <span class="main">(</span>cterm * cterm<span class="main">)</span> list <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> subst_term_norm<span class="main">:</span> Type.tyenv * Envir.tenv <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> concl_conv_n<span class="main">:</span> int <span class="main">-&gt;</span> conv <span class="main">-&gt;</span> conv
  <span class="keyword1"><span class="keyword">val</span></span> concl_conv<span class="main">:</span> conv <span class="main">-&gt;</span> conv
  <span class="keyword1"><span class="keyword">val</span></span> transitive_list<span class="main">:</span> thm list <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> skip_n_conv<span class="main">:</span> int <span class="main">-&gt;</span> conv <span class="main">-&gt;</span> conv
  <span class="keyword1"><span class="keyword">val</span></span> pattern_rewr_conv<span class="main">:</span> term <span class="main">-&gt;</span> <span class="main">(</span>term * thm<span class="main">)</span> list <span class="main">-&gt;</span> conv
  <span class="keyword1"><span class="keyword">val</span></span> eq_cong_th<span class="main">:</span> int <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> forall_elim_sch<span class="main">:</span> thm <span class="main">-&gt;</span> thm

  <span class="comment1">(* Conversions *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> reverse_eta_conv<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> conv
  <span class="keyword1"><span class="keyword">val</span></span> repeat_n_conv<span class="main">:</span> int <span class="main">-&gt;</span> conv <span class="main">-&gt;</span> conv

  <span class="comment1">(* Miscellaneous. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> test_conv<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> conv <span class="main">-&gt;</span> string <span class="main">-&gt;</span> string * string <span class="main">-&gt;</span> unit
  <span class="keyword1"><span class="keyword">val</span></span> term_pat_setup<span class="main">:</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> cterm_pat_setup<span class="main">:</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> type_pat_setup<span class="main">:</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> timer<span class="main">:</span> string * <span class="main">(</span>unit <span class="main">-&gt;</span> 'a<span class="main">)</span> <span class="main">-&gt;</span> 'a
  <span class="keyword1"><span class="keyword">val</span></span> exn_trace<span class="main">:</span> <span class="main">(</span>unit <span class="main">-&gt;</span> 'a<span class="main">)</span> <span class="main">-&gt;</span> 'a
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Util</span> <span class="main">:</span> <span class="entity">UTIL</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">assert</span> <span class="entity">b</span> <span class="entity">exn_str</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">b</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="entity">exn_str</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">propT</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">prop</span><span class="antiquote">}</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">max</span> <span class="entity">comp</span> <span class="entity">lst</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">max2</span> <span class="entity">t1</span> <span class="entity">t2</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">comp</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span> LESS <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">t2</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">t1</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">lst</span> <span class="keyword2"><span class="keyword">of</span></span>
          <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"max: empty list"</span>
        <span class="main">|</span> <span class="entity">l</span> :: <span class="entity">ls</span> <span class="main">=&gt;</span> fold <span class="entity">max2</span> <span class="entity">ls</span> <span class="entity">l</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Given a function comp, remove y for each pair (x, y) such that comp
   x y = true (if x dominates y).
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">max_partial</span> <span class="entity">comp</span> <span class="entity">lst</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">helper</span> <span class="entity">taken</span> <span class="entity">remains</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">remains</span> <span class="keyword2"><span class="keyword">of</span></span>
              <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="entity">taken</span>
            <span class="main">|</span> <span class="entity">x</span> :: <span class="entity">xs</span> <span class="main">=&gt;</span>
              <span class="keyword2"><span class="keyword">if</span></span> exists <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">y</span> <span class="main">=&gt;</span> <span class="entity">comp</span> <span class="entity">y</span> <span class="entity">x</span><span class="main">)</span> <span class="entity">taken</span> <span class="keyword2"><span class="keyword">then</span></span>
                <span class="entity">helper</span> <span class="entity">taken</span> <span class="entity">xs</span>
              <span class="keyword2"><span class="keyword">else</span></span>
                <span class="entity">helper</span> <span class="main">(</span><span class="entity">x</span> :: filter_out <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">y</span> <span class="main">=&gt;</span> <span class="entity">comp</span> <span class="entity">x</span> <span class="entity">y</span><span class="main">)</span> <span class="entity">taken</span><span class="main">)</span> <span class="entity">xs</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">helper</span> <span class="main">[</span><span class="main">]</span> <span class="entity">lst</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Return all subsets of lst. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">subsets</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="main">[</span><span class="main">]</span><span class="main">]</span>
  <span class="main">|</span> <span class="entity">subsets</span> <span class="main">(</span><span class="entity">l</span>::<span class="entity">ls</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prev</span> <span class="main">=</span> <span class="entity">subsets</span> <span class="entity">ls</span> <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">prev</span> @ map <span class="main">(</span>cons <span class="entity">l</span><span class="main">)</span> <span class="entity">prev</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* List of all permutations of xs *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">all_permutes</span> <span class="entity">xs</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">xs</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="main">[</span><span class="main">]</span><span class="main">]</span>
      <span class="main">|</span> <span class="main">[</span><span class="entity">x</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="main">[</span><span class="entity">x</span><span class="main">]</span><span class="main">]</span>
      <span class="main">|</span> <span class="main">[</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="main">[</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="entity">y</span><span class="main">,</span> <span class="entity">x</span><span class="main">]</span><span class="main">]</span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span>
        maps <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">i</span> <span class="main">=&gt;</span> map <span class="main">(</span>cons <span class="main">(</span>nth <span class="entity">xs</span> <span class="entity">i</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="entity">all_permutes</span> <span class="main">(</span>nth_drop <span class="entity">i</span> <span class="entity">xs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
             <span class="main">(</span><span class="inner_numeral">0</span> upto <span class="main">(</span>length <span class="entity">xs</span> - <span class="inner_numeral">1</span><span class="main">)</span><span class="main">)</span>

<span class="comment1">(* Convert list to pair. List must consist of exactly two items. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">the_pair</span> <span class="entity">lst</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">lst</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="main">[</span><span class="entity">i1</span><span class="main">,</span> <span class="entity">i2</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">i1</span><span class="main">,</span> <span class="entity">i2</span><span class="main">)</span>
              <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"the_pair"</span>

<span class="comment1">(* Convert list to triple. List must consist of exactly three items. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">the_triple</span> <span class="entity">lst</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">lst</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="main">[</span><span class="entity">i1</span><span class="main">,</span> <span class="entity">i2</span><span class="main">,</span> <span class="entity">i3</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">i1</span><span class="main">,</span> <span class="entity">i2</span><span class="main">,</span> <span class="entity">i3</span><span class="main">)</span>
              <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"the_triple"</span>

<span class="comment1">(* Split list into (ins, outs), where ins satisfy f, and outs don't. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">filter_split</span> <span class="main">_</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">filter_split</span> <span class="entity">f</span> <span class="main">(</span><span class="entity">x</span> :: <span class="entity">xs</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">ins</span><span class="main">,</span> <span class="entity">outs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">filter_split</span> <span class="entity">f</span> <span class="entity">xs</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">f</span> <span class="entity">x</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="entity">x</span> :: <span class="entity">ins</span><span class="main">,</span> <span class="entity">outs</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="entity">ins</span><span class="main">,</span> <span class="entity">x</span> :: <span class="entity">outs</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Form the Cartesian product of two lists. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">all_pairs</span> <span class="main">(</span><span class="entity">l1</span><span class="main">,</span> <span class="entity">l2</span><span class="main">)</span> <span class="main">=</span>
    maps <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">y</span> <span class="main">=&gt;</span> <span class="main">(</span>map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span><span class="main">)</span> <span class="entity">l1</span><span class="main">)</span><span class="main">)</span> <span class="entity">l2</span>

<span class="comment1">(* Given two sorted lists, remove all pairs of terms that appear in
   both lists, counting multiplicity.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">remove_dup_lists</span> <span class="entity">ord</span> <span class="main">(</span><span class="entity">xs</span><span class="main">,</span> <span class="entity">ys</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">xs</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">ys</span><span class="main">)</span>
     <span class="main">|</span> <span class="entity">x</span> :: <span class="entity">xs'</span> <span class="main">=&gt;</span>
       <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">ys</span> <span class="keyword2"><span class="keyword">of</span></span>
           <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">xs</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
         <span class="main">|</span> <span class="entity">y</span> :: <span class="entity">ys'</span> <span class="main">=&gt;</span>
           <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">ord</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
               LESS <span class="main">=&gt;</span> apfst <span class="main">(</span>cons <span class="entity">x</span><span class="main">)</span> <span class="main">(</span><span class="entity">remove_dup_lists</span> <span class="entity">ord</span> <span class="main">(</span><span class="entity">xs'</span><span class="main">,</span> <span class="entity">ys</span><span class="main">)</span><span class="main">)</span>
             <span class="main">|</span> EQUAL <span class="main">=&gt;</span> <span class="entity">remove_dup_lists</span> <span class="entity">ord</span> <span class="main">(</span><span class="entity">xs'</span><span class="main">,</span> <span class="entity">ys'</span><span class="main">)</span>
             <span class="main">|</span> GREATER <span class="main">=&gt;</span> apsnd <span class="main">(</span>cons <span class="entity">y</span><span class="main">)</span> <span class="main">(</span><span class="entity">remove_dup_lists</span> <span class="entity">ord</span> <span class="main">(</span><span class="entity">xs</span><span class="main">,</span> <span class="entity">ys'</span><span class="main">)</span><span class="main">)</span>

<span class="comment1">(* Whether l1 is a subsequence of l2. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_subseq</span> <span class="entity">eq</span> <span class="main">(</span><span class="entity">l1</span><span class="main">,</span> <span class="entity">l2</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">l1</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> true
      <span class="main">|</span> <span class="entity">x</span> :: <span class="entity">l1'</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">l2</span> <span class="keyword2"><span class="keyword">of</span></span>
            <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> false
          <span class="main">|</span> <span class="entity">y</span> :: <span class="entity">l2'</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">eq</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">is_subseq</span> <span class="entity">eq</span> <span class="main">(</span><span class="entity">l1'</span><span class="main">,</span> <span class="entity">l2'</span><span class="main">)</span>
                        <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">is_subseq</span> <span class="entity">eq</span> <span class="main">(</span><span class="entity">l1</span><span class="main">,</span> <span class="entity">l2'</span><span class="main">)</span>

<span class="comment1">(* Whether pre is a prefix of str. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_prefix_str</span> <span class="entity">pre</span> <span class="entity">str</span> <span class="main">=</span>
    is_prefix <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="main">(</span>String.explode <span class="entity">pre</span><span class="main">)</span> <span class="main">(</span>String.explode <span class="entity">str</span><span class="main">)</span>

<span class="comment1">(* Test whether x is followed by exactly one _. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_just_internal</span> <span class="entity">x</span> <span class="main">=</span>
    Name.is_internal <span class="entity">x</span> <span class="keyword1"><span class="keyword">andalso</span></span> not <span class="main">(</span>Name.is_skolem <span class="entity">x</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fo_init</span> <span class="main">=</span> <span class="main">(</span>Vartab.empty<span class="main">,</span> Vartab.empty<span class="main">)</span>

<span class="comment1">(* Lookup a Vartab inst with string and integer specifying indexname. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">defined_instn</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span> <span class="main">(</span><span class="entity">str</span><span class="main">,</span> <span class="entity">n</span><span class="main">)</span> <span class="main">=</span> Vartab.defined <span class="entity">inst</span> <span class="main">(</span><span class="entity">str</span><span class="main">,</span> <span class="entity">n</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">lookup_instn</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span> <span class="main">(</span><span class="entity">str</span><span class="main">,</span> <span class="entity">n</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> Vartab.lookup <span class="entity">inst</span> <span class="main">(</span><span class="entity">str</span><span class="main">,</span> <span class="entity">n</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
        NONE <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="main">(</span><span class="inner_quoted">"lookup_inst: not found "</span> ^ <span class="entity">str</span> ^
                            <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">n</span> <span class="main">=</span> <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="inner_quoted">""</span> <span class="keyword2"><span class="keyword">else</span></span> string_of_int <span class="entity">n</span><span class="main">)</span><span class="main">)</span>
      <span class="main">|</span> SOME <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">u</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">u</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">lookup_inst</span> <span class="main">(</span><span class="entity">tyinst</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span> <span class="entity">str</span> <span class="main">=</span> <span class="entity">lookup_instn</span> <span class="main">(</span><span class="entity">tyinst</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span> <span class="main">(</span><span class="entity">str</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">lookup_tyinst</span> <span class="main">(</span><span class="entity">tyinst</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="entity">str</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> Vartab.lookup <span class="entity">tyinst</span> <span class="main">(</span><span class="entity">str</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
        NONE <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="main">(</span><span class="inner_quoted">"lookup_tyinst: not found "</span> ^ <span class="entity">str</span><span class="main">)</span>
      <span class="main">|</span> SOME <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">T</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">update_env</span> <span class="main">(</span><span class="entity">idx</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span> <span class="main">(</span><span class="entity">tyenv</span><span class="main">,</span> <span class="entity">tenv</span><span class="main">)</span> <span class="main">=</span>
    <span class="main">(</span><span class="entity">tyenv</span><span class="main">,</span> <span class="entity">tenv</span> |&gt; Vartab.update_new <span class="main">(</span><span class="entity">idx</span><span class="main">,</span> <span class="main">(</span>type_of <span class="entity">t</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

<span class="comment1">(* A rough comparison, simply compare the corresponding terms. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">eq_env</span> <span class="main">(</span><span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">inst1</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">inst2</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">data1</span> <span class="main">=</span> Vartab.dest <span class="entity">inst1</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">data2</span> <span class="main">=</span> Vartab.dest <span class="entity">inst2</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">compare_data</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">i</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">ty</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">(</span><span class="entity">x'</span><span class="main">,</span> <span class="entity">i'</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">ty'</span><span class="main">,</span> <span class="entity">t'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
          <span class="entity">x</span> <span class="main">=</span> <span class="entity">x'</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">i</span> <span class="main">=</span> <span class="entity">i'</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">ty</span> <span class="main">=</span> <span class="entity">ty'</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">t</span> aconv <span class="entity">t'</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      eq_set <span class="entity">compare_data</span> <span class="main">(</span><span class="entity">data1</span><span class="main">,</span> <span class="entity">data2</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">first_order_match_list</span> <span class="entity">thy</span> <span class="entity">pairs</span> <span class="entity">inst</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">pairs</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="entity">inst</span>
      <span class="main">|</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">u</span><span class="main">)</span> :: <span class="entity">rest</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inst'</span> <span class="main">=</span> Pattern.first_order_match <span class="entity">thy</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">u</span><span class="main">)</span> <span class="entity">inst</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="entity">first_order_match_list</span> <span class="entity">thy</span> <span class="entity">rest</span> <span class="entity">inst'</span>
        <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">string_of_terms</span> <span class="entity">ctxt</span> <span class="entity">ts</span> <span class="main">=</span>
    <span class="entity">ts</span> |&gt; map <span class="main">(</span>Syntax.pretty_term <span class="entity">ctxt</span><span class="main">)</span>
       |&gt; Pretty.commas |&gt; Pretty.block |&gt; Pretty.string_of
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">string_of_terms_global</span> <span class="entity">thy</span> <span class="entity">ts</span> <span class="main">=</span>
    <span class="entity">ts</span> |&gt; map <span class="main">(</span>Syntax.pretty_term_global <span class="entity">thy</span><span class="main">)</span>
       |&gt; Pretty.commas |&gt; Pretty.block |&gt; Pretty.string_of

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pretty_helper</span> <span class="entity">aux</span> <span class="entity">env</span> <span class="main">=</span>
    <span class="entity">env</span> |&gt; Vartab.dest
        |&gt; map <span class="entity">aux</span>
        |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">s1</span><span class="main">,</span> <span class="entity">s2</span><span class="main">)</span> <span class="main">=&gt;</span> Pretty.block <span class="main">[</span><span class="entity">s1</span><span class="main">,</span> Pretty.str <span class="inner_quoted">" := "</span><span class="main">,</span> <span class="entity">s2</span><span class="main">]</span><span class="main">)</span>
        |&gt; Pretty.enum <span class="inner_quoted">","</span> <span class="inner_quoted">"["</span> <span class="inner_quoted">"]"</span>
        |&gt; Pretty.string_of

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">string_of_tyenv</span> <span class="entity">ctxt</span> <span class="entity">tyenv</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_typs</span> <span class="main">(</span><span class="entity">v</span><span class="main">,</span> <span class="main">(</span><span class="entity">s</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>TVar <span class="main">(</span><span class="entity">v</span><span class="main">,</span> <span class="entity">s</span><span class="main">)</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">print</span> <span class="main">=</span> apply2 <span class="main">(</span>Syntax.pretty_typ <span class="entity">ctxt</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">pretty_helper</span> <span class="main">(</span><span class="entity">print</span> o <span class="entity">get_typs</span><span class="main">)</span> <span class="entity">tyenv</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">string_of_env</span> <span class="entity">ctxt</span> <span class="entity">env</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_ts</span> <span class="main">(</span><span class="entity">v</span><span class="main">,</span> <span class="main">(</span><span class="entity">T</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Var <span class="main">(</span><span class="entity">v</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">print</span> <span class="main">=</span> apply2 <span class="main">(</span>Syntax.pretty_term <span class="entity">ctxt</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">pretty_helper</span> <span class="main">(</span><span class="entity">print</span> o <span class="entity">get_ts</span><span class="main">)</span> <span class="entity">env</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">string_of_list</span> <span class="entity">func</span> <span class="entity">lst</span> <span class="main">=</span>
    Pretty.str_list <span class="inner_quoted">"["</span> <span class="inner_quoted">"]"</span> <span class="main">(</span>map <span class="entity">func</span> <span class="entity">lst</span><span class="main">)</span> |&gt; Pretty.string_of
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">string_of_list'</span> <span class="entity">func</span> <span class="entity">lst</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> length <span class="entity">lst</span> <span class="main">=</span> <span class="inner_numeral">1</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">func</span> <span class="main">(</span>the_single <span class="entity">lst</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">string_of_list</span> <span class="entity">func</span> <span class="entity">lst</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">string_of_bool</span> <span class="entity">b</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">b</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="inner_quoted">"true"</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="inner_quoted">"false"</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">trace_t</span> <span class="entity">ctxt</span> <span class="entity">s</span> <span class="entity">t</span> <span class="main">=</span>
    tracing <span class="main">(</span><span class="entity">s</span> ^ <span class="inner_quoted">" "</span> ^ <span class="main">(</span>Syntax.string_of_term <span class="entity">ctxt</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">trace_tlist</span> <span class="entity">ctxt</span> <span class="entity">s</span> <span class="entity">ts</span> <span class="main">=</span>
    tracing <span class="main">(</span><span class="entity">s</span> ^ <span class="inner_quoted">" "</span> ^ <span class="main">(</span><span class="entity">string_of_terms</span> <span class="entity">ctxt</span> <span class="entity">ts</span><span class="main">)</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">trace_thm</span> <span class="entity">ctxt</span> <span class="entity">s</span> <span class="entity">th</span> <span class="main">=</span>
    tracing <span class="main">(</span><span class="entity">s</span> ^ <span class="inner_quoted">" "</span> ^ <span class="main">(</span><span class="entity">th</span> |&gt; Thm.prop_of |&gt; Syntax.string_of_term <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">trace_fullthm</span> <span class="entity">ctxt</span> <span class="entity">s</span> <span class="entity">th</span> <span class="main">=</span>
    tracing <span class="main">(</span><span class="entity">s</span> ^ <span class="inner_quoted">" ["</span> ^ <span class="main">(</span>Thm.hyps_of <span class="entity">th</span> |&gt; <span class="entity">string_of_terms</span> <span class="entity">ctxt</span><span class="main">)</span> ^
             <span class="inner_quoted">"] ==&gt; "</span> ^ <span class="main">(</span>Thm.prop_of <span class="entity">th</span> |&gt; Syntax.string_of_term <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">trace_thm_global</span> <span class="entity">s</span> <span class="entity">th</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Thm.theory_of_thm <span class="entity">th</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      tracing <span class="main">(</span><span class="entity">s</span> ^ <span class="inner_quoted">" "</span> ^ <span class="main">(</span><span class="entity">th</span> |&gt; Thm.prop_of |&gt; Syntax.string_of_term_global <span class="entity">thy</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">trace_fullthm_global</span> <span class="entity">s</span> <span class="entity">th</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Thm.theory_of_thm <span class="entity">th</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      tracing <span class="main">(</span><span class="entity">s</span> ^ <span class="inner_quoted">" ["</span> ^ <span class="main">(</span>Thm.hyps_of <span class="entity">th</span> |&gt; <span class="entity">string_of_terms_global</span> <span class="entity">thy</span><span class="main">)</span> ^
               <span class="inner_quoted">"] ==&gt; "</span> ^ <span class="main">(</span>Thm.prop_of <span class="entity">th</span> |&gt; Syntax.string_of_term_global <span class="entity">thy</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">declare_free_term</span> <span class="entity">t</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span>is_Free <span class="entity">t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"declare_free_term: t not free."</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">ctxt</span> |&gt; Variable.add_fixes_direct <span class="main">[</span><span class="entity">t</span> |&gt; Term.dest_Free |&gt; fst<span class="main">]</span>
              |&gt; Variable.declare_term <span class="entity">t</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_abs</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span> Abs <span class="main">_</span> <span class="main">=&gt;</span> true <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false

<span class="comment1">(* Whether a given term is of the form A ==&gt; B. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_implies</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span>fastype_of <span class="entity">t</span> <span class="main">=</span> <span class="entity">propT</span><span class="main">)</span> <span class="inner_quoted">"is_implies: wrong type"</span>
    <span class="keyword2"><span class="keyword">in</span></span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> Pure.imp<span class="antiquote">}</span></span> $ <span class="main">_</span> $ <span class="main">_</span> <span class="main">=&gt;</span> true
               <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Extract the last two arguments on t, collecting the rest into f. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_binop</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="entity">f</span> $ <span class="entity">a</span> $ <span class="entity">b</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">f</span><span class="main">,</span> <span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="entity">b</span><span class="main">)</span><span class="main">)</span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"dest_binop"</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_binop_head</span> <span class="entity">t</span> <span class="main">=</span> fst <span class="main">(</span><span class="entity">dest_binop</span> <span class="entity">t</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_binop_args</span> <span class="entity">t</span> <span class="main">=</span> snd <span class="main">(</span><span class="entity">dest_binop</span> <span class="entity">t</span><span class="main">)</span>

<span class="comment1">(* Return the argument of t. If t is f applied to multiple arguments,
   return the last argument.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_arg</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="main">_</span> $ <span class="entity">arg</span> <span class="main">=&gt;</span> <span class="entity">arg</span> <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"dest_arg"</span>

<span class="comment1">(* Return the first of two arguments of t. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_arg1</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="main">_</span> $ <span class="entity">arg1</span> $ <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">arg1</span> <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"dest_arg1"</span>

<span class="comment1">(* Return the list of all arguments of t. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_args</span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">t</span> |&gt; Term.strip_comb |&gt; snd

<span class="comment1">(* Return the nth argument of t, counting from left and starting at zero. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_argn</span> <span class="entity">n</span> <span class="entity">t</span> <span class="main">=</span> nth <span class="main">(</span><span class="entity">dest_args</span> <span class="entity">t</span><span class="main">)</span> <span class="entity">n</span>

<span class="comment1">(* Return the name of the head function. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_head_name</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> Term.head_of <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
        Const <span class="main">(</span><span class="entity">nm</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">nm</span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"get_head_name"</span>

<span class="comment1">(* Whether the term is of the form A == B. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_meta_eq</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span>fastype_of <span class="entity">t</span> <span class="main">=</span> <span class="entity">propT</span><span class="main">)</span> <span class="inner_quoted">"is_meta_eq_term: wrong type"</span>
    <span class="keyword2"><span class="keyword">in</span></span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Pure.eq<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="main">_</span> $ <span class="main">_</span> <span class="main">=&gt;</span> true
               <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Given free variable freevar (or a list of free variables freevars),
   determine whether any of the inputs appears in t.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">occurs_frees</span> <span class="entity">freevars</span> <span class="entity">t</span> <span class="main">=</span>
    inter <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv<span class="main">)</span> <span class="main">(</span>map Free <span class="main">(</span>Term.add_frees <span class="entity">t</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="entity">freevars</span> &lt;&gt; <span class="main">[</span><span class="main">]</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">occurs_free</span> <span class="entity">freevar</span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">occurs_frees</span> <span class="main">[</span><span class="entity">freevar</span><span class="main">]</span> <span class="entity">t</span>

<span class="comment1">(* Whether the given term contains schematic variables. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">has_vars</span> <span class="entity">t</span> <span class="main">=</span> length <span class="main">(</span>Term.add_vars <span class="entity">t</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> &gt; <span class="inner_numeral">0</span>

<span class="comment1">(* Whether subt is a subterm of t. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_subterm</span> <span class="entity">subt</span> <span class="entity">t</span> <span class="main">=</span> exists_subterm <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t'</span> <span class="main">=&gt;</span> <span class="entity">t'</span> aconv <span class="entity">subt</span><span class="main">)</span> <span class="entity">t</span>

<span class="comment1">(* Whether any of subts is a subterm of t. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">has_subterm</span> <span class="entity">subts</span> <span class="entity">t</span> <span class="main">=</span> exists_subterm <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t'</span> <span class="main">=&gt;</span> member <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv<span class="main">)</span> <span class="entity">subts</span> <span class="entity">t'</span><span class="main">)</span> <span class="entity">t</span>

<span class="comment1">(* Whether s is a head term of t. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_head</span> <span class="entity">s</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">sf</span><span class="main">,</span> <span class="entity">sargs</span><span class="main">)</span> <span class="main">=</span> Term.strip_comb <span class="entity">s</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">tf</span><span class="main">,</span> <span class="entity">targs</span><span class="main">)</span> <span class="main">=</span> Term.strip_comb <span class="entity">t</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">sf</span> aconv <span class="entity">tf</span> <span class="keyword1"><span class="keyword">andalso</span></span> is_prefix <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv<span class="main">)</span> <span class="entity">sargs</span> <span class="entity">targs</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* If stmt is P(t), return %t. P(t). *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">lambda_abstract</span> <span class="entity">t</span> <span class="entity">stmt</span> <span class="main">=</span> Term.lambda <span class="entity">t</span> <span class="main">(</span>Term.abstract_over <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">stmt</span><span class="main">)</span><span class="main">)</span>

<span class="comment1">(* A more general criterion for patterns. In combinations, any
   argument that is a pattern (in the more general sense) frees up
   checking for any functional schematic variables in that argument.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_pattern_list</span> <span class="entity">ts</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_funT</span> <span class="entity">T</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">T</span> <span class="keyword2"><span class="keyword">of</span></span> Type <span class="main">(</span><span class="inner_quoted">"fun"</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> true <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_fun_vars</span> <span class="entity">t</span> <span class="main">=</span> <span class="main">(</span>Term.add_vars <span class="entity">t</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
                               |&gt; filter <span class="main">(</span><span class="entity">is_funT</span> o snd<span class="main">)</span> |&gt; map Var

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">test_list</span> <span class="entity">exclude_vars</span> <span class="entity">ts</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">ts</span> <span class="keyword2"><span class="keyword">of</span></span>
              <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> true
            <span class="main">|</span> <span class="main">[</span><span class="entity">t</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="entity">test_term</span> <span class="entity">exclude_vars</span> <span class="entity">t</span>
            <span class="main">|</span> <span class="entity">t</span> :: <span class="entity">ts'</span> <span class="main">=&gt;</span>
              <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">test_term</span> <span class="entity">exclude_vars</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
                <span class="entity">test_list</span> <span class="main">(</span>merge <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv<span class="main">)</span> <span class="main">(</span><span class="entity">exclude_vars</span><span class="main">,</span> <span class="entity">get_fun_vars</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span> <span class="entity">ts'</span>
              <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">test_list</span> <span class="entity">exclude_vars</span> <span class="entity">ts'</span> <span class="keyword2"><span class="keyword">then</span></span>
                <span class="entity">test_term</span> <span class="main">(</span>distinct <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv<span class="main">)</span>
                                    <span class="main">(</span><span class="entity">exclude_vars</span> @ maps <span class="entity">get_fun_vars</span> <span class="entity">ts'</span><span class="main">)</span><span class="main">)</span> <span class="entity">t</span>
              <span class="keyword2"><span class="keyword">else</span></span> false

      <span class="keyword2"><span class="keyword">and</span></span> <span class="entity">test_term</span> <span class="entity">exclude_vars</span> <span class="entity">t</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
              Abs <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">t'</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">test_term</span> <span class="entity">exclude_vars</span> <span class="entity">t'</span>
            <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">head</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span> <span class="main">=</span> strip_comb <span class="entity">t</span> <span class="keyword2"><span class="keyword">in</span></span>
                     <span class="keyword2"><span class="keyword">if</span></span> is_Var <span class="entity">head</span> <span class="keyword2"><span class="keyword">then</span></span>
                       <span class="keyword2"><span class="keyword">if</span></span> member <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv<span class="main">)</span> <span class="entity">exclude_vars</span> <span class="entity">head</span> <span class="keyword2"><span class="keyword">then</span></span>
                         <span class="entity">test_list</span> <span class="entity">exclude_vars</span> <span class="entity">args</span>
                       <span class="keyword2"><span class="keyword">else</span></span>
                         forall is_Bound <span class="entity">args</span> <span class="keyword1"><span class="keyword">andalso</span></span>
                         not <span class="main">(</span>has_duplicates <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv<span class="main">)</span> <span class="entity">args</span><span class="main">)</span>
                     <span class="keyword2"><span class="keyword">else</span></span>
                       <span class="entity">test_list</span> <span class="entity">exclude_vars</span> <span class="entity">args</span>
                   <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">test_list</span> <span class="main">[</span><span class="main">]</span> <span class="entity">ts</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_pattern</span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">is_pattern_list</span> <span class="main">[</span><span class="entity">t</span><span class="main">]</span>

<span class="comment1">(* Push !!x to the right as much as possible. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">normalize_meta_all_imp_once</span> <span class="entity">ct</span> <span class="main">=</span>
    Conv.try_conv <span class="main">(</span>
      Conv.every_conv <span class="main">[</span>Conv.rewr_conv <span class="main">(</span>Thm.symmetric <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Pure.norm_hhf_eq<span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">,</span>
                       Conv.arg_conv <span class="entity">normalize_meta_all_imp_once</span><span class="main">]</span><span class="main">)</span> <span class="entity">ct</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">normalize_meta_all_imp</span> <span class="entity">ctxt</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Thm.term_of <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> Logic.is_all <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
        Conv.every_conv <span class="main">[</span>Conv.binder_conv <span class="main">(</span><span class="entity">normalize_meta_all_imp</span> o snd<span class="main">)</span> <span class="entity">ctxt</span><span class="main">,</span>
                         <span class="entity">normalize_meta_all_imp_once</span><span class="main">]</span> <span class="entity">ct</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_implies</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
        Conv.arg_conv <span class="main">(</span><span class="entity">normalize_meta_all_imp</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">ct</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        Conv.all_conv <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Rewrite A ==&gt; !!v_i. B to !!v_i. A ==&gt; B. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">swap_meta_imp_alls</span> <span class="entity">ctxt</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Thm.term_of <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_implies</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">andalso</span></span> Logic.is_all <span class="main">(</span><span class="entity">dest_arg</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
        Conv.every_conv <span class="main">[</span>Conv.rewr_conv <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Pure.norm_hhf_eq<span class="antiquote">}</span></span></span><span class="main">,</span>
                         Conv.binder_conv <span class="main">(</span><span class="entity">swap_meta_imp_alls</span> o snd<span class="main">)</span> <span class="entity">ctxt</span><span class="main">]</span> <span class="entity">ct</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        Conv.all_conv <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Normalize a horn clause into standard form !!v_i. A_i ==&gt; B. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">normalize_meta_horn</span> <span class="entity">ctxt</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Thm.term_of <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> Logic.is_all <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
        Conv.binder_conv <span class="main">(</span><span class="entity">normalize_meta_horn</span> o snd<span class="main">)</span> <span class="entity">ctxt</span> <span class="entity">ct</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_implies</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
        Conv.every_conv <span class="main">[</span>Conv.arg_conv <span class="main">(</span><span class="entity">normalize_meta_horn</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">,</span>
                         <span class="entity">swap_meta_imp_alls</span> <span class="entity">ctxt</span><span class="main">]</span> <span class="entity">ct</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        Conv.all_conv <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Deconstruct a horn clause !!v_i. A_i ==&gt; B into (v_i, (A_i, B)). *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">strip_meta_horn</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
        Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Pure.all<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ Abs <span class="main">(</span><span class="entity">abs</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">T</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">body</span><span class="main">)</span> <span class="main">=</span> Term.dest_abs <span class="entity">abs</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">var</span> <span class="main">=</span> Free <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">vars</span><span class="main">,</span> <span class="main">(</span><span class="entity">assums</span><span class="main">,</span> <span class="entity">concl</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">strip_meta_horn</span> <span class="entity">body</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="main">(</span><span class="entity">var</span> :: <span class="entity">vars</span><span class="main">,</span> <span class="main">(</span><span class="entity">assums</span><span class="main">,</span> <span class="entity">concl</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">end</span></span>
      <span class="main">|</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> Pure.imp<span class="antiquote">}</span></span> $ <span class="entity">P</span> $ <span class="entity">Q</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">vars</span><span class="main">,</span> <span class="main">(</span><span class="entity">assums</span><span class="main">,</span> <span class="entity">concl</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">strip_meta_horn</span> <span class="entity">Q</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="main">(</span><span class="entity">vars</span><span class="main">,</span> <span class="main">(</span><span class="entity">P</span> :: <span class="entity">assums</span><span class="main">,</span> <span class="entity">concl</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">end</span></span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">list_meta_horn</span> <span class="main">(</span><span class="entity">vars</span><span class="main">,</span> <span class="main">(</span><span class="entity">As</span><span class="main">,</span> <span class="entity">B</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
    <span class="main">(</span>Logic.list_implies <span class="main">(</span><span class="entity">As</span><span class="main">,</span> <span class="entity">B</span><span class="main">)</span><span class="main">)</span> |&gt; fold Logic.all <span class="main">(</span>rev <span class="entity">vars</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">to_internal_vars</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">vars</span><span class="main">,</span> <span class="entity">body</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">vars'</span> <span class="main">=</span> <span class="entity">vars</span> |&gt; map Term.dest_Free
                       |&gt; Variable.variant_frees <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span>
                       |&gt; map <span class="main">(</span>apfst Name.internal<span class="main">)</span>
                       |&gt; map Free
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">subst</span> <span class="main">=</span> <span class="entity">vars</span> ~~ <span class="entity">vars'</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">(</span><span class="entity">vars'</span><span class="main">,</span> subst_atomic <span class="entity">subst</span> <span class="entity">body</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rename_abs_term</span> <span class="entity">vars</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">vars</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="entity">t</span>
      <span class="main">|</span> <span class="entity">var</span> :: <span class="entity">rest</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> Term.dest_Free <span class="entity">var</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="entity">A</span> $ Abs <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">T1</span><span class="main">,</span> <span class="entity">body</span><span class="main">)</span> <span class="main">=&gt;</span>
                    <span class="entity">A</span> $ Abs <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">T1</span><span class="main">,</span> <span class="entity">rename_abs_term</span> <span class="entity">rest</span> <span class="entity">body</span><span class="main">)</span>
                  <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> error <span class="inner_quoted">"rename_abs_term"</span>
        <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">print_term_detail</span> <span class="entity">ctxt</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
        Const <span class="main">(</span><span class="entity">s</span><span class="main">,</span> <span class="entity">ty</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="inner_quoted">"Const ("</span> ^ <span class="entity">s</span> ^ <span class="inner_quoted">", "</span> ^ <span class="main">(</span>Syntax.string_of_typ <span class="entity">ctxt</span> <span class="entity">ty</span><span class="main">)</span>
      <span class="main">|</span> Free <span class="main">(</span><span class="entity">s</span><span class="main">,</span> <span class="entity">ty</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="inner_quoted">"Free ("</span> ^ <span class="entity">s</span> ^ <span class="inner_quoted">", "</span> ^ <span class="main">(</span>Syntax.string_of_typ <span class="entity">ctxt</span> <span class="entity">ty</span><span class="main">)</span> ^ <span class="inner_quoted">")"</span>
      <span class="main">|</span> Var <span class="main">(</span><span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">i</span><span class="main">)</span><span class="main">,</span> <span class="entity">ty</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="inner_quoted">"Var (("</span> ^ <span class="entity">x</span> ^ <span class="inner_quoted">", "</span> ^ <span class="main">(</span>string_of_int <span class="entity">i</span><span class="main">)</span> ^ <span class="inner_quoted">"), "</span> ^
                             <span class="main">(</span>Syntax.string_of_typ <span class="entity">ctxt</span> <span class="entity">ty</span><span class="main">)</span> ^ <span class="inner_quoted">")"</span>
      <span class="main">|</span> Bound <span class="entity">n</span> <span class="main">=&gt;</span> <span class="inner_quoted">"Bound "</span> ^ <span class="main">(</span>string_of_int <span class="entity">n</span><span class="main">)</span>
      <span class="main">|</span> Abs <span class="main">(</span><span class="entity">s</span><span class="main">,</span> <span class="entity">ty</span><span class="main">,</span> <span class="entity">b</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="inner_quoted">"Abs ("</span> ^ <span class="entity">s</span> ^ <span class="inner_quoted">", "</span> ^ <span class="main">(</span>Syntax.string_of_typ <span class="entity">ctxt</span> <span class="entity">ty</span><span class="main">)</span> ^
                          <span class="inner_quoted">", "</span> ^ <span class="main">(</span><span class="entity">print_term_detail</span> <span class="entity">ctxt</span> <span class="entity">b</span><span class="main">)</span> ^ <span class="inner_quoted">")"</span>
      <span class="main">|</span> <span class="entity">u</span> $ <span class="entity">v</span> <span class="main">=&gt;</span> <span class="inner_quoted">"("</span> ^ <span class="entity">print_term_detail</span> <span class="entity">ctxt</span> <span class="entity">u</span> ^ <span class="inner_quoted">") $ ("</span> ^
                 <span class="entity">print_term_detail</span> <span class="entity">ctxt</span> <span class="entity">v</span> ^ <span class="inner_quoted">")"</span>

<span class="comment1">(* Version for ct. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_cargs</span> <span class="entity">ct</span> <span class="main">=</span> <span class="entity">ct</span> |&gt; Drule.strip_comb |&gt; snd
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_binop_cargs</span> <span class="entity">ct</span> <span class="main">=</span> <span class="main">(</span>Thm.dest_arg1 <span class="entity">ct</span><span class="main">,</span> Thm.dest_arg <span class="entity">ct</span><span class="main">)</span>

<span class="comment1">(* Apply cv to nth argument of t, counting from right and starting at 0. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">arg_backn_conv</span> <span class="entity">n</span> <span class="entity">cv</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">n</span> <span class="main">=</span> <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span> Conv.arg_conv <span class="entity">cv</span> <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">else</span></span> Conv.fun_conv <span class="main">(</span><span class="entity">arg_backn_conv</span> <span class="main">(</span><span class="entity">n</span>-<span class="inner_numeral">1</span><span class="main">)</span> <span class="entity">cv</span><span class="main">)</span> <span class="entity">ct</span>

<span class="comment1">(* Apply cv to nth argument of t, counting from left and starting at 0. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">argn_conv</span> <span class="entity">n</span> <span class="entity">cv</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args_count</span> <span class="main">=</span> <span class="entity">ct</span> |&gt; Thm.term_of |&gt; <span class="entity">dest_args</span> |&gt; length
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span><span class="entity">n</span> &gt;= <span class="inner_numeral">0</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">n</span> &lt; <span class="entity">args_count</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">arg_backn_conv</span> <span class="main">(</span><span class="entity">args_count</span> - <span class="entity">n</span> - <span class="inner_numeral">1</span><span class="main">)</span> <span class="entity">cv</span> <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Given a head cterm f (function to be applied), and a list of
   equivalence theorems of arguments, produce an equivalent theorem
   for the overall term.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">comb_equiv</span> <span class="main">(</span><span class="entity">cf</span><span class="main">,</span> <span class="entity">arg_equivs</span><span class="main">)</span> <span class="main">=</span>
    Library.foldl <span class="main">(</span>uncurry Thm.combination<span class="main">)</span> <span class="main">(</span>Thm.reflexive <span class="entity">cf</span><span class="main">,</span> <span class="entity">arg_equivs</span><span class="main">)</span>

<span class="comment1">(* Retrive name of theorem. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">name_of_thm</span> <span class="entity">th</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> Thm.has_name_hint <span class="entity">th</span> <span class="keyword2"><span class="keyword">then</span></span> Thm.get_name_hint <span class="entity">th</span>
                     <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"name_of_thm: not found"</span>

<span class="comment1">(* Set the name of th to the name of ori_th, followed by suffix. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">update_name_of_thm</span> <span class="entity">ori_th</span> <span class="entity">suffix</span> <span class="entity">th</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> Thm.has_name_hint <span class="entity">ori_th</span> <span class="keyword2"><span class="keyword">then</span></span>
      <span class="entity">th</span> |&gt; Thm.put_name_hint <span class="main">(</span>Thm.get_name_hint <span class="entity">ori_th</span> ^ <span class="entity">suffix</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">th</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs_of</span> <span class="main">=</span> Thm.term_of o Thm.lhs_of
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs_of</span> <span class="main">=</span> Thm.term_of o Thm.rhs_of

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">assume_meta_eq</span> <span class="entity">thy</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span>
    Thm.assume <span class="main">(</span>Thm.global_cterm_of <span class="entity">thy</span> <span class="main">(</span>Logic.mk_equals <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">assume_thm</span> <span class="entity">ctxt</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> type_of <span class="entity">t</span> &lt;&gt; <span class="entity">propT</span> <span class="keyword2"><span class="keyword">then</span></span>
      <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"assume_thm: t is not of type prop"</span>
    <span class="keyword2"><span class="keyword">else</span></span> Thm.assume <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">t</span><span class="main">)</span>

<span class="comment1">(* Similar to Envir.subst_term. Apply an instantiation to a theorem. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">subst_thm_thy</span> <span class="entity">thy</span> <span class="main">(</span><span class="entity">tyinsts</span><span class="main">,</span> <span class="entity">insts</span><span class="main">)</span> <span class="entity">th</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_tyenv</span> <span class="main">(</span><span class="entity">v</span><span class="main">,</span> <span class="main">(</span><span class="entity">S</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
          <span class="main">(</span><span class="main">(</span><span class="entity">v</span><span class="main">,</span> <span class="entity">S</span><span class="main">)</span><span class="main">,</span> Thm.global_ctyp_of <span class="entity">thy</span> <span class="entity">T</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tys</span> <span class="main">=</span> map <span class="entity">process_tyenv</span> <span class="main">(</span>Vartab.dest <span class="entity">tyinsts</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_tenv</span> <span class="main">(</span><span class="entity">v</span><span class="main">,</span> <span class="main">(</span><span class="entity">T</span><span class="main">,</span> <span class="entity">u</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
          <span class="main">(</span><span class="main">(</span><span class="entity">v</span><span class="main">,</span> Envir.subst_type <span class="entity">tyinsts</span> <span class="entity">T</span><span class="main">)</span><span class="main">,</span> Thm.global_cterm_of <span class="entity">thy</span> <span class="entity">u</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ts</span> <span class="main">=</span> map <span class="entity">process_tenv</span> <span class="main">(</span>Vartab.dest <span class="entity">insts</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">th</span> |&gt; Drule.instantiate_normalize <span class="main">(</span><span class="entity">tys</span><span class="main">,</span> <span class="entity">ts</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">subst_thm</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">tyinsts</span><span class="main">,</span> <span class="entity">insts</span><span class="main">)</span> <span class="entity">th</span> <span class="main">=</span>
    <span class="entity">subst_thm_thy</span> <span class="main">(</span>Proof_Context.theory_of <span class="entity">ctxt</span><span class="main">)</span> <span class="main">(</span><span class="entity">tyinsts</span><span class="main">,</span> <span class="entity">insts</span><span class="main">)</span> <span class="entity">th</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">send_first_to_hyps</span> <span class="entity">th</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cprem</span> <span class="main">=</span> Thm.cprem_of <span class="entity">th</span> <span class="inner_numeral">1</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      Thm.implies_elim <span class="entity">th</span> <span class="main">(</span>Thm.assume <span class="entity">cprem</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">send_all_to_hyps</span> <span class="entity">th</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span>forall <span class="main">(</span>not o <span class="entity">has_vars</span><span class="main">)</span> <span class="main">(</span>Thm.prems_of <span class="entity">th</span><span class="main">)</span><span class="main">)</span>
                     <span class="inner_quoted">"send_all_to_hyps: schematic variables in hyps."</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      funpow <span class="main">(</span>Thm.nprems_of <span class="entity">th</span><span class="main">)</span> <span class="entity">send_first_to_hyps</span> <span class="entity">th</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Replace using subst the internal variables in th. This proceeds in
   several steps: first, pull any hypotheses of the theorem involving
   the replaced variables into statement of the theorem, perform the
   replacement (using forall_intr then forall_elim), finally return
   the hypotheses to their original place.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">subst_thm_atomic</span> <span class="entity">subst</span> <span class="entity">th</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">old_cts</span> <span class="main">=</span> map fst <span class="entity">subst</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">old_ts</span> <span class="main">=</span> map Thm.term_of <span class="entity">old_cts</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">new_cts</span> <span class="main">=</span> map snd <span class="entity">subst</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">chyps</span> <span class="main">=</span> filter <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ct</span> <span class="main">=&gt;</span> <span class="entity">has_subterm</span> <span class="entity">old_ts</span> <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span><span class="main">)</span>
                         <span class="main">(</span>Thm.chyps_of <span class="entity">th</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">th</span> |&gt; fold Thm.implies_intr <span class="entity">chyps</span>
         |&gt; fold Thm.forall_intr <span class="entity">old_cts</span>
         |&gt; fold Thm.forall_elim <span class="main">(</span>rev <span class="entity">new_cts</span><span class="main">)</span>
         |&gt; funpow <span class="main">(</span>length <span class="entity">chyps</span><span class="main">)</span> <span class="entity">send_first_to_hyps</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Substitution into terms used in auto2. Substitute types first and
   instantiate the types in the table of term instantiations. Also
   perform beta_norm at the end.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">subst_term_norm</span> <span class="main">(</span><span class="entity">tyinsts</span><span class="main">,</span> <span class="entity">insts</span><span class="main">)</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">inst_tenv</span> <span class="entity">tenv</span> <span class="main">=</span>
          <span class="entity">tenv</span> |&gt; Vartab.dest
               |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">ixn</span><span class="main">,</span> <span class="main">(</span><span class="entity">T</span><span class="main">,</span> <span class="entity">v</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span>
                          <span class="main">(</span><span class="entity">ixn</span><span class="main">,</span> <span class="main">(</span>Envir.subst_type <span class="entity">tyinsts</span> <span class="entity">T</span><span class="main">,</span> <span class="entity">v</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
               |&gt; Vartab.make
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">t</span> |&gt; Envir.subst_term_types <span class="entity">tyinsts</span>
        |&gt; Envir.subst_term <span class="main">(</span><span class="entity">tyinsts</span><span class="main">,</span> <span class="entity">inst_tenv</span> <span class="entity">insts</span><span class="main">)</span>
        |&gt; Envir.beta_norm
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Apply the conversion cv to the statement of th, yielding the
   equivalent theorem.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">apply_to_thm</span> <span class="entity">cv</span> <span class="entity">th</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq</span> <span class="main">=</span> <span class="entity">cv</span> <span class="main">(</span>Thm.cprop_of <span class="entity">th</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span> <span class="keyword2"><span class="keyword">if</span></span> Thm.is_reflexive <span class="entity">eq</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">th</span> <span class="keyword2"><span class="keyword">else</span></span> Thm.equal_elim <span class="entity">eq</span> <span class="entity">th</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Given th of form A == B, get th' of form B == A. *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">meta_sym</span> <span class="main">=</span> Thm.symmetric

<span class="comment1">(* Apply conv to rewrite the left hand side of th. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">apply_to_lhs</span> <span class="entity">cv</span> <span class="entity">th</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq</span> <span class="main">=</span> <span class="entity">cv</span> <span class="main">(</span>Thm.lhs_of <span class="entity">th</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span> <span class="keyword2"><span class="keyword">if</span></span> Thm.is_reflexive <span class="entity">eq</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">th</span> <span class="keyword2"><span class="keyword">else</span></span> Thm.transitive <span class="main">(</span><span class="entity">meta_sym</span> <span class="entity">eq</span><span class="main">)</span> <span class="entity">th</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Apply conv to rewrite the right hand side of th. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">apply_to_rhs</span> <span class="entity">cv</span> <span class="entity">th</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq</span> <span class="main">=</span> <span class="entity">cv</span> <span class="main">(</span>Thm.rhs_of <span class="entity">th</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span> <span class="keyword2"><span class="keyword">if</span></span> Thm.is_reflexive <span class="entity">eq</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">th</span> <span class="keyword2"><span class="keyword">else</span></span> Thm.transitive <span class="entity">th</span> <span class="entity">eq</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Using cv, rewrite the part of ct after stripping i premises. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">concl_conv_n</span> <span class="entity">i</span> <span class="entity">cv</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">i</span> <span class="main">=</span> <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">cv</span> <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span>Conv.arg_conv <span class="main">(</span><span class="entity">concl_conv_n</span> <span class="main">(</span><span class="entity">i</span>-<span class="inner_numeral">1</span><span class="main">)</span> <span class="entity">cv</span><span class="main">)</span><span class="main">)</span> <span class="entity">ct</span>

<span class="comment1">(* Rewrite part of ct after stripping all premises. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">concl_conv</span> <span class="entity">cv</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> Thm.term_of <span class="entity">ct</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> Pure.imp<span class="antiquote">}</span></span> $ <span class="main">_</span> $ <span class="main">_</span> <span class="main">=&gt;</span> Conv.arg_conv <span class="main">(</span><span class="entity">concl_conv</span> <span class="entity">cv</span><span class="main">)</span> <span class="entity">ct</span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">cv</span> <span class="entity">ct</span>

<span class="comment1">(* Given a list of theorems A = B, B = C, etc., apply
   Thm.transitive to get equality between start and end.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">transitive_list</span> <span class="entity">ths</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rev_transitive</span> <span class="entity">btoc</span> <span class="entity">atob</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">b</span><span class="main">,</span> <span class="entity">c</span><span class="main">)</span> <span class="main">=</span> <span class="entity">btoc</span> |&gt; Thm.cprop_of |&gt; Thm.dest_equals
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="entity">b'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">atob</span> |&gt; Thm.cprop_of |&gt; Thm.dest_equals
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">b</span> aconvc <span class="entity">b'</span> <span class="keyword2"><span class="keyword">then</span></span>
              <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">a</span> aconvc <span class="entity">b</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">btoc</span>
              <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">b</span> aconvc <span class="entity">c</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">atob</span>
              <span class="keyword2"><span class="keyword">else</span></span> Thm.transitive <span class="entity">atob</span> <span class="entity">btoc</span>
            <span class="keyword2"><span class="keyword">else</span></span>
              <span class="keyword2"><span class="keyword">let</span></span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">trace_thm_global</span> <span class="inner_quoted">"ths:"</span><span class="main">)</span> <span class="entity">ths</span>
              <span class="keyword2"><span class="keyword">in</span></span>
                <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"transitive_list: intermediate does not agree"</span>
              <span class="keyword2"><span class="keyword">end</span></span>
          <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">in</span></span>
      fold <span class="entity">rev_transitive</span> <span class="main">(</span>tl <span class="entity">ths</span><span class="main">)</span> <span class="main">(</span>hd <span class="entity">ths</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Skip to argument n times. For example, if applied to rewrite a
   proposition in implication form (==&gt; or --&gt;), it will skip the
   first n assumptions.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">skip_n_conv</span> <span class="entity">n</span> <span class="entity">cv</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">n</span> &lt;= <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">cv</span> <span class="keyword2"><span class="keyword">else</span></span> Conv.arg_conv <span class="main">(</span><span class="entity">skip_n_conv</span> <span class="main">(</span><span class="entity">n</span>-<span class="inner_numeral">1</span><span class="main">)</span> <span class="entity">cv</span><span class="main">)</span>

<span class="comment1">(* Given a term t, and pairs (a_i, eq_i), where a_i's are atomic
   subterms of t. Suppose the input is obtained by replacing each a_i
   by the left side of eq_i in t, obtain equality from t to the term
   obtained by replacing each a_i by the right side of eq_i in t.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pattern_rewr_conv</span> <span class="entity">t</span> <span class="entity">eq_ths</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
        Bound <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"pattern_rewr_conv: bound variable."</span>
      <span class="main">|</span> Abs <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"pattern_rewr_conv: abs not supported."</span>
      <span class="main">|</span> <span class="main">_</span> $ <span class="main">_</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">f</span><span class="main">,</span> <span class="entity">arg</span><span class="main">)</span> <span class="main">=</span> Term.strip_comb <span class="entity">t</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">f'</span><span class="main">,</span> <span class="entity">arg'</span><span class="main">)</span> <span class="main">=</span> Drule.strip_comb <span class="entity">ct</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span><span class="entity">f</span> aconv Thm.term_of <span class="entity">f'</span><span class="main">)</span>
                         <span class="inner_quoted">"pattern_rewr_conv: input does not match pattern."</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ths</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">ct</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">pattern_rewr_conv</span> <span class="entity">t</span> <span class="entity">eq_ths</span> <span class="entity">ct</span><span class="main">)</span>
                        <span class="main">(</span><span class="entity">arg</span> ~~ <span class="entity">arg'</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="entity">comb_equiv</span> <span class="main">(</span><span class="entity">f'</span><span class="main">,</span> <span class="entity">ths</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">end</span></span>
      <span class="main">|</span> Const <span class="main">_</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span><span class="entity">t</span> aconv Thm.term_of <span class="entity">ct</span><span class="main">)</span>
                         <span class="inner_quoted">"pattern_rewr_conv: input does not match pattern."</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          Conv.all_conv <span class="entity">ct</span>
        <span class="keyword2"><span class="keyword">end</span></span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span>  <span class="comment1">(* Free and Var cases *)</span>
        <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> AList.lookup <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv<span class="main">)</span> <span class="entity">eq_ths</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
             NONE <span class="main">=&gt;</span> Conv.all_conv <span class="entity">ct</span>
           <span class="main">|</span> SOME <span class="entity">eq_th</span> <span class="main">=&gt;</span>
             <span class="keyword2"><span class="keyword">let</span></span>
               <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span><span class="entity">lhs_of</span> <span class="entity">eq_th</span> aconv <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span><span class="main">)</span>
                              <span class="inner_quoted">"pattern_rewr_conv: wrong substitution."</span>
             <span class="keyword2"><span class="keyword">in</span></span>
               <span class="entity">eq_th</span>
             <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>

<span class="comment1">(* Given integer i, term b_i, and a term A = f(a_1, ..., a_n), produce
   the theorem a_i = b_i ==&gt; A = f(a_1, ..., b_i, ..., a_n).
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">eq_cong_th</span> <span class="entity">i</span> <span class="entity">bi</span> <span class="entity">A</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">cf</span><span class="main">,</span> <span class="entity">cargs</span><span class="main">)</span> <span class="main">=</span> Drule.strip_comb <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">A</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span><span class="entity">i</span> &lt; length <span class="entity">cargs</span><span class="main">)</span> <span class="inner_quoted">"eq_cong_th: i out of bounds."</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ai</span> <span class="main">=</span> Thm.term_of <span class="main">(</span>nth <span class="entity">cargs</span> <span class="entity">i</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq_i</span> <span class="main">=</span> <span class="entity">assume_meta_eq</span> <span class="entity">thy</span> <span class="main">(</span><span class="entity">ai</span><span class="main">,</span> <span class="entity">bi</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eqs</span> <span class="main">=</span> map Thm.reflexive <span class="main">(</span>take <span class="entity">i</span> <span class="entity">cargs</span><span class="main">)</span> @ <span class="main">[</span><span class="entity">eq_i</span><span class="main">]</span> @
                map Thm.reflexive <span class="main">(</span>drop <span class="main">(</span><span class="entity">i</span> + <span class="inner_numeral">1</span><span class="main">)</span> <span class="entity">cargs</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq_A</span> <span class="main">=</span> <span class="entity">comb_equiv</span> <span class="main">(</span><span class="entity">cf</span><span class="main">,</span> <span class="entity">eqs</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      Thm.implies_intr <span class="main">(</span>Thm.cprop_of <span class="entity">eq_i</span><span class="main">)</span> <span class="entity">eq_A</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Convert theorems of form !!x y. P x y into P ?x ?y (arbitrary
   number of quantifiers).
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">forall_elim_sch</span> <span class="entity">th</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> Thm.prop_of <span class="entity">th</span> <span class="keyword2"><span class="keyword">of</span></span>
        Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Pure.all<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ Abs <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">T</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">var_xs</span> <span class="main">=</span> map fst <span class="main">(</span>Term.add_var_names <span class="main">(</span>Thm.prop_of <span class="entity">th</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">x'</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> member <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">var_xs</span> <span class="entity">x</span> <span class="keyword2"><span class="keyword">then</span></span>
                     singleton <span class="main">(</span>Name.variant_list <span class="entity">var_xs</span><span class="main">)</span> <span class="entity">x</span>
                   <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">x</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Thm.theory_of_thm <span class="entity">th</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="entity">th</span> |&gt; Thm.forall_elim <span class="main">(</span>Thm.global_cterm_of <span class="entity">thy</span> <span class="main">(</span>Var <span class="main">(</span><span class="main">(</span><span class="entity">x'</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
             |&gt; <span class="entity">forall_elim_sch</span>
        <span class="keyword2"><span class="keyword">end</span></span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">th</span>

<span class="comment1">(* Given P of function type, produce P == %x. P x. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">reverse_eta_conv</span> <span class="entity">ctxt</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Thm.term_of <span class="entity">ct</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">argT</span> <span class="main">=</span> Term.domain_type <span class="main">(</span>fastype_of <span class="entity">t</span><span class="main">)</span>
                 <span class="keyword3"><span class="keyword">handle</span></span> Match <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> CTERM <span class="main">(</span><span class="inner_quoted">"reverse_eta_conv"</span><span class="main">,</span> <span class="main">[</span><span class="entity">ct</span><span class="main">]</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs</span> <span class="main">=</span> Abs <span class="main">(</span><span class="inner_quoted">"x"</span><span class="main">,</span> <span class="entity">argT</span><span class="main">,</span> <span class="entity">t</span> $ Bound <span class="inner_numeral">0</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq_th</span> <span class="main">=</span> Thm.eta_conversion <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">rhs</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">meta_sym</span> <span class="entity">eq_th</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Repeat cv exactly n times. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">repeat_n_conv</span> <span class="entity">n</span> <span class="entity">cv</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">n</span> <span class="main">=</span> <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span> Conv.all_conv <span class="entity">t</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="entity">cv</span> then_conv <span class="main">(</span><span class="entity">repeat_n_conv</span> <span class="main">(</span><span class="entity">n</span>-<span class="inner_numeral">1</span><span class="main">)</span> <span class="entity">cv</span><span class="main">)</span><span class="main">)</span> <span class="entity">t</span>

<span class="comment1">(* Generic function for testing a conv. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">test_conv</span> <span class="entity">ctxt</span> <span class="entity">cv</span> <span class="entity">err_str</span> <span class="main">(</span><span class="entity">str1</span><span class="main">,</span> <span class="entity">str2</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Proof_Context.read_term_pattern <span class="entity">ctxt</span> <span class="entity">str1</span><span class="main">,</span>
                      Proof_Context.read_term_pattern <span class="entity">ctxt</span> <span class="entity">str2</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th</span> <span class="main">=</span> <span class="entity">cv</span> <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">t1</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">t1</span> aconv <span class="main">(</span><span class="entity">lhs_of</span> <span class="entity">th</span><span class="main">)</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">t2</span> aconv <span class="main">(</span><span class="entity">rhs_of</span> <span class="entity">th</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_t</span> <span class="entity">ctxt</span> <span class="inner_quoted">"Input:"</span> <span class="entity">t1</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_t</span> <span class="entity">ctxt</span> <span class="inner_quoted">"Expected:"</span> <span class="entity">t2</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_t</span> <span class="entity">ctxt</span> <span class="inner_quoted">"Actual:"</span> <span class="main">(</span>Thm.prop_of <span class="entity">th</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="entity">err_str</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* term_pat and typ_pat, from Isabelle Cookbook. *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">term_pat_setup</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parser</span> <span class="main">=</span> Args.context -- Scan.lift Args.embedded_inner_syntax
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">term_pat</span> <span class="main">(</span><span class="entity">ctxt</span><span class="main">,</span> <span class="entity">str</span><span class="main">)</span> <span class="main">=</span>
          <span class="entity">str</span> |&gt; Proof_Context.read_term_pattern <span class="entity">ctxt</span>
              |&gt; ML_Syntax.print_term
              |&gt; ML_Syntax.atomic
    <span class="keyword2"><span class="keyword">in</span></span>
      ML_Antiquotation.inline <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">binding</span> "term_pat"<span class="antiquote">}</span></span></span> <span class="main">(</span><span class="entity">parser</span> &gt;&gt; <span class="entity">term_pat</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cterm_pat_setup</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parser</span> <span class="main">=</span> Args.context -- Scan.lift Args.embedded_inner_syntax
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">cterm_pat</span> <span class="main">(</span><span class="entity">ctxt</span><span class="main">,</span> <span class="entity">str</span><span class="main">)</span> <span class="main">=</span>
          <span class="entity">str</span> |&gt; Proof_Context.read_term_pattern <span class="entity">ctxt</span>
              |&gt; ML_Syntax.print_term
              |&gt; ML_Syntax.atomic
              |&gt; prefix <span class="inner_quoted">"Thm.cterm_of ML_context"</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      ML_Antiquotation.value <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">binding</span> "cterm_pat"<span class="antiquote">}</span></span></span> <span class="main">(</span><span class="entity">parser</span> &gt;&gt; <span class="entity">cterm_pat</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">type_pat_setup</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parser</span> <span class="main">=</span> Args.context -- Scan.lift Args.embedded_inner_syntax
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">typ_pat</span> <span class="main">(</span><span class="entity">ctxt</span><span class="main">,</span> <span class="entity">str</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt'</span> <span class="main">=</span> Proof_Context.set_mode Proof_Context.mode_schematic <span class="entity">ctxt</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="entity">str</span> |&gt; Syntax.read_typ <span class="entity">ctxt'</span>
                |&gt; ML_Syntax.print_typ
                |&gt; ML_Syntax.atomic
          <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">in</span></span>
      ML_Antiquotation.inline <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">binding</span> "typ_pat"<span class="antiquote">}</span></span></span> <span class="main">(</span><span class="entity">parser</span> &gt;&gt; <span class="entity">typ_pat</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Time the given function f : unit -&gt; 'a. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">timer</span> <span class="main">(</span><span class="entity">msg</span><span class="main">,</span> <span class="entity">f</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t_start</span> <span class="main">=</span> Timing.start <span class="main">(</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">res</span> <span class="main">=</span> <span class="entity">f</span> <span class="main">(</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t_end</span> <span class="main">=</span> Timing.result <span class="entity">t_start</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">(</span>writeln <span class="main">(</span><span class="entity">msg</span> ^ <span class="main">(</span>Timing.message <span class="entity">t_end</span><span class="main">)</span><span class="main">)</span><span class="main">;</span> <span class="entity">res</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* When exception is shown when running function f : unit -&gt; 'a, print
   stack trace.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">exn_trace</span> <span class="entity">f</span> <span class="main">=</span> Runtime.exn_trace <span class="entity">f</span>

<span class="keyword2"><span class="keyword">end</span></span>  <span class="comment1">(* structure Util. *)</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Basic_Util</span><span class="main">:</span> <span class="entity">BASIC_UTIL</span> <span class="main">=</span> <span class="entity">Util</span>
<span class="keyword3"><span class="keyword">open</span></span> <span class="entity">Basic_Util</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> Theory.setup <span class="main">(</span><span class="entity">Util.term_pat_setup</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> Theory.setup <span class="main">(</span><span class="entity">Util.cterm_pat_setup</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> Theory.setup <span class="main">(</span><span class="entity">Util.type_pat_setup</span><span class="main">)</span>
</pre>
</div><div id="files/AFP/Auto2_HOL/util_base.ML">
<div class="head">
<h1>File ‹$AFP/Auto2_HOL/util_base.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*
  File: util_base.ML
  Author: Bohua Zhan

  Defines the interface that an object logic has to meet to setup auto2.
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">BASIC_UTIL_BASE</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> boolT<span class="main">:</span> typ

  <span class="keyword1"><span class="keyword">val</span></span> dest_eq<span class="main">:</span> term <span class="main">-&gt;</span> term * term
  <span class="keyword1"><span class="keyword">val</span></span> cdest_eq<span class="main">:</span> cterm <span class="main">-&gt;</span> cterm * cterm
  <span class="keyword1"><span class="keyword">val</span></span> mk_eq<span class="main">:</span> term * term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> is_eq_term<span class="main">:</span> term <span class="main">-&gt;</span> bool

  <span class="keyword1"><span class="keyword">val</span></span> bFalse<span class="main">:</span> term
  <span class="keyword1"><span class="keyword">val</span></span> bTrue<span class="main">:</span> term
  <span class="keyword1"><span class="keyword">val</span></span> true_th<span class="main">:</span> thm
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">UTIL_BASE</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">include</span></span> <span class="entity">BASIC_UTIL_BASE</span>

  <span class="comment1">(* Types *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> mk_setT<span class="main">:</span> typ <span class="main">-&gt;</span> typ

  <span class="comment1">(* Terms *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> Trueprop_name<span class="main">:</span> string
  <span class="keyword1"><span class="keyword">val</span></span> Not_name<span class="main">:</span> string
  <span class="keyword1"><span class="keyword">val</span></span> Conj_name<span class="main">:</span> string
  <span class="keyword1"><span class="keyword">val</span></span> Disj_name<span class="main">:</span> string
  <span class="keyword1"><span class="keyword">val</span></span> Imp_name<span class="main">:</span> string
  <span class="keyword1"><span class="keyword">val</span></span> All_name<span class="main">:</span> string
  <span class="keyword1"><span class="keyword">val</span></span> Ex_name<span class="main">:</span> string
  <span class="keyword1"><span class="keyword">val</span></span> is_if<span class="main">:</span> term <span class="main">-&gt;</span> bool

  <span class="comment1">(* Cterms *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> cTrueprop<span class="main">:</span> cterm
  <span class="keyword1"><span class="keyword">val</span></span> cNot<span class="main">:</span> cterm
  <span class="keyword1"><span class="keyword">val</span></span> cConj<span class="main">:</span> cterm
  <span class="keyword1"><span class="keyword">val</span></span> cDisj<span class="main">:</span> cterm

  <span class="comment1">(* Theorems for equality *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> to_meta_eq_cv<span class="main">:</span> conv
  <span class="keyword1"><span class="keyword">val</span></span> to_obj_eq_cv<span class="main">:</span> conv
  <span class="keyword1"><span class="keyword">val</span></span> to_obj_eq_iff<span class="main">:</span> thm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> obj_sym_cv<span class="main">:</span> conv

  <span class="comment1">(* Theorems *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> iffD_th<span class="main">:</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> nn_create_th<span class="main">:</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> nn_cancel_th<span class="main">:</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> to_contra_form_th<span class="main">:</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> to_contra_form_th'<span class="main">:</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> atomize_imp_th<span class="main">:</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> atomize_all_th<span class="main">:</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> conjunct1_th<span class="main">:</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> conjunct2_th<span class="main">:</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> conjI_th<span class="main">:</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> or_intro1_th<span class="main">:</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> or_intro2_th<span class="main">:</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> iffD1_th<span class="main">:</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> iffD2_th<span class="main">:</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> inv_back_th<span class="main">:</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> sym_th<span class="main">:</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> exE_th'<span class="main">:</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> eq_True_th<span class="main">:</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> eq_True_inv_th<span class="main">:</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> disj_True1_th<span class="main">:</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> disj_True2_th<span class="main">:</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> ex_vardef_th<span class="main">:</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> imp_conv_disj_th<span class="main">:</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> de_Morgan_conj_th<span class="main">:</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> de_Morgan_disj_th<span class="main">:</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> not_ex_th<span class="main">:</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> not_all_th<span class="main">:</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> not_imp_th<span class="main">:</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> or_cancel1_th<span class="main">:</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> or_cancel2_th<span class="main">:</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> swap_all_disj_th<span class="main">:</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> swap_ex_conj_th<span class="main">:</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> all_trivial_th<span class="main">:</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> case_split_th<span class="main">:</span> thm

  <span class="comment1">(* Theorems for proofstep module *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> atomize_conjL_th<span class="main">:</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> backward_conv_th<span class="main">:</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> backward1_conv_th<span class="main">:</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> backward2_conv_th<span class="main">:</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> resolve_conv_th<span class="main">:</span> thm

  <span class="comment1">(* Other theorems *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> contra_triv_th<span class="main">:</span> thm

  <span class="comment1">(* AC for conj and disj *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> conj_assoc_th<span class="main">:</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> conj_commute_th<span class="main">:</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> disj_assoc_th<span class="main">:</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> disj_commute_th<span class="main">:</span> thm

  <span class="comment1">(* Member, Ball and Bex *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> Mem_name<span class="main">:</span> string
  <span class="keyword1"><span class="keyword">val</span></span> Ball_name<span class="main">:</span> string
  <span class="keyword1"><span class="keyword">val</span></span> Bex_name<span class="main">:</span> string
  <span class="keyword1"><span class="keyword">val</span></span> Bex_def_th<span class="main">:</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> Ball_def_th<span class="main">:</span> thm
<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="files/auto2_hol.ML">
<div class="head">
<h1>File ‹auto2_hol.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*
  File: auto2_hol.ML
  Author: Bohua Zhan

  Setup of auto2 for HOL.
*)</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">UtilBase</span> <span class="main">:</span> <span class="entity">UTIL_BASE</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="comment1">(* Types *)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">boolT</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">bool</span><span class="antiquote">}</span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mk_setT</span> <span class="main">=</span> <span class="entity">HOLogic.mk_setT</span>

<span class="comment1">(* Equality *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_eq</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
        Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> HOL.eq<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="entity">lhs</span> $ <span class="entity">rhs</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"dest_eq"</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">cdest_eq</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> Thm.term_of <span class="entity">ct</span> <span class="keyword2"><span class="keyword">of</span></span>
        Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> HOL.eq<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="main">_</span> $ <span class="main">_</span> <span class="main">=&gt;</span> <span class="main">(</span>Thm.dest_arg1 <span class="entity">ct</span><span class="main">,</span> Thm.dest_arg <span class="entity">ct</span><span class="main">)</span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"dest_eq"</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_eq</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">u</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">T</span> <span class="main">=</span> fastype_of <span class="entity">t</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> HOL.eq<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">T</span> --&gt; <span class="entity">T</span> --&gt; <span class="entity">boolT</span><span class="main">)</span> $ <span class="entity">t</span> $ <span class="entity">u</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_eq_term</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span>fastype_of <span class="entity">t</span> <span class="main">=</span> <span class="entity">boolT</span><span class="main">)</span> <span class="inner_quoted">"is_eq_term: wrong type"</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> HOL.eq<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="main">_</span> $ <span class="main">_</span> <span class="main">=&gt;</span> true
              <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Terms *)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">bTrue</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">True</span><span class="antiquote">}</span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">bFalse</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">False</span><span class="antiquote">}</span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Trueprop_name</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> HOL.Trueprop<span class="antiquote">}</span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Not_name</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> HOL.Not<span class="antiquote">}</span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Conj_name</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> HOL.conj<span class="antiquote">}</span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Disj_name</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> HOL.disj<span class="antiquote">}</span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Imp_name</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> HOL.implies<span class="antiquote">}</span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">All_name</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> HOL.All<span class="antiquote">}</span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Ex_name</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> HOL.Ex<span class="antiquote">}</span></span>

<span class="comment1">(* If expressions are treated differently. In a term "if a then b else
   c", only terms in "a" are considered in the proof state.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_if</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
        Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> If<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="main">_</span> $ <span class="main">_</span> $ <span class="main">_</span> <span class="main">=&gt;</span> true
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cTrueprop</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">cterm</span> <span class="quoted">Trueprop</span><span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cNot</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">cterm</span> <span class="quoted">Not</span><span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cConj</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">cterm</span> <span class="quoted">conj</span><span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cDisj</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">cterm</span> <span class="quoted">disj</span><span class="antiquote">}</span></span></span>

<span class="comment1">(* Theorems for equality *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">to_meta_eq_cv</span> <span class="main">=</span> Conv.rewr_conv <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> to_meta_eq<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">to_obj_eq_cv</span> <span class="main">=</span> Conv.rewr_conv <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> atomize_eq<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">to_obj_eq_iff</span> <span class="main">=</span> <span class="entity">apply_to_thm</span> <span class="main">(</span><span class="entity">Util.concl_conv</span> <span class="entity">to_obj_eq_cv</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">obj_sym_cv</span> <span class="main">=</span> Conv.rewr_conv <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> obj_sym<span class="antiquote">}</span></span></span>

<span class="comment1">(* Theorems *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">true_th</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> TrueI<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">iffD_th</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> iffD<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">nn_create_th</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> nn_create<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">nn_cancel_th</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> HOL.nnf_simps<span class="main">(</span>6<span class="main">)</span><span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">to_contra_form_th</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> to_contra_form<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">to_contra_form_th'</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> to_contra_form'<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">atomize_imp_th</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> atomize_imp<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">atomize_all_th</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> atomize_all<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">conjunct1_th</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> conjunct1<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">conjunct2_th</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> conjunct2<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">conjI_th</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> conjI<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">or_intro1_th</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> or_intro1<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">or_intro2_th</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> or_intro2<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">iffD1_th</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> iffD1<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">iffD2_th</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> iffD2<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inv_back_th</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> inv_backward<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sym_th</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> sym<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">exE_th'</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> exE'<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq_True_th</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> HOL.eqTrueI<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq_True_inv_th</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> HOL.eqTrueE<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">disj_True1_th</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> HOL.simp_thms<span class="main">(</span>30<span class="main">)</span><span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">disj_True2_th</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> HOL.simp_thms<span class="main">(</span>29<span class="main">)</span><span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ex_vardef_th</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> HOL.simp_thms<span class="main">(</span>37<span class="main">)</span><span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">imp_conv_disj_th</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> imp_conv_disj<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">de_Morgan_conj_th</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> de_Morgan_conj<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">de_Morgan_disj_th</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> de_Morgan_disj<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">not_ex_th</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> HOL.not_ex<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">not_all_th</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> HOL.not_all<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">not_imp_th</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> HOL.not_imp<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">or_cancel1_th</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> or_cancel1<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">or_cancel2_th</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> or_cancel2<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">swap_all_disj_th</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> swap_all_disj<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">swap_ex_conj_th</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> swap_ex_conj<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_trivial_th</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> HOL.simp_thms<span class="main">(</span>35<span class="main">)</span><span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">case_split_th</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> HOL.case_split<span class="antiquote">}</span></span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">atomize_conjL_th</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> HOL_Base.atomize_conjL<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">backward_conv_th</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> backward_conv<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">backward1_conv_th</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> backward1_conv<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">backward2_conv_th</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> backward2_conv<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">resolve_conv_th</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> resolve_conv<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">contra_triv_th</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> contra_triv<span class="antiquote">}</span></span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">conj_assoc_th</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> conj_assoc<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">conj_commute_th</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> conj_commute<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">disj_assoc_th</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> disj_assoc<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">disj_commute_th</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> disj_commute<span class="antiquote">}</span></span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Mem_name</span> <span class="main">=</span> <span class="inner_quoted">"Set.member"</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Ball_name</span> <span class="main">=</span> <span class="inner_quoted">"Set.Ball"</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Bex_name</span> <span class="main">=</span> <span class="inner_quoted">"Set.Bex"</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Bex_def_th</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Bex_def'<span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Ball_def_th</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Ball_def'<span class="antiquote">}</span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>  <span class="comment1">(* structure Base *)</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Basic_UtilBase</span><span class="main">:</span> <span class="entity">BASIC_UTIL_BASE</span> <span class="main">=</span> <span class="entity">UtilBase</span>
<span class="keyword3"><span class="keyword">open</span></span> <span class="entity">Basic_UtilBase</span>
</pre>
</div><div id="files/AFP/Auto2_HOL/util_logic.ML">
<div class="head">
<h1>File ‹$AFP/Auto2_HOL/util_logic.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*
  File: util_logic.ML
  Author: Bohua Zhan

  Utility functions, after fixing object logic.
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">BASIC_UTIL_LOGIC</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="comment1">(* Terms *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> Trueprop<span class="main">:</span> term
  <span class="keyword1"><span class="keyword">val</span></span> is_Trueprop<span class="main">:</span> term <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> mk_Trueprop<span class="main">:</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> dest_Trueprop<span class="main">:</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> Trueprop_conv<span class="main">:</span> conv <span class="main">-&gt;</span> conv
  <span class="keyword1"><span class="keyword">val</span></span> pFalse<span class="main">:</span> term
  <span class="keyword1"><span class="keyword">val</span></span> Not<span class="main">:</span> term
  <span class="keyword1"><span class="keyword">val</span></span> mk_not<span class="main">:</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> dest_not<span class="main">:</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> is_neg<span class="main">:</span> term <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> get_neg<span class="main">:</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> get_neg'<span class="main">:</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> conj<span class="main">:</span> term
  <span class="keyword1"><span class="keyword">val</span></span> is_conj<span class="main">:</span> term <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> mk_conj<span class="main">:</span> term * term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> strip_conj<span class="main">:</span> term <span class="main">-&gt;</span> term list
  <span class="keyword1"><span class="keyword">val</span></span> list_conj<span class="main">:</span> term list <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> disj<span class="main">:</span> term
  <span class="keyword1"><span class="keyword">val</span></span> is_disj<span class="main">:</span> term <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> mk_disj<span class="main">:</span> term * term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> strip_disj<span class="main">:</span> term <span class="main">-&gt;</span> term list
  <span class="keyword1"><span class="keyword">val</span></span> list_disj<span class="main">:</span> term list <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> imp<span class="main">:</span> term
  <span class="keyword1"><span class="keyword">val</span></span> is_imp<span class="main">:</span> term <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> mk_imp<span class="main">:</span> term * term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> dest_imp<span class="main">:</span> term <span class="main">-&gt;</span> term * term
  <span class="keyword1"><span class="keyword">val</span></span> strip_obj_imp<span class="main">:</span> term <span class="main">-&gt;</span> term list * term
  <span class="keyword1"><span class="keyword">val</span></span> list_obj_imp<span class="main">:</span> term list * term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> is_obj_all<span class="main">:</span> term <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> is_ball<span class="main">:</span> term <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> mk_obj_all<span class="main">:</span> term <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> is_ex<span class="main">:</span> term <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> is_bex<span class="main">:</span> term <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> mk_exists<span class="main">:</span> term <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> is_mem<span class="main">:</span> term <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> mk_mem<span class="main">:</span> term * term <span class="main">-&gt;</span> term

  <span class="comment1">(* Theorems *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> is_true_th<span class="main">:</span> thm <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> prop_of'<span class="main">:</span> thm <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> cprop_of'<span class="main">:</span> thm <span class="main">-&gt;</span> cterm
  <span class="keyword1"><span class="keyword">val</span></span> concl_of'<span class="main">:</span> thm <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> make_trueprop_eq<span class="main">:</span> thm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> assume_eq<span class="main">:</span> theory <span class="main">-&gt;</span> term * term <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> apply_to_thm'<span class="main">:</span> conv <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> to_meta_eq<span class="main">:</span> thm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> to_obj_eq<span class="main">:</span> thm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> obj_sym<span class="main">:</span> thm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> rewr_obj_eq<span class="main">:</span> thm <span class="main">-&gt;</span> conv

  <span class="keyword1"><span class="keyword">val</span></span> conj_left_th<span class="main">:</span> thm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> conj_right_th<span class="main">:</span> thm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> equiv_forward_th<span class="main">:</span> thm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> equiv_backward_th<span class="main">:</span> thm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> inv_backward_th<span class="main">:</span> thm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> to_obj_eq_th<span class="main">:</span> thm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> to_obj_eq_iff_th<span class="main">:</span> thm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> obj_sym_th<span class="main">:</span> thm <span class="main">-&gt;</span> thm
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">UTIL_LOGIC</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">include</span></span> <span class="entity">BASIC_UTIL_LOGIC</span>

  <span class="comment1">(* Terms *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> term_of_bool<span class="main">:</span> bool <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> bool_of_term<span class="main">:</span> term <span class="main">-&gt;</span> bool

  <span class="comment1">(* Finding subterms *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> list_subterms<span class="main">:</span> term <span class="main">-&gt;</span> term list
  <span class="keyword1"><span class="keyword">val</span></span> get_all_subterms<span class="main">:</span> term <span class="main">-&gt;</span> term list
  <span class="keyword1"><span class="keyword">val</span></span> get_all_subterms_skip_if<span class="main">:</span> term <span class="main">-&gt;</span> term list

  <span class="comment1">(* cterms *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_cneg<span class="main">:</span> cterm <span class="main">-&gt;</span> cterm

  <span class="comment1">(* Theorems *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> make_neg_eq<span class="main">:</span> thm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> rewrite_to_contra_form<span class="main">:</span> conv
  <span class="keyword1"><span class="keyword">val</span></span> rewrite_from_contra_form<span class="main">:</span> conv
  <span class="keyword1"><span class="keyword">val</span></span> to_obj_conv<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> conv
  <span class="keyword1"><span class="keyword">val</span></span> to_obj_conv_on_horn<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> conv
  <span class="keyword1"><span class="keyword">val</span></span> to_meta_conv<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> conv
  <span class="keyword1"><span class="keyword">val</span></span> split_conj_th<span class="main">:</span> thm <span class="main">-&gt;</span> thm list
  <span class="keyword1"><span class="keyword">val</span></span> split_conj_gen_th<span class="main">:</span> thm <span class="main">-&gt;</span> thm list
  <span class="keyword1"><span class="keyword">val</span></span> split_not_disj_th<span class="main">:</span> thm <span class="main">-&gt;</span> thm list
  <span class="keyword1"><span class="keyword">val</span></span> strip_horn'<span class="main">:</span> thm <span class="main">-&gt;</span> term list * term
  <span class="keyword1"><span class="keyword">val</span></span> mk_conjs_th<span class="main">:</span> thm list <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> ex_elim<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> force_abs_form<span class="main">:</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> strip_obj_horn<span class="main">:</span> term <span class="main">-&gt;</span> term list * <span class="main">(</span>term list * term<span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> list_obj_horn<span class="main">:</span> term list * <span class="main">(</span>term list * term<span class="main">)</span> <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> is_ex_form_gen<span class="main">:</span> term <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> normalize_exists<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> conv
  <span class="keyword1"><span class="keyword">val</span></span> strip_exists<span class="main">:</span> term <span class="main">-&gt;</span> term list * term

  <span class="comment1">(* Wrapper around common tactics. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> prove_by_tac<span class="main">:</span> <span class="main">(</span><span class="entity">Proof.context</span> <span class="main">-&gt;</span> int <span class="main">-&gt;</span> tactic<span class="main">)</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span>
                    thm list <span class="main">-&gt;</span> term <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> contra_by_tac<span class="main">:</span> <span class="main">(</span><span class="entity">Proof.context</span> <span class="main">-&gt;</span> int <span class="main">-&gt;</span> tactic<span class="main">)</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span>
                     thm list <span class="main">-&gt;</span> thm
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">UtilLogic</span> <span class="main">:</span> <span class="entity">UTIL_LOGIC</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="comment1">(* Booleans *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">term_of_bool</span> <span class="entity">b</span> <span class="main">=</span> <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">b</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">bTrue</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">bFalse</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">bool_of_term</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">t</span> aconv <span class="entity">bTrue</span> <span class="keyword2"><span class="keyword">then</span></span> true
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">t</span> aconv <span class="entity">bFalse</span> <span class="keyword2"><span class="keyword">then</span></span> false
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"bool_of_term: unexpected t."</span>

<span class="comment1">(* Trueprop *)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Trueprop</span> <span class="main">=</span> Const <span class="main">(</span><span class="entity">UtilBase.Trueprop_name</span><span class="main">,</span> <span class="entity">boolT</span> --&gt; <span class="entity">propT</span><span class="main">)</span>

<span class="comment1">(* Returns whether the given term is Trueprop. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_Trueprop</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span>fastype_of <span class="entity">t</span> <span class="main">=</span> <span class="entity">propT</span><span class="main">)</span> <span class="inner_quoted">"is_Trueprop: wrong type"</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span> Const <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">c</span> <span class="main">=</span> <span class="entity">UtilBase.Trueprop_name</span>
              <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_Trueprop</span> <span class="entity">P</span> <span class="main">=</span> <span class="entity">Trueprop</span> $ <span class="entity">P</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_Trueprop</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_Trueprop</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">dest_arg</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"dest_Trueprop"</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">Trueprop_conv</span> <span class="entity">cv</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_Trueprop</span> <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> Conv.arg_conv <span class="entity">cv</span> <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword3"><span class="keyword">raise</span></span> CTERM <span class="main">(</span><span class="inner_quoted">"Trueprop_conv"</span><span class="main">,</span> <span class="main">[</span><span class="entity">ct</span><span class="main">]</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pFalse</span> <span class="main">=</span> <span class="entity">Trueprop</span> $ <span class="entity">bFalse</span>

<span class="comment1">(* Not *)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Not</span> <span class="main">=</span> Const <span class="main">(</span><span class="entity">UtilBase.Not_name</span><span class="main">,</span> <span class="entity">boolT</span> --&gt; <span class="entity">boolT</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_not</span> <span class="entity">P</span> <span class="main">=</span> <span class="entity">Not</span> $ <span class="entity">P</span>

<span class="comment1">(* Returns whether the given term is in neg form. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_neg</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span>fastype_of <span class="entity">t</span> <span class="main">=</span> <span class="entity">boolT</span><span class="main">)</span> <span class="inner_quoted">"is_neg: wrong type"</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
          Const <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">c</span> <span class="main">=</span> <span class="entity">UtilBase.Not_name</span>
        <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_not</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_neg</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">dest_arg</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"dest_not"</span>

<span class="comment1">(* Returns the negation of the given term. Avoids double negatives. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_neg</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_neg</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">dest_not</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">Not</span> $ <span class="entity">t</span>

<span class="comment1">(* Version of get_neg for Trueprop terms. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_neg'</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span><span class="entity">is_Trueprop</span> <span class="entity">t</span><span class="main">)</span> <span class="inner_quoted">"get_neg': input should be a Trueprop."</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">t</span> |&gt; <span class="entity">dest_Trueprop</span> |&gt; <span class="entity">get_neg</span> |&gt; <span class="entity">mk_Trueprop</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Conjunction and disjunction *)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">conj</span> <span class="main">=</span> Const <span class="main">(</span><span class="entity">UtilBase.Conj_name</span><span class="main">,</span> <span class="entity">boolT</span> --&gt; <span class="entity">boolT</span> --&gt; <span class="entity">boolT</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_conj</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span> Const <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="main">_</span> $ <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">c</span> <span class="main">=</span> <span class="entity">UtilBase.Conj_name</span> <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_conj</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">u</span><span class="main">)</span> <span class="main">=</span> <span class="entity">conj</span> $ <span class="entity">t</span> $ <span class="entity">u</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">strip_conj</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_conj</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="entity">dest_arg1</span> <span class="entity">t</span><span class="main">)</span> :: <span class="entity">strip_conj</span> <span class="main">(</span><span class="entity">dest_arg</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="entity">t</span><span class="main">]</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">list_conj</span> <span class="entity">ts</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">ts</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> error <span class="inner_quoted">"list_conj"</span>
      <span class="main">|</span> <span class="main">[</span><span class="entity">t</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="entity">t</span>
      <span class="main">|</span> <span class="entity">t</span> :: <span class="entity">rest</span> <span class="main">=&gt;</span> <span class="entity">mk_conj</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">list_conj</span> <span class="entity">rest</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">disj</span> <span class="main">=</span> Const <span class="main">(</span><span class="entity">UtilBase.Disj_name</span><span class="main">,</span> <span class="entity">boolT</span> --&gt; <span class="entity">boolT</span> --&gt; <span class="entity">boolT</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_disj</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span> Const <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="main">_</span> $ <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">c</span> <span class="main">=</span> <span class="entity">UtilBase.Disj_name</span> <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_disj</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">u</span><span class="main">)</span> <span class="main">=</span> <span class="entity">disj</span> $ <span class="entity">t</span> $ <span class="entity">u</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">strip_disj</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_disj</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="entity">dest_arg1</span> <span class="entity">t</span><span class="main">)</span> :: <span class="entity">strip_disj</span> <span class="main">(</span><span class="entity">dest_arg</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="entity">t</span><span class="main">]</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">list_disj</span> <span class="entity">ts</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">ts</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"list_disj"</span>
      <span class="main">|</span> <span class="main">[</span><span class="entity">t</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="entity">t</span>
      <span class="main">|</span> <span class="entity">t</span> :: <span class="entity">ts'</span> <span class="main">=&gt;</span> <span class="entity">mk_disj</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">list_disj</span> <span class="entity">ts'</span><span class="main">)</span>

<span class="comment1">(* Object implication *)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">imp</span> <span class="main">=</span> Const <span class="main">(</span><span class="entity">UtilBase.Imp_name</span><span class="main">,</span> <span class="entity">boolT</span> --&gt; <span class="entity">boolT</span> --&gt; <span class="entity">boolT</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_imp</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span> Const <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="main">_</span> $ <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">c</span> <span class="main">=</span> <span class="entity">UtilBase.Imp_name</span> <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_imp</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">u</span><span class="main">)</span> <span class="main">=</span> <span class="entity">imp</span> $ <span class="entity">t</span> $ <span class="entity">u</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_imp</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_imp</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="entity">dest_arg1</span> <span class="entity">t</span><span class="main">,</span> <span class="entity">dest_arg</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"dest_imp"</span>

<span class="comment1">(* Given t of form A1 --&gt; ... --&gt; An, return ([A1, ..., A(n-1)], An). *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">strip_obj_imp</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_imp</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
      <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">As</span><span class="main">,</span> <span class="entity">B'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">strip_obj_imp</span> <span class="main">(</span><span class="entity">dest_arg</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">dest_arg1</span> <span class="entity">t</span> :: <span class="entity">As</span><span class="main">,</span> <span class="entity">B'</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">list_obj_imp</span> <span class="main">(</span><span class="entity">As</span><span class="main">,</span> <span class="entity">C</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">As</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="entity">C</span>
      <span class="main">|</span> <span class="entity">A</span> :: <span class="entity">rest</span> <span class="main">=&gt;</span> <span class="entity">mk_imp</span> <span class="main">(</span><span class="entity">A</span><span class="main">,</span> <span class="entity">list_obj_imp</span> <span class="main">(</span><span class="entity">rest</span><span class="main">,</span> <span class="entity">C</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_obj_all</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
        Const <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ Abs <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">c</span> <span class="main">=</span> <span class="entity">UtilBase.All_name</span> <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_ball</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
        Const <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="main">_</span> $ <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">c</span> <span class="main">=</span> <span class="entity">UtilBase.Ball_name</span> <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_obj_all</span> <span class="entity">t</span> <span class="entity">body</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="main">=</span> Term.dest_Free <span class="entity">t</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      Const <span class="main">(</span><span class="entity">UtilBase.All_name</span><span class="main">,</span> <span class="main">(</span><span class="entity">T</span> --&gt; <span class="entity">boolT</span><span class="main">)</span> --&gt; <span class="entity">boolT</span><span class="main">)</span> $ Term.absfree <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="entity">body</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_ex</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span> Const <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ Abs <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">c</span> <span class="main">=</span> <span class="entity">UtilBase.Ex_name</span> <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_bex</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span> Const <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="main">_</span> $ <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">c</span> <span class="main">=</span> <span class="entity">UtilBase.Bex_name</span> <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_exists</span> <span class="entity">t</span> <span class="entity">body</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="main">=</span> Term.dest_Free <span class="entity">t</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      Const <span class="main">(</span><span class="entity">UtilBase.Ex_name</span><span class="main">,</span> <span class="main">(</span><span class="entity">T</span> --&gt; <span class="entity">boolT</span><span class="main">)</span> --&gt; <span class="entity">boolT</span><span class="main">)</span> $ Term.absfree <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="entity">body</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_mem</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span> Const <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="main">_</span> $ <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">c</span> <span class="main">=</span> <span class="entity">UtilBase.Mem_name</span> <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_mem</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">A</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">T</span> <span class="main">=</span> fastype_of <span class="entity">x</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      Const <span class="main">(</span><span class="entity">UtilBase.Mem_name</span><span class="main">,</span> <span class="entity">T</span> --&gt; <span class="entity">UtilBase.mk_setT</span> <span class="entity">T</span> --&gt; <span class="entity">boolT</span><span class="main">)</span> $ <span class="entity">x</span> $ <span class="entity">A</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Finding subterms *)</span>

<span class="comment1">(* Get all subterms of t. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">list_subterms</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_at_head</span> <span class="entity">t</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
              Abs <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">body</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">dest_at_head</span> <span class="entity">body</span>
            <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">if</span></span> Term.is_open <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
                     <span class="entity">t</span> |&gt; Term.strip_comb |&gt; snd |&gt; maps <span class="entity">dest_at_head</span>
                   <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="entity">t</span><span class="main">]</span>

      <span class="keyword2"><span class="keyword">and</span></span> <span class="entity">dest</span> <span class="entity">t</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
              Abs <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">dest_at_head</span> <span class="entity">t</span>
            <span class="main">|</span> <span class="main">_</span> $ <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">t</span> |&gt; Term.strip_comb |&gt; snd
            <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">dest</span> <span class="entity">t</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* List all (closed) subterms. Larger ones will be listed first. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_all_subterms</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="entity">t</span> |&gt; <span class="entity">list_subterms</span> |&gt; maps <span class="entity">get_all_subterms</span> |&gt; distinct <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv<span class="main">)</span>
      |&gt; cons <span class="entity">t</span>

<span class="comment1">(* List all (closed) subterms. For terms of form if cond then yes or
   no, list only subterms of cond.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_all_subterms_skip_if</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">UtilBase.is_if</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
      <span class="entity">t</span> |&gt; <span class="entity">Util.dest_args</span> |&gt; hd |&gt; <span class="entity">get_all_subterms_skip_if</span> |&gt; cons <span class="entity">t</span>
    <span class="keyword2"><span class="keyword">else</span></span>
      <span class="entity">t</span> |&gt; <span class="entity">list_subterms</span> |&gt; maps <span class="entity">get_all_subterms_skip_if</span>
        |&gt; distinct <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv<span class="main">)</span> |&gt; cons <span class="entity">t</span>

<span class="comment1">(* cterms *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_cneg</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Thm.term_of <span class="entity">ct</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span>fastype_of <span class="entity">t</span> <span class="main">=</span> <span class="entity">boolT</span><span class="main">)</span> <span class="inner_quoted">"get_neg: wrong type"</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_neg</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span> Thm.dest_arg <span class="entity">ct</span> <span class="keyword2"><span class="keyword">else</span></span> Thm.apply <span class="entity">UtilBase.cNot</span> <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Theorems *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_true_th</span> <span class="entity">th</span> <span class="main">=</span> Thm.eq_thm_prop <span class="main">(</span><span class="entity">th</span><span class="main">,</span> <span class="entity">true_th</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prop_of'</span> <span class="entity">th</span> <span class="main">=</span> <span class="entity">dest_Trueprop</span> <span class="main">(</span>Thm.prop_of <span class="entity">th</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">cprop_of'</span> <span class="entity">th</span> <span class="main">=</span> Thm.dest_arg <span class="main">(</span>Thm.cprop_of <span class="entity">th</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">concl_of'</span> <span class="entity">th</span> <span class="main">=</span> <span class="entity">dest_Trueprop</span> <span class="main">(</span>Thm.concl_of <span class="entity">th</span><span class="main">)</span>

<span class="comment1">(* Given an equality between bools, make it an equality between props,
   by applying the function Trueprop to both sides.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">make_trueprop_eq</span> <span class="entity">th</span> <span class="main">=</span>
    Thm.combination <span class="main">(</span>Thm.reflexive <span class="entity">UtilBase.cTrueprop</span><span class="main">)</span> <span class="entity">th</span>

<span class="comment1">(* Assumed theorems. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">assume_eq</span> <span class="entity">thy</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span>
    Thm.assume <span class="main">(</span>Thm.global_cterm_of <span class="entity">thy</span> <span class="main">(</span><span class="entity">mk_Trueprop</span> <span class="main">(</span><span class="entity">mk_eq</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

<span class="comment1">(* Apply cv to the statement of th, skipping Trueprop. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">apply_to_thm'</span> <span class="entity">cv</span> <span class="entity">th</span> <span class="main">=</span> <span class="entity">apply_to_thm</span> <span class="main">(</span><span class="entity">Trueprop_conv</span> <span class="entity">cv</span><span class="main">)</span> <span class="entity">th</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">to_meta_eq</span> <span class="main">=</span> <span class="entity">apply_to_thm</span> <span class="main">(</span><span class="entity">Util.concl_conv</span> <span class="entity">UtilBase.to_meta_eq_cv</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">to_obj_eq</span> <span class="main">=</span> <span class="entity">apply_to_thm</span> <span class="main">(</span><span class="entity">Util.concl_conv</span> <span class="entity">UtilBase.to_obj_eq_cv</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">obj_sym</span> <span class="main">=</span> <span class="entity">apply_to_thm</span> <span class="main">(</span><span class="entity">Util.concl_conv</span> <span class="entity">UtilBase.obj_sym_cv</span><span class="main">)</span>

<span class="comment1">(* Obtain rewriting conv from obj equality. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rewr_obj_eq</span> <span class="entity">eq_th</span> <span class="main">=</span> Conv.rewr_conv <span class="main">(</span><span class="entity">to_meta_eq</span> <span class="entity">eq_th</span><span class="main">)</span>

<span class="comment1">(* Given an equality A == B, make the equality ~A == ~B. Cancel ~~ on
   both sides if exists.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">make_neg_eq</span> <span class="entity">th</span> <span class="main">=</span>
    <span class="entity">th</span> |&gt; Thm.combination <span class="main">(</span>Thm.reflexive <span class="entity">UtilBase.cNot</span><span class="main">)</span>
       |&gt; <span class="entity">apply_to_lhs</span> <span class="main">(</span>Conv.try_conv <span class="main">(</span><span class="entity">rewr_obj_eq</span> <span class="entity">UtilBase.nn_cancel_th</span><span class="main">)</span><span class="main">)</span>
       |&gt; <span class="entity">apply_to_rhs</span> <span class="main">(</span>Conv.try_conv <span class="main">(</span><span class="entity">rewr_obj_eq</span> <span class="entity">UtilBase.nn_cancel_th</span><span class="main">)</span><span class="main">)</span>

<span class="comment1">(* If ct is of the form [...] ==&gt; False, leave it unchanged.
   Otherwise, change [...] ==&gt; B to [..., ~ B] ==&gt; False and change
   [...] ==&gt; ~ B to [..., B] ==&gt; False.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rewrite_to_contra_form</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">concl</span><span class="main">)</span> <span class="main">=</span> Logic.strip_horn <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">concl'</span> <span class="main">=</span> <span class="entity">dest_Trueprop</span> <span class="entity">concl</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">concl'</span> aconv <span class="entity">bFalse</span> <span class="keyword2"><span class="keyword">then</span></span>
        Conv.all_conv <span class="entity">ct</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_neg</span> <span class="entity">concl'</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="entity">Util.concl_conv</span> <span class="main">(</span>Conv.rewr_conv <span class="entity">UtilBase.to_contra_form_th'</span><span class="main">)</span> <span class="entity">ct</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="entity">Util.concl_conv</span> <span class="main">(</span>Conv.rewr_conv <span class="entity">UtilBase.to_contra_form_th</span><span class="main">)</span> <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Rewrite ct from [...] ==&gt; A ==&gt; False to [...] ==&gt; ~ A and from
   [...] ==&gt; ~ A ==&gt; False to [...] ==&gt; A.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rewrite_from_contra_form</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">prems</span><span class="main">,</span> <span class="entity">concl</span><span class="main">)</span> <span class="main">=</span> Logic.strip_horn <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span><span class="entity">concl</span> aconv <span class="entity">pFalse</span><span class="main">)</span>
                     <span class="inner_quoted">"rewrite_from_contra_form: concl should be false."</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">num_prems</span> <span class="main">=</span> length <span class="entity">prems</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">last_prem'</span> <span class="main">=</span> <span class="entity">dest_Trueprop</span> <span class="main">(</span>nth <span class="entity">prems</span> <span class="main">(</span><span class="entity">num_prems</span>-<span class="inner_numeral">1</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">to_contra_form</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_neg</span> <span class="entity">last_prem'</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">UtilBase.to_contra_form_th</span>
                           <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">UtilBase.to_contra_form_th'</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">Util.concl_conv_n</span> <span class="main">(</span><span class="entity">num_prems</span>-<span class="inner_numeral">1</span><span class="main">)</span>
                        <span class="main">(</span>Conv.rewr_conv <span class="main">(</span><span class="entity">meta_sym</span> <span class="entity">to_contra_form</span><span class="main">)</span><span class="main">)</span> <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Converts ==&gt; to --&gt; and !! to !. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">to_obj_conv</span> <span class="entity">ctxt</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> Thm.term_of <span class="entity">ct</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> Pure.imp<span class="antiquote">}</span></span> $ <span class="main">_</span> $ <span class="main">_</span> <span class="main">=&gt;</span>
        Conv.every_conv <span class="main">[</span>Conv.binop_conv <span class="main">(</span><span class="entity">to_obj_conv</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">,</span>
                         Conv.rewr_conv <span class="entity">UtilBase.atomize_imp_th</span><span class="main">]</span> <span class="entity">ct</span>
      <span class="main">|</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Pure.all<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ Abs <span class="main">_</span> <span class="main">=&gt;</span>
        Conv.every_conv <span class="main">[</span>Conv.binder_conv <span class="main">(</span><span class="entity">to_obj_conv</span> o snd<span class="main">)</span> <span class="entity">ctxt</span><span class="main">,</span>
                         Conv.rewr_conv <span class="entity">UtilBase.atomize_all_th</span><span class="main">]</span> <span class="entity">ct</span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> Conv.all_conv <span class="entity">ct</span>

<span class="comment1">(* When ct is of form A1 ==&gt; ... ==&gt; An, apply to_obj_conv to each Ai. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">to_obj_conv_on_horn</span> <span class="entity">ctxt</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> Thm.term_of <span class="entity">ct</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> Pure.imp<span class="antiquote">}</span></span> $ <span class="main">_</span> $ <span class="main">_</span> <span class="main">=&gt;</span>
        Conv.every_conv <span class="main">[</span>Conv.arg1_conv <span class="main">(</span><span class="entity">to_obj_conv</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">,</span>
                         Conv.arg_conv <span class="main">(</span><span class="entity">to_obj_conv_on_horn</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">]</span> <span class="entity">ct</span>
      <span class="main">|</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Pure.all<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ Abs <span class="main">_</span> <span class="main">=&gt;</span>
        Conv.binder_conv <span class="main">(</span><span class="entity">to_obj_conv_on_horn</span> o snd<span class="main">)</span> <span class="entity">ctxt</span> <span class="entity">ct</span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> Conv.all_conv <span class="entity">ct</span>

<span class="comment1">(* Convert !! and ==&gt; on the outermost level. Pull all !! to the front. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">to_meta_conv</span> <span class="entity">ctxt</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Thm.term_of <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_Trueprop</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_obj_all</span> <span class="main">(</span><span class="entity">dest_Trueprop</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
        Conv.every_conv <span class="main">[</span>Conv.rewr_conv <span class="main">(</span><span class="entity">meta_sym</span> <span class="entity">UtilBase.atomize_all_th</span><span class="main">)</span><span class="main">,</span>
                         <span class="entity">to_meta_conv</span> <span class="entity">ctxt</span><span class="main">]</span> <span class="entity">ct</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_Trueprop</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_ball</span> <span class="main">(</span><span class="entity">dest_Trueprop</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
        Conv.every_conv <span class="main">[</span>Conv.arg_conv <span class="main">(</span><span class="entity">rewr_obj_eq</span> <span class="entity">UtilBase.Ball_def_th</span><span class="main">)</span><span class="main">,</span>
                         <span class="entity">to_meta_conv</span> <span class="entity">ctxt</span><span class="main">]</span> <span class="entity">ct</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_Trueprop</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_imp</span> <span class="main">(</span><span class="entity">dest_Trueprop</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
        Conv.every_conv <span class="main">[</span>Conv.rewr_conv <span class="main">(</span><span class="entity">meta_sym</span> <span class="entity">UtilBase.atomize_imp_th</span><span class="main">)</span><span class="main">,</span>
                         <span class="entity">to_meta_conv</span> <span class="entity">ctxt</span><span class="main">]</span> <span class="entity">ct</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> Logic.is_all <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
        Conv.binder_conv <span class="main">(</span><span class="entity">to_meta_conv</span> o snd<span class="main">)</span> <span class="entity">ctxt</span> <span class="entity">ct</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">Util.is_implies</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
        Conv.every_conv <span class="main">[</span>Conv.arg_conv <span class="main">(</span><span class="entity">to_meta_conv</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">,</span>
                         <span class="entity">Util.swap_meta_imp_alls</span> <span class="entity">ctxt</span><span class="main">]</span> <span class="entity">ct</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        Conv.all_conv <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Modify th using imp_th, and add postfix to name (if available). *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">thm_RS_mod</span> <span class="entity">imp_th</span> <span class="entity">suffix</span> <span class="entity">th</span> <span class="main">=</span>
    <span class="main">(</span><span class="entity">th</span> RS <span class="entity">imp_th</span><span class="main">)</span> |&gt; Drule.zero_var_indexes
                   |&gt; <span class="entity">Util.update_name_of_thm</span> <span class="entity">th</span> <span class="entity">suffix</span>

<span class="comment1">(* From A &amp; B, obtain A. *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">conj_left_th</span> <span class="main">=</span> <span class="entity">thm_RS_mod</span> <span class="entity">UtilBase.conjunct1_th</span> <span class="inner_quoted">"@left"</span>
<span class="comment1">(* From A &amp; B, obtain B. *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">conj_right_th</span> <span class="main">=</span> <span class="entity">thm_RS_mod</span> <span class="entity">UtilBase.conjunct2_th</span> <span class="inner_quoted">"@right"</span>
<span class="comment1">(* From (A::bool) = B, obtain A ==&gt; B. *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">equiv_forward_th</span> <span class="main">=</span> <span class="entity">thm_RS_mod</span> <span class="entity">UtilBase.iffD1_th</span> <span class="inner_quoted">"@eqforward"</span>
<span class="comment1">(* From (A::bool) = B, obtain B ==&gt; A. *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">equiv_backward_th</span> <span class="main">=</span> <span class="entity">thm_RS_mod</span> <span class="entity">UtilBase.iffD2_th</span> <span class="inner_quoted">"@eqbackward"</span>
<span class="comment1">(* From (A::bool) = B, obtain ~A ==&gt; ~B. *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inv_backward_th</span> <span class="main">=</span> <span class="entity">thm_RS_mod</span> <span class="entity">UtilBase.inv_back_th</span> <span class="inner_quoted">"@invbackward"</span>
<span class="comment1">(* Same as to_obj_eq, except keeping names and indices. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">to_obj_eq_th</span> <span class="entity">th</span> <span class="main">=</span> <span class="entity">th</span> |&gt; <span class="entity">to_obj_eq</span> |&gt; <span class="entity">Util.update_name_of_thm</span> <span class="entity">th</span> <span class="inner_quoted">"@obj_eq"</span>
<span class="comment1">(* Same as to_obj_eq_iff, except keeping names and indices. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">to_obj_eq_iff_th</span> <span class="entity">th</span> <span class="main">=</span> <span class="entity">th</span> |&gt; <span class="entity">UtilBase.to_obj_eq_iff</span> |&gt; <span class="entity">Util.update_name_of_thm</span> <span class="entity">th</span> <span class="inner_quoted">"@iff"</span>
<span class="comment1">(* Same as obj_sym, except keeping names and indices. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">obj_sym_th</span> <span class="entity">th</span> <span class="main">=</span> <span class="entity">th</span> |&gt; <span class="entity">obj_sym</span> |&gt; <span class="entity">Util.update_name_of_thm</span> <span class="entity">th</span> <span class="inner_quoted">"@sym"</span>

<span class="comment1">(* Given th of form (P ==&gt;) A1 &amp; ... &amp; An, return theorems (P ==&gt;) A1,
   ..., (P ==&gt;) An, where there can be zero or more premises in front.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">split_conj_th</span> <span class="entity">th</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_conj</span> <span class="main">(</span><span class="entity">prop_of'</span> <span class="entity">th</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
      <span class="main">(</span><span class="entity">th</span> RS <span class="entity">UtilBase.conjunct1_th</span><span class="main">)</span> :: <span class="main">(</span><span class="entity">split_conj_th</span> <span class="main">(</span><span class="entity">th</span> RS <span class="entity">UtilBase.conjunct2_th</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="entity">th</span><span class="main">]</span>

<span class="comment1">(* More general form. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">split_conj_gen_th</span> <span class="entity">th</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_conj</span> <span class="main">(</span><span class="entity">prop_of'</span> <span class="entity">th</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
      maps <span class="entity">split_conj_gen_th</span> <span class="main">[</span><span class="entity">th</span> RS <span class="entity">UtilBase.conjunct1_th</span><span class="main">,</span>
                              <span class="entity">th</span> RS <span class="entity">UtilBase.conjunct2_th</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="entity">th</span><span class="main">]</span>

<span class="comment1">(* Given th of form ~ (A1 | ... | An), return theorems ~ A1, ... ~ An. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">split_not_disj_th</span> <span class="entity">th</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">prop_of'</span> <span class="entity">th</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_neg</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_disj</span> <span class="main">(</span><span class="entity">dest_not</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="main">(</span><span class="entity">th</span> RS <span class="entity">UtilBase.or_intro1_th</span><span class="main">)</span> :: <span class="main">(</span><span class="entity">split_not_disj_th</span> <span class="main">(</span><span class="entity">th</span> RS <span class="entity">UtilBase.or_intro2_th</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="entity">th</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Similar to Logic.strip_horn, except remove Trueprop. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">strip_horn'</span> <span class="entity">th</span> <span class="main">=</span> <span class="main">(</span>Logic.strip_horn <span class="main">(</span>Thm.prop_of <span class="entity">th</span><span class="main">)</span><span class="main">)</span>
                         |&gt; apfst <span class="main">(</span>map <span class="entity">dest_Trueprop</span><span class="main">)</span>
                         |&gt; apsnd <span class="entity">dest_Trueprop</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_conjs_th</span> <span class="entity">ths</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">ths</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"mk_conjs_th"</span>
      <span class="main">|</span> <span class="main">[</span><span class="entity">th</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="entity">th</span>
      <span class="main">|</span> <span class="entity">th</span> :: <span class="entity">rest</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="entity">th</span><span class="main">,</span> <span class="entity">mk_conjs_th</span> <span class="entity">rest</span><span class="main">]</span> MRS <span class="entity">UtilBase.conjI_th</span>

<span class="comment1">(* Given th of form P x ==&gt; False, where x is the given free variable,
   obtain new theorem of form (EX x. P x) ==&gt; False. The function is
   written so it can be applied to multiple variables with fold. For
   example, "fold (ex_elim ctxt) [x, y] (P x y ==&gt; False) will give
   (EX y x. P x y) ==&gt; False.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ex_elim</span> <span class="entity">ctxt</span> <span class="entity">freevar</span> <span class="entity">th</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th'</span> <span class="main">=</span> <span class="entity">th</span> |&gt; Thm.forall_intr <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">freevar</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">head_prem</span> <span class="main">=</span> hd <span class="main">(</span>Thm.prems_of <span class="entity">UtilBase.exE_th'</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inst</span> <span class="main">=</span> Pattern.match <span class="entity">thy</span> <span class="main">(</span><span class="entity">head_prem</span><span class="main">,</span> Thm.prop_of <span class="entity">th'</span><span class="main">)</span> <span class="entity">fo_init</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">exE_inst</span> <span class="main">=</span> <span class="entity">Util.subst_thm</span> <span class="entity">ctxt</span> <span class="entity">inst</span> <span class="entity">UtilBase.exE_th'</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      Thm.elim_implies <span class="entity">th'</span> <span class="entity">exE_inst</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">force_abs_form</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
        Abs <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">t</span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> Abs <span class="main">(</span><span class="inner_quoted">"x"</span><span class="main">,</span> domain_type <span class="main">(</span>fastype_of <span class="entity">t</span><span class="main">)</span><span class="main">,</span> <span class="entity">t</span> $ Bound <span class="inner_numeral">0</span><span class="main">)</span>

<span class="comment1">(* Normalization of object forall expressions in horn-clause form. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">strip_obj_horn</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_obj_all</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
          <span class="main">_</span> $ Abs <span class="main">(</span><span class="entity">abs</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">T</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">body</span><span class="main">)</span> <span class="main">=</span> Term.dest_abs <span class="entity">abs</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">var</span> <span class="main">=</span> Free <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">vars</span><span class="main">,</span> <span class="main">(</span><span class="entity">assum</span><span class="main">,</span> <span class="entity">concl</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">strip_obj_horn</span> <span class="entity">body</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="main">(</span><span class="entity">var</span> :: <span class="entity">vars</span><span class="main">,</span> <span class="main">(</span><span class="entity">assum</span><span class="main">,</span> <span class="entity">concl</span><span class="main">)</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>
        <span class="main">|</span> <span class="entity">f</span> $ <span class="entity">arg</span> <span class="main">=&gt;</span> <span class="entity">strip_obj_horn</span> <span class="main">(</span><span class="entity">f</span> $ <span class="entity">force_abs_form</span> <span class="entity">arg</span><span class="main">)</span>
        <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"strip_obj_horn"</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_ball</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
          <span class="main">_</span> $ <span class="entity">S</span> $ Abs <span class="main">(</span><span class="entity">abs</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">T</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">body</span><span class="main">)</span> <span class="main">=</span> Term.dest_abs <span class="entity">abs</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">var</span> <span class="main">=</span> Free <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mem</span> <span class="main">=</span> <span class="entity">mk_mem</span> <span class="main">(</span><span class="entity">var</span><span class="main">,</span> <span class="entity">S</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">vars</span><span class="main">,</span> <span class="main">(</span><span class="entity">assum</span><span class="main">,</span> <span class="entity">concl</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">strip_obj_horn</span> <span class="entity">body</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="main">(</span><span class="entity">var</span> :: <span class="entity">vars</span><span class="main">,</span> <span class="main">(</span><span class="entity">mem</span> :: <span class="entity">assum</span><span class="main">,</span> <span class="entity">concl</span><span class="main">)</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>
        <span class="main">|</span> <span class="entity">f</span> $ <span class="entity">S</span> $ <span class="entity">arg</span> <span class="main">=&gt;</span> <span class="entity">strip_obj_horn</span> <span class="main">(</span><span class="entity">f</span> $ <span class="entity">S</span> $ <span class="entity">force_abs_form</span> <span class="entity">arg</span><span class="main">)</span>
        <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"strip_obj_horn"</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_imp</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">vars</span><span class="main">,</span> <span class="main">(</span><span class="entity">assum</span><span class="main">,</span> <span class="entity">concl</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">strip_obj_horn</span> <span class="main">(</span><span class="entity">dest_arg</span> <span class="entity">t</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span><span class="entity">vars</span><span class="main">,</span> <span class="main">(</span><span class="entity">dest_arg1</span> <span class="entity">t</span> :: <span class="entity">assum</span><span class="main">,</span> <span class="entity">concl</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">else</span></span>
      <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">list_obj_horn</span> <span class="main">(</span><span class="entity">vars</span><span class="main">,</span> <span class="main">(</span><span class="entity">As</span><span class="main">,</span> <span class="entity">B</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
    <span class="main">(</span><span class="entity">list_obj_imp</span> <span class="main">(</span><span class="entity">As</span><span class="main">,</span> <span class="entity">B</span><span class="main">)</span><span class="main">)</span> |&gt; fold <span class="entity">mk_obj_all</span> <span class="main">(</span>rev <span class="entity">vars</span><span class="main">)</span>

<span class="comment1">(* Whether t can be immediately rewritten into EX form. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_ex_form_gen</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="entity">is_ex</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">orelse</span></span> <span class="entity">is_bex</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">orelse</span></span>
    <span class="main">(</span><span class="entity">is_neg</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_obj_all</span> <span class="main">(</span><span class="entity">dest_not</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span> <span class="keyword1"><span class="keyword">orelse</span></span>
    <span class="main">(</span><span class="entity">is_neg</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_ball</span> <span class="main">(</span><span class="entity">dest_not</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span> <span class="keyword1"><span class="keyword">orelse</span></span>
    <span class="main">(</span><span class="entity">is_conj</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_ex_form_gen</span> <span class="main">(</span><span class="entity">dest_arg</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span>

<span class="comment1">(* Rewrite A &amp; EX v_i. B to EX v_i. A &amp; B. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">swap_conj_exists</span> <span class="entity">ctxt</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Thm.term_of <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_conj</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_ex</span> <span class="main">(</span><span class="entity">dest_arg</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
        Conv.every_conv <span class="main">[</span><span class="entity">rewr_obj_eq</span> <span class="entity">UtilBase.swap_ex_conj_th</span><span class="main">,</span>
                         Conv.binder_conv <span class="main">(</span><span class="entity">swap_conj_exists</span> o snd<span class="main">)</span> <span class="entity">ctxt</span><span class="main">]</span> <span class="entity">ct</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        Conv.all_conv <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Normalize existence statement into EX v_i. A_1 &amp; ... &amp; A_n. This
   includes moving as many existence quantifiers to the left as
   possible.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">normalize_exists</span> <span class="entity">ctxt</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Thm.term_of <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_ex</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
        Conv.binder_conv <span class="main">(</span><span class="entity">normalize_exists</span> o snd<span class="main">)</span> <span class="entity">ctxt</span> <span class="entity">ct</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_bex</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
        Conv.every_conv <span class="main">[</span><span class="entity">rewr_obj_eq</span> <span class="entity">UtilBase.Bex_def_th</span><span class="main">,</span> <span class="entity">normalize_exists</span> <span class="entity">ctxt</span><span class="main">]</span> <span class="entity">ct</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_neg</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_obj_all</span> <span class="main">(</span><span class="entity">dest_not</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
        Conv.every_conv <span class="main">[</span><span class="entity">rewr_obj_eq</span> <span class="entity">UtilBase.not_all_th</span><span class="main">,</span> <span class="entity">normalize_exists</span> <span class="entity">ctxt</span><span class="main">]</span> <span class="entity">ct</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_neg</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_ball</span> <span class="main">(</span><span class="entity">dest_not</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
        Conv.every_conv <span class="main">[</span>Conv.arg_conv <span class="main">(</span><span class="entity">rewr_obj_eq</span> <span class="entity">UtilBase.Ball_def_th</span><span class="main">)</span><span class="main">,</span>
                         <span class="entity">rewr_obj_eq</span> <span class="entity">UtilBase.not_all_th</span><span class="main">,</span>
                         Conv.binder_conv <span class="main">(</span>K <span class="main">(</span><span class="entity">rewr_obj_eq</span> <span class="entity">UtilBase.not_imp_th</span><span class="main">)</span><span class="main">)</span> <span class="entity">ctxt</span><span class="main">,</span>
                         <span class="entity">normalize_exists</span> <span class="entity">ctxt</span><span class="main">]</span> <span class="entity">ct</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_conj</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
        Conv.every_conv <span class="main">[</span>Conv.arg_conv <span class="main">(</span><span class="entity">normalize_exists</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">,</span>
                         <span class="entity">swap_conj_exists</span> <span class="entity">ctxt</span><span class="main">]</span> <span class="entity">ct</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        Conv.all_conv <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Assume t is in normal form. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">strip_exists</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_ex</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
          <span class="main">_</span> $ Abs <span class="main">(</span><span class="entity">abs</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">T</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">body</span><span class="main">)</span> <span class="main">=</span> Term.dest_abs <span class="entity">abs</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">var</span> <span class="main">=</span> Free <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">vars</span><span class="main">,</span> <span class="entity">body'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">strip_exists</span> <span class="entity">body</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="main">(</span><span class="entity">var</span> :: <span class="entity">vars</span><span class="main">,</span> <span class="entity">body'</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>
        <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"strip_exists"</span>
    <span class="keyword2"><span class="keyword">else</span></span>
      <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span>

<span class="comment1">(* Generic wrapper function. tac can be arith_tac, simp_tac, etc. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prove_by_tac</span> <span class="entity">tac</span> <span class="entity">ctxt</span> <span class="entity">ths</span> <span class="entity">goal</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goal'</span> <span class="main">=</span> Logic.list_implies <span class="main">(</span>map Thm.prop_of <span class="entity">ths</span><span class="main">,</span> <span class="entity">mk_Trueprop</span> <span class="entity">goal</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">ths</span> MRS <span class="main">(</span>Goal.prove <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">goal'</span> <span class="main">(</span>K <span class="main">(</span><span class="entity">tac</span> <span class="entity">ctxt</span> <span class="inner_numeral">1</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">contra_by_tac</span> <span class="entity">tac</span> <span class="entity">ctxt</span> <span class="entity">ths</span> <span class="main">=</span> <span class="entity">prove_by_tac</span> <span class="entity">tac</span> <span class="entity">ctxt</span> <span class="entity">ths</span> <span class="entity">bFalse</span>

<span class="keyword2"><span class="keyword">end</span></span>  <span class="comment1">(* structure UtilLogic *)</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Basic_UtilLogic</span><span class="main">:</span> <span class="entity">BASIC_UTIL_LOGIC</span> <span class="main">=</span> <span class="entity">UtilLogic</span>
<span class="keyword3"><span class="keyword">open</span></span> <span class="entity">Basic_UtilLogic</span>
</pre>
</div><div id="files/AFP/Auto2_HOL/box_id.ML">
<div class="head">
<h1>File ‹$AFP/Auto2_HOL/box_id.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*
  File: box_id.ML
  Author: Bohua Zhan

  Definition and functions on box_id. Box ID is used for keeping track of case
  analysis. Each primitive ID, encoded by integers starting at 1, represents a
  new case. A box ID in general consists of a list of primitive IDs. The
  primitive ID 0 is reserved as a flag for incremental matching.
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">BOXID</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">box_id</span>
  <span class="keyword1"><span class="keyword">val</span></span> string_of_box_id<span class="main">:</span> <span class="entity">box_id</span> <span class="main">-&gt;</span> string

  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">box_lattice</span>
  <span class="keyword1"><span class="keyword">val</span></span> home_id<span class="main">:</span> int
  <span class="keyword1"><span class="keyword">val</span></span> has_incr_id<span class="main">:</span> <span class="entity">box_id</span> <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> add_incr_id<span class="main">:</span> <span class="entity">box_id</span> <span class="main">-&gt;</span> <span class="entity">box_id</span>
  <span class="keyword1"><span class="keyword">val</span></span> replace_incr_id<span class="main">:</span> <span class="entity">box_id</span> <span class="main">-&gt;</span> <span class="entity">box_id</span>

  <span class="keyword1"><span class="keyword">val</span></span> get_parent_prim<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> int <span class="main">-&gt;</span> <span class="entity">box_id</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_ancestors_prim<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">box_id</span> <span class="main">-&gt;</span> int list
  <span class="keyword1"><span class="keyword">val</span></span> reduce_box_id<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> int list <span class="main">-&gt;</span> <span class="entity">box_id</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_parent_at_i<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">box_id</span> <span class="main">-&gt;</span> int <span class="main">-&gt;</span> <span class="entity">box_id</span>
  <span class="keyword1"><span class="keyword">val</span></span> merge_boxes<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">box_id</span> * <span class="entity">box_id</span> <span class="main">-&gt;</span> <span class="entity">box_id</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_all_merges<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">box_id</span> list list <span class="main">-&gt;</span> <span class="entity">box_id</span> list
  <span class="keyword1"><span class="keyword">val</span></span> get_all_merges_info<span class="main">:</span>
      <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * 'a<span class="main">)</span> list list <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * 'a list<span class="main">)</span> list
  <span class="keyword1"><span class="keyword">val</span></span> is_eq_ancestor<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">box_id</span> <span class="main">-&gt;</span> <span class="entity">box_id</span> <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> is_eq_descendent<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">box_id</span> <span class="main">-&gt;</span> <span class="entity">box_id</span> <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> is_box_resolved<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">box_id</span> <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> is_box_unresolved<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">box_id</span> <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> id_is_eq_ancestor<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">box_id</span> * 'a <span class="main">-&gt;</span> <span class="entity">box_id</span> * 'a <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> info_eq_better<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">box_id</span> * thm <span class="main">-&gt;</span> <span class="entity">box_id</span> * thm <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> merge_box_with_info<span class="main">:</span>
      <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">box_id</span> <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * 'a<span class="main">)</span> list <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * 'a<span class="main">)</span> list
  <span class="keyword1"><span class="keyword">val</span></span> merge_eq_infos<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">box_id</span> * thm <span class="main">-&gt;</span> <span class="entity">box_id</span> * thm <span class="main">-&gt;</span> <span class="entity">box_id</span> * thm
  <span class="keyword1"><span class="keyword">val</span></span> add_prim_id<span class="main">:</span> <span class="entity">box_id</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> int * <span class="entity">Proof.context</span>
  <span class="keyword1"><span class="keyword">val</span></span> add_resolved<span class="main">:</span> <span class="entity">box_id</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">BoxID</span> <span class="main">:</span> <span class="entity">BOXID</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">box_id</span> <span class="main">=</span> int list

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">string_of_box_id</span> <span class="entity">id</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> length <span class="entity">id</span> <span class="main">=</span> <span class="inner_numeral">1</span> <span class="keyword2"><span class="keyword">then</span></span> string_of_int <span class="main">(</span>hd <span class="entity">id</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="inner_quoted">"("</span> ^ commas <span class="main">(</span>map string_of_int <span class="entity">id</span><span class="main">)</span> ^ <span class="inner_quoted">")"</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Boxidtab</span> <span class="main">=</span> Table <span class="main">(</span><span class="keyword1"><span class="keyword">type</span></span> <span class="entity">key</span> <span class="main">=</span> <span class="entity">box_id</span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ord</span> <span class="main">=</span> list_ord int_ord<span class="main">)</span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">box_lattice</span> <span class="main">=</span> <span class="main">{</span>
  parents<span class="main">:</span> <span class="entity">box_id</span> vector<span class="main">,</span>
  resolved<span class="main">:</span> <span class="entity">box_id</span> list
<span class="main">}</span>

<span class="comment1">(* Initialize with primitive ID zero (used to designate incremental
   matching).
 *)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Data</span> <span class="main">=</span> Proof_Data
<span class="main">(</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">T</span> <span class="main">=</span> <span class="entity">box_lattice</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">init</span> <span class="main">_</span> <span class="main">=</span> <span class="main">{</span>parents <span class="main">=</span> Vector.fromList <span class="main">[</span><span class="main">[</span><span class="main">]</span><span class="main">]</span><span class="main">,</span> resolved <span class="main">=</span> <span class="main">[</span><span class="main">]</span><span class="main">}</span>
<span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">home_id</span> <span class="main">=</span> <span class="inner_numeral">1</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">has_incr_id</span> <span class="entity">id</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">id</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> false <span class="main">|</span> <span class="entity">x</span> :: <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">x</span> <span class="main">=</span> <span class="inner_numeral">0</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_incr_id</span> <span class="entity">id</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">has_incr_id</span> <span class="entity">id</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"add_incr_id"</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="inner_numeral">0</span> :: <span class="entity">id</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">replace_incr_id</span> <span class="entity">id</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">has_incr_id</span> <span class="entity">id</span> <span class="keyword2"><span class="keyword">then</span></span> tl <span class="entity">id</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">id</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_parent_prim</span> <span class="entity">ctxt</span> <span class="entity">prim_id</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">parents</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> Data.get <span class="entity">ctxt</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      Vector.sub <span class="main">(</span><span class="entity">parents</span><span class="main">,</span> <span class="entity">prim_id</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword3"><span class="keyword">handle</span></span> Subscript <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"get_parent_prim: prim_id out of bounds."</span>

<span class="comment1">(* Returns the list of primitive ancestors of id. Result may not be in
   order.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_ancestors_prim</span> <span class="entity">ctxt</span> <span class="entity">id</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">helper</span> <span class="entity">all_ids</span> <span class="entity">cur_ids</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">new_ids</span> <span class="main">=</span>
                <span class="main">(</span>maps <span class="main">(</span><span class="entity">get_parent_prim</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">cur_ids</span><span class="main">)</span>
                    |&gt; distinct <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> |&gt; subtract <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">all_ids</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">new_ids</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">all_ids</span>
            <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">helper</span> <span class="main">(</span><span class="entity">all_ids</span> @ <span class="entity">new_ids</span><span class="main">)</span> <span class="entity">new_ids</span>
          <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">helper</span> <span class="entity">id</span> <span class="entity">id</span>
    <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword3"><span class="keyword">handle</span></span> Option.Option <span class="main">=&gt;</span>
           <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"get_ancestors_prim: unexpected prim id."</span>

<span class="comment1">(* For any {a, b} in ids where a is an ancestor of b, remove a from
   ids. Assume input is in order. Output is a valid box_id.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">reduce_box_id</span> <span class="entity">ctxt</span> <span class="entity">prim_lst</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">helper</span> <span class="entity">taken</span> <span class="entity">rest</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">rest</span> <span class="keyword2"><span class="keyword">of</span></span>
              <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="entity">taken</span>
            <span class="main">|</span> <span class="entity">cur</span> :: <span class="entity">rest'</span> <span class="main">=&gt;</span>
              <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cur_ancestors</span> <span class="main">=</span> <span class="entity">get_ancestors_prim</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">cur</span><span class="main">]</span>
              <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">helper</span> <span class="main">(</span><span class="entity">cur</span> :: subtract <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">cur_ancestors</span> <span class="entity">taken</span><span class="main">)</span> <span class="entity">rest'</span> <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">in</span></span>
      rev <span class="main">(</span><span class="entity">helper</span> <span class="main">[</span><span class="main">]</span> <span class="entity">prim_lst</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Given two ordered lists of integers without duplicates, merge them
   into a sorted list (the merge part of mergesort).
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ordered_merge</span> <span class="entity">ms</span> <span class="entity">ns</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="main">(</span><span class="entity">ms</span><span class="main">,</span> <span class="entity">ns</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">ns</span>
      <span class="main">|</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">ms</span>
      <span class="main">|</span> <span class="main">(</span><span class="entity">m</span> :: <span class="entity">ms'</span><span class="main">,</span> <span class="entity">n</span> :: <span class="entity">ns'</span><span class="main">)</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">m</span> &lt; <span class="entity">n</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">m</span> :: <span class="entity">ordered_merge</span> <span class="entity">ms'</span> <span class="entity">ns</span>
        <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">n</span> &lt; <span class="entity">m</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">n</span> :: <span class="entity">ordered_merge</span> <span class="entity">ms</span> <span class="entity">ns'</span>
        <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">m</span> :: <span class="entity">ordered_merge</span> <span class="entity">ms'</span> <span class="entity">ns'</span>

<span class="comment1">(* Returns box_id of the immediate parent coming from expanding the
   parent of the ith primitive id in the current box_id.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_parent_at_i</span> <span class="entity">ctxt</span> <span class="entity">id</span> <span class="entity">i</span> <span class="main">=</span>
    <span class="entity">reduce_box_id</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">ordered_merge</span> <span class="main">(</span>nth_drop <span class="entity">i</span> <span class="entity">id</span><span class="main">)</span>
                                      <span class="main">(</span><span class="entity">get_parent_prim</span> <span class="entity">ctxt</span> <span class="main">(</span>nth <span class="entity">id</span> <span class="entity">i</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

<span class="comment1">(* Merge two generalized boxes. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">merge_boxes</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id1</span><span class="main">,</span> <span class="entity">id2</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">merged</span> <span class="main">=</span> <span class="entity">ordered_merge</span> <span class="entity">id1</span> <span class="entity">id2</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">merged_len</span> <span class="main">=</span> length <span class="entity">merged</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">merged_len</span> <span class="main">=</span> length <span class="entity">id1</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">id1</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">merged_len</span> <span class="main">=</span> length <span class="entity">id2</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">id2</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">reduce_box_id</span> <span class="entity">ctxt</span> <span class="entity">merged</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Returns list of ids that are all possible intersections of subsets
   of ids.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_all_merges</span> <span class="entity">ctxt</span> <span class="entity">id_lsts</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">merge2</span> <span class="entity">ids1</span> <span class="entity">ids2</span> <span class="main">=</span>
          maps <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">id1</span> <span class="main">=&gt;</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">id2</span> <span class="main">=&gt;</span> <span class="entity">merge_boxes</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id1</span><span class="main">,</span> <span class="entity">id2</span><span class="main">)</span><span class="main">)</span> <span class="entity">ids2</span><span class="main">)</span> <span class="entity">ids1</span>
               |&gt; distinct <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      fold <span class="entity">merge2</span> <span class="entity">id_lsts</span> <span class="main">[</span><span class="main">[</span><span class="main">]</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Given a list a_p, where each a_p is a list of entries b_{pq}, where
   each entry is of the form (id_{pq}, x_{pq}), return all ways of
   choosing one entry b_{pq} from each a_p, combining them by merging
   id_{pq} and putting x_{pq} into a list.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_all_merges_info</span> <span class="entity">ctxt</span> <span class="entity">lsts</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">lsts</span> <span class="keyword2"><span class="keyword">then</span></span>
      <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"get_all_merges_info: lsts is empty."</span>
    <span class="keyword2"><span class="keyword">else</span></span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">merge</span> <span class="main">(</span><span class="main">(</span><span class="entity">id1</span><span class="main">,</span> <span class="entity">x</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">id2</span><span class="main">,</span> <span class="entity">xs</span><span class="main">)</span><span class="main">)</span>
            <span class="main">=</span> <span class="main">(</span><span class="entity">merge_boxes</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id1</span><span class="main">,</span> <span class="entity">id2</span><span class="main">)</span><span class="main">,</span> <span class="entity">x</span> :: <span class="entity">xs</span><span class="main">)</span>

        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">merge2</span> <span class="main">(</span><span class="entity">lst1</span><span class="main">,</span> <span class="entity">lst2</span><span class="main">)</span> <span class="main">=</span> map <span class="entity">merge</span> <span class="main">(</span><span class="entity">Util.all_pairs</span> <span class="main">(</span><span class="entity">lst1</span><span class="main">,</span> <span class="entity">lst2</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        Library.foldr <span class="entity">merge2</span> <span class="main">(</span><span class="entity">lsts</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">]</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Returns whether id is an ancestor / descendent of id'. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_eq_ancestor</span> <span class="entity">ctxt</span> <span class="entity">id</span> <span class="entity">id'</span> <span class="main">=</span> <span class="main">(</span><span class="entity">id'</span> <span class="main">=</span> <span class="entity">merge_boxes</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">id'</span><span class="main">)</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_eq_descendent</span> <span class="entity">ctxt</span> <span class="entity">id</span> <span class="entity">id'</span> <span class="main">=</span> <span class="main">(</span><span class="entity">id</span> <span class="main">=</span> <span class="entity">merge_boxes</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">id'</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_box_resolved</span> <span class="entity">ctxt</span> <span class="entity">id</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">resolved</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> Data.get <span class="entity">ctxt</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      exists <span class="main">(</span><span class="entity">is_eq_descendent</span> <span class="entity">ctxt</span> <span class="entity">id</span><span class="main">)</span> <span class="entity">resolved</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">is_box_unresolved</span> <span class="main">=</span> not oo <span class="entity">is_box_resolved</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">id_is_eq_ancestor</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">is_eq_ancestor</span> <span class="entity">ctxt</span> <span class="entity">id</span> <span class="entity">id'</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">info_eq_better</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">th'</span><span class="main">)</span> <span class="main">=</span>
    Thm.prop_of <span class="entity">th</span> aconv Thm.prop_of <span class="entity">th'</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_eq_ancestor</span> <span class="entity">ctxt</span> <span class="entity">id</span> <span class="entity">id'</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">merge_box_with_info</span> <span class="entity">ctxt</span> <span class="entity">id</span> <span class="main">=</span>
    map <span class="main">(</span>apfst <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">id'</span> <span class="main">=&gt;</span> <span class="entity">merge_boxes</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">id'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">merge_eq_infos</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">th'</span><span class="main">)</span> <span class="main">=</span>
    <span class="main">(</span><span class="entity">merge_boxes</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">id'</span><span class="main">)</span><span class="main">,</span> <span class="entity">Util.transitive_list</span> <span class="main">[</span><span class="entity">th</span><span class="main">,</span> <span class="entity">th'</span><span class="main">]</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_prim_id</span> <span class="entity">parent_id</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">parents</span><span class="main">,</span> <span class="entity">resolved</span><span class="main">}</span> <span class="main">=</span> Data.get <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prim_id</span> <span class="main">=</span> Vector.length <span class="entity">parents</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parents'</span> <span class="main">=</span> Vector.concat <span class="main">[</span><span class="entity">parents</span><span class="main">,</span> Vector.fromList <span class="main">[</span><span class="entity">parent_id</span><span class="main">]</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">(</span><span class="entity">prim_id</span><span class="main">,</span> <span class="entity">ctxt</span> |&gt; Data.map <span class="main">(</span>K <span class="main">{</span>parents <span class="main">=</span> <span class="entity">parents'</span><span class="main">,</span> resolved <span class="main">=</span> <span class="entity">resolved</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_resolved</span> <span class="entity">id</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">parents</span><span class="main">,</span> <span class="entity">resolved</span><span class="main">}</span> <span class="main">=</span> Data.get <span class="entity">ctxt</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> exists <span class="main">(</span><span class="entity">is_eq_descendent</span> <span class="entity">ctxt</span> <span class="entity">id</span><span class="main">)</span> <span class="entity">resolved</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">ctxt</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">resolved'</span> <span class="main">=</span> <span class="entity">id</span> :: filter_out <span class="main">(</span><span class="entity">is_eq_ancestor</span> <span class="entity">ctxt</span> <span class="entity">id</span><span class="main">)</span> <span class="entity">resolved</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="entity">ctxt</span> |&gt; Data.map <span class="main">(</span>K <span class="main">{</span>parents <span class="main">=</span> <span class="entity">parents</span><span class="main">,</span> resolved <span class="main">=</span> <span class="entity">resolved'</span><span class="main">}</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>  <span class="comment1">(* structure BoxID *)</span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">box_id</span> <span class="main">=</span> <span class="entity">BoxID.box_id</span>
<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">id_inst</span> <span class="main">=</span> <span class="entity">box_id</span> * <span class="main">(</span>Type.tyenv * Envir.tenv<span class="main">)</span>
<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">id_inst_th</span> <span class="main">=</span> <span class="entity">id_inst</span> * thm
<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">id_inst_ths</span> <span class="main">=</span> <span class="entity">id_inst</span> * thm list
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Boxidtab</span> <span class="main">=</span> Table <span class="main">(</span><span class="keyword1"><span class="keyword">type</span></span> <span class="entity">key</span> <span class="main">=</span> <span class="entity">BoxID.box_id</span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ord</span> <span class="main">=</span> list_ord int_ord<span class="main">)</span>
</pre>
</div><div id="files/AFP/Auto2_HOL/consts.ML">
<div class="head">
<h1>File ‹$AFP/Auto2_HOL/consts.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*
  File: consts.ML
  Author: Bohua Zhan

  Dealing with constants.
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">CONSTS</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> add_const_data<span class="main">:</span> string * <span class="main">(</span>term <span class="main">-&gt;</span> bool<span class="main">)</span> <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> detect_const<span class="main">:</span> theory <span class="main">-&gt;</span> term <span class="main">-&gt;</span> string option
  <span class="keyword1"><span class="keyword">val</span></span> detect_const_ctxt<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> string option
  <span class="keyword1"><span class="keyword">val</span></span> is_const<span class="main">:</span> theory <span class="main">-&gt;</span> term <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> is_const_ctxt<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> neq_const<span class="main">:</span> theory <span class="main">-&gt;</span> term * term <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> neq_const_ctxt<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term * term <span class="main">-&gt;</span> bool
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Consts</span> <span class="main">:</span> <span class="entity">CONSTS</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="comment1">(* Table of detectors for constants, each registered under a
   descriptive name.
 *)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Data</span> <span class="main">=</span> Theory_Data <span class="main">(</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">T</span> <span class="main">=</span> <span class="main">(</span>term <span class="main">-&gt;</span> bool<span class="main">)</span> Symtab.table<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">empty</span> <span class="main">=</span> Symtab.empty<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">extend</span> <span class="main">=</span> I<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">merge</span> <span class="main">=</span> Symtab.merge pointer_eq
<span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_const_data</span> <span class="main">(</span><span class="entity">str</span><span class="main">,</span> <span class="entity">f</span><span class="main">)</span> <span class="main">=</span>
    Data.map <span class="main">(</span>Symtab.update_new <span class="main">(</span><span class="entity">str</span><span class="main">,</span> <span class="entity">f</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">detect_const</span> <span class="entity">thy</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">data</span> <span class="main">=</span> Symtab.dest <span class="main">(</span>Data.get <span class="entity">thy</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      get_first <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">str</span><span class="main">,</span> <span class="entity">f</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">f</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span> SOME <span class="entity">str</span> <span class="keyword2"><span class="keyword">else</span></span> NONE<span class="main">)</span> <span class="entity">data</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">detect_const_ctxt</span> <span class="entity">ctxt</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="entity">detect_const</span> <span class="main">(</span>Proof_Context.theory_of <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">t</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_const</span> <span class="entity">thy</span> <span class="entity">t</span> <span class="main">=</span>
    is_some <span class="main">(</span><span class="entity">detect_const</span> <span class="entity">thy</span> <span class="entity">t</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_const_ctxt</span> <span class="entity">ctxt</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="entity">is_const</span> <span class="main">(</span>Proof_Context.theory_of <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">t</span>

<span class="comment1">(* Whether two constants are of the same type and not equal. If either
   input is not a constant, return false.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">neq_const</span> <span class="entity">thy</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty1</span> <span class="main">=</span> the <span class="main">(</span><span class="entity">detect_const</span> <span class="entity">thy</span> <span class="entity">t1</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty2</span> <span class="main">=</span> the <span class="main">(</span><span class="entity">detect_const</span> <span class="entity">thy</span> <span class="entity">t2</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">ty1</span> <span class="main">=</span> <span class="entity">ty2</span> <span class="keyword1"><span class="keyword">andalso</span></span> not <span class="main">(</span><span class="entity">t1</span> aconv <span class="entity">t2</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword3"><span class="keyword">handle</span></span> Option.Option <span class="main">=&gt;</span> false

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">neq_const_ctxt</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span>
    <span class="entity">neq_const</span> <span class="main">(</span>Proof_Context.theory_of <span class="entity">ctxt</span><span class="main">)</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>  <span class="comment1">(* structure Consts. *)</span>
</pre>
</div><div id="files/AFP/Auto2_HOL/property.ML">
<div class="head">
<h1>File ‹$AFP/Auto2_HOL/property.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*
  File: property.ML
  Author: Bohua Zhan

  Theory data for properties. This data consists of the following parts:

  - Two tables containing property update rules.

  - A table containing list of fields that can have properties.
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">PROPERTY</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> is_property<span class="main">:</span> term <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> add_property_field_const<span class="main">:</span> term <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> is_property_field<span class="main">:</span> theory <span class="main">-&gt;</span> term <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> strip_property_field<span class="main">:</span> theory <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term list
  <span class="keyword1"><span class="keyword">val</span></span> is_property_prem<span class="main">:</span> theory <span class="main">-&gt;</span> term <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> get_property_name<span class="main">:</span> term <span class="main">-&gt;</span> string
  <span class="keyword1"><span class="keyword">val</span></span> get_property_names<span class="main">:</span> term list <span class="main">-&gt;</span> string list
  <span class="keyword1"><span class="keyword">val</span></span> get_property_arg<span class="main">:</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> get_property_arg_th<span class="main">:</span> thm <span class="main">-&gt;</span> cterm

  <span class="comment1">(* About the PropertyUpdateData table.*)</span>
  <span class="keyword1"><span class="keyword">val</span></span> can_add_property_update<span class="main">:</span> thm <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> add_property_update<span class="main">:</span> thm <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> lookup_property_update<span class="main">:</span> theory <span class="main">-&gt;</span> string <span class="main">-&gt;</span> thm list
  <span class="keyword1"><span class="keyword">val</span></span> lookup_property_update_fun<span class="main">:</span> theory <span class="main">-&gt;</span> string <span class="main">-&gt;</span> thm list
  <span class="keyword1"><span class="keyword">val</span></span> instantiate_property_update<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm option
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Property</span> <span class="main">:</span> <span class="entity">PROPERTY</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="comment1">(* Rules deriving new properties of t from other properties of t. They
   are indexed under the names of the properties in the premises.
 *)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">UpdateData</span> <span class="main">=</span> Theory_Data <span class="main">(</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">T</span> <span class="main">=</span> <span class="main">(</span>thm list<span class="main">)</span> Symtab.table<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">empty</span> <span class="main">=</span> Symtab.empty<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">extend</span> <span class="main">=</span> I<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">merge</span> <span class="main">=</span> Symtab.merge_list Thm.eq_thm_prop
<span class="main">)</span>

<span class="comment1">(* Rules for deriving properties of f x_1 ... x_n from properties of
   x_1, ... x_n. They are indexed under the name of the head function
   f.
 *)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">UpdateFunData</span> <span class="main">=</span> Theory_Data <span class="main">(</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">T</span> <span class="main">=</span> <span class="main">(</span>thm list<span class="main">)</span> Symtab.table<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">empty</span> <span class="main">=</span> Symtab.empty<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">extend</span> <span class="main">=</span> I<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">merge</span> <span class="main">=</span> Symtab.merge_list Thm.eq_thm_prop
<span class="main">)</span>

<span class="comment1">(* Set of fields of a structure whose property can be considered as
   properties of the structure itself. Relevant when checking
   is_property_prem.
 *)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">FieldData</span> <span class="main">=</span> Theory_Data <span class="main">(</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">T</span> <span class="main">=</span> unit Symtab.table<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">empty</span> <span class="main">=</span> Symtab.empty<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">extend</span> <span class="main">=</span> I<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">merge</span> <span class="main">=</span> Symtab.merge <span class="main">(</span>K true<span class="main">)</span>
<span class="main">)</span>

<span class="comment1">(* Whether the term is a property predicate applied to a term. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_property</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span>fastype_of <span class="entity">t</span> <span class="main">=</span> <span class="entity">boolT</span><span class="main">)</span> <span class="inner_quoted">"is_property: wrong type"</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">f</span><span class="main">,</span> <span class="entity">ts</span><span class="main">)</span> <span class="main">=</span> Term.strip_comb <span class="entity">t</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> length <span class="entity">ts</span> &lt;&gt; <span class="inner_numeral">1</span> <span class="keyword1"><span class="keyword">orelse</span></span> not <span class="main">(</span>Term.is_Const <span class="entity">f</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> false <span class="keyword2"><span class="keyword">else</span></span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">T</span> <span class="main">=</span> fastype_of <span class="main">(</span>the_single <span class="entity">ts</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">dT</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> Term.strip_type <span class="entity">T</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        length <span class="entity">dT</span> <span class="main">=</span> <span class="inner_numeral">0</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">T</span> &lt;&gt; <span class="entity">boolT</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Insert the following constant as a property field. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_property_field_const</span> <span class="entity">t</span> <span class="entity">thy</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> Term.head_of <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
        Const <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">pTs</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> Term.strip_type <span class="entity">T</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> length <span class="entity">pTs</span> <span class="main">=</span> <span class="inner_numeral">1</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">)</span>
                  <span class="keyword2"><span class="keyword">else</span></span> error <span class="inner_quoted">"Add property field: input should be a field."</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> writeln <span class="main">(</span><span class="inner_quoted">"Add field "</span> ^ <span class="entity">c</span> ^ <span class="inner_quoted">" as property field."</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="entity">thy</span> |&gt; FieldData.map <span class="main">(</span>Symtab.update_new <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="main">(</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">end</span></span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> error <span class="inner_quoted">"Add property field: input should be a constant."</span>

<span class="comment1">(* Whether the term is zero or more property field constants applied
   to a Var term.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_property_field</span> <span class="entity">thy</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
        Var <span class="main">_</span> <span class="main">=&gt;</span> true
      <span class="main">|</span> Const <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="entity">t'</span> <span class="main">=&gt;</span>
        Symtab.defined <span class="main">(</span>FieldData.get <span class="entity">thy</span><span class="main">)</span> <span class="entity">c</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_property_field</span> <span class="entity">thy</span> <span class="entity">t'</span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false

<span class="comment1">(* Given a term t, return all possible ways to strip property field
   constants from t. For example, if t is of the form f1(f2(x)), where
   f1 and f2 are property constants, then the result is [f1(f2(x)),
   f2(x), x].
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">strip_property_field</span> <span class="entity">thy</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
        Const <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="entity">t'</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">if</span></span> Symtab.defined <span class="main">(</span>FieldData.get <span class="entity">thy</span><span class="main">)</span> <span class="entity">c</span> <span class="keyword2"><span class="keyword">then</span></span>
          <span class="entity">t</span> :: <span class="entity">strip_property_field</span> <span class="entity">thy</span> <span class="entity">t'</span>
        <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="entity">t</span><span class="main">]</span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="entity">t</span><span class="main">]</span>

<span class="comment1">(* Stricter condition than is_property: the argument must be a
   schematic variable (up to property fields).
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_property_prem</span> <span class="entity">thy</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="entity">is_property</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_property_field</span> <span class="entity">thy</span> <span class="main">(</span><span class="entity">dest_arg</span> <span class="entity">t</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">get_property_name</span> <span class="main">=</span> <span class="entity">Util.get_head_name</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_property_names</span> <span class="entity">ts</span> <span class="main">=</span>
    <span class="entity">ts</span> |&gt; map <span class="entity">get_property_name</span> |&gt; distinct <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span>

<span class="comment1">(* Return the argument of the property. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_property_arg</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="entity">dest_arg</span> <span class="entity">t</span>
    <span class="keyword3"><span class="keyword">handle</span></span> Fail <span class="inner_quoted">"dest_arg"</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"get_property_arg: t in wrong form."</span>

<span class="comment1">(* Return the argument of the property theorem as a cterm. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_property_arg_th</span> <span class="entity">th</span> <span class="main">=</span>
    Thm.dest_arg <span class="main">(</span><span class="entity">cprop_of'</span> <span class="entity">th</span><span class="main">)</span>
    <span class="keyword3"><span class="keyword">handle</span></span> CTERM <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"get_property_carg"</span>
         <span class="main">|</span> Fail <span class="inner_quoted">"dest_Trueprop"</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"get_property_carg"</span>

<span class="comment1">(* Add the given rule as a property update. The requirements on th is
   as follows:

   - The conclusion must be a property constant, with argument in the
     form of either ?x or f ?x1 ... ?xn.

   - Each premise must be a property constant on ?x (in the first
     case) or one of ?x1 ... ?xn (in the second case). The argument of
     the property in the conclusion must contain all schematic
     variables of the theorem.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">can_add_property_update</span> <span class="entity">th</span> <span class="entity">thy</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">prems</span><span class="main">,</span> <span class="entity">concl</span><span class="main">)</span> <span class="main">=</span> <span class="entity">UtilLogic.strip_horn'</span> <span class="entity">th</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_property</span> <span class="entity">concl</span> <span class="keyword1"><span class="keyword">andalso</span></span> forall <span class="main">(</span><span class="entity">is_property_prem</span> <span class="entity">thy</span><span class="main">)</span> <span class="entity">prems</span>
      <span class="keyword2"><span class="keyword">then</span></span> <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">concl_arg</span> <span class="main">=</span> <span class="entity">get_property_arg</span> <span class="entity">concl</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_vars</span> <span class="main">=</span> map Var <span class="main">(</span>Term.add_vars <span class="main">(</span>Thm.prop_of <span class="entity">th</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="keyword2"><span class="keyword">if</span></span> is_Var <span class="entity">concl_arg</span> <span class="keyword2"><span class="keyword">then</span></span>
          <span class="comment1">(* First case: check that concl_arg is the only schematic Var. *)</span>
          length <span class="entity">all_vars</span> <span class="main">=</span> <span class="inner_numeral">1</span>
        <span class="keyword2"><span class="keyword">else</span></span>
          <span class="comment1">(* Second case: concl_arg is of the form f ?x1 ... ?xn. *)</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">=</span> <span class="entity">Util.dest_args</span> <span class="entity">concl_arg</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            forall is_Var <span class="entity">args</span> <span class="keyword1"><span class="keyword">andalso</span></span> subset <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv<span class="main">)</span> <span class="main">(</span><span class="entity">all_vars</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword2"><span class="keyword">else</span></span> false
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Add the given theorem as a property update rule. Choose which table
   to add the rule to.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_property_update</span> <span class="entity">th</span> <span class="entity">thy</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">prems</span><span class="main">,</span> <span class="entity">concl</span><span class="main">)</span> <span class="main">=</span> <span class="entity">UtilLogic.strip_horn'</span> <span class="entity">th</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span><span class="entity">is_property</span> <span class="entity">concl</span><span class="main">)</span>
                     <span class="inner_quoted">"add_property_update: concl must be a property constant."</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span>forall <span class="main">(</span><span class="entity">is_property_prem</span> <span class="entity">thy</span><span class="main">)</span> <span class="entity">prems</span><span class="main">)</span>
                     <span class="inner_quoted">"add_property_update: prem must be a property premise."</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">concl_arg</span> <span class="main">=</span> <span class="entity">get_property_arg</span> <span class="entity">concl</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_vars</span> <span class="main">=</span> map Var <span class="main">(</span>Term.add_vars <span class="main">(</span>Thm.prop_of <span class="entity">th</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> is_Var <span class="entity">concl_arg</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="comment1">(* First case. Each premise must also be about ?x. Add to
           UpdateData table under the names of the predicates.
         *)</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span>length <span class="entity">all_vars</span> <span class="main">=</span> <span class="inner_numeral">1</span><span class="main">)</span>
                         <span class="inner_quoted">"add_property_update: extraneous Vars in th."</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">names</span> <span class="main">=</span> <span class="entity">get_property_names</span> <span class="entity">prems</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> writeln <span class="main">(</span><span class="inner_quoted">"Add property rule for "</span> ^
                           <span class="main">(</span><span class="entity">Util.string_of_list</span> I <span class="entity">names</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="entity">thy</span> |&gt; UpdateData.map <span class="main">(</span>
            fold <span class="main">(</span>Symtab.update_list Thm.eq_thm_prop<span class="main">)</span> <span class="main">(</span>map <span class="main">(</span>rpair <span class="entity">th</span><span class="main">)</span> <span class="entity">names</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="comment1">(* Second case. concl_arg in the form f ?x1 ... ?xn. Add to
           UpdateFunData table under f.
         *)</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">f</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span> <span class="main">=</span> Term.strip_comb <span class="entity">concl_arg</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">c</span> <span class="main">=</span>
              <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">f</span> <span class="keyword2"><span class="keyword">of</span></span>
                  Const <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">c</span>
                <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"add_property_update: f is not constant."</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span>forall is_Var <span class="entity">args</span><span class="main">)</span>
                         <span class="inner_quoted">"add_property_update: all args of concl must be Vars."</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span>subset <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv<span class="main">)</span> <span class="main">(</span><span class="entity">all_vars</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span><span class="main">)</span>
                         <span class="inner_quoted">"add_property_update: extraneous Vars in th."</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> writeln <span class="main">(</span><span class="inner_quoted">"Add property rule for function "</span> ^ <span class="entity">c</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="entity">thy</span> |&gt; UpdateFunData.map <span class="main">(</span>Symtab.update_list Thm.eq_thm_prop <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Find update rules of the form P1 x ==&gt; ... ==&gt; Pn x ==&gt; P x, where
   c is one of P1, ... Pn.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">lookup_property_update</span> <span class="entity">thy</span> <span class="entity">c</span> <span class="main">=</span>
    Symtab.lookup_list <span class="main">(</span>UpdateData.get <span class="entity">thy</span><span class="main">)</span> <span class="entity">c</span>

<span class="comment1">(* Find update rules of the form A1 ==&gt; ... ==&gt; An ==&gt;
   P(f(x1,...,xn)), where each A_i is a property on one of x_j. Here c
   is the name of f.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">lookup_property_update_fun</span> <span class="entity">thy</span> <span class="entity">c</span> <span class="main">=</span>
    Symtab.lookup_list <span class="main">(</span>UpdateFunData.get <span class="entity">thy</span><span class="main">)</span> <span class="entity">c</span>

<span class="comment1">(* Instantiate th by matching t with the argument of the conclusion of
   th. Return NONE if instantiation is unsuccessful (because type does
   not match).
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">instantiate_property_update</span> <span class="entity">ctxt</span> <span class="entity">t</span> <span class="entity">th</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">concl</span><span class="main">)</span> <span class="main">=</span> <span class="entity">UtilLogic.strip_horn'</span> <span class="entity">th</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">concl_arg</span> <span class="main">=</span> <span class="entity">get_property_arg</span> <span class="entity">concl</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> Sign.typ_instance <span class="entity">thy</span> <span class="main">(</span>fastype_of <span class="entity">t</span><span class="main">,</span> fastype_of <span class="entity">concl_arg</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">err_str</span> <span class="main">=</span> <span class="inner_quoted">"instantiate_property_update: cannot match with t."</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inst</span> <span class="main">=</span> Pattern.first_order_match <span class="entity">thy</span> <span class="main">(</span><span class="entity">concl_arg</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span> <span class="entity">fo_init</span>
                     <span class="keyword3"><span class="keyword">handle</span></span> Pattern.MATCH <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="entity">err_str</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          SOME <span class="main">(</span><span class="entity">Util.subst_thm</span> <span class="entity">ctxt</span> <span class="entity">inst</span> <span class="entity">th</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword2"><span class="keyword">else</span></span> NONE
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>  <span class="comment1">(* structure Property. *)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">add_property_field_const</span> <span class="main">=</span> <span class="entity">Property.add_property_field_const</span>
</pre>
</div><div id="files/AFP/Auto2_HOL/wellform.ML">
<div class="head">
<h1>File ‹$AFP/Auto2_HOL/wellform.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*
  File: wellform.ML
  Author: Bohua Zhan

  Wellformed-ness of terms.
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">WELLFORM</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> register_wellform_data<span class="main">:</span> string * string list <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> lookup_wellform_data<span class="main">:</span> theory <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term list
  <span class="keyword1"><span class="keyword">val</span></span> is_subterm_wellform_data'<span class="main">:</span>
      theory <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term <span class="main">-&gt;</span> <span class="main">(</span>term * term<span class="main">)</span> option
  <span class="keyword1"><span class="keyword">val</span></span> is_subterm_wellform_data<span class="main">:</span>
      theory <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> <span class="main">(</span>term * term<span class="main">)</span> option
  <span class="keyword1"><span class="keyword">val</span></span> lookup_wellform_pattern<span class="main">:</span> theory <span class="main">-&gt;</span> term * term <span class="main">-&gt;</span> <span class="main">(</span>term * term<span class="main">)</span> option
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">WellForm</span> <span class="main">:</span> <span class="entity">WELLFORM</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="comment1">(* Each entry in the table consists of a term of the form f ?a_1
   ... ?a_n, where f is a constant, and each ?a_i is a pure schematic
   variable, paired with a list of requirements for the term to be
   valid. It is indexed under the string of the constant f.
 *)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Data</span> <span class="main">=</span> Theory_Data <span class="main">(</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">T</span> <span class="main">=</span> <span class="main">(</span>term * term list<span class="main">)</span> Symtab.table
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">empty</span> <span class="main">=</span> Symtab.empty<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">extend</span> <span class="main">=</span> I<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">merge</span> <span class="main">=</span> Symtab.merge <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span>
<span class="main">)</span>

<span class="comment1">(* Add a term with its requirements to the table. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">register_wellform_data</span> <span class="main">(</span><span class="entity">t_str</span><span class="main">,</span> <span class="entity">req_strs</span><span class="main">)</span> <span class="entity">thy</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt</span> <span class="main">=</span> Proof_Context.init_global <span class="entity">thy</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Proof_Context.read_term_pattern <span class="entity">ctxt</span> <span class="entity">t_str</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt'</span> <span class="main">=</span> Variable.declare_term <span class="entity">t</span> <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">reqs</span> <span class="main">=</span> map <span class="main">(</span>Proof_Context.read_term_pattern <span class="entity">ctxt'</span><span class="main">)</span> <span class="entity">req_strs</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">f</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span> <span class="main">=</span> Term.strip_comb <span class="entity">t</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span>Term.is_Const <span class="entity">f</span><span class="main">)</span>
                     <span class="inner_quoted">"add_wellform_data: head must be Const."</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span>forall Term.is_Free <span class="entity">args</span><span class="main">)</span>
                     <span class="inner_quoted">"add_wellform_data: arguments must be Free."</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> Term.dest_Const <span class="entity">f</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">thy</span> |&gt; Data.map <span class="main">(</span>Symtab.update_new <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">reqs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Lookup table for the given term t. If nothing is found, return the
   empty list by default.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">lookup_wellform_data</span> <span class="entity">thy</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">f</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span> <span class="main">=</span> Term.strip_comb <span class="entity">t</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">data</span> <span class="main">=</span> Data.get <span class="entity">thy</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">f</span> <span class="keyword2"><span class="keyword">of</span></span>
          Const <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span>
          <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> Symtab.lookup <span class="entity">data</span> <span class="entity">c</span> <span class="keyword2"><span class="keyword">of</span></span>
               NONE <span class="main">=&gt;</span> <span class="main">[</span><span class="main">]</span>
             <span class="main">|</span> SOME <span class="main">(</span><span class="entity">t'</span><span class="main">,</span> <span class="entity">reqs</span><span class="main">)</span> <span class="main">=&gt;</span>
               <span class="keyword2"><span class="keyword">let</span></span>
                 <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">vars</span><span class="main">)</span> <span class="main">=</span> Term.strip_comb <span class="entity">t'</span>
               <span class="keyword2"><span class="keyword">in</span></span>
                 <span class="keyword2"><span class="keyword">if</span></span> length <span class="entity">vars</span> &lt;&gt; length <span class="entity">args</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span> <span class="keyword2"><span class="keyword">else</span></span>
                 <span class="keyword2"><span class="keyword">let</span></span>
                   <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tys</span> <span class="main">=</span> map fastype_of <span class="entity">vars</span> ~~ map fastype_of <span class="entity">args</span>
                   <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tyinst</span> <span class="main">=</span> fold <span class="main">(</span>Sign.typ_match <span class="entity">thy</span><span class="main">)</span> <span class="entity">tys</span> Vartab.empty
                   <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">vars'</span> <span class="main">=</span> map <span class="main">(</span>Envir.subst_term_types <span class="entity">tyinst</span><span class="main">)</span> <span class="entity">vars</span>
                   <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">subst_fun</span> <span class="entity">req</span> <span class="main">=</span>
                       <span class="entity">req</span> |&gt; Envir.subst_term_types <span class="entity">tyinst</span>
                           |&gt; Term.subst_atomic <span class="main">(</span><span class="entity">vars'</span> ~~ <span class="entity">args</span><span class="main">)</span>
                 <span class="keyword2"><span class="keyword">in</span></span>
                   distinct <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv<span class="main">)</span> <span class="main">(</span>map <span class="entity">subst_fun</span> <span class="entity">reqs</span><span class="main">)</span>
                 <span class="keyword2"><span class="keyword">end</span></span>
                 <span class="keyword3"><span class="keyword">handle</span></span> Type.TYPE_MATCH <span class="main">=&gt;</span> <span class="main">[</span><span class="main">]</span>
               <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>
        <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Check whether req is part of the wellformed-ness data of a subterm
   of t. If so, return the pair SOME (t', req), where t' is a subterm
   of t and req is a wellformed-ness data of t'. Otherwise return
   NONE.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_subterm_wellform_data'</span> <span class="entity">thy</span> <span class="entity">req</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> member <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv<span class="main">)</span> <span class="main">(</span><span class="entity">lookup_wellform_data</span> <span class="entity">thy</span> <span class="entity">t</span><span class="main">)</span> <span class="entity">req</span> <span class="keyword2"><span class="keyword">then</span></span>
      SOME <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">req</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span> <span class="main">=</span> Term.strip_comb <span class="entity">t</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      get_first <span class="main">(</span><span class="entity">is_subterm_wellform_data'</span> <span class="entity">thy</span> <span class="entity">req</span><span class="main">)</span> <span class="entity">args</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_subterm_wellform_data</span> <span class="entity">thy</span> <span class="entity">req</span> <span class="entity">ts</span> <span class="main">=</span>
    get_first <span class="main">(</span><span class="entity">is_subterm_wellform_data'</span> <span class="entity">thy</span> <span class="entity">req</span><span class="main">)</span> <span class="entity">ts</span>

<span class="comment1">(* Given a term t and wellform data for t, return the relevant
   wellform pattern.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">lookup_wellform_pattern</span> <span class="entity">thy</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">wf_t</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">f</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span> <span class="main">=</span> Term.strip_comb <span class="entity">t</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">data</span> <span class="main">=</span> Data.get <span class="entity">thy</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">f</span> <span class="keyword2"><span class="keyword">of</span></span>
          Const <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span>
          <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> Symtab.lookup <span class="entity">data</span> <span class="entity">c</span> <span class="keyword2"><span class="keyword">of</span></span>
               NONE <span class="main">=&gt;</span> NONE
             <span class="main">|</span> SOME <span class="main">(</span><span class="entity">t'</span><span class="main">,</span> <span class="entity">reqs</span><span class="main">)</span> <span class="main">=&gt;</span>
               <span class="keyword2"><span class="keyword">let</span></span>
                 <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">vars</span><span class="main">)</span> <span class="main">=</span> Term.strip_comb <span class="entity">t'</span>
               <span class="keyword2"><span class="keyword">in</span></span>
                 <span class="keyword2"><span class="keyword">if</span></span> length <span class="entity">vars</span> &lt;&gt; length <span class="entity">args</span> <span class="keyword2"><span class="keyword">then</span></span> NONE
                 <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
                   <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tys</span> <span class="main">=</span> map fastype_of <span class="entity">vars</span> ~~ map fastype_of <span class="entity">args</span>
                   <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tyinst</span> <span class="main">=</span> fold <span class="main">(</span>Sign.typ_match <span class="entity">thy</span><span class="main">)</span> <span class="entity">tys</span> Vartab.empty
                   <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">vars'</span> <span class="main">=</span> map <span class="main">(</span>Envir.subst_term_types <span class="entity">tyinst</span><span class="main">)</span> <span class="entity">vars</span>
                   <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">subst_fun</span> <span class="entity">t</span> <span class="main">=</span>
                       <span class="entity">t</span> |&gt; Envir.subst_term_types <span class="entity">tyinst</span>
                         |&gt; Term.subst_atomic <span class="main">(</span><span class="entity">vars'</span> ~~ <span class="entity">args</span><span class="main">)</span>
                   <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">reqs'</span> <span class="main">=</span> filter <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">req</span> <span class="main">=&gt;</span> <span class="entity">wf_t</span> aconv <span class="entity">subst_fun</span> <span class="entity">req</span><span class="main">)</span> <span class="entity">reqs</span>
                 <span class="keyword2"><span class="keyword">in</span></span>
                   <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">reqs'</span> <span class="keyword2"><span class="keyword">of</span></span>
                       <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> NONE
                     <span class="main">|</span> <span class="entity">req'</span> :: <span class="main">_</span> <span class="main">=&gt;</span>
                       SOME <span class="main">(</span>apply2 <span class="main">(</span>Envir.subst_term_types <span class="entity">tyinst</span><span class="main">)</span> <span class="main">(</span><span class="entity">t'</span><span class="main">,</span> <span class="entity">req'</span><span class="main">)</span><span class="main">)</span>
                 <span class="keyword2"><span class="keyword">end</span></span>
               <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>
        <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> NONE
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>  <span class="comment1">(* structure WellForm. *)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">register_wellform_data</span> <span class="main">=</span> <span class="entity">WellForm.register_wellform_data</span>
</pre>
</div><div id="files/AFP/Auto2_HOL/wfterm.ML">
<div class="head">
<h1>File ‹$AFP/Auto2_HOL/wfterm.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*
  File: wfterm.ML
  Author: Bohua Zhan

  Definition and basic functions on Wellformed terms.
*)</span>

<span class="comment1">(* A wellformed term is a cterm combined with wellform data (usually
   only for a particular function head.
 *)</span>
<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">wfterm</span>
  <span class="main">=</span> <span class="entity">WfTerm</span> <span class="keyword2"><span class="keyword">of</span></span> cterm
  <span class="main">|</span> <span class="entity">WfComb</span> <span class="keyword2"><span class="keyword">of</span></span> cterm * wfterm list * thm list

<span class="keyword1"><span class="keyword">infix</span></span> <span class="inner_numeral">1</span> then_wfconv
<span class="keyword1"><span class="keyword">infix</span></span> <span class="inner_numeral">0</span> else_wfconv

<span class="comment1">(* Conversion between wellformed terms. Produce a new wellformed term,
   together with an equality between corresponding terms.
 *)</span>
<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">wfconv</span> <span class="main">=</span> <span class="entity">wfterm</span> <span class="main">-&gt;</span> <span class="entity">wfterm</span> * thm

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">WFTERM</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="comment1">(* Conversion between term and wfterm. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> cterm_of<span class="main">:</span> <span class="entity">wfterm</span> <span class="main">-&gt;</span> cterm
  <span class="keyword1"><span class="keyword">val</span></span> term_of<span class="main">:</span> <span class="entity">wfterm</span> <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> theory_of_wft<span class="main">:</span> <span class="entity">wfterm</span> <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> wellform_ths_of<span class="main">:</span> <span class="entity">wfterm</span> <span class="main">-&gt;</span> thm list
  <span class="keyword1"><span class="keyword">val</span></span> find_target_on_ths<span class="main">:</span> thm list <span class="main">-&gt;</span> term <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> cterm_to_wfterm_on_ths<span class="main">:</span> thm list <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> cterm <span class="main">-&gt;</span> <span class="entity">wfterm</span>
  <span class="keyword1"><span class="keyword">val</span></span> cterm_to_wfterm_assume<span class="main">:</span> term list <span class="main">-&gt;</span> cterm <span class="main">-&gt;</span> <span class="entity">wfterm</span>

  <span class="comment1">(* Wellformed version of conv. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> strip_comb<span class="main">:</span> <span class="entity">wfterm</span> <span class="main">-&gt;</span> cterm * <span class="entity">wfterm</span> list
  <span class="keyword1"><span class="keyword">val</span></span> all_conv<span class="main">:</span> <span class="entity">wfconv</span>
  <span class="keyword1"><span class="keyword">val</span></span> no_conv<span class="main">:</span> <span class="entity">wfconv</span>
  <span class="keyword1"><span class="keyword">val</span></span> argn_conv<span class="main">:</span> int <span class="main">-&gt;</span> <span class="entity">wfconv</span> <span class="main">-&gt;</span> <span class="entity">wfconv</span>
  <span class="keyword1"><span class="keyword">val</span></span> arg_conv<span class="main">:</span> <span class="entity">wfconv</span> <span class="main">-&gt;</span> <span class="entity">wfconv</span>
  <span class="keyword1"><span class="keyword">val</span></span> arg1_conv<span class="main">:</span> <span class="entity">wfconv</span> <span class="main">-&gt;</span> <span class="entity">wfconv</span>
  <span class="keyword1"><span class="keyword">val</span></span> rewr_obj_eq<span class="main">:</span> term list <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> <span class="entity">wfconv</span>
  <span class="keyword1"><span class="keyword">val</span></span> then_wfconv<span class="main">:</span> <span class="entity">wfconv</span> * <span class="entity">wfconv</span> <span class="main">-&gt;</span> <span class="entity">wfconv</span>
  <span class="keyword1"><span class="keyword">val</span></span> else_wfconv<span class="main">:</span> <span class="entity">wfconv</span> * <span class="entity">wfconv</span> <span class="main">-&gt;</span> <span class="entity">wfconv</span>
  <span class="keyword1"><span class="keyword">val</span></span> try_conv<span class="main">:</span> <span class="entity">wfconv</span> <span class="main">-&gt;</span> <span class="entity">wfconv</span>
  <span class="keyword1"><span class="keyword">val</span></span> repeat_conv<span class="main">:</span> <span class="entity">wfconv</span> <span class="main">-&gt;</span> <span class="entity">wfconv</span>
  <span class="keyword1"><span class="keyword">val</span></span> first_conv<span class="main">:</span> <span class="entity">wfconv</span> list <span class="main">-&gt;</span> <span class="entity">wfconv</span>
  <span class="keyword1"><span class="keyword">val</span></span> every_conv<span class="main">:</span> <span class="entity">wfconv</span> list <span class="main">-&gt;</span> <span class="entity">wfconv</span>
  <span class="keyword1"><span class="keyword">val</span></span> binop_conv<span class="main">:</span> <span class="entity">wfconv</span> <span class="main">-&gt;</span> <span class="entity">wfconv</span>
  <span class="keyword1"><span class="keyword">val</span></span> conv_of<span class="main">:</span> conv <span class="main">-&gt;</span> <span class="entity">wfconv</span>

  <span class="comment1">(* Some debugging facilities. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> string_of_wfterm<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">wfterm</span> <span class="main">-&gt;</span> string
  <span class="keyword1"><span class="keyword">val</span></span> test_wfconv<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> <span class="entity">wfconv</span> <span class="main">-&gt;</span> string <span class="main">-&gt;</span> string * string <span class="main">-&gt;</span> unit

  <span class="comment1">(* Rewriting a wellformed expression. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> rewrite_on_eqs<span class="main">:</span> term list <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">wfterm</span> * thm<span class="main">)</span> list <span class="main">-&gt;</span> <span class="entity">wfconv</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">WfTerm</span> <span class="main">:</span> <span class="entity">WFTERM</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="comment1">(* Extract a regular cterm from a wellformed term. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">cterm_of</span> <span class="entity">wft</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">wft</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="entity">WfTerm</span> <span class="entity">ct</span> <span class="main">=&gt;</span> <span class="entity">ct</span>
      <span class="main">|</span> <span class="entity">WfComb</span> <span class="main">(</span><span class="entity">cf</span><span class="main">,</span> <span class="entity">args</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> Drule.list_comb <span class="main">(</span><span class="entity">cf</span><span class="main">,</span> map <span class="entity">cterm_of</span> <span class="entity">args</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">term_of</span> <span class="entity">wft</span> <span class="main">=</span>
    Thm.term_of <span class="main">(</span><span class="entity">cterm_of</span> <span class="entity">wft</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">theory_of_wft</span> <span class="entity">wft</span> <span class="main">=</span>
    Thm.theory_of_cterm <span class="main">(</span><span class="entity">cterm_of</span> <span class="entity">wft</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">wellform_ths_of</span> <span class="entity">wft</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">wft</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="entity">WfTerm</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="main">]</span>
      <span class="main">|</span> <span class="entity">WfComb</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">args</span><span class="main">,</span> <span class="entity">ths</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">ths</span> @ <span class="main">(</span>maps <span class="entity">wellform_ths_of</span> <span class="entity">args</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">find_target_on_ths</span> <span class="entity">ths</span> <span class="entity">prop</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_on_th</span> <span class="entity">th</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">prop_of'</span> <span class="entity">th</span> aconv <span class="entity">prop</span> <span class="keyword2"><span class="keyword">then</span></span> SOME <span class="entity">th</span> <span class="keyword2"><span class="keyword">else</span></span> NONE
    <span class="keyword2"><span class="keyword">in</span></span>
      the <span class="main">(</span>get_first <span class="entity">get_on_th</span> <span class="entity">ths</span><span class="main">)</span>
      <span class="keyword3"><span class="keyword">handle</span></span> Option.Option <span class="main">=&gt;</span>
             <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"find_target_on_ths: not found"</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Obtain a wellformed term from a cterm and a list of
   theorems. Traverse only through combinations whose function head
   agrees with one of fheads. Throws an exception if any wellform data
   is not found.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">cterm_to_wfterm_on_ths</span> <span class="entity">assum_ths</span> <span class="entity">fheads</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> Thm.term_of <span class="entity">ct</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="main">_</span> $ <span class="main">_</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Thm.theory_of_cterm <span class="entity">ct</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Thm.term_of <span class="entity">ct</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">cf</span><span class="main">,</span> <span class="entity">cargs</span><span class="main">)</span> <span class="main">=</span> Drule.strip_comb <span class="entity">ct</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="keyword2"><span class="keyword">if</span></span> forall <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">fhead</span> <span class="main">=&gt;</span> not <span class="main">(</span><span class="entity">Util.is_head</span> <span class="entity">fhead</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span> <span class="entity">fheads</span> <span class="keyword2"><span class="keyword">then</span></span>
            <span class="entity">WfTerm</span> <span class="entity">ct</span>
          <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ths</span> <span class="main">=</span>
                map <span class="main">(</span><span class="entity">find_target_on_ths</span> <span class="entity">assum_ths</span><span class="main">)</span>
                    <span class="main">(</span><span class="entity">WellForm.lookup_wellform_data</span> <span class="entity">thy</span> <span class="entity">t</span><span class="main">)</span>
                <span class="keyword3"><span class="keyword">handle</span></span> Fail <span class="inner_quoted">"find_target_on_ths: not found"</span> <span class="main">=&gt;</span>
                       <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"cterm_to_wfterm_on_ths"</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">wfargs</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">cterm_to_wfterm_on_ths</span> <span class="entity">assum_ths</span> <span class="entity">fheads</span><span class="main">)</span> <span class="entity">cargs</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="entity">WfComb</span> <span class="main">(</span><span class="entity">cf</span><span class="main">,</span> <span class="entity">wfargs</span><span class="main">,</span> <span class="entity">ths</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>
        <span class="keyword2"><span class="keyword">end</span></span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">WfTerm</span> <span class="entity">ct</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">cterm_to_wfterm_assume</span> <span class="entity">fheads</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> Thm.term_of <span class="entity">ct</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="main">_</span> $ <span class="main">_</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Thm.theory_of_cterm <span class="entity">ct</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Thm.term_of <span class="entity">ct</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">cf</span><span class="main">,</span> <span class="entity">cargs</span><span class="main">)</span> <span class="main">=</span> Drule.strip_comb <span class="entity">ct</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="keyword2"><span class="keyword">if</span></span> forall <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">fhead</span> <span class="main">=&gt;</span> not <span class="main">(</span><span class="entity">Util.is_head</span> <span class="entity">fhead</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span> <span class="entity">fheads</span> <span class="keyword2"><span class="keyword">then</span></span>
            <span class="entity">WfTerm</span> <span class="entity">ct</span>
          <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ths</span> <span class="main">=</span> map <span class="main">(</span>Thm.assume o Thm.global_cterm_of <span class="entity">thy</span> o <span class="entity">mk_Trueprop</span><span class="main">)</span>
                          <span class="main">(</span><span class="entity">WellForm.lookup_wellform_data</span> <span class="entity">thy</span> <span class="entity">t</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">wfargs</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">cterm_to_wfterm_assume</span> <span class="entity">fheads</span><span class="main">)</span> <span class="entity">cargs</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="entity">WfComb</span> <span class="main">(</span><span class="entity">cf</span><span class="main">,</span> <span class="entity">wfargs</span><span class="main">,</span> <span class="entity">ths</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>
        <span class="keyword2"><span class="keyword">end</span></span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">WfTerm</span> <span class="entity">ct</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">strip_comb</span> <span class="entity">wft</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">wft</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="entity">WfTerm</span> <span class="entity">ct</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">ct</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">WfComb</span> <span class="main">(</span><span class="entity">cf</span><span class="main">,</span> <span class="entity">args</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">cf</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">all_conv</span> <span class="entity">wft</span> <span class="main">=</span>
    <span class="main">(</span><span class="entity">wft</span><span class="main">,</span> Thm.reflexive <span class="main">(</span><span class="entity">cterm_of</span> <span class="entity">wft</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">no_conv</span> <span class="main">_</span> <span class="main">=</span>
    <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"WfTerm.no_conv"</span>

<span class="comment1">(* Apply wfcv to the nth argument of wft (counting from the
   left). Remember to update the wellform data at head.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">argn_conv</span> <span class="entity">n</span> <span class="entity">wfcv</span> <span class="entity">wft</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">wft</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="entity">WfTerm</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"argn_conv: applied to atom."</span>
      <span class="main">|</span> <span class="entity">WfComb</span> <span class="main">(</span><span class="entity">cf</span><span class="main">,</span> <span class="entity">args</span><span class="main">,</span> <span class="entity">ths</span><span class="main">)</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span><span class="entity">n</span> &lt; length <span class="entity">args</span><span class="main">)</span> <span class="inner_quoted">"argn_conv: n out of bounds."</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Thm.theory_of_cterm <span class="entity">cf</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">wft'</span><span class="main">,</span> <span class="entity">eq_th</span><span class="main">)</span> <span class="main">=</span> <span class="entity">wfcv</span> <span class="main">(</span>nth <span class="entity">args</span> <span class="entity">n</span><span class="main">)</span>

          <span class="comment1">(* New list of arguments, and equalities between the two lists. *)</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args'</span> <span class="main">=</span> take <span class="entity">n</span> <span class="entity">args</span> @ <span class="main">[</span><span class="entity">wft'</span><span class="main">]</span> @ drop <span class="main">(</span><span class="entity">n</span> + <span class="inner_numeral">1</span><span class="main">)</span> <span class="entity">args</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq_ths'</span> <span class="main">=</span> map <span class="main">(</span>Thm.reflexive o <span class="entity">cterm_of</span><span class="main">)</span> <span class="main">(</span>take <span class="entity">n</span> <span class="entity">args</span><span class="main">)</span> @
                        <span class="main">[</span><span class="entity">eq_th</span><span class="main">]</span> @
                        map <span class="main">(</span>Thm.reflexive o <span class="entity">cterm_of</span><span class="main">)</span> <span class="main">(</span>drop <span class="main">(</span><span class="entity">n</span> + <span class="inner_numeral">1</span><span class="main">)</span> <span class="entity">args</span><span class="main">)</span>

          <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">convert_th</span> <span class="entity">th</span> <span class="main">=</span>
              <span class="keyword2"><span class="keyword">let</span></span>
                <span class="comment1">(* Obtain pattern from theory. *)</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">pat</span><span class="main">,</span> <span class="entity">data_pat</span><span class="main">)</span> <span class="main">=</span>
                    the <span class="main">(</span><span class="entity">WellForm.lookup_wellform_pattern</span>
                             <span class="entity">thy</span> <span class="main">(</span><span class="entity">term_of</span> <span class="entity">wft</span><span class="main">,</span> <span class="entity">prop_of'</span> <span class="entity">th</span><span class="main">)</span><span class="main">)</span>
                    <span class="keyword3"><span class="keyword">handle</span></span> Option.Option <span class="main">=&gt;</span>
                           <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"convert_th: invalid input."</span>

                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pat_args</span> <span class="main">=</span> <span class="entity">Util.dest_args</span> <span class="entity">pat</span>
              <span class="keyword2"><span class="keyword">in</span></span>
                <span class="entity">apply_to_thm'</span> <span class="main">(</span>
                  <span class="entity">Util.pattern_rewr_conv</span> <span class="entity">data_pat</span> <span class="main">(</span><span class="entity">pat_args</span> ~~ <span class="entity">eq_ths'</span><span class="main">)</span><span class="main">)</span> <span class="entity">th</span>
              <span class="keyword2"><span class="keyword">end</span></span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="main">(</span><span class="entity">WfComb</span> <span class="main">(</span><span class="entity">cf</span><span class="main">,</span> <span class="entity">args'</span><span class="main">,</span> map <span class="entity">convert_th</span> <span class="entity">ths</span><span class="main">)</span><span class="main">,</span> <span class="entity">Util.comb_equiv</span> <span class="main">(</span><span class="entity">cf</span><span class="main">,</span> <span class="entity">eq_ths'</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">arg_conv</span> <span class="entity">wfcv</span> <span class="entity">wft</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span> <span class="main">=</span> Term.strip_comb <span class="main">(</span><span class="entity">term_of</span> <span class="entity">wft</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">argn_conv</span> <span class="main">(</span>length <span class="entity">args</span> - <span class="inner_numeral">1</span><span class="main">)</span> <span class="entity">wfcv</span> <span class="entity">wft</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">arg1_conv</span> <span class="entity">wfcv</span> <span class="entity">wft</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span> <span class="main">=</span> Term.strip_comb <span class="main">(</span><span class="entity">term_of</span> <span class="entity">wft</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">argn_conv</span> <span class="main">(</span>length <span class="entity">args</span> - <span class="inner_numeral">2</span><span class="main">)</span> <span class="entity">wfcv</span> <span class="entity">wft</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Apply the given theorem as a rewrite rule. th is assumed to be in
   the form P_1 ==&gt; ... ==&gt; P_m ==&gt; l = r &amp; Q_1 &amp; ... &amp; Q_n, where P_1
   through P_m provide wellform data for l, and Q_1 through Q_n
   provide additional wellform data for r.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rewr_obj_eq</span> <span class="entity">fheads</span> <span class="entity">th</span> <span class="entity">wft</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> <span class="entity">theory_of_wft</span> <span class="entity">wft</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">term_of</span> <span class="entity">wft</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">wf_ths</span> <span class="main">=</span> <span class="entity">wellform_ths_of</span> <span class="entity">wft</span>

      <span class="comment1">(* First need to instantiate th by matching l with the term of wft. *)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pat_l</span> <span class="main">=</span> <span class="entity">th</span> |&gt; <span class="entity">concl_of'</span> |&gt; <span class="entity">strip_conj</span> |&gt; hd |&gt; <span class="entity">dest_eq</span> |&gt; fst
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inst</span> <span class="main">=</span> Pattern.first_order_match <span class="entity">thy</span> <span class="main">(</span><span class="entity">pat_l</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span> <span class="entity">fo_init</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th'</span> <span class="main">=</span> <span class="entity">Util.subst_thm_thy</span> <span class="entity">thy</span> <span class="entity">inst</span> <span class="entity">th</span>

      <span class="comment1">(* Second, find theorems justifying premises of th'. *)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prems</span> <span class="main">=</span> map <span class="entity">dest_Trueprop</span> <span class="main">(</span>Thm.prems_of <span class="entity">th'</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prems_th</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">find_target_on_ths</span> <span class="entity">wf_ths</span><span class="main">)</span> <span class="entity">prems</span>
                     <span class="keyword3"><span class="keyword">handle</span></span> Fail <span class="inner_quoted">"find_target_on_ths: not found"</span> <span class="main">=&gt;</span>
                            <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"WfTerm.rewr_obj_eq"</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th''</span> <span class="main">=</span> <span class="entity">prems_th</span> MRS <span class="entity">th'</span>

      <span class="comment1">(* Finally, apply rewrite rule and fill in wellform data on rhs. *)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th_splits</span> <span class="main">=</span> <span class="entity">UtilLogic.split_conj_th</span> <span class="entity">th''</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">eq_th</span><span class="main">,</span> <span class="entity">wf_ths'</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>hd <span class="entity">th_splits</span><span class="main">,</span> tl <span class="entity">th_splits</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">c_rhs</span> <span class="main">=</span> <span class="entity">eq_th</span> |&gt; Thm.cprop_of |&gt; Thm.dest_arg |&gt; Thm.dest_arg
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">wf_rhs</span> <span class="main">=</span> <span class="entity">cterm_to_wfterm_on_ths</span> <span class="main">(</span><span class="entity">wf_ths</span> @ <span class="entity">wf_ths'</span><span class="main">)</span> <span class="entity">fheads</span> <span class="entity">c_rhs</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">(</span><span class="entity">wf_rhs</span><span class="main">,</span> <span class="entity">to_meta_eq</span> <span class="entity">eq_th</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword3"><span class="keyword">handle</span></span> Pattern.MATCH <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"WfTerm.rewr_obj_eq failed"</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="main">(</span><span class="entity">wfcv1</span> <span class="entity">then_wfconv</span> <span class="entity">wfcv2</span><span class="main">)</span> <span class="entity">wft</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">wft'</span><span class="main">,</span> <span class="entity">eq_th1</span><span class="main">)</span> <span class="main">=</span> <span class="entity">wfcv1</span> <span class="entity">wft</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">wft''</span><span class="main">,</span> <span class="entity">eq_th2</span><span class="main">)</span> <span class="main">=</span> <span class="entity">wfcv2</span> <span class="entity">wft'</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">(</span><span class="entity">wft''</span><span class="main">,</span> <span class="entity">Util.transitive_list</span> <span class="main">[</span><span class="entity">eq_th1</span><span class="main">,</span> <span class="entity">eq_th2</span><span class="main">]</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="main">(</span><span class="entity">wfcv1</span> <span class="entity">else_wfconv</span> <span class="entity">wfcv2</span><span class="main">)</span> <span class="entity">wft</span> <span class="main">=</span>
    <span class="main">(</span><span class="entity">wfcv1</span> <span class="entity">wft</span>
     <span class="keyword3"><span class="keyword">handle</span></span> THM <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">wfcv2</span> <span class="entity">wft</span>
          <span class="main">|</span> CTERM <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">wfcv2</span> <span class="entity">wft</span>
          <span class="main">|</span> TERM <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">wfcv2</span> <span class="entity">wft</span>
          <span class="main">|</span> TYPE <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">wfcv2</span> <span class="entity">wft</span>
          <span class="main">|</span> Fail <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">wfcv2</span> <span class="entity">wft</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">try_conv</span> <span class="entity">wfcv</span> <span class="main">=</span> <span class="entity">wfcv</span> <span class="entity">else_wfconv</span> <span class="entity">all_conv</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">repeat_conv</span> <span class="entity">wfcv</span> <span class="entity">wft</span> <span class="main">=</span> <span class="entity">try_conv</span> <span class="main">(</span><span class="entity">wfcv</span> <span class="entity">then_wfconv</span> <span class="entity">repeat_conv</span> <span class="entity">wfcv</span><span class="main">)</span> <span class="entity">wft</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">first_conv</span> <span class="entity">wfcvs</span> <span class="main">=</span> fold_rev <span class="main">(</span>curry <span class="keyword1"><span class="keyword">op</span></span> <span class="entity">else_wfconv</span><span class="main">)</span> <span class="entity">wfcvs</span> <span class="entity">no_conv</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">every_conv</span> <span class="entity">wfcvs</span> <span class="main">=</span> fold_rev <span class="main">(</span>curry <span class="keyword1"><span class="keyword">op</span></span> <span class="entity">then_wfconv</span><span class="main">)</span> <span class="entity">wfcvs</span> <span class="entity">all_conv</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">binop_conv</span> <span class="entity">wfcv</span> <span class="main">=</span> <span class="entity">arg1_conv</span> <span class="entity">wfcv</span> <span class="entity">then_wfconv</span> <span class="entity">arg_conv</span> <span class="entity">wfcv</span>

<span class="comment1">(* Transforming a regular conversion to a well-formed conversion. This
   should be used only when the output of the conversion is guaranteed
   to not have further wellform structure.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">conv_of</span> <span class="entity">cv</span> <span class="entity">wft</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ct</span> <span class="main">=</span> <span class="entity">cterm_of</span> <span class="entity">wft</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq_th</span> <span class="main">=</span> <span class="entity">cv</span> <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">(</span><span class="entity">WfTerm</span> <span class="main">(</span>Thm.rhs_of <span class="entity">eq_th</span><span class="main">)</span><span class="main">,</span> <span class="entity">eq_th</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">string_of_wfterm</span> <span class="entity">ctxt</span> <span class="entity">wft</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">wft</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="entity">WfTerm</span> <span class="entity">ct</span> <span class="main">=&gt;</span> <span class="inner_quoted">"@("</span> ^ Syntax.string_of_term <span class="entity">ctxt</span> <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span> ^ <span class="inner_quoted">")"</span>
      <span class="main">|</span> <span class="entity">WfComb</span> <span class="main">(</span><span class="entity">ct</span><span class="main">,</span> <span class="entity">wfts</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span>
        Syntax.string_of_term <span class="entity">ctxt</span> <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span> ^ <span class="inner_quoted">" $ "</span> ^
        <span class="main">(</span>space_implode <span class="inner_quoted">" $ "</span> <span class="main">(</span>map <span class="main">(</span><span class="entity">string_of_wfterm</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">wfts</span><span class="main">)</span><span class="main">)</span>

<span class="comment1">(* Apply wfcv on the term given by str_t, and compare the result to
   the term given by str_res.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">test_wfconv</span> <span class="entity">ctxt</span> <span class="entity">fheads</span> <span class="entity">wfcv</span> <span class="entity">err_str</span> <span class="main">(</span><span class="entity">str1</span><span class="main">,</span> <span class="entity">str2</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Syntax.read_term <span class="entity">ctxt</span> <span class="entity">str1</span><span class="main">,</span> Syntax.read_term <span class="entity">ctxt</span> <span class="entity">str2</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">wft</span> <span class="main">=</span> <span class="entity">cterm_to_wfterm_assume</span> <span class="entity">fheads</span> <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">t1</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th</span> <span class="main">=</span> snd <span class="main">(</span><span class="entity">wfcv</span> <span class="entity">wft</span><span class="main">)</span>
               <span class="keyword3"><span class="keyword">handle</span></span> Fail <span class="entity">err</span> <span class="main">=&gt;</span>
                      <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_t</span> <span class="entity">ctxt</span> <span class="inner_quoted">"Input:"</span> <span class="entity">t1</span> <span class="keyword2"><span class="keyword">in</span></span>
                        <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="main">(</span><span class="entity">err</span> ^ <span class="inner_quoted">" -- "</span> ^ <span class="entity">err_str</span><span class="main">)</span>
                      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">t1</span> aconv <span class="main">(</span><span class="entity">Util.lhs_of</span> <span class="entity">th</span><span class="main">)</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">t2</span> aconv <span class="main">(</span><span class="entity">Util.rhs_of</span> <span class="entity">th</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_t</span> <span class="entity">ctxt</span> <span class="inner_quoted">"Input:"</span> <span class="entity">t1</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_t</span> <span class="entity">ctxt</span> <span class="inner_quoted">"Expected:"</span> <span class="entity">t2</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_t</span> <span class="entity">ctxt</span> <span class="inner_quoted">"Actual:"</span> <span class="main">(</span>Thm.prop_of <span class="entity">th</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="entity">err_str</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Given a well-formed term wft, and a list of equations to
   well-formed terms, rewrite all subterms of wft that are equal to
   the left side of one of the equations. Assume that all fheads are
   binary functions.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rewrite_on_eqs</span> <span class="entity">fheads</span> <span class="entity">wf_eqs</span> <span class="entity">wft</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">term_of</span> <span class="entity">wft</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> member <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv<span class="main">)</span> <span class="entity">fheads</span> <span class="main">(</span>Term.head_of <span class="entity">t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="entity">binop_conv</span> <span class="main">(</span><span class="entity">rewrite_on_eqs</span> <span class="entity">fheads</span> <span class="entity">wf_eqs</span><span class="main">)</span> <span class="entity">wft</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="keyword2"><span class="keyword">case</span></span> find_first <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">eq</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">t</span> aconv <span class="main">(</span><span class="entity">Util.lhs_of</span> <span class="entity">eq</span><span class="main">)</span><span class="main">)</span> <span class="entity">wf_eqs</span> <span class="keyword2"><span class="keyword">of</span></span>
            NONE <span class="main">=&gt;</span> <span class="entity">all_conv</span> <span class="entity">wft</span>
          <span class="main">|</span> SOME <span class="main">(</span><span class="entity">wft</span><span class="main">,</span> <span class="entity">eq_th</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">wft</span><span class="main">,</span> <span class="entity">eq_th</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>  <span class="comment1">(* structure WfTerm *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="main">(</span><span class="entity">wfcv1</span> <span class="entity">then_wfconv</span> <span class="entity">wfcv2</span><span class="main">)</span> <span class="main">=</span> <span class="entity">WfTerm.then_wfconv</span> <span class="main">(</span><span class="entity">wfcv1</span><span class="main">,</span> <span class="entity">wfcv2</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="main">(</span><span class="entity">wfcv1</span> <span class="entity">else_wfconv</span> <span class="entity">wfcv2</span><span class="main">)</span> <span class="main">=</span> <span class="entity">WfTerm.else_wfconv</span> <span class="main">(</span><span class="entity">wfcv1</span><span class="main">,</span> <span class="entity">wfcv2</span><span class="main">)</span>
</pre>
</div><div id="files/AFP/Auto2_HOL/rewrite.ML">
<div class="head">
<h1>File ‹$AFP/Auto2_HOL/rewrite.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*
  File: rewrite.ML
  Author: Bohua Zhan

  Maintains the congruence closure of the currently known equalities.
  Automatically apply transitivity and the congruence property.
*)</span>

<span class="comment1">(* Order on equality theorems, by comparing the right side. *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simp_ord</span> <span class="main">=</span> Term_Ord.term_ord o <span class="main">(</span>apply2 <span class="entity">Util.rhs_of</span><span class="main">)</span>

<span class="comment1">(* Equality on box_id * thm, comparing the right side. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">eq_info</span> <span class="main">(</span><span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">th'</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
    <span class="main">(</span><span class="entity">id</span> <span class="main">=</span> <span class="entity">id'</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">Util.rhs_of</span> <span class="entity">th</span> aconv <span class="entity">Util.rhs_of</span> <span class="entity">th'</span><span class="main">)</span>

<span class="comment1">(* Debug functions. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">print_info</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=</span> <span class="inner_quoted">"("</span> ^ <span class="main">(</span><span class="entity">BoxID.string_of_box_id</span> <span class="entity">id</span><span class="main">)</span> ^ <span class="inner_quoted">", "</span> ^
                               <span class="main">(</span><span class="entity">th</span> |&gt; <span class="entity">Util.rhs_of</span> |&gt; Syntax.string_of_term <span class="entity">ctxt</span><span class="main">)</span> ^ <span class="inner_quoted">")"</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">print_infos</span> <span class="entity">ctxt</span> <span class="entity">lst</span> <span class="main">=</span> commas <span class="main">(</span>map <span class="main">(</span><span class="entity">print_info</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">lst</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">print_info'</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">ths</span><span class="main">)</span> <span class="main">=</span>
    <span class="inner_quoted">"("</span> ^ <span class="main">(</span><span class="entity">BoxID.string_of_box_id</span> <span class="entity">id</span><span class="main">)</span> ^ <span class="inner_quoted">", "</span> ^
    <span class="main">(</span><span class="entity">ths</span> |&gt; map <span class="entity">Util.rhs_of</span> |&gt; <span class="entity">Util.string_of_terms</span> <span class="entity">ctxt</span><span class="main">)</span> ^ <span class="inner_quoted">")"</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">print_infos'</span> <span class="entity">ctxt</span> <span class="entity">lst</span> <span class="main">=</span> cat_lines <span class="main">(</span>map <span class="main">(</span><span class="entity">print_info'</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">lst</span><span class="main">)</span>

<span class="comment1">(* Data structure for rewrite table. *)</span>
<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">rewrite_table</span> <span class="main">=</span> <span class="main">{</span>
  <span class="comment1">(* terms[t] is the list of ids at which t is present. *)</span>
  terms<span class="main">:</span> <span class="main">(</span><span class="entity">box_id</span> list * cterm<span class="main">)</span> Termtab.table<span class="main">,</span>
  <span class="comment1">(* equiv[a] is list of (id, th), where th is "a == a'" under id. *)</span>
  equiv<span class="main">:</span> <span class="main">(</span><span class="main">(</span><span class="entity">box_id</span> * thm<span class="main">)</span> list<span class="main">)</span> Termtab.table<span class="main">,</span>
  <span class="comment1">(* Index of reachability under equiv. *)</span>
  all_equiv<span class="main">:</span> <span class="main">(</span><span class="main">(</span><span class="entity">box_id</span> * thm<span class="main">)</span> list<span class="main">)</span> Termtab.table<span class="main">,</span>
  <span class="comment1">(* contain[A] is the list of terms for which A is a direct subterm. *)</span>
  contain<span class="main">:</span> <span class="main">(</span>cterm list<span class="main">)</span> Termtab.table<span class="main">,</span>
  <span class="comment1">(* Rewrite info of a term. *)</span>
  simp<span class="main">:</span> <span class="main">(</span><span class="main">(</span><span class="entity">box_id</span> * thm<span class="main">)</span> list<span class="main">)</span> Termtab.table<span class="main">,</span>
  <span class="comment1">(* Subterm rewrite info of a term. *)</span>
  subsimp<span class="main">:</span> <span class="main">(</span><span class="main">(</span><span class="entity">box_id</span> * thm<span class="main">)</span> list<span class="main">)</span> Termtab.table<span class="main">,</span>
  <span class="comment1">(* Reverse of subsimp. Head rep of a term. *)</span>
  reps<span class="main">:</span> <span class="main">(</span><span class="main">(</span><span class="entity">box_id</span> * thm<span class="main">)</span> list<span class="main">)</span> Termtab.table
<span class="main">}</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">REWRITE_TABLE</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="comment1">(* Construction and modification. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> clean_resolved<span class="main">:</span> <span class="entity">box_id</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span>
  <span class="keyword1"><span class="keyword">val</span></span> clear_incr<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span>

  <span class="comment1">(* contain table. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> add_contain<span class="main">:</span> cterm <span class="main">-&gt;</span> term <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span>
  <span class="keyword1"><span class="keyword">val</span></span> immediate_contains<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> cterm list

  <span class="comment1">(* terms table. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> in_table_raw_ids<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> <span class="entity">box_id</span> list
  <span class="keyword1"><span class="keyword">val</span></span> in_table_raw_for_id<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">box_id</span> * term <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> in_table_raw<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> add_term_raw<span class="main">:</span> <span class="entity">box_id</span> * cterm <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_all_terms<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> cterm list
  <span class="keyword1"><span class="keyword">val</span></span> get_all_id_terms<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * cterm<span class="main">)</span> list

  <span class="comment1">(* equiv table. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> add_equiv<span class="main">:</span> <span class="entity">box_id</span> * thm <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span>
  <span class="keyword1"><span class="keyword">val</span></span> equiv_neighs<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * thm<span class="main">)</span> list
  <span class="keyword1"><span class="keyword">val</span></span> get_all_equiv<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * thm<span class="main">)</span> list

  <span class="comment1">(* simp table. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> update_simp<span class="main">:</span> <span class="entity">box_id</span> * thm <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_rewrite_info<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> cterm <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * thm<span class="main">)</span> list
  <span class="keyword1"><span class="keyword">val</span></span> get_rewrite<span class="main">:</span> <span class="entity">box_id</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> cterm <span class="main">-&gt;</span> thm

  <span class="comment1">(* subsimp and rep tables. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_subterm_rewrite_info<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> cterm <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * thm<span class="main">)</span> list
  <span class="keyword1"><span class="keyword">val</span></span> remove_rep<span class="main">:</span> <span class="entity">box_id</span> * thm <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span>
  <span class="keyword1"><span class="keyword">val</span></span> update_subsimp<span class="main">:</span> <span class="entity">box_id</span> * thm <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_head_rep_info<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * thm<span class="main">)</span> list
  <span class="keyword1"><span class="keyword">val</span></span> get_head_rep<span class="main">:</span> <span class="entity">box_id</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> thm option
  <span class="keyword1"><span class="keyword">val</span></span> get_head_rep_with_id_th<span class="main">:</span>
      <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">box_id</span> * thm <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * thm<span class="main">)</span> list
  <span class="keyword1"><span class="keyword">val</span></span> get_cached_subterm_rewrite_info<span class="main">:</span>
      <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * thm<span class="main">)</span> list
  <span class="keyword1"><span class="keyword">val</span></span> get_cached_subterm_rewrite<span class="main">:</span> <span class="entity">box_id</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> cterm <span class="main">-&gt;</span> thm

  <span class="comment1">(* Simplification of arbitrary terms. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> head_simplify<span class="main">:</span> <span class="entity">box_id</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> cterm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> simplify<span class="main">:</span> <span class="entity">box_id</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> cterm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> subterm_simplify<span class="main">:</span> <span class="entity">box_id</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> cterm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> simp_val<span class="main">:</span> <span class="entity">box_id</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> cterm <span class="main">-&gt;</span> cterm
  <span class="keyword1"><span class="keyword">val</span></span> simp_val_t<span class="main">:</span> <span class="entity">box_id</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> simplify_info<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> cterm <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * thm<span class="main">)</span> list
  <span class="keyword1"><span class="keyword">val</span></span> subterm_simplify_info<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> cterm <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * thm<span class="main">)</span> list
  <span class="keyword1"><span class="keyword">val</span></span> is_equiv<span class="main">:</span> <span class="entity">box_id</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> cterm * cterm <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> is_equiv_t<span class="main">:</span> <span class="entity">box_id</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term * term <span class="main">-&gt;</span> bool

  <span class="comment1">(* Computation of head equiv. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_head_equiv<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> cterm <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * thm<span class="main">)</span> list
  <span class="keyword1"><span class="keyword">val</span></span> get_head_equiv_with_t<span class="main">:</span>
      <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">box_id</span> * cterm <span class="main">-&gt;</span> term <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * thm<span class="main">)</span> list

  <span class="comment1">(* Update of whole rewrite table. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> process_update_simp<span class="main">:</span> <span class="main">(</span><span class="entity">box_id</span> * thm<span class="main">)</span> list <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span>
  <span class="keyword1"><span class="keyword">val</span></span> equiv_info<span class="main">:</span>
      <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">box_id</span> <span class="main">-&gt;</span> cterm * cterm <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * thm<span class="main">)</span> list
  <span class="keyword1"><span class="keyword">val</span></span> equiv_info_t<span class="main">:</span>
      <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">box_id</span> <span class="main">-&gt;</span> term * term <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * thm<span class="main">)</span> list
  <span class="keyword1"><span class="keyword">val</span></span> subequiv_info<span class="main">:</span>
      <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">box_id</span> <span class="main">-&gt;</span> cterm * cterm <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * thm<span class="main">)</span> list
  <span class="keyword1"><span class="keyword">val</span></span> add_rewrite_raw<span class="main">:</span> <span class="entity">box_id</span> <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_reachable_terms<span class="main">:</span> bool <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> term list
  <span class="keyword1"><span class="keyword">val</span></span> complete_table<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * thm<span class="main">)</span> list * <span class="entity">Proof.context</span>
  <span class="keyword1"><span class="keyword">val</span></span> add_term<span class="main">:</span>
      <span class="entity">box_id</span> * cterm <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * thm<span class="main">)</span> list * <span class="entity">Proof.context</span>
  <span class="keyword1"><span class="keyword">val</span></span> add_term_list<span class="main">:</span>
      <span class="main">(</span><span class="entity">box_id</span> * cterm<span class="main">)</span> list <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * thm<span class="main">)</span> list * <span class="entity">Proof.context</span>
  <span class="keyword1"><span class="keyword">val</span></span> add_rewrite<span class="main">:</span>
      <span class="entity">box_id</span> * thm <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * thm<span class="main">)</span> list * <span class="entity">Proof.context</span>

  <span class="comment1">(* Updating rewrite table from list of (id, th) pairs. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_new_terms<span class="main">:</span> <span class="entity">Proof.context</span> * <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * cterm<span class="main">)</span> list
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">RewriteTable</span> <span class="main">:</span> <span class="entity">REWRITE_TABLE</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="comment1">(*** Initialization and modification of rewrite table ***)</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Data</span> <span class="main">=</span> Proof_Data
<span class="main">(</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">T</span> <span class="main">=</span> <span class="entity">rewrite_table</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">init</span> <span class="main">_</span> <span class="main">=</span> <span class="main">{</span>terms <span class="main">=</span> Termtab.empty<span class="main">,</span> equiv <span class="main">=</span> Termtab.empty<span class="main">,</span>
                all_equiv <span class="main">=</span> Termtab.empty<span class="main">,</span> contain <span class="main">=</span> Termtab.empty<span class="main">,</span>
                simp <span class="main">=</span> Termtab.empty<span class="main">,</span> subsimp <span class="main">=</span> Termtab.empty<span class="main">,</span>
                reps <span class="main">=</span> Termtab.empty<span class="main">}</span>
<span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">clean_resolved</span> <span class="entity">id</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">terms</span><span class="main">,</span> <span class="entity">equiv</span><span class="main">,</span> <span class="entity">all_equiv</span><span class="main">,</span> <span class="entity">contain</span><span class="main">,</span> <span class="entity">simp</span><span class="main">,</span> <span class="entity">subsimp</span><span class="main">,</span> <span class="entity">reps</span><span class="main">}</span> <span class="main">=</span>
          Data.get <span class="entity">ctxt</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">clean</span> <span class="entity">tb</span> <span class="entity">id_fun</span> <span class="main">=</span>
          <span class="entity">tb</span> |&gt; Termtab.map
             <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> filter_out <span class="main">(</span><span class="entity">BoxID.is_eq_ancestor</span> <span class="entity">ctxt</span> <span class="entity">id</span> o <span class="entity">id_fun</span><span class="main">)</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">clean_terms_1</span> <span class="main">(</span><span class="entity">ids</span><span class="main">,</span> <span class="entity">ct</span><span class="main">)</span> <span class="main">=</span>
          <span class="main">(</span>filter_out <span class="main">(</span><span class="entity">BoxID.is_eq_ancestor</span> <span class="entity">ctxt</span> <span class="entity">id</span><span class="main">)</span> <span class="entity">ids</span><span class="main">,</span> <span class="entity">ct</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">clean_terms</span> <span class="entity">tb</span> <span class="main">=</span>
          <span class="entity">tb</span> |&gt; Termtab.map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">clean_terms_1</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">ctxt</span> |&gt; Data.map <span class="main">(</span>
        K <span class="main">{</span>terms <span class="main">=</span> <span class="entity">clean_terms</span> <span class="entity">terms</span><span class="main">,</span> equiv <span class="main">=</span> <span class="entity">clean</span> <span class="entity">equiv</span> fst<span class="main">,</span>
           all_equiv <span class="main">=</span> <span class="entity">clean</span> <span class="entity">all_equiv</span> fst<span class="main">,</span>
           contain <span class="main">=</span> <span class="entity">contain</span><span class="main">,</span> simp <span class="main">=</span> <span class="entity">clean</span> <span class="entity">simp</span> fst<span class="main">,</span> subsimp <span class="main">=</span> <span class="entity">clean</span> <span class="entity">subsimp</span> fst<span class="main">,</span>
           reps <span class="main">=</span> <span class="entity">clean</span> <span class="entity">reps</span> fst<span class="main">}</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* equiv_eq_better ctxt info1 info2 means info2 is extraneous in the
   equiv table.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">equiv_eq_better</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">th'</span><span class="main">)</span> <span class="main">=</span>
    <span class="entity">Util.rhs_of</span> <span class="entity">th</span> aconv <span class="entity">Util.rhs_of</span> <span class="entity">th'</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">BoxID.is_eq_ancestor</span> <span class="entity">ctxt</span> <span class="entity">id</span> <span class="entity">id'</span>

<span class="comment1">(* simp_eq_better ctxt info1 info2 means info2 is extraneous in the
   simp table.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">simp_eq_better</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">th'</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">BoxID.is_eq_ancestor</span> <span class="entity">ctxt</span> <span class="entity">id</span> <span class="entity">id'</span> <span class="keyword2"><span class="keyword">then</span></span>
      <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">t'</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">Util.rhs_of</span> <span class="entity">th</span><span class="main">,</span> <span class="entity">Util.rhs_of</span> <span class="entity">th'</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">t</span> aconv <span class="entity">t'</span> <span class="keyword1"><span class="keyword">orelse</span></span> Term_Ord.term_ord <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">t'</span><span class="main">)</span> <span class="main">=</span> LESS <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">else</span></span> false

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">clear_incr</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">terms</span><span class="main">,</span> <span class="entity">equiv</span><span class="main">,</span> <span class="entity">all_equiv</span><span class="main">,</span> <span class="entity">contain</span><span class="main">,</span> <span class="entity">simp</span><span class="main">,</span> <span class="entity">subsimp</span><span class="main">,</span> <span class="entity">reps</span><span class="main">}</span> <span class="main">=</span>
          Data.get <span class="entity">ctxt</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">clear_one</span> <span class="entity">cmp</span> <span class="entity">infos</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">if</span></span> exists <span class="main">(</span><span class="entity">BoxID.has_incr_id</span> o fst<span class="main">)</span> <span class="entity">infos</span> <span class="keyword2"><span class="keyword">then</span></span>
            <span class="entity">infos</span> |&gt; map <span class="main">(</span>apfst <span class="entity">BoxID.replace_incr_id</span><span class="main">)</span>
                  |&gt; <span class="entity">Util.max_partial</span> <span class="entity">cmp</span>
          <span class="keyword2"><span class="keyword">else</span></span>
            <span class="entity">infos</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">clear</span> <span class="entity">cmp</span> <span class="entity">tb</span> <span class="main">=</span>
          <span class="entity">tb</span> |&gt; Termtab.map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">clear_one</span> <span class="entity">cmp</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">clear_term_one</span> <span class="main">(</span><span class="entity">ids</span><span class="main">,</span> <span class="entity">ct</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">if</span></span> exists <span class="entity">BoxID.has_incr_id</span> <span class="entity">ids</span> <span class="keyword2"><span class="keyword">then</span></span>
            <span class="main">(</span><span class="entity">ids</span> |&gt; map <span class="entity">BoxID.replace_incr_id</span>
                 |&gt; <span class="entity">Util.max_partial</span> <span class="main">(</span><span class="entity">BoxID.is_eq_ancestor</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">,</span> <span class="entity">ct</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">else</span></span>
            <span class="main">(</span><span class="entity">ids</span><span class="main">,</span> <span class="entity">ct</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">clear_term</span> <span class="entity">tb</span> <span class="main">=</span>
          <span class="entity">tb</span> |&gt; Termtab.map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">clear_term_one</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">ctxt</span> |&gt; Data.map <span class="main">(</span>
        K <span class="main">{</span>terms <span class="main">=</span> <span class="entity">clear_term</span> <span class="entity">terms</span><span class="main">,</span>
           equiv <span class="main">=</span> <span class="entity">clear</span> <span class="main">(</span><span class="entity">equiv_eq_better</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">equiv</span><span class="main">,</span>
           all_equiv <span class="main">=</span> <span class="entity">clear</span> <span class="main">(</span><span class="entity">equiv_eq_better</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">all_equiv</span><span class="main">,</span>
           contain <span class="main">=</span> <span class="entity">contain</span><span class="main">,</span>
           simp <span class="main">=</span> <span class="entity">clear</span> <span class="main">(</span><span class="entity">simp_eq_better</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">simp</span><span class="main">,</span>
           subsimp <span class="main">=</span> <span class="entity">clear</span> <span class="main">(</span><span class="entity">simp_eq_better</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">subsimp</span><span class="main">,</span>
           reps <span class="main">=</span> <span class="entity">clear</span> <span class="main">(</span><span class="entity">equiv_eq_better</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">reps</span><span class="main">}</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map_terms</span> <span class="entity">f</span> <span class="main">{</span><span class="entity">terms</span><span class="main">,</span> <span class="entity">equiv</span><span class="main">,</span> <span class="entity">all_equiv</span><span class="main">,</span> <span class="entity">contain</span><span class="main">,</span> <span class="entity">simp</span><span class="main">,</span> <span class="entity">subsimp</span><span class="main">,</span> <span class="entity">reps</span><span class="main">}</span> <span class="main">=</span>
    <span class="main">{</span>terms <span class="main">=</span> <span class="entity">f</span> <span class="entity">terms</span><span class="main">,</span> equiv <span class="main">=</span> <span class="entity">equiv</span><span class="main">,</span> all_equiv <span class="main">=</span> <span class="entity">all_equiv</span><span class="main">,</span>
     contain <span class="main">=</span> <span class="entity">contain</span><span class="main">,</span> simp <span class="main">=</span> <span class="entity">simp</span><span class="main">,</span> subsimp <span class="main">=</span> <span class="entity">subsimp</span><span class="main">,</span> reps <span class="main">=</span> <span class="entity">reps</span><span class="main">}</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map_equiv</span> <span class="entity">f</span> <span class="main">{</span><span class="entity">terms</span><span class="main">,</span> <span class="entity">equiv</span><span class="main">,</span> <span class="entity">all_equiv</span><span class="main">,</span> <span class="entity">contain</span><span class="main">,</span> <span class="entity">simp</span><span class="main">,</span> <span class="entity">subsimp</span><span class="main">,</span> <span class="entity">reps</span><span class="main">}</span> <span class="main">=</span>
    <span class="main">{</span>terms <span class="main">=</span> <span class="entity">terms</span><span class="main">,</span> equiv <span class="main">=</span> <span class="entity">f</span> <span class="entity">equiv</span><span class="main">,</span> all_equiv <span class="main">=</span> <span class="entity">all_equiv</span><span class="main">,</span>
     contain <span class="main">=</span> <span class="entity">contain</span><span class="main">,</span> simp <span class="main">=</span> <span class="entity">simp</span><span class="main">,</span> subsimp <span class="main">=</span> <span class="entity">subsimp</span><span class="main">,</span> reps <span class="main">=</span> <span class="entity">reps</span><span class="main">}</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map_all_equiv</span> <span class="entity">f</span> <span class="main">{</span><span class="entity">terms</span><span class="main">,</span> <span class="entity">equiv</span><span class="main">,</span> <span class="entity">all_equiv</span><span class="main">,</span> <span class="entity">contain</span><span class="main">,</span> <span class="entity">simp</span><span class="main">,</span> <span class="entity">subsimp</span><span class="main">,</span> <span class="entity">reps</span><span class="main">}</span> <span class="main">=</span>
    <span class="main">{</span>terms <span class="main">=</span> <span class="entity">terms</span><span class="main">,</span> equiv <span class="main">=</span> <span class="entity">equiv</span><span class="main">,</span> all_equiv <span class="main">=</span> <span class="entity">f</span> <span class="entity">all_equiv</span><span class="main">,</span>
     contain <span class="main">=</span> <span class="entity">contain</span><span class="main">,</span> simp <span class="main">=</span> <span class="entity">simp</span><span class="main">,</span> subsimp <span class="main">=</span> <span class="entity">subsimp</span><span class="main">,</span> reps <span class="main">=</span> <span class="entity">reps</span><span class="main">}</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map_contain</span> <span class="entity">f</span> <span class="main">{</span><span class="entity">terms</span><span class="main">,</span> <span class="entity">equiv</span><span class="main">,</span> <span class="entity">all_equiv</span><span class="main">,</span> <span class="entity">contain</span><span class="main">,</span> <span class="entity">simp</span><span class="main">,</span> <span class="entity">subsimp</span><span class="main">,</span> <span class="entity">reps</span><span class="main">}</span> <span class="main">=</span>
    <span class="main">{</span>terms <span class="main">=</span> <span class="entity">terms</span><span class="main">,</span> equiv <span class="main">=</span> <span class="entity">equiv</span><span class="main">,</span> all_equiv <span class="main">=</span> <span class="entity">all_equiv</span><span class="main">,</span>
     contain <span class="main">=</span> <span class="entity">f</span> <span class="entity">contain</span><span class="main">,</span> simp <span class="main">=</span> <span class="entity">simp</span><span class="main">,</span> subsimp <span class="main">=</span> <span class="entity">subsimp</span><span class="main">,</span> reps <span class="main">=</span> <span class="entity">reps</span><span class="main">}</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map_simp</span> <span class="entity">f</span> <span class="main">{</span><span class="entity">terms</span><span class="main">,</span> <span class="entity">equiv</span><span class="main">,</span> <span class="entity">all_equiv</span><span class="main">,</span> <span class="entity">contain</span><span class="main">,</span> <span class="entity">simp</span><span class="main">,</span> <span class="entity">subsimp</span><span class="main">,</span> <span class="entity">reps</span><span class="main">}</span> <span class="main">=</span>
    <span class="main">{</span>terms <span class="main">=</span> <span class="entity">terms</span><span class="main">,</span> equiv <span class="main">=</span> <span class="entity">equiv</span><span class="main">,</span> all_equiv <span class="main">=</span> <span class="entity">all_equiv</span><span class="main">,</span>
     contain <span class="main">=</span> <span class="entity">contain</span><span class="main">,</span> simp <span class="main">=</span> <span class="entity">f</span> <span class="entity">simp</span><span class="main">,</span> subsimp <span class="main">=</span> <span class="entity">subsimp</span><span class="main">,</span> reps <span class="main">=</span> <span class="entity">reps</span><span class="main">}</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map_subsimp</span> <span class="entity">f</span> <span class="main">{</span><span class="entity">terms</span><span class="main">,</span> <span class="entity">equiv</span><span class="main">,</span> <span class="entity">all_equiv</span><span class="main">,</span> <span class="entity">contain</span><span class="main">,</span> <span class="entity">simp</span><span class="main">,</span> <span class="entity">subsimp</span><span class="main">,</span> <span class="entity">reps</span><span class="main">}</span> <span class="main">=</span>
    <span class="main">{</span>terms <span class="main">=</span> <span class="entity">terms</span><span class="main">,</span> equiv <span class="main">=</span> <span class="entity">equiv</span><span class="main">,</span> all_equiv <span class="main">=</span> <span class="entity">all_equiv</span><span class="main">,</span>
     contain <span class="main">=</span> <span class="entity">contain</span><span class="main">,</span> simp <span class="main">=</span> <span class="entity">simp</span><span class="main">,</span> subsimp <span class="main">=</span> <span class="entity">f</span> <span class="entity">subsimp</span><span class="main">,</span> reps <span class="main">=</span> <span class="entity">reps</span><span class="main">}</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map_reps</span> <span class="entity">f</span> <span class="main">{</span><span class="entity">terms</span><span class="main">,</span> <span class="entity">equiv</span><span class="main">,</span> <span class="entity">all_equiv</span><span class="main">,</span> <span class="entity">contain</span><span class="main">,</span> <span class="entity">simp</span><span class="main">,</span> <span class="entity">subsimp</span><span class="main">,</span> <span class="entity">reps</span><span class="main">}</span> <span class="main">=</span>
    <span class="main">{</span>terms <span class="main">=</span> <span class="entity">terms</span><span class="main">,</span> equiv <span class="main">=</span> <span class="entity">equiv</span><span class="main">,</span> all_equiv <span class="main">=</span> <span class="entity">all_equiv</span><span class="main">,</span>
     contain <span class="main">=</span> <span class="entity">contain</span><span class="main">,</span> simp <span class="main">=</span> <span class="entity">simp</span><span class="main">,</span> subsimp <span class="main">=</span> <span class="entity">subsimp</span><span class="main">,</span> reps <span class="main">=</span> <span class="entity">f</span> <span class="entity">reps</span><span class="main">}</span>

<span class="comment1">(*** Basic manipulation of contain table. ***)</span>

<span class="comment1">(* Add the information that t contains subt directly. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_contain</span> <span class="entity">ct</span> <span class="entity">subt</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">contain</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> Data.get <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">contain_subt</span> <span class="main">=</span> the_default <span class="main">[</span><span class="main">]</span> <span class="main">(</span>Termtab.lookup <span class="entity">contain</span> <span class="entity">subt</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> member <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconvc<span class="main">)</span> <span class="entity">contain_subt</span> <span class="entity">ct</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">ctxt</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">ctxt</span> |&gt; Data.map <span class="main">(</span><span class="entity">map_contain</span> <span class="main">(</span>Termtab.update <span class="main">(</span><span class="entity">subt</span><span class="main">,</span>  <span class="entity">ct</span> :: <span class="entity">contain_subt</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Get all terms that directly contains t. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">immediate_contains</span> <span class="entity">ctxt</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">contain</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> Data.get <span class="entity">ctxt</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      the_default <span class="main">[</span><span class="main">]</span> <span class="main">(</span>Termtab.lookup <span class="entity">contain</span> <span class="entity">t</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(*** Basic manipulation of the terms table. ***)</span>

<span class="comment1">(* Return ids in which t is directly in table. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">in_table_raw_ids</span> <span class="entity">ctxt</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">terms</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> Data.get <span class="entity">ctxt</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> Termtab.lookup <span class="entity">terms</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
          NONE <span class="main">=&gt;</span> <span class="main">[</span><span class="main">]</span>
        <span class="main">|</span> SOME <span class="main">(</span><span class="entity">ids</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">ids</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Whether the term is present in table at the given id. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">in_table_raw_for_id</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span> <span class="main">=</span>
    exists <span class="main">(</span><span class="entity">BoxID.is_eq_descendent</span> <span class="entity">ctxt</span> <span class="entity">id</span><span class="main">)</span> <span class="main">(</span><span class="entity">in_table_raw_ids</span> <span class="entity">ctxt</span> <span class="entity">t</span><span class="main">)</span>

<span class="comment1">(* Whether the term is present at any id. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">in_table_raw</span> <span class="entity">ctxt</span> <span class="entity">t</span> <span class="main">=</span>
    length <span class="main">(</span><span class="entity">in_table_raw_ids</span> <span class="entity">ctxt</span> <span class="entity">t</span><span class="main">)</span> &gt; <span class="inner_numeral">0</span>

<span class="comment1">(* Add t to table at the given id. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_term_raw</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">ct</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Thm.term_of <span class="entity">ct</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prev_ids</span> <span class="main">=</span> <span class="entity">in_table_raw_ids</span> <span class="entity">ctxt</span> <span class="entity">t</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ids_t</span> <span class="main">=</span> <span class="main">(</span><span class="entity">id</span> :: <span class="entity">prev_ids</span><span class="main">)</span>
                      |&gt; <span class="entity">Util.max_partial</span> <span class="main">(</span><span class="entity">BoxID.is_eq_ancestor</span> <span class="entity">ctxt</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">ctxt</span> |&gt; Data.map <span class="main">(</span><span class="entity">map_terms</span> <span class="main">(</span>Termtab.update <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="main">(</span><span class="entity">ids_t</span><span class="main">,</span> <span class="entity">ct</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Return list of all terms (at any ids) present in table. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_all_terms</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">terms</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> Data.get <span class="entity">ctxt</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">ct</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">ct</span><span class="main">)</span> <span class="main">(</span>Termtab.dest <span class="entity">terms</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Return list of all terms with ids present in table. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_all_id_terms</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">terms</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> Data.get <span class="entity">ctxt</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      maps <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">(</span><span class="entity">ids</span><span class="main">,</span> <span class="entity">ct</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span> map <span class="main">(</span>rpair <span class="entity">ct</span><span class="main">)</span> <span class="entity">ids</span><span class="main">)</span>
           <span class="main">(</span>Termtab.dest <span class="entity">terms</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(*** Basic manipulation of equiv table. ***)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">has_equiv_eq_better</span> <span class="entity">ctxt</span> <span class="entity">infos</span> <span class="entity">info'</span> <span class="main">=</span>
    exists <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">info</span> <span class="main">=&gt;</span> <span class="entity">equiv_eq_better</span> <span class="entity">ctxt</span> <span class="entity">info</span> <span class="entity">info'</span><span class="main">)</span> <span class="entity">infos</span>

<span class="comment1">(* Add one way equivalence edge. Maintain the non-comparable property
   of the set of equivalence edges between any two nodes. cur_info is
   of form (id, t == t').
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_equiv_raw</span> <span class="main">(</span><span class="entity">cur_info</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">equiv</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> Data.get <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">Util.lhs_of</span> <span class="entity">th</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">equiv_t</span> <span class="main">=</span> the_default <span class="main">[</span><span class="main">]</span> <span class="main">(</span>Termtab.lookup <span class="entity">equiv</span> <span class="entity">t</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> exists <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">info</span> <span class="main">=&gt;</span> <span class="entity">equiv_eq_better</span> <span class="entity">ctxt</span> <span class="entity">info</span> <span class="entity">cur_info</span><span class="main">)</span> <span class="entity">equiv_t</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">ctxt</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">ctxt</span> |&gt; Data.map <span class="main">(</span><span class="entity">map_equiv</span> <span class="main">(</span>
          Termtab.update <span class="main">(</span>
            <span class="entity">t</span><span class="main">,</span> <span class="entity">equiv_t</span> |&gt; filter_out <span class="main">(</span><span class="entity">equiv_eq_better</span> <span class="entity">ctxt</span> <span class="entity">cur_info</span><span class="main">)</span>
                       |&gt; cons <span class="entity">cur_info</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Add the given equivalence edge. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_equiv</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span>not <span class="main">(</span><span class="entity">Util.lhs_of</span> <span class="entity">th</span> aconv <span class="entity">Util.rhs_of</span> <span class="entity">th</span><span class="main">)</span><span class="main">)</span> <span class="inner_quoted">"add_equiv: t == t'"</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">ctxt</span> |&gt; <span class="entity">add_equiv_raw</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span>
           |&gt; <span class="entity">add_equiv_raw</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">meta_sym</span> <span class="entity">th</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Get all edges coming from t in the equiv graph. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">equiv_neighs</span> <span class="entity">ctxt</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">equiv</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> Data.get <span class="entity">ctxt</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> Termtab.lookup <span class="entity">equiv</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
          NONE <span class="main">=&gt;</span> <span class="main">[</span><span class="main">]</span>
        <span class="main">|</span> SOME <span class="entity">infos</span> <span class="main">=&gt;</span> <span class="entity">infos</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_all_equiv</span> <span class="entity">ctxt</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">all_equiv</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> Data.get <span class="entity">ctxt</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      the <span class="main">(</span>Termtab.lookup <span class="entity">all_equiv</span> <span class="entity">t</span><span class="main">)</span>
      <span class="keyword3"><span class="keyword">handle</span></span> Option.Option <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"all_equiv: not found"</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(*** Basic manipulation of simp table. ***)</span>

<span class="comment1">(* Update rewrite of t under id to th: t == t'. Similar to
   add_equiv_raw.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">update_simp</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">simp</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> Data.get <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ct</span> <span class="main">=</span> Thm.lhs_of <span class="entity">th</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Thm.term_of <span class="entity">ct</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simp_t</span> <span class="main">=</span> the_default <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> Thm.reflexive <span class="entity">ct</span><span class="main">)</span><span class="main">]</span> <span class="main">(</span>Termtab.lookup <span class="entity">simp</span> <span class="entity">t</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> exists <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">info</span> <span class="main">=&gt;</span> <span class="entity">simp_eq_better</span> <span class="entity">ctxt</span> <span class="entity">info</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">)</span> <span class="entity">simp_t</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">ctxt</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="entity">ctxt</span> |&gt; Data.map <span class="main">(</span><span class="entity">map_simp</span> <span class="main">(</span>
          Termtab.update <span class="main">(</span>
            <span class="entity">t</span><span class="main">,</span> <span class="entity">simp_t</span> |&gt; filter_out <span class="main">(</span><span class="entity">simp_eq_better</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">)</span>
                      |&gt; cons <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Get the entire rewrite info of t as stored directly in
   table. Return as a list of (id, th) pairs.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_rewrite_info</span> <span class="entity">ctxt</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">simp</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> Data.get <span class="entity">ctxt</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> Termtab.lookup <span class="entity">simp</span> <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
          NONE <span class="main">=&gt;</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> Thm.reflexive <span class="entity">ct</span><span class="main">)</span><span class="main">]</span>
        <span class="main">|</span> SOME <span class="entity">infos</span> <span class="main">=&gt;</span> <span class="entity">infos</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Return the rewrite of t under a given id, as stored directly in
   table. Return t == t if not in table.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_rewrite</span> <span class="entity">id</span> <span class="entity">ctxt</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">get_rewrite_info</span> <span class="entity">ctxt</span> <span class="entity">ct</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> Thm.reflexive <span class="entity">ct</span>
      <span class="main">|</span> <span class="entity">ths'</span> <span class="main">=&gt;</span> <span class="entity">ths'</span> |&gt; filter <span class="main">(</span><span class="entity">BoxID.is_eq_descendent</span> <span class="entity">ctxt</span> <span class="entity">id</span> o fst<span class="main">)</span>
                     |&gt; map snd
                     |&gt; <span class="entity">Util.max</span> <span class="main">(</span>rev_order o <span class="entity">simp_ord</span><span class="main">)</span>

<span class="comment1">(*** Basic manipulation of subsimp and rep tables. ***)</span>

<span class="comment1">(* Given list of lists of simplifying infos indexed by term and then
   id, return simplifying infos indexed first by id and then term.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">merge_simp_infos</span> <span class="entity">ctxt</span> <span class="entity">lsts</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ids</span> <span class="main">=</span> map <span class="main">(</span>map fst<span class="main">)</span> <span class="entity">lsts</span> |&gt; <span class="entity">BoxID.get_all_merges</span> <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_for_id_lst</span> <span class="entity">id</span> <span class="entity">lst</span> <span class="main">=</span>
          <span class="entity">lst</span> |&gt; filter <span class="main">(</span><span class="entity">BoxID.is_eq_descendent</span> <span class="entity">ctxt</span> <span class="entity">id</span> o fst<span class="main">)</span>
              |&gt; map snd |&gt; <span class="entity">Util.max</span> <span class="main">(</span>rev_order o <span class="entity">simp_ord</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_for_id</span> <span class="entity">id</span> <span class="main">=</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> map <span class="main">(</span><span class="entity">get_for_id_lst</span> <span class="entity">id</span><span class="main">)</span> <span class="entity">lsts</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      map <span class="entity">get_for_id</span> <span class="entity">ids</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Get entire subterm rewrite info of t. Return as a list of (id,
   rewrite) pairs.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_subterm_rewrite_info</span> <span class="entity">ctxt</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">cf</span><span class="main">,</span> <span class="entity">subs</span><span class="main">)</span> <span class="main">=</span> Drule.strip_comb <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">subs</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> Thm.reflexive <span class="entity">ct</span><span class="main">)</span><span class="main">]</span> <span class="keyword2"><span class="keyword">else</span></span>
      <span class="main">(</span>map <span class="main">(</span><span class="entity">get_rewrite_info</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">subs</span><span class="main">)</span>
          |&gt; <span class="entity">merge_simp_infos</span> <span class="entity">ctxt</span>
          |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">equivs</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">Util.comb_equiv</span> <span class="main">(</span><span class="entity">cf</span><span class="main">,</span> <span class="entity">equivs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
          |&gt; <span class="entity">Util.max_partial</span> <span class="main">(</span><span class="entity">simp_eq_better</span> <span class="entity">ctxt</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Given a head rep (id, th) (where th is reverse of a subterm
   rewrite), remove th from the reps table.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">remove_rep</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">reps</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> Data.get <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">Util.lhs_of</span> <span class="entity">th</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">reps_t</span> <span class="main">=</span> the_default <span class="main">[</span><span class="main">]</span> <span class="main">(</span>Termtab.lookup <span class="entity">reps</span> <span class="entity">t</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span>member <span class="entity">eq_info</span> <span class="entity">reps_t</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">)</span> <span class="inner_quoted">"remove_rep: not found"</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">ctxt</span> |&gt; Data.map <span class="main">(</span><span class="entity">map_reps</span> <span class="main">(</span>Termtab.map_entry <span class="entity">t</span> <span class="main">(</span>remove <span class="entity">eq_info</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Update subterm rewrite of t under id to th: t == t'. Also update
   the reps table (reverse of subsimp table).
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">update_subsimp</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">subsimp</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> Data.get <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">t'</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">Util.lhs_of</span> <span class="entity">th</span><span class="main">,</span> <span class="entity">Util.rhs_of</span> <span class="entity">th</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">subsimp_t</span> <span class="main">=</span> the_default <span class="main">[</span><span class="main">]</span> <span class="main">(</span>Termtab.lookup <span class="entity">subsimp</span> <span class="entity">t</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> exists <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">info</span> <span class="main">=&gt;</span> <span class="entity">simp_eq_better</span> <span class="entity">ctxt</span> <span class="entity">info</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">)</span> <span class="entity">subsimp_t</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">ctxt</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th'</span> <span class="main">=</span> <span class="entity">meta_sym</span> <span class="entity">th</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">rem</span><span class="main">,</span> <span class="entity">keep</span><span class="main">)</span> <span class="main">=</span> <span class="entity">filter_split</span> <span class="main">(</span><span class="entity">simp_eq_better</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">)</span> <span class="entity">subsimp_t</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="entity">ctxt</span> |&gt; Data.map <span class="main">(</span><span class="entity">map_subsimp</span> <span class="main">(</span>Termtab.update <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> :: <span class="entity">keep</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
               |&gt; Data.map <span class="main">(</span><span class="entity">map_reps</span> <span class="main">(</span>Termtab.map_default <span class="main">(</span><span class="entity">t'</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="main">(</span>cons <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
               |&gt; fold <span class="entity">remove_rep</span> <span class="main">(</span>map <span class="main">(</span>apsnd <span class="entity">meta_sym</span><span class="main">)</span> <span class="entity">rem</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Returns the list of (id, th) pairs, where th is t == t', such that
   t' subterm rewrites to t at box id.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_head_rep_info</span> <span class="entity">ctxt</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">reps</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> Data.get <span class="entity">ctxt</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> Termtab.lookup <span class="entity">reps</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
          NONE <span class="main">=&gt;</span> <span class="main">[</span><span class="main">]</span>
        <span class="main">|</span> SOME <span class="entity">infos</span> <span class="main">=&gt;</span> <span class="entity">infos</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Assume t is subterm simplified under id. Return SOME (t == v) if v
   is a term in the rewrite table that is subterm rewrites to t, under
   the given id. If there is no such v, return NONE.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_head_rep</span> <span class="entity">id</span> <span class="entity">ctxt</span> <span class="entity">t</span> <span class="main">=</span>
    get_first <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">t'</span><span class="main">)</span> <span class="main">=&gt;</span>
                  <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">BoxID.is_eq_ancestor</span> <span class="entity">ctxt</span> <span class="entity">id'</span> <span class="entity">id</span> <span class="keyword2"><span class="keyword">then</span></span> SOME <span class="entity">t'</span> <span class="keyword2"><span class="keyword">else</span></span> NONE<span class="main">)</span>
              <span class="main">(</span><span class="entity">get_head_rep_info</span> <span class="entity">ctxt</span> <span class="entity">t</span><span class="main">)</span>

<span class="comment1">(* Returns head representations of the right side of th under id, or
   under more restrictive assumptions. Merge the equivalence theorems
   with th. Not guaranteed to be non-redundant.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_head_rep_with_id_th</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=</span>
    <span class="entity">get_head_rep_info</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">Util.rhs_of</span> <span class="entity">th</span><span class="main">)</span> |&gt; map <span class="main">(</span><span class="entity">BoxID.merge_eq_infos</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">)</span>

<span class="comment1">(* Using the subsimp table for subterm simplification. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_cached_subterm_rewrite_info</span> <span class="entity">ctxt</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">subsimp</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> Data.get <span class="entity">ctxt</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> Termtab.lookup <span class="entity">subsimp</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
          NONE <span class="main">=&gt;</span> <span class="main">[</span><span class="main">]</span>
        <span class="main">|</span> SOME <span class="entity">infos</span> <span class="main">=&gt;</span> <span class="entity">infos</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Obtain the subterm simplification of t under id, or a less
   restrictive assumption.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_cached_subterm_rewrite</span> <span class="entity">id</span> <span class="entity">ctxt</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">get_cached_subterm_rewrite_info</span> <span class="entity">ctxt</span> <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> Thm.reflexive <span class="entity">ct</span>
      <span class="main">|</span> <span class="entity">ths'</span> <span class="main">=&gt;</span> <span class="entity">ths'</span> |&gt; filter <span class="main">(</span><span class="entity">BoxID.is_eq_descendent</span> <span class="entity">ctxt</span> <span class="entity">id</span> o fst<span class="main">)</span>
                     |&gt; map snd
                     |&gt; <span class="entity">Util.max</span> <span class="main">(</span>rev_order o <span class="entity">simp_ord</span><span class="main">)</span>

<span class="comment1">(*** Simplification of terms not indexed in table. ***)</span>

<span class="comment1">(* Assume t is subterm simplified under id. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">head_simplify</span> <span class="entity">id</span> <span class="entity">ctxt</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">get_head_rep</span> <span class="entity">id</span> <span class="entity">ctxt</span> <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
        NONE <span class="main">=&gt;</span> Thm.reflexive <span class="entity">ct</span>
      <span class="main">|</span> SOME <span class="entity">th</span> <span class="main">=&gt;</span> <span class="entity">Util.transitive_list</span> <span class="main">[</span><span class="entity">th</span><span class="main">,</span> <span class="entity">get_rewrite</span> <span class="entity">id</span> <span class="entity">ctxt</span> <span class="main">(</span>Thm.rhs_of <span class="entity">th</span><span class="main">)</span><span class="main">]</span>

<span class="comment1">(* First simplify subterms, then simplify head. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">simplify</span> <span class="entity">id</span> <span class="entity">ctxt</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">in_table_raw</span> <span class="entity">ctxt</span> <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
      <span class="entity">get_rewrite</span> <span class="entity">id</span> <span class="entity">ctxt</span> <span class="entity">ct</span> <span class="keyword2"><span class="keyword">else</span></span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th</span> <span class="main">=</span> <span class="entity">subterm_simplify</span> <span class="entity">id</span> <span class="entity">ctxt</span> <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">Util.transitive_list</span> <span class="main">[</span><span class="entity">th</span><span class="main">,</span> <span class="entity">head_simplify</span> <span class="entity">id</span> <span class="entity">ctxt</span> <span class="main">(</span>Thm.rhs_of <span class="entity">th</span><span class="main">)</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Simplify subterms, but not head. *)</span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">subterm_simplify</span> <span class="entity">id</span> <span class="entity">ctxt</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">in_table_raw</span> <span class="entity">ctxt</span> <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
      <span class="entity">get_cached_subterm_rewrite</span> <span class="entity">id</span> <span class="entity">ctxt</span> <span class="entity">ct</span> <span class="keyword2"><span class="keyword">else</span></span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">cf</span><span class="main">,</span> <span class="entity">subs</span><span class="main">)</span> <span class="main">=</span> Drule.strip_comb <span class="entity">ct</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">equivs</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">simplify</span> <span class="entity">id</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">subs</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">Util.comb_equiv</span> <span class="main">(</span><span class="entity">cf</span><span class="main">,</span> <span class="entity">equivs</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Convenient function for getting simplified value. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">simp_val</span> <span class="entity">id</span> <span class="entity">ctxt</span> <span class="entity">ct</span> <span class="main">=</span> Thm.rhs_of <span class="main">(</span><span class="entity">simplify</span> <span class="entity">id</span> <span class="entity">ctxt</span> <span class="entity">ct</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">simp_val_t</span> <span class="entity">id</span> <span class="entity">ctxt</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="entity">Util.rhs_of</span> <span class="main">(</span><span class="entity">simplify</span> <span class="entity">id</span> <span class="entity">ctxt</span> <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span>

<span class="comment1">(* Get all simplifications and subterm-simplifications. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">simplify_info</span> <span class="entity">ctxt</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">in_table_raw</span> <span class="entity">ctxt</span> <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
      <span class="entity">get_rewrite_info</span> <span class="entity">ctxt</span> <span class="entity">ct</span> <span class="keyword2"><span class="keyword">else</span></span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">subterm_info</span> <span class="main">=</span> <span class="entity">subterm_simplify_info</span> <span class="entity">ctxt</span> <span class="entity">ct</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_rewrite_with_id_th</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">th'</span><span class="main">)</span> <span class="main">=</span>
          <span class="main">(</span><span class="entity">get_rewrite_info</span> <span class="entity">ctxt</span> <span class="main">(</span>Thm.rhs_of <span class="entity">th'</span><span class="main">)</span><span class="main">)</span>
              |&gt; map <span class="main">(</span><span class="entity">BoxID.merge_eq_infos</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">th'</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">head_info</span> <span class="main">=</span>
          <span class="entity">subterm_info</span> |&gt; maps <span class="main">(</span><span class="entity">get_head_rep_with_id_th</span> <span class="entity">ctxt</span><span class="main">)</span>
                       |&gt; <span class="entity">Util.max_partial</span> <span class="main">(</span><span class="entity">BoxID.id_is_eq_ancestor</span> <span class="entity">ctxt</span><span class="main">)</span>
                       |&gt; maps <span class="entity">get_rewrite_with_id_th</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">subterm_info</span> @ <span class="entity">head_info</span> |&gt; <span class="entity">Util.max_partial</span> <span class="main">(</span><span class="entity">simp_eq_better</span> <span class="entity">ctxt</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Note similarity with get_subterm_rewrite_info. *)</span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">subterm_simplify_info</span> <span class="entity">ctxt</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">in_table_raw</span> <span class="entity">ctxt</span> <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
      <span class="entity">get_cached_subterm_rewrite_info</span> <span class="entity">ctxt</span> <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">cf</span><span class="main">,</span> <span class="entity">subs</span><span class="main">)</span> <span class="main">=</span> Drule.strip_comb <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">subs</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> Thm.reflexive <span class="entity">ct</span><span class="main">)</span><span class="main">]</span> <span class="keyword2"><span class="keyword">else</span></span>
      <span class="main">(</span>map <span class="main">(</span><span class="entity">simplify_info</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">subs</span><span class="main">)</span>
          |&gt; <span class="entity">merge_simp_infos</span> <span class="entity">ctxt</span>
          |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">equivs</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">Util.comb_equiv</span> <span class="main">(</span><span class="entity">cf</span><span class="main">,</span> <span class="entity">equivs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
          |&gt; <span class="entity">Util.max_partial</span> <span class="main">(</span><span class="entity">simp_eq_better</span> <span class="entity">ctxt</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Exported equivalence function. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_equiv</span> <span class="entity">id</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">ct1</span><span class="main">,</span> <span class="entity">ct2</span><span class="main">)</span> <span class="main">=</span>
    <span class="entity">ct1</span> aconvc <span class="entity">ct2</span> <span class="keyword1"><span class="keyword">orelse</span></span> <span class="entity">simp_val</span> <span class="entity">id</span> <span class="entity">ctxt</span> <span class="entity">ct1</span> aconvc <span class="entity">simp_val</span> <span class="entity">id</span> <span class="entity">ctxt</span> <span class="entity">ct2</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_equiv_t</span> <span class="entity">id</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span>
    <span class="entity">t1</span> aconv <span class="entity">t2</span> <span class="keyword1"><span class="keyword">orelse</span></span> <span class="entity">is_equiv</span> <span class="entity">id</span> <span class="entity">ctxt</span> <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">t1</span><span class="main">,</span> Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">t2</span><span class="main">)</span>

<span class="comment1">(* No assumption on u. Get list of (id', u') pairs where id &lt;= id', u'
   is in the table equivalent to u under id', and the head of u' is
   the same as that for t. If (id1, u1) and (id2, u2) are such that
   id2 implies id1 and all arguments of u1, u2 are equivalent under
   t2, then (id2, u2) is not included in the results. This
   function is much faster when u is in table (uses get_all_equiv
   directly).
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_head_equiv</span> <span class="entity">ctxt</span> <span class="entity">cu</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">u</span> <span class="main">=</span> Thm.term_of <span class="entity">cu</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span>not <span class="main">(</span>Term.is_open <span class="entity">u</span><span class="main">)</span><span class="main">)</span> <span class="inner_quoted">"get_all_head_equivs: u is open"</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rep_eq_better</span> <span class="main">(</span><span class="entity">id1</span><span class="main">,</span> <span class="entity">th1</span><span class="main">)</span> <span class="main">(</span><span class="entity">id2</span><span class="main">,</span> <span class="entity">th2</span><span class="main">)</span> <span class="main">=</span>
          <span class="entity">BoxID.is_eq_ancestor</span> <span class="entity">ctxt</span> <span class="entity">id1</span> <span class="entity">id2</span> <span class="keyword1"><span class="keyword">andalso</span></span>
          <span class="entity">is_equiv</span> <span class="entity">id2</span> <span class="entity">ctxt</span> <span class="main">(</span>Thm.rhs_of <span class="entity">th1</span><span class="main">,</span> Thm.rhs_of <span class="entity">th2</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_all_equiv_under_id</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">th'</span><span class="main">)</span> <span class="main">=</span>
          <span class="main">(</span><span class="entity">get_all_equiv</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">Util.rhs_of</span> <span class="entity">th'</span><span class="main">)</span><span class="main">)</span>
              |&gt; map <span class="main">(</span><span class="entity">BoxID.merge_eq_infos</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">th'</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">in_table_raw</span> <span class="entity">ctxt</span> <span class="entity">u</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="comment1">(* Get all equivs from table. *)</span>
        <span class="entity">get_all_equiv</span> <span class="entity">ctxt</span> <span class="entity">u</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="entity">cu</span> |&gt; <span class="entity">subterm_simplify_info</span> <span class="entity">ctxt</span>
           |&gt; maps <span class="main">(</span><span class="entity">get_head_rep_with_id_th</span> <span class="entity">ctxt</span><span class="main">)</span>
           |&gt; <span class="entity">Util.max_partial</span> <span class="entity">rep_eq_better</span>
           |&gt; maps <span class="entity">get_all_equiv_under_id</span>
           |&gt; cons <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> Thm.reflexive <span class="entity">cu</span><span class="main">)</span>
           |&gt; <span class="entity">Util.max_partial</span> <span class="main">(</span><span class="entity">equiv_eq_better</span> <span class="entity">ctxt</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Get list of head equivs for cu, whose head agrees (or matches) with t. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_head_equiv_with_t</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">cu</span><span class="main">)</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_valid</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">if</span></span> Term.is_Var <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span> true
          <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> Term.is_Var <span class="main">(</span>Term.head_of <span class="entity">t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> true
          <span class="keyword2"><span class="keyword">else</span></span> Term.aconv_untyped <span class="main">(</span>Term.head_of <span class="main">(</span><span class="entity">Util.rhs_of</span> <span class="entity">th</span><span class="main">)</span><span class="main">,</span> Term.head_of <span class="entity">t</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">(</span><span class="entity">get_head_equiv</span> <span class="entity">ctxt</span> <span class="entity">cu</span><span class="main">)</span>
          |&gt; filter <span class="entity">is_valid</span>
          |&gt; <span class="entity">BoxID.merge_box_with_info</span> <span class="entity">ctxt</span> <span class="entity">id</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(*** Adding rewrite rules and maintain invariants of the table. ***)</span>

<span class="comment1">(* Work out all consequences of updating simps in the rewrite
   table. This includes updating simp of neighboring nodes, and
   updating simps / subsimps of nodes for which the current node is a
   subterm. inits is a list of simps to be added, where each element
   is of the form (id, t == t') updating simp of t. In this function
   we maintain a list of simplifications (to_process) that have been
   added to the table, but whose consequences (on neighboring terms
   and containing terms) need to be processed.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_update_simp</span> <span class="entity">inits</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">eq_update</span> <span class="main">(</span><span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">th'</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
          <span class="main">(</span><span class="entity">id</span> <span class="main">=</span> <span class="entity">id'</span> <span class="keyword1"><span class="keyword">andalso</span></span> Thm.prop_of <span class="entity">th</span> aconv Thm.prop_of <span class="entity">th'</span><span class="main">)</span>

      <span class="comment1">(* Add the simp (id, th) for the left side of th to the
         table. If (id, th) is not redundant, add (id, th) to the list
         of simps whose consequences need to be processed.
       *)</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_simp</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">(</span><span class="entity">to_process</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">simp_ord</span> <span class="main">(</span><span class="entity">th</span><span class="main">,</span> <span class="entity">get_rewrite</span> <span class="entity">id</span> <span class="entity">ctxt</span> <span class="main">(</span>Thm.lhs_of <span class="entity">th</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> LESS <span class="keyword2"><span class="keyword">then</span></span>
            <span class="main">(</span>insert <span class="entity">eq_update</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="entity">to_process</span><span class="main">,</span> <span class="entity">update_simp</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="entity">ctxt</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">else</span></span>
            <span class="main">(</span><span class="entity">to_process</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span>

      <span class="comment1">(* Recompute subterm simplifications of t. Update the subsimp
         table as well as the simp table (in the latter case possibly
         adding to the to_process list.
       *)</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_term</span> <span class="entity">ct</span> <span class="main">(</span><span class="entity">to_process</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">subsimps</span> <span class="main">=</span> <span class="entity">get_subterm_rewrite_info</span> <span class="entity">ctxt</span> <span class="entity">ct</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt'</span> <span class="main">=</span> fold <span class="entity">update_subsimp</span> <span class="entity">subsimps</span> <span class="entity">ctxt</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            fold <span class="entity">process_simp</span> <span class="entity">subsimps</span> <span class="main">(</span><span class="entity">to_process</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>

      <span class="comment1">(* Pull the first item of to_process and work out its
         consequences.
       *)</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">update_step</span> <span class="main">(</span><span class="entity">to_process</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">to_process</span> <span class="keyword2"><span class="keyword">of</span></span>
              <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span>
            <span class="main">|</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> :: <span class="entity">rest</span> <span class="main">=&gt;</span>
              <span class="keyword2"><span class="keyword">let</span></span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">Util.lhs_of</span> <span class="entity">th</span>
                <span class="comment1">(* th: t == simp_t, th': t = t', result: t' = simp_t. *)</span>
                <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_neigh</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">th'</span><span class="main">)</span> <span class="main">=</span>
                    <span class="entity">BoxID.merge_eq_infos</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">meta_sym</span> <span class="entity">th'</span><span class="main">)</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">new_simp</span> <span class="main">=</span> map <span class="entity">process_neigh</span> <span class="main">(</span><span class="entity">equiv_neighs</span> <span class="entity">ctxt</span> <span class="entity">t</span><span class="main">)</span>
              <span class="keyword2"><span class="keyword">in</span></span>
                <span class="main">(</span><span class="entity">rest</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span> |&gt; fold <span class="entity">process_simp</span> <span class="entity">new_simp</span>
                             |&gt; fold <span class="entity">process_term</span> <span class="main">(</span><span class="entity">immediate_contains</span> <span class="entity">ctxt</span> <span class="entity">t</span><span class="main">)</span>
                             |&gt; <span class="entity">update_step</span>
              <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span> |&gt; fold <span class="entity">process_simp</span> <span class="entity">inits</span> |&gt; <span class="entity">update_step</span> |&gt; snd
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Return list of ids that are descendents of id at which t1 and t2
   are equiv.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">equiv_info</span> <span class="entity">ctxt</span> <span class="entity">id</span> <span class="main">(</span><span class="entity">ct1</span><span class="main">,</span> <span class="entity">ct2</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simp1</span> <span class="main">=</span> <span class="entity">simplify_info</span> <span class="entity">ctxt</span> <span class="entity">ct1</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simp2</span> <span class="main">=</span> <span class="entity">simplify_info</span> <span class="entity">ctxt</span> <span class="entity">ct2</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">compare</span> <span class="main">(</span><span class="entity">id1</span><span class="main">,</span> <span class="entity">th1</span><span class="main">)</span> <span class="main">(</span><span class="entity">id2</span><span class="main">,</span> <span class="entity">th2</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">Util.rhs_of</span> <span class="entity">th1</span> aconv <span class="entity">Util.rhs_of</span> <span class="entity">th2</span> <span class="keyword2"><span class="keyword">then</span></span>
            <span class="main">[</span><span class="main">(</span><span class="entity">BoxID.merge_boxes</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id1</span><span class="main">,</span> <span class="entity">id2</span><span class="main">)</span><span class="main">,</span> <span class="entity">Util.transitive_list</span> <span class="main">[</span><span class="entity">th1</span><span class="main">,</span> <span class="entity">meta_sym</span> <span class="entity">th2</span><span class="main">]</span><span class="main">)</span><span class="main">]</span>
          <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">(</span>maps <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">s1</span> <span class="main">=&gt;</span> maps <span class="main">(</span><span class="entity">compare</span> <span class="entity">s1</span><span class="main">)</span> <span class="entity">simp2</span><span class="main">)</span> <span class="entity">simp1</span><span class="main">)</span>
          |&gt; <span class="entity">BoxID.merge_box_with_info</span> <span class="entity">ctxt</span> <span class="entity">id</span>
          |&gt; <span class="entity">Util.max_partial</span> <span class="main">(</span><span class="entity">BoxID.id_is_eq_ancestor</span> <span class="entity">ctxt</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">equiv_info_t</span> <span class="entity">ctxt</span> <span class="entity">id</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span>
    <span class="entity">equiv_info</span> <span class="entity">ctxt</span> <span class="entity">id</span> <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">t1</span><span class="main">,</span> Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">t2</span><span class="main">)</span>

<span class="comment1">(* Return list of ids that are descendents of id at which t1 and t2
   are subterm equiv.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">subequiv_info</span> <span class="entity">ctxt</span> <span class="entity">id</span> <span class="main">(</span><span class="entity">ct1</span><span class="main">,</span> <span class="entity">ct2</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span><span class="main">(</span>Term.head_of <span class="main">(</span>Thm.term_of <span class="entity">ct1</span><span class="main">)</span><span class="main">)</span>
                aconv Term.head_of <span class="main">(</span>Thm.term_of <span class="entity">ct2</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simp1</span> <span class="main">=</span> <span class="entity">subterm_simplify_info</span> <span class="entity">ctxt</span> <span class="entity">ct1</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simp2</span> <span class="main">=</span> <span class="entity">subterm_simplify_info</span> <span class="entity">ctxt</span> <span class="entity">ct2</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">compare</span> <span class="main">(</span><span class="entity">id1</span><span class="main">,</span> <span class="entity">th1</span><span class="main">)</span> <span class="main">(</span><span class="entity">id2</span><span class="main">,</span> <span class="entity">th2</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">Util.rhs_of</span> <span class="entity">th1</span> aconv <span class="entity">Util.rhs_of</span> <span class="entity">th2</span> <span class="keyword2"><span class="keyword">then</span></span>
            <span class="main">[</span><span class="main">(</span><span class="entity">BoxID.merge_boxes</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id1</span><span class="main">,</span> <span class="entity">id2</span><span class="main">)</span><span class="main">,</span>
              <span class="entity">Util.transitive_list</span> <span class="main">[</span><span class="entity">th1</span><span class="main">,</span> <span class="entity">meta_sym</span> <span class="entity">th2</span><span class="main">]</span><span class="main">)</span><span class="main">]</span>
          <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">(</span>maps <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">s1</span> <span class="main">=&gt;</span> maps <span class="main">(</span><span class="entity">compare</span> <span class="entity">s1</span><span class="main">)</span> <span class="entity">simp2</span><span class="main">)</span> <span class="entity">simp1</span><span class="main">)</span>
          |&gt; <span class="entity">BoxID.merge_box_with_info</span> <span class="entity">ctxt</span> <span class="entity">id</span>
          |&gt; <span class="entity">Util.max_partial</span> <span class="main">(</span><span class="entity">BoxID.id_is_eq_ancestor</span> <span class="entity">ctxt</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Get list of terms reachable from the terms ts. If trav_contains =
   false, only travel along equiv edges. Otherwise also travel from t
   to any term containing t.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_reachable_terms</span> <span class="entity">trav_contains</span> <span class="entity">ctxt</span> <span class="entity">ts</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">helper</span> <span class="main">(</span><span class="entity">new</span><span class="main">,</span> <span class="entity">all</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">new</span> <span class="keyword2"><span class="keyword">of</span></span>
              <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">all</span><span class="main">)</span>
            <span class="main">|</span> <span class="entity">t</span> :: <span class="entity">rest</span> <span class="main">=&gt;</span>
              <span class="keyword2"><span class="keyword">let</span></span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">contains</span> <span class="main">=</span>
                    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">trav_contains</span> <span class="keyword2"><span class="keyword">then</span></span>
                      map Thm.term_of <span class="main">(</span><span class="entity">immediate_contains</span> <span class="entity">ctxt</span> <span class="entity">t</span><span class="main">)</span>
                    <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="main">]</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">neighs</span> <span class="main">=</span> <span class="main">(</span><span class="entity">equiv_neighs</span> <span class="entity">ctxt</span> <span class="entity">t</span><span class="main">)</span>
                                 |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">Util.rhs_of</span> <span class="entity">th</span><span class="main">)</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">new'</span> <span class="main">=</span> <span class="main">(</span><span class="entity">contains</span> @ <span class="entity">neighs</span><span class="main">)</span>
                               |&gt; distinct <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv<span class="main">)</span>
                               |&gt; subtract <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv<span class="main">)</span> <span class="entity">all</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all'</span> <span class="main">=</span> <span class="entity">new'</span> @ <span class="entity">all</span>
              <span class="keyword2"><span class="keyword">in</span></span>
                <span class="entity">helper</span> <span class="main">(</span><span class="entity">rest</span> @ <span class="entity">new'</span><span class="main">,</span> <span class="entity">all'</span><span class="main">)</span>
              <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">in</span></span>
      snd <span class="main">(</span><span class="entity">helper</span> <span class="main">(</span><span class="entity">ts</span><span class="main">,</span> <span class="entity">ts</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_all_equiv_raw</span> <span class="main">(</span><span class="entity">cur_info</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">all_equiv</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> Data.get <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">Util.lhs_of</span> <span class="entity">th</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">equiv_t</span> <span class="main">=</span> the_default <span class="main">[</span><span class="main">]</span> <span class="main">(</span>Termtab.lookup <span class="entity">all_equiv</span> <span class="entity">t</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> exists <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">info</span> <span class="main">=&gt;</span> <span class="entity">equiv_eq_better</span> <span class="entity">ctxt</span> <span class="entity">info</span> <span class="entity">cur_info</span><span class="main">)</span> <span class="entity">equiv_t</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">ctxt</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">ctxt</span> |&gt; Data.map <span class="main">(</span><span class="entity">map_all_equiv</span> <span class="main">(</span>
          Termtab.update <span class="main">(</span>
            <span class="entity">t</span><span class="main">,</span> <span class="entity">equiv_t</span> |&gt; filter_out <span class="main">(</span><span class="entity">equiv_eq_better</span> <span class="entity">ctxt</span> <span class="entity">cur_info</span><span class="main">)</span>
                       |&gt; cons <span class="entity">cur_info</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">update_all_equiv</span> <span class="entity">id</span> <span class="entity">th</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">ct1</span><span class="main">,</span> <span class="entity">ct2</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Thm.lhs_of <span class="entity">th</span><span class="main">,</span> Thm.rhs_of <span class="entity">th</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t1_equiv</span> <span class="main">=</span> <span class="entity">get_all_equiv</span> <span class="entity">ctxt</span> <span class="main">(</span>Thm.term_of <span class="entity">ct1</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t2_equiv</span> <span class="main">=</span> <span class="entity">get_all_equiv</span> <span class="entity">ctxt</span> <span class="main">(</span>Thm.term_of <span class="entity">ct2</span><span class="main">)</span>

      <span class="comment1">(* eq1 is t1 == t1', eq2 is t2 == t2', add t1' == t2' and t2' ==
         t1' to all_equiv.
       *)</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_pair</span> <span class="main">(</span><span class="main">(</span><span class="entity">id1</span><span class="main">,</span> <span class="entity">eq1</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">id2</span><span class="main">,</span> <span class="entity">eq2</span><span class="main">)</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">id'</span> <span class="main">=</span> <span class="entity">BoxID.merge_boxes</span>
                          <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">BoxID.merge_boxes</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id1</span><span class="main">,</span> <span class="entity">id2</span><span class="main">)</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq</span> <span class="main">=</span> <span class="entity">Util.transitive_list</span> <span class="main">[</span><span class="entity">meta_sym</span> <span class="entity">eq1</span><span class="main">,</span> <span class="entity">th</span><span class="main">,</span> <span class="entity">eq2</span><span class="main">]</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="entity">ctxt</span> |&gt; <span class="entity">add_all_equiv_raw</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">eq</span><span class="main">)</span>
                 |&gt; <span class="entity">add_all_equiv_raw</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">meta_sym</span> <span class="entity">eq</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">in</span></span>
      fold <span class="entity">process_pair</span> <span class="main">(</span><span class="entity">Util.all_pairs</span> <span class="main">(</span><span class="entity">t1_equiv</span><span class="main">,</span> <span class="entity">t2_equiv</span><span class="main">)</span><span class="main">)</span> <span class="entity">ctxt</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Assume t1 and t2 are already in table. Add equiv edge th: t1 == t2 and
   work out all the consequences.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_rewrite_raw</span> <span class="entity">id</span> <span class="entity">th</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">ct1</span><span class="main">,</span> <span class="entity">ct2</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Thm.lhs_of <span class="entity">th</span><span class="main">,</span> Thm.rhs_of <span class="entity">th</span><span class="main">)</span>

      <span class="comment1">(* New simplifications. *)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t1_rinfo</span> <span class="main">=</span> <span class="entity">get_rewrite_info</span> <span class="entity">ctxt</span> <span class="entity">ct1</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t2_rinfo</span> <span class="main">=</span> <span class="entity">get_rewrite_info</span> <span class="entity">ctxt</span> <span class="entity">ct2</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t1_news</span> <span class="main">=</span> <span class="entity">t2_rinfo</span> |&gt; map <span class="main">(</span><span class="entity">BoxID.merge_eq_infos</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t2_news</span> <span class="main">=</span> <span class="entity">t1_rinfo</span> |&gt; map <span class="main">(</span><span class="entity">BoxID.merge_eq_infos</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">meta_sym</span> <span class="entity">th</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">ctxt</span> |&gt; <span class="entity">add_equiv</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span>
           |&gt; <span class="entity">process_update_simp</span> <span class="main">(</span><span class="entity">t1_news</span> @ <span class="entity">t2_news</span><span class="main">)</span>
           |&gt; <span class="entity">update_all_equiv</span> <span class="entity">id</span> <span class="entity">th</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Add equiv edges so the rewrite table is consistent. That is, any two nodes that
   have the same simp should be connected in the equiv graph. Also
   return the list of equiv edges added.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">complete_table</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">find_new_equiv</span> <span class="entity">ct</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">equivs</span> <span class="main">=</span> <span class="entity">get_all_equiv</span> <span class="entity">ctxt</span> <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="main">(</span><span class="entity">get_subterm_rewrite_info</span> <span class="entity">ctxt</span> <span class="entity">ct</span><span class="main">)</span>
                |&gt; maps <span class="main">(</span><span class="entity">get_head_rep_with_id_th</span> <span class="entity">ctxt</span><span class="main">)</span>
                |&gt; <span class="entity">Util.max_partial</span> <span class="main">(</span><span class="entity">equiv_eq_better</span> <span class="entity">ctxt</span><span class="main">)</span>
                |&gt; filter_out <span class="main">(</span><span class="entity">has_equiv_eq_better</span> <span class="entity">ctxt</span> <span class="entity">equivs</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">new_equivs</span> <span class="main">=</span> <span class="main">(</span>maps <span class="entity">find_new_equiv</span> <span class="main">(</span><span class="entity">get_all_terms</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span>
                           |&gt; <span class="entity">Util.max_partial</span> <span class="main">(</span><span class="entity">BoxID.id_is_eq_ancestor</span> <span class="entity">ctxt</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">new_equivs</span> <span class="keyword2"><span class="keyword">of</span></span>
          <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span>
        <span class="main">|</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> :: <span class="main">_</span> <span class="main">=&gt;</span>
          <span class="comment1">(* Add bi-directional edges for terms with the same subterm
             simplification. Keep track of list of edges added.
           *)</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt'</span> <span class="main">=</span> <span class="entity">ctxt</span> |&gt; <span class="entity">add_rewrite_raw</span> <span class="entity">id</span> <span class="entity">th</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">edges</span><span class="main">,</span> <span class="entity">ctxt''</span><span class="main">)</span> <span class="main">=</span> <span class="entity">complete_table</span> <span class="entity">ctxt'</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="main">(</span><span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> :: <span class="entity">edges</span><span class="main">,</span> <span class="entity">ctxt''</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Add term t to rewrite table at box id. The primed version (used in
   add_rewrite_thm) add t and all its subterms to the table. The
   unprimed version also add new equiv edges if necessary, resulting
   is a consistent rewrite table.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_term'</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">ct</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">in_table_raw_for_id</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> Thm.term_of <span class="entity">ct</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">ctxt</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
      <span class="comment1">(* First add subterms. *)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Thm.term_of <span class="entity">ct</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">imm_subterms</span> <span class="main">=</span> <span class="entity">UtilLogic.list_subterms</span> <span class="entity">t</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">id_subs</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span> <span class="entity">imm_subterms</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt'</span> <span class="main">=</span> <span class="entity">ctxt</span> |&gt; fold <span class="entity">add_term'</span> <span class="entity">id_subs</span> |&gt; <span class="entity">add_term_raw</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">ct</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="comment1">(* If t is already in table (just not at id), then we are
         done. Otherwise compute all indexed info for t.
       *)</span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">in_table_raw</span> <span class="entity">ctxt</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">ctxt'</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
        <span class="comment1">(* Compute simplification and properties of t. Note we are
           doing this in box [] (not id), so it does not need to be
           recomputed if a term is added to a more general box.
         *)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simps</span> <span class="main">=</span> <span class="entity">get_subterm_rewrite_info</span> <span class="entity">ctxt'</span> <span class="entity">ct</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="entity">ctxt'</span> |&gt; fold <span class="main">(</span><span class="entity">add_contain</span> <span class="entity">ct</span><span class="main">)</span> <span class="entity">imm_subterms</span>
              |&gt; fold <span class="entity">update_simp</span> <span class="entity">simps</span>
              |&gt; fold <span class="entity">update_subsimp</span> <span class="entity">simps</span>
              |&gt; <span class="entity">add_all_equiv_raw</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> Thm.reflexive <span class="entity">ct</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_term</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">ct</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">in_table_raw_for_id</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> Thm.term_of <span class="entity">ct</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">ctxt</span> |&gt; <span class="entity">add_term'</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">ct</span><span class="main">)</span> |&gt; <span class="entity">complete_table</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_term_list</span> <span class="entity">term_infos</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">term_infos</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span>
      <span class="main">|</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">ct</span><span class="main">)</span> :: <span class="entity">rest</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">edges</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">add_term</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">ct</span><span class="main">)</span> <span class="entity">ctxt</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">edges'</span><span class="main">,</span> <span class="entity">ctxt''</span><span class="main">)</span> <span class="main">=</span> <span class="entity">add_term_list</span> <span class="entity">rest</span> <span class="entity">ctxt'</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="main">(</span><span class="entity">edges</span> @ <span class="entity">edges'</span><span class="main">,</span> <span class="entity">ctxt''</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* First make sure t1 and t2 are in table. Add t1 == t2 to the table,
   and work out any consequences. The result is a consistent rewrite
   table.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_rewrite</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">eq_th</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="comment1">(* eq_th is meta-equality when between lambda terms. *)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">meta_eq</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">Util.is_meta_eq</span> <span class="main">(</span>Thm.prop_of <span class="entity">eq_th</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">eq_th</span>
                    <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">to_meta_eq</span> <span class="entity">eq_th</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">ct1</span><span class="main">,</span> <span class="entity">ct2</span><span class="main">)</span> <span class="main">=</span> <span class="entity">meta_eq</span> |&gt; Thm.cprop_of |&gt; Thm.dest_equals
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_equiv</span> <span class="entity">id</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">ct1</span><span class="main">,</span> <span class="entity">ct2</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="entity">ctxt</span> |&gt; <span class="entity">add_term'</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">ct1</span><span class="main">)</span> |&gt; <span class="entity">add_term'</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">ct2</span><span class="main">)</span>
             |&gt; <span class="entity">add_rewrite_raw</span> <span class="entity">id</span> <span class="entity">meta_eq</span>
             |&gt; <span class="entity">complete_table</span>
             |&gt; apfst <span class="main">(</span>cons <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">meta_eq</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Returns the list of terms in ctxt' that is not in ctxt. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_new_terms</span> <span class="main">(</span><span class="entity">ctxt</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_for_term</span> <span class="entity">ct</span> <span class="main">=</span>
          <span class="main">(</span><span class="entity">in_table_raw_ids</span> <span class="entity">ctxt'</span> <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span><span class="main">)</span>
              |&gt; filter_out <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">id</span> <span class="main">=&gt;</span> <span class="entity">in_table_raw_for_id</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> Thm.term_of <span class="entity">ct</span><span class="main">)</span><span class="main">)</span>
              |&gt; map <span class="main">(</span>rpair <span class="entity">ct</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      maps <span class="entity">get_for_term</span> <span class="main">(</span><span class="entity">get_all_terms</span> <span class="entity">ctxt'</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>  <span class="comment1">(* structure RewriteTable. *)</span>
</pre>
</div><div id="files/AFP/Auto2_HOL/propertydata.ML">
<div class="head">
<h1>File ‹$AFP/Auto2_HOL/propertydata.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*
  File: propertydata.ML
  Author: Bohua Zhan

  Table maintaining list of properties satisfied by terms currently
  appearing in the proof.

  Under each key t, maintain a list of (id, th), where th is of the
  form P(t), with P a registered property constant.
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">PROPERTY_DATA</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> clean_resolved<span class="main">:</span> <span class="entity">box_id</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span>
  <span class="keyword1"><span class="keyword">val</span></span> clear_incr<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span>

  <span class="keyword1"><span class="keyword">val</span></span> get_property_for_term<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * thm<span class="main">)</span> list
  <span class="keyword1"><span class="keyword">val</span></span> add_property_raw<span class="main">:</span> <span class="entity">box_id</span> * thm <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span>
  <span class="keyword1"><span class="keyword">val</span></span> convert_property<span class="main">:</span>
      <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">box_id</span> * thm <span class="main">-&gt;</span> <span class="entity">box_id</span> * thm <span class="main">-&gt;</span> <span class="entity">box_id</span> * thm

  <span class="keyword1"><span class="keyword">val</span></span> get_property<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">box_id</span> * cterm <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * thm<span class="main">)</span> list
  <span class="keyword1"><span class="keyword">val</span></span> get_property_t<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">box_id</span> * term <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * thm<span class="main">)</span> list
  <span class="keyword1"><span class="keyword">val</span></span> apply_property_update_rule<span class="main">:</span>
      <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">box_id</span> <span class="main">-&gt;</span> thm option <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * thm<span class="main">)</span> list
  <span class="keyword1"><span class="keyword">val</span></span> apply_property_update_on_term<span class="main">:</span>
      <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">box_id</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * thm<span class="main">)</span> list
  <span class="keyword1"><span class="keyword">val</span></span> process_update_property<span class="main">:</span>
      <span class="main">(</span><span class="entity">box_id</span> * thm<span class="main">)</span> list <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span>
  <span class="keyword1"><span class="keyword">val</span></span> process_rewrite_property<span class="main">:</span> <span class="entity">box_id</span> * thm <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span>
  <span class="keyword1"><span class="keyword">val</span></span> add_property<span class="main">:</span> <span class="entity">box_id</span> * thm <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_new_property<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * thm<span class="main">)</span> list
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">PropertyData</span> <span class="main">:</span> <span class="entity">PROPERTY_DATA</span> <span class="main">=</span>

<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Data</span> <span class="main">=</span> Proof_Data
<span class="main">(</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">T</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="entity">box_id</span> * thm<span class="main">)</span> list<span class="main">)</span> Termtab.table
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">init</span> <span class="main">_</span> <span class="main">=</span> Termtab.empty
<span class="main">)</span>

<span class="comment1">(* Remove all entries at or below id. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">clean_resolved</span> <span class="entity">id</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">clean_property</span> <span class="entity">tb</span> <span class="main">=</span>
          <span class="entity">tb</span> |&gt; Termtab.map
             <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> filter_out <span class="main">(</span><span class="entity">BoxID.is_eq_ancestor</span> <span class="entity">ctxt</span> <span class="entity">id</span> o fst<span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">ctxt</span> |&gt; Data.map <span class="entity">clean_property</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">clear_incr</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">clear_one</span> <span class="entity">infos</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">if</span></span> exists <span class="main">(</span><span class="entity">BoxID.has_incr_id</span> o fst<span class="main">)</span> <span class="entity">infos</span> <span class="keyword2"><span class="keyword">then</span></span>
            <span class="entity">infos</span> |&gt; map <span class="main">(</span>apfst <span class="entity">BoxID.replace_incr_id</span><span class="main">)</span>
                  |&gt; <span class="entity">Util.max_partial</span> <span class="main">(</span><span class="entity">BoxID.info_eq_better</span> <span class="entity">ctxt</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">else</span></span>
            <span class="entity">infos</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">ctxt</span> |&gt; Data.map <span class="main">(</span>Termtab.map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">clear_one</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Retrieve the current list of properties for a term t. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_property_for_term</span> <span class="entity">ctxt</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">property</span> <span class="main">=</span> Data.get <span class="entity">ctxt</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      the_default <span class="main">[</span><span class="main">]</span> <span class="main">(</span>Termtab.lookup <span class="entity">property</span> <span class="entity">t</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Add a new property. Similar to add_equiv_raw. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_property_raw</span> <span class="main">(</span><span class="entity">cur_info</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">Property.get_property_arg</span> <span class="main">(</span><span class="entity">prop_of'</span> <span class="entity">th</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">props</span> <span class="main">=</span> <span class="entity">get_property_for_term</span> <span class="entity">ctxt</span> <span class="entity">t</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> exists <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">info</span> <span class="main">=&gt;</span> <span class="entity">BoxID.info_eq_better</span> <span class="entity">ctxt</span> <span class="entity">info</span> <span class="entity">cur_info</span><span class="main">)</span> <span class="entity">props</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="entity">ctxt</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">props'</span> <span class="main">=</span> <span class="entity">props</span> |&gt; filter_out <span class="main">(</span><span class="entity">BoxID.info_eq_better</span> <span class="entity">ctxt</span> <span class="entity">cur_info</span><span class="main">)</span>
                             |&gt; cons <span class="entity">cur_info</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="entity">ctxt</span> |&gt; Data.map <span class="main">(</span>Termtab.update <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">props'</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Given th of the form P(s), and eq_th of the form s == t, return
   P(t). Merge boxes corresponding to the two theorems.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">convert_property</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">eq_th</span><span class="main">)</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=</span>
    <span class="main">(</span><span class="entity">BoxID.merge_boxes</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">id'</span><span class="main">)</span><span class="main">,</span>
     <span class="entity">th</span> |&gt; <span class="entity">apply_to_thm'</span> <span class="main">(</span>Conv.arg_conv <span class="main">(</span>Conv.rewr_conv <span class="entity">eq_th</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_property_raw</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">prop</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">P</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span> <span class="main">=</span> Term.dest_comb <span class="entity">prop</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">(</span><span class="entity">get_property_for_term</span> <span class="entity">ctxt</span> <span class="entity">t</span><span class="main">)</span>
          |&gt; filter <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=&gt;</span> Term.head_of <span class="main">(</span><span class="entity">prop_of'</span> <span class="entity">th</span><span class="main">)</span> aconv <span class="entity">P</span><span class="main">)</span>
          |&gt; <span class="entity">BoxID.merge_box_with_info</span> <span class="entity">ctxt</span> <span class="entity">id</span>
          |&gt; <span class="entity">Util.max_partial</span> <span class="main">(</span><span class="entity">BoxID.id_is_eq_ancestor</span> <span class="entity">ctxt</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Attempt to retrieve property with the given statement from the
   table. Here the statement is given as a certified term.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_property</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">cprop</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">P</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span> <span class="main">=</span> Term.dest_comb <span class="main">(</span>Thm.term_of <span class="entity">cprop</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">RewriteTable.in_table_raw_for_id</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="entity">get_property_raw</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> Thm.term_of <span class="entity">cprop</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ct</span> <span class="main">=</span> Thm.dest_arg <span class="entity">cprop</span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_head_rep</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">eq_th</span><span class="main">)</span> <span class="main">=</span>
            <span class="main">(</span><span class="entity">get_property_raw</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">P</span> $ <span class="entity">Util.rhs_of</span> <span class="entity">eq_th</span><span class="main">)</span><span class="main">)</span>
                |&gt; map <span class="main">(</span><span class="entity">convert_property</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">meta_sym</span> <span class="entity">eq_th</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span><span class="entity">RewriteTable.subterm_simplify_info</span> <span class="entity">ctxt</span> <span class="entity">ct</span><span class="main">)</span>
            |&gt; maps <span class="main">(</span><span class="entity">RewriteTable.get_head_rep_with_id_th</span> <span class="entity">ctxt</span><span class="main">)</span>
            |&gt; maps <span class="entity">process_head_rep</span>
            |&gt; <span class="entity">Util.max_partial</span> <span class="main">(</span><span class="entity">BoxID.id_is_eq_ancestor</span> <span class="entity">ctxt</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* As above, except statement is only a term. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_property_t</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">prop</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span> <span class="main">=</span> Term.dest_comb <span class="entity">prop</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">RewriteTable.in_table_raw_for_id</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="entity">get_property_raw</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">prop</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="entity">get_property</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">prop</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* th is an instantiated property update rule (without schematic
   variables). All premises and conclusions of th should be
   properties. Apply this rule at id and below to get new properties.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">apply_property_update_rule</span> <span class="entity">ctxt</span> <span class="entity">id</span> <span class="entity">th_opt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">th_opt</span> <span class="keyword2"><span class="keyword">of</span></span>
        NONE <span class="main">=&gt;</span> <span class="main">[</span><span class="main">]</span>
      <span class="main">|</span> SOME <span class="entity">th</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prems</span> <span class="main">=</span> map <span class="entity">dest_Trueprop</span> <span class="main">(</span>Thm.prems_of <span class="entity">th</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">prems</span> <span class="keyword2"><span class="keyword">then</span></span>
            <span class="main">[</span><span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">]</span>
          <span class="keyword2"><span class="keyword">else</span></span>
            <span class="entity">prems</span> |&gt; map <span class="main">(</span>pair <span class="entity">id</span><span class="main">)</span>
                  |&gt; map <span class="main">(</span><span class="entity">get_property_raw</span> <span class="entity">ctxt</span><span class="main">)</span>
                  |&gt; <span class="entity">BoxID.get_all_merges_info</span> <span class="entity">ctxt</span>
                  |&gt; <span class="entity">Util.max_partial</span> <span class="main">(</span><span class="entity">BoxID.id_is_eq_ancestor</span> <span class="entity">ctxt</span><span class="main">)</span>
                  |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">ths</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">ths</span> MRS <span class="entity">th</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Find relevant property updates for term t of the form f(x1,...x_n),
   from new properties of x1, ... xn. Apply these to get list of new
   properties.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">apply_property_update_on_term</span> <span class="entity">ctxt</span> <span class="entity">id</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> fastype_of <span class="entity">t</span> <span class="main">=</span> <span class="entity">boolT</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span> <span class="keyword2"><span class="keyword">else</span></span>
    <span class="keyword2"><span class="keyword">case</span></span> head_of <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
        Const <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">updt_rules</span> <span class="main">=</span> <span class="entity">Property.lookup_property_update_fun</span> <span class="entity">thy</span> <span class="entity">c</span>
          <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_updt_rule</span> <span class="entity">th</span> <span class="main">=</span>
              <span class="entity">th</span> |&gt; <span class="entity">Property.instantiate_property_update</span> <span class="entity">ctxt</span> <span class="entity">t</span>
                 |&gt; <span class="entity">apply_property_update_rule</span> <span class="entity">ctxt</span> <span class="entity">id</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          maps <span class="entity">process_updt_rule</span> <span class="entity">updt_rules</span>
        <span class="keyword2"><span class="keyword">end</span></span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="main">]</span>

<span class="comment1">(* Work out all consequences of adding a list of properties. In
   addition to propagating properties along equalities, need to apply
   property update rules.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_update_property</span> <span class="entity">inits</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">eq_property</span> <span class="main">(</span><span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">th'</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
          <span class="main">(</span><span class="entity">id</span> <span class="main">=</span> <span class="entity">id'</span> <span class="keyword1"><span class="keyword">andalso</span></span> Thm.prop_of <span class="entity">th</span> aconv Thm.prop_of <span class="entity">th'</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_property</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">(</span><span class="entity">to_process</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">Property.get_property_arg</span> <span class="main">(</span><span class="entity">prop_of'</span> <span class="entity">th</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">property_t</span> <span class="main">=</span> <span class="entity">get_property_for_term</span> <span class="entity">ctxt</span> <span class="entity">t</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="keyword2"><span class="keyword">if</span></span> exists <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">info</span> <span class="main">=&gt;</span> <span class="entity">BoxID.info_eq_better</span> <span class="entity">ctxt</span> <span class="entity">info</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">)</span>
                      <span class="entity">property_t</span> <span class="keyword2"><span class="keyword">then</span></span>
              <span class="main">(</span><span class="entity">to_process</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span>
            <span class="keyword2"><span class="keyword">else</span></span>
              <span class="main">(</span>insert <span class="entity">eq_property</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="entity">to_process</span><span class="main">,</span>
               <span class="entity">add_property_raw</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="entity">ctxt</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">update_step</span> <span class="main">(</span><span class="entity">to_process</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">to_process</span> <span class="keyword2"><span class="keyword">of</span></span>
              <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span>
            <span class="main">|</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> :: <span class="entity">rest</span> <span class="main">=&gt;</span>
              <span class="keyword2"><span class="keyword">let</span></span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">Property.get_property_arg</span> <span class="main">(</span><span class="entity">prop_of'</span> <span class="entity">th</span><span class="main">)</span>

                <span class="comment1">(* Neighbors of t. Here th: P t, th': t = t', result: P t'. *)</span>
                <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_neigh</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">eq_th</span><span class="main">)</span> <span class="main">=</span>
                    <span class="entity">convert_property</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">eq_th</span><span class="main">)</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">new_property_neigh</span> <span class="main">=</span>
                    map <span class="entity">process_neigh</span> <span class="main">(</span><span class="entity">RewriteTable.equiv_neighs</span> <span class="entity">ctxt</span> <span class="entity">t</span><span class="main">)</span>

                <span class="comment1">(* Derived properties of t. *)</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ts</span> <span class="main">=</span> <span class="entity">Property.strip_property_field</span> <span class="entity">thy</span> <span class="entity">t</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">c</span> <span class="main">=</span> <span class="entity">Property.get_property_name</span> <span class="main">(</span><span class="entity">prop_of'</span> <span class="entity">th</span><span class="main">)</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">updt_rules</span> <span class="main">=</span> <span class="entity">Property.lookup_property_update</span> <span class="entity">thy</span> <span class="entity">c</span>
                <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_updt_rule</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=</span>
                    <span class="entity">th</span> |&gt; <span class="entity">Property.instantiate_property_update</span> <span class="entity">ctxt</span> <span class="entity">t</span>
                       |&gt; <span class="entity">apply_property_update_rule</span> <span class="entity">ctxt</span> <span class="entity">id</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">new_property_t</span> <span class="main">=</span> maps <span class="entity">process_updt_rule</span>
                                          <span class="main">(</span><span class="entity">Util.all_pairs</span> <span class="main">(</span><span class="entity">ts</span><span class="main">,</span> <span class="entity">updt_rules</span><span class="main">)</span><span class="main">)</span>

                <span class="comment1">(* Derived properties of parent terms of t. *)</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parents_t</span> <span class="main">=</span>
                    map <span class="main">(</span>Thm.term_of<span class="main">)</span> <span class="main">(</span><span class="entity">RewriteTable.immediate_contains</span> <span class="entity">ctxt</span> <span class="entity">t</span><span class="main">)</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">new_property_ps</span> <span class="main">=</span>
                    maps <span class="main">(</span><span class="entity">apply_property_update_on_term</span> <span class="entity">ctxt</span> <span class="entity">id</span><span class="main">)</span> <span class="entity">parents_t</span>
              <span class="keyword2"><span class="keyword">in</span></span>
                <span class="main">(</span><span class="entity">rest</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span> |&gt; fold <span class="entity">process_property</span> <span class="entity">new_property_neigh</span>
                             |&gt; fold <span class="entity">process_property</span> <span class="entity">new_property_t</span>
                             |&gt; fold <span class="entity">process_property</span> <span class="entity">new_property_ps</span>
                             |&gt; <span class="entity">update_step</span>
              <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span> |&gt; fold <span class="entity">process_property</span> <span class="entity">inits</span> |&gt; <span class="entity">update_step</span> |&gt; snd
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Work out all consequences of adding an equality for the property table. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_rewrite_property</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">Util.lhs_of</span> <span class="entity">th</span><span class="main">,</span> <span class="entity">Util.rhs_of</span> <span class="entity">th</span><span class="main">)</span>

      <span class="comment1">(* New properties. *)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t1_property</span> <span class="main">=</span> <span class="entity">get_property_for_term</span> <span class="entity">ctxt</span> <span class="entity">t1</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t2_property</span> <span class="main">=</span> <span class="entity">get_property_for_term</span> <span class="entity">ctxt</span> <span class="entity">t2</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t1_newp</span> <span class="main">=</span> <span class="entity">t2_property</span> |&gt; map <span class="main">(</span><span class="entity">convert_property</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">meta_sym</span> <span class="entity">th</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t2_newp</span> <span class="main">=</span> <span class="entity">t1_property</span> |&gt; map <span class="main">(</span><span class="entity">convert_property</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">ctxt</span> |&gt; <span class="entity">process_update_property</span> <span class="main">(</span><span class="entity">t1_newp</span> @ <span class="entity">t2_newp</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* First make sure t is in the table. Add property P(t) to the table,
   and work out any consequences. The result is a consistent property
   table.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_property</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ct</span> <span class="main">=</span> <span class="entity">Property.get_property_arg_th</span> <span class="entity">th</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">ctxt</span> |&gt; <span class="entity">RewriteTable.add_term</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">ct</span><span class="main">)</span> |&gt; snd
           |&gt; <span class="entity">process_update_property</span> <span class="main">[</span><span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Return the list of properties that depend on prim_id, as a list of
   (id, th).
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_new_property</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="main">(</span>Data.get <span class="entity">ctxt</span><span class="main">)</span>
        |&gt; Termtab.dest_list |&gt; map snd
        |&gt; filter <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">BoxID.has_incr_id</span> <span class="entity">id</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>  <span class="comment1">(* structure PropertyData *)</span>
</pre>
</div><div id="files/AFP/Auto2_HOL/matcher.ML">
<div class="head">
<h1>File ‹$AFP/Auto2_HOL/matcher.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*
  File: matcher.ML
  Author: Bohua Zhan

  Matching up to equivalence (E-matching) using a rewrite table.
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">MATCHER</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="comment1">(* Internal *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> check_type_term<span class="main">:</span> theory <span class="main">-&gt;</span> term * term <span class="main">-&gt;</span> <span class="entity">id_inst</span> <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">id_inst</span> * term<span class="main">)</span> option
  <span class="keyword1"><span class="keyword">val</span></span> check_type<span class="main">:</span> theory <span class="main">-&gt;</span> typ * typ <span class="main">-&gt;</span> <span class="entity">id_inst</span> <span class="main">-&gt;</span> <span class="entity">id_inst</span> option
  <span class="keyword1"><span class="keyword">val</span></span> update_inst<span class="main">:</span> term list <span class="main">-&gt;</span> indexname <span class="main">-&gt;</span> cterm <span class="main">-&gt;</span> <span class="entity">id_inst</span> <span class="main">-&gt;</span> <span class="entity">id_inst_th</span> list

  <span class="comment1">(* THe actual matching function. These are defined together. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> match_list<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> term list * cterm list <span class="main">-&gt;</span>
                  <span class="entity">id_inst</span> <span class="main">-&gt;</span> <span class="entity">id_inst_ths</span> list
  <span class="keyword1"><span class="keyword">val</span></span> match_comb<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> term * cterm <span class="main">-&gt;</span> <span class="entity">id_inst</span> <span class="main">-&gt;</span>
                  <span class="entity">id_inst_th</span> list
  <span class="keyword1"><span class="keyword">val</span></span> match_head<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> term * cterm <span class="main">-&gt;</span> <span class="entity">id_inst</span> <span class="main">-&gt;</span>
                  <span class="entity">id_inst_th</span> list
  <span class="keyword1"><span class="keyword">val</span></span> match_all_head<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> term * cterm <span class="main">-&gt;</span> <span class="entity">id_inst</span> <span class="main">-&gt;</span>
                      <span class="entity">id_inst_th</span> list
  <span class="keyword1"><span class="keyword">val</span></span> match<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> term * cterm <span class="main">-&gt;</span> <span class="entity">id_inst</span> <span class="main">-&gt;</span>
             <span class="entity">id_inst_th</span> list

  <span class="comment1">(* Defined in terms of match. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> rewrite_match<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term * cterm <span class="main">-&gt;</span> <span class="entity">id_inst</span> <span class="main">-&gt;</span> <span class="entity">id_inst_th</span> list
  <span class="keyword1"><span class="keyword">val</span></span> rewrite_match_head<span class="main">:</span>
      <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term * cterm <span class="main">-&gt;</span> <span class="entity">id_inst</span> <span class="main">-&gt;</span> <span class="entity">id_inst_th</span> list
  <span class="keyword1"><span class="keyword">val</span></span> rewrite_match_list<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="main">(</span>bool * <span class="main">(</span>term * cterm<span class="main">)</span><span class="main">)</span> list <span class="main">-&gt;</span>
                          <span class="entity">id_inst</span> <span class="main">-&gt;</span> <span class="entity">id_inst_ths</span> list
  <span class="keyword1"><span class="keyword">val</span></span> rewrite_match_subset<span class="main">:</span>
      <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> term list * cterm list <span class="main">-&gt;</span> <span class="entity">id_inst</span> <span class="main">-&gt;</span>
      <span class="entity">id_inst_ths</span> list

  <span class="comment1">(* Prematching. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> pre_match_type<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> typ * typ <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> pre_match_comb<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term * cterm <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> pre_match_head'<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term * cterm <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> pre_match_all_head<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term * cterm <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> pre_match<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term * cterm <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> pre_match_head<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term * cterm <span class="main">-&gt;</span> bool
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Matcher</span> <span class="main">:</span> <span class="entity">MATCHER</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">compare_inst</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">id1</span><span class="main">,</span> <span class="entity">inst1</span><span class="main">)</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">(</span><span class="entity">id2</span><span class="main">,</span> <span class="entity">inst2</span><span class="main">)</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
    eq_list <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="main">(</span><span class="entity">id1</span><span class="main">,</span> <span class="entity">id2</span><span class="main">)</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">Util.eq_env</span> <span class="main">(</span><span class="entity">inst1</span><span class="main">,</span> <span class="entity">inst2</span><span class="main">)</span>

<span class="comment1">(* Match type at the top level for t and u. If there is no match,
   return NONE. Otherwise, return the updated instsp as well as t
   instantiated with the new type.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">check_type_term</span> <span class="entity">thy</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">u</span><span class="main">)</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="main">(</span><span class="entity">tyinst</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">T</span><span class="main">,</span> <span class="entity">U</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>fastype_of <span class="entity">t</span><span class="main">,</span> fastype_of <span class="entity">u</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">T</span> <span class="main">=</span> <span class="entity">U</span> <span class="keyword2"><span class="keyword">then</span></span> SOME <span class="main">(</span><span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="main">(</span><span class="entity">tyinst</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tyinst'</span> <span class="main">=</span> Sign.typ_match <span class="entity">thy</span> <span class="main">(</span><span class="entity">T</span><span class="main">,</span> <span class="entity">U</span><span class="main">)</span> <span class="entity">tyinst</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t'</span> <span class="main">=</span> Envir.subst_term_types <span class="entity">tyinst'</span> <span class="entity">t</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        SOME <span class="main">(</span><span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="main">(</span><span class="entity">tyinst'</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="entity">t'</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword3"><span class="keyword">handle</span></span> Type.TYPE_MATCH <span class="main">=&gt;</span> NONE

<span class="comment1">(* Match two types. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">check_type</span> <span class="entity">thy</span> <span class="main">(</span><span class="entity">T</span><span class="main">,</span> <span class="entity">U</span><span class="main">)</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="main">(</span><span class="entity">tyinst</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tyinst'</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">T</span> <span class="main">=</span> <span class="entity">U</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">tyinst</span>
                    <span class="keyword2"><span class="keyword">else</span></span> Sign.typ_match <span class="entity">thy</span> <span class="main">(</span><span class="entity">T</span><span class="main">,</span> <span class="entity">U</span><span class="main">)</span> <span class="entity">tyinst</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      SOME <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="main">(</span><span class="entity">tyinst'</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword3"><span class="keyword">handle</span></span> Type.TYPE_MATCH <span class="main">=&gt;</span> NONE

<span class="comment1">(* Starting here, bd_vars is the list of free variables substituted
   for bound variables, when matching goes inside abstractions.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_open</span> <span class="entity">bd_vars</span> <span class="entity">u</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">bd_vars</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> false
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span>
        length <span class="main">(</span>inter <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv<span class="main">)</span> <span class="entity">bd_vars</span> <span class="main">(</span>map Free <span class="main">(</span>Term.add_frees <span class="entity">u</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> &gt; <span class="inner_numeral">0</span>

<span class="comment1">(* Assign schematic variable with indexname ixn to u. Type of the
   schematic variable is determined by the type of u.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">update_inst</span> <span class="entity">bd_vars</span> <span class="entity">ixn</span> <span class="entity">cu</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">u</span> <span class="main">=</span> Thm.term_of <span class="entity">cu</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_open</span> <span class="entity">bd_vars</span> <span class="entity">u</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="main">(</span><span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">Util.update_env</span> <span class="main">(</span><span class="entity">ixn</span><span class="main">,</span> <span class="entity">u</span><span class="main">)</span> <span class="entity">inst</span><span class="main">)</span><span class="main">,</span> Thm.reflexive <span class="entity">cu</span><span class="main">)</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Matching an order list of patterns against terms. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">match_list</span> <span class="entity">ctxt</span> <span class="entity">bd_vars</span> <span class="main">(</span><span class="entity">ts</span><span class="main">,</span> <span class="entity">cus</span><span class="main">)</span> <span class="entity">instsp</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">ts</span> <span class="keyword1"><span class="keyword">andalso</span></span> null <span class="entity">cus</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">(</span><span class="entity">instsp</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">ts</span> <span class="keyword1"><span class="keyword">orelse</span></span> null <span class="entity">cus</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
      <span class="comment1">(* Two choices, one of which should always work (encounter no
         illegal higher-order patterns.
       *)</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">hd_first</span> <span class="main">(</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">insts_t</span> <span class="main">=</span> <span class="entity">match</span> <span class="entity">ctxt</span> <span class="entity">bd_vars</span> <span class="main">(</span>hd <span class="entity">ts</span><span class="main">,</span> hd <span class="entity">cus</span><span class="main">)</span> <span class="entity">instsp</span>
            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_inst_t</span> <span class="main">(</span><span class="entity">instsp'</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=</span>
                <span class="keyword2"><span class="keyword">let</span></span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">insts_ts'</span> <span class="main">=</span> <span class="entity">match_list</span> <span class="entity">ctxt</span> <span class="entity">bd_vars</span> <span class="main">(</span>tl <span class="entity">ts</span><span class="main">,</span> tl <span class="entity">cus</span><span class="main">)</span> <span class="entity">instsp'</span>
                <span class="keyword2"><span class="keyword">in</span></span>
                  map <span class="main">(</span>apsnd <span class="main">(</span>cons <span class="entity">th</span><span class="main">)</span><span class="main">)</span> <span class="entity">insts_ts'</span>
                <span class="keyword2"><span class="keyword">end</span></span>
          <span class="keyword2"><span class="keyword">in</span></span>
            maps <span class="entity">process_inst_t</span> <span class="entity">insts_t</span>
          <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">tl_first</span> <span class="main">(</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">insts_ts'</span> <span class="main">=</span> <span class="entity">match_list</span> <span class="entity">ctxt</span> <span class="entity">bd_vars</span> <span class="main">(</span>tl <span class="entity">ts</span><span class="main">,</span> tl <span class="entity">cus</span><span class="main">)</span> <span class="entity">instsp</span>
            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_inst_ts'</span> <span class="main">(</span><span class="entity">instsp'</span><span class="main">,</span> <span class="entity">ths</span><span class="main">)</span> <span class="main">=</span>
                <span class="keyword2"><span class="keyword">let</span></span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">insts_t</span> <span class="main">=</span> <span class="entity">match</span> <span class="entity">ctxt</span> <span class="entity">bd_vars</span> <span class="main">(</span>hd <span class="entity">ts</span><span class="main">,</span> hd <span class="entity">cus</span><span class="main">)</span> <span class="entity">instsp'</span>
                <span class="keyword2"><span class="keyword">in</span></span>
                  map <span class="main">(</span>apsnd <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">th</span> <span class="main">=&gt;</span> <span class="entity">th</span> :: <span class="entity">ths</span><span class="main">)</span><span class="main">)</span> <span class="entity">insts_t</span>
                <span class="keyword2"><span class="keyword">end</span></span>
          <span class="keyword2"><span class="keyword">in</span></span>
            maps <span class="entity">process_inst_ts'</span> <span class="entity">insts_ts'</span>
          <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">hd_first</span> <span class="main">(</span><span class="main">)</span> <span class="keyword3"><span class="keyword">handle</span></span> Fail <span class="inner_quoted">"invalid pattern"</span> <span class="main">=&gt;</span> <span class="entity">tl_first</span> <span class="main">(</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Match a non-AC function. *)</span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">match_comb</span> <span class="entity">ctxt</span> <span class="entity">bd_vars</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">cu</span><span class="main">)</span> <span class="main">(</span><span class="entity">instsp</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">tf</span><span class="main">,</span> <span class="entity">targs</span><span class="main">)</span> <span class="main">=</span> Term.strip_comb <span class="entity">t</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">cuf</span><span class="main">,</span> <span class="entity">cuargs</span><span class="main">)</span> <span class="main">=</span> Drule.strip_comb <span class="entity">cu</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">uf</span> <span class="main">=</span> Thm.term_of <span class="entity">cuf</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> Term.aconv_untyped <span class="main">(</span><span class="entity">tf</span><span class="main">,</span> <span class="entity">uf</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">instsps'</span> <span class="main">=</span> <span class="entity">match_list</span> <span class="entity">ctxt</span> <span class="entity">bd_vars</span> <span class="main">(</span><span class="entity">targs</span><span class="main">,</span> <span class="entity">cuargs</span><span class="main">)</span> <span class="entity">instsp</span>
          <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_inst</span> <span class="main">(</span><span class="entity">instsp'</span><span class="main">,</span> <span class="entity">ths</span><span class="main">)</span> <span class="main">=</span>
              <span class="main">(</span><span class="entity">instsp'</span><span class="main">,</span> <span class="entity">Util.comb_equiv</span> <span class="main">(</span><span class="entity">cuf</span><span class="main">,</span> <span class="entity">ths</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          map <span class="entity">process_inst</span> <span class="entity">instsps'</span>
        <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> is_Var <span class="entity">tf</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">ixn</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> Term.dest_Var <span class="entity">tf</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="keyword2"><span class="keyword">case</span></span> Vartab.lookup <span class="entity">inst</span> <span class="entity">ixn</span> <span class="keyword2"><span class="keyword">of</span></span>
              NONE <span class="main">=&gt;</span>
              <span class="keyword2"><span class="keyword">if</span></span> subset <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv<span class="main">)</span> <span class="main">(</span><span class="entity">targs</span><span class="main">,</span> <span class="entity">bd_vars</span><span class="main">)</span> <span class="keyword1"><span class="keyword">andalso</span></span>
                 not <span class="main">(</span>has_duplicates <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv<span class="main">)</span> <span class="entity">targs</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
                <span class="keyword2"><span class="keyword">let</span></span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cu'</span> <span class="main">=</span> <span class="entity">cu</span> |&gt; Thm.term_of
                               |&gt; fold <span class="entity">Util.lambda_abstract</span> <span class="main">(</span>rev <span class="entity">targs</span><span class="main">)</span>
                               |&gt; Thm.cterm_of <span class="entity">ctxt</span>
                <span class="keyword2"><span class="keyword">in</span></span>
                  map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">instsp'</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">instsp'</span><span class="main">,</span> Thm.reflexive <span class="entity">cu</span><span class="main">)</span><span class="main">)</span>
                      <span class="main">(</span><span class="entity">update_inst</span> <span class="entity">bd_vars</span> <span class="entity">ixn</span> <span class="entity">cu'</span> <span class="entity">instsp</span><span class="main">)</span>
                <span class="keyword2"><span class="keyword">end</span></span>
              <span class="keyword2"><span class="keyword">else</span></span>
                <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"invalid pattern"</span>
            <span class="main">|</span> SOME <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">tf'</span><span class="main">)</span> <span class="main">=&gt;</span>
              <span class="keyword2"><span class="keyword">let</span></span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t'</span> <span class="main">=</span> Term.list_comb <span class="main">(</span><span class="entity">tf'</span><span class="main">,</span> <span class="entity">targs</span><span class="main">)</span> |&gt; Envir.beta_norm
              <span class="keyword2"><span class="keyword">in</span></span>
                <span class="entity">match</span> <span class="entity">ctxt</span> <span class="entity">bd_vars</span> <span class="main">(</span><span class="entity">t'</span><span class="main">,</span> <span class="entity">cu</span><span class="main">)</span> <span class="entity">instsp</span>
              <span class="keyword2"><span class="keyword">end</span></span>
        <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Match t and u at head. *)</span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">match_head</span> <span class="entity">ctxt</span> <span class="entity">bd_vars</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">cu</span><span class="main">)</span> <span class="main">(</span><span class="entity">instsp</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">u</span> <span class="main">=</span> Thm.term_of <span class="entity">cu</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> fastype_of <span class="entity">t</span> &lt;&gt; fastype_of <span class="entity">u</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span> <span class="keyword2"><span class="keyword">else</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">u</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
          <span class="main">(</span>Var <span class="main">(</span><span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">i</span><span class="main">)</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span>
          <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> Vartab.lookup <span class="entity">inst</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">i</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
               NONE <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">x</span> <span class="main">=</span> <span class="inner_quoted">"NUMC"</span> <span class="keyword1"><span class="keyword">andalso</span></span>
                          not <span class="main">(</span><span class="entity">Consts.is_const_ctxt</span> <span class="entity">ctxt</span> <span class="entity">u</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span>
                       <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">x</span> <span class="main">=</span> <span class="inner_quoted">"FREE"</span> <span class="keyword1"><span class="keyword">andalso</span></span> not <span class="main">(</span>Term.is_Free <span class="entity">u</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span>
                       <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">update_inst</span> <span class="entity">bd_vars</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">i</span><span class="main">)</span> <span class="entity">cu</span> <span class="entity">instsp</span>
             <span class="main">|</span> SOME <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">u'</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">match_head</span> <span class="entity">ctxt</span> <span class="entity">bd_vars</span> <span class="main">(</span><span class="entity">u'</span><span class="main">,</span> <span class="entity">cu</span><span class="main">)</span> <span class="entity">instsp</span><span class="main">)</span>
        <span class="main">|</span> <span class="main">(</span>Free <span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> Free <span class="main">(</span><span class="entity">b</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span>
          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">a</span> <span class="main">=</span> <span class="entity">b</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">(</span><span class="entity">instsp</span><span class="main">,</span> Thm.reflexive <span class="entity">cu</span><span class="main">)</span><span class="main">]</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="main">]</span>
        <span class="main">|</span> <span class="main">(</span>Const <span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> Const <span class="main">(</span><span class="entity">b</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span>
          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">a</span> <span class="main">=</span> <span class="entity">b</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">(</span><span class="entity">instsp</span><span class="main">,</span> Thm.reflexive <span class="entity">cu</span><span class="main">)</span><span class="main">]</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="main">]</span>
        <span class="main">|</span> <span class="main">(</span><span class="main">_</span> $ <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">match_comb</span> <span class="entity">ctxt</span> <span class="entity">bd_vars</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">cu</span><span class="main">)</span> <span class="entity">instsp</span>
        <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* With fixed t, match with all equivalences of u. *)</span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">match_all_head</span> <span class="entity">ctxt</span> <span class="entity">bd_vars</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">cu</span><span class="main">)</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">env</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">u</span> <span class="main">=</span> Thm.term_of <span class="entity">cu</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">u_equivs</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_open</span> <span class="entity">bd_vars</span> <span class="entity">u</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">(</span><span class="entity">id</span><span class="main">,</span> Thm.reflexive <span class="entity">cu</span><span class="main">)</span><span class="main">]</span>
          <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">RewriteTable.get_head_equiv_with_t</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">cu</span><span class="main">)</span> <span class="entity">t</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_equiv</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">eq_u</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cu'</span> <span class="main">=</span> Thm.rhs_of <span class="entity">eq_u</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">insts_u'</span> <span class="main">=</span> <span class="entity">match_head</span> <span class="entity">ctxt</span> <span class="entity">bd_vars</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">cu'</span><span class="main">)</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">env</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_inst</span> <span class="main">(</span><span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">env'</span><span class="main">)</span><span class="main">,</span> <span class="entity">eq_th</span><span class="main">)</span> <span class="main">=</span>
                <span class="comment1">(* eq_th: t(env') == u', eq_u: u == u'. *)</span>
                <span class="main">(</span><span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">env'</span><span class="main">)</span><span class="main">,</span> <span class="entity">Util.transitive_list</span> <span class="main">[</span><span class="entity">eq_th</span><span class="main">,</span> <span class="entity">meta_sym</span> <span class="entity">eq_u</span><span class="main">]</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            map <span class="entity">process_inst</span> <span class="entity">insts_u'</span>
          <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">in</span></span>
      maps <span class="entity">process_equiv</span> <span class="entity">u_equivs</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Match t and u, possibly by rewriting u at head. *)</span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">match</span> <span class="entity">ctxt</span> <span class="entity">bd_vars</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">cu</span><span class="main">)</span> <span class="main">(</span><span class="entity">instsp</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">check_type_term</span> <span class="main">(</span>Proof_Context.theory_of <span class="entity">ctxt</span><span class="main">)</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> Thm.term_of <span class="entity">cu</span><span class="main">)</span> <span class="entity">instsp</span> <span class="keyword2"><span class="keyword">of</span></span>
        NONE <span class="main">=&gt;</span> <span class="main">[</span><span class="main">]</span>
      <span class="main">|</span> SOME <span class="main">(</span><span class="entity">instsp'</span><span class="main">,</span> <span class="entity">t'</span><span class="main">)</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">case</span></span> <span class="main">(</span><span class="entity">t'</span><span class="main">,</span> Thm.term_of <span class="entity">cu</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
            <span class="main">(</span>Var <span class="main">(</span><span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">i</span><span class="main">)</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span>
            <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> Vartab.lookup <span class="entity">inst</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">i</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
                 NONE <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">if</span></span> member <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="main">[</span><span class="inner_quoted">"NUMC"</span><span class="main">,</span> <span class="inner_quoted">"FREE"</span><span class="main">]</span> <span class="entity">x</span> <span class="keyword2"><span class="keyword">then</span></span>
                           <span class="entity">match_all_head</span> <span class="entity">ctxt</span> <span class="entity">bd_vars</span> <span class="main">(</span><span class="entity">t'</span><span class="main">,</span> <span class="entity">cu</span><span class="main">)</span> <span class="entity">instsp'</span>
                         <span class="keyword2"><span class="keyword">else</span></span>
                           <span class="entity">update_inst</span> <span class="entity">bd_vars</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">i</span><span class="main">)</span> <span class="entity">cu</span> <span class="entity">instsp'</span>
               <span class="main">|</span> SOME <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">u'</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">match</span> <span class="entity">ctxt</span> <span class="entity">bd_vars</span> <span class="main">(</span><span class="entity">u'</span><span class="main">,</span> <span class="entity">cu</span><span class="main">)</span> <span class="entity">instsp'</span><span class="main">)</span>
          <span class="main">|</span> <span class="main">(</span>Abs <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">T</span><span class="main">,</span> <span class="entity">t'</span><span class="main">)</span><span class="main">,</span> Abs <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">U</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span>
            <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">check_type</span> <span class="main">(</span>Proof_Context.theory_of <span class="entity">ctxt</span><span class="main">)</span> <span class="main">(</span><span class="entity">T</span><span class="main">,</span> <span class="entity">U</span><span class="main">)</span> <span class="entity">instsp'</span> <span class="keyword2"><span class="keyword">of</span></span>
                NONE <span class="main">=&gt;</span> <span class="main">[</span><span class="main">]</span>
              <span class="main">|</span> SOME <span class="main">(</span><span class="entity">instsp''</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">(</span><span class="entity">tyinst'</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span>
                <span class="keyword2"><span class="keyword">let</span></span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">cv</span><span class="main">,</span> <span class="entity">cu'</span><span class="main">)</span> <span class="main">=</span> Thm.dest_abs <span class="main">(</span>SOME Name.uu<span class="main">)</span> <span class="entity">cu</span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">v</span> <span class="main">=</span> Thm.term_of <span class="entity">cv</span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t''</span> <span class="main">=</span> Envir.subst_term_types <span class="entity">tyinst'</span> <span class="entity">t'</span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t_free</span> <span class="main">=</span> Term.subst_bound <span class="main">(</span><span class="entity">v</span><span class="main">,</span> <span class="entity">t''</span><span class="main">)</span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">insts'</span> <span class="main">=</span> <span class="entity">match</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">v</span> :: <span class="entity">bd_vars</span><span class="main">)</span> <span class="main">(</span><span class="entity">t_free</span><span class="main">,</span> <span class="entity">cu'</span><span class="main">)</span> <span class="entity">instsp''</span>
                  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_inst</span> <span class="main">(</span><span class="entity">inst'</span><span class="main">,</span> <span class="entity">th'</span><span class="main">)</span> <span class="main">=</span>
                      <span class="main">(</span><span class="entity">inst'</span><span class="main">,</span> Thm.abstract_rule <span class="entity">x</span> <span class="entity">cv</span> <span class="entity">th'</span><span class="main">)</span>
                <span class="keyword2"><span class="keyword">in</span></span>
                  map <span class="entity">process_inst</span> <span class="entity">insts'</span>
                <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>
          <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="comment1">(* Free, Const, and comb case *)</span>
            <span class="main">(</span><span class="entity">match_all_head</span> <span class="entity">ctxt</span> <span class="entity">bd_vars</span> <span class="main">(</span><span class="entity">t'</span><span class="main">,</span> <span class="entity">cu</span><span class="main">)</span> <span class="entity">instsp'</span><span class="main">)</span>
                |&gt; distinct <span class="entity">compare_inst</span>

<span class="comment1">(* Function for export *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rewrite_match_gen</span> <span class="entity">at_head</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">cu</span><span class="main">)</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">env</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">at_head</span> <span class="keyword2"><span class="keyword">then</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">check_type_term</span> <span class="main">(</span>Proof_Context.theory_of <span class="entity">ctxt</span><span class="main">)</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> Thm.term_of <span class="entity">cu</span><span class="main">)</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">env</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
          NONE <span class="main">=&gt;</span> <span class="main">[</span><span class="main">]</span>
        <span class="main">|</span> SOME <span class="main">(</span><span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">env</span><span class="main">)</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">match_head</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">cu</span><span class="main">)</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">env</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">else</span></span>
      <span class="entity">match</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">cu</span><span class="main">)</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">env</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rewrite_match</span> <span class="main">=</span> <span class="entity">rewrite_match_gen</span> false
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rewrite_match_head</span> <span class="main">=</span> <span class="entity">rewrite_match_gen</span> true

<span class="comment1">(* pairs is a list of (at_head, (t, u)). Match the pairs in sequence,
   and return a list of ((id, inst), ths), where ths is the list of
   equalities t(env) == u.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rewrite_match_list</span> <span class="entity">ctxt</span> <span class="entity">pairs</span> <span class="entity">instsp</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">pairs</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="main">(</span><span class="entity">instsp</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">]</span>
      <span class="main">|</span> <span class="main">(</span><span class="entity">at_head</span><span class="main">,</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">cu</span><span class="main">)</span><span class="main">)</span> :: <span class="entity">pairs'</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">insts_t</span> <span class="main">=</span> <span class="entity">rewrite_match_gen</span> <span class="entity">at_head</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">cu</span><span class="main">)</span> <span class="entity">instsp</span>
          <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_inst_t</span> <span class="main">(</span><span class="entity">instsp'</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=</span>
              <span class="keyword2"><span class="keyword">let</span></span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">insts_ts'</span> <span class="main">=</span> <span class="entity">rewrite_match_list</span> <span class="entity">ctxt</span> <span class="entity">pairs'</span> <span class="entity">instsp'</span>
              <span class="keyword2"><span class="keyword">in</span></span>
                map <span class="main">(</span>apsnd <span class="main">(</span>cons <span class="entity">th</span><span class="main">)</span><span class="main">)</span> <span class="entity">insts_ts'</span>
              <span class="keyword2"><span class="keyword">end</span></span>
        <span class="keyword2"><span class="keyword">in</span></span>
          maps <span class="entity">process_inst_t</span> <span class="entity">insts_t</span>
        <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Given two lists of terms (ts, us), match ts with a subset of
   us. Return a list of ((id, inst), ths), where ths is the list of
   equalities t_i(env) == u_j.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rewrite_match_subset</span> <span class="entity">ctxt</span> <span class="entity">bd_vars</span> <span class="main">(</span><span class="entity">ts</span><span class="main">,</span> <span class="entity">cus</span><span class="main">)</span> <span class="entity">instsp</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">ts</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="main">(</span><span class="entity">instsp</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">]</span>
      <span class="main">|</span> <span class="entity">t</span> :: <span class="entity">ts'</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">match_i</span> <span class="entity">i</span> <span class="main">=</span>
              map <span class="main">(</span>pair <span class="entity">i</span><span class="main">)</span> <span class="main">(</span><span class="entity">match</span> <span class="entity">ctxt</span> <span class="entity">bd_vars</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> nth <span class="entity">cus</span> <span class="entity">i</span><span class="main">)</span> <span class="entity">instsp</span><span class="main">)</span>

          <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_match_i</span> <span class="main">(</span><span class="entity">i</span><span class="main">,</span> <span class="main">(</span><span class="entity">instsp'</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
              <span class="keyword2"><span class="keyword">let</span></span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">insts_ts'</span> <span class="main">=</span> <span class="entity">rewrite_match_subset</span>
                                    <span class="entity">ctxt</span> <span class="entity">bd_vars</span> <span class="main">(</span><span class="entity">ts'</span><span class="main">,</span> nth_drop <span class="entity">i</span> <span class="entity">cus</span><span class="main">)</span> <span class="entity">instsp'</span>
              <span class="keyword2"><span class="keyword">in</span></span>
                map <span class="main">(</span>apsnd <span class="main">(</span>cons <span class="entity">th</span><span class="main">)</span><span class="main">)</span> <span class="entity">insts_ts'</span>
              <span class="keyword2"><span class="keyword">end</span></span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="main">(</span><span class="inner_numeral">0</span> upto <span class="main">(</span>length <span class="entity">cus</span> - <span class="inner_numeral">1</span><span class="main">)</span><span class="main">)</span>
              |&gt; maps <span class="entity">match_i</span> |&gt; maps <span class="entity">process_match_i</span>
        <span class="keyword2"><span class="keyword">end</span></span>
        <span class="keyword3"><span class="keyword">handle</span></span> Fail <span class="inner_quoted">"invalid pattern"</span> <span class="main">=&gt;</span>
               <span class="keyword2"><span class="keyword">if</span></span> length <span class="entity">ts'</span> &gt; <span class="inner_numeral">0</span> <span class="keyword1"><span class="keyword">andalso</span></span> Term_Ord.term_ord <span class="main">(</span><span class="entity">t</span><span class="main">,</span> hd <span class="entity">ts'</span><span class="main">)</span> <span class="main">=</span> LESS <span class="keyword2"><span class="keyword">then</span></span>
                 <span class="entity">rewrite_match_subset</span> <span class="entity">ctxt</span> <span class="entity">bd_vars</span> <span class="main">(</span><span class="entity">ts'</span> @ <span class="main">[</span><span class="entity">t</span><span class="main">]</span><span class="main">,</span> <span class="entity">cus</span><span class="main">)</span> <span class="entity">instsp</span>
               <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"rewrite_match_subset: invalid pattern"</span>

<span class="comment1">(* Fast function for determining whether there can be a match between
   t and u.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pre_match_type</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">T</span><span class="main">,</span> <span class="entity">U</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> Sign.typ_match <span class="entity">thy</span> <span class="main">(</span><span class="entity">T</span><span class="main">,</span> <span class="entity">U</span><span class="main">)</span> Vartab.empty
    <span class="keyword2"><span class="keyword">in</span></span>
      true
    <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword3"><span class="keyword">handle</span></span> Type.TYPE_MATCH <span class="main">=&gt;</span> false

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pre_match_comb</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">cu</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">tf</span><span class="main">,</span> <span class="entity">targs</span><span class="main">)</span> <span class="main">=</span> Term.strip_comb <span class="entity">t</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">cuf</span><span class="main">,</span> <span class="entity">cuargs</span><span class="main">)</span> <span class="main">=</span> Drule.strip_comb <span class="entity">cu</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">uf</span> <span class="main">=</span> Thm.term_of <span class="entity">cuf</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      is_Var <span class="entity">tf</span> <span class="keyword1"><span class="keyword">orelse</span></span> <span class="main">(</span>Term.aconv_untyped <span class="main">(</span><span class="entity">tf</span><span class="main">,</span> <span class="entity">uf</span><span class="main">)</span> <span class="keyword1"><span class="keyword">andalso</span></span>
                        length <span class="entity">targs</span> <span class="main">=</span> length <span class="entity">cuargs</span> <span class="keyword1"><span class="keyword">andalso</span></span>
                        forall <span class="main">(</span><span class="entity">pre_match</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="main">(</span><span class="entity">targs</span> ~~ <span class="entity">cuargs</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">pre_match_head'</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">cu</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">u</span> <span class="main">=</span> Thm.term_of <span class="entity">cu</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">u</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
          <span class="main">(</span>Var <span class="main">(</span><span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span>
          <span class="keyword2"><span class="keyword">if</span></span> Term.is_open <span class="entity">u</span> <span class="keyword2"><span class="keyword">then</span></span> false
          <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span><span class="entity">pre_match_type</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">T</span><span class="main">,</span> fastype_of <span class="entity">u</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> false
          <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">x</span> <span class="main">=</span> <span class="inner_quoted">"NUMC"</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">Consts.is_const_ctxt</span> <span class="entity">ctxt</span> <span class="entity">u</span>
          <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">x</span> <span class="main">=</span> <span class="inner_quoted">"FREE"</span> <span class="keyword2"><span class="keyword">then</span></span> Term.is_Free <span class="entity">u</span>
          <span class="keyword2"><span class="keyword">else</span></span> true
        <span class="main">|</span> <span class="main">(</span>Free <span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">,</span> Free <span class="main">(</span><span class="entity">b</span><span class="main">,</span> <span class="entity">U</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span>
          <span class="main">(</span><span class="entity">a</span> <span class="main">=</span> <span class="entity">b</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">pre_match_type</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">T</span><span class="main">,</span> <span class="entity">U</span><span class="main">)</span><span class="main">)</span>
        <span class="main">|</span> <span class="main">(</span>Const <span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">,</span> Const <span class="main">(</span><span class="entity">b</span><span class="main">,</span> <span class="entity">U</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span>
          <span class="main">(</span><span class="entity">a</span> <span class="main">=</span> <span class="entity">b</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">pre_match_type</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">T</span><span class="main">,</span> <span class="entity">U</span><span class="main">)</span><span class="main">)</span>
        <span class="main">|</span> <span class="main">(</span><span class="main">_</span> $ <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">pre_match_comb</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">cu</span><span class="main">)</span>
        <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">pre_match_all_head</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">cu</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">u</span> <span class="main">=</span> Thm.term_of <span class="entity">cu</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tyinst</span> <span class="main">=</span> Sign.typ_match <span class="entity">thy</span> <span class="main">(</span>fastype_of <span class="entity">t</span><span class="main">,</span> fastype_of <span class="entity">u</span><span class="main">)</span> Vartab.empty
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t'</span> <span class="main">=</span> Envir.subst_term_types <span class="entity">tyinst</span> <span class="entity">t</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> Term.is_open <span class="entity">u</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">pre_match_head'</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">t'</span><span class="main">,</span> <span class="entity">cu</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">u_equivs</span> <span class="main">=</span>
            <span class="main">(</span><span class="entity">RewriteTable.get_head_equiv_with_t</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">cu</span><span class="main">)</span> <span class="entity">t'</span><span class="main">)</span>
                |&gt; map snd |&gt; map Thm.rhs_of
      <span class="keyword2"><span class="keyword">in</span></span>
        exists <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">cu'</span> <span class="main">=&gt;</span> <span class="entity">pre_match_head'</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">t'</span><span class="main">,</span> <span class="entity">cu'</span><span class="main">)</span><span class="main">)</span> <span class="entity">u_equivs</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword3"><span class="keyword">handle</span></span> Type.TYPE_MATCH <span class="main">=&gt;</span> false

<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">pre_match</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">cu</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">u</span> <span class="main">=</span> Thm.term_of <span class="entity">cu</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">u</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
          <span class="main">(</span>Var <span class="main">(</span><span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span>
          <span class="keyword2"><span class="keyword">if</span></span> Term.is_open <span class="entity">u</span> <span class="keyword2"><span class="keyword">then</span></span> false
          <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span><span class="entity">pre_match_type</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">T</span><span class="main">,</span> fastype_of <span class="entity">u</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> false
          <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> member <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="main">[</span><span class="inner_quoted">"NUMC"</span><span class="main">,</span> <span class="inner_quoted">"FREE"</span><span class="main">]</span> <span class="entity">x</span> <span class="keyword2"><span class="keyword">then</span></span>
            <span class="entity">pre_match_all_head</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">cu</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">else</span></span> true
        <span class="main">|</span> <span class="main">(</span>Abs <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">T</span><span class="main">,</span> <span class="entity">t'</span><span class="main">)</span><span class="main">,</span> Abs <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">U</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span>
          <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span><span class="entity">pre_match_type</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">T</span><span class="main">,</span> <span class="entity">U</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> false
          <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">cv</span><span class="main">,</span> <span class="entity">cu'</span><span class="main">)</span> <span class="main">=</span> Thm.dest_abs <span class="main">(</span>SOME Name.uu<span class="main">)</span> <span class="entity">cu</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t''</span> <span class="main">=</span> subst_bound <span class="main">(</span>Thm.term_of <span class="entity">cv</span><span class="main">,</span> <span class="entity">t'</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="entity">pre_match</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">t''</span><span class="main">,</span> <span class="entity">cu'</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>
        <span class="main">|</span> <span class="main">(</span>Bound <span class="entity">i</span><span class="main">,</span> Bound <span class="entity">j</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">i</span> <span class="main">=</span> <span class="entity">j</span><span class="main">)</span>
        <span class="main">|</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">pre_match_all_head</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">cu</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pre_match_head</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">cu</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">u</span> <span class="main">=</span> Thm.term_of <span class="entity">cu</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tyinst</span> <span class="main">=</span> Sign.typ_match <span class="entity">thy</span> <span class="main">(</span>fastype_of <span class="entity">t</span><span class="main">,</span> fastype_of <span class="entity">u</span><span class="main">)</span> Vartab.empty
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t'</span> <span class="main">=</span> Envir.subst_term_types <span class="entity">tyinst</span> <span class="entity">t</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">pre_match_head'</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">t'</span><span class="main">,</span> <span class="entity">cu</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword3"><span class="keyword">handle</span></span> Type.TYPE_MATCH <span class="main">=&gt;</span> false

<span class="keyword2"><span class="keyword">end</span></span>  <span class="comment1">(* structure Matcher. *)</span>
</pre>
</div><div id="files/AFP/Auto2_HOL/items.ML">
<div class="head">
<h1>File ‹$AFP/Auto2_HOL/items.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*
  File: items.ML
  Author: Bohua Zhan

  Items and matching on items.
*)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">TY_NULL</span> <span class="main">=</span> <span class="inner_quoted">"NULL"</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">TY_EQ</span> <span class="main">=</span> <span class="inner_quoted">"EQ"</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">TY_VAR</span> <span class="main">=</span> <span class="inner_quoted">"VAR"</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">TY_PROP</span> <span class="main">=</span> <span class="inner_quoted">"PROP"</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">TY_TERM</span> <span class="main">=</span> <span class="inner_quoted">"TERM"</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">TY_PROPERTY</span> <span class="main">=</span> <span class="inner_quoted">"PROPERTY"</span>

<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">raw_item</span> <span class="main">=</span> <span class="entity">Handler</span> <span class="keyword2"><span class="keyword">of</span></span> term list * term * thm
                  <span class="main">|</span> <span class="entity">Fact</span> <span class="keyword2"><span class="keyword">of</span></span> string * term list * thm
<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">box_item</span> <span class="main">=</span> <span class="main">{</span>uid<span class="main">:</span> int<span class="main">,</span> id<span class="main">:</span> <span class="entity">box_id</span><span class="main">,</span> sc<span class="main">:</span> int<span class="main">,</span> ty_str<span class="main">:</span> string<span class="main">,</span>
                 tname<span class="main">:</span> cterm list<span class="main">,</span> prop<span class="main">:</span> thm<span class="main">}</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">BOXITEM</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="comment1">(* Facts. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> var_to_fact<span class="main">:</span> term <span class="main">-&gt;</span> <span class="entity">raw_item</span>
  <span class="keyword1"><span class="keyword">val</span></span> term_to_fact<span class="main">:</span> term <span class="main">-&gt;</span> <span class="entity">raw_item</span>
  <span class="keyword1"><span class="keyword">val</span></span> is_fact_raw<span class="main">:</span> <span class="entity">raw_item</span> <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> match_ty_str_raw<span class="main">:</span> string <span class="main">-&gt;</span> <span class="entity">raw_item</span> <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> match_ty_strs_raw<span class="main">:</span> string list <span class="main">-&gt;</span> <span class="entity">raw_item</span> <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> get_tname_raw<span class="main">:</span> <span class="entity">raw_item</span> <span class="main">-&gt;</span> term list
  <span class="keyword1"><span class="keyword">val</span></span> get_thm_raw<span class="main">:</span> <span class="entity">raw_item</span> <span class="main">-&gt;</span> thm
  <span class="comment1">(* Handlers. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> is_handler_raw<span class="main">:</span> <span class="entity">raw_item</span> <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> dest_handler_raw<span class="main">:</span> <span class="entity">raw_item</span> <span class="main">-&gt;</span> term list * term * thm
  <span class="comment1">(* Misc. functions. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> eq_ritem<span class="main">:</span> <span class="entity">raw_item</span> * <span class="entity">raw_item</span> <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> instantiate<span class="main">:</span> <span class="main">(</span>cterm * cterm<span class="main">)</span> list <span class="main">-&gt;</span> <span class="entity">raw_item</span> <span class="main">-&gt;</span> <span class="entity">raw_item</span>
  <span class="keyword1"><span class="keyword">val</span></span> obtain_variant_frees<span class="main">:</span>
      <span class="entity">Proof.context</span> * <span class="entity">raw_item</span> list <span class="main">-&gt;</span> <span class="entity">Proof.context</span> * <span class="main">(</span>cterm * cterm<span class="main">)</span> list

  <span class="keyword1"><span class="keyword">val</span></span> null_item<span class="main">:</span> <span class="entity">box_item</span>
  <span class="keyword1"><span class="keyword">val</span></span> item_with_id<span class="main">:</span> <span class="entity">box_id</span> <span class="main">-&gt;</span> <span class="entity">box_item</span> <span class="main">-&gt;</span> <span class="entity">box_item</span>
  <span class="keyword1"><span class="keyword">val</span></span> item_with_incr<span class="main">:</span> <span class="entity">box_item</span> <span class="main">-&gt;</span> <span class="entity">box_item</span>
  <span class="keyword1"><span class="keyword">val</span></span> item_replace_incr<span class="main">:</span> <span class="entity">box_item</span> <span class="main">-&gt;</span> <span class="entity">box_item</span>
  <span class="keyword1"><span class="keyword">val</span></span> eq_item<span class="main">:</span> <span class="entity">box_item</span> * <span class="entity">box_item</span> <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> match_ty_str<span class="main">:</span> string <span class="main">-&gt;</span> <span class="entity">box_item</span> <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> match_ty_strs<span class="main">:</span> string list <span class="main">-&gt;</span> <span class="entity">box_item</span> <span class="main">-&gt;</span> bool
  <span class="comment1">(* Misc. functions. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> merged_id<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">box_item</span> list <span class="main">-&gt;</span> <span class="entity">box_id</span>
  <span class="keyword1"><span class="keyword">val</span></span> mk_box_item<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> int * <span class="entity">box_id</span> * int * <span class="entity">raw_item</span> <span class="main">-&gt;</span> <span class="entity">box_item</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">BoxItem</span> <span class="main">:</span> <span class="entity">BOXITEM</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">var_to_fact</span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">Fact</span> <span class="main">(</span><span class="entity">TY_VAR</span><span class="main">,</span> <span class="main">[</span><span class="entity">t</span><span class="main">]</span><span class="main">,</span> <span class="entity">true_th</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">term_to_fact</span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">Fact</span> <span class="main">(</span><span class="entity">TY_TERM</span><span class="main">,</span> <span class="main">[</span><span class="entity">t</span><span class="main">]</span><span class="main">,</span> <span class="entity">true_th</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_fact_raw</span> <span class="entity">ritem</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">ritem</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="entity">Fact</span> <span class="main">_</span> <span class="main">=&gt;</span> true <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">match_ty_str_raw</span> <span class="entity">s</span> <span class="entity">ritem</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">ritem</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="entity">Fact</span> <span class="main">(</span><span class="entity">ty_str</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">s</span> <span class="main">=</span> <span class="inner_quoted">""</span> <span class="keyword1"><span class="keyword">orelse</span></span> <span class="entity">ty_str</span> <span class="main">=</span> <span class="entity">s</span> <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">match_ty_strs_raw</span> <span class="entity">slist</span> <span class="entity">ritem</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">ritem</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="entity">Fact</span> <span class="main">(</span><span class="entity">ty_str</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> member <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">slist</span> <span class="entity">ty_str</span> <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_tname_raw</span> <span class="entity">ritem</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">ritem</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="entity">Fact</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">ts</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">ts</span> <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"get_tname_raw"</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_thm_raw</span> <span class="entity">ritem</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">ritem</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="entity">Fact</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">th</span> <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"get_thm_raw"</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_handler_raw</span> <span class="entity">ritem</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">ritem</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="entity">Handler</span> <span class="main">_</span> <span class="main">=&gt;</span> true <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_handler_raw</span> <span class="entity">ritem</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">ritem</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="entity">Handler</span> <span class="main">(</span><span class="entity">vars</span><span class="main">,</span> <span class="entity">t</span><span class="main">,</span> <span class="entity">ex_th</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">vars</span><span class="main">,</span> <span class="entity">t</span><span class="main">,</span> <span class="entity">ex_th</span><span class="main">)</span>
                <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"dest_handler_raw: wrong type"</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">eq_ritem</span> <span class="main">(</span><span class="entity">ritem1</span><span class="main">,</span> <span class="entity">ritem2</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">ritem1</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="entity">Fact</span> <span class="main">(</span><span class="entity">ty1</span><span class="main">,</span> <span class="entity">ts1</span><span class="main">,</span> <span class="entity">th1</span><span class="main">)</span> <span class="main">=&gt;</span>
        <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">ritem2</span> <span class="keyword2"><span class="keyword">of</span></span>
             <span class="entity">Fact</span> <span class="main">(</span><span class="entity">ty2</span><span class="main">,</span> <span class="entity">ts2</span><span class="main">,</span> <span class="entity">th2</span><span class="main">)</span> <span class="main">=&gt;</span>
             <span class="entity">ty1</span> <span class="main">=</span> <span class="entity">ty2</span> <span class="keyword1"><span class="keyword">andalso</span></span> eq_list <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv<span class="main">)</span> <span class="main">(</span><span class="entity">ts1</span><span class="main">,</span> <span class="entity">ts2</span><span class="main">)</span> <span class="keyword1"><span class="keyword">andalso</span></span>
             Thm.eq_thm_prop <span class="main">(</span><span class="entity">th1</span><span class="main">,</span> <span class="entity">th2</span><span class="main">)</span>
           <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false<span class="main">)</span>
      <span class="main">|</span> <span class="entity">Handler</span> <span class="main">(</span><span class="entity">vars1</span><span class="main">,</span> <span class="entity">t1</span><span class="main">,</span> <span class="entity">ex_th1</span><span class="main">)</span> <span class="main">=&gt;</span>
        <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">ritem2</span> <span class="keyword2"><span class="keyword">of</span></span>
             <span class="entity">Fact</span> <span class="main">_</span> <span class="main">=&gt;</span> false
           <span class="main">|</span> <span class="entity">Handler</span> <span class="main">(</span><span class="entity">vars2</span><span class="main">,</span> <span class="entity">t2</span><span class="main">,</span> <span class="entity">ex_th2</span><span class="main">)</span> <span class="main">=&gt;</span>
             eq_list <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv<span class="main">)</span> <span class="main">(</span><span class="entity">vars1</span><span class="main">,</span> <span class="entity">vars2</span><span class="main">)</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">t1</span> aconv <span class="entity">t2</span> <span class="keyword1"><span class="keyword">andalso</span></span>
             Thm.eq_thm_prop <span class="main">(</span><span class="entity">ex_th1</span><span class="main">,</span> <span class="entity">ex_th2</span><span class="main">)</span><span class="main">)</span>

<span class="comment1">(* Given a context and list of raw items, obtain fresh names of free
   variables for each internal (schematic) variable declared in the
   raw items, and declare the new variables in context. Return the
   substitution from internal schematic variables to the new free
   variables.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">obtain_variant_frees</span> <span class="main">(</span><span class="entity">ctxt</span><span class="main">,</span> <span class="entity">ritems</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="comment1">(* Original internal variables. *)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_vars</span> <span class="main">=</span>
          <span class="entity">ritems</span> |&gt; filter <span class="main">(</span><span class="entity">match_ty_str_raw</span> <span class="entity">TY_VAR</span><span class="main">)</span> |&gt; maps <span class="entity">get_tname_raw</span>
                 |&gt; filter is_Free |&gt; map dest_Free
                 |&gt; filter <span class="main">(</span><span class="entity">Util.is_just_internal</span> o fst<span class="main">)</span>
      <span class="comment1">(* New names for these variables. *)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_vars'</span> <span class="main">=</span>
          <span class="entity">all_vars</span> |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span>Name.dest_internal <span class="entity">x</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">)</span>
                   |&gt; Variable.variant_frees <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">subst</span> <span class="main">=</span> map <span class="main">(</span>apply2 <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> o Free<span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="entity">all_vars</span> ~~ <span class="entity">all_vars'</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">(</span>fold <span class="entity">Util.declare_free_term</span> <span class="main">(</span>map Free <span class="entity">all_vars'</span><span class="main">)</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="entity">subst</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Here inst is the return value of obtain_variant_frees. Perform the
   replacement on the ritems.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">instantiate</span> <span class="entity">subst</span> <span class="entity">ritem</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">subst_fun</span> <span class="main">=</span> Term.subst_atomic <span class="main">(</span>map <span class="main">(</span>apply2 Thm.term_of<span class="main">)</span> <span class="entity">subst</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">ritem</span> <span class="keyword2"><span class="keyword">of</span></span>
          <span class="entity">Handler</span> <span class="main">(</span><span class="entity">vars</span><span class="main">,</span> <span class="entity">t</span><span class="main">,</span> <span class="entity">ex_th</span><span class="main">)</span> <span class="main">=&gt;</span>
          <span class="entity">Handler</span> <span class="main">(</span>map <span class="entity">subst_fun</span> <span class="entity">vars</span><span class="main">,</span> <span class="entity">subst_fun</span> <span class="entity">t</span><span class="main">,</span>
                   <span class="entity">Util.subst_thm_atomic</span> <span class="entity">subst</span> <span class="entity">ex_th</span><span class="main">)</span>
        <span class="main">|</span> <span class="entity">Fact</span> <span class="main">(</span><span class="entity">ty_str</span><span class="main">,</span> <span class="entity">tname</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=&gt;</span>
          <span class="entity">Fact</span> <span class="main">(</span><span class="entity">ty_str</span><span class="main">,</span> map <span class="entity">subst_fun</span> <span class="entity">tname</span><span class="main">,</span> <span class="entity">Util.subst_thm_atomic</span> <span class="entity">subst</span> <span class="entity">th</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">null_item</span> <span class="main">=</span> <span class="main">{</span>uid <span class="main">=</span> <span class="inner_numeral">0</span><span class="main">,</span> id <span class="main">=</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span> sc <span class="main">=</span> <span class="inner_numeral">0</span><span class="main">,</span> ty_str <span class="main">=</span> <span class="entity">TY_NULL</span><span class="main">,</span>
                 tname <span class="main">=</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span> prop <span class="main">=</span> <span class="entity">true_th</span><span class="main">}</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">item_with_id</span> <span class="entity">id</span> <span class="main">{</span><span class="entity">uid</span><span class="main">,</span> <span class="entity">sc</span><span class="main">,</span> <span class="entity">ty_str</span><span class="main">,</span> <span class="entity">tname</span><span class="main">,</span> <span class="entity">prop</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span>
    <span class="main">{</span>uid <span class="main">=</span> <span class="entity">uid</span><span class="main">,</span> id <span class="main">=</span> <span class="entity">id</span><span class="main">,</span> sc <span class="main">=</span> <span class="entity">sc</span><span class="main">,</span> ty_str <span class="main">=</span> <span class="entity">ty_str</span><span class="main">,</span> tname <span class="main">=</span> <span class="entity">tname</span><span class="main">,</span> prop <span class="main">=</span> <span class="entity">prop</span><span class="main">}</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">item_with_incr</span> <span class="entity">item</span> <span class="main">=</span>
    <span class="entity">item_with_id</span> <span class="main">(</span><span class="entity">BoxID.add_incr_id</span> <span class="main">(</span><span class="main">#</span>id <span class="entity">item</span><span class="main">)</span><span class="main">)</span> <span class="entity">item</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">item_replace_incr</span> <span class="entity">item</span> <span class="main">=</span>
    <span class="entity">item_with_id</span> <span class="main">(</span><span class="entity">BoxID.replace_incr_id</span> <span class="main">(</span><span class="main">#</span>id <span class="entity">item</span><span class="main">)</span><span class="main">)</span> <span class="entity">item</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">eq_item</span> <span class="main">(</span><span class="entity">item1</span><span class="main">,</span> <span class="entity">item2</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">#</span>uid <span class="entity">item1</span> <span class="main">=</span> <span class="main">#</span>uid <span class="entity">item2</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">match_ty_str</span> <span class="entity">s</span> <span class="main">{</span><span class="entity">ty_str</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="main">(</span><span class="entity">s</span> <span class="main">=</span> <span class="inner_quoted">""</span> <span class="keyword1"><span class="keyword">orelse</span></span> <span class="entity">s</span> <span class="main">=</span> <span class="entity">ty_str</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">match_ty_strs</span> <span class="entity">slist</span> <span class="main">{</span><span class="entity">ty_str</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> member <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">slist</span> <span class="entity">ty_str</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">merged_id</span> <span class="entity">ctxt</span> <span class="entity">items</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">items</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="main">]</span>
      <span class="main">|</span> <span class="main">{</span><span class="entity">id</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> :: <span class="entity">items'</span> <span class="main">=&gt;</span> <span class="entity">BoxID.merge_boxes</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">merged_id</span> <span class="entity">ctxt</span> <span class="entity">items'</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_box_item</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">uid</span><span class="main">,</span> <span class="entity">id</span><span class="main">,</span> <span class="entity">sc</span><span class="main">,</span> <span class="entity">ritem</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">ritem</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="entity">Handler</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"mk_box_item: ritem must be Fact"</span>
      <span class="main">|</span> <span class="entity">Fact</span> <span class="main">(</span><span class="entity">ty_str</span><span class="main">,</span> <span class="entity">ts</span><span class="main">,</span> <span class="entity">prop</span><span class="main">)</span> <span class="main">=&gt;</span>
        <span class="main">{</span>uid <span class="main">=</span> <span class="entity">uid</span><span class="main">,</span> id <span class="main">=</span> <span class="entity">id</span><span class="main">,</span> sc <span class="main">=</span> <span class="entity">sc</span><span class="main">,</span> ty_str <span class="main">=</span> <span class="entity">ty_str</span><span class="main">,</span>
         tname <span class="main">=</span> map <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">ts</span><span class="main">,</span> prop <span class="main">=</span> <span class="entity">prop</span><span class="main">}</span>

<span class="keyword2"><span class="keyword">end</span></span>  <span class="comment1">(* structure BoxItem. *)</span>

<span class="comment1">(* Specifies a method for matching patterns against items.

   - pre_match is a filter function checking whether it is possible
     for the pattern to match the item, after possibly instantiating
     some schematic variables in the pattern (for example, this
     function should always return true if input pattern is ?A).

   - match is the actual matching function, returning instantiation,
     as well as theorem justifying the instantiated pattern.

   If the matcher is for justifying a proposition, the input term to
   pre_match and match is of type bool. Othewise, the restrictions
   depend on type of item to match.
 *)</span>
<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">item_matcher</span> <span class="main">=</span> <span class="main">{</span>
  pre_match<span class="main">:</span> term <span class="main">-&gt;</span> <span class="entity">box_item</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> bool<span class="main">,</span>
  match<span class="main">:</span> term <span class="main">-&gt;</span> <span class="entity">box_item</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">id_inst</span> <span class="main">-&gt;</span> <span class="entity">id_inst_th</span> list
<span class="main">}</span>

<span class="comment1">(* Output function for items of a given type. *)</span>
<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">item_output</span> <span class="main">=</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term list * thm <span class="main">-&gt;</span> string

<span class="comment1">(* Data structure containing methods involved in the input / output of
   items of a given type.

   - prop_matchers: methods for matching the item against a desired
     proposition.

   - typed_matchers: methods for matching the item against a pattern
     for items of the same type.

   - output_fn: printing function of theorems. Input is tname and the
     proposition.
 *)</span>
<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">item_io_info</span> <span class="main">=</span> <span class="main">{</span>
  prop_matchers<span class="main">:</span> <span class="entity">item_matcher</span> list<span class="main">,</span>
  typed_matchers<span class="main">:</span> <span class="entity">item_matcher</span> list<span class="main">,</span>
  term_fn<span class="main">:</span> <span class="main">(</span>term list <span class="main">-&gt;</span> term list<span class="main">)</span> option<span class="main">,</span>
  output_fn<span class="main">:</span> <span class="entity">item_output</span> option<span class="main">,</span>
  shadow_fn<span class="main">:</span> <span class="main">(</span><span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">box_id</span> <span class="main">-&gt;</span> term list * cterm list <span class="main">-&gt;</span> bool<span class="main">)</span> option
<span class="main">}</span>

<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">match_arg</span> <span class="main">=</span> <span class="entity">PropMatch</span> <span class="keyword2"><span class="keyword">of</span></span> term
                   <span class="main">|</span> <span class="entity">TypedMatch</span> <span class="keyword2"><span class="keyword">of</span></span> string * term
                   <span class="main">|</span> <span class="entity">TypedUniv</span> <span class="keyword2"><span class="keyword">of</span></span> string
                   <span class="main">|</span> <span class="entity">PropertyMatch</span> <span class="keyword2"><span class="keyword">of</span></span> term
                   <span class="main">|</span> <span class="entity">WellFormMatch</span> <span class="keyword2"><span class="keyword">of</span></span> term * term

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">prfstep_filter</span> <span class="main">=</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">id_inst</span> <span class="main">-&gt;</span> bool

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">ITEM_IO</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> pat_of_match_arg<span class="main">:</span> <span class="entity">match_arg</span> <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> subst_arg<span class="main">:</span> Type.tyenv * Envir.tenv <span class="main">-&gt;</span> <span class="entity">match_arg</span> <span class="main">-&gt;</span> <span class="entity">match_arg</span>
  <span class="keyword1"><span class="keyword">val</span></span> assert_valid_arg<span class="main">:</span> <span class="entity">match_arg</span> <span class="main">-&gt;</span> unit
  <span class="keyword1"><span class="keyword">val</span></span> check_ty_str<span class="main">:</span> string <span class="main">-&gt;</span> <span class="entity">match_arg</span> <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> is_ordinary_match<span class="main">:</span> <span class="entity">match_arg</span> <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> is_side_match<span class="main">:</span> <span class="entity">match_arg</span> <span class="main">-&gt;</span> bool

  <span class="keyword1"><span class="keyword">val</span></span> add_item_type<span class="main">:</span>
      string * <span class="main">(</span>term list <span class="main">-&gt;</span> term list<span class="main">)</span> option *
      <span class="entity">item_output</span> option *
      <span class="main">(</span><span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">box_id</span> <span class="main">-&gt;</span> term list * cterm list <span class="main">-&gt;</span> bool<span class="main">)</span> option <span class="main">-&gt;</span>
      theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> add_prop_matcher<span class="main">:</span> string * <span class="entity">item_matcher</span> <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> add_typed_matcher<span class="main">:</span> string * <span class="entity">item_matcher</span> <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> get_io_info<span class="main">:</span> theory <span class="main">-&gt;</span> string <span class="main">-&gt;</span> <span class="entity">item_io_info</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_prop_matchers<span class="main">:</span> theory <span class="main">-&gt;</span> string <span class="main">-&gt;</span> <span class="entity">item_matcher</span> list
  <span class="keyword1"><span class="keyword">val</span></span> get_typed_matchers<span class="main">:</span> theory <span class="main">-&gt;</span> string <span class="main">-&gt;</span> <span class="entity">item_matcher</span> list
  <span class="keyword1"><span class="keyword">val</span></span> prop_matcher<span class="main">:</span> <span class="entity">item_matcher</span>
  <span class="keyword1"><span class="keyword">val</span></span> term_prop_matcher<span class="main">:</span> <span class="entity">item_matcher</span>
  <span class="keyword1"><span class="keyword">val</span></span> null_eq_matcher<span class="main">:</span> <span class="entity">item_matcher</span>
  <span class="keyword1"><span class="keyword">val</span></span> term_typed_matcher<span class="main">:</span> <span class="entity">item_matcher</span>
  <span class="keyword1"><span class="keyword">val</span></span> eq_tname_typed_matcher<span class="main">:</span> <span class="entity">item_matcher</span>
  <span class="keyword1"><span class="keyword">val</span></span> null_property_matcher<span class="main">:</span> <span class="entity">item_matcher</span>
  <span class="keyword1"><span class="keyword">val</span></span> term_property_matcher<span class="main">:</span> <span class="entity">item_matcher</span>
  <span class="keyword1"><span class="keyword">val</span></span> pre_match_arg<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">match_arg</span> <span class="main">-&gt;</span> <span class="entity">box_item</span> <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> match_arg<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">match_arg</span> <span class="main">-&gt;</span> <span class="entity">box_item</span> <span class="main">-&gt;</span> <span class="entity">id_inst</span> <span class="main">-&gt;</span>
                 <span class="entity">id_inst_th</span> list

  <span class="keyword1"><span class="keyword">val</span></span> no_rewr_terms<span class="main">:</span> term list <span class="main">-&gt;</span> term list
  <span class="keyword1"><span class="keyword">val</span></span> rewr_terms_of_item<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string * term list <span class="main">-&gt;</span> term list
  <span class="keyword1"><span class="keyword">val</span></span> output_prop_fn<span class="main">:</span> <span class="entity">item_output</span>
  <span class="keyword1"><span class="keyword">val</span></span> string_of_item_info<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string * term list * thm <span class="main">-&gt;</span> string
  <span class="keyword1"><span class="keyword">val</span></span> add_basic_item_io<span class="main">:</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> string_of_raw_item<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">raw_item</span> <span class="main">-&gt;</span> string
  <span class="keyword1"><span class="keyword">val</span></span> string_of_item<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">box_item</span> <span class="main">-&gt;</span> string
  <span class="keyword1"><span class="keyword">val</span></span> trace_ritem<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string <span class="main">-&gt;</span> <span class="entity">raw_item</span> <span class="main">-&gt;</span> unit
  <span class="keyword1"><span class="keyword">val</span></span> trace_item<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string <span class="main">-&gt;</span> <span class="entity">box_item</span> <span class="main">-&gt;</span> unit
  <span class="keyword1"><span class="keyword">val</span></span> trace_ritems<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string <span class="main">-&gt;</span> <span class="entity">raw_item</span> list <span class="main">-&gt;</span> unit
  <span class="keyword1"><span class="keyword">val</span></span> trace_items<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> string <span class="main">-&gt;</span> <span class="entity">box_item</span> list <span class="main">-&gt;</span> unit
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">ItemIO</span> <span class="main">:</span> <span class="entity">ITEM_IO</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_prop_matcher_to_info</span>
        <span class="entity">mtch</span> <span class="main">{</span><span class="entity">prop_matchers</span><span class="main">,</span> <span class="entity">typed_matchers</span><span class="main">,</span> <span class="entity">term_fn</span><span class="main">,</span> <span class="entity">output_fn</span><span class="main">,</span> <span class="entity">shadow_fn</span><span class="main">}</span> <span class="main">=</span>
    <span class="main">{</span>prop_matchers <span class="main">=</span> <span class="entity">mtch</span> :: <span class="entity">prop_matchers</span><span class="main">,</span> typed_matchers <span class="main">=</span> <span class="entity">typed_matchers</span><span class="main">,</span>
     term_fn <span class="main">=</span> <span class="entity">term_fn</span><span class="main">,</span> output_fn <span class="main">=</span> <span class="entity">output_fn</span><span class="main">,</span> shadow_fn <span class="main">=</span> <span class="entity">shadow_fn</span><span class="main">}</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_typed_matcher_to_info</span>
        <span class="entity">mtch</span> <span class="main">{</span><span class="entity">prop_matchers</span><span class="main">,</span> <span class="entity">typed_matchers</span><span class="main">,</span> <span class="entity">term_fn</span><span class="main">,</span> <span class="entity">output_fn</span><span class="main">,</span> <span class="entity">shadow_fn</span><span class="main">}</span> <span class="main">=</span>
    <span class="main">{</span>prop_matchers <span class="main">=</span> <span class="entity">prop_matchers</span><span class="main">,</span> typed_matchers <span class="main">=</span> <span class="entity">mtch</span> :: <span class="entity">typed_matchers</span><span class="main">,</span>
     term_fn <span class="main">=</span> <span class="entity">term_fn</span><span class="main">,</span> output_fn <span class="main">=</span> <span class="entity">output_fn</span><span class="main">,</span> shadow_fn <span class="main">=</span> <span class="entity">shadow_fn</span><span class="main">}</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">join_infos</span> <span class="main">(</span>
  <span class="main">{</span>prop_matchers <span class="main">=</span> <span class="entity">pm1</span><span class="main">,</span> typed_matchers <span class="main">=</span> <span class="entity">tm1</span><span class="main">,</span> term_fn <span class="main">=</span> <span class="entity">tf1</span><span class="main">,</span> output_fn <span class="main">=</span> <span class="entity">of1</span><span class="main">,</span>
   shadow_fn <span class="main">=</span> <span class="entity">sf1</span><span class="main">}</span><span class="main">,</span>
  <span class="main">{</span>prop_matchers <span class="main">=</span> <span class="entity">pm2</span><span class="main">,</span> typed_matchers <span class="main">=</span> <span class="entity">tm2</span><span class="main">,</span> term_fn <span class="main">=</span> <span class="entity">tf2</span><span class="main">,</span> output_fn <span class="main">=</span> <span class="entity">of2</span><span class="main">,</span>
   shadow_fn <span class="main">=</span> <span class="entity">sf2</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span>
    <span class="main">{</span>prop_matchers <span class="main">=</span> merge pointer_eq <span class="main">(</span><span class="entity">pm1</span><span class="main">,</span> <span class="entity">pm2</span><span class="main">)</span><span class="main">,</span>
     typed_matchers <span class="main">=</span> merge pointer_eq <span class="main">(</span><span class="entity">tm1</span><span class="main">,</span> <span class="entity">tm2</span><span class="main">)</span><span class="main">,</span>
     term_fn <span class="main">=</span> <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> pointer_eq <span class="main">(</span><span class="entity">tf1</span><span class="main">,</span> <span class="entity">tf2</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">tf1</span>
                <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"join_infos: term_fn non-equal"</span><span class="main">)</span><span class="main">,</span>
     output_fn <span class="main">=</span> <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> pointer_eq <span class="main">(</span><span class="entity">of1</span><span class="main">,</span> <span class="entity">of2</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">of1</span>
                  <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"join_infos: output_fn non-equal"</span><span class="main">)</span><span class="main">,</span>
     shadow_fn <span class="main">=</span> <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> pointer_eq <span class="main">(</span><span class="entity">sf1</span><span class="main">,</span> <span class="entity">sf2</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">sf1</span>
                  <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"join_infos: shadow_fn non-equal"</span><span class="main">)</span><span class="main">}</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Data</span> <span class="main">=</span> Theory_Data <span class="main">(</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">T</span> <span class="main">=</span> <span class="entity">item_io_info</span> Symtab.table
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">empty</span> <span class="main">=</span> Symtab.empty
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">extend</span> <span class="main">=</span> I<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">merge</span> <span class="main">=</span> Symtab.join <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">join_infos</span><span class="main">)</span>
<span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pat_of_match_arg</span> <span class="entity">arg</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">arg</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="entity">PropMatch</span> <span class="entity">pat</span> <span class="main">=&gt;</span> <span class="entity">pat</span>
      <span class="main">|</span> <span class="entity">TypedMatch</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">pat</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">pat</span>
      <span class="main">|</span> <span class="entity">TypedUniv</span> <span class="main">_</span> <span class="main">=&gt;</span> Term.dummy
      <span class="main">|</span> <span class="entity">PropertyMatch</span> <span class="entity">pat</span> <span class="main">=&gt;</span> <span class="entity">pat</span>
      <span class="main">|</span> <span class="entity">WellFormMatch</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">req</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">req</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">subst_arg</span> <span class="entity">inst</span> <span class="entity">arg</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">arg</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="entity">PropMatch</span> <span class="entity">pat</span> <span class="main">=&gt;</span> <span class="entity">PropMatch</span> <span class="main">(</span><span class="entity">Util.subst_term_norm</span> <span class="entity">inst</span> <span class="entity">pat</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">TypedMatch</span> <span class="main">(</span><span class="entity">ty_str</span><span class="main">,</span> <span class="entity">pat</span><span class="main">)</span> <span class="main">=&gt;</span>
        <span class="entity">TypedMatch</span> <span class="main">(</span><span class="entity">ty_str</span><span class="main">,</span> <span class="entity">Util.subst_term_norm</span> <span class="entity">inst</span> <span class="entity">pat</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">TypedUniv</span> <span class="entity">ty_str</span> <span class="main">=&gt;</span> <span class="entity">TypedUniv</span> <span class="entity">ty_str</span>
      <span class="main">|</span> <span class="entity">PropertyMatch</span> <span class="entity">pat</span> <span class="main">=&gt;</span>
        <span class="entity">PropertyMatch</span> <span class="main">(</span><span class="entity">Util.subst_term_norm</span> <span class="entity">inst</span> <span class="entity">pat</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">WellFormMatch</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">req</span><span class="main">)</span> <span class="main">=&gt;</span>
        <span class="entity">WellFormMatch</span> <span class="main">(</span><span class="entity">Util.subst_term_norm</span> <span class="entity">inst</span> <span class="entity">t</span><span class="main">,</span> <span class="entity">Util.subst_term_norm</span> <span class="entity">inst</span> <span class="entity">req</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">assert_valid_arg</span> <span class="entity">arg</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">arg</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="entity">PropMatch</span> <span class="entity">pat</span> <span class="main">=&gt;</span>
        <span class="entity">assert</span> <span class="main">(</span>fastype_of <span class="entity">pat</span> <span class="main">=</span> <span class="entity">boolT</span><span class="main">)</span>
               <span class="inner_quoted">"assert_valid_arg: arg for PropMatch should be bool."</span>
      <span class="main">|</span> <span class="entity">TypedMatch</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">TypedUniv</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">PropertyMatch</span> <span class="entity">pat</span> <span class="main">=&gt;</span>
        <span class="entity">assert</span> <span class="main">(</span>fastype_of <span class="entity">pat</span> <span class="main">=</span> <span class="entity">boolT</span><span class="main">)</span>
               <span class="inner_quoted">"assert_valid_arg: arg for PropertyMatch should be bool."</span>
      <span class="main">|</span> <span class="entity">WellFormMatch</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">req</span><span class="main">)</span> <span class="main">=&gt;</span>
        <span class="entity">assert</span> <span class="main">(</span>fastype_of <span class="entity">req</span> <span class="main">=</span> <span class="entity">boolT</span><span class="main">)</span>
               <span class="inner_quoted">"assert_valid_arg: arg for WellFormMatch should be bool."</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">check_ty_str</span> <span class="entity">ty_str</span> <span class="entity">arg</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">arg</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="entity">TypedMatch</span> <span class="main">(</span><span class="entity">ty_str'</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">ty_str</span> <span class="main">=</span> <span class="entity">ty_str'</span>
      <span class="main">|</span> <span class="entity">TypedUniv</span> <span class="entity">ty_str'</span> <span class="main">=&gt;</span> <span class="entity">ty_str</span> <span class="main">=</span> <span class="entity">ty_str'</span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> true

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_ordinary_match</span> <span class="entity">arg</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">arg</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="entity">PropMatch</span> <span class="main">_</span> <span class="main">=&gt;</span> true
              <span class="main">|</span> <span class="entity">TypedMatch</span> <span class="main">_</span> <span class="main">=&gt;</span> true
              <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_side_match</span> <span class="entity">arg</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">arg</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="entity">PropertyMatch</span> <span class="main">_</span> <span class="main">=&gt;</span> true
              <span class="main">|</span> <span class="entity">WellFormMatch</span> <span class="main">_</span> <span class="main">=&gt;</span> true
              <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_item_type</span> <span class="main">(</span><span class="entity">ty_str</span><span class="main">,</span> <span class="entity">term_fn</span><span class="main">,</span> <span class="entity">output_fn</span><span class="main">,</span> <span class="entity">shadow_fn</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">item_info</span> <span class="main">=</span> <span class="main">{</span>prop_matchers <span class="main">=</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span> typed_matchers <span class="main">=</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span>
                       term_fn <span class="main">=</span> <span class="entity">term_fn</span><span class="main">,</span> output_fn <span class="main">=</span> <span class="entity">output_fn</span><span class="main">,</span>
                       shadow_fn <span class="main">=</span> <span class="entity">shadow_fn</span><span class="main">}</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      Data.map <span class="main">(</span>Symtab.update_new <span class="main">(</span><span class="entity">ty_str</span><span class="main">,</span> <span class="entity">item_info</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_prop_matcher</span> <span class="main">(</span><span class="entity">ty_str</span><span class="main">,</span> <span class="entity">it_match</span><span class="main">)</span> <span class="main">=</span> Data.map <span class="main">(</span>
      Symtab.map_entry <span class="entity">ty_str</span> <span class="main">(</span><span class="entity">add_prop_matcher_to_info</span> <span class="entity">it_match</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_typed_matcher</span> <span class="main">(</span><span class="entity">ty_str</span><span class="main">,</span> <span class="entity">it_match</span><span class="main">)</span> <span class="main">=</span> Data.map <span class="main">(</span>
      Symtab.map_entry <span class="entity">ty_str</span> <span class="main">(</span><span class="entity">add_typed_matcher_to_info</span> <span class="entity">it_match</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_io_info</span> <span class="entity">thy</span> <span class="entity">ty_str</span> <span class="main">=</span>
    the <span class="main">(</span>Symtab.lookup <span class="main">(</span>Data.get <span class="entity">thy</span><span class="main">)</span> <span class="entity">ty_str</span><span class="main">)</span>
    <span class="keyword3"><span class="keyword">handle</span></span> Option.Option <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="main">(</span><span class="inner_quoted">"get_io_info: not found "</span> ^ <span class="entity">ty_str</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_prop_matchers</span> <span class="entity">thy</span> <span class="entity">ty_str</span> <span class="main">=</span> <span class="main">#</span>prop_matchers <span class="main">(</span><span class="entity">get_io_info</span> <span class="entity">thy</span> <span class="entity">ty_str</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_typed_matchers</span> <span class="entity">thy</span> <span class="entity">ty_str</span> <span class="main">=</span> <span class="main">#</span>typed_matchers <span class="main">(</span><span class="entity">get_io_info</span> <span class="entity">thy</span> <span class="entity">ty_str</span><span class="main">)</span>

<span class="comment1">(* Prop-matching with a PROP item. *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prop_matcher</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pre_match</span> <span class="entity">pat</span> <span class="main">{</span><span class="entity">tname</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="entity">ctxt</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ct</span> <span class="main">=</span> the_single <span class="entity">tname</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Thm.term_of <span class="entity">ct</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_neg</span> <span class="entity">pat</span> <span class="keyword2"><span class="keyword">then</span></span>
              <span class="entity">is_neg</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">andalso</span></span>
              <span class="entity">Matcher.pre_match_head</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">get_neg</span> <span class="entity">pat</span><span class="main">,</span> <span class="entity">UtilLogic.get_cneg</span> <span class="entity">ct</span><span class="main">)</span>
            <span class="keyword2"><span class="keyword">else</span></span>
              Term.is_Var <span class="entity">pat</span> <span class="keyword1"><span class="keyword">orelse</span></span>
              <span class="main">(</span>not <span class="main">(</span><span class="entity">is_neg</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">Matcher.pre_match_head</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">pat</span><span class="main">,</span> <span class="entity">ct</span><span class="main">)</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">match</span> <span class="entity">pat</span> <span class="main">{</span><span class="entity">tname</span><span class="main">,</span> <span class="entity">prop</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ct</span> <span class="main">=</span> the_single <span class="entity">tname</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Thm.term_of <span class="entity">ct</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_neg</span> <span class="entity">pat</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_neg</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
              <span class="keyword2"><span class="keyword">let</span></span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">insts'</span> <span class="main">=</span> <span class="entity">Matcher.rewrite_match_head</span>
                                 <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">get_neg</span> <span class="entity">pat</span><span class="main">,</span> <span class="entity">UtilLogic.get_cneg</span> <span class="entity">ct</span><span class="main">)</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span>
                <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_inst</span> <span class="main">(</span><span class="entity">inst</span><span class="main">,</span> <span class="entity">eq_th</span><span class="main">)</span> <span class="main">=</span>
                    <span class="keyword2"><span class="keyword">let</span></span>
                      <span class="comment1">(* This version certainly will not cancel ~~ on
                         two sides.
                       *)</span>
                      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">make_neg_eq'</span> <span class="main">=</span> Thm.combination <span class="main">(</span>Thm.reflexive <span class="entity">UtilBase.cNot</span><span class="main">)</span>
                    <span class="keyword2"><span class="keyword">in</span></span>
                      <span class="main">(</span><span class="entity">inst</span><span class="main">,</span> Thm.equal_elim <span class="main">(</span>
                         <span class="entity">make_trueprop_eq</span> <span class="main">(</span><span class="entity">make_neg_eq'</span> <span class="main">(</span><span class="entity">meta_sym</span> <span class="entity">eq_th</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="entity">prop</span><span class="main">)</span>
                    <span class="keyword2"><span class="keyword">end</span></span>
              <span class="keyword2"><span class="keyword">in</span></span>
                map <span class="entity">process_inst</span> <span class="entity">insts'</span>
              <span class="keyword2"><span class="keyword">end</span></span>
            <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span><span class="entity">is_neg</span> <span class="entity">pat</span><span class="main">)</span> <span class="keyword1"><span class="keyword">andalso</span></span>
                    <span class="main">(</span>Term.is_Var <span class="entity">pat</span> <span class="keyword1"><span class="keyword">orelse</span></span> not <span class="main">(</span><span class="entity">is_neg</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
              <span class="keyword2"><span class="keyword">let</span></span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">insts'</span> <span class="main">=</span> <span class="entity">Matcher.rewrite_match_head</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">pat</span><span class="main">,</span> <span class="entity">ct</span><span class="main">)</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span>
                <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_inst</span> <span class="main">(</span><span class="entity">inst</span><span class="main">,</span> <span class="entity">eq_th</span><span class="main">)</span> <span class="main">=</span>
                    <span class="main">(</span><span class="entity">inst</span><span class="main">,</span> Thm.equal_elim <span class="main">(</span>
                       <span class="entity">make_trueprop_eq</span> <span class="main">(</span><span class="entity">meta_sym</span> <span class="entity">eq_th</span><span class="main">)</span><span class="main">)</span> <span class="entity">prop</span><span class="main">)</span>
              <span class="keyword2"><span class="keyword">in</span></span>
                map <span class="entity">process_inst</span> <span class="entity">insts'</span>
              <span class="keyword2"><span class="keyword">end</span></span>
            <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="main">]</span>
          <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">{</span>pre_match <span class="main">=</span> <span class="entity">pre_match</span><span class="main">,</span> match <span class="main">=</span> <span class="entity">match</span><span class="main">}</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Prop-matching with a TERM item (used to justify equalities). *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">term_prop_matcher</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pre_match</span> <span class="entity">pat</span> <span class="main">{</span><span class="entity">tname</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="entity">ctxt</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span><span class="entity">Util.has_vars</span> <span class="entity">pat</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> false
          <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_eq_term</span> <span class="entity">pat</span> <span class="keyword2"><span class="keyword">then</span></span>
            <span class="entity">Matcher.pre_match</span> <span class="entity">ctxt</span> <span class="main">(</span>fst <span class="main">(</span><span class="entity">dest_eq</span> <span class="entity">pat</span><span class="main">)</span><span class="main">,</span> the_single <span class="entity">tname</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">else</span></span> false

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">match</span> <span class="entity">pat</span> <span class="main">{</span><span class="entity">tname</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span><span class="entity">is_eq_term</span> <span class="entity">pat</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span> <span class="keyword2"><span class="keyword">else</span></span>
          <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span><span class="entity">Util.has_vars</span> <span class="entity">pat</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span> <span class="keyword2"><span class="keyword">else</span></span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">dest_eq</span> <span class="entity">pat</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cu</span> <span class="main">=</span> the_single <span class="entity">tname</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pairs</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> Term.is_Var <span class="entity">lhs</span> <span class="keyword2"><span class="keyword">then</span></span>
                          <span class="main">[</span><span class="main">(</span>false<span class="main">,</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">cu</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span>true<span class="main">,</span> <span class="main">(</span><span class="entity">rhs</span><span class="main">,</span> <span class="entity">cu</span><span class="main">)</span><span class="main">)</span><span class="main">]</span>
                        <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="main">(</span>true<span class="main">,</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">cu</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span>false<span class="main">,</span> <span class="main">(</span><span class="entity">rhs</span><span class="main">,</span> <span class="entity">cu</span><span class="main">)</span><span class="main">)</span><span class="main">]</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">insts'</span> <span class="main">=</span> <span class="entity">Matcher.rewrite_match_list</span> <span class="entity">ctxt</span> <span class="entity">pairs</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_inst</span> <span class="main">(</span><span class="entity">inst</span><span class="main">,</span> <span class="entity">ths</span><span class="main">)</span> <span class="main">=</span>
                <span class="keyword2"><span class="keyword">let</span></span>
                  <span class="comment1">(* th1: lhs(env) == u, th2: rhs(env) == u. *)</span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">th1</span><span class="main">,</span> <span class="entity">th2</span><span class="main">)</span> <span class="main">=</span> <span class="entity">the_pair</span> <span class="entity">ths</span>
                <span class="keyword2"><span class="keyword">in</span></span>
                  <span class="main">(</span><span class="entity">inst</span><span class="main">,</span> <span class="entity">to_obj_eq</span> <span class="main">(</span><span class="entity">Util.transitive_list</span> <span class="main">[</span><span class="entity">th1</span><span class="main">,</span> <span class="entity">meta_sym</span> <span class="entity">th2</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
                <span class="keyword2"><span class="keyword">end</span></span>
          <span class="keyword2"><span class="keyword">in</span></span>
            map <span class="entity">process_inst</span> <span class="entity">insts'</span>
          <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">{</span>pre_match <span class="main">=</span> <span class="entity">pre_match</span><span class="main">,</span> match <span class="main">=</span> <span class="entity">match</span><span class="main">}</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">null_eq_matcher</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pre_match</span> <span class="entity">pat</span> <span class="main">_</span> <span class="main">_</span> <span class="main">=</span> <span class="entity">is_eq_term</span> <span class="entity">pat</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">match</span> <span class="entity">pat</span> <span class="main">_</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span><span class="entity">is_eq_term</span> <span class="entity">pat</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span> <span class="keyword2"><span class="keyword">else</span></span>
          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">Util.has_vars</span> <span class="entity">pat</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span> <span class="keyword2"><span class="keyword">else</span></span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">dest_eq</span> <span class="entity">pat</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">infos</span> <span class="main">=</span> <span class="entity">RewriteTable.equiv_info_t</span> <span class="entity">ctxt</span> <span class="entity">id</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_info</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=</span>
                <span class="main">(</span><span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span><span class="main">,</span> <span class="entity">to_obj_eq</span> <span class="entity">th</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            map <span class="entity">process_info</span> <span class="entity">infos</span>
          <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">{</span>pre_match <span class="main">=</span> <span class="entity">pre_match</span><span class="main">,</span> match <span class="main">=</span> <span class="entity">match</span><span class="main">}</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Typed matching with a TERM item. *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">term_typed_matcher</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pre_match</span> <span class="entity">pat</span> <span class="main">{</span><span class="entity">tname</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="entity">ctxt</span> <span class="main">=</span>
          <span class="entity">Matcher.pre_match_head</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">pat</span><span class="main">,</span> the_single <span class="entity">tname</span><span class="main">)</span>

      <span class="comment1">(* Return value is (inst, eq), where eq is pat(inst) == tname. *)</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">match</span> <span class="entity">pat</span> <span class="main">{</span><span class="entity">tname</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span> <span class="main">=</span>
          <span class="entity">Matcher.rewrite_match_head</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">pat</span><span class="main">,</span> the_single <span class="entity">tname</span><span class="main">)</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">{</span>pre_match <span class="main">=</span> <span class="entity">pre_match</span><span class="main">,</span> match <span class="main">=</span> <span class="entity">match</span><span class="main">}</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Typed matching for items representing an equality ?A = ?B, where
   the tname is the pair (?A, ?B). Pattern is expected to be of the
   form ?A = ?B.
 *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq_tname_typed_matcher</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pre_match</span> <span class="entity">pat</span> <span class="main">{</span><span class="entity">tname</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="entity">ctxt</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">the_pair</span> <span class="main">(</span>map Thm.term_of <span class="entity">tname</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> Pattern.first_order_match <span class="entity">thy</span> <span class="main">(</span><span class="entity">pat</span><span class="main">,</span> <span class="entity">mk_eq</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span><span class="main">)</span> <span class="entity">fo_init</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            true
          <span class="keyword2"><span class="keyword">end</span></span>
          <span class="keyword3"><span class="keyword">handle</span></span> Pattern.MATCH <span class="main">=&gt;</span> false

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">match</span> <span class="entity">pat</span> <span class="main">{</span><span class="entity">tname</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">the_pair</span> <span class="main">(</span>map Thm.term_of <span class="entity">tname</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inst'</span> <span class="main">=</span>
                Pattern.first_order_match <span class="entity">thy</span> <span class="main">(</span><span class="entity">pat</span><span class="main">,</span> <span class="entity">mk_eq</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span><span class="main">)</span> <span class="entity">inst</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="main">[</span><span class="main">(</span><span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">inst'</span><span class="main">)</span><span class="main">,</span> <span class="entity">true_th</span><span class="main">)</span><span class="main">]</span>
          <span class="keyword2"><span class="keyword">end</span></span>
          <span class="keyword3"><span class="keyword">handle</span></span> Pattern.MATCH <span class="main">=&gt;</span> <span class="main">[</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">{</span>pre_match <span class="main">=</span> <span class="entity">pre_match</span><span class="main">,</span> match <span class="main">=</span> <span class="entity">match</span><span class="main">}</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Obtain a proposition from the property table. *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">null_property_matcher</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pre_match</span> <span class="entity">pat</span> <span class="main">_</span> <span class="main">_</span> <span class="main">=</span>
          <span class="entity">Property.is_property</span> <span class="entity">pat</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">match</span> <span class="entity">pat</span> <span class="main">_</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">Util.has_vars</span> <span class="entity">pat</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span>
          <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span><span class="entity">Property.is_property</span> <span class="entity">pat</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span>
          <span class="keyword2"><span class="keyword">else</span></span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">)</span>
                   <span class="main">(</span><span class="entity">PropertyData.get_property_t</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">pat</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">{</span>pre_match <span class="main">=</span> <span class="entity">pre_match</span><span class="main">,</span> match <span class="main">=</span> <span class="entity">match</span><span class="main">}</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Obtain a proposition from the property table, matching the argument
   of the property with the given term.
 *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">term_property_matcher</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pre_match</span> <span class="entity">pat</span> <span class="main">{</span><span class="entity">tname</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="entity">ctxt</span> <span class="main">=</span>
          <span class="entity">Property.is_property</span> <span class="entity">pat</span> <span class="keyword1"><span class="keyword">andalso</span></span>
          <span class="entity">Matcher.pre_match_head</span> <span class="entity">ctxt</span> <span class="main">(</span>
            <span class="entity">Property.get_property_arg</span> <span class="entity">pat</span><span class="main">,</span> the_single <span class="entity">tname</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">match</span> <span class="entity">pat</span> <span class="main">{</span><span class="entity">tname</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span><span class="entity">Util.has_vars</span> <span class="entity">pat</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span> <span class="keyword2"><span class="keyword">else</span></span>
          <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span><span class="entity">Property.is_property</span> <span class="entity">pat</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
            <span class="main">[</span><span class="main">]</span>
          <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg</span> <span class="main">=</span> <span class="entity">Property.get_property_arg</span> <span class="entity">pat</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="keyword2"><span class="keyword">let</span></span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">insts'</span> <span class="main">=</span> <span class="entity">Matcher.rewrite_match_head</span>
                               <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">arg</span><span class="main">,</span> the_single <span class="entity">tname</span><span class="main">)</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span>
              <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_inst</span> <span class="main">(</span><span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">inst'</span><span class="main">)</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span>
                  <span class="keyword2"><span class="keyword">let</span></span>
                    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">Util.subst_term_norm</span> <span class="entity">inst'</span> <span class="entity">pat</span>
                  <span class="keyword2"><span class="keyword">in</span></span>
                    map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">id''</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">(</span><span class="entity">id''</span><span class="main">,</span> <span class="entity">inst'</span><span class="main">)</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">)</span>
                        <span class="main">(</span><span class="entity">PropertyData.get_property_t</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span>
                  <span class="keyword2"><span class="keyword">end</span></span>
            <span class="keyword2"><span class="keyword">in</span></span>
              maps <span class="entity">process_inst</span> <span class="entity">insts'</span>
            <span class="keyword2"><span class="keyword">end</span></span>
          <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">{</span>pre_match <span class="main">=</span> <span class="entity">pre_match</span><span class="main">,</span> match <span class="main">=</span> <span class="entity">match</span><span class="main">}</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Generic pre-matching function. Returns whether there is a possible
   match among any of the registered matchers.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pre_match_arg</span> <span class="entity">ctxt</span> <span class="entity">arg</span> <span class="main">(</span><span class="entity">item</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">{</span><span class="entity">ty_str</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span><span class="entity">check_ty_str</span> <span class="entity">ty_str</span> <span class="entity">arg</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> false <span class="keyword2"><span class="keyword">else</span></span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert_valid_arg</span> <span class="entity">arg</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">prop_matchers</span><span class="main">,</span> <span class="entity">typed_matchers</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">get_io_info</span> <span class="entity">thy</span> <span class="entity">ty_str</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">arg</span> <span class="keyword2"><span class="keyword">of</span></span>
          <span class="entity">PropMatch</span> <span class="entity">pat</span> <span class="main">=&gt;</span>
          Term.is_Var <span class="entity">pat</span> <span class="keyword1"><span class="keyword">orelse</span></span>
          <span class="main">(</span><span class="entity">is_neg</span> <span class="entity">pat</span> <span class="keyword1"><span class="keyword">andalso</span></span> Term.is_Var <span class="main">(</span><span class="entity">get_neg</span> <span class="entity">pat</span><span class="main">)</span><span class="main">)</span> <span class="keyword1"><span class="keyword">orelse</span></span>
          not <span class="main">(</span><span class="entity">Util.is_pattern</span> <span class="entity">pat</span><span class="main">)</span> <span class="keyword1"><span class="keyword">orelse</span></span>
          exists <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">f</span> <span class="main">=&gt;</span> <span class="entity">f</span> <span class="entity">pat</span> <span class="entity">item</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="main">(</span>map <span class="main">#</span>pre_match <span class="entity">prop_matchers</span><span class="main">)</span>
        <span class="main">|</span> <span class="entity">TypedMatch</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">pat</span><span class="main">)</span> <span class="main">=&gt;</span>
          not <span class="main">(</span><span class="entity">Util.is_pattern</span> <span class="entity">pat</span><span class="main">)</span> <span class="keyword1"><span class="keyword">orelse</span></span>
          exists <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">f</span> <span class="main">=&gt;</span> <span class="entity">f</span> <span class="entity">pat</span> <span class="entity">item</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="main">(</span>map <span class="main">#</span>pre_match <span class="entity">typed_matchers</span><span class="main">)</span>
        <span class="main">|</span> <span class="entity">TypedUniv</span> <span class="main">_</span> <span class="main">=&gt;</span> true
        <span class="main">|</span> <span class="entity">PropertyMatch</span> <span class="main">_</span> <span class="main">=&gt;</span>
          <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"pre_match_arg: should not be called on PropertyMatch."</span>
        <span class="main">|</span> <span class="entity">WellFormMatch</span> <span class="main">_</span> <span class="main">=&gt;</span>
          <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"pre_match_arg: should not be called on WellFormMatch."</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Generic matching function. Returns list of all matches (iterating
   over all registered matchers for the given item type. Note box_id
   for item is taken into account here.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">match_arg</span> <span class="entity">ctxt</span> <span class="entity">arg</span> <span class="main">(</span><span class="entity">item</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">{</span><span class="entity">id</span><span class="main">,</span> <span class="entity">ty_str</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span><span class="entity">check_ty_str</span> <span class="entity">ty_str</span> <span class="entity">arg</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span> <span class="keyword2"><span class="keyword">else</span></span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert_valid_arg</span> <span class="entity">arg</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">prop_matchers</span><span class="main">,</span> <span class="entity">typed_matchers</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">get_io_info</span> <span class="entity">thy</span> <span class="entity">ty_str</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pat</span> <span class="main">=</span> <span class="entity">pat_of_match_arg</span> <span class="entity">arg</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">id''</span> <span class="main">=</span> <span class="entity">BoxID.merge_boxes</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">id'</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">arg</span> <span class="keyword2"><span class="keyword">of</span></span>
          <span class="entity">PropMatch</span> <span class="main">_</span> <span class="main">=&gt;</span> maps <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">f</span> <span class="main">=&gt;</span> <span class="entity">f</span> <span class="entity">pat</span> <span class="entity">item</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id''</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span><span class="main">)</span>
                              <span class="main">(</span>map <span class="main">#</span>match <span class="entity">prop_matchers</span><span class="main">)</span>
        <span class="main">|</span> <span class="entity">TypedUniv</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="main">(</span><span class="main">(</span><span class="entity">id''</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span><span class="main">,</span> <span class="entity">true_th</span><span class="main">)</span><span class="main">]</span>
        <span class="main">|</span> <span class="entity">TypedMatch</span> <span class="main">_</span> <span class="main">=&gt;</span> maps <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">f</span> <span class="main">=&gt;</span> <span class="entity">f</span> <span class="entity">pat</span> <span class="entity">item</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id''</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span><span class="main">)</span>
                               <span class="main">(</span>map <span class="main">#</span>match <span class="entity">typed_matchers</span><span class="main">)</span>
        <span class="main">|</span> <span class="entity">PropertyMatch</span> <span class="main">_</span> <span class="main">=&gt;</span>
          <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"match_arg: should not be called on PropertyMatch."</span>
        <span class="main">|</span> <span class="entity">WellFormMatch</span> <span class="main">_</span> <span class="main">=&gt;</span>
          <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"match_arg: should not be called on WellFormMatch."</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">no_rewr_terms</span> <span class="main">=</span> K <span class="main">[</span><span class="main">]</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">arg_rewr_terms</span> <span class="entity">ts</span> <span class="main">=</span> maps <span class="entity">Util.dest_args</span> <span class="entity">ts</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prop_rewr_terms</span> <span class="entity">ts</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> the_single <span class="entity">ts</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_neg</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">t</span> |&gt; <span class="entity">dest_arg</span> |&gt; <span class="entity">Util.dest_args</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">t</span> |&gt; <span class="entity">Util.dest_args</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rewr_terms_of_item</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">ty_str</span><span class="main">,</span> <span class="entity">tname</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">term_fn</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">get_io_info</span> <span class="entity">thy</span> <span class="entity">ty_str</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">term_fn</span> <span class="keyword2"><span class="keyword">of</span></span>
          NONE <span class="main">=&gt;</span> <span class="entity">tname</span>
        <span class="main">|</span> SOME <span class="entity">f</span> <span class="main">=&gt;</span> <span class="entity">f</span> <span class="entity">tname</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">output_prop_fn</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=</span> Thm.prop_of <span class="entity">th</span> |&gt; Syntax.string_of_term <span class="entity">ctxt</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">string_of_item_info</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">ty_str</span><span class="main">,</span> <span class="entity">ts</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">output_fn</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">get_io_info</span> <span class="entity">thy</span> <span class="entity">ty_str</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">output_fn</span> <span class="keyword2"><span class="keyword">of</span></span>
          NONE <span class="main">=&gt;</span> <span class="entity">ty_str</span> ^ <span class="inner_quoted">" "</span> ^ <span class="main">(</span><span class="entity">Util.string_of_terms</span> <span class="entity">ctxt</span> <span class="entity">ts</span><span class="main">)</span>
        <span class="main">|</span> SOME <span class="entity">f</span> <span class="main">=&gt;</span> <span class="entity">f</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">ts</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">string_of_raw_item</span> <span class="entity">ctxt</span> <span class="entity">ritem</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">ritem</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="entity">Handler</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">t</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="inner_quoted">"Handler "</span> ^ <span class="main">(</span>Syntax.string_of_term <span class="entity">ctxt</span> <span class="entity">t</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">Fact</span> <span class="entity">info</span> <span class="main">=&gt;</span> <span class="entity">string_of_item_info</span> <span class="entity">ctxt</span> <span class="entity">info</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">string_of_item</span> <span class="entity">ctxt</span> <span class="main">{</span><span class="entity">ty_str</span><span class="main">,</span> <span class="entity">tname</span><span class="main">,</span> <span class="entity">prop</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span>
    <span class="entity">string_of_item_info</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">ty_str</span><span class="main">,</span> map Thm.term_of <span class="entity">tname</span><span class="main">,</span> <span class="entity">prop</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">trace_ritem</span> <span class="entity">ctxt</span> <span class="entity">s</span> <span class="entity">ritem</span> <span class="main">=</span>
    tracing <span class="main">(</span><span class="entity">s</span> ^ <span class="inner_quoted">" "</span> ^ <span class="main">(</span><span class="entity">string_of_raw_item</span> <span class="entity">ctxt</span> <span class="entity">ritem</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">trace_ritems</span> <span class="entity">ctxt</span> <span class="entity">s</span> <span class="entity">ritems</span> <span class="main">=</span>
    tracing <span class="main">(</span><span class="entity">s</span> ^ <span class="inner_quoted">"\n"</span> ^ <span class="main">(</span>cat_lines <span class="main">(</span>map <span class="main">(</span><span class="entity">string_of_raw_item</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">ritems</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">trace_item</span> <span class="entity">ctxt</span> <span class="entity">s</span> <span class="entity">item</span> <span class="main">=</span>
    tracing <span class="main">(</span><span class="entity">s</span> ^ <span class="inner_quoted">" "</span> ^ <span class="main">(</span><span class="entity">string_of_item</span> <span class="entity">ctxt</span> <span class="entity">item</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">trace_items</span> <span class="entity">ctxt</span> <span class="entity">s</span> <span class="entity">items</span> <span class="main">=</span>
    tracing <span class="main">(</span><span class="entity">s</span> ^ <span class="inner_quoted">"\n"</span> ^ <span class="main">(</span>cat_lines <span class="main">(</span>map <span class="main">(</span><span class="entity">string_of_item</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">items</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

<span class="comment1">(* We assume ts1 is the new item at the given id, while cts2 is for an
   existing item, at some previous id.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">shadow_prop_fn</span> <span class="entity">ctxt</span> <span class="entity">id</span> <span class="main">(</span><span class="entity">ts1</span><span class="main">,</span> <span class="entity">cts2</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">ct2</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>the_single <span class="entity">ts1</span><span class="main">,</span> the_single <span class="entity">cts2</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">crhs</span><span class="main">)</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_neg</span> <span class="entity">t1</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_neg</span> <span class="main">(</span>Thm.term_of <span class="entity">ct2</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
                          <span class="main">(</span><span class="entity">get_neg</span> <span class="entity">t1</span><span class="main">,</span> <span class="entity">UtilLogic.get_cneg</span> <span class="entity">ct2</span><span class="main">)</span>
                        <span class="keyword2"><span class="keyword">else</span></span>
                          <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">ct2</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">(</span><span class="entity">Matcher.rewrite_match_head</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">crhs</span><span class="main">)</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">fo_init</span><span class="main">)</span><span class="main">)</span>
          |&gt; filter <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">id'</span> <span class="main">=</span> <span class="entity">id</span><span class="main">)</span>
          |&gt; not o null
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">shadow_term_fn</span> <span class="entity">ctxt</span> <span class="entity">id</span> <span class="main">(</span><span class="entity">ts1</span><span class="main">,</span> <span class="entity">cts2</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">crhs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>the_single <span class="entity">ts1</span><span class="main">,</span> the_single <span class="entity">cts2</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">(</span><span class="entity">Matcher.rewrite_match_head</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">crhs</span><span class="main">)</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">fo_init</span><span class="main">)</span><span class="main">)</span>
          |&gt; filter <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">id'</span> <span class="main">=</span> <span class="entity">id</span><span class="main">)</span>
          |&gt; not o null
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">add_basic_item_io</span> <span class="main">=</span>
    fold <span class="entity">add_item_type</span> <span class="main">[</span>
      <span class="main">(</span><span class="entity">TY_NULL</span><span class="main">,</span> NONE<span class="main">,</span> NONE<span class="main">,</span> NONE<span class="main">)</span><span class="main">,</span>
      <span class="main">(</span><span class="entity">TY_PROP</span><span class="main">,</span> SOME <span class="entity">prop_rewr_terms</span><span class="main">,</span> SOME <span class="entity">output_prop_fn</span><span class="main">,</span> SOME <span class="entity">shadow_prop_fn</span><span class="main">)</span><span class="main">,</span>
      <span class="main">(</span><span class="entity">TY_TERM</span><span class="main">,</span> SOME <span class="entity">no_rewr_terms</span><span class="main">,</span> NONE<span class="main">,</span> SOME <span class="entity">shadow_term_fn</span><span class="main">)</span><span class="main">,</span>
      <span class="main">(</span><span class="entity">TY_EQ</span><span class="main">,</span> NONE<span class="main">,</span> SOME <span class="entity">output_prop_fn</span><span class="main">,</span> NONE<span class="main">)</span><span class="main">,</span>
      <span class="main">(</span><span class="entity">TY_VAR</span><span class="main">,</span> NONE<span class="main">,</span> NONE<span class="main">,</span> NONE<span class="main">)</span><span class="main">,</span>
      <span class="main">(</span><span class="entity">TY_PROPERTY</span><span class="main">,</span> SOME <span class="entity">arg_rewr_terms</span><span class="main">,</span> NONE<span class="main">,</span> NONE<span class="main">)</span>

    <span class="main">]</span> #&gt; fold <span class="entity">add_prop_matcher</span> <span class="main">[</span>
      <span class="main">(</span><span class="entity">TY_PROP</span><span class="main">,</span> <span class="entity">prop_matcher</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">TY_TERM</span><span class="main">,</span> <span class="entity">term_prop_matcher</span><span class="main">)</span><span class="main">,</span>
      <span class="main">(</span><span class="entity">TY_NULL</span><span class="main">,</span> <span class="entity">null_eq_matcher</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">TY_NULL</span><span class="main">,</span> <span class="entity">null_property_matcher</span><span class="main">)</span><span class="main">,</span>
      <span class="main">(</span><span class="entity">TY_TERM</span><span class="main">,</span> <span class="entity">term_property_matcher</span><span class="main">)</span>

    <span class="main">]</span> #&gt; fold <span class="entity">add_typed_matcher</span> <span class="main">[</span>
      <span class="main">(</span><span class="entity">TY_PROP</span><span class="main">,</span> <span class="entity">prop_matcher</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">TY_TERM</span><span class="main">,</span> <span class="entity">term_typed_matcher</span><span class="main">)</span><span class="main">,</span>
      <span class="main">(</span><span class="entity">TY_VAR</span><span class="main">,</span> <span class="entity">term_typed_matcher</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">TY_EQ</span><span class="main">,</span> <span class="entity">eq_tname_typed_matcher</span><span class="main">)</span>
    <span class="main">]</span>

<span class="keyword2"><span class="keyword">end</span></span>  <span class="comment1">(* structure ItemIO. *)</span>
</pre>
</div><div id="files/AFP/Auto2_HOL/wfdata.ML">
<div class="head">
<h1>File ‹$AFP/Auto2_HOL/wfdata.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*
  File: wfdata.ML
  Author: Bohua Zhan

  Table storing wellformed-ness data during the proof.
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">WELLFORM_DATA</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> clean_resolved<span class="main">:</span> <span class="entity">box_id</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span>
  <span class="keyword1"><span class="keyword">val</span></span> clear_incr<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span>
  <span class="keyword1"><span class="keyword">val</span></span> initialize_wellform_data<span class="main">:</span> term <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span>

  <span class="comment1">(* wellform table. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_wellform_for_term<span class="main">:</span>
      <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> <span class="main">(</span>cterm * <span class="main">(</span><span class="entity">box_id</span> * thm<span class="main">)</span> list<span class="main">)</span> list
  <span class="keyword1"><span class="keyword">val</span></span> get_wellform_infos_for_term<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * thm<span class="main">)</span> list
  <span class="keyword1"><span class="keyword">val</span></span> convert_wellform<span class="main">:</span>
      <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">box_id</span> * thm <span class="main">-&gt;</span> <span class="entity">box_id</span> * thm <span class="main">-&gt;</span> <span class="entity">box_id</span> * thm
  <span class="keyword1"><span class="keyword">val</span></span> get_wellform<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">box_id</span> * cterm <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * thm<span class="main">)</span> list
  <span class="keyword1"><span class="keyword">val</span></span> get_wellform_t<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">box_id</span> * term <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * thm<span class="main">)</span> list
  <span class="keyword1"><span class="keyword">val</span></span> get_complete_wellform<span class="main">:</span>
      <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">box_id</span> * cterm <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * thm list<span class="main">)</span> list
  <span class="keyword1"><span class="keyword">val</span></span> cterm_to_wfterm<span class="main">:</span>
      <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> <span class="entity">box_id</span> * cterm <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * <span class="entity">wfterm</span><span class="main">)</span> list
  <span class="keyword1"><span class="keyword">val</span></span> term_to_wfterm<span class="main">:</span>
      <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> <span class="entity">box_id</span> * term <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * <span class="entity">wfterm</span><span class="main">)</span> list

  <span class="comment1">(* Update to wellform table. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> add_wellform_data_raw<span class="main">:</span>
      term * <span class="main">(</span><span class="entity">box_id</span> * thm<span class="main">)</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span>
  <span class="keyword1"><span class="keyword">val</span></span> find_fact<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">box_item</span> list <span class="main">-&gt;</span> <span class="entity">box_id</span> * cterm <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * thm<span class="main">)</span> list
  <span class="keyword1"><span class="keyword">val</span></span> complete_wellform_data_for_terms<span class="main">:</span>
      <span class="entity">box_item</span> list <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span>
  <span class="keyword1"><span class="keyword">val</span></span> complete_wellform_data<span class="main">:</span> <span class="entity">box_item</span> list <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span>

  <span class="comment1">(* Get changes to wellform table. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_new_wellform_data<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="main">(</span>term * <span class="main">(</span><span class="entity">box_id</span> * thm<span class="main">)</span><span class="main">)</span> list

  <span class="comment1">(* More queries on the wellform table.*)</span>
  <span class="keyword1"><span class="keyword">val</span></span> simplify_info<span class="main">:</span>
      <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> cterm <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * <span class="main">(</span><span class="entity">wfterm</span> * thm<span class="main">)</span><span class="main">)</span> list
  <span class="keyword1"><span class="keyword">val</span></span> simplify<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> cterm list <span class="main">-&gt;</span> <span class="entity">box_id</span> * <span class="entity">wfterm</span> <span class="main">-&gt;</span>
                <span class="main">(</span><span class="entity">box_id</span> * <span class="main">(</span><span class="entity">wfterm</span> * thm<span class="main">)</span><span class="main">)</span> list
  <span class="keyword1"><span class="keyword">val</span></span> get_head_equiv<span class="main">:</span>
      <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> <span class="entity">box_id</span> * cterm <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * <span class="main">(</span><span class="entity">wfterm</span> * thm<span class="main">)</span><span class="main">)</span> list
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">WellformData</span> <span class="main">:</span> <span class="entity">WELLFORM_DATA</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Data</span> <span class="main">=</span> Proof_Data
<span class="main">(</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">T</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span>cterm * <span class="main">(</span><span class="entity">box_id</span> * thm<span class="main">)</span> list<span class="main">)</span> list<span class="main">)</span> Termtab.table
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">init</span> <span class="main">_</span> <span class="main">=</span> Termtab.empty
<span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">clean_resolved</span> <span class="entity">id</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">clean_wellform_1</span> <span class="main">(</span><span class="entity">ctarget</span><span class="main">,</span> <span class="entity">infos</span><span class="main">)</span> <span class="main">=</span>
          <span class="main">(</span><span class="entity">ctarget</span><span class="main">,</span> filter_out <span class="main">(</span><span class="entity">BoxID.is_eq_ancestor</span> <span class="entity">ctxt</span> <span class="entity">id</span> o fst<span class="main">)</span> <span class="entity">infos</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">clean_wellform</span> <span class="entity">tb</span> <span class="main">=</span>
          <span class="entity">tb</span> |&gt; Termtab.map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> map <span class="entity">clean_wellform_1</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">ctxt</span> |&gt; Data.map <span class="entity">clean_wellform</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">clear_incr</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">clear_one</span> <span class="main">(</span><span class="entity">ct</span><span class="main">,</span> <span class="entity">infos</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">if</span></span> exists <span class="main">(</span><span class="entity">BoxID.has_incr_id</span> o fst<span class="main">)</span> <span class="entity">infos</span> <span class="keyword2"><span class="keyword">then</span></span>
            <span class="main">(</span><span class="entity">ct</span><span class="main">,</span> <span class="entity">infos</span> |&gt; map <span class="main">(</span>apfst <span class="entity">BoxID.replace_incr_id</span><span class="main">)</span>
                       |&gt; <span class="entity">Util.max_partial</span> <span class="main">(</span><span class="entity">BoxID.info_eq_better</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">else</span></span>
            <span class="main">(</span><span class="entity">ct</span><span class="main">,</span> <span class="entity">infos</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">ctxt</span> |&gt; Data.map <span class="main">(</span>Termtab.map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> map <span class="entity">clear_one</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Initialize wellform data for term t, with (currently) empty slots
   for each target.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">initialize_wellform_data</span> <span class="entity">t</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">wellform</span> <span class="main">=</span> Data.get <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">targets</span> <span class="main">=</span> map <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span><span class="main">)</span> <span class="main">(</span><span class="entity">WellForm.lookup_wellform_data</span> <span class="entity">thy</span> <span class="entity">t</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> Termtab.defined <span class="entity">wellform</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">ctxt</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">targets</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">ctxt</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">ctxt</span> |&gt; Data.map <span class="main">(</span>Termtab.update <span class="main">(</span><span class="entity">t</span><span class="main">,</span> map <span class="main">(</span>rpair <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="entity">targets</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_wellform_for_term</span> <span class="entity">ctxt</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">wellform</span> <span class="main">=</span> Data.get <span class="entity">ctxt</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      the_default <span class="main">[</span><span class="main">]</span> <span class="main">(</span>Termtab.lookup <span class="entity">wellform</span> <span class="entity">t</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Given a term t, return the wellform data for t in a list of (id,
   th) pairs.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_wellform_infos_for_term</span> <span class="entity">ctxt</span> <span class="entity">t</span> <span class="main">=</span>
    maps snd <span class="main">(</span><span class="entity">get_wellform_for_term</span> <span class="entity">ctxt</span> <span class="entity">t</span><span class="main">)</span>

<span class="comment1">(* Given (id, th) a wellform data for the left side of eq_th, convert
   to a wellform data for the right side.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">convert_wellform</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">eq_th</span><span class="main">)</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="main">=</span> Logic.dest_equals <span class="main">(</span>Thm.prop_of <span class="entity">eq_th</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">lhs</span> aconv <span class="entity">rhs</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">WellForm.lookup_wellform_pattern</span> <span class="entity">thy</span> <span class="main">(</span><span class="entity">Util.lhs_of</span> <span class="entity">eq_th</span><span class="main">,</span> <span class="entity">prop_of'</span> <span class="entity">th</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
          NONE <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"convert_wellform: invalid input."</span>
        <span class="main">|</span> SOME <span class="main">(</span><span class="entity">pat</span><span class="main">,</span> <span class="entity">data_pat</span><span class="main">)</span> <span class="main">=&gt;</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="comment1">(* Cannot use eq_th directly. Rather, find all the
               equivalences again for all the subterms.
             *)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cargs1</span> <span class="main">=</span> <span class="entity">Util.dest_cargs</span> <span class="main">(</span>Thm.lhs_of <span class="entity">eq_th</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cargs2</span> <span class="main">=</span> <span class="entity">Util.dest_cargs</span> <span class="main">(</span>Thm.rhs_of <span class="entity">eq_th</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq_ths</span> <span class="main">=</span>
                map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">ct</span><span class="main">,</span> <span class="entity">ct'</span><span class="main">)</span> <span class="main">=&gt;</span>
                        <span class="main">(</span><span class="entity">RewriteTable.equiv_info</span> <span class="entity">ctxt</span> <span class="entity">id'</span> <span class="main">(</span><span class="entity">ct</span><span class="main">,</span> <span class="entity">ct'</span><span class="main">)</span><span class="main">)</span>
                            |&gt; filter <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">id''</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">id''</span> <span class="main">=</span> <span class="entity">id'</span><span class="main">)</span>
                            |&gt; map snd |&gt; the_single<span class="main">)</span>
                    <span class="main">(</span><span class="entity">cargs1</span> ~~ <span class="entity">cargs2</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pat_args</span> <span class="main">=</span> <span class="entity">Util.dest_args</span> <span class="entity">pat</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th'</span> <span class="main">=</span> <span class="entity">apply_to_thm'</span> <span class="main">(</span>
                  <span class="entity">Util.pattern_rewr_conv</span> <span class="entity">data_pat</span> <span class="main">(</span><span class="entity">pat_args</span> ~~ <span class="entity">eq_ths</span><span class="main">)</span><span class="main">)</span> <span class="entity">th</span>

            <span class="comment1">(* Check the result is in the right form. *)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">subst'</span> <span class="main">=</span> <span class="entity">pat_args</span> ~~ map Thm.term_of <span class="entity">cargs2</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prop'</span> <span class="main">=</span> Term.subst_atomic <span class="entity">subst'</span> <span class="entity">data_pat</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span><span class="entity">prop_of'</span> <span class="entity">th'</span> aconv <span class="entity">prop'</span><span class="main">)</span>
                           <span class="inner_quoted">"convert_wellform: invalid output."</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="main">(</span><span class="entity">BoxID.merge_boxes</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">id'</span><span class="main">)</span><span class="main">,</span> <span class="entity">th'</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Retrieve wellform data for the given term. May need to rewrite t up
   to subterm equivalence.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_wellform</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">ct</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Thm.term_of <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">RewriteTable.in_table_raw_for_id</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="main">(</span><span class="entity">get_wellform_infos_for_term</span> <span class="entity">ctxt</span> <span class="entity">t</span><span class="main">)</span>
            |&gt; <span class="entity">BoxID.merge_box_with_info</span> <span class="entity">ctxt</span> <span class="entity">id</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="comment1">(* eq_th rewrites t to t', where t' is subterm equivalent to
             t and in the table. Obtain wellform data for t', then
             convert them into wellform data for t.
           *)</span>
          <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_head_rep</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">eq_th</span><span class="main">)</span> <span class="main">=</span>
              <span class="main">(</span><span class="entity">get_wellform_infos_for_term</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">Util.rhs_of</span> <span class="entity">eq_th</span><span class="main">)</span><span class="main">)</span>
                  |&gt; map <span class="main">(</span><span class="entity">convert_wellform</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">meta_sym</span> <span class="entity">eq_th</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="main">(</span><span class="entity">RewriteTable.subterm_simplify_info</span> <span class="entity">ctxt</span> <span class="entity">ct</span><span class="main">)</span>
              |&gt; maps <span class="main">(</span><span class="entity">RewriteTable.get_head_rep_with_id_th</span> <span class="entity">ctxt</span><span class="main">)</span>
              |&gt; maps <span class="entity">process_head_rep</span>
              |&gt; <span class="entity">BoxID.merge_box_with_info</span> <span class="entity">ctxt</span> <span class="entity">id</span>
              |&gt; <span class="entity">Util.max_partial</span> <span class="main">(</span><span class="entity">BoxID.info_eq_better</span> <span class="entity">ctxt</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_wellform_t</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span> <span class="main">=</span>
    <span class="entity">get_wellform</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">t</span><span class="main">)</span>

<span class="comment1">(* Retrieve the complete set of wellform data for term t, indexed by
   box id.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_complete_wellform</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">ct</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Thm.term_of <span class="entity">ct</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">targets</span> <span class="main">=</span> <span class="entity">WellForm.lookup_wellform_data</span> <span class="entity">thy</span> <span class="entity">t</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">targets</span> <span class="keyword2"><span class="keyword">of</span></span>
          <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">]</span>
        <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">data</span> <span class="main">=</span> <span class="main">(</span><span class="entity">get_wellform</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">ct</span><span class="main">)</span><span class="main">)</span>
                           |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">prop_of'</span> <span class="entity">th</span><span class="main">,</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
                           |&gt; AList.group <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv<span class="main">)</span>
                           |&gt; map snd
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span>length <span class="entity">data</span> &lt;= length <span class="entity">targets</span><span class="main">)</span>
                           <span class="inner_quoted">"get_complete_wellform: unexpected length data"</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="keyword2"><span class="keyword">if</span></span> length <span class="entity">data</span> &lt; length <span class="entity">targets</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span>
            <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">data</span> |&gt; <span class="entity">BoxID.get_all_merges_info</span> <span class="entity">ctxt</span>
                      |&gt; <span class="entity">Util.max_partial</span> <span class="main">(</span><span class="entity">BoxID.id_is_eq_ancestor</span> <span class="entity">ctxt</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Given a regular term, construct a wellformed term by adding
   theorems corresponding to any combination whose head agrees with
   one of fheads.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">cterm_to_wfterm</span> <span class="entity">ctxt</span> <span class="entity">fheads</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">ct</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> Thm.term_of <span class="entity">ct</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="main">_</span> $ <span class="main">_</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Thm.term_of <span class="entity">ct</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">cf</span><span class="main">,</span> <span class="entity">cargs</span><span class="main">)</span> <span class="main">=</span> Drule.strip_comb <span class="entity">ct</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="keyword2"><span class="keyword">if</span></span> forall <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">fhead</span> <span class="main">=&gt;</span> not <span class="main">(</span><span class="entity">Util.is_head</span> <span class="entity">fhead</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span> <span class="entity">fheads</span> <span class="keyword2"><span class="keyword">then</span></span>
            <span class="main">[</span><span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">WfTerm</span> <span class="entity">ct</span><span class="main">)</span><span class="main">]</span> <span class="keyword2"><span class="keyword">else</span></span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">wfdata</span> <span class="main">=</span> <span class="entity">get_complete_wellform</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">ct</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_wfdata</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">ths</span><span class="main">)</span> <span class="main">=</span>
                <span class="comment1">(* For each wellform data of t at box id', retrieve
                   the wellform data of each argment, then merge
                   together.
                 *)</span>
                <span class="entity">cargs</span> |&gt; map <span class="main">(</span>pair <span class="entity">id'</span><span class="main">)</span>
                      |&gt; map <span class="main">(</span><span class="entity">cterm_to_wfterm</span> <span class="entity">ctxt</span> <span class="entity">fheads</span><span class="main">)</span>
                      |&gt; <span class="entity">BoxID.get_all_merges_info</span> <span class="entity">ctxt</span>
                      |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">id''</span><span class="main">,</span> <span class="entity">arg'</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">id''</span><span class="main">,</span> <span class="entity">WfComb</span> <span class="main">(</span><span class="entity">cf</span><span class="main">,</span> <span class="entity">arg'</span><span class="main">,</span> <span class="entity">ths</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="main">(</span>maps <span class="entity">process_wfdata</span> <span class="entity">wfdata</span><span class="main">)</span>
                |&gt; <span class="entity">Util.max_partial</span> <span class="main">(</span><span class="entity">BoxID.id_is_eq_ancestor</span> <span class="entity">ctxt</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>
        <span class="keyword2"><span class="keyword">end</span></span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">WfTerm</span> <span class="entity">ct</span><span class="main">)</span><span class="main">]</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">term_to_wfterm</span> <span class="entity">ctxt</span> <span class="entity">fheads</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span> <span class="main">=</span>
    <span class="entity">cterm_to_wfterm</span> <span class="entity">ctxt</span> <span class="entity">fheads</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">t</span><span class="main">)</span>

<span class="comment1">(* Add the given wellform data (id, th) for the term t to the table. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_wellform_data_raw</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cprop</span> <span class="main">=</span> <span class="entity">cprop_of'</span> <span class="entity">th</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">wellform_data</span> <span class="main">=</span> <span class="entity">get_wellform_for_term</span> <span class="entity">ctxt</span> <span class="entity">t</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">infos</span> <span class="main">=</span> the <span class="main">(</span>AList.lookup <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconvc<span class="main">)</span> <span class="entity">wellform_data</span> <span class="entity">cprop</span><span class="main">)</span>
                  <span class="keyword3"><span class="keyword">handle</span></span> Option.Option <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"add_wellform_data_raw"</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> exists <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">info</span> <span class="main">=&gt;</span> <span class="entity">BoxID.info_eq_better</span> <span class="entity">ctxt</span> <span class="entity">info</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">)</span> <span class="entity">infos</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">ctxt</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">infos'</span> <span class="main">=</span> <span class="entity">infos</span> |&gt; filter_out <span class="main">(</span><span class="entity">BoxID.info_eq_better</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">)</span>
                           |&gt; cons <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="entity">ctxt</span> |&gt; Data.map <span class="main">(</span>
          Termtab.map_entry <span class="entity">t</span> <span class="main">(</span>AList.map_entry <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconvc<span class="main">)</span> <span class="entity">cprop</span> <span class="main">(</span>K <span class="entity">infos'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Given a list of items, attempt to justify t (of type bool)
   using the theorems, or equalities / properties in the rewrite
   table. Return a list of (id, th) pairs, where the statement of
   th' is t.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">find_fact</span> <span class="entity">ctxt</span> <span class="entity">items</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">ct</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Thm.term_of <span class="entity">ct</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">match_item</span> <span class="entity">item</span> <span class="main">=</span>
          <span class="main">(</span><span class="entity">ItemIO.match_arg</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">PropMatch</span> <span class="entity">t</span><span class="main">)</span> <span class="entity">item</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">fo_init</span><span class="main">)</span><span class="main">)</span>
              |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_eq_term</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>  <span class="comment1">(* Equality case *)</span>
        map <span class="main">(</span>apsnd <span class="entity">to_obj_eq</span><span class="main">)</span>
            <span class="main">(</span><span class="entity">RewriteTable.equiv_info</span> <span class="entity">ctxt</span> <span class="entity">id</span> <span class="main">(</span><span class="entity">cdest_eq</span> <span class="entity">ct</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">Property.is_property</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>  <span class="comment1">(* Property case *)</span>
        <span class="entity">PropertyData.get_property</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">ct</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">else</span></span>  <span class="comment1">(* General case *)</span>
        maps <span class="entity">match_item</span> <span class="entity">items</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Given a list of (id, th), complete the wellform data. New wellform
   data could be added when:

   - There are new theorems in the list of (id, th).

   - There are new properties added.

   - There are new equalities added.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">complete_wellform_data_for_terms</span> <span class="entity">items</span> <span class="entity">ts</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_for_t</span> <span class="entity">t</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cur_data</span> <span class="main">=</span> <span class="entity">get_wellform_for_term</span> <span class="entity">ctxt</span> <span class="entity">t</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">target_ids</span> <span class="main">=</span> <span class="entity">RewriteTable.in_table_raw_ids</span> <span class="entity">ctxt</span> <span class="entity">t</span>

            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_target</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">cprop</span><span class="main">)</span> <span class="main">=</span>
                <span class="keyword2"><span class="keyword">let</span></span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prop_data</span> <span class="main">=</span> the <span class="main">(</span>AList.lookup <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconvc<span class="main">)</span> <span class="entity">cur_data</span> <span class="entity">cprop</span><span class="main">)</span>
                <span class="keyword2"><span class="keyword">in</span></span>
                  not <span class="main">(</span>exists <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">BoxID.is_eq_ancestor</span> <span class="entity">ctxt</span> <span class="entity">id'</span> <span class="entity">id</span><span class="main">)</span>
                              <span class="entity">prop_data</span><span class="main">)</span>
                <span class="keyword2"><span class="keyword">end</span></span>

            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">targets</span> <span class="main">=</span> <span class="main">(</span><span class="entity">Util.all_pairs</span> <span class="main">(</span><span class="entity">target_ids</span><span class="main">,</span> map fst <span class="entity">cur_data</span><span class="main">)</span><span class="main">)</span>
                              |&gt; filter <span class="entity">is_target</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="entity">targets</span> |&gt; maps <span class="main">(</span><span class="entity">find_fact</span> <span class="entity">ctxt</span> <span class="entity">items</span><span class="main">)</span>
                    |&gt; map <span class="main">(</span>pair <span class="entity">t</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_data</span> <span class="main">=</span> maps <span class="entity">get_for_t</span> <span class="entity">ts</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      fold <span class="entity">add_wellform_data_raw</span> <span class="entity">all_data</span> <span class="entity">ctxt</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">complete_wellform_data</span> <span class="entity">items</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">wellform</span> <span class="main">=</span> Data.get <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ts</span> <span class="main">=</span> Termtab.keys <span class="entity">wellform</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">complete_wellform_data_for_terms</span> <span class="entity">items</span> <span class="entity">ts</span> <span class="entity">ctxt</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Return the list of new wellform data (added under id prim or
   lower). Return as a list of (t, (id, th)).
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_new_wellform_data</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">wellform</span> <span class="main">=</span> Data.get <span class="entity">ctxt</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">wellform</span> |&gt; Termtab.dest
               |&gt; maps <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">vals</span><span class="main">)</span> <span class="main">=&gt;</span> map <span class="main">(</span>pair <span class="entity">t</span><span class="main">)</span> <span class="main">(</span>maps snd <span class="entity">vals</span><span class="main">)</span><span class="main">)</span>
               |&gt; filter <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">BoxID.has_incr_id</span> <span class="entity">id</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Find simplifications of ct that are well-formed. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">simplify_info</span> <span class="entity">ctxt</span> <span class="entity">fheads</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">infos</span> <span class="main">=</span> <span class="entity">RewriteTable.simplify_info</span> <span class="entity">ctxt</span> <span class="entity">ct</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_info</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">eq_th</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs</span> <span class="main">=</span> Thm.rhs_of <span class="entity">eq_th</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">wfts</span> <span class="main">=</span> <span class="entity">cterm_to_wfterm</span> <span class="entity">ctxt</span> <span class="entity">fheads</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">wft</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="main">(</span><span class="entity">wft</span><span class="main">,</span> <span class="entity">eq_th</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="entity">wfts</span>
          <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">in</span></span>
      maps <span class="entity">process_info</span> <span class="entity">infos</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Assume cts are distinct subterms of wft, find all combinations of
   simplifying the terms ts.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">simplify</span> <span class="entity">ctxt</span> <span class="entity">fheads</span> <span class="entity">cts</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">wft</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">cts</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="main">(</span><span class="entity">wft</span><span class="main">,</span> Thm.reflexive <span class="main">(</span><span class="entity">WfTerm.cterm_of</span> <span class="entity">wft</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">else</span></span>
      <span class="entity">cts</span> |&gt; map <span class="main">(</span><span class="entity">simplify_info</span> <span class="entity">ctxt</span> <span class="entity">fheads</span><span class="main">)</span>
          |&gt; <span class="entity">BoxID.get_all_merges_info</span> <span class="entity">ctxt</span>
          |&gt; <span class="entity">BoxID.merge_box_with_info</span> <span class="entity">ctxt</span> <span class="entity">id</span>
          |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">wf_eqs</span><span class="main">)</span> <span class="main">=&gt;</span>
                     <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">WfTerm.rewrite_on_eqs</span> <span class="entity">fheads</span> <span class="entity">wf_eqs</span> <span class="entity">wft</span><span class="main">)</span><span class="main">)</span>

<span class="comment1">(* Find all well-formed head equivalences of ct. Return as a list of
   (id, (wft, eq_th)) pairs.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_head_equiv</span> <span class="entity">ctxt</span> <span class="entity">fheads</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">ct</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">head_equivs</span> <span class="main">=</span>
          <span class="entity">ct</span> |&gt; <span class="entity">RewriteTable.get_head_equiv</span> <span class="entity">ctxt</span>
             |&gt; <span class="entity">BoxID.merge_box_with_info</span> <span class="entity">ctxt</span> <span class="entity">id</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_head_equiv</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">eq_th</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs</span> <span class="main">=</span> Thm.rhs_of <span class="entity">eq_th</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">wfts</span> <span class="main">=</span> <span class="entity">cterm_to_wfterm</span> <span class="entity">ctxt</span> <span class="entity">fheads</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">id''</span><span class="main">,</span> <span class="entity">wft</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">id''</span><span class="main">,</span> <span class="main">(</span><span class="entity">wft</span><span class="main">,</span> <span class="entity">eq_th</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="entity">wfts</span>
          <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">in</span></span>
      maps <span class="entity">process_head_equiv</span> <span class="entity">head_equivs</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>  <span class="comment1">(* WellformData *)</span>
</pre>
</div><div id="files/AFP/Auto2_HOL/auto2_data.ML">
<div class="head">
<h1>File ‹$AFP/Auto2_HOL/auto2_data.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*
  File: auto2_data.ML
  Author: Bohua Zhan

  Updating of all data maintained at proof time.
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">AUTO2_DATA</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> relevant_terms_single<span class="main">:</span> <span class="entity">box_item</span> <span class="main">-&gt;</span> term list
  <span class="keyword1"><span class="keyword">val</span></span> add_terms<span class="main">:</span>
      <span class="entity">box_item</span> list <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * cterm<span class="main">)</span> list <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_incr_type<span class="main">:</span>
      <span class="entity">box_item</span> list <span class="main">-&gt;</span> <span class="entity">box_item</span> list <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_single_type<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Auto2Data</span> <span class="main">:</span> <span class="entity">AUTO2_DATA</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="comment1">(* Procedure to add a new term. Here old_items is the list of existing
   items. term_infos is a list of (id, ct) pairs.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_terms</span> <span class="entity">old_items</span> <span class="entity">term_infos</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ts</span> <span class="main">=</span> map <span class="main">(</span>Thm.term_of o snd<span class="main">)</span> <span class="entity">term_infos</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">edges</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">RewriteTable.add_term_list</span> <span class="entity">term_infos</span> <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">new_ts</span> <span class="main">=</span> map <span class="main">(</span>Thm.term_of o snd<span class="main">)</span>
                       <span class="main">(</span><span class="entity">RewriteTable.get_new_terms</span> <span class="main">(</span><span class="entity">ctxt</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">imm_properties</span> <span class="main">=</span>
          maps <span class="main">(</span><span class="entity">PropertyData.apply_property_update_on_term</span> <span class="entity">ctxt'</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="entity">ts</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">ctxt'</span> |&gt; <span class="entity">PropertyData.process_update_property</span> <span class="entity">imm_properties</span>
            |&gt; fold <span class="entity">PropertyData.process_rewrite_property</span> <span class="entity">edges</span>
            |&gt; fold <span class="entity">WellformData.initialize_wellform_data</span> <span class="entity">ts</span>
            |&gt; <span class="entity">WellformData.complete_wellform_data_for_terms</span> <span class="entity">old_items</span> <span class="entity">new_ts</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Helper function for the two functions below. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">relevant_terms_single</span> <span class="entity">item</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">ty_str</span><span class="main">,</span> <span class="entity">tname</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">item</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">ty_str</span> <span class="main">=</span> <span class="inner_quoted">"EQ"</span> <span class="keyword2"><span class="keyword">then</span></span> map Thm.term_of <span class="entity">tname</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Use the given items to update the current context data, producing
   the incremental context. Here old_items is the list of existing
   items. items is the list of new items. Update the rewrite table,
   property table, wellform table, and the custom tables.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_incr_type</span> <span class="entity">old_items</span> <span class="entity">items</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="comment1">(* List of relevant terms. *)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">relevant_terms</span> <span class="main">=</span>
          <span class="entity">items</span> |&gt; maps <span class="entity">relevant_terms_single</span>
                |&gt; <span class="entity">RewriteTable.get_reachable_terms</span> true <span class="entity">ctxt</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_one_info</span> <span class="entity">item</span> <span class="entity">ctxt</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">id</span><span class="main">,</span> <span class="entity">ty_str</span><span class="main">,</span> <span class="entity">prop</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">item</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">ty_str</span> <span class="main">=</span> <span class="inner_quoted">"EQ"</span> <span class="keyword2"><span class="keyword">then</span></span>
              <span class="keyword2"><span class="keyword">let</span></span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">edges</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">RewriteTable.add_rewrite</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">prop</span><span class="main">)</span> <span class="entity">ctxt</span>
              <span class="keyword2"><span class="keyword">in</span></span>
                <span class="entity">ctxt'</span> |&gt; fold <span class="entity">PropertyData.process_rewrite_property</span> <span class="entity">edges</span>
              <span class="keyword2"><span class="keyword">end</span></span>
            <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">ty_str</span> <span class="main">=</span> <span class="inner_quoted">"PROPERTY"</span> <span class="keyword2"><span class="keyword">then</span></span>
              <span class="entity">PropertyData.add_property</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">prop</span><span class="main">)</span> <span class="entity">ctxt</span>
            <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">ctxt</span>
          <span class="keyword2"><span class="keyword">end</span></span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">match_items</span> <span class="main">=</span>
          <span class="entity">items</span> @
          filter <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span><span class="entity">tname</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span> exists <span class="main">(</span><span class="entity">Util.has_subterm</span> <span class="entity">relevant_terms</span><span class="main">)</span>
                                            <span class="main">(</span>map Thm.term_of <span class="entity">tname</span><span class="main">)</span><span class="main">)</span> <span class="entity">old_items</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">ctxt</span> |&gt; fold <span class="entity">add_one_info</span> <span class="entity">items</span>
           |&gt; <span class="entity">WellformData.complete_wellform_data</span> <span class="entity">match_items</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_single_type</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="entity">ctxt</span> |&gt; <span class="entity">RewriteTable.clear_incr</span>
         |&gt; <span class="entity">PropertyData.clear_incr</span>
         |&gt; <span class="entity">WellformData.clear_incr</span>

<span class="keyword2"><span class="keyword">end</span></span>  <span class="comment1">(* Auto2Data *)</span>
</pre>
</div><div id="files/AFP/Auto2_HOL/status.ML">
<div class="head">
<h1>File ‹$AFP/Auto2_HOL/status.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*
  File: status.ML
  Author: Bohua Zhan

  Definition of updates and proof status.
*)</span>

<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">raw_update</span>
  <span class="main">=</span> <span class="entity">AddItems</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="main">{</span>id<span class="main">:</span> box_id<span class="main">,</span> sc<span class="main">:</span> int option<span class="main">,</span> raw_items<span class="main">:</span> raw_item list<span class="main">}</span>
  <span class="main">|</span> <span class="entity">AddBoxes</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="main">{</span>id<span class="main">:</span> box_id<span class="main">,</span> sc<span class="main">:</span> int option<span class="main">,</span> init_assum<span class="main">:</span> term<span class="main">}</span>
  <span class="main">|</span> <span class="entity">ResolveBox</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="main">{</span>id<span class="main">:</span> box_id<span class="main">,</span> th<span class="main">:</span> thm<span class="main">}</span>
  <span class="main">|</span> <span class="entity">ShadowItem</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="main">{</span>id<span class="main">:</span> box_id<span class="main">,</span> item<span class="main">:</span> box_item<span class="main">}</span>
<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">update</span> <span class="main">=</span> <span class="main">{</span>sc<span class="main">:</span> int<span class="main">,</span> prfstep_name<span class="main">:</span> string<span class="main">,</span> source<span class="main">:</span> <span class="entity">box_item</span> list<span class="main">,</span>
               raw_updt<span class="main">:</span> <span class="entity">raw_update</span><span class="main">}</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">UPDATE</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> target_of_update<span class="main">:</span> <span class="entity">raw_update</span> <span class="main">-&gt;</span> <span class="entity">box_id</span>
  <span class="keyword1"><span class="keyword">val</span></span> replace_id_of_update<span class="main">:</span> <span class="entity">raw_update</span> <span class="main">-&gt;</span> <span class="entity">raw_update</span>
  <span class="keyword1"><span class="keyword">val</span></span> string_of_raw_update<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">raw_update</span> <span class="main">-&gt;</span> string
  <span class="keyword1"><span class="keyword">val</span></span> thm_to_ritem<span class="main">:</span> thm <span class="main">-&gt;</span> <span class="entity">raw_item</span>
  <span class="keyword1"><span class="keyword">val</span></span> thm_update<span class="main">:</span> <span class="entity">box_id</span> * thm <span class="main">-&gt;</span> <span class="entity">raw_update</span>
  <span class="keyword1"><span class="keyword">val</span></span> thm_update_sc<span class="main">:</span> int <span class="main">-&gt;</span> <span class="entity">box_id</span> * thm <span class="main">-&gt;</span> <span class="entity">raw_update</span>

  <span class="keyword1"><span class="keyword">val</span></span> apply_exists_ritems<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> <span class="entity">raw_item</span> list * thm
  <span class="keyword1"><span class="keyword">val</span></span> update_info<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">box_id</span> <span class="main">-&gt;</span> <span class="entity">raw_item</span> list <span class="main">-&gt;</span> string
  <span class="keyword1"><span class="keyword">val</span></span> source_info<span class="main">:</span> <span class="entity">update</span> <span class="main">-&gt;</span> string
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Update</span> <span class="main">:</span> <span class="entity">UPDATE</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">target_of_update</span> <span class="entity">raw_updt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">raw_updt</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="entity">AddItems</span> <span class="main">{</span><span class="entity">id</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span> <span class="entity">id</span>
      <span class="main">|</span> <span class="entity">AddBoxes</span> <span class="main">{</span><span class="entity">id</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span> <span class="entity">id</span>
      <span class="main">|</span> <span class="entity">ResolveBox</span> <span class="main">{</span><span class="entity">id</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span> <span class="entity">id</span>
      <span class="main">|</span> <span class="entity">ShadowItem</span> <span class="main">{</span><span class="entity">id</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span> <span class="entity">id</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">replace_id_of_update</span> <span class="entity">raw_updt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">id</span> <span class="main">=</span> <span class="entity">target_of_update</span> <span class="entity">raw_updt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span><span class="entity">BoxID.has_incr_id</span> <span class="entity">id</span><span class="main">)</span> <span class="inner_quoted">"replace_id_of_update"</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">id'</span> <span class="main">=</span> <span class="entity">BoxID.replace_incr_id</span> <span class="entity">id</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">raw_updt</span> <span class="keyword2"><span class="keyword">of</span></span>
          <span class="entity">AddItems</span> <span class="main">{</span><span class="entity">sc</span><span class="main">,</span> <span class="entity">raw_items</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
          <span class="entity">AddItems</span> <span class="main">{</span>id <span class="main">=</span> <span class="entity">id'</span><span class="main">,</span> sc <span class="main">=</span> <span class="entity">sc</span><span class="main">,</span> raw_items <span class="main">=</span> <span class="entity">raw_items</span><span class="main">}</span>
        <span class="main">|</span> <span class="entity">AddBoxes</span> <span class="main">{</span><span class="entity">sc</span><span class="main">,</span> <span class="entity">init_assum</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
          <span class="entity">AddBoxes</span> <span class="main">{</span>id <span class="main">=</span> <span class="entity">id'</span><span class="main">,</span> sc <span class="main">=</span> <span class="entity">sc</span><span class="main">,</span> init_assum <span class="main">=</span> <span class="entity">init_assum</span><span class="main">}</span>
        <span class="main">|</span> <span class="entity">ResolveBox</span> <span class="main">{</span><span class="entity">th</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span> <span class="entity">ResolveBox</span> <span class="main">{</span>id <span class="main">=</span> <span class="entity">id'</span><span class="main">,</span> th <span class="main">=</span> <span class="entity">th</span><span class="main">}</span>
        <span class="main">|</span> <span class="entity">ShadowItem</span> <span class="main">{</span><span class="entity">item</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span> <span class="entity">ShadowItem</span> <span class="main">{</span>id <span class="main">=</span> <span class="entity">id'</span><span class="main">,</span> item <span class="main">=</span> <span class="entity">item</span><span class="main">}</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Debugging output for raw update. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">string_of_raw_update</span> <span class="entity">ctxt</span> <span class="entity">raw_updt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">raw_updt</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="entity">AddItems</span> <span class="main">{</span><span class="entity">id</span><span class="main">,</span> <span class="entity">raw_items</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
        <span class="inner_quoted">"Add items "</span> ^ <span class="main">(</span><span class="entity">Util.string_of_list</span> <span class="main">(</span>
                           <span class="entity">ItemIO.string_of_raw_item</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">raw_items</span><span class="main">)</span> ^
        <span class="inner_quoted">" to box "</span> ^ <span class="main">(</span><span class="entity">BoxID.string_of_box_id</span> <span class="entity">id</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">AddBoxes</span> <span class="main">{</span><span class="entity">id</span><span class="main">,</span> <span class="entity">init_assum</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
        <span class="inner_quoted">"Add box "</span> ^ <span class="main">(</span>Syntax.string_of_term <span class="entity">ctxt</span> <span class="entity">init_assum</span><span class="main">)</span> ^
        <span class="inner_quoted">" under box "</span> ^ <span class="main">(</span><span class="entity">BoxID.string_of_box_id</span> <span class="entity">id</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">ResolveBox</span> <span class="main">{</span><span class="entity">id</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
        <span class="inner_quoted">"Resolve box "</span> ^ <span class="main">(</span><span class="entity">BoxID.string_of_box_id</span> <span class="entity">id</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">ShadowItem</span> <span class="main">{</span><span class="entity">id</span><span class="main">,</span> <span class="entity">item</span><span class="main">}</span> <span class="main">=&gt;</span>
        <span class="inner_quoted">"Shadow item "</span> ^ <span class="main">(</span><span class="entity">ItemIO.string_of_item</span> <span class="entity">ctxt</span> <span class="entity">item</span><span class="main">)</span> ^
        <span class="inner_quoted">" in box "</span> ^ <span class="main">(</span><span class="entity">BoxID.string_of_box_id</span> <span class="entity">id</span><span class="main">)</span>

<span class="comment1">(* Create raw_item from theorem. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">thm_to_ritem</span> <span class="entity">th</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prop</span> <span class="main">=</span> Thm.prop_of <span class="entity">th</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span><span class="entity">is_Trueprop</span> <span class="entity">prop</span><span class="main">)</span> <span class="inner_quoted">"thm_update: prop is not Trueprop."</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span>not <span class="main">(</span><span class="entity">Util.has_vars</span> <span class="entity">prop</span><span class="main">)</span><span class="main">)</span>
                     <span class="inner_quoted">"thm_to_ritem: prop contains schematic variables."</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">Fact</span> <span class="main">(</span><span class="entity">TY_PROP</span><span class="main">,</span> <span class="main">[</span><span class="entity">dest_Trueprop</span> <span class="entity">prop</span><span class="main">]</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Create raw_update from id and theorem. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">thm_update</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> Thm.prop_of <span class="entity">th</span> aconv <span class="entity">pFalse</span> <span class="keyword2"><span class="keyword">then</span></span>
      <span class="entity">ResolveBox</span> <span class="main">{</span>id <span class="main">=</span> <span class="entity">id</span><span class="main">,</span> th <span class="main">=</span> <span class="entity">th</span><span class="main">}</span>
    <span class="keyword2"><span class="keyword">else</span></span>
      <span class="entity">AddItems</span> <span class="main">{</span>id <span class="main">=</span> <span class="entity">id</span><span class="main">,</span> sc <span class="main">=</span> NONE<span class="main">,</span> raw_items <span class="main">=</span> <span class="main">[</span><span class="entity">thm_to_ritem</span> <span class="entity">th</span><span class="main">]</span><span class="main">}</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">thm_update_sc</span> <span class="entity">sc</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> Thm.prop_of <span class="entity">th</span> aconv <span class="entity">pFalse</span> <span class="keyword2"><span class="keyword">then</span></span>
      <span class="entity">ResolveBox</span> <span class="main">{</span>id <span class="main">=</span> <span class="entity">id</span><span class="main">,</span> th <span class="main">=</span> <span class="entity">th</span><span class="main">}</span>
    <span class="keyword2"><span class="keyword">else</span></span>
      <span class="entity">AddItems</span> <span class="main">{</span>id <span class="main">=</span> <span class="entity">id</span><span class="main">,</span> sc <span class="main">=</span> SOME <span class="entity">sc</span><span class="main">,</span> raw_items <span class="main">=</span> <span class="main">[</span><span class="entity">thm_to_ritem</span> <span class="entity">th</span><span class="main">]</span><span class="main">}</span>

<span class="comment1">(* Apply the given existence theorem. Return a pair (ritems, th),
   ritems contain the new variables and the new handler, and th is the
   instantiated property of the new variables, which can either be
   processed further, or made into an ritem using thm_update.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">apply_exists_ritems</span> <span class="entity">ctxt</span> <span class="entity">ex_th</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">vars</span><span class="main">,</span> <span class="entity">body</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">UtilLogic.strip_exists</span> <span class="main">(</span><span class="entity">prop_of'</span> <span class="entity">ex_th</span><span class="main">)</span><span class="main">)</span>
                             |&gt; <span class="entity">Util.to_internal_vars</span> <span class="entity">ctxt</span>
                             |&gt; apsnd <span class="entity">mk_Trueprop</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">vars</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">ex_th</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span>map <span class="main">(</span><span class="entity">BoxItem.var_to_fact</span><span class="main">)</span> <span class="entity">vars</span> @ <span class="main">[</span><span class="entity">Handler</span> <span class="main">(</span><span class="entity">vars</span><span class="main">,</span> <span class="entity">body</span><span class="main">,</span> <span class="entity">ex_th</span><span class="main">)</span><span class="main">]</span><span class="main">,</span>
            Thm.assume <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">body</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Print a list of raw items. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">update_info</span> <span class="entity">ctxt</span> <span class="entity">id</span> <span class="entity">ritems</span> <span class="main">=</span>
    <span class="main">(</span><span class="entity">Util.string_of_list'</span> <span class="main">(</span><span class="entity">ItemIO.string_of_raw_item</span> <span class="entity">ctxt</span><span class="main">)</span>
                     <span class="main">(</span>filter <span class="main">(</span>not o <span class="entity">BoxItem.is_handler_raw</span><span class="main">)</span> <span class="entity">ritems</span><span class="main">)</span><span class="main">)</span> ^
    <span class="inner_quoted">" at box "</span> ^ <span class="main">(</span><span class="entity">BoxID.string_of_box_id</span> <span class="entity">id</span><span class="main">)</span>

<span class="comment1">(* Print the source of the update. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">source_info</span> <span class="main">{</span><span class="entity">prfstep_name</span><span class="main">,</span> <span class="entity">source</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span>
    <span class="entity">prfstep_name</span> ^ <span class="inner_quoted">" on "</span> ^
    <span class="main">(</span><span class="entity">Util.string_of_list'</span>
         <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span><span class="entity">uid</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span> <span class="inner_quoted">"("</span> ^ string_of_int <span class="entity">uid</span> ^ <span class="inner_quoted">")"</span><span class="main">)</span> <span class="entity">source</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>  <span class="comment1">(* structure Update. *)</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Updates_Heap</span> <span class="main">=</span>
Heap <span class="main">(</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">elem</span> <span class="main">=</span> <span class="entity">update</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ord</span> <span class="main">(</span><span class="main">{</span>sc <span class="main">=</span> <span class="entity">sc1</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">,</span> <span class="main">{</span>sc <span class="main">=</span> <span class="entity">sc2</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> int_ord <span class="main">(</span><span class="entity">sc1</span><span class="main">,</span> <span class="entity">sc2</span><span class="main">)</span>
<span class="main">)</span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">status</span> <span class="main">=</span> <span class="main">{</span>
  assums<span class="main">:</span> term list<span class="main">,</span>
  handlers<span class="main">:</span> <span class="main">(</span><span class="entity">box_id</span> * <span class="main">(</span>term list * term * thm<span class="main">)</span><span class="main">)</span> list<span class="main">,</span>
  items<span class="main">:</span> <span class="main">(</span><span class="entity">box_item</span> * <span class="entity">box_id</span> list<span class="main">)</span> Inttab.table<span class="main">,</span>
  queue<span class="main">:</span> Updates_Heap.T<span class="main">,</span>
  resolve_th<span class="main">:</span> thm option<span class="main">,</span>
  ctxt<span class="main">:</span> <span class="entity">Proof.context</span>
<span class="main">}</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">STATUS</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> empty_status<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">status</span>

  <span class="keyword1"><span class="keyword">val</span></span> map_context<span class="main">:</span> <span class="main">(</span><span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span><span class="main">)</span> <span class="main">-&gt;</span> <span class="entity">status</span> <span class="main">-&gt;</span> <span class="entity">status</span>
  <span class="keyword1"><span class="keyword">val</span></span> add_handler<span class="main">:</span> <span class="entity">box_id</span> * <span class="main">(</span>term list * term * thm<span class="main">)</span> <span class="main">-&gt;</span> <span class="entity">status</span> <span class="main">-&gt;</span> <span class="entity">status</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_handlers<span class="main">:</span> <span class="entity">status</span> <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * <span class="main">(</span>term list * term * thm<span class="main">)</span><span class="main">)</span> list
  <span class="keyword1"><span class="keyword">val</span></span> add_item<span class="main">:</span> <span class="entity">box_item</span> <span class="main">-&gt;</span> <span class="entity">status</span> <span class="main">-&gt;</span> <span class="entity">status</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_items<span class="main">:</span> <span class="entity">status</span> <span class="main">-&gt;</span> <span class="entity">box_item</span> list
  <span class="keyword1"><span class="keyword">val</span></span> get_all_items_at_id<span class="main">:</span> <span class="entity">status</span> <span class="main">-&gt;</span> <span class="entity">box_id</span> <span class="main">-&gt;</span> <span class="entity">box_item</span> list
  <span class="keyword1"><span class="keyword">val</span></span> get_num_items<span class="main">:</span> <span class="entity">status</span> <span class="main">-&gt;</span> int
  <span class="keyword1"><span class="keyword">val</span></span> set_resolve_th<span class="main">:</span> thm <span class="main">-&gt;</span> <span class="entity">status</span> <span class="main">-&gt;</span> <span class="entity">status</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_resolve_th<span class="main">:</span> <span class="entity">status</span> <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> add_prim_box<span class="main">:</span> <span class="entity">box_id</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> <span class="entity">status</span> <span class="main">-&gt;</span> int * <span class="entity">status</span>
  <span class="keyword1"><span class="keyword">val</span></span> add_resolved<span class="main">:</span> <span class="entity">box_id</span> <span class="main">-&gt;</span> <span class="entity">status</span> <span class="main">-&gt;</span> <span class="entity">status</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_init_assums<span class="main">:</span> <span class="entity">status</span> <span class="main">-&gt;</span> <span class="entity">box_id</span> <span class="main">-&gt;</span> term list
  <span class="keyword1"><span class="keyword">val</span></span> get_init_assum<span class="main">:</span> <span class="entity">status</span> <span class="main">-&gt;</span> int <span class="main">-&gt;</span> term

  <span class="keyword1"><span class="keyword">val</span></span> lookup_item<span class="main">:</span> <span class="entity">status</span> <span class="main">-&gt;</span> int <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_item</span> * <span class="entity">box_id</span> list<span class="main">)</span> option
  <span class="keyword1"><span class="keyword">val</span></span> clear_incr<span class="main">:</span> <span class="entity">status</span> <span class="main">-&gt;</span> <span class="entity">status</span>
  <span class="keyword1"><span class="keyword">val</span></span> add_shadowed<span class="main">:</span> <span class="entity">box_id</span> * <span class="entity">box_item</span> <span class="main">-&gt;</span> <span class="entity">status</span> <span class="main">-&gt;</span> <span class="entity">status</span>
  <span class="keyword1"><span class="keyword">val</span></span> query_shadowed<span class="main">:</span> <span class="entity">status</span> <span class="main">-&gt;</span> <span class="entity">box_id</span> <span class="main">-&gt;</span> <span class="entity">box_item</span> <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> query_removed<span class="main">:</span> <span class="entity">status</span> <span class="main">-&gt;</span> <span class="entity">box_item</span> <span class="main">-&gt;</span> bool

  <span class="keyword1"><span class="keyword">val</span></span> find_fact<span class="main">:</span> <span class="entity">status</span> <span class="main">-&gt;</span> <span class="entity">box_id</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> thm option
  <span class="keyword1"><span class="keyword">val</span></span> find_ritem_exact<span class="main">:</span> <span class="entity">status</span> <span class="main">-&gt;</span> <span class="entity">box_id</span> <span class="main">-&gt;</span> <span class="entity">raw_item</span> <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> invoke_handler<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term list * term * thm <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> get_on_resolve<span class="main">:</span> <span class="entity">status</span> <span class="main">-&gt;</span> <span class="entity">box_id</span> <span class="main">-&gt;</span> int <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> find_prim_box<span class="main">:</span> <span class="entity">status</span> <span class="main">-&gt;</span> <span class="entity">box_id</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> int option

  <span class="keyword1"><span class="keyword">val</span></span> map_queue<span class="main">:</span> <span class="main">(</span>Updates_Heap.T <span class="main">-&gt;</span> Updates_Heap.T<span class="main">)</span> <span class="main">-&gt;</span> <span class="entity">status</span> <span class="main">-&gt;</span> <span class="entity">status</span>
  <span class="keyword1"><span class="keyword">val</span></span> add_to_queue<span class="main">:</span> <span class="entity">update</span> <span class="main">-&gt;</span> <span class="entity">status</span> <span class="main">-&gt;</span> <span class="entity">status</span>
  <span class="keyword1"><span class="keyword">val</span></span> delmin_from_queue<span class="main">:</span> <span class="entity">status</span> <span class="main">-&gt;</span> <span class="entity">status</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Status</span> <span class="main">:</span> <span class="entity">STATUS</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">empty_status</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="main">{</span>assums <span class="main">=</span> <span class="main">[</span><span class="entity">UtilLogic.term_of_bool</span> true<span class="main">]</span><span class="main">,</span>
     handlers <span class="main">=</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span>
     items <span class="main">=</span> Inttab.empty<span class="main">,</span>
     queue <span class="main">=</span> Updates_Heap.empty<span class="main">,</span>
     ctxt <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span>
     resolve_th <span class="main">=</span> NONE<span class="main">}</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map_context</span> <span class="entity">f</span> <span class="main">{</span><span class="entity">assums</span><span class="main">,</span> <span class="entity">handlers</span><span class="main">,</span> <span class="entity">items</span><span class="main">,</span> <span class="entity">queue</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="entity">resolve_th</span><span class="main">}</span> <span class="main">=</span>
    <span class="main">{</span>assums <span class="main">=</span> <span class="entity">assums</span><span class="main">,</span> handlers <span class="main">=</span> <span class="entity">handlers</span><span class="main">,</span> items <span class="main">=</span> <span class="entity">items</span><span class="main">,</span> queue <span class="main">=</span> <span class="entity">queue</span><span class="main">,</span>
     ctxt <span class="main">=</span> <span class="entity">f</span> <span class="entity">ctxt</span><span class="main">,</span> resolve_th <span class="main">=</span> <span class="entity">resolve_th</span><span class="main">}</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_handler</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">handler</span><span class="main">)</span> <span class="main">{</span><span class="entity">assums</span><span class="main">,</span> <span class="entity">handlers</span><span class="main">,</span> <span class="entity">items</span><span class="main">,</span> <span class="entity">queue</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">,</span>
                               <span class="entity">resolve_th</span><span class="main">}</span> <span class="main">=</span>
    <span class="main">{</span>assums <span class="main">=</span> <span class="entity">assums</span><span class="main">,</span> handlers <span class="main">=</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">handler</span><span class="main">)</span> :: <span class="entity">handlers</span><span class="main">,</span> items <span class="main">=</span> <span class="entity">items</span><span class="main">,</span>
     queue <span class="main">=</span> <span class="entity">queue</span><span class="main">,</span> ctxt <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> resolve_th <span class="main">=</span> <span class="entity">resolve_th</span><span class="main">}</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_handlers</span> <span class="main">{</span><span class="entity">handlers</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">handlers</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map_items</span> <span class="entity">f</span> <span class="main">{</span><span class="entity">assums</span><span class="main">,</span> <span class="entity">handlers</span><span class="main">,</span> <span class="entity">items</span><span class="main">,</span> <span class="entity">queue</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="entity">resolve_th</span><span class="main">}</span> <span class="main">=</span>
    <span class="main">{</span>assums <span class="main">=</span> <span class="entity">assums</span><span class="main">,</span> handlers <span class="main">=</span> <span class="entity">handlers</span><span class="main">,</span> items <span class="main">=</span> <span class="entity">f</span> <span class="entity">items</span><span class="main">,</span> queue <span class="main">=</span> <span class="entity">queue</span><span class="main">,</span>
     ctxt <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> resolve_th <span class="main">=</span> <span class="entity">resolve_th</span><span class="main">}</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_item</span> <span class="main">(</span><span class="entity">item</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">{</span><span class="entity">uid</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="entity">st</span> <span class="main">=</span>
    <span class="entity">st</span> |&gt; <span class="entity">map_items</span> <span class="main">(</span>Inttab.update_new <span class="main">(</span><span class="entity">uid</span><span class="main">,</span> <span class="main">(</span><span class="entity">item</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_items</span> <span class="main">{</span><span class="entity">items</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span>
    <span class="entity">items</span> |&gt; Inttab.dest |&gt; map snd
          |&gt; filter_out <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">{</span><span class="entity">id</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">,</span> <span class="entity">shadow_ids</span><span class="main">)</span> <span class="main">=&gt;</span>
                            member <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">shadow_ids</span> <span class="entity">id</span><span class="main">)</span>
          |&gt; map fst

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_items_at_id</span> <span class="main">(</span><span class="entity">st</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">{</span><span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="entity">id</span> <span class="main">=</span>
    <span class="entity">st</span> |&gt; <span class="entity">get_items</span>
       |&gt; filter <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span>id <span class="main">=</span> <span class="entity">id'</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span> <span class="entity">BoxID.is_eq_ancestor</span> <span class="entity">ctxt</span> <span class="entity">id'</span> <span class="entity">id</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_all_items_at_id</span> <span class="main">{</span><span class="entity">items</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="entity">id</span> <span class="main">=</span>
    <span class="entity">items</span> |&gt; Inttab.dest |&gt; map snd |&gt; map fst
          |&gt; filter <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span>id <span class="main">=</span> <span class="entity">id'</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span> <span class="entity">BoxID.is_eq_ancestor</span> <span class="entity">ctxt</span> <span class="entity">id'</span> <span class="entity">id</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_num_items</span> <span class="main">{</span><span class="entity">items</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> length <span class="main">(</span>Inttab.dest <span class="entity">items</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">set_resolve_th</span> <span class="entity">th</span> <span class="main">{</span><span class="entity">assums</span><span class="main">,</span> <span class="entity">handlers</span><span class="main">,</span> <span class="entity">items</span><span class="main">,</span> <span class="entity">queue</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span>
    <span class="main">{</span>assums <span class="main">=</span> <span class="entity">assums</span><span class="main">,</span> handlers <span class="main">=</span> <span class="entity">handlers</span><span class="main">,</span> items <span class="main">=</span> <span class="entity">items</span><span class="main">,</span> queue <span class="main">=</span> <span class="entity">queue</span><span class="main">,</span>
     ctxt <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> resolve_th <span class="main">=</span> SOME <span class="entity">th</span><span class="main">}</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_resolve_th</span> <span class="main">{</span><span class="entity">resolve_th</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">resolve_th</span> <span class="keyword2"><span class="keyword">of</span></span>
        NONE <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"get_resolve_th: not resolved."</span>
      <span class="main">|</span> SOME <span class="entity">th</span> <span class="main">=&gt;</span> <span class="entity">th</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_prim_box</span> <span class="entity">parent_id</span> <span class="entity">assum</span>
                 <span class="main">{</span><span class="entity">assums</span><span class="main">,</span> <span class="entity">handlers</span><span class="main">,</span> <span class="entity">items</span><span class="main">,</span> <span class="entity">queue</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="entity">resolve_th</span><span class="main">}</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">BoxID.add_prim_id</span> <span class="entity">parent_id</span> <span class="entity">ctxt</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="main">{</span>assums <span class="main">=</span> <span class="entity">assums</span> @ <span class="main">[</span><span class="entity">assum</span><span class="main">]</span><span class="main">,</span>
            handlers <span class="main">=</span> <span class="entity">handlers</span><span class="main">,</span> items <span class="main">=</span> <span class="entity">items</span><span class="main">,</span> queue <span class="main">=</span> <span class="entity">queue</span><span class="main">,</span>
            ctxt <span class="main">=</span> <span class="entity">ctxt'</span><span class="main">,</span> resolve_th <span class="main">=</span> <span class="entity">resolve_th</span><span class="main">}</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_resolved</span> <span class="entity">id</span> <span class="main">{</span><span class="entity">assums</span><span class="main">,</span> <span class="entity">handlers</span><span class="main">,</span> <span class="entity">items</span><span class="main">,</span> <span class="entity">queue</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="entity">resolve_th</span><span class="main">}</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt'</span> <span class="main">=</span> <span class="entity">BoxID.add_resolved</span> <span class="entity">id</span> <span class="entity">ctxt</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">{</span>assums <span class="main">=</span> <span class="entity">assums</span><span class="main">,</span> handlers <span class="main">=</span> <span class="entity">handlers</span><span class="main">,</span> items <span class="main">=</span> <span class="entity">items</span><span class="main">,</span> queue <span class="main">=</span> <span class="entity">queue</span><span class="main">,</span>
       ctxt <span class="main">=</span> <span class="entity">ctxt'</span> |&gt; <span class="entity">RewriteTable.clean_resolved</span> <span class="entity">id</span>
                    |&gt; <span class="entity">PropertyData.clean_resolved</span> <span class="entity">id</span>
                    |&gt; <span class="entity">WellformData.clean_resolved</span> <span class="entity">id</span><span class="main">,</span>
       resolve_th <span class="main">=</span> <span class="entity">resolve_th</span><span class="main">}</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_init_assums</span> <span class="main">{</span><span class="entity">assums</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="entity">id</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parents</span> <span class="main">=</span> <span class="entity">BoxID.get_ancestors_prim</span> <span class="entity">ctxt</span> <span class="entity">id</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      map <span class="main">(</span>nth <span class="entity">assums</span><span class="main">)</span> <span class="entity">parents</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_init_assum</span> <span class="main">{</span><span class="entity">assums</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="entity">prim_id</span> <span class="main">=</span>
    nth <span class="entity">assums</span> <span class="entity">prim_id</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">lookup_item</span> <span class="main">{</span><span class="entity">items</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="entity">uid</span> <span class="main">=</span>
    Inttab.lookup <span class="entity">items</span> <span class="entity">uid</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">clear_incr</span> <span class="entity">st</span> <span class="main">=</span>
    <span class="entity">st</span> |&gt; <span class="entity">map_items</span> <span class="main">(</span>
      Inttab.map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">item</span><span class="main">,</span> <span class="entity">ids</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">BoxItem.item_replace_incr</span> <span class="entity">item</span><span class="main">,</span> <span class="entity">ids</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_shadowed</span> <span class="main">(</span><span class="entity">shadow_id</span><span class="main">,</span> <span class="main">{</span><span class="entity">uid</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="entity">st</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">{</span><span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">lookup_item</span> <span class="entity">st</span> <span class="entity">uid</span> <span class="keyword2"><span class="keyword">of</span></span>
        NONE <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"add_shadowed: item not found."</span>
      <span class="main">|</span> SOME <span class="main">(</span><span class="entity">item</span><span class="main">,</span> <span class="entity">shadow_ids</span><span class="main">)</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">shadow_ids'</span> <span class="main">=</span> <span class="main">(</span><span class="entity">shadow_id</span> :: <span class="entity">shadow_ids</span><span class="main">)</span>
                                |&gt; <span class="entity">Util.max_partial</span> <span class="main">(</span><span class="entity">BoxID.is_eq_ancestor</span> <span class="entity">ctxt</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="entity">st</span> |&gt; <span class="entity">map_items</span> <span class="main">(</span>Inttab.update <span class="main">(</span><span class="entity">uid</span><span class="main">,</span> <span class="main">(</span><span class="entity">item</span><span class="main">,</span> <span class="entity">shadow_ids'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">query_shadowed</span> <span class="main">(</span><span class="entity">st</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">{</span><span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="entity">shadow_id</span> <span class="main">{</span><span class="entity">uid</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">lookup_item</span> <span class="entity">st</span> <span class="entity">uid</span> <span class="keyword2"><span class="keyword">of</span></span>
        NONE <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"query_shadowed: item not found."</span>
      <span class="main">|</span> SOME <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">shadow_ids</span><span class="main">)</span> <span class="main">=&gt;</span>
        exists <span class="main">(</span><span class="entity">BoxID.is_eq_descendent</span> <span class="entity">ctxt</span> <span class="entity">shadow_id</span><span class="main">)</span> <span class="entity">shadow_ids</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">query_removed</span> <span class="entity">st</span> <span class="main">(</span><span class="entity">item</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">{</span><span class="entity">id</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> <span class="entity">query_shadowed</span> <span class="entity">st</span> <span class="entity">id</span> <span class="entity">item</span>

<span class="comment1">(* Try to find fact at id or above with the proposition t. Return SOME
   th if found.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">find_fact</span> <span class="main">(</span><span class="entity">st</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">{</span><span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="entity">id</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ct</span> <span class="main">=</span> Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">t</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">items</span> <span class="main">=</span> <span class="entity">get_items_at_id</span> <span class="entity">st</span> <span class="entity">id</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">res</span> <span class="main">=</span> <span class="main">(</span><span class="entity">WellformData.find_fact</span> <span class="entity">ctxt</span> <span class="entity">items</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">ct</span><span class="main">)</span><span class="main">)</span>
                    |&gt; filter <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">id'</span> <span class="main">=</span> <span class="entity">id</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">res</span> <span class="keyword2"><span class="keyword">of</span></span>
          <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> NONE
        <span class="main">|</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> :: <span class="main">_</span> <span class="main">=&gt;</span> SOME <span class="entity">th</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Find item with the exact ty_str and tname, whose id is an
   eq-ancestor of the given id.

   There are two special cases: if the ritem in question is of type EQ
   and PROPERTY, in which case we try to find it in the rewrite table.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">find_ritem_exact</span> <span class="main">(</span><span class="entity">st</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">{</span><span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="entity">id</span> <span class="entity">ritem</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">ritem</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="entity">Handler</span> <span class="main">_</span> <span class="main">=&gt;</span> false
      <span class="main">|</span> <span class="entity">Fact</span> <span class="main">(</span><span class="entity">ty_str</span><span class="main">,</span> <span class="entity">tname</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">ty_str</span> <span class="main">=</span> <span class="entity">TY_EQ</span> <span class="keyword2"><span class="keyword">then</span></span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">the_pair</span> <span class="main">(</span><span class="entity">BoxItem.get_tname_raw</span> <span class="entity">ritem</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="entity">RewriteTable.is_equiv_t</span> <span class="entity">id</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>
        <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">ty_str</span> <span class="main">=</span> <span class="entity">TY_PROPERTY</span> <span class="keyword2"><span class="keyword">then</span></span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prop</span> <span class="main">=</span> the_single <span class="entity">tname</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">infos</span> <span class="main">=</span>
                <span class="main">(</span><span class="entity">PropertyData.get_property_t</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">prop</span><span class="main">)</span><span class="main">)</span>
                    |&gt; filter <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">BoxID.is_eq_ancestor</span> <span class="entity">ctxt</span> <span class="entity">id'</span> <span class="entity">id</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            not <span class="main">(</span>null <span class="entity">infos</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>
        <span class="keyword2"><span class="keyword">else</span></span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">shadow_fn</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">ItemIO.get_io_info</span> <span class="entity">thy</span> <span class="entity">ty_str</span>

            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">eq_item</span> <span class="main">{</span>ty_str <span class="main">=</span> <span class="entity">ty_str2</span><span class="main">,</span> tname <span class="main">=</span> <span class="entity">tname2</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span>
                <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">ty_str</span> &lt;&gt; <span class="entity">ty_str2</span> <span class="keyword2"><span class="keyword">then</span></span> false <span class="keyword2"><span class="keyword">else</span></span>
                <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">shadow_fn</span> <span class="keyword2"><span class="keyword">of</span></span>
                    NONE <span class="main">=&gt;</span> eq_list <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv<span class="main">)</span> <span class="main">(</span><span class="entity">tname</span><span class="main">,</span> map Thm.term_of <span class="entity">tname2</span><span class="main">)</span>
                  <span class="main">|</span> SOME <span class="entity">f</span> <span class="main">=&gt;</span> <span class="entity">f</span> <span class="entity">ctxt</span> <span class="entity">id</span> <span class="main">(</span><span class="entity">tname</span><span class="main">,</span> <span class="entity">tname2</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            exists <span class="entity">eq_item</span> <span class="main">(</span><span class="entity">get_all_items_at_id</span> <span class="entity">st</span> <span class="entity">id</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Invoke a single handler (vars, t, ex_th) on the theorem th. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">invoke_handler</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">vars</span><span class="main">,</span> <span class="entity">t</span><span class="main">,</span> <span class="entity">ex_th</span><span class="main">)</span> <span class="entity">th</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> member <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv<span class="main">)</span> <span class="main">(</span>Thm.hyps_of <span class="entity">th</span><span class="main">)</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
      <span class="entity">th</span> |&gt; Thm.implies_intr <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">t</span><span class="main">)</span>
         |&gt; fold <span class="main">(</span><span class="entity">UtilLogic.ex_elim</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="main">(</span>rev <span class="entity">vars</span><span class="main">)</span>
         |&gt; Thm.elim_implies <span class="entity">ex_th</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">th</span>

<span class="comment1">(* Derive the consequence if box id is resolved, to the parent id
   formed by getting parent at index i.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_on_resolve</span> <span class="main">(</span><span class="entity">st</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">{</span><span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="entity">id</span> <span class="entity">i</span> <span class="entity">th</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="comment1">(* First get list of handlers to invoke. *)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prim_id</span> <span class="main">=</span> nth <span class="entity">id</span> <span class="entity">i</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">handlers</span> <span class="main">=</span>
          <span class="entity">st</span> |&gt; <span class="entity">get_handlers</span>
             |&gt; filter <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span>
                           <span class="entity">BoxID.is_eq_ancestor</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">prim_id</span><span class="main">]</span> <span class="entity">id'</span> <span class="keyword1"><span class="keyword">andalso</span></span>
                           <span class="entity">BoxID.is_eq_descendent</span> <span class="entity">ctxt</span> <span class="entity">id</span> <span class="entity">id'</span><span class="main">)</span>
             |&gt; map snd
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">init_assum</span> <span class="main">=</span> <span class="entity">get_init_assum</span> <span class="entity">st</span> <span class="entity">prim_id</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th'</span> <span class="main">=</span> <span class="entity">th</span> |&gt; fold <span class="main">(</span><span class="entity">invoke_handler</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">handlers</span>
                   |&gt; Thm.implies_intr <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">init_assum</span><span class="main">)</span>
                   |&gt; <span class="entity">apply_to_thm</span> <span class="entity">UtilLogic.rewrite_from_contra_form</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span><span class="entity">prim_id</span> &lt;&gt; <span class="entity">BoxID.home_id</span> <span class="keyword1"><span class="keyword">orelse</span></span> null <span class="main">(</span>Thm.hyps_of <span class="entity">th'</span><span class="main">)</span><span class="main">)</span>
                     <span class="inner_quoted">"get_on_resolve: did not remove all hypothesis at box 0."</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">th'</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Find a primitive box (if there is any) whose initial facts agree
   exactly with the given initial facts. Note we cannot yet handle new
   variables.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">find_prim_box</span> <span class="main">{</span><span class="entity">assums</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="entity">id</span> <span class="entity">init_assum</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">agree_at_id</span> <span class="entity">prim_id'</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">parent</span> <span class="main">=</span> <span class="entity">BoxID.get_parent_prim</span> <span class="entity">ctxt</span> <span class="entity">prim_id'</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">is_equiv_t</span> <span class="main">=</span> <span class="entity">RewriteTable.is_equiv_t</span> <span class="entity">parent</span> <span class="entity">ctxt</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="entity">is_equiv_t</span> <span class="main">(</span><span class="entity">init_assum</span><span class="main">,</span> nth <span class="entity">assums</span> <span class="entity">prim_id'</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">can_test_id</span> <span class="entity">prim_id'</span> <span class="main">=</span>
          <span class="entity">BoxID.is_eq_ancestor</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">BoxID.get_parent_prim</span> <span class="entity">ctxt</span> <span class="entity">prim_id'</span><span class="main">)</span> <span class="entity">id</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ids_to_test</span> <span class="main">=</span> filter <span class="entity">can_test_id</span> <span class="main">(</span><span class="inner_numeral">0</span> upto <span class="main">(</span>length <span class="entity">assums</span> - <span class="inner_numeral">1</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      find_first <span class="entity">agree_at_id</span> <span class="entity">ids_to_test</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map_queue</span> <span class="entity">f</span> <span class="main">{</span><span class="entity">assums</span><span class="main">,</span> <span class="entity">handlers</span><span class="main">,</span> <span class="entity">items</span><span class="main">,</span> <span class="entity">queue</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="entity">resolve_th</span><span class="main">}</span> <span class="main">=</span>
    <span class="main">{</span>assums <span class="main">=</span> <span class="entity">assums</span><span class="main">,</span> handlers <span class="main">=</span> <span class="entity">handlers</span><span class="main">,</span> items <span class="main">=</span> <span class="entity">items</span><span class="main">,</span> queue <span class="main">=</span> <span class="entity">f</span> <span class="entity">queue</span><span class="main">,</span>
     ctxt <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> resolve_th <span class="main">=</span> <span class="entity">resolve_th</span><span class="main">}</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_to_queue</span> <span class="entity">updt</span> <span class="main">=</span> <span class="entity">map_queue</span> <span class="main">(</span>Updates_Heap.insert <span class="entity">updt</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">delmin_from_queue</span> <span class="main">=</span> <span class="entity">map_queue</span> Updates_Heap.delete_min

<span class="keyword2"><span class="keyword">end</span></span>  <span class="comment1">(* structure Status *)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> Theory.setup <span class="main">(</span><span class="entity">ItemIO.add_basic_item_io</span><span class="main">)</span>
</pre>
</div><div id="files/AFP/Auto2_HOL/normalize.ML">
<div class="head">
<h1>File ‹$AFP/Auto2_HOL/normalize.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*
  File: normalize.ML
  Author: Bohua Zhan

  Normalization procedure for facts obtained during a proof.
*)</span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">normalizer</span> <span class="main">=</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">raw_item</span> <span class="main">-&gt;</span> <span class="entity">raw_item</span> list

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">NORMALIZER</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> add_normalizer<span class="main">:</span> string * <span class="entity">normalizer</span> <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> add_th_normalizer<span class="main">:</span>
      string * <span class="main">(</span><span class="entity">Proof.context</span> <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm list<span class="main">)</span> <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> add_rewr_normalizer<span class="main">:</span> string * thm <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> get_normalizers<span class="main">:</span> theory <span class="main">-&gt;</span> <span class="main">(</span>string * <span class="entity">normalizer</span><span class="main">)</span> list
  <span class="keyword1"><span class="keyword">val</span></span> normalize<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">raw_item</span> <span class="main">-&gt;</span> <span class="entity">raw_item</span> list
  <span class="keyword1"><span class="keyword">val</span></span> normalize_keep<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">raw_item</span> <span class="main">-&gt;</span> <span class="entity">raw_item</span> list

  <span class="comment1">(* Normalization of definition of variable *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> add_inj_struct_data<span class="main">:</span> thm <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory

  <span class="keyword1"><span class="keyword">val</span></span> is_def_eq<span class="main">:</span> theory <span class="main">-&gt;</span> term <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> swap_eq_to_front<span class="main">:</span> conv
  <span class="keyword1"><span class="keyword">val</span></span> meta_use_vardef<span class="main">:</span> thm <span class="main">-&gt;</span> <span class="main">(</span>term * term<span class="main">)</span> list * thm
  <span class="keyword1"><span class="keyword">val</span></span> meta_use_vardefs<span class="main">:</span> thm <span class="main">-&gt;</span> <span class="main">(</span>term * term<span class="main">)</span> list * thm
  <span class="keyword1"><span class="keyword">val</span></span> def_subst<span class="main">:</span> <span class="main">(</span>term * term<span class="main">)</span> list <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Normalizer</span> <span class="main">:</span> <span class="entity">NORMALIZER</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="comment1">(* Keeps list of normalizers. *)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Data</span> <span class="main">=</span> Theory_Data <span class="main">(</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">T</span> <span class="main">=</span> <span class="entity">normalizer</span> Symtab.table<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">empty</span> <span class="main">=</span> Symtab.empty<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">extend</span> <span class="main">=</span> I<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">merge</span> <span class="main">=</span> Symtab.merge pointer_eq
<span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_normalizer</span> <span class="main">(</span><span class="entity">norm_name</span><span class="main">,</span> <span class="entity">norm_fun</span><span class="main">)</span> <span class="main">=</span>
    Data.map <span class="main">(</span>Symtab.update_new <span class="main">(</span><span class="entity">norm_name</span><span class="main">,</span> <span class="entity">norm_fun</span><span class="main">)</span><span class="main">)</span>

<span class="comment1">(* Apply norm_fun: thm -&gt; thm list to any PROP item. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">th_normalizer</span> <span class="entity">norm_fun</span> <span class="entity">ctxt</span> <span class="entity">ritem</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">ritem</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="entity">Handler</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="entity">ritem</span><span class="main">]</span>
      <span class="main">|</span> <span class="entity">Fact</span> <span class="main">(</span><span class="entity">ty_str</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">ty_str</span> <span class="main">=</span> <span class="entity">TY_PROP</span> <span class="keyword2"><span class="keyword">then</span></span>
          map <span class="entity">Update.thm_to_ritem</span> <span class="main">(</span><span class="entity">norm_fun</span> <span class="entity">ctxt</span> <span class="entity">th</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="entity">ritem</span><span class="main">]</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_th_normalizer</span> <span class="main">(</span><span class="entity">norm_name</span><span class="main">,</span> <span class="entity">norm_fun</span><span class="main">)</span> <span class="main">=</span>
    <span class="entity">add_normalizer</span> <span class="main">(</span><span class="entity">norm_name</span><span class="main">,</span> <span class="entity">th_normalizer</span> <span class="entity">norm_fun</span><span class="main">)</span>

<span class="comment1">(* eq_th is a meta equality. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rewr_normalizer</span> <span class="entity">eq_th</span> <span class="entity">ctxt</span> <span class="entity">ritem</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cv</span> <span class="main">=</span> <span class="main">(</span>Conv.top_conv <span class="main">(</span>K <span class="main">(</span>Conv.try_conv <span class="main">(</span>Conv.rewr_conv <span class="entity">eq_th</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="entity">ctxt</span><span class="main">)</span>
                   then_conv <span class="main">(</span>Thm.beta_conversion true<span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">ritem</span> <span class="keyword2"><span class="keyword">of</span></span>
          <span class="entity">Handler</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="entity">ritem</span><span class="main">]</span>
        <span class="main">|</span> <span class="entity">Fact</span> <span class="main">(</span><span class="entity">ty_str</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=&gt;</span>
          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">ty_str</span> <span class="main">=</span> <span class="entity">TY_PROP</span> <span class="keyword2"><span class="keyword">then</span></span>
            <span class="main">[</span><span class="entity">Update.thm_to_ritem</span> <span class="main">(</span><span class="entity">apply_to_thm</span> <span class="entity">cv</span> <span class="entity">th</span><span class="main">)</span><span class="main">]</span>
          <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">ty_str</span> <span class="main">=</span> <span class="entity">TY_EQ</span> <span class="keyword2"><span class="keyword">then</span></span>
            <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">Util.is_meta_eq</span> <span class="main">(</span>Thm.prop_of <span class="entity">th</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
              <span class="comment1">(* Equality between lambda terms *)</span>
              <span class="main">[</span><span class="entity">ritem</span><span class="main">]</span>
            <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
              <span class="comment1">(* Apply to right side *)</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th'</span> <span class="main">=</span> <span class="entity">apply_to_thm'</span> <span class="main">(</span>Conv.arg_conv <span class="entity">cv</span><span class="main">)</span> <span class="entity">th</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">dest_eq</span> <span class="main">(</span><span class="entity">prop_of'</span> <span class="entity">th'</span><span class="main">)</span>
            <span class="keyword2"><span class="keyword">in</span></span>
              <span class="main">[</span><span class="entity">Fact</span> <span class="main">(</span><span class="entity">TY_EQ</span><span class="main">,</span> <span class="main">[</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">]</span><span class="main">,</span> <span class="entity">th'</span><span class="main">)</span><span class="main">]</span>
            <span class="keyword2"><span class="keyword">end</span></span>
          <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="entity">ritem</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_rewr_normalizer</span> <span class="main">(</span><span class="entity">norm_name</span><span class="main">,</span> <span class="entity">eq_th</span><span class="main">)</span> <span class="main">=</span>
    <span class="entity">add_normalizer</span> <span class="main">(</span><span class="entity">norm_name</span><span class="main">,</span> <span class="entity">rewr_normalizer</span> <span class="entity">eq_th</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_normalizers</span> <span class="entity">thy</span> <span class="main">=</span> Symtab.dest <span class="main">(</span>Data.get <span class="entity">thy</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">normalize</span> <span class="entity">ctxt</span> <span class="entity">ritem</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">norms</span> <span class="main">=</span> <span class="entity">get_normalizers</span> <span class="main">(</span>Proof_Context.theory_of <span class="entity">ctxt</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">apply_norm</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">norm_fun</span><span class="main">)</span> <span class="entity">ritems</span> <span class="main">=</span> maps <span class="main">(</span><span class="entity">norm_fun</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">ritems</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">norm_once</span> <span class="main">=</span> fold <span class="entity">apply_norm</span> <span class="entity">norms</span> <span class="main">[</span><span class="entity">ritem</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">norm_once</span> <span class="keyword2"><span class="keyword">of</span></span>
          <span class="main">[</span><span class="entity">ritem'</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">BoxItem.eq_ritem</span> <span class="main">(</span><span class="entity">ritem</span><span class="main">,</span> <span class="entity">ritem'</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="entity">ritem'</span><span class="main">]</span>
                      <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">normalize</span> <span class="entity">ctxt</span> <span class="entity">ritem'</span>
        <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> maps <span class="main">(</span><span class="entity">normalize</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">norm_once</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Perform normalization, but keep the original ritem. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">normalize_keep</span> <span class="entity">ctxt</span> <span class="entity">ritem</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">norm_ritems</span> <span class="main">=</span> <span class="entity">normalize</span> <span class="entity">ctxt</span> <span class="entity">ritem</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> length <span class="entity">norm_ritems</span> <span class="main">=</span> <span class="inner_numeral">1</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">norm_ritems</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">ritem</span> :: <span class="entity">norm_ritems</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Normalization of variable definition *)</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">InjStructData</span> <span class="main">=</span> Theory_Data <span class="main">(</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">T</span> <span class="main">=</span> thm Symtab.table<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">empty</span> <span class="main">=</span> Symtab.empty<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">extend</span> <span class="main">=</span> I<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">merge</span> <span class="main">=</span> Symtab.merge pointer_eq
<span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_inj_struct_data</span> <span class="entity">th</span> <span class="entity">thy</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">th</span> |&gt; <span class="entity">prop_of'</span> |&gt; <span class="entity">dest_eq</span> |&gt; fst |&gt; <span class="entity">dest_eq</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">f</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> Term.strip_comb <span class="entity">lhs</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">f</span> <span class="keyword2"><span class="keyword">of</span></span>
          Const <span class="main">(</span><span class="entity">nm</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span>
          InjStructData.map <span class="main">(</span>Symtab.update_new <span class="main">(</span><span class="entity">nm</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">)</span> <span class="entity">thy</span>
        <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"add_inj_struct_data"</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Check whether t is of the form ?A = t, where t does not contain ?A. *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">inj_args</span> <span class="entity">thy</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> Term.is_Var <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="entity">t</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">f</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span> <span class="main">=</span> Term.strip_comb <span class="entity">t</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> Term.is_Const <span class="entity">f</span> <span class="keyword1"><span class="keyword">andalso</span></span>
         Symtab.defined <span class="main">(</span>InjStructData.get <span class="entity">thy</span><span class="main">)</span> <span class="main">(</span><span class="entity">Util.get_head_name</span> <span class="entity">f</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
        maps <span class="main">(</span><span class="entity">inj_args</span> <span class="entity">thy</span><span class="main">)</span> <span class="entity">args</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="main">[</span><span class="entity">t</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_def_eq</span> <span class="entity">thy</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span><span class="entity">is_eq_term</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> false
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">dest_eq</span> <span class="entity">t</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">l_args</span><span class="main">,</span> <span class="entity">r_args</span><span class="main">)</span> <span class="main">=</span> apply2 <span class="main">(</span><span class="entity">inj_args</span> <span class="entity">thy</span><span class="main">)</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      forall Term.is_Var <span class="entity">l_args</span> <span class="keyword1"><span class="keyword">andalso</span></span>
      not <span class="main">(</span>forall Term.is_Var <span class="entity">r_args</span><span class="main">)</span> <span class="keyword1"><span class="keyword">andalso</span></span>
      forall <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="main">=&gt;</span> not <span class="main">(</span><span class="entity">Util.is_subterm</span> <span class="entity">t</span> <span class="entity">rhs</span><span class="main">)</span><span class="main">)</span> <span class="entity">l_args</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_def_eq'</span> <span class="entity">thy</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="entity">is_Trueprop</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_def_eq</span> <span class="entity">thy</span> <span class="main">(</span><span class="entity">dest_Trueprop</span> <span class="entity">t</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_neg_def_eq</span> <span class="entity">thy</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="entity">is_neg</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_def_eq</span> <span class="entity">thy</span> <span class="main">(</span><span class="entity">dest_not</span> <span class="entity">t</span><span class="main">)</span>

<span class="comment1">(* Given t of the form A_1 ==&gt; ... ==&gt; A_n ==&gt; C, swap all A_i of the
   form ?A = t to the front.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">swap_eq_to_front</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Thm.term_of <span class="entity">ct</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Thm.theory_of_cterm <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">Util.is_implies</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_def_eq'</span> <span class="entity">thy</span> <span class="main">(</span><span class="entity">dest_arg1</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
          Conv.all_conv <span class="entity">ct</span>
        <span class="keyword2"><span class="keyword">else</span></span>
          Conv.every_conv <span class="main">[</span>Conv.arg_conv <span class="entity">swap_eq_to_front</span><span class="main">,</span>
                           Conv.rewr_conv Drule.swap_prems_eq<span class="main">]</span> <span class="entity">ct</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        Conv.no_conv <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Given th where the first premise is in the form ?A = t, or f ?A_1
   ... ?A_n = t, where f is injective, replace ?A or each ?A_i in the
   rest of th, and remove the first premise.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">meta_use_vardef</span> <span class="entity">th</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span><span class="entity">Util.is_implies</span> <span class="main">(</span>Thm.prop_of <span class="entity">th</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
      <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cprem</span> <span class="main">=</span> <span class="entity">th</span> |&gt; Thm.cprop_of |&gt; Thm.dest_arg1 |&gt; Thm.dest_arg
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prem</span> <span class="main">=</span> Thm.term_of <span class="entity">cprem</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Thm.theory_of_thm <span class="entity">th</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_conj</span> <span class="entity">prem</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="entity">th</span> |&gt; <span class="entity">apply_to_thm</span> <span class="main">(</span>Conv.rewr_conv <span class="main">(</span><span class="entity">meta_sym</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> atomize_conjL<span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">)</span>
           |&gt; <span class="entity">meta_use_vardef</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_def_eq</span> <span class="entity">thy</span> <span class="entity">prem</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">c_lhs</span><span class="main">,</span> <span class="entity">c_rhs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">cdest_eq</span> <span class="entity">cprem</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">dest_eq</span> <span class="entity">prem</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="keyword2"><span class="keyword">if</span></span> Term.is_Var <span class="entity">lhs</span> <span class="keyword2"><span class="keyword">then</span></span>
            <span class="keyword2"><span class="keyword">let</span></span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">pairs</span><span class="main">,</span> <span class="entity">th'</span><span class="main">)</span> <span class="main">=</span>
                  <span class="entity">th</span> |&gt; <span class="entity">Util.subst_thm_atomic</span> <span class="main">[</span><span class="main">(</span><span class="entity">c_lhs</span><span class="main">,</span> <span class="entity">c_rhs</span><span class="main">)</span><span class="main">]</span>
                     |&gt; <span class="entity">apply_to_thm</span> <span class="main">(</span>Conv.arg1_conv <span class="entity">UtilBase.to_meta_eq_cv</span><span class="main">)</span>
                     |&gt; Thm.elim_implies <span class="main">(</span>Thm.reflexive <span class="entity">c_rhs</span><span class="main">)</span>
                     |&gt; <span class="entity">meta_use_vardef</span>
            <span class="keyword2"><span class="keyword">in</span></span>
              <span class="main">(</span><span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> :: <span class="entity">pairs</span><span class="main">,</span> <span class="entity">th'</span><span class="main">)</span>
            <span class="keyword2"><span class="keyword">end</span></span>
          <span class="keyword2"><span class="keyword">else</span></span>
            <span class="keyword2"><span class="keyword">let</span></span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">nm</span> <span class="main">=</span> <span class="entity">Util.get_head_name</span> <span class="entity">lhs</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">data</span> <span class="main">=</span> InjStructData.get <span class="entity">thy</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inj_th</span> <span class="main">=</span> the <span class="main">(</span>Symtab.lookup <span class="entity">data</span> <span class="entity">nm</span><span class="main">)</span>
                           <span class="keyword3"><span class="keyword">handle</span></span> Option.Option <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"meta_use_vardef"</span>
            <span class="keyword2"><span class="keyword">in</span></span>
              <span class="entity">th</span> |&gt; <span class="entity">apply_to_thm</span> <span class="main">(</span>
                Conv.arg1_conv <span class="main">(</span>Conv.arg_conv <span class="main">(</span><span class="entity">rewr_obj_eq</span> <span class="entity">inj_th</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
                 |&gt; <span class="entity">meta_use_vardef</span>
            <span class="keyword2"><span class="keyword">end</span></span>
        <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">disj_ts</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_disj</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">dest_arg1</span> <span class="entity">t</span> :: <span class="entity">disj_ts</span> <span class="main">(</span><span class="entity">dest_arg</span> <span class="entity">t</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="entity">t</span><span class="main">]</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">swap_disj</span> <span class="entity">ct</span> <span class="main">=</span>
    Conv.every_conv <span class="main">[</span><span class="entity">rewr_obj_eq</span> <span class="main">(</span><span class="entity">obj_sym</span> <span class="entity">UtilBase.disj_assoc_th</span><span class="main">)</span><span class="main">,</span>
                     Conv.arg1_conv <span class="main">(</span><span class="entity">rewr_obj_eq</span> <span class="entity">UtilBase.disj_commute_th</span><span class="main">)</span><span class="main">,</span>
                     <span class="entity">rewr_obj_eq</span> <span class="entity">UtilBase.disj_assoc_th</span><span class="main">]</span> <span class="entity">ct</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">disj_swap_eq_to_front'</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Thm.term_of <span class="entity">ct</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Thm.theory_of_cterm <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_disj</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_neg_def_eq</span> <span class="entity">thy</span> <span class="main">(</span><span class="entity">dest_arg1</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
          Conv.all_conv <span class="entity">ct</span>
        <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_disj</span> <span class="main">(</span><span class="entity">dest_arg</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
          Conv.every_conv <span class="main">[</span>Conv.arg_conv <span class="entity">disj_swap_eq_to_front'</span><span class="main">,</span>
                           <span class="entity">swap_disj</span><span class="main">]</span> <span class="entity">ct</span>
        <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_neg_def_eq</span> <span class="entity">thy</span> <span class="main">(</span><span class="entity">dest_arg</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
          <span class="entity">rewr_obj_eq</span> <span class="entity">UtilBase.disj_commute_th</span> <span class="entity">ct</span>
        <span class="keyword2"><span class="keyword">else</span></span>
          Conv.no_conv <span class="entity">ct</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        Conv.no_conv <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">disj_swap_eq_to_front</span> <span class="entity">ct</span> <span class="main">=</span>
    Conv.every_conv <span class="main">[</span>
      <span class="entity">Trueprop_conv</span> <span class="entity">disj_swap_eq_to_front'</span><span class="main">,</span>
      <span class="entity">Trueprop_conv</span> <span class="main">(</span><span class="entity">rewr_obj_eq</span> <span class="main">(</span><span class="entity">obj_sym</span> <span class="entity">UtilBase.imp_conv_disj_th</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
      Conv.rewr_conv <span class="main">(</span><span class="entity">meta_sym</span> <span class="entity">UtilBase.atomize_imp_th</span><span class="main">)</span>
    <span class="main">]</span> <span class="entity">ct</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">meta_use_vardefs</span> <span class="entity">th</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Thm.theory_of_thm <span class="entity">th</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> exists <span class="main">(</span><span class="entity">is_def_eq'</span> <span class="entity">thy</span><span class="main">)</span> <span class="main">(</span>Thm.prems_of <span class="entity">th</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">pairs</span><span class="main">,</span> <span class="entity">th'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">th</span> |&gt; <span class="entity">apply_to_thm</span> <span class="entity">swap_eq_to_front</span>
                                |&gt; <span class="entity">meta_use_vardef</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">pairs'</span><span class="main">,</span> <span class="entity">th''</span><span class="main">)</span> <span class="main">=</span> <span class="entity">meta_use_vardefs</span> <span class="entity">th'</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="main">(</span><span class="entity">pairs</span> @ <span class="entity">pairs'</span><span class="main">,</span> <span class="entity">th''</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_Trueprop</span> <span class="main">(</span>Thm.prop_of <span class="entity">th</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ts</span> <span class="main">=</span> <span class="entity">disj_ts</span> <span class="main">(</span><span class="entity">prop_of'</span> <span class="entity">th</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="keyword2"><span class="keyword">if</span></span> length <span class="entity">ts</span> &gt; <span class="inner_numeral">1</span> <span class="keyword1"><span class="keyword">andalso</span></span> exists <span class="main">(</span><span class="entity">is_neg_def_eq</span> <span class="entity">thy</span><span class="main">)</span> <span class="entity">ts</span> <span class="keyword2"><span class="keyword">then</span></span>
            <span class="keyword2"><span class="keyword">let</span></span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">pairs</span><span class="main">,</span> <span class="entity">th'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">th</span> |&gt; <span class="entity">apply_to_thm</span> <span class="entity">disj_swap_eq_to_front</span>
                                    |&gt; <span class="entity">meta_use_vardef</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">pairs'</span><span class="main">,</span> <span class="entity">th''</span><span class="main">)</span> <span class="main">=</span> <span class="entity">meta_use_vardefs</span> <span class="entity">th'</span>
            <span class="keyword2"><span class="keyword">in</span></span>
              <span class="main">(</span><span class="entity">pairs</span> @ <span class="entity">pairs'</span><span class="main">,</span> <span class="entity">th''</span><span class="main">)</span>
            <span class="keyword2"><span class="keyword">end</span></span>
          <span class="keyword2"><span class="keyword">else</span></span>
            <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">def_subst</span> <span class="entity">pairs</span> <span class="entity">t</span> <span class="main">=</span>
    fold <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">p</span> <span class="main">=&gt;</span> Term.subst_atomic <span class="main">[</span><span class="entity">p</span><span class="main">]</span><span class="main">)</span> <span class="entity">pairs</span> <span class="entity">t</span>

<span class="keyword2"><span class="keyword">end</span></span>  <span class="comment1">(* structure Normalizer. *)</span>
</pre>
</div><div id="files/AFP/Auto2_HOL/proofsteps.ML">
<div class="head">
<h1>File ‹$AFP/Auto2_HOL/proofsteps.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*
  File: proofsteps.ML
  Author: Bohua Zhan

  Definition of type proofstep, and facility for adding basic proof steps.
*)</span>

<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">proofstep_fn</span>
  <span class="main">=</span> <span class="entity">OneStep</span> <span class="keyword2"><span class="keyword">of</span></span> Proof.context <span class="main">-&gt;</span> box_item <span class="main">-&gt;</span> raw_update list
  <span class="main">|</span> <span class="entity">TwoStep</span> <span class="keyword2"><span class="keyword">of</span></span> Proof.context <span class="main">-&gt;</span> box_item <span class="main">-&gt;</span> box_item <span class="main">-&gt;</span> raw_update list

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">proofstep</span> <span class="main">=</span> <span class="main">{</span>
  name<span class="main">:</span> string<span class="main">,</span>
  args<span class="main">:</span> <span class="entity">match_arg</span> list<span class="main">,</span>
  func<span class="main">:</span> <span class="entity">proofstep_fn</span>
<span class="main">}</span>

<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">prfstep_descriptor</span> <span class="main">=</span> <span class="entity">WithFact</span> <span class="keyword2"><span class="keyword">of</span></span> term
                            <span class="main">|</span> <span class="entity">WithItem</span> <span class="keyword2"><span class="keyword">of</span></span> string * term
                            <span class="main">|</span> <span class="entity">WithProperty</span> <span class="keyword2"><span class="keyword">of</span></span> term
                            <span class="main">|</span> <span class="entity">WithWellForm</span> <span class="keyword2"><span class="keyword">of</span></span> term * term
                            <span class="main">|</span> <span class="entity">WithScore</span> <span class="keyword2"><span class="keyword">of</span></span> int
                            <span class="main">|</span> <span class="entity">GetFact</span> <span class="keyword2"><span class="keyword">of</span></span> term * thm
                            <span class="main">|</span> <span class="entity">ShadowFirst</span> <span class="main">|</span> <span class="entity">ShadowSecond</span>
                            <span class="main">|</span> <span class="entity">CreateCase</span> <span class="keyword2"><span class="keyword">of</span></span> term <span class="main">|</span> <span class="entity">CreateConcl</span> <span class="keyword2"><span class="keyword">of</span></span> term
                            <span class="main">|</span> <span class="entity">Filter</span> <span class="keyword2"><span class="keyword">of</span></span> prfstep_filter

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">PROOFSTEP</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> eq_prfstep<span class="main">:</span> <span class="entity">proofstep</span> * <span class="entity">proofstep</span> <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> apply_prfstep<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">box_item</span> list <span class="main">-&gt;</span> <span class="entity">proofstep</span> <span class="main">-&gt;</span> <span class="entity">raw_update</span> list
  <span class="keyword1"><span class="keyword">val</span></span> WithGoal<span class="main">:</span> term <span class="main">-&gt;</span> <span class="entity">prfstep_descriptor</span>
  <span class="keyword1"><span class="keyword">val</span></span> WithTerm<span class="main">:</span> term <span class="main">-&gt;</span> <span class="entity">prfstep_descriptor</span>
  <span class="keyword1"><span class="keyword">val</span></span> WithProp<span class="main">:</span> term <span class="main">-&gt;</span> <span class="entity">prfstep_descriptor</span>
  <span class="keyword1"><span class="keyword">val</span></span> string_of_desc<span class="main">:</span> theory <span class="main">-&gt;</span> <span class="entity">prfstep_descriptor</span> <span class="main">-&gt;</span> string
  <span class="keyword1"><span class="keyword">val</span></span> string_of_descs<span class="main">:</span> theory <span class="main">-&gt;</span> <span class="entity">prfstep_descriptor</span> list <span class="main">-&gt;</span> string

  <span class="comment1">(* prfstep_filter *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> all_insts<span class="main">:</span> <span class="entity">prfstep_filter</span>
  <span class="keyword1"><span class="keyword">val</span></span> neq_filter<span class="main">:</span> term <span class="main">-&gt;</span> <span class="entity">prfstep_filter</span>
  <span class="keyword1"><span class="keyword">val</span></span> order_filter<span class="main">:</span> string <span class="main">-&gt;</span> string <span class="main">-&gt;</span> <span class="entity">prfstep_filter</span>
  <span class="keyword1"><span class="keyword">val</span></span> size1_filter<span class="main">:</span> string <span class="main">-&gt;</span> <span class="entity">prfstep_filter</span>
  <span class="keyword1"><span class="keyword">val</span></span> not_type_filter<span class="main">:</span> string <span class="main">-&gt;</span> typ <span class="main">-&gt;</span> <span class="entity">prfstep_filter</span>

  <span class="comment1">(* First level proofstep writing functions. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> apply_pat_r<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">id_inst_ths</span> <span class="main">-&gt;</span> term * thm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> retrieve_args<span class="main">:</span> <span class="entity">prfstep_descriptor</span> list <span class="main">-&gt;</span> <span class="entity">match_arg</span> list
  <span class="keyword1"><span class="keyword">val</span></span> retrieve_pats_r<span class="main">:</span> <span class="entity">prfstep_descriptor</span> list <span class="main">-&gt;</span> <span class="main">(</span>term * thm<span class="main">)</span> list
  <span class="keyword1"><span class="keyword">val</span></span> retrieve_filts<span class="main">:</span> <span class="entity">prfstep_descriptor</span> list <span class="main">-&gt;</span> <span class="entity">prfstep_filter</span>
  <span class="keyword1"><span class="keyword">val</span></span> retrieve_cases<span class="main">:</span> <span class="entity">prfstep_descriptor</span> list <span class="main">-&gt;</span> term list
  <span class="keyword1"><span class="keyword">val</span></span> retrieve_shadows<span class="main">:</span> <span class="entity">prfstep_descriptor</span> list <span class="main">-&gt;</span> int list
  <span class="keyword1"><span class="keyword">val</span></span> get_side_ths<span class="main">:</span>
      <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">id_inst</span> <span class="main">-&gt;</span> <span class="entity">match_arg</span> list <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * thm list<span class="main">)</span> list
  <span class="keyword1"><span class="keyword">val</span></span> prfstep_custom<span class="main">:</span>
      string <span class="main">-&gt;</span> <span class="entity">prfstep_descriptor</span> list <span class="main">-&gt;</span>
      <span class="main">(</span><span class="entity">id_inst_ths</span> <span class="main">-&gt;</span> <span class="entity">box_item</span> list <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">raw_update</span> list<span class="main">)</span> <span class="main">-&gt;</span> <span class="entity">proofstep</span>
  <span class="keyword1"><span class="keyword">val</span></span> gen_prfstep<span class="main">:</span> string <span class="main">-&gt;</span> <span class="entity">prfstep_descriptor</span> list <span class="main">-&gt;</span> <span class="entity">proofstep</span>
  <span class="keyword1"><span class="keyword">val</span></span> prfstep_pre_conv<span class="main">:</span> string <span class="main">-&gt;</span> <span class="entity">prfstep_descriptor</span> list <span class="main">-&gt;</span>
                        <span class="main">(</span><span class="entity">Proof.context</span> <span class="main">-&gt;</span> conv<span class="main">)</span> <span class="main">-&gt;</span> <span class="entity">proofstep</span>
  <span class="keyword1"><span class="keyword">val</span></span> prfstep_conv<span class="main">:</span> string <span class="main">-&gt;</span> <span class="entity">prfstep_descriptor</span> list <span class="main">-&gt;</span> conv <span class="main">-&gt;</span> <span class="entity">proofstep</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">ProofStep</span> <span class="main">:</span> <span class="entity">PROOFSTEP</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">eq_prfstep</span> <span class="main">(</span><span class="entity">prfstep1</span><span class="main">,</span> <span class="entity">prfstep2</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">#</span>name <span class="entity">prfstep1</span> <span class="main">=</span> <span class="main">#</span>name <span class="entity">prfstep2</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">apply_prfstep</span> <span class="entity">ctxt</span> <span class="entity">items</span> <span class="main">{</span><span class="entity">func</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">func</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="entity">OneStep</span> <span class="entity">f</span> <span class="main">=&gt;</span> <span class="entity">f</span> <span class="entity">ctxt</span> <span class="main">(</span>the_single <span class="entity">items</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">TwoStep</span> <span class="entity">f</span> <span class="main">=&gt;</span> <span class="entity">f</span> <span class="entity">ctxt</span> <span class="main">(</span>hd <span class="entity">items</span><span class="main">)</span> <span class="main">(</span>nth <span class="entity">items</span> <span class="inner_numeral">1</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">WithGoal</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span>type_of <span class="entity">t</span> <span class="main">=</span> <span class="entity">boolT</span><span class="main">)</span> <span class="inner_quoted">"WithGoal: pat should have type bool."</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">WithFact</span> <span class="main">(</span><span class="entity">get_neg</span> <span class="entity">t</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">WithTerm</span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">WithItem</span> <span class="main">(</span><span class="entity">TY_TERM</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">WithProp</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span>type_of <span class="entity">t</span> <span class="main">=</span> <span class="entity">boolT</span><span class="main">)</span> <span class="inner_quoted">"WithProp: pat should have type bool."</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">WithItem</span> <span class="main">(</span><span class="entity">TY_PROP</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">string_of_desc</span> <span class="entity">thy</span> <span class="entity">desc</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">print</span> <span class="main">=</span> Syntax.string_of_term_global <span class="entity">thy</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">desc</span> <span class="keyword2"><span class="keyword">of</span></span>
          <span class="entity">WithFact</span> <span class="entity">t</span> <span class="main">=&gt;</span>
          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_neg</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="inner_quoted">"WithGoal "</span> ^ <span class="main">(</span><span class="entity">print</span> <span class="main">(</span><span class="entity">get_neg</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">else</span></span> <span class="inner_quoted">"WithFact "</span> ^ <span class="main">(</span><span class="entity">print</span> <span class="entity">t</span><span class="main">)</span>
        <span class="main">|</span> <span class="entity">WithItem</span> <span class="main">(</span><span class="entity">ty_str</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span> <span class="main">=&gt;</span>
          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">ty_str</span> <span class="main">=</span> <span class="entity">TY_TERM</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="inner_quoted">"WithTerm "</span> ^ <span class="main">(</span><span class="entity">print</span> <span class="entity">t</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">else</span></span> <span class="inner_quoted">"WithItem "</span> ^ <span class="entity">ty_str</span> ^ <span class="inner_quoted">" "</span> ^ <span class="main">(</span><span class="entity">print</span> <span class="entity">t</span><span class="main">)</span>
        <span class="main">|</span> <span class="entity">WithProperty</span> <span class="entity">t</span> <span class="main">=&gt;</span> <span class="inner_quoted">"WithProperty "</span> ^ <span class="main">(</span><span class="entity">print</span> <span class="entity">t</span><span class="main">)</span>
        <span class="main">|</span> <span class="entity">WithWellForm</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">req</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="inner_quoted">"WithWellForm "</span> ^ <span class="main">(</span><span class="entity">print</span> <span class="entity">req</span><span class="main">)</span>
        <span class="main">|</span> <span class="entity">WithScore</span> <span class="entity">n</span> <span class="main">=&gt;</span> <span class="inner_quoted">"WithScore "</span> ^ <span class="main">(</span>string_of_int <span class="entity">n</span><span class="main">)</span>
        <span class="main">|</span> <span class="entity">GetFact</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=&gt;</span>
          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">t</span> aconv <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">False</span><span class="antiquote">}</span></span> <span class="keyword2"><span class="keyword">then</span></span>
            <span class="inner_quoted">"GetResolve "</span> ^ <span class="main">(</span><span class="entity">Util.name_of_thm</span> <span class="entity">th</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_neg</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
            <span class="inner_quoted">"GetGoal ("</span> ^ <span class="main">(</span><span class="entity">print</span> <span class="main">(</span><span class="entity">get_neg</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span> ^ <span class="inner_quoted">", "</span> ^ <span class="main">(</span><span class="entity">Util.name_of_thm</span> <span class="entity">th</span><span class="main">)</span> ^ <span class="inner_quoted">")"</span>
          <span class="keyword2"><span class="keyword">else</span></span>
            <span class="inner_quoted">"GetFact ("</span> ^ <span class="main">(</span><span class="entity">print</span> <span class="entity">t</span><span class="main">)</span> ^ <span class="inner_quoted">", "</span> ^ <span class="main">(</span><span class="entity">Util.name_of_thm</span> <span class="entity">th</span><span class="main">)</span> ^ <span class="inner_quoted">")"</span>
        <span class="main">|</span> <span class="entity">ShadowFirst</span> <span class="main">=&gt;</span> <span class="inner_quoted">"Shadow first"</span> <span class="main">|</span> <span class="entity">ShadowSecond</span> <span class="main">=&gt;</span> <span class="inner_quoted">"Shadow second"</span>
        <span class="main">|</span> <span class="entity">CreateCase</span> <span class="entity">assum</span> <span class="main">=&gt;</span> <span class="inner_quoted">"CreateCase "</span> ^ <span class="main">(</span><span class="entity">print</span> <span class="entity">assum</span><span class="main">)</span>
        <span class="main">|</span> <span class="entity">CreateConcl</span> <span class="entity">concl</span> <span class="main">=&gt;</span> <span class="inner_quoted">"CreateConcl "</span> ^ <span class="main">(</span><span class="entity">print</span> <span class="entity">concl</span><span class="main">)</span>
        <span class="main">|</span> <span class="entity">Filter</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="inner_quoted">"Filter (...)"</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">string_of_descs</span> <span class="entity">thy</span> <span class="entity">descs</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_filter</span> <span class="entity">desc</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">desc</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="entity">Filter</span> <span class="main">_</span> <span class="main">=&gt;</span> true <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">filts</span><span class="main">,</span> <span class="entity">non_filts</span><span class="main">)</span> <span class="main">=</span> <span class="entity">filter_split</span> <span class="entity">is_filter</span> <span class="entity">descs</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">(</span>cat_lines <span class="main">(</span>map <span class="main">(</span><span class="entity">string_of_desc</span> <span class="entity">thy</span><span class="main">)</span> <span class="entity">non_filts</span><span class="main">)</span><span class="main">)</span> ^
      <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> length <span class="entity">filts</span> &gt; <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span>
         <span class="main">(</span><span class="inner_quoted">" + "</span> ^ <span class="main">(</span>string_of_int <span class="main">(</span>length <span class="entity">filts</span><span class="main">)</span><span class="main">)</span> ^ <span class="inner_quoted">" filters"</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="inner_quoted">""</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* prfstep_filter *)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_insts</span> <span class="main">=</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> true

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">neq_filter</span> <span class="entity">cond</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="main">=</span>
          <span class="entity">cond</span> |&gt; <span class="entity">dest_not</span> |&gt; <span class="entity">dest_eq</span>
          <span class="keyword3"><span class="keyword">handle</span></span> Fail <span class="inner_quoted">"dest_not"</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"neq_filter: not an inequality."</span>
               <span class="main">|</span> Fail <span class="inner_quoted">"dest_eq"</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"neq_filter: not an inequality."</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span>null <span class="main">(</span>Term.add_frees <span class="entity">cond</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
                     <span class="inner_quoted">"neq_filter: should not contain free variable."</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t1</span> <span class="main">=</span> <span class="entity">Util.subst_term_norm</span> <span class="entity">inst</span> <span class="entity">lhs</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t2</span> <span class="main">=</span> <span class="entity">Util.subst_term_norm</span> <span class="entity">inst</span> <span class="entity">rhs</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">Util.has_vars</span> <span class="entity">t1</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">Util.has_vars</span> <span class="entity">t2</span> <span class="keyword2"><span class="keyword">then</span></span> true
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">Util.has_vars</span> <span class="entity">t1</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="main">(</span><span class="entity">Matcher.rewrite_match</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">fo_init</span><span class="main">)</span><span class="main">)</span>
            |&gt; filter <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">id</span> <span class="main">=</span> <span class="entity">id'</span><span class="main">)</span> |&gt; null
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">Util.has_vars</span> <span class="entity">t2</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="main">(</span><span class="entity">Matcher.rewrite_match</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">t2</span><span class="main">,</span> Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">t1</span><span class="main">)</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">fo_init</span><span class="main">)</span><span class="main">)</span>
            |&gt; filter <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">id</span> <span class="main">=</span> <span class="entity">id'</span><span class="main">)</span> |&gt; null
      <span class="keyword2"><span class="keyword">else</span></span>
        not <span class="main">(</span><span class="entity">RewriteTable.is_equiv_t</span> <span class="entity">id</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">order_filter</span> <span class="entity">s1</span> <span class="entity">s2</span> <span class="main">_</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span> <span class="main">=</span>
    not <span class="main">(</span>Term_Ord.term_ord <span class="main">(</span><span class="entity">lookup_inst</span> <span class="entity">inst</span> <span class="entity">s2</span><span class="main">,</span> <span class="entity">lookup_inst</span> <span class="entity">inst</span> <span class="entity">s1</span><span class="main">)</span> <span class="main">=</span> LESS<span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">size1_filter</span> <span class="entity">s1</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span> <span class="main">=</span>
    size_of_term <span class="main">(</span><span class="entity">RewriteTable.simp_val_t</span> <span class="entity">id</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">lookup_inst</span> <span class="entity">inst</span> <span class="entity">s1</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="inner_numeral">1</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">not_type_filter</span> <span class="entity">s</span> <span class="entity">ty</span> <span class="main">_</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span> <span class="main">=</span>
    not <span class="main">(</span>Term.fastype_of <span class="main">(</span><span class="entity">lookup_inst</span> <span class="entity">inst</span> <span class="entity">s</span><span class="main">)</span> <span class="main">=</span> <span class="entity">ty</span><span class="main">)</span>

<span class="comment1">(* First level proofstep writing functions. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">apply_pat_r</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span><span class="main">,</span> <span class="entity">ths</span><span class="main">)</span> <span class="main">(</span><span class="entity">pat_r</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span>fastype_of <span class="entity">pat_r</span> <span class="main">=</span> <span class="entity">boolT</span><span class="main">)</span>
                     <span class="inner_quoted">"apply_pat_r: pat_r should be of type bool"</span>

      <span class="comment1">(* Split into meta equalities (usually produced by term
         matching, not applied to th, and others (assumptions for th).
       *)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">eqs</span><span class="main">,</span> <span class="entity">ths'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">ths</span> |&gt; <span class="entity">filter_split</span> <span class="main">(</span><span class="entity">Util.is_meta_eq</span> o Thm.prop_of<span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span>length <span class="entity">ths'</span> <span class="main">=</span> Thm.nprems_of <span class="entity">th</span><span class="main">)</span>
                     <span class="inner_quoted">"apply_pat_r: wrong number of assumptions."</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inst_new</span> <span class="main">=</span> <span class="entity">Util.subst_term_norm</span> <span class="entity">inst</span> <span class="main">(</span><span class="entity">mk_Trueprop</span> <span class="entity">pat_r</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th'</span> <span class="main">=</span> <span class="entity">th</span> |&gt; <span class="entity">Util.subst_thm</span> <span class="entity">ctxt</span> <span class="entity">inst</span> |&gt; fold Thm.elim_implies <span class="entity">ths'</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">inst_new</span> aconv <span class="main">(</span>Thm.prop_of <span class="entity">th'</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span>
              <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"apply_pat_r: conclusion mismatch"</span>

      <span class="comment1">(* Rewrite on subterms, top sweep order. *)</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rewr_top</span> <span class="entity">eq_th</span> <span class="main">=</span>
          Conv.top_sweep_conv <span class="main">(</span>K <span class="main">(</span>Conv.rewr_conv <span class="entity">eq_th</span><span class="main">)</span><span class="main">)</span> <span class="entity">ctxt</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">th'</span> |&gt; <span class="entity">apply_to_thm</span> <span class="main">(</span>Conv.every_conv <span class="main">(</span>map <span class="entity">rewr_top</span> <span class="entity">eqs</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">retrieve_args</span> <span class="entity">descs</span> <span class="main">=</span>
    maps <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">desc</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">desc</span> <span class="keyword2"><span class="keyword">of</span></span>
                         <span class="entity">WithFact</span> <span class="entity">t</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="entity">PropMatch</span> <span class="entity">t</span><span class="main">]</span>
                       <span class="main">|</span> <span class="entity">WithItem</span> <span class="main">(</span><span class="entity">ty_str</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="entity">TypedMatch</span> <span class="main">(</span><span class="entity">ty_str</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">]</span>
                       <span class="main">|</span> <span class="entity">WithProperty</span> <span class="entity">t</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="entity">PropertyMatch</span> <span class="entity">t</span><span class="main">]</span>
                       <span class="main">|</span> <span class="entity">WithWellForm</span> <span class="entity">t</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="entity">WellFormMatch</span> <span class="entity">t</span><span class="main">]</span>
                       <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
         <span class="entity">descs</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">retrieve_pats_r</span> <span class="entity">descs</span> <span class="main">=</span>
    maps <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">desc</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">desc</span> <span class="keyword2"><span class="keyword">of</span></span>
                         <span class="entity">GetFact</span> <span class="main">(</span><span class="entity">pat_r</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="main">(</span><span class="entity">pat_r</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">]</span>
                       <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
         <span class="entity">descs</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">retrieve_filts</span> <span class="entity">descs</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">filts</span> <span class="main">=</span> maps <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">Filter</span> <span class="entity">filt</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="entity">filt</span><span class="main">]</span> <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="entity">descs</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">inst</span> <span class="main">=&gt;</span> forall <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">f</span> <span class="main">=&gt;</span> <span class="entity">f</span> <span class="entity">ctxt</span> <span class="entity">inst</span><span class="main">)</span> <span class="entity">filts</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">retrieve_cases</span> <span class="entity">descs</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">retrieve_case</span> <span class="entity">desc</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">desc</span> <span class="keyword2"><span class="keyword">of</span></span>
              <span class="entity">CreateCase</span> <span class="entity">assum</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="entity">mk_Trueprop</span> <span class="entity">assum</span><span class="main">]</span>
            <span class="main">|</span> <span class="entity">CreateConcl</span> <span class="entity">concl</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="entity">mk_Trueprop</span> <span class="main">(</span><span class="entity">get_neg</span> <span class="entity">concl</span><span class="main">)</span><span class="main">]</span>
            <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      maps <span class="entity">retrieve_case</span> <span class="entity">descs</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">retrieve_shadows</span> <span class="entity">descs</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">retrieve_shadow</span> <span class="entity">desc</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">desc</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="entity">ShadowFirst</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="inner_numeral">0</span><span class="main">]</span> <span class="main">|</span> <span class="entity">ShadowSecond</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="inner_numeral">1</span><span class="main">]</span> <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      maps <span class="entity">retrieve_shadow</span> <span class="entity">descs</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">retrieve_score</span> <span class="entity">descs</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">retrieve_score</span> <span class="entity">desc</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">desc</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="entity">WithScore</span> <span class="entity">n</span> <span class="main">=&gt;</span> SOME <span class="entity">n</span> <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> NONE
    <span class="keyword2"><span class="keyword">in</span></span>
      get_first <span class="entity">retrieve_score</span> <span class="entity">descs</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Given list of PropertyMatch and WellFormMatch arguments, attempt to
   find the corresponding theorems in the rewrite table. Return the
   list of theorems for each possible (mutually non-comparable) box
   IDs.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_side_ths</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span> <span class="entity">side_args</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">side_args</span> <span class="keyword2"><span class="keyword">then</span></span>
      <span class="main">[</span><span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">side_args'</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">ItemIO.subst_arg</span> <span class="entity">inst</span><span class="main">)</span> <span class="entity">side_args</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_side_arg</span> <span class="entity">side_arg</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">side_arg</span> <span class="keyword2"><span class="keyword">of</span></span>
              <span class="entity">PropertyMatch</span> <span class="entity">prop</span> <span class="main">=&gt;</span>
              <span class="entity">PropertyData.get_property_t</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">prop</span><span class="main">)</span>
            <span class="main">|</span> <span class="entity">WellFormMatch</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">req</span><span class="main">)</span> <span class="main">=&gt;</span>
              <span class="main">(</span><span class="entity">WellformData.get_wellform_t</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span>
                  |&gt; filter <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">prop_of'</span> <span class="entity">th</span> aconv <span class="entity">req</span><span class="main">)</span>
            <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"get_side_ths: wrong kind of arg."</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">side_ths</span> <span class="main">=</span> map <span class="entity">process_side_arg</span> <span class="entity">side_args'</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> exists null <span class="entity">side_ths</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">side_ths</span> |&gt; <span class="entity">BoxID.get_all_merges_info</span> <span class="entity">ctxt</span>
                    |&gt; <span class="entity">Util.max_partial</span> <span class="main">(</span><span class="entity">BoxID.id_is_eq_ancestor</span> <span class="entity">ctxt</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Creates a proofstep with specified patterns and filters (in descs),
   and a custom function converting any instantiations into updates.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prfstep_custom</span> <span class="entity">name</span> <span class="entity">descs</span> <span class="entity">updt_fn</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">=</span> <span class="entity">retrieve_args</span> <span class="entity">descs</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">item_args</span><span class="main">,</span> <span class="entity">side_args</span><span class="main">)</span> <span class="main">=</span> <span class="entity">filter_split</span> <span class="entity">ItemIO.is_ordinary_match</span> <span class="entity">args</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">filt</span> <span class="main">=</span> <span class="entity">retrieve_filts</span> <span class="entity">descs</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">shadows</span> <span class="main">=</span> <span class="entity">retrieve_shadows</span> <span class="entity">descs</span>

      <span class="comment1">(* Processing an instantiation after matching the one or two
         main matchers: apply filters, remove trivial True from
         matchings, find properties, and replace incremental ids.
       *)</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_inst</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span><span class="main">,</span> <span class="entity">ths</span><span class="main">)</span> <span class="main">=</span>
          <span class="main">(</span><span class="entity">get_side_ths</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span> <span class="entity">side_args</span><span class="main">)</span>
              |&gt; filter <span class="main">(</span><span class="entity">BoxID.has_incr_id</span> o fst<span class="main">)</span>
              |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">p_ths</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span><span class="main">,</span> <span class="entity">p_ths</span> @ <span class="entity">ths</span><span class="main">)</span><span class="main">)</span>
              |&gt; filter <span class="main">(</span><span class="entity">filt</span> <span class="entity">ctxt</span> o fst<span class="main">)</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">shadow_to_update</span> <span class="entity">items</span> <span class="main">(</span><span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="entity">n</span> <span class="main">=</span>
          <span class="entity">ShadowItem</span> <span class="main">{</span>id <span class="main">=</span> <span class="entity">id</span><span class="main">,</span> item <span class="main">=</span> nth <span class="entity">items</span> <span class="entity">n</span><span class="main">}</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> length <span class="entity">item_args</span> <span class="main">=</span> <span class="inner_numeral">1</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg</span> <span class="main">=</span> the_single <span class="entity">item_args</span>
          <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prfstep</span> <span class="entity">ctxt</span> <span class="entity">item</span> <span class="main">=</span>
              <span class="keyword2"><span class="keyword">let</span></span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inst_ths</span> <span class="main">=</span> <span class="main">(</span><span class="entity">ItemIO.match_arg</span> <span class="entity">ctxt</span> <span class="entity">arg</span> <span class="entity">item</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">fo_init</span><span class="main">)</span><span class="main">)</span>
                                |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">inst</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">inst</span><span class="main">,</span> <span class="main">[</span><span class="entity">th</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
                                |&gt; maps <span class="main">(</span><span class="entity">process_inst</span> <span class="entity">ctxt</span><span class="main">)</span>

                <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_inst</span> <span class="entity">inst_th</span> <span class="main">=</span>
                    <span class="entity">updt_fn</span> <span class="entity">inst_th</span> <span class="main">[</span><span class="entity">item</span><span class="main">]</span> <span class="entity">ctxt</span> @
                    map <span class="main">(</span><span class="entity">shadow_to_update</span> <span class="main">[</span><span class="entity">item</span><span class="main">]</span> <span class="entity">inst_th</span><span class="main">)</span> <span class="entity">shadows</span>
              <span class="keyword2"><span class="keyword">in</span></span>
                maps <span class="entity">process_inst</span> <span class="entity">inst_ths</span>
              <span class="keyword2"><span class="keyword">end</span></span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="main">{</span>name <span class="main">=</span> <span class="entity">name</span><span class="main">,</span> args <span class="main">=</span> <span class="entity">args</span><span class="main">,</span> func <span class="main">=</span> <span class="entity">OneStep</span> <span class="entity">prfstep</span><span class="main">}</span>
        <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> length <span class="entity">item_args</span> <span class="main">=</span> <span class="inner_numeral">2</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">arg1</span><span class="main">,</span> <span class="entity">arg2</span><span class="main">)</span> <span class="main">=</span> <span class="entity">the_pair</span> <span class="entity">item_args</span>
          <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prfstep1</span> <span class="entity">ctxt</span> <span class="entity">item1</span> <span class="main">=</span>
              <span class="keyword2"><span class="keyword">let</span></span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inst_ths</span> <span class="main">=</span> <span class="entity">ItemIO.match_arg</span> <span class="entity">ctxt</span> <span class="entity">arg1</span> <span class="entity">item1</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">fo_init</span><span class="main">)</span>

                <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_inst1</span> <span class="entity">item2</span> <span class="main">(</span><span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=</span>
                    <span class="keyword2"><span class="keyword">let</span></span>
                      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg2'</span> <span class="main">=</span> <span class="entity">ItemIO.subst_arg</span> <span class="entity">inst</span> <span class="entity">arg2</span>
                      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inst_ths'</span> <span class="main">=</span>
                          <span class="main">(</span><span class="entity">ItemIO.match_arg</span> <span class="entity">ctxt</span> <span class="entity">arg2'</span> <span class="entity">item2</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span><span class="main">)</span>
                              |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">inst'</span><span class="main">,</span> <span class="entity">th'</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">inst'</span><span class="main">,</span> <span class="main">[</span><span class="entity">th</span><span class="main">,</span> <span class="entity">th'</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
                              |&gt; maps <span class="main">(</span><span class="entity">process_inst</span> <span class="entity">ctxt</span><span class="main">)</span>

                      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_inst</span> <span class="entity">inst_th'</span> <span class="main">=</span>
                          <span class="entity">updt_fn</span> <span class="entity">inst_th'</span> <span class="main">[</span><span class="entity">item1</span><span class="main">,</span> <span class="entity">item2</span><span class="main">]</span> <span class="entity">ctxt</span> @
                          map <span class="main">(</span><span class="entity">shadow_to_update</span> <span class="main">[</span><span class="entity">item1</span><span class="main">,</span> <span class="entity">item2</span><span class="main">]</span> <span class="entity">inst_th'</span><span class="main">)</span> <span class="entity">shadows</span>
                    <span class="keyword2"><span class="keyword">in</span></span>
                      maps <span class="entity">process_inst</span> <span class="entity">inst_ths'</span>
                    <span class="keyword2"><span class="keyword">end</span></span>
              <span class="keyword2"><span class="keyword">in</span></span>
                <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">item2</span> <span class="main">=&gt;</span> maps <span class="main">(</span><span class="entity">process_inst1</span> <span class="entity">item2</span><span class="main">)</span> <span class="entity">inst_ths</span>
              <span class="keyword2"><span class="keyword">end</span></span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="main">{</span>name <span class="main">=</span> <span class="entity">name</span><span class="main">,</span> args <span class="main">=</span> <span class="entity">args</span><span class="main">,</span> func <span class="main">=</span> <span class="entity">TwoStep</span> <span class="entity">prfstep1</span><span class="main">}</span>
        <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"prfstep_custom: must have 1 or 2 patterns."</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Create a proofstep from a list of proofstep descriptors. See
   datatype prfstep_descriptor for allowed types of descriptors.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">gen_prfstep</span> <span class="entity">name</span> <span class="entity">descs</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">=</span> <span class="entity">retrieve_args</span> <span class="entity">descs</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pats_r</span> <span class="main">=</span> <span class="entity">retrieve_pats_r</span> <span class="entity">descs</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cases</span> <span class="main">=</span> <span class="entity">retrieve_cases</span> <span class="entity">descs</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sc</span> <span class="main">=</span> <span class="entity">retrieve_score</span> <span class="entity">descs</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">input_descs</span> <span class="main">=</span>
          filter <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">desc</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">desc</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="entity">GetFact</span> <span class="main">_</span> <span class="main">=&gt;</span> false
                                        <span class="main">|</span> <span class="entity">CreateCase</span> <span class="main">_</span> <span class="main">=&gt;</span> false
                                        <span class="main">|</span> <span class="entity">CreateConcl</span> <span class="main">_</span> <span class="main">=&gt;</span> false
                                        <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> true<span class="main">)</span> <span class="entity">descs</span>

      <span class="comment1">(* Verify that all schematic variables appearing in pats_r /
         cases appear in pats.
       *)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pats</span> <span class="main">=</span> map <span class="entity">ItemIO.pat_of_match_arg</span> <span class="entity">args</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">vars</span> <span class="main">=</span> map Var <span class="main">(</span>fold Term.add_vars <span class="entity">pats</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">check_pat_r</span> <span class="main">(</span><span class="entity">pat_r</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span>
          subset <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv<span class="main">)</span> <span class="main">(</span>map Var <span class="main">(</span>Term.add_vars <span class="entity">pat_r</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">vars</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">check_case</span> <span class="entity">assum</span> <span class="main">=</span>
          subset <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv<span class="main">)</span> <span class="main">(</span>map Var <span class="main">(</span>Term.add_vars <span class="entity">assum</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">vars</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span>forall <span class="entity">check_pat_r</span> <span class="entity">pats_r</span> <span class="keyword1"><span class="keyword">andalso</span></span> forall <span class="entity">check_case</span> <span class="entity">cases</span><span class="main">)</span>
                     <span class="inner_quoted">"gen_prfstep: new schematic variable in pats_r / cases."</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pats_r_to_update</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">inst_ths</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">pats_r</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span> <span class="keyword2"><span class="keyword">else</span></span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ths</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">apply_pat_r</span> <span class="entity">ctxt</span> <span class="entity">inst_ths</span><span class="main">)</span> <span class="entity">pats_r</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="keyword2"><span class="keyword">if</span></span> length <span class="entity">ths</span> <span class="main">=</span> <span class="inner_numeral">1</span> <span class="keyword1"><span class="keyword">andalso</span></span>
               Thm.prop_of <span class="main">(</span>the_single <span class="entity">ths</span><span class="main">)</span> aconv <span class="entity">pFalse</span> <span class="keyword2"><span class="keyword">then</span></span>
              <span class="main">[</span><span class="entity">ResolveBox</span> <span class="main">{</span>id <span class="main">=</span> <span class="entity">id</span><span class="main">,</span> th <span class="main">=</span> the_single <span class="entity">ths</span><span class="main">}</span><span class="main">]</span>
            <span class="keyword2"><span class="keyword">else</span></span>
              <span class="main">[</span><span class="entity">AddItems</span> <span class="main">{</span>id <span class="main">=</span> <span class="entity">id</span><span class="main">,</span> sc <span class="main">=</span> <span class="entity">sc</span><span class="main">,</span>
                         raw_items <span class="main">=</span> map <span class="entity">Update.thm_to_ritem</span> <span class="entity">ths</span><span class="main">}</span><span class="main">]</span>
          <span class="keyword2"><span class="keyword">end</span></span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">case_to_update</span> <span class="main">(</span><span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="entity">assum</span> <span class="main">=</span>
          <span class="entity">AddBoxes</span> <span class="main">{</span>id <span class="main">=</span> <span class="entity">id</span><span class="main">,</span> sc <span class="main">=</span> <span class="entity">sc</span><span class="main">,</span>
                    init_assum <span class="main">=</span> <span class="entity">Util.subst_term_norm</span> <span class="entity">inst</span> <span class="entity">assum</span><span class="main">}</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">cases_to_update</span> <span class="entity">inst_ths</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">case_to_update</span> <span class="entity">inst_ths</span><span class="main">)</span> <span class="entity">cases</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">updt_fn</span> <span class="entity">inst_th</span> <span class="main">_</span> <span class="entity">ctxt</span> <span class="main">=</span>
          <span class="entity">pats_r_to_update</span> <span class="entity">ctxt</span> <span class="entity">inst_th</span> @ <span class="entity">cases_to_update</span> <span class="entity">inst_th</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">prfstep_custom</span> <span class="entity">name</span> <span class="entity">input_descs</span> <span class="entity">updt_fn</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prfstep_pre_conv</span> <span class="entity">name</span> <span class="entity">descs</span> <span class="entity">pre_cv</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">=</span> <span class="entity">retrieve_args</span> <span class="entity">descs</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">args</span> <span class="keyword2"><span class="keyword">of</span></span>
                  <span class="main">[</span><span class="entity">TypedMatch</span> <span class="main">(</span><span class="inner_quoted">"TERM"</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">)</span>
                <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="main">(</span><span class="inner_quoted">"prfstep_conv: should have exactly one "</span> ^
                                   <span class="inner_quoted">"term pattern."</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">filt</span> <span class="main">=</span> <span class="entity">retrieve_filts</span> <span class="entity">descs</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prfstep</span> <span class="entity">ctxt</span> <span class="entity">item</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inst_ths</span> <span class="main">=</span>
                <span class="main">(</span><span class="entity">ItemIO.match_arg</span> <span class="entity">ctxt</span> <span class="main">(</span>the_single <span class="entity">args</span><span class="main">)</span> <span class="entity">item</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">fo_init</span><span class="main">)</span><span class="main">)</span>
                    |&gt; filter <span class="main">(</span><span class="entity">BoxID.has_incr_id</span> o fst o fst<span class="main">)</span>
                    |&gt; filter <span class="main">(</span><span class="entity">filt</span> <span class="entity">ctxt</span> o fst<span class="main">)</span>

            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">inst_to_updt</span> <span class="main">(</span><span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="entity">eq1</span><span class="main">)</span> <span class="main">=</span>
                <span class="comment1">(* Here eq1 is meta_eq from pat(inst) to item. *)</span>
                <span class="keyword2"><span class="keyword">let</span></span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ct</span> <span class="main">=</span> Thm.lhs_of <span class="entity">eq1</span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">err</span> <span class="main">=</span> <span class="entity">name</span> ^ <span class="inner_quoted">": cv failed."</span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq_th</span> <span class="main">=</span> <span class="entity">pre_cv</span> <span class="entity">ctxt</span> <span class="entity">ct</span>
                              <span class="keyword3"><span class="keyword">handle</span></span> CTERM <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="entity">err</span>
                <span class="keyword2"><span class="keyword">in</span></span>
                  <span class="keyword2"><span class="keyword">if</span></span> Thm.is_reflexive <span class="entity">eq_th</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span> <span class="keyword2"><span class="keyword">else</span></span>
                  <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">RewriteTable.is_equiv</span> <span class="entity">id</span> <span class="entity">ctxt</span> <span class="main">(</span>Thm.rhs_of <span class="entity">eq1</span><span class="main">,</span> Thm.rhs_of <span class="entity">eq_th</span><span class="main">)</span>
                  <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span>
                  <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
                    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th</span> <span class="main">=</span> <span class="entity">to_obj_eq</span> <span class="main">(</span><span class="entity">Util.transitive_list</span> <span class="main">[</span><span class="entity">meta_sym</span> <span class="entity">eq1</span><span class="main">,</span> <span class="entity">eq_th</span><span class="main">]</span><span class="main">)</span>
                  <span class="keyword2"><span class="keyword">in</span></span>
                    <span class="main">[</span><span class="entity">Update.thm_update</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">]</span>
                  <span class="keyword2"><span class="keyword">end</span></span>
                <span class="keyword2"><span class="keyword">end</span></span>
          <span class="keyword2"><span class="keyword">in</span></span>
            maps <span class="entity">inst_to_updt</span> <span class="entity">inst_ths</span>
          <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">{</span>name <span class="main">=</span> <span class="entity">name</span><span class="main">,</span> args <span class="main">=</span> <span class="entity">args</span><span class="main">,</span> func <span class="main">=</span> <span class="entity">OneStep</span> <span class="entity">prfstep</span><span class="main">}</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prfstep_conv</span> <span class="entity">name</span> <span class="entity">descs</span> <span class="entity">cv</span> <span class="main">=</span> <span class="entity">prfstep_pre_conv</span> <span class="entity">name</span> <span class="entity">descs</span> <span class="main">(</span>K <span class="entity">cv</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>  <span class="comment1">(* structure ProofStep *)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">WithTerm</span> <span class="main">=</span> <span class="entity">ProofStep.WithTerm</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">WithGoal</span> <span class="main">=</span> <span class="entity">ProofStep.WithGoal</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">WithProp</span> <span class="main">=</span> <span class="entity">ProofStep.WithProp</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">neq_filter</span> <span class="main">=</span> <span class="entity">ProofStep.neq_filter</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">order_filter</span> <span class="main">=</span> <span class="entity">ProofStep.order_filter</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">size1_filter</span> <span class="main">=</span> <span class="entity">ProofStep.size1_filter</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">not_type_filter</span> <span class="main">=</span> <span class="entity">ProofStep.not_type_filter</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">PROOFSTEP_DATA</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> add_prfstep<span class="main">:</span> <span class="entity">proofstep</span> <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> del_prfstep_pred<span class="main">:</span> <span class="main">(</span>string <span class="main">-&gt;</span> bool<span class="main">)</span> <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> del_prfstep<span class="main">:</span> string <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> del_prfstep_thm<span class="main">:</span> thm <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> del_prfstep_thm_str<span class="main">:</span> string <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> del_prfstep_thm_eqforward<span class="main">:</span> thm <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> get_prfsteps<span class="main">:</span> theory <span class="main">-&gt;</span> <span class="entity">proofstep</span> list

  <span class="keyword1"><span class="keyword">val</span></span> add_prfstep_custom<span class="main">:</span>
      <span class="main">(</span>string * <span class="entity">prfstep_descriptor</span> list *
       <span class="main">(</span><span class="entity">id_inst_ths</span> <span class="main">-&gt;</span> <span class="entity">box_item</span> list <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">raw_update</span> list<span class="main">)</span><span class="main">)</span> <span class="main">-&gt;</span>
      theory <span class="main">-&gt;</span> theory

  <span class="keyword1"><span class="keyword">val</span></span> add_gen_prfstep<span class="main">:</span> string * <span class="entity">prfstep_descriptor</span> list <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> add_prfstep_pre_conv<span class="main">:</span> string * <span class="entity">prfstep_descriptor</span> list *
                            <span class="main">(</span><span class="entity">Proof.context</span> <span class="main">-&gt;</span> conv<span class="main">)</span> <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> add_prfstep_conv<span class="main">:</span>
      string * <span class="entity">prfstep_descriptor</span> list * conv <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory

  <span class="comment1">(* Constructing conditional prfstep_descriptors. *)</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">pre_prfstep_descriptor</span> <span class="main">=</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">prfstep_descriptor</span>
  <span class="keyword1"><span class="keyword">val</span></span> with_term<span class="main">:</span> string <span class="main">-&gt;</span> <span class="entity">pre_prfstep_descriptor</span>
  <span class="keyword1"><span class="keyword">val</span></span> with_cond<span class="main">:</span> string <span class="main">-&gt;</span> <span class="entity">pre_prfstep_descriptor</span>
  <span class="keyword1"><span class="keyword">val</span></span> with_conds<span class="main">:</span> string list <span class="main">-&gt;</span> <span class="entity">pre_prfstep_descriptor</span> list
  <span class="keyword1"><span class="keyword">val</span></span> with_filt<span class="main">:</span> <span class="entity">prfstep_filter</span> <span class="main">-&gt;</span> <span class="entity">pre_prfstep_descriptor</span>
  <span class="keyword1"><span class="keyword">val</span></span> with_filts<span class="main">:</span> <span class="entity">prfstep_filter</span> list <span class="main">-&gt;</span> <span class="entity">pre_prfstep_descriptor</span> list
  <span class="keyword1"><span class="keyword">val</span></span> with_score<span class="main">:</span> int <span class="main">-&gt;</span> <span class="entity">pre_prfstep_descriptor</span>

  <span class="comment1">(* Second level proofstep writing functions. *)</span>
  <span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">prfstep_mode</span> <span class="main">=</span> <span class="entity">MODE_FORWARD</span> <span class="main">|</span> <span class="entity">MODE_FORWARD'</span> <span class="main">|</span> <span class="entity">MODE_BACKWARD</span>
                          <span class="main">|</span> <span class="entity">MODE_BACKWARD1</span> <span class="main">|</span> <span class="entity">MODE_BACKWARD2</span> <span class="main">|</span> <span class="entity">MODE_RESOLVE</span>
  <span class="keyword1"><span class="keyword">val</span></span> add_prfstep_check_req<span class="main">:</span> string * string <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> add_forward_prfstep_cond<span class="main">:</span>
      thm <span class="main">-&gt;</span> <span class="entity">pre_prfstep_descriptor</span> list <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> add_forward'_prfstep_cond<span class="main">:</span>
      thm <span class="main">-&gt;</span> <span class="entity">pre_prfstep_descriptor</span> list <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> add_backward_prfstep_cond<span class="main">:</span>
      thm <span class="main">-&gt;</span> <span class="entity">pre_prfstep_descriptor</span> list <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> add_backward1_prfstep_cond<span class="main">:</span>
      thm <span class="main">-&gt;</span> <span class="entity">pre_prfstep_descriptor</span> list <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> add_backward2_prfstep_cond<span class="main">:</span>
      thm <span class="main">-&gt;</span> <span class="entity">pre_prfstep_descriptor</span> list <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> add_resolve_prfstep_cond<span class="main">:</span>
      thm <span class="main">-&gt;</span> <span class="entity">pre_prfstep_descriptor</span> list <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> add_forward_prfstep<span class="main">:</span> thm <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> add_forward'_prfstep<span class="main">:</span> thm <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> add_backward_prfstep<span class="main">:</span> thm <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> add_backward1_prfstep<span class="main">:</span> thm <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> add_backward2_prfstep<span class="main">:</span> thm <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> add_resolve_prfstep<span class="main">:</span> thm <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory

  <span class="keyword1"><span class="keyword">val</span></span> add_rewrite_rule_cond<span class="main">:</span>
      thm <span class="main">-&gt;</span> <span class="entity">pre_prfstep_descriptor</span> list <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> add_rewrite_rule_back_cond<span class="main">:</span>
      thm <span class="main">-&gt;</span> <span class="entity">pre_prfstep_descriptor</span> list <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> add_rewrite_rule_bidir_cond<span class="main">:</span>
      thm <span class="main">-&gt;</span> <span class="entity">pre_prfstep_descriptor</span> list <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory

  <span class="keyword1"><span class="keyword">val</span></span> add_rewrite_rule<span class="main">:</span> thm <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> add_rewrite_rule_back<span class="main">:</span> thm <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> add_rewrite_rule_bidir<span class="main">:</span> thm <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory

  <span class="keyword1"><span class="keyword">val</span></span> setup_attrib<span class="main">:</span> <span class="main">(</span>thm <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory<span class="main">)</span> <span class="main">-&gt;</span> attribute context_parser
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">ProofStepData</span> <span class="main">:</span> <span class="entity">PROOFSTEP_DATA</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Data</span> <span class="main">=</span> Theory_Data <span class="main">(</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">T</span> <span class="main">=</span> <span class="entity">proofstep</span> list<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">empty</span> <span class="main">=</span> <span class="main">[</span><span class="main">]</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">extend</span> <span class="main">=</span> I<span class="main">;</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">merge</span> <span class="main">(</span><span class="entity">ps1</span><span class="main">,</span> <span class="entity">ps2</span><span class="main">)</span> <span class="main">=</span> Library.merge <span class="entity">ProofStep.eq_prfstep</span> <span class="main">(</span><span class="entity">ps1</span><span class="main">,</span> <span class="entity">ps2</span><span class="main">)</span>
<span class="main">)</span>

<span class="comment1">(* Add the given proof step. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_prfstep</span> <span class="main">(</span><span class="entity">prfstep</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">{</span><span class="entity">args</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span>
    Data.map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">prfsteps</span> <span class="main">=&gt;</span>
       <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">Util.is_prefix_str</span> <span class="inner_quoted">"$"</span> <span class="main">(</span><span class="main">#</span>name <span class="entity">prfstep</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
         error <span class="inner_quoted">"Add prfstep: names beginning with $ is reserved."</span>
       <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
         <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">num_args</span> <span class="main">=</span> length <span class="main">(</span>filter_out <span class="entity">ItemIO.is_side_match</span> <span class="entity">args</span><span class="main">)</span>
       <span class="keyword2"><span class="keyword">in</span></span>
         <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">num_args</span> &gt;= <span class="inner_numeral">1</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">num_args</span> &lt;= <span class="inner_numeral">2</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">prfsteps</span> @ <span class="main">[</span><span class="entity">prfstep</span><span class="main">]</span>
         <span class="keyword2"><span class="keyword">else</span></span> error <span class="inner_quoted">"add_proofstep: need 1 or 2 patterns."</span>
       <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>

<span class="comment1">(* Deleting a proofstep. For string inputs, try adding theory
   name. For theorem inputs, try all @-suffixes.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">del_prfstep_pred</span> <span class="entity">pred</span> <span class="main">=</span>
    Data.map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">prfsteps</span> <span class="main">=&gt;</span>
       <span class="keyword2"><span class="keyword">let</span></span>
         <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">names</span> <span class="main">=</span> map <span class="main">#</span>name <span class="entity">prfsteps</span>
         <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">to_delete</span> <span class="main">=</span> filter <span class="entity">pred</span> <span class="entity">names</span>
         <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">eq_name</span> <span class="main">(</span><span class="entity">key</span><span class="main">,</span> <span class="main">{</span><span class="entity">name</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">key</span> <span class="main">=</span> <span class="entity">name</span><span class="main">)</span>
       <span class="keyword2"><span class="keyword">in</span></span>
         <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">to_delete</span> <span class="keyword2"><span class="keyword">then</span></span>
           error <span class="inner_quoted">"Delete prfstep: not found"</span>
         <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
           <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> writeln <span class="main">(</span>cat_lines <span class="main">(</span>map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">name</span> <span class="main">=&gt;</span> <span class="inner_quoted">"Delete "</span> ^ <span class="entity">name</span><span class="main">)</span>
                                           <span class="entity">to_delete</span><span class="main">)</span><span class="main">)</span>
         <span class="keyword2"><span class="keyword">in</span></span>
           subtract <span class="entity">eq_name</span> <span class="entity">to_delete</span> <span class="entity">prfsteps</span>
         <span class="keyword2"><span class="keyword">end</span></span>
       <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">del_prfstep</span> <span class="entity">prfstep_name</span> <span class="entity">thy</span> <span class="main">=</span>
    <span class="entity">del_prfstep_pred</span> <span class="main">(</span>equal <span class="entity">prfstep_name</span><span class="main">)</span> <span class="entity">thy</span>

<span class="comment1">(* Delete all proofsteps for a given theorem. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">del_prfstep_thm</span> <span class="entity">th</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th_name</span> <span class="main">=</span> <span class="entity">Util.name_of_thm</span> <span class="entity">th</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">del_prfstep_pred</span> <span class="main">(</span>equal <span class="entity">th_name</span> orf <span class="entity">Util.is_prefix_str</span> <span class="main">(</span><span class="entity">th_name</span> ^ <span class="inner_quoted">"@"</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Delete proofsteps for a given theorem, with the given postfix. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">del_prfstep_thm_str</span> <span class="entity">str</span> <span class="entity">th</span> <span class="main">=</span>
    <span class="entity">del_prfstep_pred</span> <span class="main">(</span>equal <span class="main">(</span><span class="entity">Util.name_of_thm</span> <span class="entity">th</span> ^ <span class="entity">str</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">del_prfstep_thm_eqforward</span> <span class="main">=</span> <span class="entity">del_prfstep_thm_str</span> <span class="inner_quoted">"@eqforward"</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_prfsteps</span> <span class="entity">thy</span> <span class="main">=</span> Data.get <span class="entity">thy</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_prfstep_custom</span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">descs</span><span class="main">,</span> <span class="entity">updt_fn</span><span class="main">)</span> <span class="main">=</span>
    <span class="entity">add_prfstep</span> <span class="main">(</span><span class="entity">ProofStep.prfstep_custom</span> <span class="entity">name</span> <span class="entity">descs</span> <span class="entity">updt_fn</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_gen_prfstep</span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">descs</span><span class="main">)</span> <span class="main">=</span>
    <span class="entity">add_prfstep</span> <span class="main">(</span><span class="entity">ProofStep.gen_prfstep</span> <span class="entity">name</span> <span class="entity">descs</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_prfstep_pre_conv</span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">descs</span><span class="main">,</span> <span class="entity">pre_cv</span><span class="main">)</span> <span class="main">=</span>
    <span class="entity">add_prfstep</span> <span class="main">(</span><span class="entity">ProofStep.prfstep_pre_conv</span> <span class="entity">name</span> <span class="entity">descs</span> <span class="entity">pre_cv</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_prfstep_conv</span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">descs</span><span class="main">,</span> <span class="entity">cv</span><span class="main">)</span> <span class="main">=</span>
    <span class="entity">add_prfstep</span> <span class="main">(</span><span class="entity">ProofStep.prfstep_conv</span> <span class="entity">name</span> <span class="entity">descs</span> <span class="entity">cv</span><span class="main">)</span>

<span class="comment1">(* Constructing conditional prfstep_descriptors. *)</span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">pre_prfstep_descriptor</span> <span class="main">=</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">prfstep_descriptor</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">with_term</span> <span class="entity">str</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Proof_Context.read_term_pattern <span class="entity">ctxt</span> <span class="entity">str</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span>null <span class="main">(</span>Term.add_frees <span class="entity">t</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
                     <span class="inner_quoted">"with_term: should not contain free variable."</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">WithTerm</span> <span class="entity">t</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">with_cond</span> <span class="entity">str</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="entity">Filter</span> <span class="main">(</span><span class="entity">neq_filter</span> <span class="main">(</span>Proof_Context.read_term_pattern <span class="entity">ctxt</span> <span class="entity">str</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">with_conds</span> <span class="entity">strs</span> <span class="main">=</span> map <span class="entity">with_cond</span> <span class="entity">strs</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">with_filt</span> <span class="entity">filt</span> <span class="main">=</span> K <span class="main">(</span><span class="entity">Filter</span> <span class="entity">filt</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">with_filts</span> <span class="entity">filts</span> <span class="main">=</span> map <span class="entity">with_filt</span> <span class="entity">filts</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">with_score</span> <span class="entity">n</span> <span class="main">=</span> K <span class="main">(</span><span class="entity">WithScore</span> <span class="entity">n</span><span class="main">)</span>

<span class="comment1">(* Second level proofstep writing functions. *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_and_print_prfstep</span> <span class="entity">prfstep_name</span> <span class="entity">descs</span> <span class="entity">thy</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> writeln <span class="main">(</span><span class="entity">prfstep_name</span> ^ <span class="inner_quoted">"\n"</span> ^ <span class="main">(</span><span class="entity">ProofStep.string_of_descs</span> <span class="entity">thy</span> <span class="entity">descs</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">add_gen_prfstep</span> <span class="main">(</span><span class="entity">prfstep_name</span><span class="main">,</span> <span class="entity">descs</span><span class="main">)</span> <span class="entity">thy</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Add a proofstep checking a requirement. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_prfstep_check_req</span> <span class="main">(</span><span class="entity">t_str</span><span class="main">,</span> <span class="entity">req_str</span><span class="main">)</span> <span class="entity">thy</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt</span> <span class="main">=</span> Proof_Context.init_global <span class="entity">thy</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Proof_Context.read_term_pattern <span class="entity">ctxt</span> <span class="entity">t_str</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">vars</span> <span class="main">=</span> map Free <span class="main">(</span>Term.add_frees <span class="entity">t</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">c</span> <span class="main">=</span> <span class="entity">Util.get_head_name</span> <span class="entity">t</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt'</span> <span class="main">=</span> fold <span class="entity">Util.declare_free_term</span> <span class="entity">vars</span> <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">req</span> <span class="main">=</span> Proof_Context.read_term_pattern <span class="entity">ctxt'</span> <span class="entity">req_str</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_subst</span> <span class="entity">var</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">var</span> <span class="keyword2"><span class="keyword">of</span></span> Free <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">var</span><span class="main">,</span> Var <span class="main">(</span><span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span><span class="main">)</span>
                    <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"add_prfstep_check_req"</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">subst</span> <span class="main">=</span> map <span class="entity">get_subst</span> <span class="entity">vars</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t'</span> <span class="main">=</span> Term.subst_atomic <span class="entity">subst</span> <span class="entity">t</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">req'</span> <span class="main">=</span> Term.subst_atomic <span class="entity">subst</span> <span class="entity">req</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">add_and_print_prfstep</span>
          <span class="main">(</span><span class="entity">c</span> ^ <span class="inner_quoted">"_case"</span><span class="main">)</span> <span class="main">[</span><span class="entity">WithTerm</span> <span class="entity">t'</span><span class="main">,</span> <span class="entity">CreateConcl</span> <span class="entity">req'</span><span class="main">]</span> <span class="entity">thy</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">prfstep_mode</span> <span class="main">=</span> <span class="entity">MODE_FORWARD</span> <span class="main">|</span> <span class="entity">MODE_FORWARD'</span> <span class="main">|</span> <span class="entity">MODE_BACKWARD</span>
                        <span class="main">|</span> <span class="entity">MODE_BACKWARD1</span> <span class="main">|</span> <span class="entity">MODE_BACKWARD2</span> <span class="main">|</span> <span class="entity">MODE_RESOLVE</span>

<span class="comment1">(* Maximum number of term matches for the given mode. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">max_term_matches</span> <span class="entity">mode</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">mode</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="entity">MODE_FORWARD</span> <span class="main">=&gt;</span> <span class="inner_numeral">2</span>
      <span class="main">|</span> <span class="entity">MODE_FORWARD'</span> <span class="main">=&gt;</span> <span class="inner_numeral">1</span>
      <span class="main">|</span> <span class="entity">MODE_BACKWARD</span> <span class="main">=&gt;</span> <span class="inner_numeral">1</span>
      <span class="main">|</span> <span class="entity">MODE_RESOLVE</span> <span class="main">=&gt;</span> <span class="inner_numeral">1</span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="inner_numeral">0</span>

<span class="comment1">(* Obtain the first several premises of th that are either properties
   or wellformed-ness data. ts is the list of term matches.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_side_prems</span> <span class="entity">thy</span> <span class="entity">mode</span> <span class="entity">ts</span> <span class="entity">th</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">prems</span><span class="main">,</span> <span class="entity">concl</span><span class="main">)</span> <span class="main">=</span> <span class="entity">UtilLogic.strip_horn'</span> <span class="entity">th</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span>length <span class="entity">ts</span> &lt;= <span class="entity">max_term_matches</span> <span class="entity">mode</span><span class="main">)</span>
                     <span class="inner_quoted">"get_side_prems: too many term matches."</span>

      <span class="comment1">(* Helper function. Consider the case where the first n premises
         are side conditions. Find the additional terms to match
         against for each mode.
       *)</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">additional_matches</span> <span class="entity">n</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prems'</span> <span class="main">=</span> drop <span class="entity">n</span> <span class="entity">prems</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">mode</span> <span class="keyword2"><span class="keyword">of</span></span>
                <span class="entity">MODE_FORWARD</span> <span class="main">=&gt;</span> take <span class="main">(</span><span class="inner_numeral">2</span> - length <span class="entity">ts</span><span class="main">)</span> <span class="entity">prems'</span>
              <span class="main">|</span> <span class="entity">MODE_FORWARD'</span> <span class="main">=&gt;</span>
                <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">ts</span> <span class="keyword1"><span class="keyword">andalso</span></span> length <span class="entity">prems'</span> &gt;= <span class="inner_numeral">2</span> <span class="keyword2"><span class="keyword">then</span></span>
                  <span class="main">[</span>hd <span class="entity">prems'</span><span class="main">,</span> List.last <span class="entity">prems'</span><span class="main">]</span>
                <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span>List.last <span class="entity">prems'</span><span class="main">]</span>
              <span class="main">|</span> <span class="entity">MODE_BACKWARD</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="entity">get_neg</span> <span class="entity">concl</span><span class="main">]</span>
              <span class="main">|</span> <span class="entity">MODE_BACKWARD1</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="entity">get_neg</span> <span class="entity">concl</span><span class="main">,</span> List.last <span class="entity">prems'</span><span class="main">]</span>
              <span class="main">|</span> <span class="entity">MODE_BACKWARD2</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="entity">get_neg</span> <span class="entity">concl</span><span class="main">,</span> hd <span class="entity">prems'</span><span class="main">]</span>
              <span class="main">|</span> <span class="entity">MODE_RESOLVE</span> <span class="main">=&gt;</span>
                <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">ts</span> <span class="keyword1"><span class="keyword">andalso</span></span> length <span class="entity">prems'</span> &gt; <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span>
                  <span class="main">[</span><span class="entity">get_neg</span> <span class="entity">concl</span><span class="main">,</span> List.last <span class="entity">prems'</span><span class="main">]</span>
                <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="entity">get_neg</span> <span class="entity">concl</span><span class="main">]</span>
          <span class="keyword2"><span class="keyword">end</span></span>

      <span class="comment1">(* Determine whether t is a valid side premises, relative to the
         matches ts'. If yes, return the corresponding side
         matching. Otherwise return NONE.
       *)</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">to_side_prems</span> <span class="entity">ts'</span> <span class="entity">t</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">WellForm.is_subterm_wellform_data</span> <span class="entity">thy</span> <span class="entity">t</span> <span class="entity">ts'</span> <span class="keyword2"><span class="keyword">of</span></span>
              SOME <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">req</span><span class="main">)</span> <span class="main">=&gt;</span> SOME <span class="main">(</span><span class="entity">WithWellForm</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">req</span><span class="main">)</span><span class="main">)</span>
            <span class="main">|</span> NONE <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">Property.is_property_prem</span> <span class="entity">thy</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span> SOME <span class="main">(</span><span class="entity">WithProperty</span> <span class="entity">t</span><span class="main">)</span>
                      <span class="keyword2"><span class="keyword">else</span></span> NONE

      <span class="comment1">(* Attempt to convert the first n premises to side matchings. *)</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">to_side_prems_n</span> <span class="entity">n</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ts'</span> <span class="main">=</span> <span class="entity">additional_matches</span> <span class="entity">n</span> @ <span class="entity">ts</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">side_prems'</span> <span class="main">=</span> <span class="entity">prems</span> |&gt; take <span class="entity">n</span>
                                    |&gt; map <span class="main">(</span><span class="entity">to_side_prems</span> <span class="entity">ts'</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="keyword2"><span class="keyword">if</span></span> forall is_some <span class="entity">side_prems'</span> <span class="keyword2"><span class="keyword">then</span></span>
              SOME <span class="main">(</span>map the <span class="entity">side_prems'</span><span class="main">)</span>
            <span class="keyword2"><span class="keyword">else</span></span> NONE
          <span class="keyword2"><span class="keyword">end</span></span>

      <span class="comment1">(* Minimum number of premises for the given mode. *)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">min_prems</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">mode</span> <span class="keyword2"><span class="keyword">of</span></span>
              <span class="entity">MODE_FORWARD</span> <span class="main">=&gt;</span> <span class="inner_numeral">1</span> - length <span class="entity">ts</span>
            <span class="main">|</span> <span class="entity">MODE_FORWARD'</span> <span class="main">=&gt;</span> <span class="inner_numeral">1</span>
            <span class="main">|</span> <span class="entity">MODE_BACKWARD</span> <span class="main">=&gt;</span> <span class="inner_numeral">1</span>
            <span class="main">|</span> <span class="entity">MODE_BACKWARD1</span> <span class="main">=&gt;</span> <span class="inner_numeral">2</span>
            <span class="main">|</span> <span class="entity">MODE_BACKWARD2</span> <span class="main">=&gt;</span> <span class="inner_numeral">2</span>
            <span class="main">|</span> <span class="entity">MODE_RESOLVE</span> <span class="main">=&gt;</span> <span class="inner_numeral">0</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span>length <span class="entity">prems</span> &gt;= <span class="entity">min_prems</span><span class="main">)</span>
                     <span class="inner_quoted">"get_side_prems: too few premises."</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">to_test</span> <span class="main">=</span> rev <span class="main">(</span><span class="inner_numeral">0</span> upto <span class="main">(</span>length <span class="entity">prems</span> - <span class="entity">min_prems</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="comment1">(* Always succeeds at 0. *)</span>
      the <span class="main">(</span>get_first <span class="entity">to_side_prems_n</span> <span class="entity">to_test</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Convert theorems of the form A1 ==&gt; ... ==&gt; An ==&gt; C to A1 &amp; ... &amp;
   An ==&gt; C. If keep_last = true, the last assumption is kept in
   implication form.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">atomize_conj_cv</span> <span class="entity">keep_last</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> length <span class="main">(</span>Logic.strip_imp_prems <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span><span class="main">)</span> &lt;=
       <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">keep_last</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="inner_numeral">2</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="inner_numeral">1</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
      Conv.all_conv <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">else</span></span>
      Conv.every_conv <span class="main">[</span>Conv.arg_conv <span class="main">(</span><span class="entity">atomize_conj_cv</span> <span class="entity">keep_last</span><span class="main">)</span><span class="main">,</span>
                       Conv.rewr_conv <span class="entity">UtilBase.atomize_conjL_th</span><span class="main">]</span> <span class="entity">ct</span>

<span class="comment1">(* Swap the last premise to become the first. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">swap_prem_to_front</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">n</span> <span class="main">=</span> length <span class="main">(</span>Logic.strip_imp_prems <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">n</span> &lt; <span class="inner_numeral">2</span> <span class="keyword2"><span class="keyword">then</span></span>
        Conv.all_conv <span class="entity">ct</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">n</span> <span class="main">=</span> <span class="inner_numeral">2</span> <span class="keyword2"><span class="keyword">then</span></span>
        Conv.rewr_conv Drule.swap_prems_eq <span class="entity">ct</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="main">(</span><span class="main">(</span>Conv.arg_conv <span class="entity">swap_prem_to_front</span><span class="main">)</span>
             then_conv <span class="main">(</span>Conv.rewr_conv Drule.swap_prems_eq<span class="main">)</span><span class="main">)</span> <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Using cv, rewrite all assumptions and conclusion in ct. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">horn_conv</span> <span class="entity">cv</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> Thm.term_of <span class="entity">ct</span> <span class="keyword2"><span class="keyword">of</span></span>
         <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> Pure.imp<span class="antiquote">}</span></span> $ <span class="main">_</span> $ <span class="main">_</span> <span class="main">=&gt;</span>
         <span class="main">(</span>Conv.arg1_conv <span class="main">(</span><span class="entity">Trueprop_conv</span> <span class="entity">cv</span><span class="main">)</span><span class="main">)</span>
             then_conv <span class="main">(</span>Conv.arg_conv <span class="main">(</span><span class="entity">horn_conv</span> <span class="entity">cv</span><span class="main">)</span><span class="main">)</span>
       <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">Trueprop_conv</span> <span class="entity">cv</span><span class="main">)</span> <span class="entity">ct</span>

<span class="comment1">(* Try to cancel terms of the form ~~A. *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">try_nn_cancel_cv</span> <span class="main">=</span> Conv.try_conv <span class="main">(</span><span class="entity">rewr_obj_eq</span> <span class="entity">UtilBase.nn_cancel_th</span><span class="main">)</span>

<span class="comment1">(* Post-processing of the given theorem according to mode. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">post_process_th</span> <span class="entity">ctxt</span> <span class="entity">mode</span> <span class="entity">side_count</span> <span class="entity">ts</span> <span class="entity">th</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">mode</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="entity">MODE_FORWARD</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">to_skip</span> <span class="main">=</span> <span class="entity">side_count</span> + <span class="main">(</span><span class="inner_numeral">2</span> - length <span class="entity">ts</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="entity">th</span> |&gt; <span class="entity">apply_to_thm</span> <span class="main">(</span><span class="entity">Util.skip_n_conv</span> <span class="entity">to_skip</span> <span class="main">(</span><span class="entity">UtilLogic.to_obj_conv</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span>
             |&gt; <span class="entity">Util.update_name_of_thm</span> <span class="entity">th</span> <span class="inner_quoted">""</span>
        <span class="keyword2"><span class="keyword">end</span></span>
      <span class="main">|</span> <span class="entity">MODE_FORWARD'</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cv</span> <span class="main">=</span>
              <span class="entity">swap_prem_to_front</span>
                  then_conv <span class="main">(</span><span class="entity">Util.skip_n_conv</span> <span class="main">(</span><span class="inner_numeral">2</span> - length <span class="entity">ts</span><span class="main">)</span> <span class="main">(</span><span class="entity">UtilLogic.to_obj_conv</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="entity">th</span> |&gt; <span class="entity">apply_to_thm</span> <span class="main">(</span><span class="entity">Util.skip_n_conv</span> <span class="entity">side_count</span> <span class="entity">cv</span><span class="main">)</span>
             |&gt; <span class="entity">Util.update_name_of_thm</span> <span class="entity">th</span> <span class="inner_quoted">""</span>
        <span class="keyword2"><span class="keyword">end</span></span>
      <span class="main">|</span> <span class="entity">MODE_BACKWARD</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cv</span> <span class="main">=</span> <span class="main">(</span><span class="entity">atomize_conj_cv</span> false<span class="main">)</span>
                       then_conv <span class="main">(</span>Conv.rewr_conv <span class="entity">UtilBase.backward_conv_th</span><span class="main">)</span>
                       then_conv <span class="main">(</span><span class="entity">horn_conv</span> <span class="entity">try_nn_cancel_cv</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="entity">th</span> |&gt; <span class="entity">apply_to_thm</span> <span class="main">(</span><span class="entity">Util.skip_n_conv</span> <span class="entity">side_count</span> <span class="entity">cv</span><span class="main">)</span>
             |&gt; <span class="entity">Util.update_name_of_thm</span> <span class="entity">th</span> <span class="inner_quoted">"@back"</span>
        <span class="keyword2"><span class="keyword">end</span></span>
      <span class="main">|</span> <span class="entity">MODE_BACKWARD1</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cv</span> <span class="main">=</span> <span class="main">(</span><span class="entity">atomize_conj_cv</span> true<span class="main">)</span>
                       then_conv <span class="main">(</span>Conv.rewr_conv <span class="entity">UtilBase.backward1_conv_th</span><span class="main">)</span>
                       then_conv <span class="main">(</span><span class="entity">horn_conv</span> <span class="entity">try_nn_cancel_cv</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="entity">th</span> |&gt; <span class="entity">apply_to_thm</span> <span class="main">(</span><span class="entity">Util.skip_n_conv</span> <span class="entity">side_count</span> <span class="entity">cv</span><span class="main">)</span>
             |&gt; <span class="entity">Util.update_name_of_thm</span> <span class="entity">th</span> <span class="inner_quoted">"@back1"</span>
        <span class="keyword2"><span class="keyword">end</span></span>
      <span class="main">|</span> <span class="entity">MODE_BACKWARD2</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cv</span> <span class="main">=</span> <span class="main">(</span>Conv.arg_conv <span class="main">(</span><span class="entity">atomize_conj_cv</span> false<span class="main">)</span><span class="main">)</span>
                       then_conv <span class="main">(</span>Conv.rewr_conv <span class="entity">UtilBase.backward2_conv_th</span><span class="main">)</span>
                       then_conv <span class="main">(</span><span class="entity">horn_conv</span> <span class="entity">try_nn_cancel_cv</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="entity">th</span> |&gt; <span class="entity">apply_to_thm</span> <span class="main">(</span><span class="entity">Util.skip_n_conv</span> <span class="entity">side_count</span> <span class="entity">cv</span><span class="main">)</span>
             |&gt; <span class="entity">Util.update_name_of_thm</span> <span class="entity">th</span> <span class="inner_quoted">"@back2"</span>
        <span class="keyword2"><span class="keyword">end</span></span>
      <span class="main">|</span> <span class="entity">MODE_RESOLVE</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rewr_th</span> <span class="main">=</span>
              <span class="keyword2"><span class="keyword">case</span></span> Thm.nprems_of <span class="entity">th</span> - <span class="entity">side_count</span> <span class="keyword2"><span class="keyword">of</span></span>
                  <span class="inner_numeral">0</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_neg</span> <span class="main">(</span><span class="entity">concl_of'</span> <span class="entity">th</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">UtilBase.to_contra_form_th'</span>
                       <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">UtilBase.to_contra_form_th</span>
                <span class="main">|</span> <span class="inner_numeral">1</span> <span class="main">=&gt;</span> <span class="entity">UtilBase.resolve_conv_th</span>
                <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"resolve: too many hypothesis in th."</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cv</span> <span class="main">=</span> <span class="main">(</span>Conv.rewr_conv <span class="entity">rewr_th</span><span class="main">)</span>
                       then_conv <span class="main">(</span><span class="entity">horn_conv</span> <span class="entity">try_nn_cancel_cv</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="entity">th</span> |&gt; <span class="entity">apply_to_thm</span> <span class="main">(</span><span class="entity">Util.skip_n_conv</span> <span class="entity">side_count</span> <span class="entity">cv</span><span class="main">)</span>
             |&gt; <span class="entity">Util.update_name_of_thm</span> <span class="entity">th</span> <span class="inner_quoted">"@res"</span>
        <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Add basic proofstep for the given theorem and mode. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_basic_prfstep_cond</span> <span class="entity">th</span> <span class="entity">mode</span> <span class="entity">conds</span> <span class="entity">thy</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt</span> <span class="main">=</span> Proof_Context.init_global <span class="entity">thy</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt'</span> <span class="main">=</span> <span class="entity">ctxt</span> |&gt; Variable.declare_term <span class="main">(</span>Thm.prop_of <span class="entity">th</span><span class="main">)</span>

      <span class="comment1">(* Replace variable definitions, obtaining list of replacements
         and the new theorem.
       *)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">pairs</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=</span>
          <span class="entity">th</span> |&gt; <span class="entity">apply_to_thm</span> <span class="main">(</span><span class="entity">UtilLogic.to_obj_conv_on_horn</span> <span class="entity">ctxt'</span><span class="main">)</span>
             |&gt; <span class="entity">Normalizer.meta_use_vardefs</span>
             |&gt; apsnd <span class="main">(</span><span class="entity">Util.update_name_of_thm</span> <span class="entity">th</span> <span class="inner_quoted">""</span><span class="main">)</span>

      <span class="comment1">(* List of definitions used. *)</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">print_def_subst</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="main">=</span>
          writeln <span class="main">(</span><span class="inner_quoted">"Apply def "</span> ^ <span class="main">(</span>Syntax.string_of_term <span class="entity">ctxt'</span> <span class="entity">lhs</span><span class="main">)</span> ^ <span class="inner_quoted">" = "</span> ^
                   <span class="main">(</span>Syntax.string_of_term <span class="entity">ctxt'</span> <span class="entity">rhs</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> map <span class="entity">print_def_subst</span> <span class="entity">pairs</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">def_subst_fun</span> <span class="entity">cond</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">cond</span> <span class="keyword2"><span class="keyword">of</span></span>
              <span class="entity">WithItem</span> <span class="main">(</span><span class="inner_quoted">"TERM"</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span> <span class="main">=&gt;</span>
              <span class="entity">WithItem</span> <span class="main">(</span><span class="inner_quoted">"TERM"</span><span class="main">,</span> <span class="entity">Normalizer.def_subst</span> <span class="entity">pairs</span> <span class="entity">t</span><span class="main">)</span>
            <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">cond</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">conds</span> <span class="keyword1"><span class="keyword">andalso</span></span>
         <span class="main">(</span><span class="entity">mode</span> <span class="main">=</span> <span class="entity">MODE_FORWARD</span> <span class="keyword1"><span class="keyword">orelse</span></span> <span class="entity">mode</span> <span class="main">=</span> <span class="entity">MODE_FORWARD'</span><span class="main">)</span> <span class="keyword1"><span class="keyword">andalso</span></span>
         <span class="entity">Property.can_add_property_update</span> <span class="entity">th</span> <span class="entity">thy</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="entity">Property.add_property_update</span> <span class="entity">th</span> <span class="entity">thy</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_term_cond</span> <span class="entity">cond</span> <span class="main">=</span>
            <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">cond</span> <span class="keyword2"><span class="keyword">of</span></span> <span class="entity">WithItem</span> <span class="main">(</span><span class="inner_quoted">"TERM"</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> true <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false

        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">extract_term_cond</span> <span class="entity">cond</span> <span class="main">=</span>
            <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">cond</span> <span class="keyword2"><span class="keyword">of</span></span>
                <span class="entity">WithItem</span> <span class="main">(</span><span class="inner_quoted">"TERM"</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">t</span> <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"extract_term_cond"</span>

        <span class="comment1">(* Instantiate each element of conds with ctxt', then separate
           into term and other (filter and shadow) conds.
         *)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">term_conds</span><span class="main">,</span> <span class="entity">filt_conds</span><span class="main">)</span> <span class="main">=</span>
            <span class="entity">conds</span> |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">cond</span> <span class="main">=&gt;</span> <span class="entity">cond</span> <span class="entity">ctxt'</span><span class="main">)</span>
                  |&gt; <span class="entity">filter_split</span> <span class="entity">is_term_cond</span>
                  |&gt; apfst <span class="main">(</span>map <span class="entity">def_subst_fun</span><span class="main">)</span>

        <span class="comment1">(* Get list of assumptions to be obtained from either the
           property table or the wellform table.
         *)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ts</span> <span class="main">=</span> map <span class="entity">extract_term_cond</span> <span class="entity">term_conds</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">side_prems</span> <span class="main">=</span> <span class="entity">get_side_prems</span> <span class="entity">thy</span> <span class="entity">mode</span> <span class="entity">ts</span> <span class="entity">th</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">side_count</span> <span class="main">=</span> length <span class="entity">side_prems</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th'</span> <span class="main">=</span> <span class="entity">th</span> |&gt; <span class="entity">post_process_th</span> <span class="entity">ctxt'</span> <span class="entity">mode</span> <span class="entity">side_count</span> <span class="entity">ts</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">assums</span><span class="main">,</span> <span class="entity">concl</span><span class="main">)</span> <span class="main">=</span>
            <span class="entity">th'</span> |&gt; <span class="entity">UtilLogic.strip_horn'</span> |&gt; apfst <span class="main">(</span>drop <span class="entity">side_count</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pats</span> <span class="main">=</span> map <span class="entity">extract_term_cond</span> <span class="entity">term_conds</span> @ <span class="entity">assums</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">match_descs</span> <span class="main">=</span> <span class="entity">term_conds</span> @ map <span class="entity">WithFact</span> <span class="entity">assums</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span><span class="entity">Util.is_pattern_list</span> <span class="entity">pats</span><span class="main">)</span>
                       <span class="inner_quoted">"add_basic_prfstep: invalid patterns."</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span>length <span class="entity">pats</span> &gt; <span class="inner_numeral">0</span> <span class="keyword1"><span class="keyword">andalso</span></span> length <span class="entity">pats</span> &lt;= <span class="inner_numeral">2</span><span class="main">)</span>
                       <span class="inner_quoted">"add_basic_prfstep: invalid number of patterns."</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="comment1">(* Switch two assumptions if necessary. *)</span>
        <span class="keyword2"><span class="keyword">if</span></span> length <span class="entity">pats</span> <span class="main">=</span> <span class="inner_numeral">2</span> <span class="keyword1"><span class="keyword">andalso</span></span> not <span class="main">(</span><span class="entity">Util.is_pattern</span> <span class="main">(</span>hd <span class="entity">pats</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> writeln <span class="inner_quoted">"Switching two patterns."</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">swap_prems_cv</span> <span class="main">=</span> Conv.rewr_conv Drule.swap_prems_eq
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th''</span> <span class="main">=</span>
                <span class="keyword2"><span class="keyword">if</span></span> length <span class="entity">assums</span> <span class="main">=</span> <span class="inner_numeral">1</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">th'</span>
                <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">th'</span> |&gt; <span class="entity">apply_to_thm</span> <span class="main">(</span><span class="entity">Util.skip_n_conv</span> <span class="entity">side_count</span> <span class="entity">swap_prems_cv</span><span class="main">)</span>
                         |&gt; <span class="entity">Util.update_name_of_thm</span> <span class="entity">th'</span> <span class="inner_quoted">""</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">swap_match_descs</span> <span class="main">=</span> <span class="main">[</span>nth <span class="entity">match_descs</span> <span class="inner_numeral">1</span><span class="main">,</span> hd <span class="entity">match_descs</span><span class="main">]</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">descs</span> <span class="main">=</span> <span class="entity">side_prems</span> @ <span class="entity">swap_match_descs</span> @ <span class="entity">filt_conds</span> @
                        <span class="main">[</span><span class="entity">GetFact</span> <span class="main">(</span><span class="entity">concl</span><span class="main">,</span> <span class="entity">th''</span><span class="main">)</span><span class="main">]</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="entity">add_and_print_prfstep</span> <span class="main">(</span><span class="entity">Util.name_of_thm</span> <span class="entity">th'</span><span class="main">)</span> <span class="entity">descs</span> <span class="entity">thy</span>
          <span class="keyword2"><span class="keyword">end</span></span>
        <span class="keyword2"><span class="keyword">else</span></span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">descs</span> <span class="main">=</span> <span class="entity">side_prems</span> @ <span class="entity">match_descs</span> @ <span class="entity">filt_conds</span> @
                        <span class="main">[</span><span class="entity">GetFact</span> <span class="main">(</span><span class="entity">concl</span><span class="main">,</span> <span class="entity">th'</span><span class="main">)</span><span class="main">]</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="entity">add_and_print_prfstep</span> <span class="main">(</span><span class="entity">Util.name_of_thm</span> <span class="entity">th'</span><span class="main">)</span> <span class="entity">descs</span> <span class="entity">thy</span>
          <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_forward_prfstep_cond</span> <span class="entity">th</span> <span class="main">=</span> <span class="entity">add_basic_prfstep_cond</span> <span class="entity">th</span> <span class="entity">MODE_FORWARD</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_forward'_prfstep_cond</span> <span class="entity">th</span> <span class="main">=</span> <span class="entity">add_basic_prfstep_cond</span> <span class="entity">th</span> <span class="entity">MODE_FORWARD'</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_backward_prfstep_cond</span> <span class="entity">th</span> <span class="main">=</span> <span class="entity">add_basic_prfstep_cond</span> <span class="entity">th</span> <span class="entity">MODE_BACKWARD</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_backward1_prfstep_cond</span> <span class="entity">th</span> <span class="main">=</span> <span class="entity">add_basic_prfstep_cond</span> <span class="entity">th</span> <span class="entity">MODE_BACKWARD1</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_backward2_prfstep_cond</span> <span class="entity">th</span> <span class="main">=</span> <span class="entity">add_basic_prfstep_cond</span> <span class="entity">th</span> <span class="entity">MODE_BACKWARD2</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_resolve_prfstep_cond</span> <span class="entity">th</span> <span class="main">=</span> <span class="entity">add_basic_prfstep_cond</span> <span class="entity">th</span> <span class="entity">MODE_RESOLVE</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_forward_prfstep</span> <span class="entity">th</span> <span class="main">=</span> <span class="entity">add_forward_prfstep_cond</span> <span class="entity">th</span> <span class="main">[</span><span class="main">]</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_forward'_prfstep</span> <span class="entity">th</span> <span class="main">=</span> <span class="entity">add_forward'_prfstep_cond</span> <span class="entity">th</span> <span class="main">[</span><span class="main">]</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_backward_prfstep</span> <span class="entity">th</span> <span class="main">=</span> <span class="entity">add_backward_prfstep_cond</span> <span class="entity">th</span> <span class="main">[</span><span class="main">]</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_backward1_prfstep</span> <span class="entity">th</span> <span class="main">=</span> <span class="entity">add_backward1_prfstep_cond</span> <span class="entity">th</span> <span class="main">[</span><span class="main">]</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_backward2_prfstep</span> <span class="entity">th</span> <span class="main">=</span> <span class="entity">add_backward2_prfstep_cond</span> <span class="entity">th</span> <span class="main">[</span><span class="main">]</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_resolve_prfstep</span> <span class="entity">th</span> <span class="main">=</span> <span class="entity">add_resolve_prfstep_cond</span> <span class="entity">th</span> <span class="main">[</span><span class="main">]</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_rewrite_eq_rule_cond</span> <span class="entity">th</span> <span class="entity">conds</span> <span class="entity">thy</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">Util.is_meta_eq</span> <span class="main">(</span>Thm.concl_of <span class="entity">th</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
                 <span class="entity">UtilLogic.to_obj_eq_th</span> <span class="entity">th</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">th</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">th</span> |&gt; <span class="entity">concl_of'</span> |&gt; <span class="entity">strip_conj</span> |&gt; hd |&gt; <span class="entity">dest_eq</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">thy</span> |&gt; <span class="entity">add_forward_prfstep_cond</span> <span class="entity">th</span> <span class="main">(</span>K <span class="main">(</span><span class="entity">WithTerm</span> <span class="entity">lhs</span><span class="main">)</span> :: <span class="entity">conds</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_rewrite_iff_rule_cond</span> <span class="entity">th</span> <span class="entity">conds</span> <span class="entity">thy</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">Util.is_meta_eq</span> <span class="main">(</span>Thm.concl_of <span class="entity">th</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
                 <span class="entity">UtilLogic.to_obj_eq_iff_th</span> <span class="entity">th</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">th</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">th</span> |&gt; <span class="entity">concl_of'</span> |&gt; <span class="entity">dest_eq</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span>fastype_of <span class="entity">lhs</span> <span class="main">=</span> <span class="entity">boolT</span><span class="main">)</span>
                     <span class="inner_quoted">"add_rewrite_iff: argument not of type bool."</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">forward_th</span> <span class="main">=</span> <span class="entity">th</span> |&gt; <span class="entity">equiv_forward_th</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">nforward_th</span> <span class="main">=</span> <span class="entity">th</span> |&gt; <span class="entity">inv_backward_th</span>
                           |&gt; <span class="entity">apply_to_thm</span> <span class="main">(</span><span class="entity">horn_conv</span> <span class="entity">try_nn_cancel_cv</span><span class="main">)</span>
                           |&gt; <span class="entity">Util.update_name_of_thm</span> <span class="entity">th</span> <span class="inner_quoted">"@invbackward"</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">thy</span> |&gt; <span class="entity">add_basic_prfstep_cond</span> <span class="entity">forward_th</span> <span class="entity">MODE_FORWARD'</span> <span class="entity">conds</span>
          |&gt; <span class="entity">add_basic_prfstep_cond</span> <span class="entity">nforward_th</span> <span class="entity">MODE_FORWARD'</span> <span class="entity">conds</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_rewrite_rule_cond</span> <span class="entity">th</span> <span class="entity">conds</span> <span class="entity">thy</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">Util.is_meta_eq</span> <span class="main">(</span>Thm.concl_of <span class="entity">th</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">to_obj_eq_th</span> <span class="entity">th</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">th</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">th</span> |&gt; <span class="entity">concl_of'</span> |&gt; <span class="entity">strip_conj</span> |&gt; hd |&gt; <span class="entity">dest_eq</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> fastype_of <span class="entity">lhs</span> <span class="main">=</span> <span class="entity">boolT</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="entity">add_rewrite_iff_rule_cond</span> <span class="entity">th</span> <span class="entity">conds</span> <span class="entity">thy</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="entity">add_rewrite_eq_rule_cond</span> <span class="entity">th</span> <span class="entity">conds</span> <span class="entity">thy</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_rewrite_rule_back_cond</span> <span class="entity">th</span> <span class="entity">conds</span> <span class="main">=</span>
    <span class="entity">add_rewrite_rule_cond</span> <span class="main">(</span><span class="entity">obj_sym_th</span> <span class="entity">th</span><span class="main">)</span> <span class="entity">conds</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_rewrite_rule_bidir_cond</span> <span class="entity">th</span> <span class="entity">conds</span> <span class="main">=</span>
    <span class="main">(</span><span class="entity">add_rewrite_rule_cond</span> <span class="entity">th</span> <span class="entity">conds</span><span class="main">)</span>
        #&gt; <span class="entity">add_rewrite_rule_back_cond</span> <span class="entity">th</span> <span class="entity">conds</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_rewrite_rule</span> <span class="entity">th</span> <span class="main">=</span> <span class="entity">add_rewrite_rule_cond</span> <span class="entity">th</span> <span class="main">[</span><span class="main">]</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_rewrite_rule_back</span> <span class="entity">th</span> <span class="main">=</span> <span class="entity">add_rewrite_rule_back_cond</span> <span class="entity">th</span> <span class="main">[</span><span class="main">]</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_rewrite_rule_bidir</span> <span class="entity">th</span> <span class="main">=</span> <span class="entity">add_rewrite_rule</span> <span class="entity">th</span> #&gt; <span class="entity">add_rewrite_rule_back</span> <span class="entity">th</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">setup_attrib</span> <span class="entity">f</span> <span class="main">=</span>
    <span class="entity">Attrib.add_del</span>
        <span class="main">(</span>Thm.declaration_attribute <span class="main">(</span>
            <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">th</span> <span class="main">=&gt;</span> Context.mapping <span class="main">(</span><span class="entity">f</span> <span class="entity">th</span><span class="main">)</span> I<span class="main">)</span><span class="main">)</span>
        <span class="main">(</span>Thm.declaration_attribute <span class="main">(</span>
            <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"del_step: not implemented."</span><span class="main">)</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>  <span class="comment1">(* structure ProofStepData. *)</span>

<span class="keyword3"><span class="keyword">open</span></span> <span class="entity">ProofStepData</span>
</pre>
</div><div id="files/AFP/Auto2_HOL/auto2_state.ML">
<div class="head">
<h1>File ‹$AFP/Auto2_HOL/auto2_state.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*
  File: auto2_state.ML
  Author: Bohua Zhan

  Data structure containing auto2's state for the proof language.
*)</span>

<span class="comment1">(* The state consists of a stack of frames. *)</span>
<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">auto2_frame</span> <span class="main">=</span> <span class="main">{</span>
  <span class="comment1">(* List of subgoals in the current frame. Each element is of the
     form (pat, th), where pat is the pattern used to select the
     subgoal, and th is the subgoal itself.
   *)</span>
  goals<span class="main">:</span> <span class="main">(</span>term * thm<span class="main">)</span> list<span class="main">,</span>

  <span class="comment1">(* Index of the currently selected subgoal. *)</span>
  selected<span class="main">:</span> int option<span class="main">,</span>

  <span class="comment1">(* Possible induction statement. *)</span>
  induct_stmt<span class="main">:</span> term option<span class="main">,</span>

  <span class="comment1">(* List of forall statements that should only be matched to premises
     of theorems (not in disj_match_update).
   *)</span>
  prem_only<span class="main">:</span> term list<span class="main">,</span>

  <span class="comment1">(* Callback after all subgoals are resolved. This is a pair (vars,
     f), where vars is a list of new variables, and f is the function
     that, given the list of solved subgoals as theorems, performs a
     modification on the current subgoal.
   *)</span>
  after_qed<span class="main">:</span> <span class="main">(</span>term list * <span class="main">(</span>thm list <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm<span class="main">)</span><span class="main">)</span> option
<span class="main">}</span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">auto2_state</span> <span class="main">=</span> <span class="entity">auto2_frame</span> list

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">AUTO2_STATE</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> print_state<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> unit
  <span class="keyword1"><span class="keyword">val</span></span> get_num_frame<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> int
  <span class="keyword1"><span class="keyword">val</span></span> pop_head<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span>
  <span class="keyword1"><span class="keyword">val</span></span> push_head<span class="main">:</span> <span class="entity">auto2_frame</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span>
  <span class="keyword1"><span class="keyword">val</span></span> simple_frame<span class="main">:</span>
      cterm * <span class="main">(</span>term list * <span class="main">(</span>thm list <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm<span class="main">)</span><span class="main">)</span> option <span class="main">-&gt;</span> <span class="entity">auto2_frame</span>
  <span class="keyword1"><span class="keyword">val</span></span> multiple_frame<span class="main">:</span>
      <span class="main">(</span>term * cterm<span class="main">)</span> list * <span class="main">(</span>term list * <span class="main">(</span>thm list <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm<span class="main">)</span><span class="main">)</span> option <span class="main">-&gt;</span>
      <span class="entity">auto2_frame</span>
  <span class="keyword1"><span class="keyword">val</span></span> map_head_th<span class="main">:</span> <span class="main">(</span>thm <span class="main">-&gt;</span> thm<span class="main">)</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span>
  <span class="keyword1"><span class="keyword">val</span></span> set_selected<span class="main">:</span> int option <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span>
  <span class="keyword1"><span class="keyword">val</span></span> set_induct_stmt<span class="main">:</span> term <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_last_induct_stmt<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term option
  <span class="keyword1"><span class="keyword">val</span></span> add_prem_only<span class="main">:</span> term <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span>
  <span class="keyword1"><span class="keyword">val</span></span> lookup_prem_only<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> get_top_frame<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">auto2_frame</span>
  <span class="keyword1"><span class="keyword">val</span></span> get_selected<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> get_subgoal<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Auto2_State</span> <span class="main">:</span> <span class="entity">AUTO2_STATE</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Data</span> <span class="main">=</span> Proof_Data
<span class="main">(</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">T</span> <span class="main">=</span> <span class="entity">auto2_state</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">init</span> <span class="main">_</span> <span class="main">=</span> <span class="main">[</span><span class="main">]</span>
<span class="main">)</span>

<span class="comment1">(* Print the auto2 state. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">string_of_frame</span> <span class="entity">ctxt</span> <span class="entity">frame</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">goals</span><span class="main">,</span> <span class="entity">selected</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">frame</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">n</span> <span class="main">=</span> length <span class="entity">goals</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">print_i</span> <span class="main">(</span><span class="entity">i</span><span class="main">,</span> <span class="main">(</span><span class="entity">pat</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
          <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">selected</span> <span class="main">=</span> SOME <span class="entity">i</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="inner_quoted">"*"</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="inner_quoted">" "</span><span class="main">)</span> ^
          <span class="main">(</span><span class="entity">pat</span> |&gt; Syntax.string_of_term <span class="entity">ctxt</span><span class="main">)</span> ^ <span class="inner_quoted">": "</span> ^
          <span class="main">(</span><span class="entity">th</span> |&gt; Thm.prop_of |&gt; Syntax.string_of_term <span class="entity">ctxt</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">n</span> <span class="main">=</span> <span class="inner_numeral">1</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="entity">goals</span> |&gt; the_single |&gt; snd |&gt; Thm.prop_of |&gt; Syntax.string_of_term <span class="entity">ctxt</span>
      <span class="keyword2"><span class="keyword">else</span></span> cat_lines <span class="main">(</span>map <span class="entity">print_i</span> <span class="main">(</span><span class="inner_numeral">0</span> upto <span class="main">(</span><span class="entity">n</span> - <span class="inner_numeral">1</span><span class="main">)</span> ~~ <span class="entity">goals</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">string_of_state</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">frames</span> <span class="main">=</span> Data.get <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> tracing <span class="main">(</span><span class="inner_quoted">"Auto2 state. Number of frames is "</span> ^
                       <span class="main">(</span>string_of_int <span class="main">(</span>length <span class="entity">frames</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      cat_lines <span class="main">(</span>map <span class="main">(</span><span class="entity">string_of_frame</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">frames</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">print_state</span> <span class="entity">ctxt</span> <span class="main">=</span> tracing <span class="main">(</span><span class="entity">string_of_state</span> <span class="entity">ctxt</span><span class="main">)</span>

<span class="comment1">(* Number of frames in the current state. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_num_frame</span> <span class="entity">ctxt</span> <span class="main">=</span> length <span class="main">(</span>Data.get <span class="entity">ctxt</span><span class="main">)</span>

<span class="comment1">(* Remove the top-most frame of the state. *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pop_head</span> <span class="main">=</span>
    Data.map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">frames</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">frames</span> <span class="keyword2"><span class="keyword">of</span></span>
                               <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> error <span class="inner_quoted">"pop_head"</span>
                             <span class="main">|</span> <span class="main">_</span> :: <span class="entity">rest</span> <span class="main">=&gt;</span> <span class="entity">rest</span><span class="main">)</span>

<span class="comment1">(* Push a head layer of auto2 state. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">push_head</span> <span class="entity">frame</span> <span class="main">=</span>
    Data.map <span class="main">(</span>cons <span class="entity">frame</span><span class="main">)</span>

<span class="comment1">(* Create a frame with a single goal, with statement ct. Note the
   resulting pair is (ct, ct ==&gt; (ct)).
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">simple_frame</span> <span class="main">(</span><span class="entity">ct</span><span class="main">,</span> <span class="entity">after_qed</span><span class="main">)</span> <span class="main">=</span>
    <span class="main">{</span>goals <span class="main">=</span> <span class="main">[</span><span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">,</span> Goal.protect <span class="inner_numeral">1</span> <span class="main">(</span>Thm.trivial <span class="entity">ct</span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">,</span>
     selected <span class="main">=</span> SOME <span class="inner_numeral">0</span><span class="main">,</span> induct_stmt <span class="main">=</span> NONE<span class="main">,</span> prem_only <span class="main">=</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span>
     after_qed <span class="main">=</span> <span class="entity">after_qed</span><span class="main">}</span>

<span class="comment1">(* Create a frame with multiple goals. Here the input is a list of
   (pat, ct) pairs. The goals are (pat, ct ==&gt; (ct)) pairs.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">multiple_frame</span> <span class="main">(</span><span class="entity">goals</span><span class="main">,</span> <span class="entity">after_qed</span><span class="main">)</span> <span class="main">=</span>
    <span class="main">{</span>goals <span class="main">=</span> map <span class="main">(</span>apsnd <span class="main">(</span>Goal.protect <span class="inner_numeral">1</span> o Thm.trivial<span class="main">)</span><span class="main">)</span> <span class="entity">goals</span><span class="main">,</span>
     selected <span class="main">=</span> NONE<span class="main">,</span> induct_stmt <span class="main">=</span> NONE<span class="main">,</span> prem_only <span class="main">=</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span> after_qed <span class="main">=</span> <span class="entity">after_qed</span><span class="main">}</span>

<span class="comment1">(* Modify the top frame of the auto2 state. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map_head</span> <span class="entity">f</span> <span class="main">=</span>
    Data.map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">frames</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">frames</span> <span class="keyword2"><span class="keyword">of</span></span>
                               <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> error <span class="inner_quoted">"map_head"</span>
                             <span class="main">|</span> <span class="entity">frame</span> :: <span class="entity">rest</span> <span class="main">=&gt;</span> <span class="entity">f</span> <span class="entity">frame</span> :: <span class="entity">rest</span><span class="main">)</span>

<span class="comment1">(* Modify the selected subgoal. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map_head_th</span> <span class="entity">f</span> <span class="main">=</span>
    <span class="entity">map_head</span> <span class="main">(</span>
      <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span><span class="entity">goals</span><span class="main">,</span> <span class="entity">selected</span><span class="main">,</span> <span class="entity">induct_stmt</span><span class="main">,</span> <span class="entity">prem_only</span><span class="main">,</span> <span class="entity">after_qed</span><span class="main">}</span> <span class="main">=&gt;</span>
         <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">selected</span> <span class="keyword2"><span class="keyword">of</span></span>
             NONE <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"map_frame_th: no proposition selected"</span>
           <span class="main">|</span> SOME <span class="entity">i</span> <span class="main">=&gt;</span>
             <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">i</span> &lt; <span class="inner_numeral">0</span> <span class="keyword1"><span class="keyword">orelse</span></span> <span class="entity">i</span> &gt;= length <span class="entity">goals</span> <span class="keyword2"><span class="keyword">then</span></span>
               <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"map_frame_th: unexpected selected"</span>
             <span class="keyword2"><span class="keyword">else</span></span>
               <span class="main">{</span>goals <span class="main">=</span> nth_map <span class="entity">i</span> <span class="main">(</span>apsnd <span class="entity">f</span><span class="main">)</span> <span class="entity">goals</span><span class="main">,</span>
                selected <span class="main">=</span> <span class="entity">selected</span><span class="main">,</span> induct_stmt <span class="main">=</span> <span class="entity">induct_stmt</span><span class="main">,</span>
                prem_only <span class="main">=</span> <span class="entity">prem_only</span><span class="main">,</span> after_qed <span class="main">=</span> <span class="entity">after_qed</span><span class="main">}</span><span class="main">)</span>

<span class="comment1">(* Set selected subgoal. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">set_selected</span> <span class="entity">sel</span> <span class="main">=</span>
    <span class="entity">map_head</span> <span class="main">(</span>
      <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span><span class="entity">goals</span><span class="main">,</span> <span class="entity">induct_stmt</span><span class="main">,</span> <span class="entity">prem_only</span><span class="main">,</span> <span class="entity">after_qed</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
         <span class="main">{</span>goals <span class="main">=</span> <span class="entity">goals</span><span class="main">,</span> selected <span class="main">=</span> <span class="entity">sel</span><span class="main">,</span> induct_stmt <span class="main">=</span> <span class="entity">induct_stmt</span><span class="main">,</span>
          prem_only <span class="main">=</span> <span class="entity">prem_only</span><span class="main">,</span> after_qed <span class="main">=</span> <span class="entity">after_qed</span><span class="main">}</span><span class="main">)</span>

<span class="comment1">(* Set induction statement. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">set_induct_stmt</span> <span class="entity">stmt</span> <span class="main">=</span>
    <span class="entity">map_head</span> <span class="main">(</span>
      <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span><span class="entity">goals</span><span class="main">,</span> <span class="entity">selected</span><span class="main">,</span> <span class="entity">prem_only</span><span class="main">,</span> <span class="entity">after_qed</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
         <span class="main">{</span>goals <span class="main">=</span> <span class="entity">goals</span><span class="main">,</span> selected <span class="main">=</span> <span class="entity">selected</span><span class="main">,</span> induct_stmt <span class="main">=</span> SOME <span class="entity">stmt</span><span class="main">,</span>
          prem_only <span class="main">=</span> <span class="entity">prem_only</span><span class="main">,</span> after_qed <span class="main">=</span> <span class="entity">after_qed</span><span class="main">}</span><span class="main">)</span>

<span class="comment1">(* Return the last induction statement. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_last_induct_stmt</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">frames</span> <span class="main">=</span> Data.get <span class="entity">ctxt</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      get_first <span class="main">#</span>induct_stmt <span class="main">(</span>rev <span class="entity">frames</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Add a statement as matching with premise only. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_prem_only</span> <span class="entity">stmt</span> <span class="main">=</span>
    <span class="entity">map_head</span> <span class="main">(</span>
      <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span><span class="entity">goals</span><span class="main">,</span> <span class="entity">selected</span><span class="main">,</span> <span class="entity">induct_stmt</span><span class="main">,</span> <span class="entity">prem_only</span><span class="main">,</span> <span class="entity">after_qed</span><span class="main">}</span> <span class="main">=&gt;</span>
         <span class="main">{</span>goals <span class="main">=</span> <span class="entity">goals</span><span class="main">,</span> selected <span class="main">=</span> <span class="entity">selected</span><span class="main">,</span> induct_stmt <span class="main">=</span> <span class="entity">induct_stmt</span><span class="main">,</span>
          prem_only <span class="main">=</span> <span class="entity">stmt</span> :: <span class="entity">prem_only</span><span class="main">,</span> after_qed <span class="main">=</span> <span class="entity">after_qed</span><span class="main">}</span><span class="main">)</span>

<span class="comment1">(* Check whether a statement is matching with premise only. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">lookup_prem_only</span> <span class="entity">ctxt</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prem_only</span> <span class="main">=</span> maps <span class="main">#</span>prem_only <span class="main">(</span>Data.get <span class="entity">ctxt</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      member <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv<span class="main">)</span> <span class="entity">prem_only</span> <span class="entity">t</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Return the top frame of the state. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_top_frame</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> Data.get <span class="entity">ctxt</span> <span class="keyword2"><span class="keyword">of</span></span>
      <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"Auto2 proof should start with @begin keyword"</span>
    <span class="main">|</span> <span class="entity">st</span> :: <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">st</span>

<span class="comment1">(* Return the goal theorem (of the form A ==&gt; (C)). *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_selected</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">goals</span><span class="main">,</span> <span class="entity">selected</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">get_top_frame</span> <span class="entity">ctxt</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">selected</span> <span class="keyword2"><span class="keyword">of</span></span>
          NONE <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"get_selected: no goal is selected."</span>
        <span class="main">|</span> SOME <span class="entity">i</span> <span class="main">=&gt;</span> snd <span class="main">(</span>nth <span class="entity">goals</span> <span class="entity">i</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Return the current subgoal. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_subgoal</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="entity">ctxt</span> |&gt; <span class="entity">get_selected</span> |&gt; Thm.prems_of |&gt; the_single
    <span class="keyword3"><span class="keyword">handle</span></span> List.Empty <span class="main">=&gt;</span> error <span class="inner_quoted">"get_subgoal: should have exactly one premise."</span>

<span class="keyword2"><span class="keyword">end</span></span>  <span class="comment1">(* structure Auto2_State *)</span>
</pre>
</div><div id="files/AFP/Auto2_HOL/logic_steps.ML">
<div class="head">
<h1>File ‹$AFP/Auto2_HOL/logic_steps.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*
  File: logic_steps.ML
  Author: Bohua Zhan

  Core (logic) proofsteps.
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">LOGIC_PROOFSTEPS</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="comment1">(* General logic *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> shadow_prop_item<span class="main">:</span> <span class="entity">proofstep</span>
  <span class="keyword1"><span class="keyword">val</span></span> shadow_term_item<span class="main">:</span> <span class="entity">proofstep</span>

  <span class="keyword1"><span class="keyword">val</span></span> exists_elim_prfstep<span class="main">:</span> <span class="entity">proofstep</span>
  <span class="keyword1"><span class="keyword">val</span></span> add_logic_proofsteps<span class="main">:</span> theory <span class="main">-&gt;</span> theory

  <span class="keyword1"><span class="keyword">val</span></span> mk_all_disj<span class="main">:</span> term list * term list <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> strip_all_disj<span class="main">:</span> term <span class="main">-&gt;</span> term list * term list
  <span class="keyword1"><span class="keyword">val</span></span> norm_all_disj<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> conv
  <span class="keyword1"><span class="keyword">val</span></span> replace_disj_vars<span class="main">:</span>
      <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term list * term list <span class="main">-&gt;</span> term list * term list
  <span class="keyword1"><span class="keyword">val</span></span> disj_prop_match<span class="main">:</span>
      <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">id_inst</span> <span class="main">-&gt;</span>
      term * <span class="main">(</span>term list * term list<span class="main">)</span> * <span class="main">(</span><span class="main">(</span>indexname * typ<span class="main">)</span> list * cterm list<span class="main">)</span> <span class="main">-&gt;</span>
      <span class="entity">id_inst_th</span> list
  <span class="keyword1"><span class="keyword">val</span></span> norm_conj<span class="main">:</span> conv

  <span class="comment1">(* DISJ items. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> TY_DISJ<span class="main">:</span> string
  <span class="keyword1"><span class="keyword">val</span></span> disj_to_ritems<span class="main">:</span> bool <span class="main">-&gt;</span> term <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> <span class="entity">raw_item</span> list
  <span class="keyword1"><span class="keyword">val</span></span> disj_to_update<span class="main">:</span> bool <span class="main">-&gt;</span> term <span class="main">-&gt;</span> <span class="entity">box_id</span> * int option * thm <span class="main">-&gt;</span> <span class="entity">raw_update</span>
  <span class="keyword1"><span class="keyword">val</span></span> dest_tname_of_disj<span class="main">:</span> cterm list <span class="main">-&gt;</span> term * cterm list
  <span class="keyword1"><span class="keyword">val</span></span> is_match_prem_only<span class="main">:</span> <span class="entity">box_item</span> <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> analyze_disj_th<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> term * thm
  <span class="keyword1"><span class="keyword">val</span></span> disj_rewr_terms<span class="main">:</span> term list <span class="main">-&gt;</span> term list
  <span class="keyword1"><span class="keyword">val</span></span> output_disj_fn<span class="main">:</span> <span class="entity">item_output</span>
  <span class="keyword1"><span class="keyword">val</span></span> disj_prop_matcher<span class="main">:</span> <span class="entity">item_matcher</span>

  <span class="keyword1"><span class="keyword">val</span></span> reduce_disj_True<span class="main">:</span> conv
  <span class="keyword1"><span class="keyword">val</span></span> match_update_prfstep<span class="main">:</span> <span class="entity">proofstep</span>
  <span class="keyword1"><span class="keyword">val</span></span> match_one_sch_prfstep<span class="main">:</span> <span class="entity">proofstep</span>
  <span class="keyword1"><span class="keyword">val</span></span> disj_match_iff_prfstep<span class="main">:</span> <span class="entity">proofstep</span>
  <span class="keyword1"><span class="keyword">val</span></span> disj_create_case_prfstep<span class="main">:</span> <span class="entity">proofstep</span>
  <span class="keyword1"><span class="keyword">val</span></span> disj_shadow_prfstep<span class="main">:</span> <span class="entity">proofstep</span>
  <span class="keyword1"><span class="keyword">val</span></span> add_disj_proofsteps<span class="main">:</span> theory <span class="main">-&gt;</span> theory

  <span class="comment1">(* Normalizers *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> split_not_imp_th<span class="main">:</span> thm <span class="main">-&gt;</span> thm list
  <span class="keyword1"><span class="keyword">val</span></span> split_conj_gen_th<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm list
  <span class="keyword1"><span class="keyword">val</span></span> eq_normalizer<span class="main">:</span> <span class="entity">normalizer</span>
  <span class="keyword1"><span class="keyword">val</span></span> property_normalizer<span class="main">:</span> <span class="entity">normalizer</span>
  <span class="keyword1"><span class="keyword">val</span></span> disj_normalizer<span class="main">:</span> <span class="entity">normalizer</span>
  <span class="keyword1"><span class="keyword">val</span></span> logic_thm_update<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">box_id</span> * thm <span class="main">-&gt;</span> <span class="entity">raw_update</span>
  <span class="keyword1"><span class="keyword">val</span></span> add_disj_normalizers<span class="main">:</span> theory <span class="main">-&gt;</span> theory
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Logic_ProofSteps</span> <span class="main">:</span> <span class="entity">LOGIC_PROOFSTEPS</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">boolVar</span> <span class="entity">s</span> <span class="main">=</span> Var <span class="main">(</span><span class="main">(</span><span class="entity">s</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span><span class="main">,</span> <span class="entity">boolT</span><span class="main">)</span>

<span class="comment1">(* Shadowing based on equivalence. For both PROP and TERM items,
   shadowing is based on subterm equivalence, skipping any Not (~) at
   head.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">shadow_item_fn</span> <span class="entity">ctxt</span> <span class="entity">item1</span> <span class="entity">item2</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="main">#</span>sc <span class="entity">item1</span> <span class="main">=</span> <span class="inner_numeral">0</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="main">#</span>sc <span class="entity">item2</span> <span class="main">=</span> <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">id</span> <span class="main">=</span> <span class="entity">BoxItem.merged_id</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">item1</span><span class="main">,</span> <span class="entity">item2</span><span class="main">]</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span>forall <span class="main">(</span><span class="entity">BoxItem.match_ty_strs</span> <span class="main">[</span><span class="entity">TY_TERM</span><span class="main">,</span> <span class="entity">TY_PROP</span><span class="main">]</span><span class="main">)</span>
                             <span class="main">[</span><span class="entity">item1</span><span class="main">,</span> <span class="entity">item2</span><span class="main">]</span><span class="main">)</span>
                     <span class="inner_quoted">"shadow_item_fn"</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">tname1</span><span class="main">,</span> <span class="entity">tname2</span><span class="main">)</span> <span class="main">=</span>
          <span class="main">(</span>the_single <span class="main">(</span><span class="main">#</span>tname <span class="entity">item1</span><span class="main">)</span><span class="main">,</span> the_single <span class="main">(</span><span class="main">#</span>tname <span class="entity">item2</span><span class="main">)</span><span class="main">)</span>
          <span class="keyword3"><span class="keyword">handle</span></span> List.Empty <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"shadow_item_fn"</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Thm.term_of <span class="entity">tname1</span><span class="main">,</span> Thm.term_of <span class="entity">tname2</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">if</span></span> fastype_of <span class="entity">t1</span> <span class="main">=</span> <span class="entity">boolT</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_neg</span> <span class="entity">t1</span> <span class="keyword1"><span class="keyword">andalso</span></span>
             fastype_of <span class="entity">t2</span> <span class="main">=</span> <span class="entity">boolT</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_neg</span> <span class="entity">t2</span> <span class="keyword2"><span class="keyword">then</span></span>
            <span class="main">(</span><span class="entity">UtilLogic.get_cneg</span> <span class="entity">tname1</span><span class="main">,</span> <span class="entity">UtilLogic.get_cneg</span> <span class="entity">tname2</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">else</span></span>
            <span class="main">(</span><span class="entity">tname1</span><span class="main">,</span> <span class="entity">tname2</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">equiv_ids</span> <span class="main">=</span>
          <span class="main">(</span><span class="entity">RewriteTable.subequiv_info</span> <span class="entity">ctxt</span> <span class="entity">id</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span><span class="main">)</span>
              |&gt; map fst |&gt; filter <span class="entity">BoxID.has_incr_id</span>
              |&gt; <span class="entity">Util.max_partial</span> <span class="main">(</span><span class="entity">BoxID.is_eq_ancestor</span> <span class="entity">ctxt</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">item_to_shadow</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">if</span></span> <span class="main">#</span>uid <span class="entity">item1</span> &gt; <span class="main">#</span>uid <span class="entity">item2</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">item1</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">item2</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_id</span> <span class="entity">id'</span> <span class="main">=</span>
          <span class="entity">ShadowItem</span> <span class="main">{</span>id <span class="main">=</span> <span class="entity">id'</span><span class="main">,</span> item <span class="main">=</span> <span class="entity">item_to_shadow</span><span class="main">}</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      map <span class="entity">process_id</span> <span class="entity">equiv_ids</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">shadow_prop_item</span> <span class="main">=</span>
    <span class="main">{</span>name <span class="main">=</span> <span class="inner_quoted">"shadow_prop"</span><span class="main">,</span>
     args <span class="main">=</span> <span class="main">[</span><span class="entity">TypedUniv</span> <span class="entity">TY_PROP</span><span class="main">,</span> <span class="entity">TypedUniv</span> <span class="entity">TY_PROP</span><span class="main">]</span><span class="main">,</span>
     func <span class="main">=</span> <span class="entity">TwoStep</span> <span class="entity">shadow_item_fn</span><span class="main">}</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">shadow_term_item</span> <span class="main">=</span>
    <span class="main">{</span>name <span class="main">=</span> <span class="inner_quoted">"shadow_term"</span><span class="main">,</span>
     args <span class="main">=</span> <span class="main">[</span><span class="entity">TypedUniv</span> <span class="entity">TY_TERM</span><span class="main">,</span> <span class="entity">TypedUniv</span> <span class="entity">TY_TERM</span><span class="main">]</span><span class="main">,</span>
     func <span class="main">=</span> <span class="entity">TwoStep</span> <span class="entity">shadow_item_fn</span><span class="main">}</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">eq_abs_fn</span> <span class="entity">ctxt</span> <span class="entity">item1</span> <span class="entity">item2</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span>id <span class="main">=</span> <span class="entity">id1</span><span class="main">,</span> tname <span class="main">=</span> <span class="entity">tname1</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">item1</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span>id <span class="main">=</span> <span class="entity">id2</span><span class="main">,</span> tname <span class="main">=</span> <span class="entity">tname2</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">item2</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">id</span> <span class="main">=</span> <span class="entity">BoxID.merge_boxes</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id1</span><span class="main">,</span> <span class="entity">id2</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">ct1</span><span class="main">,</span> <span class="entity">ct2</span><span class="main">)</span> <span class="main">=</span> apply2 the_single <span class="main">(</span><span class="entity">tname1</span><span class="main">,</span> <span class="entity">tname2</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span> apply2 Thm.term_of <span class="main">(</span><span class="entity">ct1</span><span class="main">,</span> <span class="entity">ct2</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span><span class="entity">Util.is_abs</span> <span class="entity">t1</span><span class="main">)</span> <span class="keyword1"><span class="keyword">orelse</span></span> not <span class="main">(</span><span class="entity">Util.is_abs</span> <span class="entity">t2</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">RewriteTable.is_equiv</span> <span class="entity">id</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">ct1</span><span class="main">,</span> <span class="entity">ct2</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> Term_Ord.term_ord <span class="main">(</span><span class="entity">t2</span><span class="main">,</span> <span class="entity">t1</span><span class="main">)</span> <span class="main">=</span> LESS <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_equiv</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">eq_th</span><span class="main">)</span> <span class="main">=</span>
            <span class="keyword2"><span class="keyword">let</span></span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">Util.lhs_of</span> <span class="entity">eq_th</span><span class="main">,</span> <span class="entity">Util.rhs_of</span> <span class="entity">eq_th</span><span class="main">)</span>
            <span class="keyword2"><span class="keyword">in</span></span>
              <span class="entity">AddItems</span> <span class="main">{</span>id <span class="main">=</span> <span class="entity">id'</span><span class="main">,</span> sc <span class="main">=</span> SOME <span class="inner_numeral">1</span><span class="main">,</span>
                        raw_items <span class="main">=</span> <span class="main">[</span><span class="entity">Fact</span> <span class="main">(</span><span class="entity">TY_EQ</span><span class="main">,</span> <span class="main">[</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">]</span><span class="main">,</span> <span class="entity">eq_th</span><span class="main">)</span><span class="main">]</span><span class="main">}</span>
            <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span><span class="entity">Matcher.rewrite_match</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">ct2</span><span class="main">)</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">fo_init</span><span class="main">)</span><span class="main">)</span>
            |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="entity">eq_th</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">eq_th</span><span class="main">)</span><span class="main">)</span>
            |&gt; filter <span class="main">(</span><span class="entity">BoxID.has_incr_id</span> o fst<span class="main">)</span>
            |&gt; <span class="entity">Util.max_partial</span> <span class="main">(</span><span class="entity">BoxID.id_is_eq_ancestor</span> <span class="entity">ctxt</span><span class="main">)</span>
            |&gt; map <span class="entity">process_equiv</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq_abs_prfstep</span> <span class="main">=</span>
    <span class="main">{</span>name <span class="main">=</span> <span class="inner_quoted">"eq_abs"</span><span class="main">,</span>
     args <span class="main">=</span> <span class="main">[</span><span class="entity">TypedUniv</span> <span class="entity">TY_TERM</span><span class="main">,</span> <span class="entity">TypedUniv</span> <span class="entity">TY_TERM</span><span class="main">]</span><span class="main">,</span>
     func <span class="main">=</span> <span class="entity">TwoStep</span> <span class="entity">eq_abs_fn</span><span class="main">}</span>

<span class="comment1">(* Given an assumption of the form EX x. A, we produce an assumption A
   with x in A replaced by a free variable. To avoid name collisions,
   when the update is produced x is replaced by an "internal" free
   variable, with suffix '_'. When the update is applied, that
   internal free variable is replaced by a fresh variable as
   determined by the context. We produce at most two variables at a
   time.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">exists_elim_fn</span> <span class="entity">ctxt</span> <span class="main">{</span><span class="entity">id</span><span class="main">,</span> <span class="entity">prop</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span><span class="entity">BoxID.has_incr_id</span> <span class="entity">id</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span> <span class="keyword2"><span class="keyword">else</span></span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">prop_of'</span> <span class="entity">prop</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_ex</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">orelse</span></span> <span class="entity">is_bex</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">orelse</span></span>
         <span class="main">(</span><span class="entity">is_neg</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_obj_all</span> <span class="main">(</span><span class="entity">dest_not</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span> <span class="keyword1"><span class="keyword">orelse</span></span>
         <span class="main">(</span><span class="entity">is_neg</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_ball</span> <span class="main">(</span><span class="entity">dest_not</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">ritems</span><span class="main">,</span> <span class="entity">th'</span><span class="main">)</span> <span class="main">=</span>
              <span class="entity">prop</span> |&gt; <span class="entity">apply_to_thm'</span> <span class="main">(</span><span class="entity">UtilLogic.normalize_exists</span> <span class="entity">ctxt</span><span class="main">)</span>
                   |&gt; <span class="entity">Update.apply_exists_ritems</span> <span class="entity">ctxt</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="main">[</span><span class="entity">AddItems</span> <span class="main">{</span>id <span class="main">=</span> <span class="entity">id</span><span class="main">,</span> sc <span class="main">=</span> NONE<span class="main">,</span>
                     raw_items <span class="main">=</span> <span class="entity">ritems</span> @ <span class="main">[</span><span class="entity">Update.thm_to_ritem</span> <span class="entity">th'</span><span class="main">]</span><span class="main">}</span><span class="main">]</span>
        <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">exists_elim_prfstep</span> <span class="main">=</span>
    <span class="main">{</span>name <span class="main">=</span> <span class="inner_quoted">"exists_elim"</span><span class="main">,</span>
     args <span class="main">=</span> <span class="main">[</span><span class="entity">TypedUniv</span> <span class="entity">TY_PROP</span><span class="main">]</span><span class="main">,</span>
     func <span class="main">=</span> <span class="entity">OneStep</span> <span class="entity">exists_elim_fn</span><span class="main">}</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">add_logic_proofsteps</span> <span class="main">=</span>
    fold <span class="entity">add_prfstep</span> <span class="main">[</span>
      <span class="entity">shadow_prop_item</span><span class="main">,</span> <span class="entity">shadow_term_item</span><span class="main">,</span> <span class="entity">exists_elim_prfstep</span><span class="main">,</span> <span class="entity">eq_abs_prfstep</span>
    <span class="main">]</span>

<span class="comment1">(* Given (x_1 ... x_n, A_1 ... A_n), create the corresponding
   forall-disj term.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_all_disj</span> <span class="main">(</span><span class="entity">vars</span><span class="main">,</span> <span class="entity">terms</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">vars</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="entity">list_disj</span> <span class="entity">terms</span>
      <span class="main">|</span> <span class="entity">var</span> :: <span class="entity">vars'</span> <span class="main">=&gt;</span> <span class="entity">mk_obj_all</span> <span class="entity">var</span> <span class="main">(</span><span class="entity">mk_all_disj</span> <span class="main">(</span><span class="entity">vars'</span><span class="main">,</span> <span class="entity">terms</span><span class="main">)</span><span class="main">)</span>

<span class="comment1">(* Normalize t into a disjunction of terms. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">strip_disj</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_disj</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
      maps <span class="entity">strip_disj</span> <span class="main">[</span><span class="entity">dest_arg1</span> <span class="entity">t</span><span class="main">,</span> <span class="entity">dest_arg</span> <span class="entity">t</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_imp</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
      maps <span class="entity">strip_disj</span> <span class="main">[</span><span class="entity">get_neg</span> <span class="main">(</span><span class="entity">dest_arg1</span> <span class="entity">t</span><span class="main">)</span><span class="main">,</span> <span class="entity">dest_arg</span> <span class="entity">t</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_neg</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t'</span> <span class="main">=</span> <span class="entity">dest_not</span> <span class="entity">t</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_neg</span> <span class="entity">t'</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">strip_disj</span> <span class="main">(</span><span class="entity">dest_not</span> <span class="entity">t'</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_conj</span> <span class="entity">t'</span> <span class="keyword2"><span class="keyword">then</span></span>
          maps <span class="entity">strip_disj</span> <span class="main">[</span><span class="entity">get_neg</span> <span class="main">(</span><span class="entity">dest_arg1</span> <span class="entity">t'</span><span class="main">)</span><span class="main">,</span> <span class="entity">get_neg</span> <span class="main">(</span><span class="entity">dest_arg</span> <span class="entity">t'</span><span class="main">)</span><span class="main">]</span>
        <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="entity">t</span><span class="main">]</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="entity">t</span><span class="main">]</span>

<span class="comment1">(* Normalize a term into the form !x_1 ... x_n. A_1 | ... | A_n *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">strip_all_disj</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_obj_all</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
          <span class="main">_</span> $ Abs <span class="main">(</span><span class="entity">abs</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">T</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">body</span><span class="main">)</span> <span class="main">=</span> Term.dest_abs <span class="entity">abs</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">var</span> <span class="main">=</span> Free <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">vars</span><span class="main">,</span> <span class="entity">disjs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">strip_all_disj</span> <span class="entity">body</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="keyword2"><span class="keyword">if</span></span> exists <span class="main">(</span><span class="entity">Util.occurs_free</span> <span class="entity">var</span><span class="main">)</span> <span class="entity">disjs</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="entity">var</span> :: <span class="entity">vars</span><span class="main">,</span> <span class="entity">disjs</span><span class="main">)</span>
            <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="entity">vars</span><span class="main">,</span> <span class="entity">disjs</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>
        <span class="main">|</span> <span class="entity">f</span> $ <span class="entity">arg</span> <span class="main">=&gt;</span> <span class="entity">strip_all_disj</span> <span class="main">(</span><span class="entity">f</span> $ <span class="entity">UtilLogic.force_abs_form</span> <span class="entity">arg</span><span class="main">)</span>
        <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"strip_all_disj"</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_ball</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
          <span class="main">_</span> $ <span class="entity">S</span> $ Abs <span class="main">(</span><span class="entity">abs</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">T</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">body</span><span class="main">)</span> <span class="main">=</span> Term.dest_abs <span class="entity">abs</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">var</span> <span class="main">=</span> Free <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mem</span> <span class="main">=</span> <span class="entity">mk_mem</span> <span class="main">(</span><span class="entity">var</span><span class="main">,</span> <span class="entity">S</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">vars</span><span class="main">,</span> <span class="entity">disjs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">strip_all_disj</span> <span class="entity">body</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="main">(</span><span class="entity">var</span> :: <span class="entity">vars</span><span class="main">,</span> <span class="entity">get_neg</span> <span class="entity">mem</span> :: <span class="entity">disjs</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>
        <span class="main">|</span> <span class="entity">f</span> $ <span class="entity">S</span> $ <span class="entity">arg</span> <span class="main">=&gt;</span> <span class="entity">strip_all_disj</span> <span class="main">(</span><span class="entity">f</span> $ <span class="entity">S</span> $ <span class="entity">UtilLogic.force_abs_form</span> <span class="entity">arg</span><span class="main">)</span>
        <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"strip_all_disj"</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_neg</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_ex</span> <span class="main">(</span><span class="entity">dest_not</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">dest_not</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
          <span class="main">_</span> $ Abs <span class="main">(</span><span class="entity">abs</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">T</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">body</span><span class="main">)</span> <span class="main">=</span> Term.dest_abs <span class="entity">abs</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">var</span> <span class="main">=</span> Free <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">vars</span><span class="main">,</span> <span class="entity">disjs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">strip_all_disj</span> <span class="main">(</span><span class="entity">get_neg</span> <span class="entity">body</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="keyword2"><span class="keyword">if</span></span> exists <span class="main">(</span><span class="entity">Util.occurs_free</span> <span class="entity">var</span><span class="main">)</span> <span class="entity">disjs</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="entity">var</span> :: <span class="entity">vars</span><span class="main">,</span> <span class="entity">disjs</span><span class="main">)</span>
            <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="entity">vars</span><span class="main">,</span> <span class="entity">disjs</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>
        <span class="main">|</span> <span class="entity">f</span> $ <span class="entity">arg</span> <span class="main">=&gt;</span> <span class="entity">strip_all_disj</span> <span class="main">(</span><span class="entity">get_neg</span> <span class="main">(</span><span class="entity">f</span> $ <span class="entity">UtilLogic.force_abs_form</span> <span class="entity">arg</span><span class="main">)</span><span class="main">)</span>
        <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"strip_all_disj"</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_neg</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_bex</span> <span class="main">(</span><span class="entity">dest_not</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">dest_not</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
          <span class="main">_</span> $ <span class="entity">S</span> $ Abs <span class="main">(</span><span class="entity">abs</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">T</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">body</span><span class="main">)</span> <span class="main">=</span> Term.dest_abs <span class="entity">abs</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">var</span> <span class="main">=</span> Free <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mem</span> <span class="main">=</span> <span class="entity">mk_mem</span> <span class="main">(</span><span class="entity">var</span><span class="main">,</span> <span class="entity">S</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">vars</span><span class="main">,</span> <span class="entity">disjs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">strip_all_disj</span> <span class="main">(</span><span class="entity">get_neg</span> <span class="entity">body</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="main">(</span><span class="entity">var</span> :: <span class="entity">vars</span><span class="main">,</span> <span class="entity">get_neg</span> <span class="entity">mem</span> :: <span class="entity">disjs</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>
        <span class="main">|</span> <span class="entity">f</span> $ <span class="entity">S</span> $ <span class="entity">arg</span> <span class="main">=&gt;</span> <span class="entity">strip_all_disj</span> <span class="main">(</span><span class="entity">get_neg</span> <span class="main">(</span><span class="entity">f</span> $ <span class="entity">S</span> $ <span class="entity">UtilLogic.force_abs_form</span> <span class="entity">arg</span><span class="main">)</span><span class="main">)</span>
        <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"strip_all_disj"</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_disj</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">v1</span><span class="main">,</span> <span class="entity">ts1</span><span class="main">)</span> <span class="main">=</span> <span class="entity">strip_all_disj</span> <span class="main">(</span><span class="entity">dest_arg1</span> <span class="entity">t</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">v2</span><span class="main">,</span> <span class="entity">ts2</span><span class="main">)</span> <span class="main">=</span> <span class="entity">strip_all_disj</span> <span class="main">(</span><span class="entity">dest_arg</span> <span class="entity">t</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span><span class="entity">v1</span> @ <span class="entity">v2</span><span class="main">,</span> <span class="entity">ts1</span> @ <span class="entity">ts2</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_imp</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">v1</span><span class="main">,</span> <span class="entity">ts1</span><span class="main">)</span> <span class="main">=</span> <span class="entity">strip_all_disj</span> <span class="main">(</span><span class="entity">get_neg</span> <span class="main">(</span><span class="entity">dest_arg1</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">v2</span><span class="main">,</span> <span class="entity">ts2</span><span class="main">)</span> <span class="main">=</span> <span class="entity">strip_all_disj</span> <span class="main">(</span><span class="entity">dest_arg</span> <span class="entity">t</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span><span class="entity">v1</span> @ <span class="entity">v2</span><span class="main">,</span> <span class="entity">ts1</span> @ <span class="entity">ts2</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_neg</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t'</span> <span class="main">=</span> <span class="entity">dest_not</span> <span class="entity">t</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_neg</span> <span class="entity">t'</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">strip_all_disj</span> <span class="main">(</span><span class="entity">dest_not</span> <span class="entity">t'</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_conj</span> <span class="entity">t'</span> <span class="keyword2"><span class="keyword">then</span></span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">v1</span><span class="main">,</span> <span class="entity">ts1</span><span class="main">)</span> <span class="main">=</span> <span class="entity">strip_all_disj</span> <span class="main">(</span><span class="entity">get_neg</span> <span class="main">(</span><span class="entity">dest_arg1</span> <span class="entity">t'</span><span class="main">)</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">v2</span><span class="main">,</span> <span class="entity">ts2</span><span class="main">)</span> <span class="main">=</span> <span class="entity">strip_all_disj</span> <span class="main">(</span><span class="entity">get_neg</span> <span class="main">(</span><span class="entity">dest_arg</span> <span class="entity">t'</span><span class="main">)</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="main">(</span><span class="entity">v1</span> @ <span class="entity">v2</span><span class="main">,</span> <span class="entity">ts1</span> @ <span class="entity">ts2</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>
        <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="entity">t</span><span class="main">]</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="entity">t</span><span class="main">]</span><span class="main">)</span>

<span class="comment1">(* Normalize (A_1 | A_2 | ... | A_m) | (B_1 | B_2 | ... | B_n) *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">norm_disj_clauses</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">arg1</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Util.dest_binop_args</span> <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_disj</span> <span class="entity">arg1</span> <span class="keyword2"><span class="keyword">then</span></span>
        Conv.every_conv <span class="main">[</span><span class="entity">rewr_obj_eq</span> <span class="entity">UtilBase.disj_assoc_th</span><span class="main">,</span>
                         Conv.arg_conv <span class="entity">norm_disj_clauses</span><span class="main">]</span> <span class="entity">ct</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        Conv.all_conv <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Normalize ct. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">norm_disj</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Thm.term_of <span class="entity">ct</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span>fastype_of <span class="entity">t</span> <span class="main">=</span> <span class="entity">boolT</span><span class="main">)</span> <span class="inner_quoted">"norm_disj: wrong type"</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_disj</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
        Conv.every_conv <span class="main">[</span>Conv.binop_conv <span class="entity">norm_disj</span><span class="main">,</span> <span class="entity">norm_disj_clauses</span><span class="main">]</span> <span class="entity">ct</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_imp</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
        Conv.every_conv <span class="main">[</span><span class="entity">rewr_obj_eq</span> <span class="entity">UtilBase.imp_conv_disj_th</span><span class="main">,</span> <span class="entity">norm_disj</span><span class="main">]</span> <span class="entity">ct</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_neg</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_neg</span> <span class="main">(</span><span class="entity">dest_not</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
        Conv.every_conv <span class="main">[</span><span class="entity">rewr_obj_eq</span> <span class="entity">UtilBase.nn_cancel_th</span><span class="main">,</span> <span class="entity">norm_disj</span><span class="main">]</span> <span class="entity">ct</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_neg</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_conj</span> <span class="main">(</span><span class="entity">dest_not</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
        Conv.every_conv <span class="main">[</span><span class="entity">rewr_obj_eq</span> <span class="entity">UtilBase.de_Morgan_conj_th</span><span class="main">,</span> <span class="entity">norm_disj</span><span class="main">]</span> <span class="entity">ct</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        Conv.all_conv <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Normalize to forall at the top-level *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">norm_all_disj</span> <span class="entity">ctxt</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Thm.term_of <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_obj_all</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span><span class="entity">Util.is_subterm</span> <span class="main">(</span>Bound <span class="inner_numeral">0</span><span class="main">)</span> <span class="main">(</span><span class="entity">dest_arg</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
          Conv.every_conv <span class="main">[</span><span class="entity">rewr_obj_eq</span> <span class="entity">UtilBase.all_trivial_th</span><span class="main">,</span>
                           <span class="entity">norm_all_disj</span> <span class="entity">ctxt</span><span class="main">]</span> <span class="entity">ct</span>
        <span class="keyword2"><span class="keyword">else</span></span>
          Conv.every_conv <span class="main">[</span>Conv.binder_conv <span class="main">(</span><span class="entity">norm_all_disj</span> o snd<span class="main">)</span> <span class="entity">ctxt</span><span class="main">]</span> <span class="entity">ct</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_ball</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
        Conv.every_conv <span class="main">[</span><span class="entity">rewr_obj_eq</span> <span class="entity">UtilBase.Ball_def_th</span><span class="main">,</span> <span class="entity">norm_all_disj</span> <span class="entity">ctxt</span><span class="main">]</span> <span class="entity">ct</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_neg</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_ex</span> <span class="main">(</span><span class="entity">dest_not</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
        Conv.every_conv <span class="main">[</span><span class="entity">rewr_obj_eq</span> <span class="entity">UtilBase.not_ex_th</span><span class="main">,</span> <span class="entity">norm_all_disj</span> <span class="entity">ctxt</span><span class="main">]</span> <span class="entity">ct</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_neg</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_bex</span> <span class="main">(</span><span class="entity">dest_not</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
        Conv.every_conv <span class="main">[</span>
          Conv.arg_conv <span class="main">(</span><span class="entity">rewr_obj_eq</span> <span class="entity">UtilBase.Bex_def_th</span><span class="main">)</span><span class="main">,</span> <span class="entity">norm_all_disj</span> <span class="entity">ctxt</span><span class="main">]</span> <span class="entity">ct</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_disj</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq1</span> <span class="main">=</span> Conv.binop_conv <span class="main">(</span><span class="entity">norm_all_disj</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">ct</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs</span> <span class="main">=</span> <span class="entity">Util.rhs_of</span> <span class="entity">eq1</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_obj_all</span> <span class="main">(</span><span class="entity">dest_arg1</span> <span class="entity">rhs</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
            Conv.every_conv <span class="main">[</span>Conv.rewr_conv <span class="entity">eq1</span><span class="main">,</span>
                             <span class="entity">rewr_obj_eq</span> <span class="entity">UtilBase.disj_commute_th</span><span class="main">,</span>
                             <span class="entity">rewr_obj_eq</span> <span class="entity">UtilBase.swap_all_disj_th</span><span class="main">,</span>
                             <span class="entity">norm_all_disj</span> <span class="entity">ctxt</span><span class="main">]</span> <span class="entity">ct</span>
          <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_obj_all</span> <span class="main">(</span><span class="entity">dest_arg</span> <span class="entity">rhs</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
            Conv.every_conv <span class="main">[</span>Conv.rewr_conv <span class="entity">eq1</span><span class="main">,</span>
                             <span class="entity">rewr_obj_eq</span> <span class="entity">UtilBase.swap_all_disj_th</span><span class="main">,</span>
                             <span class="entity">norm_all_disj</span> <span class="entity">ctxt</span><span class="main">]</span> <span class="entity">ct</span>
          <span class="keyword2"><span class="keyword">else</span></span>
            Conv.every_conv <span class="main">[</span>Conv.rewr_conv <span class="entity">eq1</span><span class="main">,</span> <span class="entity">norm_disj_clauses</span><span class="main">]</span> <span class="entity">ct</span>
        <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_imp</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
        Conv.every_conv <span class="main">[</span><span class="entity">rewr_obj_eq</span> <span class="entity">UtilBase.imp_conv_disj_th</span><span class="main">,</span> <span class="entity">norm_all_disj</span> <span class="entity">ctxt</span><span class="main">]</span> <span class="entity">ct</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_neg</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_neg</span> <span class="main">(</span><span class="entity">dest_not</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
        Conv.every_conv <span class="main">[</span><span class="entity">rewr_obj_eq</span> <span class="entity">UtilBase.nn_cancel_th</span><span class="main">,</span> <span class="entity">norm_all_disj</span> <span class="entity">ctxt</span><span class="main">]</span> <span class="entity">ct</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_neg</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_conj</span> <span class="main">(</span><span class="entity">dest_not</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
        Conv.every_conv <span class="main">[</span><span class="entity">rewr_obj_eq</span> <span class="entity">UtilBase.de_Morgan_conj_th</span><span class="main">,</span> <span class="entity">norm_all_disj</span> <span class="entity">ctxt</span><span class="main">]</span> <span class="entity">ct</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        Conv.all_conv <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_disj_eq</span> <span class="entity">eq_ths</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">eq_ths</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"mk_disj_eq"</span>
      <span class="main">|</span> <span class="main">[</span><span class="entity">eq</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="entity">eq</span>
      <span class="main">|</span> <span class="entity">eq</span> :: <span class="entity">eqs'</span> <span class="main">=&gt;</span> Drule.binop_cong_rule <span class="entity">UtilBase.cDisj</span> <span class="entity">eq</span> <span class="main">(</span><span class="entity">mk_disj_eq</span> <span class="entity">eqs'</span><span class="main">)</span>

<span class="comment1">(* Sort A | (B_1 | B_2 | ... | B_n), assuming the right side is sorted. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">sort_disj_clause_aux</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span><span class="entity">is_disj</span> <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> Conv.all_conv <span class="entity">ct</span> <span class="keyword2"><span class="keyword">else</span></span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">arg1</span><span class="main">,</span> <span class="entity">arg2</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Util.dest_binop_args</span> <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_disj</span> <span class="entity">arg2</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="keyword2"><span class="keyword">if</span></span> Term_Ord.term_ord <span class="main">(</span><span class="entity">dest_arg1</span> <span class="entity">arg2</span><span class="main">,</span> <span class="entity">arg1</span><span class="main">)</span> <span class="main">=</span> LESS <span class="keyword2"><span class="keyword">then</span></span>
          Conv.every_conv <span class="main">[</span><span class="entity">rewr_obj_eq</span> <span class="main">(</span><span class="entity">obj_sym</span> <span class="entity">UtilBase.disj_assoc_th</span><span class="main">)</span><span class="main">,</span>
                           Conv.arg1_conv <span class="main">(</span><span class="entity">rewr_obj_eq</span> <span class="entity">UtilBase.disj_commute_th</span><span class="main">)</span><span class="main">,</span>
                           <span class="entity">rewr_obj_eq</span> <span class="entity">UtilBase.disj_assoc_th</span><span class="main">,</span>
                           Conv.arg_conv <span class="entity">sort_disj_clause_aux</span><span class="main">]</span> <span class="entity">ct</span>
        <span class="keyword2"><span class="keyword">else</span></span>
          Conv.all_conv <span class="entity">ct</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="keyword2"><span class="keyword">if</span></span> Term_Ord.term_ord <span class="main">(</span><span class="entity">arg2</span><span class="main">,</span> <span class="entity">arg1</span><span class="main">)</span> <span class="main">=</span> LESS <span class="keyword2"><span class="keyword">then</span></span>
          <span class="entity">rewr_obj_eq</span> <span class="main">(</span><span class="entity">obj_sym</span> <span class="entity">UtilBase.disj_commute_th</span><span class="main">)</span> <span class="entity">ct</span>
        <span class="keyword2"><span class="keyword">else</span></span>
          Conv.all_conv <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Sort A_1 | ... | A_n. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">sort_disj_clause</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span><span class="entity">is_disj</span> <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> Conv.all_conv <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">else</span></span> Conv.every_conv <span class="main">[</span>Conv.arg_conv <span class="entity">sort_disj_clause</span><span class="main">,</span>
                          <span class="entity">sort_disj_clause_aux</span><span class="main">]</span> <span class="entity">ct</span>

<span class="comment1">(* Apply cv on the body of !x y z. ... .*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">forall_body_conv</span> <span class="entity">cv</span> <span class="entity">ctxt</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_obj_all</span> <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
      Conv.binder_conv <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">forall_body_conv</span> <span class="entity">cv</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">else</span></span>
      <span class="entity">cv</span> <span class="entity">ct</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">norm_all_disj_sorted</span> <span class="entity">ctxt</span> <span class="entity">ct</span> <span class="main">=</span>
    Conv.every_conv <span class="main">[</span><span class="entity">norm_all_disj</span> <span class="entity">ctxt</span><span class="main">,</span>
                     <span class="entity">forall_body_conv</span> <span class="entity">sort_disj_clause</span> <span class="entity">ctxt</span><span class="main">]</span> <span class="entity">ct</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">abstract_eq</span> <span class="entity">ctxt</span> <span class="entity">var</span> <span class="entity">eq</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="main">=</span> Term.dest_Free <span class="entity">var</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_const</span> <span class="main">=</span> Const <span class="main">(</span><span class="entity">UtilBase.All_name</span><span class="main">,</span> <span class="main">(</span><span class="entity">T</span> --&gt; <span class="entity">boolT</span><span class="main">)</span> --&gt; <span class="entity">boolT</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      Drule.arg_cong_rule <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">all_const</span><span class="main">)</span>
                          <span class="main">(</span>Thm.abstract_rule <span class="entity">x</span> <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">var</span><span class="main">)</span> <span class="entity">eq</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">replace_disj_vars</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">vars</span><span class="main">,</span> <span class="entity">disjs</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">vars'</span> <span class="main">=</span> <span class="entity">vars</span> |&gt; map Term.dest_Free
                       |&gt; Variable.variant_frees <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span>
                       |&gt; map Free
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">subst</span> <span class="main">=</span> <span class="entity">vars</span> ~~ <span class="entity">vars'</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">(</span><span class="entity">vars'</span><span class="main">,</span> map <span class="main">(</span>subst_atomic <span class="entity">subst</span><span class="main">)</span> <span class="entity">disjs</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Matching for all-disj propositions *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">disj_prop_match</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="main">(</span><span class="entity">tyinst</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="main">(</span><span class="entity">var_t</span><span class="main">,</span> <span class="entity">ts</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">var_u</span><span class="main">,</span> <span class="entity">cus</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">us</span> <span class="main">=</span> map Thm.term_of <span class="entity">cus</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> length <span class="entity">var_t</span> &lt;&gt; length <span class="entity">var_u</span> <span class="keyword1"><span class="keyword">orelse</span></span> length <span class="entity">ts</span> &lt;&gt; length <span class="entity">us</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span> <span class="keyword2"><span class="keyword">else</span></span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="comment1">(* First match the types (return [] if no match). *)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tys_t</span> <span class="main">=</span> map fastype_of <span class="entity">var_t</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tys_u</span> <span class="main">=</span> map snd <span class="entity">var_u</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tyinst'</span> <span class="main">=</span> fold <span class="main">(</span>Sign.typ_match <span class="entity">thy</span><span class="main">)</span> <span class="main">(</span><span class="entity">tys_t</span> ~~ <span class="entity">tys_u</span><span class="main">)</span> <span class="entity">tyinst</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">var_t'</span> <span class="main">=</span> map <span class="main">(</span>Envir.subst_term_types <span class="entity">tyinst'</span><span class="main">)</span> <span class="entity">var_t</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ts'</span> <span class="main">=</span> <span class="entity">ts</span> |&gt; map <span class="main">(</span>Envir.subst_term_types <span class="entity">tyinst'</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">var_ct'</span> <span class="main">=</span> map <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">var_t'</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cus'</span> <span class="main">=</span> <span class="entity">cus</span> |&gt; map <span class="main">(</span>Thm.instantiate_cterm <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">var_u</span> ~~ <span class="entity">var_ct'</span><span class="main">)</span><span class="main">)</span>

        <span class="comment1">(* Match the type-instantiated pattern with term. *)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">insts</span> <span class="main">=</span> <span class="entity">Matcher.rewrite_match_subset</span>
                        <span class="entity">ctxt</span> <span class="entity">var_t'</span> <span class="main">(</span><span class="entity">ts'</span><span class="main">,</span> <span class="entity">cus'</span><span class="main">)</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="main">(</span><span class="entity">tyinst'</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span><span class="main">)</span>

        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_inst</span> <span class="main">(</span><span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">instsp'</span><span class="main">)</span><span class="main">,</span> <span class="entity">ths</span><span class="main">)</span> <span class="main">=</span>
            <span class="keyword2"><span class="keyword">let</span></span>
              <span class="comment1">(* Equality between normalized t and u *)</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq_th</span> <span class="main">=</span> <span class="entity">ths</span> |&gt; <span class="entity">mk_disj_eq</span>
                              |&gt; fold <span class="main">(</span><span class="entity">abstract_eq</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="main">(</span>rev <span class="entity">var_t'</span><span class="main">)</span>
                              |&gt; <span class="entity">apply_to_lhs</span> <span class="main">(</span><span class="entity">norm_all_disj_sorted</span> <span class="entity">ctxt</span><span class="main">)</span>
                              |&gt; <span class="entity">apply_to_rhs</span> <span class="main">(</span><span class="entity">norm_all_disj_sorted</span> <span class="entity">ctxt</span><span class="main">)</span>

              <span class="comment1">(* Equality between un-normalized t and u *)</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t'</span> <span class="main">=</span> <span class="entity">Util.subst_term_norm</span> <span class="entity">instsp'</span> <span class="entity">t</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">norm1</span> <span class="main">=</span> <span class="entity">norm_all_disj_sorted</span> <span class="entity">ctxt</span> <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">t'</span><span class="main">)</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cu</span> <span class="main">=</span> Thm.cterm_of <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">mk_all_disj</span> <span class="main">(</span><span class="entity">var_t'</span><span class="main">,</span> map Thm.term_of <span class="entity">cus'</span><span class="main">)</span><span class="main">)</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">norm2</span> <span class="main">=</span> <span class="entity">norm_all_disj_sorted</span> <span class="entity">ctxt</span> <span class="entity">cu</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq_th'</span> <span class="main">=</span> <span class="entity">Util.transitive_list</span> <span class="main">[</span><span class="entity">norm1</span><span class="main">,</span> <span class="entity">eq_th</span><span class="main">,</span> <span class="entity">meta_sym</span> <span class="entity">norm2</span><span class="main">]</span>
            <span class="keyword2"><span class="keyword">in</span></span>
              <span class="main">(</span><span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">instsp'</span><span class="main">)</span><span class="main">,</span> <span class="entity">eq_th'</span><span class="main">)</span>
            <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword2"><span class="keyword">in</span></span>
        map <span class="entity">process_inst</span> <span class="entity">insts</span>
      <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword3"><span class="keyword">handle</span></span> Type.TYPE_MATCH <span class="main">=&gt;</span> <span class="main">[</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">norm_conj_de_Morgan</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Thm.term_of <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_neg</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_disj</span> <span class="main">(</span><span class="entity">dest_not</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
        Conv.every_conv <span class="main">[</span><span class="entity">rewr_obj_eq</span> <span class="entity">UtilBase.de_Morgan_disj_th</span><span class="main">,</span>
                         Conv.arg_conv <span class="entity">norm_conj_de_Morgan</span><span class="main">]</span> <span class="entity">ct</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        Conv.all_conv <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">norm_conj_not_imp</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Thm.term_of <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_neg</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_imp</span> <span class="main">(</span><span class="entity">dest_not</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
        Conv.every_conv <span class="main">[</span><span class="entity">rewr_obj_eq</span> <span class="entity">UtilBase.not_imp_th</span><span class="main">,</span>
                         Conv.arg_conv <span class="entity">norm_conj_not_imp</span><span class="main">]</span> <span class="entity">ct</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        Conv.all_conv <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">norm_nn_cancel</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Thm.term_of <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_neg</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_neg</span> <span class="main">(</span><span class="entity">dest_not</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
        Conv.every_conv <span class="main">[</span><span class="entity">rewr_obj_eq</span> <span class="entity">UtilBase.nn_cancel_th</span><span class="main">,</span>
                         <span class="entity">norm_nn_cancel</span><span class="main">]</span> <span class="entity">ct</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        Conv.all_conv <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">norm_conj</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Thm.term_of <span class="entity">ct</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span>fastype_of <span class="entity">t</span> <span class="main">=</span> <span class="entity">boolT</span><span class="main">)</span> <span class="inner_quoted">"norm_conj: wrong type"</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_neg</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_neg</span> <span class="main">(</span><span class="entity">dest_not</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="entity">norm_nn_cancel</span> <span class="entity">ct</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_neg</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_imp</span> <span class="main">(</span><span class="entity">dest_not</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="entity">norm_conj_not_imp</span> <span class="entity">ct</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_neg</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_disj</span> <span class="main">(</span><span class="entity">dest_not</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="entity">norm_conj_de_Morgan</span> <span class="entity">ct</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        Conv.all_conv <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* DISJ items. *)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">TY_DISJ</span> <span class="main">=</span> <span class="inner_quoted">"DISJ"</span>

<span class="comment1">(* Given a theorem in the form of a disjunction, possibly containing
   schematic variables, return the corresponding DISJ item.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">disj_to_ritems</span> <span class="entity">prem_only</span> <span class="entity">disj_head</span> <span class="entity">th</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">subs</span> <span class="main">=</span> <span class="entity">strip_disj</span> <span class="main">(</span><span class="entity">prop_of'</span> <span class="entity">th</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> length <span class="entity">subs</span> <span class="main">=</span> <span class="inner_numeral">1</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">Util.has_vars</span> <span class="main">(</span>Thm.prop_of <span class="entity">th</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">th_to_ritem</span> <span class="entity">th</span> <span class="main">=</span>
                <span class="entity">Fact</span> <span class="main">(</span><span class="entity">TY_DISJ</span><span class="main">,</span>
                      <span class="entity">UtilLogic.term_of_bool</span> <span class="entity">prem_only</span> :: <span class="entity">disj</span> :: <span class="entity">strip_disj</span> <span class="main">(</span><span class="entity">prop_of'</span> <span class="entity">th</span><span class="main">)</span><span class="main">,</span>
                      <span class="entity">th</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            map <span class="entity">th_to_ritem</span> <span class="main">(</span><span class="entity">th</span> |&gt; <span class="entity">apply_to_thm'</span> <span class="entity">norm_conj</span>
                                |&gt; <span class="entity">UtilLogic.split_conj_th</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>
        <span class="keyword2"><span class="keyword">else</span></span>
          <span class="main">[</span><span class="entity">Fact</span> <span class="main">(</span><span class="entity">TY_PROP</span><span class="main">,</span> <span class="main">[</span><span class="entity">prop_of'</span> <span class="entity">th</span><span class="main">]</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">]</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tname</span> <span class="main">=</span> <span class="entity">UtilLogic.term_of_bool</span> <span class="entity">prem_only</span> :: <span class="entity">disj_head</span> :: <span class="entity">subs</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">[</span><span class="entity">Fact</span> <span class="main">(</span><span class="entity">TY_DISJ</span><span class="main">,</span> <span class="entity">tname</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">]</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">disj_to_update</span> <span class="entity">prem_only</span> <span class="entity">disj_head</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">sc</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> Thm.prop_of <span class="entity">th</span> aconv <span class="entity">pFalse</span> <span class="keyword2"><span class="keyword">then</span></span>
      <span class="entity">ResolveBox</span> <span class="main">{</span>id <span class="main">=</span> <span class="entity">id</span><span class="main">,</span> th <span class="main">=</span> <span class="entity">th</span><span class="main">}</span>
    <span class="keyword2"><span class="keyword">else</span></span>
      <span class="entity">AddItems</span> <span class="main">{</span>id <span class="main">=</span> <span class="entity">id</span><span class="main">,</span> sc <span class="main">=</span> <span class="entity">sc</span><span class="main">,</span>
                raw_items <span class="main">=</span> <span class="entity">disj_to_ritems</span> <span class="entity">prem_only</span> <span class="entity">disj_head</span> <span class="entity">th</span><span class="main">}</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_disj_head</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_disj</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">disj</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_imp</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">get_disj_head</span> <span class="main">(</span><span class="entity">dest_arg</span> <span class="entity">t</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_neg</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_neg</span> <span class="main">(</span><span class="entity">dest_not</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
      <span class="entity">get_disj_head</span> <span class="main">(</span><span class="entity">dest_not</span> <span class="main">(</span><span class="entity">dest_not</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_neg</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_conj</span> <span class="main">(</span><span class="entity">dest_not</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">conj</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_obj_all</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">orelse</span></span> <span class="entity">is_ball</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">dest_arg</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
          Abs <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">T</span><span class="main">,</span> <span class="entity">body</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">get_disj_head</span> <span class="main">(</span>snd <span class="main">(</span>Term.dest_abs <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">T</span><span class="main">,</span> <span class="entity">body</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
        <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">imp</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_neg</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_ex</span> <span class="main">(</span><span class="entity">dest_not</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">conj</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_neg</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_bex</span> <span class="main">(</span><span class="entity">dest_not</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">conj</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">imp</span>

<span class="comment1">(* Given a theorem th, return equivalent theorem in disjunctive form,
   with possible schematic variables. Also return whether th is
   "active", that is, whether it is originally a conjunctive goal or
   disjunctive fact, as opposed to implications.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">analyze_disj_th</span> <span class="entity">ctxt</span> <span class="entity">th</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">head</span> <span class="main">=</span> <span class="entity">get_disj_head</span> <span class="main">(</span><span class="entity">prop_of'</span> <span class="entity">th</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th'</span> <span class="main">=</span> <span class="entity">th</span> |&gt; <span class="entity">apply_to_thm'</span> <span class="main">(</span><span class="entity">norm_all_disj</span> <span class="entity">ctxt</span><span class="main">)</span>
                   |&gt; <span class="entity">apply_to_thm</span> <span class="main">(</span><span class="entity">UtilLogic.to_meta_conv</span> <span class="entity">ctxt</span><span class="main">)</span>
                   |&gt; <span class="entity">Util.forall_elim_sch</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">(</span><span class="entity">head</span><span class="main">,</span> <span class="entity">th'</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Deconstruct the tname of a DISJ item. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_tname_of_disj</span> <span class="entity">tname</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">tname</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="main">_</span> :: <span class="entity">disj_head</span> :: <span class="entity">rest</span> <span class="main">=&gt;</span> <span class="main">(</span>Thm.term_of <span class="entity">disj_head</span><span class="main">,</span> <span class="entity">rest</span><span class="main">)</span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"dest_tname_of_disj: too few terms in tname."</span>

<span class="comment1">(* Determine whether the item is for matching premises only (from the
   first entry in tname.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_match_prem_only</span> <span class="main">{</span><span class="entity">tname</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span>
    <span class="entity">UtilLogic.bool_of_term</span> <span class="main">(</span>Thm.term_of <span class="main">(</span>hd <span class="entity">tname</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_active_head</span> <span class="entity">disj_head</span> <span class="main">=</span> <span class="main">(</span>not <span class="main">(</span><span class="entity">disj_head</span> aconv <span class="entity">imp</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">disj_rewr_terms</span> <span class="entity">ts</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">UtilLogic.bool_of_term</span> <span class="main">(</span>hd <span class="entity">ts</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span> <span class="keyword2"><span class="keyword">else</span></span> drop <span class="inner_numeral">2</span> <span class="entity">ts</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">output_disj_fn</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">ts</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">match_prem</span><span class="main">,</span> <span class="entity">disj_head</span><span class="main">,</span> <span class="entity">subs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>hd <span class="entity">ts</span><span class="main">,</span> hd <span class="main">(</span>tl <span class="entity">ts</span><span class="main">)</span><span class="main">,</span> tl <span class="main">(</span>tl <span class="entity">ts</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prefix</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">UtilLogic.bool_of_term</span> <span class="entity">match_prem</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="inner_quoted">"(match_prem) "</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="inner_quoted">""</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">disj_head</span> aconv <span class="entity">disj</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="entity">prefix</span> ^ <span class="main">(</span><span class="main">(</span>foldr1 <span class="entity">mk_disj</span> <span class="entity">subs</span><span class="main">)</span> |&gt; Syntax.string_of_term <span class="entity">ctxt</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">disj_head</span> aconv <span class="entity">conj</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="entity">prefix</span> ^ <span class="main">(</span><span class="main">(</span>foldr1 <span class="entity">mk_conj</span> <span class="main">(</span>map <span class="entity">get_neg</span> <span class="entity">subs</span><span class="main">)</span><span class="main">)</span>
                      |&gt; <span class="entity">get_neg</span> |&gt; Syntax.string_of_term <span class="entity">ctxt</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">disj_head</span> aconv <span class="entity">imp</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="entity">prefix</span> ^ <span class="main">(</span><span class="main">(</span>foldr1 <span class="entity">mk_imp</span> <span class="main">(</span><span class="entity">subs</span> |&gt; split_last |&gt; apfst <span class="main">(</span>map <span class="entity">get_neg</span><span class="main">)</span>
                                       |&gt; apsnd single |&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> @<span class="main">)</span><span class="main">)</span><span class="main">)</span>
                      |&gt; Syntax.string_of_term <span class="entity">ctxt</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"output_disj_fn: unexpected disj_head."</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">disj_prop_matcher</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pre_match</span> <span class="entity">pat</span> <span class="main">{</span><span class="entity">tname</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="entity">ctxt</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">var_t</span><span class="main">,</span> <span class="entity">ts</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">strip_all_disj</span> <span class="entity">pat</span><span class="main">)</span> |&gt; <span class="entity">replace_disj_vars</span> <span class="entity">ctxt</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">cus</span><span class="main">)</span> <span class="main">=</span> <span class="entity">dest_tname_of_disj</span> <span class="entity">tname</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">us</span> <span class="main">=</span> map Thm.term_of <span class="entity">cus</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">var_u</span> <span class="main">=</span> fold Term.add_vars <span class="entity">us</span> <span class="main">[</span><span class="main">]</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            length <span class="entity">ts</span> <span class="main">=</span> length <span class="entity">us</span> <span class="keyword1"><span class="keyword">andalso</span></span> length <span class="entity">var_t</span> <span class="main">=</span> length <span class="entity">var_u</span>
          <span class="keyword2"><span class="keyword">end</span></span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">match</span> <span class="entity">pat</span> <span class="entity">item</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">instsp</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">tname</span><span class="main">,</span> prop <span class="main">=</span> <span class="entity">th</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">item</span>

            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">cus</span><span class="main">)</span> <span class="main">=</span> <span class="entity">dest_tname_of_disj</span> <span class="entity">tname</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">us</span> <span class="main">=</span> map Thm.term_of <span class="entity">cus</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">var_u</span> <span class="main">=</span> fold Term.add_vars <span class="entity">us</span> <span class="main">[</span><span class="main">]</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">var_t</span><span class="main">,</span> <span class="entity">ts</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">strip_all_disj</span> <span class="entity">pat</span><span class="main">)</span> |&gt; <span class="entity">replace_disj_vars</span> <span class="entity">ctxt</span>

            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_perm</span> <span class="entity">perm</span> <span class="main">=</span>
                map <span class="main">(</span>pair <span class="main">(</span>map Var <span class="entity">perm</span><span class="main">)</span><span class="main">)</span>
                    <span class="main">(</span><span class="entity">disj_prop_match</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">instsp</span><span class="main">)</span> <span class="main">(</span><span class="entity">pat</span><span class="main">,</span> <span class="main">(</span><span class="entity">var_t</span><span class="main">,</span> <span class="entity">ts</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">perm</span><span class="main">,</span> <span class="entity">cus</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_inst</span> <span class="main">(</span><span class="entity">var_u</span><span class="main">,</span> <span class="main">(</span><span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">instsp'</span><span class="main">)</span><span class="main">,</span> <span class="entity">eq_th</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
                <span class="keyword2"><span class="keyword">let</span></span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq_th'</span> <span class="main">=</span> <span class="entity">make_trueprop_eq</span> <span class="main">(</span><span class="entity">meta_sym</span> <span class="entity">eq_th</span><span class="main">)</span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">forall_th</span> <span class="main">=</span>
                      <span class="entity">th</span> |&gt; fold Thm.forall_intr <span class="main">(</span>rev <span class="main">(</span>map <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">var_u</span><span class="main">)</span><span class="main">)</span>
                         |&gt; <span class="entity">apply_to_thm</span> <span class="main">(</span><span class="entity">UtilLogic.to_obj_conv</span> <span class="entity">ctxt</span><span class="main">)</span>
                <span class="keyword2"><span class="keyword">in</span></span>
                  <span class="main">(</span><span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">instsp'</span><span class="main">)</span><span class="main">,</span> Thm.equal_elim <span class="entity">eq_th'</span> <span class="entity">forall_th</span><span class="main">)</span>
                <span class="keyword2"><span class="keyword">end</span></span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="keyword2"><span class="keyword">if</span></span> length <span class="entity">var_t</span> &lt;&gt; length <span class="entity">var_u</span> <span class="keyword1"><span class="keyword">orelse</span></span> length <span class="entity">ts</span> &lt;&gt; length <span class="entity">us</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span>
            <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">var_u</span> |&gt; <span class="entity">Util.all_permutes</span> |&gt; maps <span class="entity">process_perm</span>
                       |&gt; map <span class="entity">process_inst</span>
          <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">{</span>pre_match <span class="main">=</span> <span class="entity">pre_match</span><span class="main">,</span> match <span class="main">=</span> <span class="entity">match</span><span class="main">}</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Given ct in the form p_1 | ... | p_n, apply cv to each of p_i. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ac_disj_conv</span> <span class="entity">cv</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_disj</span> <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
      Conv.every_conv <span class="main">[</span>Conv.arg1_conv <span class="entity">cv</span><span class="main">,</span>
                       Conv.arg_conv <span class="main">(</span><span class="entity">ac_disj_conv</span> <span class="entity">cv</span><span class="main">)</span><span class="main">]</span> <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">cv</span> <span class="entity">ct</span>

<span class="comment1">(* Assume ct is a disjunction, associating to the right. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">reduce_disj_True</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_disj</span> <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
      <span class="main">(</span><span class="main">(</span><span class="entity">rewr_obj_eq</span> <span class="entity">UtilBase.disj_True1_th</span><span class="main">)</span>
           else_conv <span class="main">(</span><span class="main">(</span>Conv.arg_conv <span class="entity">reduce_disj_True</span><span class="main">)</span>
                          then_conv <span class="main">(</span><span class="entity">rewr_obj_eq</span> <span class="entity">UtilBase.disj_True2_th</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">else</span></span>
      Conv.all_conv <span class="entity">ct</span>

<span class="comment1">(* Handles also the case where pat is in not-conj or imp form. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">match_prop</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">item2</span><span class="main">)</span> <span class="entity">pat</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">disj_pats</span> <span class="main">=</span> <span class="entity">strip_disj</span> <span class="entity">pat</span>

      <span class="comment1">(* th is pat'(inst), where pat' is one of the disjunctive terms
         of pat.
       *)</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_inst</span> <span class="main">(</span><span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="comment1">(* Construct the theorem pat'(inst) == True. *)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">to_eqT_cv</span> <span class="main">=</span> <span class="main">(</span><span class="entity">th</span> RS <span class="entity">UtilBase.eq_True_th</span><span class="main">)</span> |&gt; <span class="entity">rewr_obj_eq</span> |&gt; Conv.try_conv

            <span class="comment1">(* Rewrite pat(inst) using the above, then rewrite to True. *)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pat_eqT</span> <span class="main">=</span>
                <span class="entity">pat</span> |&gt; Thm.cterm_of <span class="entity">ctxt</span> |&gt; <span class="entity">norm_disj</span>
                    |&gt; <span class="entity">Util.subst_thm</span> <span class="entity">ctxt</span> <span class="entity">inst</span>
                    |&gt; <span class="entity">apply_to_rhs</span> <span class="main">(</span><span class="entity">ac_disj_conv</span> <span class="entity">to_eqT_cv</span><span class="main">)</span>
                    |&gt; <span class="entity">apply_to_rhs</span> <span class="entity">reduce_disj_True</span>
                    |&gt; <span class="entity">to_obj_eq</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">patT</span> <span class="main">=</span> <span class="entity">pat_eqT</span> RS <span class="entity">UtilBase.eq_True_inv_th</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="main">(</span><span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span><span class="main">,</span> <span class="entity">patT</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">insts1</span> <span class="main">=</span>
          <span class="main">(</span><span class="entity">ItemIO.match_arg</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">PropMatch</span> <span class="entity">pat</span><span class="main">)</span> <span class="entity">item2</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">fo_init</span><span class="main">)</span><span class="main">)</span>
              |&gt; filter <span class="main">(</span><span class="entity">BoxID.has_incr_id</span> o fst o fst<span class="main">)</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">insts2</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">if</span></span> length <span class="entity">disj_pats</span> &gt; <span class="inner_numeral">1</span> <span class="keyword2"><span class="keyword">then</span></span>
            map <span class="entity">process_inst</span> <span class="main">(</span>maps <span class="main">(</span><span class="entity">match_prop</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">item2</span><span class="main">)</span><span class="main">)</span> <span class="entity">disj_pats</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">insts1</span> @ <span class="entity">insts2</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Given theorem ~P, cancel any disjunct that is aconv to P. It is
   possible to leave one disjunct P un-cancelled.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">disj_cancel_cv</span> <span class="entity">ctxt</span> <span class="entity">th</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_disj</span> <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
      Conv.every_conv <span class="main">[</span>Conv.arg_conv <span class="main">(</span><span class="entity">disj_cancel_cv</span> <span class="entity">ctxt</span> <span class="entity">th</span><span class="main">)</span><span class="main">,</span>
                       Conv.try_conv <span class="main">(</span><span class="entity">rewr_obj_eq</span> <span class="main">(</span><span class="entity">th</span> RS <span class="entity">UtilBase.or_cancel1_th</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
                       Conv.try_conv <span class="main">(</span><span class="entity">rewr_obj_eq</span> <span class="main">(</span><span class="entity">th</span> RS <span class="entity">UtilBase.or_cancel2_th</span><span class="main">)</span><span class="main">)</span><span class="main">]</span> <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">else</span></span>
      Conv.all_conv <span class="entity">ct</span>

<span class="comment1">(* Given theorem P and a disjuncion theorem, return new disjunction
   theorem with ~P cancelled. If all disjuncts can be cancelled,
   return False.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">disj_cancel_prop</span> <span class="entity">ctxt</span> <span class="entity">th</span> <span class="entity">prop</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th'</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_neg</span> <span class="main">(</span><span class="entity">prop_of'</span> <span class="entity">th</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">th</span>
                <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">th</span> RS <span class="entity">UtilBase.nn_create_th</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prop'</span> <span class="main">=</span> <span class="entity">prop</span> |&gt; <span class="entity">apply_to_thm'</span> <span class="main">(</span><span class="entity">disj_cancel_cv</span> <span class="entity">ctxt</span> <span class="entity">th'</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">P</span> <span class="main">=</span> <span class="entity">th'</span> |&gt; <span class="entity">prop_of'</span> |&gt; <span class="entity">dest_not</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">prop_of'</span> <span class="entity">prop'</span> aconv <span class="entity">P</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="main">[</span><span class="entity">th'</span><span class="main">,</span> <span class="entity">prop'</span><span class="main">]</span> MRS <span class="entity">UtilBase.contra_triv_th</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">prop'</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Reduce a disjunction p_1 | ... | t | ... | p_n by matching ~t with
   the second item. If the disjunction contains schematic variables, t
   must have either zero or the largest number of schematic variables.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">match_update_fn</span> <span class="entity">ctxt</span> <span class="entity">item1</span> <span class="entity">item2</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_match_prem_only</span> <span class="entity">item1</span> <span class="keyword1"><span class="keyword">andalso</span></span>
       <span class="entity">Util.has_vars</span> <span class="main">(</span>Thm.prop_of <span class="main">(</span><span class="main">#</span>prop <span class="entity">item1</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span> <span class="keyword2"><span class="keyword">else</span></span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">id</span><span class="main">,</span> <span class="entity">prop</span><span class="main">,</span> <span class="entity">tname</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">item1</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">disj_head</span><span class="main">,</span> <span class="entity">csubs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">dest_tname_of_disj</span> <span class="entity">tname</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">subs</span> <span class="main">=</span> map Thm.term_of <span class="entity">csubs</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">count_var</span> <span class="entity">t</span> <span class="main">=</span> length <span class="main">(</span>Term.add_vars <span class="entity">t</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">max_nvar</span> <span class="main">=</span> fold <span class="main">(</span>curry Int.max<span class="main">)</span> <span class="main">(</span>map <span class="entity">count_var</span> <span class="entity">subs</span><span class="main">)</span> <span class="inner_numeral">0</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_priority_term</span> <span class="entity">t</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_neg</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
            exists <span class="main">(</span><span class="entity">is_ex</span> orf <span class="entity">is_bex</span><span class="main">)</span> <span class="main">(</span><span class="entity">strip_conj</span> <span class="main">(</span><span class="entity">dest_not</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">else</span></span>
            exists <span class="main">(</span><span class="entity">is_obj_all</span> orf <span class="entity">is_ball</span><span class="main">)</span> <span class="main">(</span><span class="entity">strip_disj</span> <span class="entity">t</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">has_priority_term</span> <span class="main">=</span> exists <span class="entity">is_priority_term</span> <span class="main">(</span>map <span class="entity">get_neg</span> <span class="entity">subs</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">NO_MATCH</span><span class="main">,</span> <span class="entity">SLOW_MATCH</span><span class="main">,</span> <span class="entity">YES_MATCH</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="inner_numeral">0</span><span class="main">,</span> <span class="inner_numeral">1</span><span class="main">,</span> <span class="inner_numeral">2</span><span class="main">)</span>
      <span class="comment1">(* Test whether to perform matching on pattern. *)</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">test_do_match</span> <span class="entity">t</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">nvar</span> <span class="main">=</span> <span class="entity">count_var</span> <span class="entity">t</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">neg_t</span> <span class="main">=</span> <span class="entity">get_neg</span> <span class="entity">t</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span><span class="entity">Util.is_pattern</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">NO_MATCH</span>
            <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> length <span class="entity">subs</span> &gt; <span class="inner_numeral">1</span> <span class="keyword1"><span class="keyword">andalso</span></span>
                    <span class="entity">Property.is_property_prem</span> <span class="entity">thy</span> <span class="entity">neg_t</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">NO_MATCH</span>
            <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">has_priority_term</span> <span class="keyword1"><span class="keyword">andalso</span></span>
                    not <span class="main">(</span><span class="entity">is_priority_term</span> <span class="entity">neg_t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">SLOW_MATCH</span>
            <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_mem</span> <span class="entity">neg_t</span> <span class="keyword1"><span class="keyword">andalso</span></span> Term.is_Var <span class="main">(</span><span class="entity">dest_arg1</span> <span class="entity">neg_t</span><span class="main">)</span> <span class="keyword1"><span class="keyword">andalso</span></span>
                    null <span class="main">(</span>Term.add_frees <span class="main">(</span><span class="entity">dest_arg</span> <span class="entity">neg_t</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">SLOW_MATCH</span>
            <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">nvar</span> <span class="main">=</span> <span class="inner_numeral">0</span> <span class="keyword1"><span class="keyword">orelse</span></span> <span class="entity">nvar</span> <span class="main">=</span> <span class="entity">max_nvar</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">YES_MATCH</span>
            <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">NO_MATCH</span>
          <span class="keyword2"><span class="keyword">end</span></span>

      <span class="comment1">(* Match the negation of subs[i] with th2. For each match,
         instantiate in prop all schematic variables in t, so that t
         becomes ~th2. Then remove t from prop in the instantiated
         version.
       *)</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_matches</span> <span class="entity">i</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> nth <span class="entity">subs</span> <span class="entity">i</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">do_match</span> <span class="main">=</span> <span class="entity">test_do_match</span> <span class="entity">t</span>
            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_inst</span> <span class="main">(</span><span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=</span>
                <span class="keyword2"><span class="keyword">let</span></span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prop'</span> <span class="main">=</span> <span class="entity">prop</span> |&gt; <span class="entity">Util.subst_thm_thy</span> <span class="entity">thy</span> <span class="entity">inst</span>
                                   |&gt; <span class="entity">disj_cancel_prop</span> <span class="entity">ctxt</span> <span class="entity">th</span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sc</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">do_match</span> <span class="main">=</span> <span class="entity">SLOW_MATCH</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="inner_numeral">200</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="inner_numeral">10</span>
                <span class="keyword2"><span class="keyword">in</span></span>
                  <span class="entity">disj_to_update</span> false <span class="entity">disj_head</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> SOME <span class="entity">sc</span><span class="main">,</span> <span class="entity">prop'</span><span class="main">)</span> ::
                  <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">count_var</span> <span class="entity">t</span> &gt; <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span>
                   <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="entity">ShadowItem</span> <span class="main">{</span>id <span class="main">=</span> <span class="entity">id'</span><span class="main">,</span> item <span class="main">=</span> <span class="entity">item1</span><span class="main">}</span><span class="main">]</span><span class="main">)</span>
                <span class="keyword2"><span class="keyword">end</span></span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">do_match</span> <span class="main">=</span> <span class="entity">NO_MATCH</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span>
            <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">t</span> |&gt; <span class="entity">get_neg</span> |&gt; <span class="entity">match_prop</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">item2</span><span class="main">)</span>
                   |&gt; maps <span class="entity">process_inst</span>
          <span class="keyword2"><span class="keyword">end</span></span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_matches_no_var</span> <span class="main">(</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_inst</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">ths</span><span class="main">)</span> <span class="main">=</span>
                <span class="keyword2"><span class="keyword">let</span></span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prop'</span> <span class="main">=</span> <span class="entity">prop</span> |&gt; fold <span class="main">(</span><span class="entity">disj_cancel_prop</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">ths</span>
                <span class="keyword2"><span class="keyword">in</span></span>
                  <span class="entity">disj_to_update</span> false <span class="entity">disj_head</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> SOME <span class="inner_numeral">1</span><span class="main">,</span> <span class="entity">prop'</span><span class="main">)</span> ::
                  <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_match_prem_only</span> <span class="entity">item1</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span>
                   <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="entity">ShadowItem</span> <span class="main">{</span>id <span class="main">=</span> <span class="entity">id'</span><span class="main">,</span> item <span class="main">=</span> <span class="entity">item1</span><span class="main">}</span><span class="main">]</span><span class="main">)</span>
                <span class="keyword2"><span class="keyword">end</span></span>

            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_match_at_id</span> <span class="entity">id'</span> <span class="entity">insts</span> <span class="main">=</span>
                <span class="entity">insts</span> |&gt; filter <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span>
                                    <span class="entity">BoxID.is_eq_ancestor</span> <span class="entity">ctxt</span> <span class="entity">id</span> <span class="entity">id'</span><span class="main">)</span>
                      |&gt; map snd |&gt; take <span class="inner_numeral">1</span>

            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_matches_at_id</span> <span class="entity">all_insts</span> <span class="entity">id'</span> <span class="main">=</span>
                <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> maps <span class="main">(</span><span class="entity">get_match_at_id</span> <span class="entity">id'</span><span class="main">)</span> <span class="entity">all_insts</span><span class="main">)</span>

            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">merge_matches</span> <span class="entity">all_insts</span> <span class="main">=</span>
                <span class="keyword2"><span class="keyword">let</span></span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ids</span> <span class="main">=</span> distinct <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="main">(</span>maps <span class="main">(</span>map <span class="main">(</span>fst o fst<span class="main">)</span><span class="main">)</span> <span class="entity">all_insts</span><span class="main">)</span>
                <span class="keyword2"><span class="keyword">in</span></span>
                  map <span class="main">(</span><span class="entity">get_matches_at_id</span> <span class="entity">all_insts</span><span class="main">)</span> <span class="entity">ids</span>
                <span class="keyword2"><span class="keyword">end</span></span>

            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span>length <span class="entity">subs</span> &gt;= <span class="inner_numeral">2</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ts</span> <span class="main">=</span> <span class="main">[</span>hd <span class="entity">subs</span><span class="main">,</span> List.last <span class="entity">subs</span><span class="main">]</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="entity">ts</span> |&gt; map <span class="entity">get_neg</span> |&gt; map <span class="main">(</span><span class="entity">match_prop</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">item2</span><span class="main">)</span><span class="main">)</span>
               |&gt; <span class="entity">merge_matches</span>
               |&gt; maps <span class="entity">process_inst</span>
          <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">max_nvar</span> <span class="main">=</span> <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="entity">get_matches_no_var</span> <span class="main">(</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        maps <span class="entity">get_matches</span> <span class="main">(</span><span class="inner_numeral">0</span> upto <span class="main">(</span>length <span class="entity">subs</span> - <span class="inner_numeral">1</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">match_update_prfstep</span> <span class="main">=</span>
    <span class="main">{</span>name <span class="main">=</span> <span class="inner_quoted">"disj_match_update"</span><span class="main">,</span>
     args <span class="main">=</span> <span class="main">[</span><span class="entity">TypedUniv</span> <span class="entity">TY_DISJ</span><span class="main">,</span> <span class="entity">PropMatch</span> <span class="main">(</span><span class="entity">boolVar</span> <span class="inner_quoted">"A"</span><span class="main">)</span><span class="main">]</span><span class="main">,</span>
     func <span class="main">=</span> <span class="entity">TwoStep</span> <span class="entity">match_update_fn</span><span class="main">}</span>

<span class="comment1">(* For DISJ items with a single term, of form f p1 ... pn, match t
   against each of p_i.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">match_one_sch_fn</span> <span class="entity">ctxt</span> <span class="entity">item1</span> <span class="entity">item2</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_match_prem_only</span> <span class="entity">item1</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span> <span class="keyword2"><span class="keyword">else</span></span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">id</span><span class="main">,</span> <span class="entity">tname</span><span class="main">,</span> prop <span class="main">=</span> <span class="entity">th1</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">item1</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">subs</span> <span class="main">=</span> <span class="main">(</span><span class="entity">dest_tname_of_disj</span> <span class="entity">tname</span><span class="main">)</span> |&gt; snd |&gt; map Thm.term_of
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> length <span class="entity">subs</span> &gt; <span class="inner_numeral">1</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span> <span class="keyword2"><span class="keyword">else</span></span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> the_single <span class="entity">subs</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">=</span> <span class="entity">Util.dest_args</span> <span class="entity">t</span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">count_var</span> <span class="entity">t</span> <span class="main">=</span> length <span class="main">(</span>Term.add_vars <span class="entity">t</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">nvar</span> <span class="main">=</span> <span class="entity">count_var</span> <span class="entity">t</span>

        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_matches</span> <span class="entity">i</span> <span class="main">=</span>
            <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">count_var</span> <span class="main">(</span>nth <span class="entity">args</span> <span class="entity">i</span><span class="main">)</span> &lt; <span class="entity">nvar</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span> <span class="keyword2"><span class="keyword">else</span></span>
            <span class="keyword2"><span class="keyword">let</span></span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg</span> <span class="main">=</span> nth <span class="entity">args</span> <span class="entity">i</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">targ</span> <span class="main">=</span> <span class="entity">TypedMatch</span> <span class="main">(</span><span class="entity">TY_TERM</span><span class="main">,</span> <span class="entity">arg</span><span class="main">)</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">insts</span> <span class="main">=</span> <span class="main">(</span><span class="entity">ItemIO.match_arg</span> <span class="entity">ctxt</span> <span class="entity">targ</span> <span class="entity">item2</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">fo_init</span><span class="main">)</span><span class="main">)</span>
                              |&gt; filter <span class="main">(</span><span class="entity">BoxID.has_incr_id</span> o fst o fst<span class="main">)</span>
              <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">inst_to_updt</span> <span class="main">(</span><span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span>
                  <span class="keyword2"><span class="keyword">let</span></span>
                    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th1'</span> <span class="main">=</span> <span class="entity">Util.subst_thm_thy</span> <span class="entity">thy</span> <span class="entity">inst</span> <span class="entity">th1</span>
                    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prop'</span> <span class="main">=</span> <span class="entity">prop_of'</span> <span class="entity">th1'</span>
                  <span class="keyword2"><span class="keyword">in</span></span>
                    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_eq_term</span> <span class="entity">prop'</span> <span class="keyword1"><span class="keyword">andalso</span></span>
                       <span class="entity">RewriteTable.is_equiv_t</span> <span class="entity">id'</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">dest_eq</span> <span class="entity">prop'</span><span class="main">)</span>
                    <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="entity">Update.thm_update</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">th1'</span><span class="main">)</span><span class="main">]</span>
                  <span class="keyword2"><span class="keyword">end</span></span>
            <span class="keyword2"><span class="keyword">in</span></span>
              maps <span class="entity">inst_to_updt</span> <span class="entity">insts</span>
            <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword2"><span class="keyword">in</span></span>
        maps <span class="entity">get_matches</span> <span class="main">(</span><span class="inner_numeral">0</span> upto <span class="main">(</span>length <span class="entity">args</span> - <span class="inner_numeral">1</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">match_one_sch_prfstep</span> <span class="main">=</span>
    <span class="main">{</span>name <span class="main">=</span> <span class="inner_quoted">"disj_match_one_sch"</span><span class="main">,</span>
     args <span class="main">=</span> <span class="main">[</span><span class="entity">TypedUniv</span> <span class="entity">TY_DISJ</span><span class="main">,</span> <span class="entity">TypedUniv</span> <span class="entity">TY_TERM</span><span class="main">]</span><span class="main">,</span>
     func <span class="main">=</span> <span class="entity">TwoStep</span> <span class="entity">match_one_sch_fn</span><span class="main">}</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">disj_match_iff_fn</span> <span class="entity">ctxt</span> <span class="main">{</span><span class="entity">id</span><span class="main">,</span> <span class="entity">tname</span><span class="main">,</span> <span class="entity">prop</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span><span class="entity">BoxID.has_incr_id</span> <span class="entity">id</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span> <span class="keyword2"><span class="keyword">else</span></span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">csubs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">dest_tname_of_disj</span> <span class="entity">tname</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">subs</span> <span class="main">=</span> map Thm.term_of <span class="entity">csubs</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> length <span class="entity">subs</span> &gt; <span class="inner_numeral">1</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span><span class="entity">is_eq_term</span> <span class="main">(</span>the_single <span class="entity">subs</span><span class="main">)</span> <span class="keyword1"><span class="keyword">andalso</span></span>
              fastype_of <span class="main">(</span><span class="entity">dest_arg</span> <span class="main">(</span>the_single <span class="entity">subs</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">boolT</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cv</span> <span class="main">=</span> <span class="main">(</span><span class="entity">UtilLogic.to_obj_conv</span> <span class="entity">ctxt</span><span class="main">)</span> then_conv <span class="main">(</span><span class="entity">Trueprop_conv</span> <span class="entity">norm_disj</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">forward</span> <span class="main">=</span> <span class="entity">prop</span> |&gt; <span class="entity">UtilLogic.equiv_forward_th</span> |&gt; <span class="entity">apply_to_thm</span> <span class="entity">cv</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">backward</span> <span class="main">=</span> <span class="entity">prop</span> |&gt; <span class="entity">UtilLogic.equiv_backward_th</span> |&gt; <span class="entity">apply_to_thm</span> <span class="entity">cv</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">[</span><span class="entity">disj_to_update</span> false <span class="entity">imp</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> NONE<span class="main">,</span> <span class="entity">forward</span><span class="main">)</span><span class="main">,</span>
         <span class="entity">disj_to_update</span> false <span class="entity">imp</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> NONE<span class="main">,</span> <span class="entity">backward</span><span class="main">)</span><span class="main">]</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">disj_match_iff_prfstep</span> <span class="main">=</span>
    <span class="main">{</span>name <span class="main">=</span> <span class="inner_quoted">"disj_match_iff"</span><span class="main">,</span>
     args <span class="main">=</span> <span class="main">[</span><span class="entity">TypedUniv</span> <span class="entity">TY_DISJ</span><span class="main">]</span><span class="main">,</span>
     func <span class="main">=</span> <span class="entity">OneStep</span> <span class="entity">disj_match_iff_fn</span><span class="main">}</span>

<span class="comment1">(* For active case, create box checking the next case. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">disj_create_case_fn</span> <span class="main">_</span> <span class="main">{</span><span class="entity">id</span><span class="main">,</span> <span class="entity">tname</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span><span class="entity">BoxID.has_incr_id</span> <span class="entity">id</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span> <span class="keyword2"><span class="keyword">else</span></span>
    <span class="keyword2"><span class="keyword">if</span></span> exists <span class="entity">Util.has_vars</span> <span class="main">(</span>map Thm.term_of <span class="entity">tname</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span> <span class="keyword2"><span class="keyword">else</span></span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">disj_head</span><span class="main">,</span> <span class="entity">csubs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">dest_tname_of_disj</span> <span class="entity">tname</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span><span class="entity">is_active_head</span> <span class="entity">disj_head</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> length <span class="entity">csubs</span> <span class="main">=</span> <span class="inner_numeral">1</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">subs</span> <span class="main">=</span> map Thm.term_of <span class="entity">csubs</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">[</span><span class="entity">AddBoxes</span> <span class="main">{</span>id <span class="main">=</span> <span class="entity">id</span><span class="main">,</span>
                   sc <span class="main">=</span> NONE<span class="main">,</span> init_assum <span class="main">=</span> <span class="entity">mk_Trueprop</span> <span class="main">(</span>hd <span class="entity">subs</span><span class="main">)</span><span class="main">}</span><span class="main">]</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">disj_create_case_prfstep</span> <span class="main">=</span>
    <span class="main">{</span>name <span class="main">=</span> <span class="inner_quoted">"disj_create_case"</span><span class="main">,</span>
     args <span class="main">=</span> <span class="main">[</span><span class="entity">TypedUniv</span> <span class="entity">TY_DISJ</span><span class="main">]</span><span class="main">,</span>
     func <span class="main">=</span> <span class="entity">OneStep</span> <span class="entity">disj_create_case_fn</span><span class="main">}</span>

<span class="comment1">(* item1 dominates item2 if the disjunctive terms in item1 is a subset
   of that for item2.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">disj_shadow_fn</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">item1</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">{</span>tname <span class="main">=</span> <span class="entity">tname1</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span>
                   <span class="main">(</span><span class="entity">item2</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">{</span>tname <span class="main">=</span> <span class="entity">tname2</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">id</span> <span class="main">=</span> <span class="entity">BoxItem.merged_id</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">item1</span><span class="main">,</span> <span class="entity">item2</span><span class="main">]</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">disj_head1</span><span class="main">,</span> <span class="entity">subs1</span><span class="main">)</span> <span class="main">=</span> <span class="entity">dest_tname_of_disj</span> <span class="entity">tname1</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">disj_head2</span><span class="main">,</span> <span class="entity">subs2</span><span class="main">)</span> <span class="main">=</span> <span class="entity">dest_tname_of_disj</span> <span class="entity">tname2</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span><span class="entity">BoxID.has_incr_id</span> <span class="entity">id</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span> <span class="keyword2"><span class="keyword">else</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span><span class="entity">is_active_head</span> <span class="entity">disj_head1</span><span class="main">)</span> <span class="keyword1"><span class="keyword">andalso</span></span>
         <span class="entity">is_active_head</span> <span class="entity">disj_head2</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_match_prem_only</span> <span class="entity">item1</span> <span class="keyword1"><span class="keyword">andalso</span></span>
              not <span class="main">(</span><span class="entity">is_match_prem_only</span> <span class="entity">item2</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> subset <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconvc<span class="main">)</span> <span class="main">(</span><span class="entity">subs1</span><span class="main">,</span> <span class="entity">subs2</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="main">[</span><span class="entity">ShadowItem</span> <span class="main">{</span>id <span class="main">=</span> <span class="entity">id</span><span class="main">,</span> item <span class="main">=</span> <span class="entity">item2</span><span class="main">}</span><span class="main">]</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">disj_shadow_prfstep</span> <span class="main">=</span>
    <span class="main">{</span>name <span class="main">=</span> <span class="inner_quoted">"disj_shadow"</span><span class="main">,</span>
     args <span class="main">=</span> <span class="main">[</span><span class="entity">TypedUniv</span> <span class="entity">TY_DISJ</span><span class="main">,</span> <span class="entity">TypedUniv</span> <span class="entity">TY_DISJ</span><span class="main">]</span><span class="main">,</span>
     func <span class="main">=</span> <span class="entity">TwoStep</span> <span class="entity">disj_shadow_fn</span><span class="main">}</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">add_disj_proofsteps</span> <span class="main">=</span>
    fold <span class="entity">ItemIO.add_item_type</span> <span class="main">[</span>
      <span class="main">(</span><span class="entity">TY_DISJ</span><span class="main">,</span> SOME <span class="entity">disj_rewr_terms</span><span class="main">,</span> SOME <span class="entity">output_disj_fn</span><span class="main">,</span> NONE<span class="main">)</span>

    <span class="main">]</span> #&gt; fold <span class="entity">ItemIO.add_prop_matcher</span> <span class="main">[</span>
      <span class="main">(</span><span class="entity">TY_DISJ</span><span class="main">,</span> <span class="entity">disj_prop_matcher</span><span class="main">)</span>

    <span class="main">]</span> #&gt; fold <span class="entity">add_prfstep</span> <span class="main">[</span>
      <span class="entity">match_update_prfstep</span><span class="main">,</span> <span class="entity">match_one_sch_prfstep</span><span class="main">,</span> <span class="entity">disj_match_iff_prfstep</span><span class="main">,</span>
      <span class="entity">disj_create_case_prfstep</span><span class="main">,</span> <span class="entity">disj_shadow_prfstep</span>
    <span class="main">]</span>

<span class="comment1">(* Normalizers *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">split_not_imp_th</span> <span class="entity">th</span> <span class="main">=</span>
    <span class="entity">th</span> |&gt; <span class="entity">apply_to_thm'</span> <span class="entity">norm_conj_not_imp</span>
       |&gt; <span class="entity">UtilLogic.split_conj_th</span>

<span class="comment1">(* Generalized form of splitting A &amp; B. Also deal with cases ~(A | B)
   and ~(A --&gt; B).
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">split_conj_gen_th</span> <span class="main">_</span> <span class="entity">th</span> <span class="main">=</span>
    <span class="entity">th</span> |&gt; <span class="entity">apply_to_thm'</span> <span class="entity">norm_conj</span>
       |&gt; <span class="entity">UtilLogic.split_conj_th</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">eq_normalizer</span> <span class="main">_</span> <span class="entity">ritem</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">ritem</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="entity">Handler</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="entity">ritem</span><span class="main">]</span>
      <span class="main">|</span> <span class="entity">Fact</span> <span class="main">(</span><span class="entity">ty_str</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">ty_str</span> &lt;&gt; <span class="entity">TY_PROP</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="entity">ritem</span><span class="main">]</span>
        <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_eq_term</span> <span class="main">(</span><span class="entity">prop_of'</span> <span class="entity">th</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">dest_eq</span> <span class="main">(</span><span class="entity">prop_of'</span> <span class="entity">th</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="keyword2"><span class="keyword">if</span></span> fastype_of <span class="entity">lhs</span> <span class="main">=</span> <span class="entity">boolT</span> <span class="keyword2"><span class="keyword">then</span></span>
              map <span class="entity">Update.thm_to_ritem</span>
                  <span class="main">(</span><span class="entity">UtilLogic.split_conj_th</span> <span class="main">(</span><span class="entity">th</span> RS <span class="entity">UtilBase.iffD_th</span><span class="main">)</span><span class="main">)</span>
            <span class="keyword2"><span class="keyword">else</span></span>
              <span class="main">[</span><span class="entity">Fact</span> <span class="main">(</span><span class="entity">TY_EQ</span><span class="main">,</span> <span class="main">[</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">]</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">]</span>
          <span class="keyword2"><span class="keyword">end</span></span>
        <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="entity">ritem</span><span class="main">]</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">property_normalizer</span> <span class="main">_</span> <span class="entity">ritem</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">ritem</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="entity">Handler</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="entity">ritem</span><span class="main">]</span>
      <span class="main">|</span> <span class="entity">Fact</span> <span class="main">(</span><span class="entity">ty_str</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">ty_str</span> &lt;&gt; <span class="entity">TY_PROP</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="entity">ritem</span><span class="main">]</span>
        <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">Property.is_property</span> <span class="main">(</span><span class="entity">prop_of'</span> <span class="entity">th</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
          <span class="main">[</span><span class="entity">Fact</span> <span class="main">(</span><span class="entity">TY_PROPERTY</span><span class="main">,</span> <span class="main">[</span><span class="entity">prop_of'</span> <span class="entity">th</span><span class="main">]</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">]</span>
        <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="entity">ritem</span><span class="main">]</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">disj_normalizer</span> <span class="entity">ctxt</span> <span class="entity">ritem</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">ritem</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="entity">Handler</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="entity">ritem</span><span class="main">]</span>
      <span class="main">|</span> <span class="entity">Fact</span> <span class="main">(</span><span class="entity">ty_str</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">ty_str</span> &lt;&gt; <span class="entity">TY_PROP</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="entity">ritem</span><span class="main">]</span>
        <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">prop_of'</span> <span class="entity">th</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_neg</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_conj</span> <span class="main">(</span><span class="entity">dest_not</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword1"><span class="keyword">orelse</span></span>
             <span class="entity">is_disj</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">orelse</span></span> <span class="entity">is_imp</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">orelse</span></span>
             <span class="entity">is_obj_all</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">orelse</span></span> <span class="entity">is_ball</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">orelse</span></span>
             <span class="entity">is_neg</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_ex</span> <span class="main">(</span><span class="entity">dest_not</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword1"><span class="keyword">orelse</span></span>
             <span class="entity">is_neg</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_bex</span> <span class="main">(</span><span class="entity">dest_not</span> <span class="entity">t</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">then</span></span>
            <span class="keyword2"><span class="keyword">let</span></span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">disj_head</span><span class="main">,</span> <span class="entity">disj_th</span><span class="main">)</span> <span class="main">=</span> <span class="entity">analyze_disj_th</span> <span class="entity">ctxt</span> <span class="entity">th</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prem_only</span> <span class="main">=</span> <span class="entity">Auto2_State.lookup_prem_only</span> <span class="entity">ctxt</span> <span class="entity">t</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">disj_th</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">prem_only</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">disj_th</span>
                            <span class="keyword2"><span class="keyword">else</span></span> snd <span class="main">(</span><span class="entity">Normalizer.meta_use_vardefs</span> <span class="entity">disj_th</span><span class="main">)</span>
            <span class="keyword2"><span class="keyword">in</span></span>
              <span class="entity">disj_to_ritems</span> <span class="entity">prem_only</span> <span class="entity">disj_head</span> <span class="entity">disj_th</span>
            <span class="keyword2"><span class="keyword">end</span></span>
          <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="entity">ritem</span><span class="main">]</span>
        <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">logic_thm_update</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">prop_of'</span> <span class="entity">th</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_obj_all</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">orelse</span></span> <span class="entity">is_ball</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">orelse</span></span>
         <span class="entity">is_neg</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_ex</span> <span class="main">(</span><span class="entity">dest_not</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword1"><span class="keyword">orelse</span></span>
         <span class="entity">is_neg</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_bex</span> <span class="main">(</span><span class="entity">dest_not</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword1"><span class="keyword">orelse</span></span>
         <span class="entity">is_disj</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">orelse</span></span> <span class="entity">is_imp</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">orelse</span></span>
         <span class="entity">is_neg</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_conj</span> <span class="main">(</span><span class="entity">dest_not</span> <span class="entity">t</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">then</span></span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">disj_head</span><span class="main">,</span> <span class="entity">disj_th</span><span class="main">)</span> <span class="main">=</span> <span class="entity">analyze_disj_th</span> <span class="entity">ctxt</span> <span class="entity">th</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">raw_items</span> <span class="main">=</span> <span class="entity">disj_to_ritems</span> true <span class="entity">disj_head</span> <span class="entity">disj_th</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="entity">AddItems</span> <span class="main">{</span>id <span class="main">=</span> <span class="entity">id</span><span class="main">,</span> sc <span class="main">=</span> NONE<span class="main">,</span> raw_items <span class="main">=</span> <span class="entity">raw_items</span><span class="main">}</span>
        <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="entity">Update.thm_update</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">add_disj_normalizers</span> <span class="main">=</span>
    <span class="entity">Normalizer.add_th_normalizer</span> <span class="main">(</span>
      <span class="inner_quoted">"split_conj_gen"</span><span class="main">,</span> <span class="entity">split_conj_gen_th</span>

    <span class="main">)</span> #&gt; fold <span class="entity">Normalizer.add_normalizer</span> <span class="main">[</span>
      <span class="main">(</span><span class="inner_quoted">"eq"</span><span class="main">,</span> <span class="entity">eq_normalizer</span><span class="main">)</span><span class="main">,</span>
      <span class="main">(</span><span class="inner_quoted">"property"</span><span class="main">,</span> <span class="entity">property_normalizer</span><span class="main">)</span><span class="main">,</span>
      <span class="main">(</span><span class="inner_quoted">"disj"</span><span class="main">,</span> <span class="entity">disj_normalizer</span><span class="main">)</span>
    <span class="main">]</span>

<span class="keyword2"><span class="keyword">end</span></span>  <span class="comment1">(* structure Logic_ProofSteps. *)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> Theory.setup <span class="entity">Logic_ProofSteps.add_logic_proofsteps</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> Theory.setup <span class="entity">Logic_ProofSteps.add_disj_proofsteps</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> Theory.setup <span class="entity">Logic_ProofSteps.add_disj_normalizers</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">TY_DISJ</span> <span class="main">=</span> <span class="entity">Logic_ProofSteps.TY_DISJ</span>
</pre>
</div><div id="files/AFP/Auto2_HOL/auto2.ML">
<div class="head">
<h1>File ‹$AFP/Auto2_HOL/auto2.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*
  Title: auto2.ML
  Author: Bohua Zhan

  Main file defining inference algorithm and tactic.
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">SCORES</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> item_score<span class="main">:</span> <span class="entity">raw_item</span> <span class="main">-&gt;</span> int
  <span class="keyword1"><span class="keyword">val</span></span> items_score<span class="main">:</span> <span class="entity">raw_item</span> list <span class="main">-&gt;</span> int
  <span class="keyword1"><span class="keyword">val</span></span> get_score<span class="main">:</span> <span class="entity">raw_update</span> <span class="main">-&gt;</span> int
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Scores</span> <span class="main">:</span> <span class="entity">SCORES</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">item_score</span> <span class="entity">ritem</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">ritem</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="entity">Handler</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="inner_numeral">0</span>
      <span class="main">|</span> <span class="entity">Fact</span> <span class="main">(</span><span class="entity">ty_str</span><span class="main">,</span> <span class="entity">tname</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">ty_str</span> <span class="main">=</span> <span class="entity">TY_VAR</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="inner_numeral">10</span>  <span class="comment1">(* cost of introducing a variable. *)</span>
        <span class="keyword2"><span class="keyword">else</span></span> Integer.sum <span class="main">(</span>map size_of_term <span class="entity">tname</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">items_score</span> <span class="entity">raw_items</span> <span class="main">=</span> <span class="entity">Util.max</span> int_ord <span class="main">(</span>map <span class="entity">item_score</span> <span class="entity">raw_items</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_score</span> <span class="entity">raw_updt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">raw_updt</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="entity">AddItems</span> <span class="main">{</span><span class="entity">raw_items</span><span class="main">,</span> <span class="entity">sc</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
        <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">sc</span> <span class="keyword2"><span class="keyword">of</span></span> NONE <span class="main">=&gt;</span> <span class="entity">items_score</span> <span class="entity">raw_items</span> <span class="main">|</span> SOME <span class="entity">n</span> <span class="main">=&gt;</span> <span class="entity">n</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">AddBoxes</span> <span class="main">{</span><span class="entity">init_assum</span><span class="main">,</span> <span class="entity">sc</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
        <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">sc</span> <span class="keyword2"><span class="keyword">of</span></span> NONE <span class="main">=&gt;</span> <span class="inner_numeral">20</span> + <span class="inner_numeral">5</span> * size_of_term <span class="entity">init_assum</span>
                  <span class="main">|</span> SOME <span class="entity">n</span> <span class="main">=&gt;</span> <span class="entity">n</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">ResolveBox</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="inner_numeral">~1</span>
      <span class="main">|</span> <span class="entity">ShadowItem</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="inner_numeral">~1</span>

<span class="keyword2"><span class="keyword">end</span></span>  <span class="comment1">(* structure SCORES. *)</span>

<span class="comment1">(* Flags specifying output options. *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">print_trace</span> <span class="main">=</span>
    <span class="entity">Attrib.setup_config_bool</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">binding</span> "print_trace"<span class="antiquote">}</span></span></span> <span class="main">(</span>K false<span class="main">)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">print_intended</span> <span class="main">=</span>
    <span class="entity">Attrib.setup_config_bool</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">binding</span> "print_intended"<span class="antiquote">}</span></span></span> <span class="main">(</span>K false<span class="main">)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">print_term</span> <span class="main">=</span>
    <span class="entity">Attrib.setup_config_bool</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">binding</span> "print_term"<span class="antiquote">}</span></span></span> <span class="main">(</span>K false<span class="main">)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">print_shadow</span> <span class="main">=</span>
    <span class="entity">Attrib.setup_config_bool</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">binding</span> "print_shadow"<span class="antiquote">}</span></span></span> <span class="main">(</span>K false<span class="main">)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">print_score</span> <span class="main">=</span>
    <span class="entity">Attrib.setup_config_bool</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">binding</span> "print_score"<span class="antiquote">}</span></span></span> <span class="main">(</span>K false<span class="main">)</span>

<span class="comment1">(* Flag specifying the maximum number of steps. *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">max_steps</span> <span class="main">=</span>
    <span class="entity">Attrib.setup_config_int</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">binding</span> "max_steps"<span class="antiquote">}</span></span></span> <span class="main">(</span>K <span class="inner_numeral">2000</span><span class="main">)</span>

<span class="comment1">(* Proof status. Manages changes to proof status, and main loop
   carrying out proof steps and adding new proof steps to the queue.
 *)</span>
<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">PROOFSTATUS</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> check_hyps<span class="main">:</span> <span class="entity">box_id</span> <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> <span class="entity">status</span> <span class="main">-&gt;</span> unit
  <span class="keyword1"><span class="keyword">val</span></span> scoring<span class="main">:</span> <span class="entity">proofstep</span> <span class="main">-&gt;</span> int <span class="main">-&gt;</span> <span class="entity">box_item</span> list <span class="main">-&gt;</span> <span class="entity">status</span> <span class="main">-&gt;</span>
               <span class="main">(</span><span class="entity">box_item</span> <span class="main">-&gt;</span> <span class="entity">raw_update</span> list<span class="main">)</span> <span class="main">-&gt;</span> <span class="entity">update</span> list
  <span class="keyword1"><span class="keyword">val</span></span> process_shadow<span class="main">:</span> <span class="entity">update</span> <span class="main">-&gt;</span> <span class="entity">status</span> <span class="main">-&gt;</span> <span class="entity">status</span>
  <span class="keyword1"><span class="keyword">val</span></span> process_resolve<span class="main">:</span> <span class="entity">update</span> <span class="main">-&gt;</span> <span class="entity">status</span> <span class="main">-&gt;</span> <span class="entity">status</span>
  <span class="keyword1"><span class="keyword">val</span></span> apply_update_instant<span class="main">:</span> <span class="entity">update</span> <span class="main">-&gt;</span> <span class="entity">status</span> <span class="main">-&gt;</span> <span class="entity">status</span>
  <span class="keyword1"><span class="keyword">val</span></span> process_fact_all<span class="main">:</span> <span class="entity">box_id</span> <span class="main">-&gt;</span> int <span class="main">-&gt;</span> <span class="entity">box_item</span> list <span class="main">-&gt;</span> <span class="entity">status</span> <span class="main">-&gt;</span> <span class="entity">status</span>
  <span class="keyword1"><span class="keyword">val</span></span> process_add_items<span class="main">:</span> <span class="entity">update</span> <span class="main">-&gt;</span> <span class="entity">status</span> <span class="main">-&gt;</span> <span class="entity">status</span>
  <span class="keyword1"><span class="keyword">val</span></span> process_add_boxes<span class="main">:</span> <span class="entity">update</span> <span class="main">-&gt;</span> <span class="entity">status</span> <span class="main">-&gt;</span> <span class="entity">status</span>
  <span class="keyword1"><span class="keyword">val</span></span> apply_update<span class="main">:</span> <span class="entity">update</span> <span class="main">-&gt;</span> <span class="entity">status</span> <span class="main">-&gt;</span> <span class="entity">status</span>
  <span class="keyword1"><span class="keyword">val</span></span> init_status<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> <span class="entity">status</span>
  <span class="keyword1"><span class="keyword">val</span></span> solve_root<span class="main">:</span> int * <span class="entity">status</span> <span class="main">-&gt;</span> int * <span class="entity">status</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">ProofStatus</span> <span class="main">:</span> <span class="entity">PROOFSTATUS</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">check_hyps</span> <span class="entity">id</span> <span class="entity">th</span> <span class="main">(</span><span class="entity">st</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">{</span><span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">hyps</span> <span class="main">=</span> Thm.hyps_of <span class="entity">th</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inits</span> <span class="main">=</span> <span class="entity">Status.get_init_assums</span> <span class="entity">st</span> <span class="entity">id</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">handlers</span> <span class="main">=</span>
          <span class="main">(</span><span class="entity">Status.get_handlers</span> <span class="entity">st</span><span class="main">)</span>
              |&gt; filter <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">BoxID.is_eq_ancestor</span> <span class="entity">ctxt</span> <span class="entity">id'</span> <span class="entity">id</span><span class="main">)</span>
              |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">t</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">t</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">extra</span> <span class="main">=</span> subtract <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv<span class="main">)</span> <span class="main">(</span><span class="entity">inits</span> @ <span class="entity">handlers</span><span class="main">)</span> <span class="entity">hyps</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">extra</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_tlist</span> <span class="entity">ctxt</span> <span class="inner_quoted">"extra:"</span> <span class="entity">extra</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"illegal hyp"</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Perform preliminary checks before matching the last item of a
   proofstep, and process the resulting updates.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">scoring</span> <span class="main">{</span><span class="entity">name</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="entity">sc</span> <span class="entity">items</span> <span class="main">(</span><span class="entity">st</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">{</span><span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="entity">func</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">merged_id</span> <span class="main">=</span> <span class="entity">BoxItem.merged_id</span> <span class="entity">ctxt</span> <span class="entity">items</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">BoxID.is_box_resolved</span> <span class="entity">ctxt</span> <span class="entity">merged_id</span> <span class="keyword1"><span class="keyword">orelse</span></span>
         exists <span class="main">(</span><span class="entity">Status.query_shadowed</span> <span class="entity">st</span> <span class="entity">merged_id</span><span class="main">)</span> <span class="entity">items</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">scs</span> <span class="main">=</span> map <span class="main">#</span>sc <span class="entity">items</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">max_sc</span> <span class="main">=</span> fold <span class="main">(</span>curry Int.max<span class="main">)</span> <span class="entity">scs</span> <span class="entity">sc</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">raw_updts</span> <span class="main">=</span> <span class="main">(</span><span class="entity">func</span> <span class="main">(</span>List.last <span class="entity">items</span><span class="main">)</span><span class="main">)</span>
                              |&gt; map <span class="entity">Update.replace_id_of_update</span>
          <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_raw_updt</span> <span class="entity">raw_updt</span> <span class="main">=</span>
              <span class="keyword2"><span class="keyword">let</span></span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">id</span> <span class="main">=</span> <span class="entity">Update.target_of_update</span> <span class="entity">raw_updt</span>
              <span class="keyword2"><span class="keyword">in</span></span>
                <span class="comment1">(* Perform resolved and shadowed tests again since id
                   may be descendent of merged_id.
                 *)</span>
                <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">BoxID.is_box_resolved</span> <span class="entity">ctxt</span> <span class="entity">id</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span>
                <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> exists <span class="main">(</span><span class="entity">Status.query_shadowed</span> <span class="entity">st</span> <span class="entity">id</span><span class="main">)</span> <span class="entity">items</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span>
                <span class="keyword2"><span class="keyword">else</span></span>
                  <span class="main">[</span><span class="main">{</span>sc <span class="main">=</span> <span class="entity">Scores.get_score</span> <span class="entity">raw_updt</span> + <span class="entity">max_sc</span><span class="main">,</span> prfstep_name <span class="main">=</span> <span class="entity">name</span><span class="main">,</span>
                    source <span class="main">=</span> <span class="entity">items</span><span class="main">,</span> raw_updt <span class="main">=</span> <span class="entity">raw_updt</span><span class="main">}</span><span class="main">]</span>
              <span class="keyword2"><span class="keyword">end</span></span>
        <span class="keyword2"><span class="keyword">in</span></span>
          maps <span class="entity">process_raw_updt</span> <span class="entity">raw_updts</span>
        <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_shadow</span> <span class="main">(</span><span class="entity">updt</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">{</span><span class="entity">raw_updt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="entity">st</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">{</span><span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">raw_updt</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="entity">ShadowItem</span> <span class="main">{</span>id <span class="main">=</span> <span class="entity">shadow_id</span><span class="main">,</span> <span class="entity">item</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">{</span><span class="entity">ty_str</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">}</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span>Config.get <span class="entity">ctxt</span> <span class="entity">print_trace</span><span class="main">)</span> <span class="keyword1"><span class="keyword">orelse</span></span>
                     not <span class="main">(</span>Config.get <span class="entity">ctxt</span> <span class="entity">print_shadow</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">)</span>
                  <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">ty_str</span> <span class="main">=</span> <span class="entity">TY_TERM</span> <span class="keyword1"><span class="keyword">andalso</span></span>
                          not <span class="main">(</span>Config.get <span class="entity">ctxt</span> <span class="entity">print_term</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">)</span>
                  <span class="keyword2"><span class="keyword">else</span></span> tracing <span class="main">(</span><span class="inner_quoted">"Shadowing "</span> ^
                                <span class="entity">ItemIO.string_of_item</span> <span class="entity">ctxt</span> <span class="entity">item</span> ^
                                <span class="inner_quoted">" at box "</span> ^ <span class="entity">BoxID.string_of_box_id</span> <span class="entity">shadow_id</span> ^
                                <span class="inner_quoted">" ("</span> ^ <span class="entity">Update.source_info</span> <span class="entity">updt</span> ^ <span class="inner_quoted">")"</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="entity">st</span> |&gt; <span class="entity">Status.add_shadowed</span> <span class="main">(</span><span class="entity">shadow_id</span><span class="main">,</span> <span class="entity">item</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">end</span></span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"process_shadow: wrong type of update"</span>

<span class="comment1">(* When a box, whether primitive or composite, is resolved, perform
   the following two actions: 1. Resolve current and all descendent
   boxes. 2. Add the appropriate fact to each of the immediate parent
   boxes.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_resolve</span> <span class="main">(</span><span class="entity">updt</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">{</span><span class="entity">sc</span><span class="main">,</span> <span class="entity">raw_updt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="entity">st</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">{</span><span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">raw_updt</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="entity">ResolveBox</span> <span class="main">{</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">}</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> Config.get <span class="entity">ctxt</span> <span class="entity">print_trace</span> <span class="keyword2"><span class="keyword">then</span></span>
                    tracing <span class="main">(</span><span class="inner_quoted">"Finished box "</span> ^ <span class="entity">BoxID.string_of_box_id</span> <span class="entity">id</span> ^
                             <span class="inner_quoted">" ("</span> ^ <span class="entity">Update.source_info</span> <span class="entity">updt</span> ^ <span class="inner_quoted">")"</span><span class="main">)</span>
                  <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="main">)</span>

          <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">update_one</span> <span class="entity">i</span> <span class="entity">st</span> <span class="main">=</span>
              <span class="keyword2"><span class="keyword">let</span></span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cur_parent</span> <span class="main">=</span> <span class="entity">BoxID.get_parent_at_i</span> <span class="entity">ctxt</span> <span class="entity">id</span> <span class="entity">i</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">res_th</span> <span class="main">=</span> <span class="entity">Status.get_on_resolve</span> <span class="entity">st</span> <span class="entity">id</span> <span class="entity">i</span> <span class="entity">th</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">check_hyps</span> <span class="entity">cur_parent</span> <span class="entity">res_th</span> <span class="entity">st</span>

                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">res_obj_th</span> <span class="main">=</span> <span class="entity">apply_to_thm</span> <span class="main">(</span><span class="entity">UtilLogic.to_obj_conv</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">res_th</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">updt</span> <span class="main">=</span> <span class="main">{</span>sc <span class="main">=</span> <span class="entity">sc</span><span class="main">,</span> prfstep_name <span class="main">=</span> <span class="inner_quoted">"$RESOLVE"</span><span class="main">,</span> source <span class="main">=</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span>
                            raw_updt <span class="main">=</span> <span class="entity">Logic_ProofSteps.logic_thm_update</span>
                                           <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">cur_parent</span><span class="main">,</span> <span class="entity">res_obj_th</span><span class="main">)</span><span class="main">}</span>
              <span class="keyword2"><span class="keyword">in</span></span>
                <span class="entity">st</span> |&gt; <span class="entity">apply_update_instant</span> <span class="entity">updt</span>
              <span class="keyword2"><span class="keyword">end</span></span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">BoxID.is_box_resolved</span> <span class="entity">ctxt</span> <span class="entity">id</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">st</span>
          <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">id</span> <span class="main">=</span> <span class="main">[</span><span class="entity">BoxID.home_id</span><span class="main">]</span> <span class="keyword2"><span class="keyword">then</span></span>
            <span class="entity">st</span> |&gt; <span class="entity">Status.set_resolve_th</span> <span class="main">(</span><span class="entity">Status.get_on_resolve</span> <span class="entity">st</span> <span class="entity">id</span> <span class="inner_numeral">0</span> <span class="entity">th</span><span class="main">)</span>
               |&gt; <span class="entity">Status.add_resolved</span> <span class="entity">id</span>
          <span class="keyword2"><span class="keyword">else</span></span>
            <span class="entity">st</span> |&gt; fold <span class="entity">update_one</span> <span class="main">(</span><span class="inner_numeral">0</span> upto <span class="main">(</span>length <span class="entity">id</span><span class="main">)</span> - <span class="inner_numeral">1</span><span class="main">)</span>
               |&gt; <span class="entity">Status.add_resolved</span> <span class="entity">id</span>
        <span class="keyword2"><span class="keyword">end</span></span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"process_resolve: wrong type of update"</span>

<span class="comment1">(* Directly apply Shadow and Resolve updates. Put the remaining
   updates in queue.
*)</span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">apply_update_instant</span> <span class="main">(</span><span class="entity">updt</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">{</span><span class="entity">raw_updt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="entity">st</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">{</span><span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">id</span> <span class="main">=</span> <span class="entity">Update.target_of_update</span> <span class="entity">raw_updt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span>not <span class="main">(</span><span class="entity">BoxID.has_incr_id</span> <span class="entity">id</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">BoxID.is_box_resolved</span> <span class="entity">ctxt</span> <span class="entity">id</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">st</span> <span class="keyword2"><span class="keyword">else</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">raw_updt</span> <span class="keyword2"><span class="keyword">of</span></span>
          <span class="entity">ResolveBox</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">process_resolve</span> <span class="entity">updt</span> <span class="entity">st</span>
        <span class="main">|</span> <span class="entity">ShadowItem</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">process_shadow</span> <span class="entity">updt</span> <span class="entity">st</span>
        <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">Status.add_to_queue</span> <span class="entity">updt</span> <span class="entity">st</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_step_single</span> <span class="entity">sc</span> <span class="entity">items</span> <span class="entity">prfstep</span> <span class="main">(</span><span class="entity">st</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">{</span><span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">args</span><span class="main">,</span> <span class="entity">func</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">prfstep</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg</span> <span class="main">=</span> the_single <span class="main">(</span>filter_out <span class="entity">ItemIO.is_side_match</span> <span class="entity">args</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">items'</span> <span class="main">=</span> filter <span class="main">(</span><span class="entity">ItemIO.pre_match_arg</span> <span class="entity">ctxt</span> <span class="entity">arg</span><span class="main">)</span> <span class="entity">items</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">f</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">func</span> <span class="keyword2"><span class="keyword">of</span></span>
                  <span class="entity">OneStep</span> <span class="entity">f</span> <span class="main">=&gt;</span> <span class="entity">f</span>
                <span class="main">|</span> <span class="entity">TwoStep</span> <span class="main">_</span> <span class="main">=&gt;</span>
                  <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"process_step_single: wrong type of func."</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_one_item</span> <span class="entity">item</span> <span class="entity">st</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">updts</span> <span class="main">=</span> <span class="entity">scoring</span> <span class="entity">prfstep</span> <span class="entity">sc</span> <span class="main">[</span><span class="entity">item</span><span class="main">]</span> <span class="entity">st</span> <span class="main">(</span><span class="entity">f</span> <span class="entity">ctxt</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="entity">st</span> |&gt; fold <span class="entity">apply_update_instant</span> <span class="entity">updts</span>
          <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">st</span> |&gt; fold <span class="entity">process_one_item</span> <span class="entity">items'</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_step_pair</span> <span class="entity">sc</span> <span class="entity">items</span> <span class="entity">items'</span> <span class="entity">prfstep</span> <span class="main">(</span><span class="entity">st</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">{</span><span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">args</span><span class="main">,</span> <span class="entity">func</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">prfstep</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">arg1</span><span class="main">,</span> <span class="entity">arg2</span><span class="main">)</span> <span class="main">=</span> <span class="entity">the_pair</span> <span class="main">(</span>filter_out <span class="entity">ItemIO.is_side_match</span> <span class="entity">args</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">f</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">func</span> <span class="keyword2"><span class="keyword">of</span></span>
                  <span class="entity">TwoStep</span> <span class="entity">f</span> <span class="main">=&gt;</span> <span class="entity">f</span>
                <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"process_step_pair: wrong type of func."</span>

      <span class="comment1">(* Filter the two lists of items using pre_match_arg. *)</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">filter_pairs</span> <span class="main">(</span><span class="entity">left</span><span class="main">,</span> <span class="entity">right</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">if</span></span> length <span class="entity">left</span> &lt; length <span class="entity">right</span> <span class="keyword2"><span class="keyword">then</span></span>
            <span class="keyword2"><span class="keyword">let</span></span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">left'</span> <span class="main">=</span> filter <span class="main">(</span><span class="entity">ItemIO.pre_match_arg</span> <span class="entity">ctxt</span> <span class="entity">arg1</span><span class="main">)</span> <span class="entity">left</span>
            <span class="keyword2"><span class="keyword">in</span></span>
              <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">left'</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
              <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="entity">left'</span><span class="main">,</span> filter <span class="main">(</span><span class="entity">ItemIO.pre_match_arg</span> <span class="entity">ctxt</span> <span class="entity">arg2</span><span class="main">)</span> <span class="entity">right</span><span class="main">)</span>
            <span class="keyword2"><span class="keyword">end</span></span>
          <span class="keyword2"><span class="keyword">else</span></span>
            <span class="keyword2"><span class="keyword">let</span></span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">right'</span> <span class="main">=</span> filter <span class="main">(</span><span class="entity">ItemIO.pre_match_arg</span> <span class="entity">ctxt</span> <span class="entity">arg2</span><span class="main">)</span> <span class="entity">right</span>
            <span class="keyword2"><span class="keyword">in</span></span>
              <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">right'</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
              <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span>filter <span class="main">(</span><span class="entity">ItemIO.pre_match_arg</span> <span class="entity">ctxt</span> <span class="entity">arg1</span><span class="main">)</span> <span class="entity">left</span><span class="main">,</span> <span class="entity">right'</span><span class="main">)</span>
            <span class="keyword2"><span class="keyword">end</span></span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_pairs</span> <span class="main">(</span><span class="entity">left</span><span class="main">,</span> <span class="entity">right</span><span class="main">)</span> <span class="entity">st</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">left'</span><span class="main">,</span> <span class="entity">right'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">filter_pairs</span> <span class="main">(</span><span class="entity">left</span><span class="main">,</span> <span class="entity">right</span><span class="main">)</span>

            <span class="comment1">(* One step in the iteration, fixing both left and right
               items. Do not match item with itself.
             *)</span>
            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_pair</span> <span class="entity">left_item</span> <span class="entity">func</span> <span class="entity">right_item</span> <span class="entity">st</span> <span class="main">=</span>
                <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">BoxItem.eq_item</span> <span class="main">(</span><span class="entity">left_item</span><span class="main">,</span> <span class="entity">right_item</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">st</span> <span class="keyword2"><span class="keyword">else</span></span>
                <span class="keyword2"><span class="keyword">let</span></span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">updts</span> <span class="main">=</span>
                      <span class="entity">scoring</span> <span class="entity">prfstep</span> <span class="entity">sc</span> <span class="main">[</span><span class="entity">left_item</span><span class="main">,</span> <span class="entity">right_item</span><span class="main">]</span> <span class="entity">st</span> <span class="entity">func</span>
                <span class="keyword2"><span class="keyword">in</span></span>
                  <span class="entity">st</span> |&gt; fold <span class="entity">apply_update_instant</span> <span class="entity">updts</span>
                <span class="keyword2"><span class="keyword">end</span></span>

            <span class="comment1">(* Iterate over the right items, fixing left item. *)</span>
            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">loop_right</span> <span class="entity">left_item</span> <span class="entity">st</span> <span class="main">=</span>
                <span class="keyword2"><span class="keyword">let</span></span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">func</span> <span class="main">=</span> <span class="entity">f</span> <span class="entity">ctxt</span> <span class="entity">left_item</span>
                <span class="keyword2"><span class="keyword">in</span></span>
                  <span class="entity">st</span> |&gt; fold <span class="main">(</span><span class="entity">process_pair</span> <span class="entity">left_item</span> <span class="entity">func</span><span class="main">)</span> <span class="entity">right'</span>
                <span class="keyword2"><span class="keyword">end</span></span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="entity">st</span> |&gt; fold <span class="entity">loop_right</span> <span class="entity">left'</span>
          <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="comment1">(* We know items is a subset of items'. On the second round,
         match with the extra elements in items' on the left.
       *)</span>
      <span class="entity">st</span> |&gt; <span class="entity">process_pairs</span> <span class="main">(</span><span class="entity">items</span><span class="main">,</span> <span class="entity">items'</span><span class="main">)</span>
         |&gt; <span class="entity">process_pairs</span> <span class="main">(</span>subtract <span class="entity">BoxItem.eq_item</span> <span class="entity">items</span> <span class="entity">items'</span><span class="main">,</span> <span class="entity">items</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_prfstep</span> <span class="entity">sc</span> <span class="entity">items</span> <span class="entity">items'</span> <span class="entity">prfstep</span> <span class="main">(</span><span class="entity">st</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">{</span><span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">args</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">prfstep</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">items</span> <span class="main">=</span> filter_out <span class="main">(</span>
          <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">item</span> <span class="main">=&gt;</span> <span class="entity">BoxID.is_box_resolved</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="main">#</span>id <span class="entity">item</span><span class="main">)</span> <span class="keyword1"><span class="keyword">orelse</span></span>
                     <span class="entity">Status.query_removed</span> <span class="entity">st</span> <span class="entity">item</span><span class="main">)</span> <span class="entity">items</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">items</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">st</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> length <span class="main">(</span>filter_out <span class="entity">ItemIO.is_side_match</span> <span class="entity">args</span><span class="main">)</span> <span class="main">=</span> <span class="inner_numeral">1</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="entity">st</span> |&gt; <span class="entity">process_step_single</span> <span class="entity">sc</span> <span class="entity">items</span> <span class="entity">prfstep</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="entity">st</span> |&gt; <span class="entity">process_step_pair</span> <span class="entity">sc</span> <span class="entity">items</span> <span class="entity">items'</span> <span class="entity">prfstep</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* List of terms to be added to the rewrite table. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_rewr_terms</span> <span class="entity">ctxt</span> <span class="entity">item</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">ty_str</span><span class="main">,</span> <span class="entity">tname</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">item</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ts</span> <span class="main">=</span> map Thm.term_of <span class="entity">tname</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rewr_terms</span> <span class="main">=</span> <span class="entity">ItemIO.rewr_terms_of_item</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">ty_str</span><span class="main">,</span> <span class="entity">ts</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">terms</span> <span class="main">=</span> <span class="entity">rewr_terms</span> |&gt; maps <span class="entity">UtilLogic.get_all_subterms</span>
                             |&gt; distinct <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv<span class="main">)</span>
                             |&gt; filter_out <span class="entity">Util.has_vars</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">headt</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">ty_str</span> <span class="main">=</span> <span class="entity">TY_PROP</span> <span class="keyword2"><span class="keyword">then</span></span>
                    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_neg</span> <span class="main">(</span>the_single <span class="entity">ts</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
                      <span class="main">[</span><span class="entity">dest_not</span> <span class="main">(</span>the_single <span class="entity">ts</span><span class="main">)</span><span class="main">]</span>
                    <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">ts</span>
                  <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">headt</span> @ <span class="entity">terms</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* List of terms to be added as TERM items. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_rewr_terms2</span> <span class="entity">ctxt</span> <span class="entity">item</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">ty_str</span><span class="main">,</span> <span class="entity">tname</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">item</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ts</span> <span class="main">=</span> map Thm.term_of <span class="entity">tname</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rewr_terms</span> <span class="main">=</span> <span class="entity">ItemIO.rewr_terms_of_item</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">ty_str</span><span class="main">,</span> <span class="entity">ts</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">rewr_terms</span> |&gt; maps <span class="entity">UtilLogic.get_all_subterms_skip_if</span>
                 |&gt; distinct <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv<span class="main">)</span>
                 |&gt; filter_out <span class="entity">Util.has_vars</span>
                 |&gt; filter_out <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="main">=&gt;</span> fastype_of <span class="entity">t</span> <span class="main">=</span> <span class="entity">boolT</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_add_terms</span> <span class="entity">id</span> <span class="entity">sc</span> <span class="entity">items</span> <span class="main">(</span><span class="entity">st</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">{</span><span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="comment1">(* Add terms to the rewrite table. *)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">term_infos</span> <span class="main">=</span> <span class="entity">items</span> |&gt; maps <span class="main">(</span><span class="entity">get_rewr_terms</span> <span class="entity">ctxt</span><span class="main">)</span>
                             |&gt; distinct <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv<span class="main">)</span>
                             |&gt; map <span class="main">(</span>pair <span class="entity">id</span> o Thm.cterm_of <span class="entity">ctxt</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">old_items</span> <span class="main">=</span>
          <span class="main">(</span><span class="entity">Status.get_items</span> <span class="entity">st</span><span class="main">)</span>
              |&gt; filter_out <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span><span class="entity">id</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span> <span class="entity">BoxID.is_box_resolved</span> <span class="entity">ctxt</span> <span class="entity">id</span><span class="main">)</span>
              |&gt; subtract <span class="entity">BoxItem.eq_item</span> <span class="entity">items</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt'</span> <span class="main">=</span> <span class="entity">ctxt</span> |&gt; <span class="entity">Auto2Data.add_terms</span> <span class="entity">old_items</span> <span class="entity">term_infos</span>

      <span class="comment1">(* Add new terms as updates. *)</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">exists_item</span> <span class="entity">t</span> <span class="main">=</span>
          <span class="entity">Status.find_ritem_exact</span> <span class="entity">st</span> <span class="entity">id</span> <span class="main">(</span><span class="entity">Fact</span> <span class="main">(</span><span class="entity">TY_TERM</span><span class="main">,</span> <span class="main">[</span><span class="entity">t</span><span class="main">]</span><span class="main">,</span> <span class="entity">true_th</span><span class="main">)</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">terms2</span> <span class="main">=</span> <span class="entity">items</span> |&gt; maps <span class="main">(</span><span class="entity">get_rewr_terms2</span> <span class="entity">ctxt</span><span class="main">)</span>
                         |&gt; distinct <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv<span class="main">)</span>
                         |&gt; filter_out <span class="entity">exists_item</span>
                         |&gt; filter_out <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="main">=&gt;</span> fastype_of <span class="entity">t</span> <span class="main">=</span> <span class="entity">boolT</span><span class="main">)</span>

      <span class="comment1">(* New terms have score of the source item plus 1. *)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">updt</span> <span class="main">=</span>
          <span class="main">{</span>sc <span class="main">=</span> <span class="entity">sc</span><span class="main">,</span> prfstep_name <span class="main">=</span> <span class="inner_quoted">"$TERM"</span><span class="main">,</span> source <span class="main">=</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span>
           raw_updt <span class="main">=</span> <span class="entity">AddItems</span> <span class="main">{</span>id <span class="main">=</span> <span class="entity">id</span><span class="main">,</span> sc <span class="main">=</span> NONE<span class="main">,</span>
                                raw_items <span class="main">=</span> map <span class="entity">BoxItem.term_to_fact</span> <span class="entity">terms2</span><span class="main">}</span><span class="main">}</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">st</span> |&gt; <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> length <span class="entity">terms2</span> &gt; <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">Status.add_to_queue</span> <span class="entity">updt</span> <span class="keyword2"><span class="keyword">else</span></span> I<span class="main">)</span>
         |&gt; <span class="entity">Status.map_context</span> <span class="main">(</span>K <span class="entity">ctxt'</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Process the given items. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_fact_all</span> <span class="entity">id</span> <span class="entity">sc</span> <span class="entity">items</span> <span class="main">(</span><span class="entity">st</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">{</span><span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">items</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">st</span> <span class="keyword2"><span class="keyword">else</span></span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">items'</span> <span class="main">=</span>
          <span class="main">(</span><span class="entity">Status.get_items</span> <span class="entity">st</span><span class="main">)</span>
              |&gt; filter_out <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span><span class="entity">id</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span> <span class="entity">BoxID.is_box_resolved</span> <span class="entity">ctxt</span> <span class="entity">id</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">old_items</span> <span class="main">=</span> subtract <span class="entity">BoxItem.eq_item</span> <span class="entity">items</span> <span class="entity">items'</span>

      <span class="comment1">(* Incremental context and the list of relevant terms for the
         increment. *)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt'</span> <span class="main">=</span> <span class="entity">Auto2Data.get_incr_type</span> <span class="entity">old_items</span> <span class="entity">items</span> <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ts</span> <span class="main">=</span>
          <span class="main">(</span>maps <span class="entity">Auto2Data.relevant_terms_single</span> <span class="entity">items</span> @
           maps <span class="main">(</span><span class="entity">Property.strip_property_field</span> <span class="entity">thy</span> o <span class="entity">dest_arg</span> o <span class="entity">prop_of'</span> o snd<span class="main">)</span>
                <span class="main">(</span><span class="entity">PropertyData.get_new_property</span> <span class="entity">ctxt'</span><span class="main">)</span> @
           map fst <span class="main">(</span><span class="entity">WellformData.get_new_wellform_data</span> <span class="entity">ctxt'</span><span class="main">)</span><span class="main">)</span>
              |&gt; distinct <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv<span class="main">)</span>
              |&gt; <span class="entity">RewriteTable.get_reachable_terms</span> true <span class="entity">ctxt</span>

      <span class="comment1">(* List of items to consider for init and incr rounds. *)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">init_items</span> <span class="main">=</span> filter_out <span class="main">(</span><span class="entity">BoxItem.match_ty_str</span> <span class="entity">TY_PROPERTY</span><span class="main">)</span> <span class="entity">items</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">incr_filt</span> <span class="main">{</span>id <span class="main">=</span> <span class="entity">id'</span><span class="main">,</span> <span class="entity">tname</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span>
          exists <span class="main">(</span><span class="entity">Util.has_subterm</span> <span class="entity">ts</span><span class="main">)</span> <span class="main">(</span>map Thm.term_of <span class="entity">tname</span><span class="main">)</span> <span class="keyword1"><span class="keyword">andalso</span></span>
          <span class="entity">BoxID.is_box_unresolved</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">BoxID.merge_boxes</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">id'</span><span class="main">)</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">incr_items</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">ts</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span>
          <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">old_items</span> |&gt; filter <span class="entity">incr_filt</span>
                         |&gt; cons <span class="entity">BoxItem.null_item</span>

      <span class="comment1">(* List of proofsteps to consider for init and incr rounds. *)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prfsteps</span> <span class="main">=</span> <span class="entity">ProofStepData.get_prfsteps</span> <span class="entity">thy</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_items</span> <span class="main">=</span> <span class="entity">init_items</span> @ <span class="entity">incr_items</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">st</span> |&gt; <span class="entity">Status.map_context</span> <span class="main">(</span>K <span class="entity">ctxt'</span><span class="main">)</span>
         |&gt; fold <span class="main">(</span><span class="entity">process_prfstep</span> <span class="entity">sc</span> <span class="entity">all_items</span> <span class="entity">items'</span><span class="main">)</span> <span class="entity">prfsteps</span>
         |&gt; <span class="entity">Status.map_context</span> <span class="entity">Auto2Data.get_single_type</span>
         |&gt; <span class="entity">Status.clear_incr</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_add_items</span> <span class="main">(</span><span class="entity">updt</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">{</span><span class="entity">sc</span><span class="main">,</span> <span class="entity">prfstep_name</span><span class="main">,</span> <span class="entity">raw_updt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span>
                      <span class="main">(</span><span class="entity">st</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">{</span><span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">raw_updt</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="entity">AddItems</span> <span class="main">{</span><span class="entity">id</span><span class="main">,</span> raw_items <span class="main">=</span> <span class="entity">ritems</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">ctxt'</span><span class="main">,</span> <span class="entity">subst</span><span class="main">)</span> <span class="main">=</span> <span class="entity">BoxItem.obtain_variant_frees</span> <span class="main">(</span><span class="entity">ctxt</span><span class="main">,</span> <span class="entity">ritems</span><span class="main">)</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ritems'</span> <span class="main">=</span>
              <span class="entity">ritems</span> |&gt; map <span class="main">(</span><span class="entity">BoxItem.instantiate</span> <span class="entity">subst</span><span class="main">)</span>
                     |&gt; <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">prfstep_name</span> <span class="main">=</span> <span class="inner_quoted">"$RESOLVE"</span> <span class="keyword1"><span class="keyword">orelse</span></span>
                            <span class="entity">prfstep_name</span> <span class="main">=</span> <span class="inner_quoted">"$INIT_BOX"</span> <span class="keyword2"><span class="keyword">then</span></span>
                           maps <span class="main">(</span><span class="entity">Normalizer.normalize_keep</span> <span class="entity">ctxt'</span><span class="main">)</span>
                         <span class="keyword2"><span class="keyword">else</span></span>
                           maps <span class="main">(</span><span class="entity">Normalizer.normalize</span> <span class="entity">ctxt'</span><span class="main">)</span><span class="main">)</span>
                     |&gt; distinct <span class="entity">BoxItem.eq_ritem</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">dup_ritems</span><span class="main">,</span> <span class="entity">new_ritems</span><span class="main">)</span> <span class="main">=</span>
              <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">sc</span> <span class="main">=</span> <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">ritems'</span><span class="main">)</span>
              <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">filter_split</span> <span class="main">(</span><span class="entity">Status.find_ritem_exact</span> <span class="entity">st</span> <span class="entity">id</span><span class="main">)</span> <span class="entity">ritems'</span>

          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">dup_ritems</span> <span class="keyword1"><span class="keyword">orelse</span></span>
                     not <span class="main">(</span>Config.get <span class="entity">ctxt</span> <span class="entity">print_trace</span><span class="main">)</span> <span class="keyword1"><span class="keyword">orelse</span></span>
                     not <span class="main">(</span>Config.get <span class="entity">ctxt</span> <span class="entity">print_intended</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span>
                  <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">prfstep_name</span> <span class="main">=</span> <span class="inner_quoted">"$TERM"</span> <span class="keyword1"><span class="keyword">andalso</span></span>
                     not <span class="main">(</span>Config.get <span class="entity">ctxt</span> <span class="entity">print_term</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">)</span>
                  <span class="keyword2"><span class="keyword">else</span></span> tracing <span class="main">(</span><span class="inner_quoted">"Intend to add "</span> ^
                                <span class="entity">Update.update_info</span> <span class="entity">ctxt'</span> <span class="entity">id</span> <span class="entity">dup_ritems</span> ^
                                <span class="inner_quoted">" ("</span> ^ <span class="entity">Update.source_info</span> <span class="entity">updt</span> ^ <span class="inner_quoted">")"</span><span class="main">)</span>

          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">handlers</span><span class="main">,</span> <span class="entity">ritems'</span><span class="main">)</span> <span class="main">=</span>
              <span class="entity">filter_split</span> <span class="entity">BoxItem.is_handler_raw</span> <span class="entity">new_ritems</span>

          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">uid_incr</span> <span class="main">=</span> length <span class="entity">ritems'</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">uid_next</span> <span class="main">=</span> <span class="entity">Status.get_num_items</span> <span class="entity">st</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">uid_string</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">uid_incr</span> <span class="main">=</span> <span class="inner_numeral">1</span> <span class="keyword2"><span class="keyword">then</span></span> string_of_int <span class="entity">uid_next</span>
                           <span class="keyword2"><span class="keyword">else</span></span> string_of_int <span class="entity">uid_next</span> ^ <span class="inner_quoted">"-"</span> ^
                                string_of_int <span class="main">(</span><span class="entity">uid_next</span> + <span class="entity">uid_incr</span> - <span class="inner_numeral">1</span><span class="main">)</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sc_string</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> Config.get <span class="entity">ctxt</span> <span class="entity">print_score</span> <span class="keyword2"><span class="keyword">then</span></span>
                            <span class="main">(</span>string_of_int <span class="entity">sc</span><span class="main">)</span> ^ <span class="inner_quoted">", "</span>
                          <span class="keyword2"><span class="keyword">else</span></span> <span class="inner_quoted">""</span>

          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">new_ritems</span> <span class="keyword1"><span class="keyword">orelse</span></span>
                     not <span class="main">(</span>Config.get <span class="entity">ctxt</span> <span class="entity">print_trace</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span>
                  <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">prfstep_name</span> <span class="main">=</span> <span class="inner_quoted">"$TERM"</span> <span class="keyword1"><span class="keyword">andalso</span></span>
                     not <span class="main">(</span>Config.get <span class="entity">ctxt</span> <span class="entity">print_term</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">)</span>
                  <span class="keyword2"><span class="keyword">else</span></span> tracing <span class="main">(</span><span class="inner_quoted">"Add "</span> ^ <span class="entity">Update.update_info</span> <span class="entity">ctxt'</span> <span class="entity">id</span> <span class="entity">ritems'</span> ^
                                <span class="inner_quoted">" ("</span> ^ <span class="entity">uid_string</span> ^ <span class="inner_quoted">", "</span> ^ <span class="entity">sc_string</span> ^
                                <span class="entity">Update.source_info</span> <span class="entity">updt</span> ^ <span class="inner_quoted">")"</span><span class="main">)</span>

          <span class="comment1">(* Produce the actual items. *)</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">items</span> <span class="main">=</span>
              map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">i</span> <span class="main">=&gt;</span> <span class="entity">BoxItem.mk_box_item</span>
                               <span class="entity">ctxt'</span> <span class="main">(</span><span class="entity">uid_next</span> + <span class="entity">i</span><span class="main">,</span> <span class="entity">id</span><span class="main">,</span> <span class="entity">sc</span><span class="main">,</span> nth <span class="entity">ritems'</span> <span class="entity">i</span><span class="main">)</span><span class="main">)</span>
                  <span class="main">(</span><span class="inner_numeral">0</span> upto <span class="main">(</span>length <span class="entity">ritems'</span> - <span class="inner_numeral">1</span><span class="main">)</span><span class="main">)</span>

          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">handlers_info</span> <span class="main">=</span> map <span class="main">(</span>pair <span class="entity">id</span> o <span class="entity">BoxItem.dest_handler_raw</span><span class="main">)</span> <span class="entity">handlers</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="entity">st</span> |&gt; <span class="entity">Status.map_context</span> <span class="main">(</span>K <span class="entity">ctxt'</span><span class="main">)</span>
             |&gt; fold <span class="entity">Status.add_handler</span> <span class="entity">handlers_info</span>
             |&gt; <span class="entity">process_add_terms</span> <span class="entity">id</span> <span class="entity">sc</span> <span class="entity">items</span>
             |&gt; fold <span class="entity">Status.add_item</span> <span class="main">(</span>map <span class="entity">BoxItem.item_with_incr</span> <span class="entity">items</span><span class="main">)</span>
             |&gt; <span class="entity">process_fact_all</span> <span class="entity">id</span> <span class="entity">sc</span> <span class="main">(</span>map <span class="entity">BoxItem.item_with_incr</span> <span class="entity">items</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">end</span></span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"process_add_items: wrong type of update"</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_add_boxes</span> <span class="main">(</span><span class="entity">updt</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">{</span><span class="entity">sc</span><span class="main">,</span> <span class="entity">raw_updt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="entity">st</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">{</span><span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">raw_updt</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="entity">AddBoxes</span> <span class="main">{</span><span class="entity">id</span><span class="main">,</span> <span class="entity">init_assum</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ritem</span> <span class="main">=</span> <span class="entity">init_assum</span> |&gt; Thm.cterm_of <span class="entity">ctxt</span>
                                 |&gt; Thm.assume |&gt; <span class="entity">Update.thm_to_ritem</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span>fastype_of <span class="entity">init_assum</span> <span class="main">=</span> <span class="entity">propT</span><span class="main">)</span>
                         <span class="inner_quoted">"process_add_boxes: assumption is not of type prop."</span>

          <span class="comment1">(* Find neg_form and check if already present. *)</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">neg_form_opt</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">id</span> <span class="main">=</span> <span class="main">[</span><span class="main">]</span> <span class="keyword2"><span class="keyword">then</span></span> NONE <span class="keyword2"><span class="keyword">else</span></span>
                             <span class="entity">init_assum</span> |&gt; <span class="entity">dest_Trueprop</span> |&gt; <span class="entity">get_neg</span>
                                        |&gt; <span class="entity">Status.find_fact</span> <span class="entity">st</span> <span class="entity">id</span>

          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prev_prim_box</span> <span class="main">=</span> <span class="entity">Status.find_prim_box</span> <span class="entity">st</span> <span class="entity">id</span> <span class="entity">init_assum</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="comment1">(* Do nothing if there is already a box with the same
             assumptions and conclusions.
           *)</span>
          <span class="keyword2"><span class="keyword">if</span></span> is_some <span class="entity">prev_prim_box</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">st</span>
          <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> is_some <span class="entity">neg_form_opt</span> <span class="keyword2"><span class="keyword">then</span></span>
            <span class="keyword2"><span class="keyword">let</span></span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th</span> <span class="main">=</span> the <span class="entity">neg_form_opt</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">updt</span> <span class="main">=</span> <span class="main">{</span>sc <span class="main">=</span> <span class="entity">sc</span><span class="main">,</span> prfstep_name <span class="main">=</span> <span class="inner_quoted">"$RESOLVE"</span><span class="main">,</span> source <span class="main">=</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span>
                          raw_updt <span class="main">=</span> <span class="entity">Logic_ProofSteps.logic_thm_update</span>
                                         <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">}</span>
            <span class="keyword2"><span class="keyword">in</span></span>
              <span class="entity">st</span> |&gt; <span class="entity">apply_update_instant</span> <span class="entity">updt</span>
            <span class="keyword2"><span class="keyword">end</span></span>
          <span class="comment1">(* Otherwise, proceed to create the box. *)</span>
          <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> Config.get <span class="entity">ctxt</span> <span class="entity">print_trace</span> <span class="keyword2"><span class="keyword">then</span></span>
                      tracing <span class="main">(</span><span class="inner_quoted">"Add box under "</span> ^ <span class="entity">BoxID.string_of_box_id</span> <span class="entity">id</span> ^ <span class="inner_quoted">" ("</span> ^
                               <span class="entity">Update.source_info</span> <span class="entity">updt</span> ^ <span class="inner_quoted">")"</span><span class="main">)</span>
                    <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">prim_id</span><span class="main">,</span> <span class="entity">st'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">st</span> |&gt; <span class="entity">Status.map_context</span> <span class="main">(</span>K <span class="entity">ctxt</span><span class="main">)</span>
                                    |&gt; <span class="entity">Status.add_prim_box</span> <span class="entity">id</span> <span class="entity">init_assum</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">new_id</span> <span class="main">=</span> <span class="main">[</span><span class="entity">prim_id</span><span class="main">]</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> Config.get <span class="entity">ctxt</span> <span class="entity">print_trace</span> <span class="keyword2"><span class="keyword">then</span></span>
                      tracing <span class="main">(</span><span class="entity">BoxID.string_of_box_id</span> <span class="entity">new_id</span> ^ <span class="inner_quoted">": "</span> ^
                               Syntax.string_of_term <span class="entity">ctxt</span> <span class="entity">init_assum</span><span class="main">)</span>
                    <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="main">)</span>

            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ritems'</span> <span class="main">=</span>
                <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">ritem</span> <span class="keyword2"><span class="keyword">of</span></span>
                    <span class="entity">Handler</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="entity">ritem</span><span class="main">]</span>
                  <span class="main">|</span> <span class="entity">Fact</span> <span class="main">(</span><span class="entity">ty_str</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=&gt;</span>
                    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">ty_str</span> <span class="main">=</span> <span class="entity">TY_PROP</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_neg</span> <span class="main">(</span><span class="entity">prop_of'</span> <span class="entity">th</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
                      map <span class="entity">Update.thm_to_ritem</span> <span class="main">(</span>
                        <span class="entity">Logic_ProofSteps.split_not_imp_th</span> <span class="entity">th</span><span class="main">)</span>
                    <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="entity">ritem</span><span class="main">]</span>

            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">item_updt</span> <span class="main">=</span> <span class="main">{</span>
              sc <span class="main">=</span> <span class="entity">sc</span><span class="main">,</span> prfstep_name <span class="main">=</span> <span class="inner_quoted">"$INIT_BOX"</span><span class="main">,</span> source <span class="main">=</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span>
              raw_updt <span class="main">=</span> <span class="entity">AddItems</span> <span class="main">{</span>id <span class="main">=</span> <span class="entity">new_id</span><span class="main">,</span> sc <span class="main">=</span> NONE<span class="main">,</span> raw_items <span class="main">=</span> <span class="entity">ritems'</span><span class="main">}</span><span class="main">}</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="entity">st'</span> |&gt; <span class="entity">process_add_items</span> <span class="entity">item_updt</span>
          <span class="keyword2"><span class="keyword">end</span></span>
        <span class="keyword2"><span class="keyword">end</span></span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"process_add_boxes: wrong type of update"</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">apply_update</span> <span class="main">(</span><span class="entity">updt</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">{</span><span class="entity">raw_updt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="entity">st</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">{</span><span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">id</span> <span class="main">=</span> <span class="entity">Update.target_of_update</span> <span class="entity">raw_updt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span>not <span class="main">(</span><span class="entity">BoxID.has_incr_id</span> <span class="entity">id</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">BoxID.is_box_resolved</span> <span class="entity">ctxt</span> <span class="entity">id</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">st</span> <span class="keyword2"><span class="keyword">else</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">raw_updt</span> <span class="keyword2"><span class="keyword">of</span></span>
          <span class="entity">AddItems</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">process_add_items</span> <span class="entity">updt</span> <span class="entity">st</span>
        <span class="main">|</span> <span class="entity">AddBoxes</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">process_add_boxes</span> <span class="entity">updt</span> <span class="entity">st</span>
        <span class="main">|</span> <span class="entity">ResolveBox</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">process_resolve</span> <span class="entity">updt</span> <span class="entity">st</span>
        <span class="main">|</span> <span class="entity">ShadowItem</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">process_shadow</span> <span class="entity">updt</span> <span class="entity">st</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Initialize status, given the subgoal in pure logic form. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">init_status</span> <span class="entity">ctxt</span> <span class="entity">subgoal</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="comment1">(* Free variables are implicitly quantified over at the front. *)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">raw_updt</span> <span class="main">=</span> <span class="entity">AddBoxes</span> <span class="main">{</span>id <span class="main">=</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span> sc <span class="main">=</span> NONE<span class="main">,</span> init_assum <span class="main">=</span> <span class="entity">get_neg'</span> <span class="entity">subgoal</span><span class="main">}</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">updt</span> <span class="main">=</span> <span class="main">{</span>sc <span class="main">=</span> <span class="inner_numeral">0</span><span class="main">,</span> prfstep_name <span class="main">=</span> <span class="inner_quoted">"$INIT"</span><span class="main">,</span> source <span class="main">=</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span>
                  raw_updt <span class="main">=</span> <span class="entity">raw_updt</span><span class="main">}</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">ctxt</span> |&gt; <span class="entity">Status.empty_status</span>
           |&gt; <span class="entity">Status.add_item</span> <span class="entity">BoxItem.null_item</span>
           |&gt; <span class="entity">apply_update</span> <span class="entity">updt</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Given a condition status -&gt; bool, step until the condition is
   satisfied. Return steps remaining as well as updated status.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">solve_root</span> <span class="main">(</span><span class="entity">steps</span><span class="main">,</span> <span class="main">(</span><span class="entity">st</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">{</span><span class="entity">queue</span><span class="main">,</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">BoxID.is_box_resolved</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">BoxID.home_id</span><span class="main">]</span> <span class="keyword2"><span class="keyword">then</span></span>
      <span class="main">(</span><span class="entity">steps</span><span class="main">,</span> <span class="entity">st</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">steps</span> <span class="main">=</span> <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span>
      error <span class="inner_quoted">"Maximum number of steps reached"</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">updt</span> <span class="main">=</span> Updates_Heap.min <span class="entity">queue</span>
                 <span class="keyword3"><span class="keyword">handle</span></span> List.Empty <span class="main">=&gt;</span> error <span class="inner_quoted">"No more moves"</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">st'</span> <span class="main">=</span> <span class="entity">st</span> |&gt; <span class="entity">Status.delmin_from_queue</span> |&gt; <span class="entity">apply_update</span> <span class="entity">updt</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">solve_root</span> <span class="main">(</span><span class="entity">steps</span> - <span class="inner_numeral">1</span><span class="main">,</span> <span class="entity">st'</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>  <span class="comment1">(* structure ProofStatus. *)</span>

<span class="comment1">(* Definition of auto2. *)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">AUTO2</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> auto2_tac<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> tactic
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Auto2</span> <span class="main">:</span> <span class="entity">AUTO2</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">auto2_tac</span> <span class="entity">ctxt</span> <span class="entity">state</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">subgoals</span> <span class="main">=</span> <span class="entity">state</span> |&gt; Thm.cprop_of |&gt; Drule.strip_imp_prems
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">steps</span> <span class="main">=</span> Config.get <span class="entity">ctxt</span> <span class="entity">max_steps</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">subgoals</span> <span class="keyword2"><span class="keyword">then</span></span> Seq.empty <span class="keyword2"><span class="keyword">else</span></span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">c_subgoal</span> <span class="main">=</span> hd <span class="entity">subgoals</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">subgoal</span> <span class="main">=</span> Thm.term_of <span class="entity">c_subgoal</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> tracing <span class="main">(</span>
              <span class="inner_quoted">"Subgoal 1 of "</span> ^ <span class="main">(</span>string_of_int <span class="main">(</span>length <span class="entity">subgoals</span><span class="main">)</span><span class="main">)</span> ^ <span class="inner_quoted">":\n"</span> ^
              <span class="main">(</span>Syntax.string_of_term <span class="entity">ctxt</span> <span class="entity">subgoal</span><span class="main">)</span> ^ <span class="inner_quoted">"\n"</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">subgoal_norm</span> <span class="main">=</span> Conv.every_conv <span class="main">[</span>
            <span class="entity">Util.normalize_meta_horn</span> <span class="entity">ctxt</span><span class="main">,</span>
            <span class="entity">UtilLogic.to_obj_conv</span> <span class="entity">ctxt</span><span class="main">]</span> <span class="entity">c_subgoal</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">st</span> <span class="main">=</span> <span class="entity">ProofStatus.init_status</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">Util.rhs_of</span> <span class="entity">subgoal_norm</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">steps'</span><span class="main">,</span> <span class="entity">st'</span><span class="main">)</span> <span class="main">=</span>
            <span class="entity">Util.timer</span> <span class="main">(</span><span class="inner_quoted">"Total time: "</span><span class="main">,</span>
                        <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">ProofStatus.solve_root</span> <span class="main">(</span><span class="entity">steps</span><span class="main">,</span> <span class="entity">st</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> writeln <span class="main">(</span><span class="inner_quoted">"Finished in "</span> ^
                         <span class="main">(</span>string_of_int <span class="main">(</span><span class="entity">steps</span> - <span class="entity">steps'</span><span class="main">)</span><span class="main">)</span> ^ <span class="inner_quoted">" steps."</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th</span> <span class="main">=</span> <span class="entity">st'</span> |&gt; <span class="entity">Status.get_resolve_th</span>
                     |&gt; Thm.equal_elim <span class="main">(</span><span class="entity">meta_sym</span> <span class="entity">subgoal_norm</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        Seq.single <span class="main">(</span>Thm.implies_elim <span class="entity">state</span> <span class="entity">th</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>  <span class="comment1">(* structure Auto2 *)</span>
</pre>
</div><div id="files/AFP/Auto2_HOL/auto2_outer.ML">
<div class="head">
<h1>File ‹$AFP/Auto2_HOL/auto2_outer.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*
  File: auto2_outer.ML
  Author: Bohua Zhan

  Proof language for auto2.
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">AUTO2_OUTER</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> auto2_solve<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> cterm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> init_state<span class="main">:</span> <span class="entity">Proof.state</span> <span class="main">-&gt;</span> <span class="entity">Proof.state</span>
  <span class="keyword1"><span class="keyword">val</span></span> refine_subgoal_th<span class="main">:</span> thm <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm

  <span class="keyword1"><span class="keyword">val</span></span> have_resolve<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> term <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> have_after_qed<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> have_cmd<span class="main">:</span> bool * string * bool <span class="main">-&gt;</span> <span class="entity">Proof.state</span> <span class="main">-&gt;</span> <span class="entity">Proof.state</span>

  <span class="keyword1"><span class="keyword">val</span></span> subgoal_cmd<span class="main">:</span> string <span class="main">-&gt;</span> <span class="entity">Proof.state</span> <span class="main">-&gt;</span> <span class="entity">Proof.state</span>
  <span class="keyword1"><span class="keyword">val</span></span> endgoal_cmd<span class="main">:</span> <span class="entity">Proof.state</span> <span class="main">-&gt;</span> <span class="entity">Proof.state</span>

  <span class="keyword1"><span class="keyword">val</span></span> end_cmd<span class="main">:</span> <span class="entity">Proof.state</span> <span class="main">-&gt;</span> <span class="entity">Proof.state</span>
  <span class="keyword1"><span class="keyword">val</span></span> qed_cmd<span class="main">:</span> <span class="entity">Proof.state</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span>

  <span class="keyword1"><span class="keyword">val</span></span> obtain_resolve<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> term <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> obtain_after_qed<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> obtain_cmd<span class="main">:</span> string list * string list * bool <span class="main">-&gt;</span> <span class="entity">Proof.state</span> <span class="main">-&gt;</span> <span class="entity">Proof.state</span>

  <span class="keyword1"><span class="keyword">val</span></span> case_resolve<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> case_after_qed<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> case_cmd<span class="main">:</span> string * bool <span class="main">-&gt;</span> <span class="entity">Proof.state</span> <span class="main">-&gt;</span> <span class="entity">Proof.state</span>

  <span class="keyword1"><span class="keyword">val</span></span> contra_resolve<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> term <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> contra_after_qed<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> contra_cmd<span class="main">:</span> <span class="entity">Proof.state</span> <span class="main">-&gt;</span> <span class="entity">Proof.state</span>

  <span class="keyword1"><span class="keyword">val</span></span> let_resolve<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> term <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> let_after_qed<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term list <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> let_cmd<span class="main">:</span> string list <span class="main">-&gt;</span> <span class="entity">Proof.state</span> <span class="main">-&gt;</span> <span class="entity">Proof.state</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Auto2_Outer</span> <span class="main">:</span> <span class="entity">AUTO2_OUTER</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="comment1">(* Use auto2 to solve the given statement *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">auto2_solve</span> <span class="entity">ctxt</span> <span class="entity">stmt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goal</span> <span class="main">=</span> <span class="entity">stmt</span> |&gt; Thm.trivial |&gt; Goal.protect <span class="inner_numeral">1</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">(</span><span class="entity">Auto2.auto2_tac</span> <span class="entity">ctxt</span> <span class="entity">goal</span><span class="main">)</span>
          |&gt; Seq.hd |&gt; Goal.conclude
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Initiate auto2 state, using goal from the Isar state. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">init_state</span> <span class="entity">state</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">goal</span><span class="main">,</span> context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">Proof.goal</span> <span class="entity">state</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span><span class="entity">Auto2_State.get_num_frame</span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="inner_numeral">0</span><span class="main">)</span>
                     <span class="inner_quoted">"init_state: state not empty."</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">subgoals</span> <span class="main">=</span> <span class="entity">goal</span> |&gt; Thm.cprop_of |&gt; Drule.strip_imp_prems
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">init_frame</span> <span class="main">=</span> <span class="entity">Auto2_State.simple_frame</span> <span class="main">(</span>hd <span class="entity">subgoals</span><span class="main">,</span> NONE<span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">state</span> |&gt; <span class="entity">Proof.map_contexts</span> <span class="main">(</span><span class="entity">Auto2_State.push_head</span> <span class="entity">init_frame</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
    <span class="entity">Outer_Syntax.command</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">command_keyword</span> "<span class="keyword1">@proof</span>"<span class="antiquote">}</span></span></span> <span class="inner_quoted">"begin auto2 proof"</span>
    <span class="main">(</span>Scan.succeed <span class="main">(</span><span class="entity">Toplevel.proof</span> <span class="entity">init_state</span><span class="main">)</span><span class="main">)</span>

<span class="comment1">(* Given th of the form A ==&gt; B, and prop of the form B ==&gt; C, return
   the theorem A ==&gt; C. In effect, we modified (refined) the subgoal
   in prop from B to A using th.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">refine_subgoal_th</span> <span class="entity">th</span> <span class="entity">prop</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">assum</span> <span class="main">=</span> hd <span class="main">(</span>Drule.cprems_of <span class="entity">th</span><span class="main">)</span>  <span class="comment1">(* A *)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">th</span> |&gt; <span class="entity">Util.send_first_to_hyps</span>  <span class="comment1">(* [A] ==&gt; B *)</span>
         |&gt; Thm.implies_elim <span class="entity">prop</span>    <span class="comment1">(* [A] ==&gt; C *)</span>
         |&gt; Thm.implies_intr <span class="entity">assum</span>   <span class="comment1">(* A ==&gt; C *)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Given theorem As ==&gt; B, a term C, and a list of variables x, obtain
   the theorem (!!x. As ==&gt; B ==&gt; C) ==&gt; (!!x. As ==&gt; C).
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">have_resolve</span> <span class="entity">ctxt</span> <span class="entity">vars</span> <span class="entity">th</span> <span class="entity">concl</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prop</span> <span class="main">=</span> Thm.prop_of <span class="entity">th</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">As</span><span class="main">,</span> <span class="entity">B</span><span class="main">)</span> <span class="main">=</span> Logic.strip_horn <span class="entity">prop</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cAs</span> <span class="main">=</span> map <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">As</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">c_vars</span> <span class="main">=</span> map <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">vars</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">stmt</span> <span class="main">=</span> <span class="main">(</span><span class="entity">Util.list_meta_horn</span> <span class="main">(</span><span class="entity">vars</span><span class="main">,</span> <span class="main">(</span><span class="entity">As</span> @ <span class="main">[</span><span class="entity">B</span><span class="main">]</span><span class="main">,</span> <span class="entity">concl</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
                     |&gt; Thm.cterm_of <span class="entity">ctxt</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thAs</span> <span class="main">=</span> map Thm.assume <span class="entity">cAs</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th_bc</span> <span class="main">=</span>
          <span class="entity">stmt</span> |&gt; Thm.assume  <span class="comment1">(* !!x. As ==&gt; B ==&gt; C *)</span>
               |&gt; fold Thm.forall_elim <span class="entity">c_vars</span>
               |&gt; fold Thm.elim_implies <span class="entity">thAs</span>  <span class="comment1">(* B ==&gt; C *)</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th_b</span> <span class="main">=</span> <span class="entity">th</span> |&gt; fold Thm.elim_implies <span class="entity">thAs</span>  <span class="comment1">(* B *)</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th_c</span> <span class="main">=</span> Thm.implies_elim <span class="entity">th_bc</span> <span class="entity">th_b</span>  <span class="comment1">(* C *)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">th_c</span> |&gt; fold Thm.implies_intr <span class="main">(</span>rev <span class="entity">cAs</span><span class="main">)</span>
           |&gt; fold Thm.forall_intr <span class="main">(</span>rev <span class="entity">c_vars</span><span class="main">)</span>
           |&gt; Thm.implies_intr <span class="entity">stmt</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Given prop in the form (!!x. As ==&gt; C) ==&gt; D, and th in the form As
   ==&gt; B, return the theorem (!!x. As ==&gt; B ==&gt; C) ==&gt; D.

   In effect, this adds B as an extra assumption in the current
   subgoal.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">have_after_qed</span> <span class="entity">ctxt</span> <span class="entity">th</span> <span class="entity">prop</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">vars</span><span class="main">,</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">concl</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">prop</span> |&gt; Thm.prems_of |&gt; the_single
                                    |&gt; <span class="entity">Util.strip_meta_horn</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">have_res</span> <span class="main">=</span> <span class="entity">have_resolve</span> <span class="entity">ctxt</span> <span class="entity">vars</span> <span class="entity">th</span> <span class="entity">concl</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">refine_subgoal_th</span> <span class="entity">have_res</span> <span class="entity">prop</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Implementation of @have command. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">have_cmd</span> <span class="main">(</span><span class="entity">is_rule</span><span class="main">,</span> <span class="entity">t</span><span class="main">,</span> <span class="entity">is_with</span><span class="main">)</span> <span class="entity">state</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">Proof.goal</span> <span class="entity">state</span>

      <span class="comment1">(* Goal to be proved: !!x. As' ==&gt; C *)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">vars</span><span class="main">,</span> <span class="main">(</span><span class="entity">assums</span><span class="main">,</span> <span class="entity">concl</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">t</span> |&gt; Syntax.read_term <span class="entity">ctxt</span>
                                      |&gt; <span class="entity">UtilLogic.strip_obj_horn</span>

      <span class="comment1">(* Current subgoal *)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">(</span><span class="entity">As</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">ctxt</span> |&gt; <span class="entity">Auto2_State.get_subgoal</span>
                              |&gt; <span class="entity">Util.strip_meta_horn</span>

      <span class="comment1">(* Actual goal: strip vars, and add As as additional assumptions. *)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">stmt</span> <span class="main">=</span> Logic.list_implies <span class="main">(</span><span class="entity">As</span> @ map <span class="entity">mk_Trueprop</span> <span class="entity">assums</span><span class="main">,</span>
                                     <span class="entity">mk_Trueprop</span> <span class="entity">concl</span><span class="main">)</span>

      <span class="comment1">(* Post-processing. We begin with th: As ==&gt; As' ==&gt; C, and want
         to create the theorem As ==&gt; (!!x. As' ==&gt; C), then use it to
         insert !!x. As' ==&gt; C as an additional assumption.
       *)</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">post_process</span> <span class="entity">th</span> <span class="main">=</span>
          <span class="entity">th</span> |&gt; funpow <span class="main">(</span>length <span class="entity">As</span><span class="main">)</span> <span class="entity">Util.send_first_to_hyps</span>
             <span class="comment1">(* [As] ==&gt; As' ==&gt; C *)</span>
             |&gt; fold Thm.forall_intr <span class="main">(</span>rev <span class="main">(</span>map <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">vars</span><span class="main">)</span><span class="main">)</span>
             <span class="comment1">(* [As] ==&gt; !!x. As' ==&gt; C *)</span>
             |&gt; <span class="entity">apply_to_thm</span> <span class="main">(</span><span class="entity">UtilLogic.to_obj_conv</span> <span class="entity">ctxt</span><span class="main">)</span>
             <span class="comment1">(* [As] ==&gt; !x. As' --&gt; C *)</span>
             |&gt; fold Thm.implies_intr <span class="main">(</span>rev <span class="main">(</span>map <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">As</span><span class="main">)</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">after_qed</span> <span class="entity">ths</span> <span class="entity">prop</span> <span class="main">=</span>
          <span class="entity">have_after_qed</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">post_process</span> <span class="main">(</span>the_single <span class="entity">ths</span><span class="main">)</span><span class="main">)</span> <span class="entity">prop</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">add_prem_only</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_rule</span> <span class="keyword2"><span class="keyword">then</span></span> I
          <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">Auto2_State.add_prem_only</span>
                   <span class="main">(</span><span class="entity">UtilLogic.list_obj_horn</span> <span class="main">(</span><span class="entity">vars</span><span class="main">,</span> <span class="main">(</span><span class="entity">assums</span><span class="main">,</span> <span class="entity">concl</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">new_vars</span> <span class="main">=</span>
          filter_out <span class="main">(</span>Variable.is_fixed <span class="entity">ctxt</span> o fst o Term.dest_Free<span class="main">)</span> <span class="entity">vars</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> not <span class="entity">is_with</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="comment1">(* Run auto2 to obtain As ==&gt; As' ==&gt; C. *)</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt'</span> <span class="main">=</span> fold <span class="entity">Util.declare_free_term</span> <span class="entity">new_vars</span> <span class="entity">ctxt</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th</span> <span class="main">=</span> <span class="entity">auto2_solve</span> <span class="entity">ctxt'</span> <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt'</span> <span class="entity">stmt</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="entity">state</span> |&gt; <span class="entity">Proof.map_contexts</span> <span class="main">(</span><span class="entity">Auto2_State.map_head_th</span> <span class="main">(</span><span class="entity">after_qed</span> <span class="main">[</span><span class="entity">th</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
                |&gt; <span class="entity">Proof.map_contexts</span> <span class="entity">add_prem_only</span>
        <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">new_frame</span> <span class="main">=</span> <span class="entity">Auto2_State.simple_frame</span> <span class="main">(</span>
                Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">stmt</span><span class="main">,</span> SOME <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">after_qed</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="comment1">(* The order here does not matter much. All three actions
             will be completed before proof begins.
           *)</span>
          <span class="entity">state</span> |&gt; <span class="entity">Proof.map_contexts</span> <span class="entity">add_prem_only</span>
                |&gt; <span class="entity">Proof.map_contexts</span> <span class="main">(</span>fold <span class="entity">Util.declare_free_term</span> <span class="entity">new_vars</span><span class="main">)</span>
                |&gt; <span class="entity">Proof.map_contexts</span> <span class="main">(</span><span class="entity">Auto2_State.push_head</span> <span class="entity">new_frame</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">read_rule</span> <span class="main">=</span>
    Scan.option <span class="main">(</span>Parse.$$$ <span class="inner_quoted">"("</span> --| <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">keyword</span> "<span class="keyword2">@rule</span>"<span class="antiquote">}</span></span></span> |-- Parse.$$$ <span class="inner_quoted">")"</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">read_with</span> <span class="main">=</span>
    Scan.option <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">keyword</span> "<span class="keyword2">@with</span>"<span class="antiquote">}</span></span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
    <span class="entity">Outer_Syntax.command</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">command_keyword</span> "<span class="keyword1">@have</span>"<span class="antiquote">}</span></span></span> <span class="inner_quoted">"intermediate goal"</span>
    <span class="main">(</span><span class="entity">read_rule</span> -- Parse.term -- <span class="entity">read_with</span> &gt;&gt;
        <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">rule_opt</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">,</span> <span class="entity">with_opt</span><span class="main">)</span> <span class="main">=&gt;</span>
            <span class="entity">Toplevel.proof</span>
                <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">state</span> <span class="main">=&gt;</span>
                    <span class="entity">have_cmd</span> <span class="main">(</span>is_some <span class="entity">rule_opt</span><span class="main">,</span> <span class="entity">t</span><span class="main">,</span> is_some <span class="entity">with_opt</span><span class="main">)</span> <span class="entity">state</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

<span class="comment1">(* Whether the goal is already resolved. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_goal_resolved</span> <span class="entity">th</span> <span class="main">=</span>
    not <span class="main">(</span><span class="entity">Util.is_head</span> <span class="main">(</span>Logic.protectC<span class="main">)</span> <span class="main">(</span>Thm.concl_of <span class="entity">th</span><span class="main">)</span><span class="main">)</span>

<span class="comment1">(* Match pattern pat with t. Here pat is the pattern for selecting the
   i'th subgoal.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">match_subgoal_pat</span> <span class="entity">thy</span> <span class="entity">t</span> <span class="main">(</span><span class="entity">i</span><span class="main">,</span> <span class="entity">pat</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inst</span> <span class="main">=</span> Pattern.first_order_match <span class="entity">thy</span> <span class="main">(</span><span class="entity">pat</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span> <span class="entity">fo_init</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">vars</span> <span class="main">=</span> rev <span class="main">(</span>map Var <span class="main">(</span>Term.add_vars <span class="entity">pat</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ts</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">Util.subst_term_norm</span> <span class="entity">inst</span><span class="main">)</span> <span class="entity">vars</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      SOME <span class="main">(</span><span class="entity">i</span><span class="main">,</span> <span class="entity">ts</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword3"><span class="keyword">handle</span></span> Pattern.MATCH <span class="main">=&gt;</span> NONE

<span class="comment1">(* Implementation of the @subgoal command. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">subgoal_cmd</span> <span class="entity">s</span> <span class="entity">state</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">Proof.goal</span> <span class="entity">state</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">goals</span><span class="main">,</span> <span class="entity">selected</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">Auto2_State.get_top_frame</span> <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span><span class="entity">selected</span> <span class="main">=</span> NONE<span class="main">)</span> <span class="inner_quoted">"@subgoal: already selected a subgoal."</span>

      <span class="comment1">(* Figure out which subgoal to select by matching *)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Syntax.read_term <span class="entity">ctxt</span> <span class="entity">s</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">res</span> <span class="main">=</span> get_first <span class="main">(</span><span class="entity">match_subgoal_pat</span> <span class="entity">thy</span> <span class="entity">t</span><span class="main">)</span> <span class="main">(</span>tag_list <span class="inner_numeral">0</span> <span class="main">(</span>map fst <span class="entity">goals</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">res</span> <span class="keyword2"><span class="keyword">of</span></span>
          NONE <span class="main">=&gt;</span> error <span class="inner_quoted">"@subgoal: pattern not found"</span>
        <span class="main">|</span> SOME <span class="main">(</span><span class="entity">i</span><span class="main">,</span> <span class="entity">ts</span><span class="main">)</span> <span class="main">=&gt;</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prop</span> <span class="main">=</span> snd <span class="main">(</span>nth <span class="entity">goals</span> <span class="entity">i</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span>not <span class="main">(</span><span class="entity">is_goal_resolved</span> <span class="entity">prop</span><span class="main">)</span><span class="main">)</span>
                           <span class="inner_quoted">"@subgoal: goal already resolved."</span>

            <span class="comment1">(* Use the matched variables ts to name the forall variables. *)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t'</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> Thm.prop_of <span class="entity">prop</span> <span class="keyword2"><span class="keyword">of</span></span>
                         <span class="entity">imp</span> $ <span class="entity">A</span> $ <span class="entity">B</span> <span class="main">=&gt;</span> <span class="entity">imp</span> $ <span class="entity">Util.rename_abs_term</span> <span class="entity">ts</span> <span class="entity">A</span> $ <span class="entity">B</span>
                       <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"subgoal_cmd"</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prop</span> <span class="main">=</span> Thm.renamed_prop <span class="entity">t'</span> <span class="entity">prop</span>

            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">new_ts</span> <span class="main">=</span>
                filter_out <span class="main">(</span>Variable.is_fixed <span class="entity">ctxt</span> o fst o Term.dest_Free<span class="main">)</span> <span class="entity">ts</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="entity">state</span> |&gt; <span class="entity">Proof.map_contexts</span> <span class="main">(</span><span class="entity">Auto2_State.set_selected</span> <span class="main">(</span>SOME <span class="entity">i</span><span class="main">)</span><span class="main">)</span>
                  |&gt; <span class="entity">Proof.map_contexts</span> <span class="main">(</span><span class="entity">Auto2_State.map_head_th</span> <span class="main">(</span>K <span class="entity">prop</span><span class="main">)</span><span class="main">)</span>
                  |&gt; <span class="entity">Proof.map_contexts</span> <span class="main">(</span>fold <span class="entity">Util.declare_free_term</span> <span class="entity">new_ts</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
    <span class="entity">Outer_Syntax.command</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">command_keyword</span> "<span class="keyword1">@subgoal</span>"<span class="antiquote">}</span></span></span> <span class="inner_quoted">"select subgoal"</span>
    <span class="main">(</span>Parse.term &gt;&gt;
       <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">s</span> <span class="main">=&gt;</span> <span class="entity">Toplevel.proof</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">state</span> <span class="main">=&gt;</span> <span class="entity">subgoal_cmd</span> <span class="entity">s</span> <span class="entity">state</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

<span class="comment1">(* Use auto2 to resolve one of the goals. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">auto2_solve_goal</span> <span class="entity">ctxt</span> <span class="entity">prop</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_goal_resolved</span> <span class="entity">prop</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">prop</span> <span class="keyword2"><span class="keyword">else</span></span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">vars</span><span class="main">,</span> <span class="main">(</span><span class="entity">As</span><span class="main">,</span> <span class="entity">C</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
          <span class="entity">prop</span> |&gt; Thm.prems_of |&gt; the_single |&gt; <span class="entity">Util.strip_meta_horn</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">body</span> <span class="main">=</span> <span class="entity">Util.list_meta_horn</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">(</span><span class="entity">As</span><span class="main">,</span> <span class="entity">C</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th</span> <span class="main">=</span> <span class="entity">auto2_solve</span> <span class="entity">ctxt</span> <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">body</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">th</span> |&gt; fold Thm.forall_intr <span class="main">(</span>rev <span class="main">(</span>map <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">vars</span><span class="main">)</span><span class="main">)</span>
         |&gt; Thm.implies_elim <span class="entity">prop</span>
         |&gt; Goal.conclude
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Implementation of the @endgoal command.

   There should be more than one goal in the current frame, and one of
   the goals is selected. Use auto2 to finish the selected goal.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">endgoal_cmd</span> <span class="entity">state</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">Proof.goal</span> <span class="entity">state</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">goals</span><span class="main">,</span> <span class="entity">selected</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">Auto2_State.get_top_frame</span> <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span>length <span class="entity">goals</span> &gt; <span class="inner_numeral">1</span> <span class="keyword1"><span class="keyword">andalso</span></span> is_some <span class="entity">selected</span><span class="main">)</span>
                     <span class="inner_quoted">"@endgoal: called without a selection"</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prop</span> <span class="main">=</span> snd <span class="main">(</span>nth <span class="entity">goals</span> <span class="main">(</span>the <span class="entity">selected</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">solved_prop</span> <span class="main">=</span> <span class="entity">auto2_solve_goal</span> <span class="entity">ctxt</span> <span class="entity">prop</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">state</span> |&gt; <span class="entity">Proof.map_contexts</span> <span class="main">(</span><span class="entity">Auto2_State.map_head_th</span> <span class="main">(</span>K <span class="entity">solved_prop</span><span class="main">)</span><span class="main">)</span>
            |&gt; <span class="entity">Proof.map_contexts</span> <span class="main">(</span><span class="entity">Auto2_State.set_selected</span> NONE<span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
    <span class="entity">Outer_Syntax.command</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">command_keyword</span> "<span class="keyword1">@endgoal</span>"<span class="antiquote">}</span></span></span> <span class="inner_quoted">"endgoal of with block"</span>
    <span class="main">(</span>Scan.succeed <span class="main">(</span>
        <span class="entity">Toplevel.proof</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">state</span> <span class="main">=&gt;</span> <span class="entity">endgoal_cmd</span> <span class="entity">state</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

<span class="comment1">(* Implementation of the @end command.

   If there is exactly one goal in the current frame, that goal should
   be selected and unresolved. Use auto2 to resolve that goal. If
   there are multiple goals in the current frame, use auto2 to finish
   all unresolved goals.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">end_cmd</span> <span class="entity">state</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">Proof.goal</span> <span class="entity">state</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">goals</span><span class="main">,</span> <span class="entity">selected</span><span class="main">,</span> <span class="entity">after_qed</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">Auto2_State.get_top_frame</span> <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span><span class="main">(</span>length <span class="entity">goals</span> <span class="main">=</span> <span class="inner_numeral">1</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">selected</span> <span class="main">=</span> SOME <span class="inner_numeral">0</span><span class="main">)</span> <span class="keyword1"><span class="keyword">orelse</span></span>
                      <span class="main">(</span>length <span class="entity">goals</span> &gt; <span class="inner_numeral">1</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">selected</span> <span class="main">=</span> NONE<span class="main">)</span><span class="main">)</span>
                     <span class="inner_quoted">"@end: cannot call within an selection."</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">solved_props</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">auto2_solve_goal</span> <span class="entity">ctxt</span> o snd<span class="main">)</span> <span class="entity">goals</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span>forall <span class="entity">is_goal_resolved</span> <span class="entity">solved_props</span><span class="main">)</span>
                     <span class="inner_quoted">"@end: failed to resolve all goals"</span>

      <span class="comment1">(* List of new variables, and callback function. *)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">new_vars</span><span class="main">,</span> <span class="entity">f</span><span class="main">)</span> <span class="main">=</span> the <span class="entity">after_qed</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">state</span> |&gt; <span class="entity">Proof.map_contexts</span> <span class="entity">Auto2_State.pop_head</span>
            |&gt; <span class="entity">Proof.map_contexts</span> <span class="main">(</span><span class="entity">Auto2_State.map_head_th</span> <span class="main">(</span><span class="entity">f</span> <span class="entity">solved_props</span><span class="main">)</span><span class="main">)</span>
            |&gt; <span class="entity">Proof.map_contexts</span> <span class="main">(</span>fold <span class="entity">Util.declare_free_term</span> <span class="entity">new_vars</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
    <span class="entity">Outer_Syntax.command</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">command_keyword</span> "<span class="keyword1">@end</span>"<span class="antiquote">}</span></span></span> <span class="inner_quoted">"end of with block"</span>
    <span class="main">(</span>Scan.succeed <span class="main">(</span>
        <span class="entity">Toplevel.proof</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">state</span> <span class="main">=&gt;</span> <span class="entity">end_cmd</span> <span class="entity">state</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

<span class="comment1">(* Implementation of the @qed command. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">qed_cmd</span> <span class="entity">state</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">Proof.goal</span> <span class="entity">state</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span><span class="entity">Auto2_State.get_num_frame</span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="inner_numeral">1</span><span class="main">)</span>
                     <span class="inner_quoted">"Qed should be applied outside any 'with' blocks"</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prop</span> <span class="main">=</span> <span class="entity">Auto2_State.get_selected</span> <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">vars</span><span class="main">,</span> <span class="main">(</span><span class="entity">As</span><span class="main">,</span> <span class="entity">C</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">prop</span> |&gt; Thm.prems_of |&gt; the_single
                                 |&gt; <span class="entity">Util.strip_meta_horn</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">body</span> <span class="main">=</span> <span class="entity">Util.list_meta_horn</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">(</span><span class="entity">As</span><span class="main">,</span> <span class="entity">C</span><span class="main">)</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th</span> <span class="main">=</span> <span class="main">(</span><span class="entity">auto2_solve</span> <span class="entity">ctxt</span> <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">body</span><span class="main">)</span><span class="main">)</span>
                   |&gt; fold Thm.forall_intr <span class="main">(</span>rev <span class="main">(</span>map <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">vars</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">new_prop</span> <span class="main">=</span> Thm.implies_elim <span class="entity">prop</span> <span class="entity">th</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">method</span> <span class="main">=</span> K <span class="main">(</span><span class="entity">Context_Tactic.CONTEXT_TACTIC</span> <span class="main">(</span>PRIMITIVE <span class="main">(</span>K <span class="entity">new_prop</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">state</span> |&gt; <span class="entity">Proof.map_contexts</span> <span class="main">(</span><span class="entity">Auto2_State.map_head_th</span> <span class="main">(</span>K <span class="entity">new_prop</span><span class="main">)</span><span class="main">)</span>
            |&gt; <span class="entity">Proof.refine_singleton</span> <span class="main">(</span><span class="entity">Method.Basic</span> <span class="main">(</span>K <span class="entity">method</span><span class="main">)</span><span class="main">)</span>
            |&gt; <span class="entity">Proof.global_done_proof</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
    <span class="entity">Outer_Syntax.command</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">command_keyword</span> "<span class="keyword1">@qed</span>"<span class="antiquote">}</span></span></span> <span class="inner_quoted">"end of proof"</span>
    <span class="main">(</span>Scan.succeed <span class="main">(</span>
        <span class="entity">Toplevel.end_proof</span> <span class="main">(</span>K <span class="entity">qed_cmd</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

<span class="comment1">(* Given theorem As ==&gt; EX y. P(y), a term C, and a list of variables
   x, obtain the theorem (!!x y. As ==&gt; P(y) ==&gt; C) ==&gt; (!!x. As ==&gt;
   C).
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">obtain_resolve</span> <span class="entity">ctxt</span> <span class="entity">vars</span> <span class="entity">th</span> <span class="entity">concl</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prop</span> <span class="main">=</span> Thm.prop_of <span class="entity">th</span>

      <span class="comment1">(* B is EX y. P(y) *)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">As</span><span class="main">,</span> <span class="entity">B</span><span class="main">)</span> <span class="main">=</span> Logic.strip_horn <span class="entity">prop</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cAs</span> <span class="main">=</span> map <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">As</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">c_vars</span> <span class="main">=</span> map <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">vars</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">new_vars</span><span class="main">,</span> <span class="entity">body</span><span class="main">)</span> <span class="main">=</span> <span class="entity">UtilLogic.strip_exists</span> <span class="main">(</span><span class="entity">dest_Trueprop</span> <span class="entity">B</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">As'</span> <span class="main">=</span> <span class="entity">As</span> @ <span class="main">[</span><span class="entity">mk_Trueprop</span> <span class="entity">body</span><span class="main">]</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">stmt</span> <span class="main">=</span> <span class="main">(</span><span class="entity">Util.list_meta_horn</span> <span class="main">(</span><span class="entity">vars</span> @ <span class="entity">new_vars</span><span class="main">,</span> <span class="main">(</span><span class="entity">As'</span><span class="main">,</span> <span class="entity">concl</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
                     |&gt; Thm.cterm_of <span class="entity">ctxt</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thAs</span> <span class="main">=</span> map Thm.assume <span class="entity">cAs</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th_b</span> <span class="main">=</span> <span class="entity">th</span> |&gt; fold Thm.elim_implies <span class="entity">thAs</span>

      <span class="comment1">(* P(y) ==&gt; C *)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th_bc</span> <span class="main">=</span> <span class="entity">stmt</span> |&gt; Thm.assume
                       |&gt; fold Thm.forall_elim <span class="entity">c_vars</span>
                       |&gt; fold Thm.forall_elim <span class="main">(</span>map <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">new_vars</span><span class="main">)</span>
                       |&gt; fold Thm.elim_implies <span class="entity">thAs</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th_c</span> <span class="main">=</span> <span class="main">(</span>fold <span class="main">(</span><span class="entity">UtilLogic.ex_elim</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="main">(</span>rev <span class="entity">new_vars</span><span class="main">)</span> <span class="entity">th_bc</span><span class="main">)</span>
                     |&gt; Thm.elim_implies <span class="entity">th_b</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">th_c</span> |&gt; fold Thm.implies_intr <span class="main">(</span>rev <span class="entity">cAs</span><span class="main">)</span>
           |&gt; fold Thm.forall_intr <span class="main">(</span>rev <span class="entity">c_vars</span><span class="main">)</span>
           |&gt; Thm.implies_intr <span class="entity">stmt</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Give prop in the form (!!x. As ==&gt; C) ==&gt; D, and th in the form As
   ==&gt; EX y. P(y), return the theorem (!!x y. As ==&gt; P(y) ==&gt; C) ==&gt;
   D.

   In effect, this creates new variables y with property P(y) in the
   current subgoal.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">obtain_after_qed</span> <span class="entity">ctxt</span> <span class="entity">ths</span> <span class="entity">prop</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th</span> <span class="main">=</span> the_single <span class="entity">ths</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">vars</span><span class="main">,</span> <span class="main">(</span><span class="entity">As</span><span class="main">,</span> <span class="entity">C</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">prop</span> |&gt; Thm.prems_of |&gt; the_single
                                 |&gt; <span class="entity">Util.strip_meta_horn</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">body</span> <span class="main">=</span> <span class="entity">Util.list_meta_horn</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">(</span><span class="entity">As</span><span class="main">,</span> <span class="entity">C</span><span class="main">)</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">concl</span> <span class="main">=</span> Logic.strip_imp_concl <span class="entity">body</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">obtain_res</span> <span class="main">=</span> <span class="entity">obtain_resolve</span> <span class="entity">ctxt</span> <span class="entity">vars</span> <span class="entity">th</span> <span class="entity">concl</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">refine_subgoal_th</span> <span class="entity">obtain_res</span> <span class="entity">prop</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Implementation of @obtain command. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">obtain_cmd</span> <span class="main">(</span><span class="entity">vars</span><span class="main">,</span> <span class="entity">conds</span><span class="main">,</span> <span class="entity">is_with</span><span class="main">)</span> <span class="entity">state</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">Proof.goal</span> <span class="entity">state</span>

      <span class="comment1">(* First read list of variables and conditions *)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">vars</span><span class="main">,</span> <span class="entity">conds</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Syntax.read_terms <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">vars</span> @ <span class="entity">conds</span><span class="main">)</span><span class="main">)</span>
                              |&gt; chop <span class="main">(</span>length <span class="entity">vars</span><span class="main">)</span>

      <span class="comment1">(* Elements of vars can be in the form x : A, process it into a
         variable x and a condition x : A.
       *)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">vars</span><span class="main">,</span> <span class="entity">conds</span><span class="main">)</span> <span class="main">=</span>
          <span class="main">(</span>map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_mem</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">dest_arg1</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">t</span><span class="main">)</span> <span class="entity">vars</span><span class="main">,</span>
           filter <span class="entity">is_mem</span> <span class="entity">vars</span> @ <span class="entity">conds</span><span class="main">)</span>

      <span class="comment1">(* Goal: EX vars. conds *)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">C</span> <span class="main">=</span> <span class="entity">conds</span> |&gt; <span class="entity">list_conj</span> |&gt; fold <span class="entity">mk_exists</span> <span class="main">(</span>rev <span class="entity">vars</span><span class="main">)</span> |&gt; <span class="entity">mk_Trueprop</span>

      <span class="comment1">(* Current subgoal *)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">(</span><span class="entity">As</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">ctxt</span> |&gt; <span class="entity">Auto2_State.get_subgoal</span>
                              |&gt; <span class="entity">Util.strip_meta_horn</span>

      <span class="comment1">(* Actual goal: As ==&gt; EX vars. conds *)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">stmt</span> <span class="main">=</span> Logic.list_implies <span class="main">(</span><span class="entity">As</span><span class="main">,</span> <span class="entity">C</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">new_vars</span> <span class="main">=</span>
          filter_out <span class="main">(</span>Variable.is_fixed <span class="entity">ctxt</span> o fst o Term.dest_Free<span class="main">)</span> <span class="entity">vars</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">after_qed</span> <span class="main">=</span> <span class="entity">obtain_after_qed</span> <span class="entity">ctxt</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> not <span class="entity">is_with</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="comment1">(* Run auto2 to obtain As ==&gt; EX vars. conds. *)</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th</span> <span class="main">=</span> <span class="entity">auto2_solve</span> <span class="entity">ctxt</span> <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">stmt</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="entity">state</span> |&gt; <span class="entity">Proof.map_contexts</span> <span class="main">(</span>fold <span class="entity">Util.declare_free_term</span> <span class="entity">new_vars</span><span class="main">)</span>
                |&gt; <span class="entity">Proof.map_contexts</span> <span class="main">(</span><span class="entity">Auto2_State.map_head_th</span> <span class="main">(</span><span class="entity">after_qed</span> <span class="main">[</span><span class="entity">th</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">new_frame</span> <span class="main">=</span> <span class="entity">Auto2_State.simple_frame</span> <span class="main">(</span>
                Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">stmt</span><span class="main">,</span> SOME <span class="main">(</span><span class="entity">new_vars</span><span class="main">,</span> <span class="entity">after_qed</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="entity">state</span> |&gt; <span class="entity">Proof.map_contexts</span> <span class="main">(</span><span class="entity">Auto2_State.push_head</span> <span class="entity">new_frame</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">obtain_param</span> <span class="main">=</span>
    Scan.repeat Parse.term --
    Scan.option <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">keyword</span> "<span class="keyword2">where</span>"<span class="antiquote">}</span></span></span> |-- Scan.repeat Parse.term<span class="main">)</span> --
    <span class="entity">read_with</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  <span class="entity">Outer_Syntax.command</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">command_keyword</span> "<span class="keyword1">@obtain</span>"<span class="antiquote">}</span></span></span> <span class="inner_quoted">"obtain variables"</span>
    <span class="main">(</span><span class="entity">obtain_param</span> &gt;&gt;
       <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">vars</span><span class="main">,</span> <span class="entity">conds</span><span class="main">)</span><span class="main">,</span> <span class="entity">with_opt</span><span class="main">)</span> <span class="main">=&gt;</span>
           <span class="entity">Toplevel.proof</span> <span class="main">(</span>
             <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">state</span> <span class="main">=&gt;</span>
                <span class="entity">obtain_cmd</span> <span class="main">(</span><span class="entity">vars</span><span class="main">,</span> these <span class="entity">conds</span><span class="main">,</span> is_some <span class="entity">with_opt</span><span class="main">)</span> <span class="entity">state</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

<span class="comment1">(* Given theorem As ==&gt; B ==&gt; C, and a list of variables x, obtain the
   theorem (!!x. As ==&gt; ~B ==&gt; C) ==&gt; (!!x. As ==&gt; C).
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">case_resolve</span> <span class="entity">ctxt</span> <span class="entity">vars</span> <span class="entity">th</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prop</span> <span class="main">=</span> Thm.prop_of <span class="entity">th</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">As</span><span class="main">,</span> <span class="entity">B</span><span class="main">)</span><span class="main">,</span> <span class="entity">C</span><span class="main">)</span> <span class="main">=</span> <span class="entity">prop</span> |&gt; Logic.strip_horn |&gt; apfst split_last
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cAs</span> <span class="main">=</span> map <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">As</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">c_vars</span> <span class="main">=</span> map <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">vars</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">nB</span> <span class="main">=</span> <span class="entity">mk_Trueprop</span> <span class="main">(</span><span class="entity">Not</span> $ <span class="main">(</span><span class="entity">dest_Trueprop</span> <span class="entity">B</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">stmt</span> <span class="main">=</span> <span class="main">(</span><span class="entity">Util.list_meta_horn</span> <span class="main">(</span><span class="entity">vars</span><span class="main">,</span> <span class="main">(</span><span class="entity">As</span> @ <span class="main">[</span><span class="entity">nB</span><span class="main">]</span><span class="main">,</span> <span class="entity">C</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
                     |&gt; Thm.cterm_of <span class="entity">ctxt</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thAs</span> <span class="main">=</span> map Thm.assume <span class="entity">cAs</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th_nbc</span> <span class="main">=</span>
          <span class="entity">stmt</span> |&gt; Thm.assume  <span class="comment1">(* !!x. As ==&gt; ~B ==&gt; C *)</span>
               |&gt; fold Thm.forall_elim <span class="entity">c_vars</span>
               |&gt; fold Thm.elim_implies <span class="entity">thAs</span>  <span class="comment1">(* ~B ==&gt; C *)</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th_bc</span> <span class="main">=</span> <span class="entity">th</span> |&gt; fold Thm.elim_implies <span class="entity">thAs</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inst</span> <span class="main">=</span> <span class="entity">fo_init</span> |&gt; <span class="entity">Util.update_env</span> <span class="main">(</span><span class="main">(</span><span class="inner_quoted">"P"</span><span class="main">,</span><span class="inner_numeral">0</span><span class="main">)</span><span class="main">,</span> <span class="entity">dest_Trueprop</span> <span class="entity">B</span><span class="main">)</span>
                         |&gt; <span class="entity">Util.update_env</span> <span class="main">(</span><span class="main">(</span><span class="inner_quoted">"Q"</span><span class="main">,</span><span class="inner_numeral">0</span><span class="main">)</span><span class="main">,</span> <span class="entity">dest_Trueprop</span> <span class="entity">C</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th_c</span> <span class="main">=</span> <span class="main">(</span><span class="entity">Util.subst_thm</span> <span class="entity">ctxt</span> <span class="entity">inst</span> <span class="entity">UtilBase.case_split_th</span><span class="main">)</span>
                     |&gt; fold Thm.elim_implies <span class="main">[</span><span class="entity">th_bc</span><span class="main">,</span> <span class="entity">th_nbc</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">th_c</span> |&gt; fold Thm.implies_intr <span class="main">(</span>rev <span class="entity">cAs</span><span class="main">)</span>
           |&gt; fold Thm.forall_intr <span class="main">(</span>rev <span class="entity">c_vars</span><span class="main">)</span>
           |&gt; Thm.implies_intr <span class="entity">stmt</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Given prop in the form (!!x. As ==&gt; C) ==&gt; D, and th in the form As
   ==&gt; B ==&gt; C, return the theorem (!!x. As ==&gt; ~B ==&gt; C) ==&gt; D.

   In effect, this adds ~B as extra assumption in the current subgoal.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">case_after_qed</span> <span class="entity">ctxt</span> <span class="entity">ths</span> <span class="entity">prop</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th</span> <span class="main">=</span> the_single <span class="entity">ths</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">vars</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">prop</span> |&gt; Thm.prems_of |&gt; the_single
                           |&gt; <span class="entity">Util.strip_meta_horn</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">case_res</span> <span class="main">=</span> <span class="entity">case_resolve</span> <span class="entity">ctxt</span> <span class="entity">vars</span> <span class="entity">th</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">refine_subgoal_th</span> <span class="entity">case_res</span> <span class="entity">prop</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Implementation of @case command. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">case_cmd</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">is_with</span><span class="main">)</span> <span class="entity">state</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">Proof.goal</span> <span class="entity">state</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">B</span> <span class="main">=</span> <span class="entity">t</span> |&gt; Syntax.read_term <span class="entity">ctxt</span> |&gt; <span class="entity">mk_Trueprop</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">(</span><span class="entity">As</span><span class="main">,</span> <span class="entity">C</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">ctxt</span> |&gt; <span class="entity">Auto2_State.get_subgoal</span>
                              |&gt; <span class="entity">Util.strip_meta_horn</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">stmt</span> <span class="main">=</span> Logic.list_implies <span class="main">(</span><span class="entity">As</span> @ <span class="main">[</span><span class="entity">B</span><span class="main">]</span><span class="main">,</span> <span class="entity">C</span><span class="main">)</span> |&gt; Thm.cterm_of <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">after_qed</span> <span class="main">=</span> <span class="entity">case_after_qed</span> <span class="entity">ctxt</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> not <span class="entity">is_with</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="comment1">(* Run auto2 to obtain A_1 ==&gt; ... ==&gt; A_n ==&gt; B ==&gt; C *)</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th</span> <span class="main">=</span> <span class="entity">auto2_solve</span> <span class="entity">ctxt</span> <span class="entity">stmt</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="entity">state</span> |&gt; <span class="entity">Proof.map_contexts</span> <span class="main">(</span><span class="entity">Auto2_State.map_head_th</span> <span class="main">(</span><span class="entity">after_qed</span> <span class="main">[</span><span class="entity">th</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">new_frame</span> <span class="main">=</span> <span class="entity">Auto2_State.simple_frame</span> <span class="main">(</span><span class="entity">stmt</span><span class="main">,</span> SOME <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">after_qed</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="entity">state</span> |&gt; <span class="entity">Proof.map_contexts</span> <span class="main">(</span><span class="entity">Auto2_State.push_head</span> <span class="entity">new_frame</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
    <span class="entity">Outer_Syntax.command</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">command_keyword</span> "<span class="keyword1">@case</span>"<span class="antiquote">}</span></span></span> <span class="inner_quoted">"intermediate case"</span>
    <span class="main">(</span>Parse.term -- <span class="entity">read_with</span> &gt;&gt;
        <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">with_opt</span><span class="main">)</span> <span class="main">=&gt;</span>
            <span class="entity">Toplevel.proof</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">state</span> <span class="main">=&gt;</span> <span class="entity">case_cmd</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> is_some <span class="entity">with_opt</span><span class="main">)</span> <span class="entity">state</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

<span class="comment1">(* Given a list of variables x, assumptions As, and term C, return the
   theorem (!!x. As ==&gt; ~C ==&gt; False) ==&gt; (!!x. As ==&gt; C).
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">contra_resolve</span> <span class="entity">ctxt</span> <span class="entity">vars</span> <span class="entity">As</span> <span class="entity">C</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">stmt</span> <span class="main">=</span> <span class="main">(</span><span class="entity">Util.list_meta_horn</span> <span class="main">(</span><span class="entity">vars</span><span class="main">,</span> <span class="main">(</span><span class="entity">As</span> @ <span class="main">[</span><span class="entity">get_neg'</span> <span class="entity">C</span><span class="main">]</span><span class="main">,</span> <span class="entity">pFalse</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
                     |&gt; Thm.cterm_of <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cAs</span> <span class="main">=</span> map <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">As</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">c_vars</span> <span class="main">=</span> map <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">vars</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thAs</span> <span class="main">=</span> map Thm.assume <span class="entity">cAs</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th_c</span> <span class="main">=</span>
          <span class="entity">stmt</span> |&gt; Thm.assume  <span class="comment1">(* !!x. A_1 ==&gt; ... ==&gt; A_n ==&gt; ~C ==&gt; False *)</span>
               |&gt; fold Thm.forall_elim <span class="entity">c_vars</span>
               |&gt; fold Thm.elim_implies <span class="entity">thAs</span>  <span class="comment1">(* ~C ==&gt; False *)</span>
               |&gt; <span class="entity">apply_to_thm</span> <span class="entity">UtilLogic.rewrite_from_contra_form</span>  <span class="comment1">(* C *)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">th_c</span> |&gt; fold Thm.implies_intr <span class="main">(</span>rev <span class="entity">cAs</span><span class="main">)</span>
           |&gt; fold Thm.forall_intr <span class="main">(</span>rev <span class="entity">c_vars</span><span class="main">)</span>
           |&gt; Thm.implies_intr <span class="entity">stmt</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Given prop in the form (!!x. As ==&gt; C) ==&gt; D, return the theorem
   (!!x. As ==&gt; ~C ==&gt; False) ==&gt; D.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">contra_after_qed</span> <span class="entity">ctxt</span> <span class="entity">prop</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">vars</span><span class="main">,</span> <span class="main">(</span><span class="entity">As</span><span class="main">,</span> <span class="entity">C</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">prop</span> |&gt; Thm.prems_of |&gt; the_single
                                 |&gt; <span class="entity">Util.strip_meta_horn</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">contra_res</span> <span class="main">=</span> <span class="entity">contra_resolve</span> <span class="entity">ctxt</span> <span class="entity">vars</span> <span class="entity">As</span> <span class="entity">C</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">refine_subgoal_th</span> <span class="entity">contra_res</span> <span class="entity">prop</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Implementation of @contradiction command. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">contra_cmd</span> <span class="entity">state</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">Proof.goal</span> <span class="entity">state</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">after_qed</span> <span class="main">=</span> <span class="entity">contra_after_qed</span> <span class="entity">ctxt</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">state</span> |&gt; <span class="entity">Proof.map_contexts</span> <span class="main">(</span><span class="entity">Auto2_State.map_head_th</span> <span class="entity">after_qed</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
    <span class="entity">Outer_Syntax.command</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">command_keyword</span> "<span class="keyword1">@contradiction</span>"<span class="antiquote">}</span></span></span>
    <span class="inner_quoted">"apply proof by contradiction"</span>
    <span class="main">(</span>Scan.succeed <span class="main">(</span>
        <span class="entity">Toplevel.proof</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">state</span> <span class="main">=&gt;</span> <span class="entity">contra_cmd</span> <span class="entity">state</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

<span class="comment1">(* Given a list of variables x, an equation y = t, assumptions As, and
   a term C, return the theorem (!!x y. As ==&gt; y = t ==&gt; C) ==&gt;
   (!!x. As ==&gt; C).
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">let_resolve</span> <span class="entity">ctxt</span> <span class="entity">vars</span> <span class="entity">eq</span> <span class="entity">As</span> <span class="entity">C</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span>

      <span class="comment1">(* Call obtain_resolve with th as A_i ==&gt; EX y. y = t. *)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">dest_eq</span> <span class="entity">eq</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pat_a</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">UtilBase.ex_vardef_th</span> |&gt; <span class="entity">prop_of'</span> |&gt; <span class="entity">dest_arg</span> <span class="keyword2"><span class="keyword">of</span></span>
                      Abs <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">b</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">dest_arg</span> <span class="entity">b</span>
                    <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"ex_vardef_th"</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> Term.dest_Free <span class="entity">lhs</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inst</span> <span class="main">=</span> Pattern.first_order_match <span class="entity">thy</span> <span class="main">(</span><span class="entity">pat_a</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="entity">fo_init</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ex_th</span> <span class="main">=</span> <span class="entity">Util.subst_thm</span> <span class="entity">ctxt</span> <span class="entity">inst</span> <span class="entity">UtilBase.ex_vardef_th</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t'</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> Thm.prop_of <span class="entity">ex_th</span> <span class="keyword2"><span class="keyword">of</span></span>
                   <span class="entity">A</span> $ <span class="main">(</span><span class="entity">B</span> $ Abs <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">T</span><span class="main">,</span> <span class="entity">body</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">A</span> $ <span class="main">(</span><span class="entity">B</span> $ Abs <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">T</span><span class="main">,</span> <span class="entity">body</span><span class="main">)</span><span class="main">)</span>
                 <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> error <span class="inner_quoted">"let_resolve"</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ex_th</span> <span class="main">=</span>
          <span class="entity">ex_th</span> |&gt; Thm.renamed_prop <span class="entity">t'</span>
                |&gt; fold Thm.implies_intr <span class="main">(</span>rev <span class="main">(</span>map <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">As</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">obtain_resolve</span> <span class="entity">ctxt</span> <span class="entity">vars</span> <span class="entity">ex_th</span> <span class="entity">C</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Given prop in the form (!!x. As ==&gt; C) ==&gt; D, and an equation y =
   t, return the theorem (!!x y. As ==&gt; y = t ==&gt; C) ==&gt; D.

   In effect, this creates a new variable y with property y = t in the
   current subgoal.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">let_after_qed</span> <span class="entity">ctxt</span> <span class="entity">eqs</span> <span class="entity">prop</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">fold_one</span> <span class="entity">eq</span> <span class="entity">prop</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">vars</span><span class="main">,</span> <span class="main">(</span><span class="entity">As</span><span class="main">,</span> <span class="entity">C</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">prop</span> |&gt; Thm.prems_of |&gt; the_single
                                       |&gt; <span class="entity">Util.strip_meta_horn</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">let_res</span> <span class="main">=</span> <span class="entity">let_resolve</span> <span class="entity">ctxt</span> <span class="entity">vars</span> <span class="entity">eq</span> <span class="entity">As</span> <span class="entity">C</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="entity">refine_subgoal_th</span> <span class="entity">let_res</span> <span class="entity">prop</span>
          <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">in</span></span>
      fold <span class="entity">fold_one</span> <span class="entity">eqs</span> <span class="entity">prop</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Implementation of the @let command. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">let_cmd</span> <span class="entity">eqs</span> <span class="entity">state</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">Proof.goal</span> <span class="entity">state</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eqs</span> <span class="main">=</span> Syntax.read_terms <span class="entity">ctxt</span> <span class="entity">eqs</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">vars</span> <span class="main">=</span> map <span class="main">(</span>fst o <span class="entity">dest_eq</span><span class="main">)</span> <span class="entity">eqs</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">new_vars</span> <span class="main">=</span>
          filter_out <span class="main">(</span>Variable.is_fixed <span class="entity">ctxt</span> o fst o Term.dest_Free<span class="main">)</span> <span class="entity">vars</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">after_qed</span> <span class="main">=</span> <span class="entity">let_after_qed</span> <span class="entity">ctxt</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">state</span> |&gt; <span class="entity">Proof.map_context</span> <span class="main">(</span>fold <span class="entity">Util.declare_free_term</span> <span class="entity">new_vars</span><span class="main">)</span>
            |&gt; <span class="entity">Proof.map_contexts</span> <span class="main">(</span><span class="entity">Auto2_State.map_head_th</span> <span class="main">(</span><span class="entity">after_qed</span> <span class="entity">eqs</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
    <span class="entity">Outer_Syntax.command</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">command_keyword</span> "<span class="keyword1">@let</span>"<span class="antiquote">}</span></span></span> <span class="inner_quoted">"define a variable"</span>
    <span class="main">(</span>Scan.repeat Parse.term &gt;&gt;
        <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">eqs</span> <span class="main">=&gt;</span> <span class="entity">Toplevel.proof</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">state</span> <span class="main">=&gt;</span> <span class="entity">let_cmd</span> <span class="entity">eqs</span> <span class="entity">state</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>  <span class="comment1">(* structure Auto2_Outer *)</span>
</pre>
</div><div id="files/acdata.ML">
<div class="head">
<h1>File ‹acdata.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*
  File: acdata.ML
  Author: Bohua Zhan

  Dealing with associative-commutative operations.
*)</span>

<span class="comment1">(* Data for an AC function. *)</span>
<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">ac_info</span> <span class="main">=</span> <span class="main">{</span>
  cfhead<span class="main">:</span> cterm<span class="main">,</span>
  unit<span class="main">:</span> cterm option<span class="main">,</span>
  assoc_th<span class="main">:</span> thm<span class="main">,</span>  <span class="comment1">(* (a . b) . c = a . (b . c) *)</span>
  comm_th<span class="main">:</span> thm<span class="main">,</span>   <span class="comment1">(* a . b = b . a *)</span>
  unitl_th<span class="main">:</span> thm<span class="main">,</span>  <span class="comment1">(* e . a = a *)</span>
  unitr_th<span class="main">:</span> thm   <span class="comment1">(* a . e = a *)</span>
<span class="main">}</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">ACUTIL</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> inst_ac_info<span class="main">:</span> theory <span class="main">-&gt;</span> typ <span class="main">-&gt;</span> <span class="entity">ac_info</span> <span class="main">-&gt;</span> <span class="entity">ac_info</span> option
  <span class="keyword1"><span class="keyword">val</span></span> head_agrees<span class="main">:</span> <span class="entity">ac_info</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> eq_unit<span class="main">:</span> <span class="entity">ac_info</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> add_ac_data<span class="main">:</span> <span class="entity">ac_info</span> <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> get_head_ac_info<span class="main">:</span> theory <span class="main">-&gt;</span> term <span class="main">-&gt;</span> <span class="entity">ac_info</span> option

  <span class="keyword1"><span class="keyword">val</span></span> has_assoc_th<span class="main">:</span> <span class="entity">ac_info</span> <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> has_comm_th<span class="main">:</span> <span class="entity">ac_info</span> <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> has_unit_th<span class="main">:</span> <span class="entity">ac_info</span> <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> comm_cv<span class="main">:</span> <span class="entity">ac_info</span> <span class="main">-&gt;</span> conv
  <span class="keyword1"><span class="keyword">val</span></span> assoc_cv<span class="main">:</span> <span class="entity">ac_info</span> <span class="main">-&gt;</span> conv
  <span class="keyword1"><span class="keyword">val</span></span> assoc_sym_cv<span class="main">:</span> <span class="entity">ac_info</span> <span class="main">-&gt;</span> conv
  <span class="keyword1"><span class="keyword">val</span></span> swap_cv<span class="main">:</span> <span class="entity">ac_info</span> <span class="main">-&gt;</span> conv
  <span class="keyword1"><span class="keyword">val</span></span> swap_r_cv<span class="main">:</span> <span class="entity">ac_info</span> <span class="main">-&gt;</span> conv

  <span class="keyword1"><span class="keyword">val</span></span> dest_ac<span class="main">:</span> <span class="entity">ac_info</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> term list
  <span class="keyword1"><span class="keyword">val</span></span> cdest_ac<span class="main">:</span> <span class="entity">ac_info</span> <span class="main">-&gt;</span> cterm <span class="main">-&gt;</span> cterm list
  <span class="keyword1"><span class="keyword">val</span></span> comb_ac_equiv<span class="main">:</span> <span class="entity">ac_info</span> <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> normalize_assoc<span class="main">:</span> <span class="entity">ac_info</span> <span class="main">-&gt;</span> conv
  <span class="keyword1"><span class="keyword">val</span></span> move_outmost<span class="main">:</span> <span class="entity">ac_info</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> conv
  <span class="keyword1"><span class="keyword">val</span></span> normalize_unit<span class="main">:</span> <span class="entity">ac_info</span> <span class="main">-&gt;</span> conv
  <span class="keyword1"><span class="keyword">val</span></span> normalize_comm_gen<span class="main">:</span> <span class="entity">ac_info</span> <span class="main">-&gt;</span> <span class="main">(</span>term * term <span class="main">-&gt;</span> bool<span class="main">)</span> <span class="main">-&gt;</span> conv
  <span class="keyword1"><span class="keyword">val</span></span> normalize_comm<span class="main">:</span> <span class="entity">ac_info</span> <span class="main">-&gt;</span> conv
  <span class="keyword1"><span class="keyword">val</span></span> normalize_au<span class="main">:</span> <span class="entity">ac_info</span> <span class="main">-&gt;</span> conv
  <span class="keyword1"><span class="keyword">val</span></span> normalize_all_ac<span class="main">:</span> <span class="entity">ac_info</span> <span class="main">-&gt;</span> conv
  <span class="keyword1"><span class="keyword">val</span></span> ac_last_conv<span class="main">:</span> <span class="entity">ac_info</span> <span class="main">-&gt;</span> conv <span class="main">-&gt;</span> conv
  <span class="keyword1"><span class="keyword">val</span></span> norm_combine<span class="main">:</span> <span class="entity">ac_info</span> <span class="main">-&gt;</span> <span class="main">(</span>term <span class="main">-&gt;</span> bool<span class="main">)</span> <span class="main">-&gt;</span> conv <span class="main">-&gt;</span> conv
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">ACUtil</span> <span class="main">:</span> <span class="entity">ACUTIL</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="comment1">(* Register of generators of ac_inst_info. *)</span>
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Data</span> <span class="main">=</span> Theory_Data <span class="main">(</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">T</span> <span class="main">=</span> <span class="entity">ac_info</span> Symtab.table<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">empty</span> <span class="main">=</span> Symtab.empty<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">extend</span> <span class="main">=</span> I<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">merge</span> <span class="main">=</span> Symtab.merge <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">info1</span><span class="main">,</span> <span class="entity">info2</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">#</span>cfhead <span class="entity">info1</span> aconvc <span class="main">#</span>cfhead <span class="entity">info2</span><span class="main">)</span>
<span class="main">)</span>

<span class="comment1">(* Instantiate an ac_info for a specific type T. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">inst_ac_info</span> <span class="entity">thy</span> <span class="entity">T</span> <span class="main">{</span><span class="entity">assoc_th</span><span class="main">,</span> <span class="entity">comm_th</span><span class="main">,</span> <span class="entity">unitl_th</span><span class="main">,</span> <span class="entity">unitr_th</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="comment1">(* Instantiate th to having argument of type T. If not possible,
         change th to true_th.
       *)</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">inst_th</span> <span class="entity">th</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_true_th</span> <span class="entity">th</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">true_th</span> <span class="keyword2"><span class="keyword">else</span></span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="comment1">(* Extract the first argument of th, then the body type of
               that argument.
             *)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg_type</span> <span class="main">=</span> <span class="entity">th</span> |&gt; <span class="entity">prop_of'</span> |&gt; <span class="entity">Util.dest_args</span> |&gt; hd
                              |&gt; Term.type_of |&gt; Term.body_type
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">arg_type</span> <span class="main">=</span> <span class="entity">T</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">th</span> <span class="keyword2"><span class="keyword">else</span></span>
            <span class="keyword2"><span class="keyword">let</span></span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tenv</span> <span class="main">=</span> Sign.typ_match <span class="entity">thy</span> <span class="main">(</span><span class="entity">arg_type</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> Vartab.empty
            <span class="keyword2"><span class="keyword">in</span></span>
              <span class="entity">Util.subst_thm_thy</span> <span class="entity">thy</span> <span class="main">(</span><span class="entity">tenv</span><span class="main">,</span> Vartab.empty<span class="main">)</span> <span class="entity">th</span>
            <span class="keyword2"><span class="keyword">end</span></span>
            <span class="keyword3"><span class="keyword">handle</span></span> Type.TYPE_MATCH <span class="main">=&gt;</span> <span class="entity">true_th</span>
          <span class="keyword2"><span class="keyword">end</span></span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">assoc_th'</span> <span class="main">=</span> <span class="entity">inst_th</span> <span class="entity">assoc_th</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">unitl_th'</span> <span class="main">=</span> <span class="entity">inst_th</span> <span class="entity">unitl_th</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_true_th</span> <span class="entity">assoc_th'</span> <span class="keyword2"><span class="keyword">then</span></span> NONE <span class="keyword2"><span class="keyword">else</span></span>
      SOME <span class="main">{</span>cfhead <span class="main">=</span> <span class="entity">assoc_th'</span> |&gt; <span class="entity">cprop_of'</span> |&gt; Thm.dest_arg1 |&gt; Thm.dest_fun2<span class="main">,</span>
            unit <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_true_th</span> <span class="entity">unitl_th'</span> <span class="keyword2"><span class="keyword">then</span></span> NONE
                   <span class="keyword2"><span class="keyword">else</span></span> SOME <span class="main">(</span><span class="entity">unitl_th'</span> |&gt;  <span class="entity">cprop_of'</span> |&gt; Thm.dest_arg1 |&gt; Thm.dest_arg1<span class="main">)</span><span class="main">,</span>
            assoc_th <span class="main">=</span> <span class="entity">assoc_th'</span><span class="main">,</span>
            comm_th <span class="main">=</span> <span class="entity">inst_th</span> <span class="entity">comm_th</span><span class="main">,</span>
            unitl_th <span class="main">=</span> <span class="entity">unitl_th'</span><span class="main">,</span>
            unitr_th <span class="main">=</span> <span class="entity">inst_th</span> <span class="entity">unitr_th</span><span class="main">}</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">head_agrees</span> <span class="main">{</span><span class="entity">cfhead</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">Util.is_head</span> <span class="main">(</span>Thm.term_of <span class="entity">cfhead</span><span class="main">)</span> <span class="entity">t</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">eq_unit</span> <span class="main">{</span><span class="entity">unit</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">unit</span> <span class="keyword2"><span class="keyword">of</span></span> NONE <span class="main">=&gt;</span> false <span class="main">|</span> SOME <span class="entity">ct'</span> <span class="main">=&gt;</span> <span class="entity">t</span> aconv <span class="main">(</span>Thm.term_of <span class="entity">ct'</span><span class="main">)</span>

<span class="comment1">(* Add the given ac_info under the given name. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_ac_data</span> <span class="entity">info</span> <span class="entity">thy</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">assoc_th</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">info</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">f</span> <span class="main">=</span> <span class="entity">assoc_th</span> |&gt; <span class="entity">prop_of'</span> |&gt; <span class="entity">dest_eq</span> |&gt; snd |&gt; Term.head_of
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">f</span> <span class="keyword2"><span class="keyword">of</span></span>
          Const <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> tracing <span class="main">(</span><span class="inner_quoted">"Add ac data for function "</span> ^ <span class="entity">c</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            Data.map <span class="main">(</span>Symtab.update_new <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">info</span><span class="main">)</span><span class="main">)</span> <span class="entity">thy</span>
          <span class="keyword2"><span class="keyword">end</span></span>
        <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> error <span class="inner_quoted">"Add AC data: invalid assoc_th"</span>
    <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword3"><span class="keyword">handle</span></span> Symtab.DUP <span class="main">_</span> <span class="main">=&gt;</span> error <span class="inner_quoted">"Add AC data: info already exists."</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_head_ac_info</span> <span class="entity">thy</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
        Const <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="main">_</span> $ <span class="main">_</span> <span class="main">=&gt;</span>
        <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> Symtab.lookup <span class="main">(</span>Data.get <span class="entity">thy</span><span class="main">)</span> <span class="entity">c</span> <span class="keyword2"><span class="keyword">of</span></span>
             NONE <span class="main">=&gt;</span> NONE
           <span class="main">|</span> SOME <span class="entity">ac_info</span> <span class="main">=&gt;</span> <span class="entity">inst_ac_info</span> <span class="entity">thy</span> <span class="main">(</span>fastype_of <span class="entity">t</span><span class="main">)</span> <span class="entity">ac_info</span><span class="main">)</span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> NONE

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">has_assoc_th</span> <span class="main">{</span><span class="entity">assoc_th</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> not <span class="main">(</span><span class="entity">is_true_th</span> <span class="entity">assoc_th</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">has_comm_th</span> <span class="main">{</span><span class="entity">comm_th</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> not <span class="main">(</span><span class="entity">is_true_th</span> <span class="entity">comm_th</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">has_unit_th</span> <span class="main">{</span><span class="entity">unitl_th</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> not <span class="main">(</span><span class="entity">is_true_th</span> <span class="entity">unitl_th</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">comm_cv</span> <span class="main">{</span><span class="entity">comm_th</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">rewr_obj_eq</span> <span class="entity">comm_th</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">assoc_cv</span> <span class="main">{</span><span class="entity">assoc_th</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">rewr_obj_eq</span> <span class="entity">assoc_th</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">assoc_sym_cv</span> <span class="main">{</span><span class="entity">assoc_th</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">rewr_obj_eq</span> <span class="main">(</span><span class="entity">obj_sym</span> <span class="entity">assoc_th</span><span class="main">)</span>

<span class="comment1">(* (a . b) . c = (a . c) . b *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">swap_cv</span> <span class="main">(</span><span class="entity">ac_info</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">{</span><span class="entity">assoc_th</span><span class="main">,</span> <span class="entity">comm_th</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">head_agrees</span> <span class="entity">ac_info</span> <span class="main">(</span><span class="entity">dest_arg1</span> <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
      Conv.every_conv <span class="main">[</span><span class="entity">rewr_obj_eq</span> <span class="entity">assoc_th</span><span class="main">,</span>
                       Conv.arg_conv <span class="main">(</span><span class="entity">rewr_obj_eq</span> <span class="entity">comm_th</span><span class="main">)</span><span class="main">,</span>
                       <span class="entity">rewr_obj_eq</span> <span class="main">(</span><span class="entity">obj_sym</span> <span class="entity">assoc_th</span><span class="main">)</span><span class="main">]</span> <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">else</span></span>
      <span class="entity">rewr_obj_eq</span> <span class="entity">comm_th</span> <span class="entity">ct</span>

<span class="comment1">(* a . (b . c) = b . (a . c) *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">swap_r_cv</span> <span class="main">(</span><span class="entity">ac_info</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">{</span><span class="entity">assoc_th</span><span class="main">,</span> <span class="entity">comm_th</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">head_agrees</span> <span class="entity">ac_info</span> <span class="main">(</span><span class="entity">dest_arg</span> <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
      Conv.every_conv <span class="main">[</span><span class="entity">rewr_obj_eq</span> <span class="main">(</span><span class="entity">obj_sym</span> <span class="entity">assoc_th</span><span class="main">)</span><span class="main">,</span>
                       Conv.arg1_conv <span class="main">(</span><span class="entity">rewr_obj_eq</span> <span class="entity">comm_th</span><span class="main">)</span><span class="main">,</span>
                       <span class="entity">rewr_obj_eq</span> <span class="entity">assoc_th</span><span class="main">]</span> <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">else</span></span>
      <span class="entity">rewr_obj_eq</span> <span class="entity">comm_th</span> <span class="entity">ct</span>

<span class="comment1">(* Destruct t, assuming it is associated to the left. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_ac</span> <span class="entity">ac_info</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest</span> <span class="entity">t</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">head_agrees</span> <span class="entity">ac_info</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
            <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">a1</span><span class="main">,</span> <span class="entity">a2</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Util.dest_binop_args</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">a2</span> :: <span class="entity">dest</span> <span class="entity">a1</span> <span class="keyword2"><span class="keyword">end</span></span>
          <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="entity">t</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      rev <span class="main">(</span><span class="entity">dest</span> <span class="entity">t</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">cdest_ac</span> <span class="entity">ac_info</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest</span> <span class="entity">ct</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">head_agrees</span> <span class="entity">ac_info</span> <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
            <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">a1</span><span class="main">,</span> <span class="entity">a2</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Util.dest_binop_cargs</span> <span class="entity">ct</span> <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">a2</span> :: <span class="entity">dest</span> <span class="entity">a1</span> <span class="keyword2"><span class="keyword">end</span></span>
          <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="entity">ct</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      rev <span class="main">(</span><span class="entity">dest</span> <span class="entity">ct</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Given ths: [A1 == B1, ..., An == Bn], get theorem A1...An ==
   B1...Bn. Associate to the left only.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">comb_ac_equiv</span> <span class="main">{</span><span class="entity">cfhead</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="entity">ths</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">binop_comb</span> <span class="entity">th1</span> <span class="entity">th2</span> <span class="main">=</span>
          Thm.combination <span class="main">(</span>Thm.combination <span class="main">(</span>Thm.reflexive <span class="entity">cfhead</span><span class="main">)</span> <span class="entity">th1</span><span class="main">)</span> <span class="entity">th2</span>

      <span class="comment1">(* Combine in the reverse order. *)</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">comb</span> <span class="entity">ths</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">ths</span> <span class="keyword2"><span class="keyword">of</span></span>
              <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"comb_ac_equiv: empty list"</span>
            <span class="main">|</span> <span class="main">[</span><span class="entity">th</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="entity">th</span>
            <span class="main">|</span> <span class="main">[</span><span class="entity">th1</span><span class="main">,</span> <span class="entity">th2</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="entity">binop_comb</span> <span class="entity">th2</span> <span class="entity">th1</span>
            <span class="main">|</span> <span class="entity">th</span> :: <span class="entity">ths'</span> <span class="main">=&gt;</span> <span class="entity">binop_comb</span> <span class="main">(</span><span class="entity">comb</span> <span class="entity">ths'</span><span class="main">)</span> <span class="entity">th</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">comb</span> <span class="main">(</span>rev <span class="entity">ths</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Normalize association with the given direction. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">normalize_assoc</span> <span class="entity">ac_info</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span><span class="entity">has_assoc_th</span> <span class="entity">ac_info</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> Conv.all_conv <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">assoc_th</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">ac_info</span>

      <span class="comment1">(* First rewrite into form (...) * a, then rewrite the remaining
         parts.
       *)</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">normalize</span> <span class="entity">ct</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">head_agrees</span> <span class="entity">ac_info</span> <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
            Conv.every_conv <span class="main">[</span>Conv.repeat_conv <span class="main">(</span><span class="entity">rewr_obj_eq</span> <span class="main">(</span><span class="entity">obj_sym</span> <span class="entity">assoc_th</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
                             Conv.arg1_conv <span class="entity">normalize</span><span class="main">]</span> <span class="entity">ct</span>
          <span class="keyword2"><span class="keyword">else</span></span>
            Conv.all_conv <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">normalize</span> <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Move the given u within ct to the rightmost position. Assume
   associate to the left.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">move_outmost</span> <span class="main">(</span><span class="entity">ac_info</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">{</span><span class="entity">comm_th</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="entity">u</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span><span class="entity">has_assoc_th</span> <span class="entity">ac_info</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">has_comm_th</span> <span class="entity">ac_info</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
      <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"move_outmost: commutativity is not available."</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">u</span> aconv <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> Conv.all_conv <span class="entity">ct</span> <span class="keyword2"><span class="keyword">else</span></span>
    <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span><span class="entity">head_agrees</span> <span class="entity">ac_info</span> <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
      <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"move_outmost: u not found in ct."</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="entity">b</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Util.dest_binop_args</span> <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">u</span> aconv <span class="entity">b</span> <span class="keyword2"><span class="keyword">then</span></span> Conv.all_conv <span class="entity">ct</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">head_agrees</span> <span class="entity">ac_info</span> <span class="entity">a</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="main">(</span><span class="main">(</span>Conv.arg1_conv <span class="main">(</span><span class="entity">move_outmost</span> <span class="entity">ac_info</span> <span class="entity">u</span><span class="main">)</span><span class="main">)</span>
             then_conv <span class="main">(</span><span class="entity">swap_cv</span> <span class="entity">ac_info</span><span class="main">)</span><span class="main">)</span> <span class="entity">ct</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">u</span> aconv <span class="entity">a</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="entity">rewr_obj_eq</span> <span class="entity">comm_th</span> <span class="entity">ct</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"move_outmost: u not found in ct."</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* In a product of a_1, a_2, ..., remove any a_i that is a unit. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">normalize_unit</span> <span class="main">(</span><span class="entity">ac_info</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">{</span><span class="entity">unitl_th</span><span class="main">,</span> <span class="entity">unitr_th</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span><span class="entity">has_unit_th</span> <span class="entity">ac_info</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> Conv.all_conv <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">normalize</span> <span class="entity">ct</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">head_agrees</span> <span class="entity">ac_info</span> <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
            Conv.every_conv <span class="main">[</span>Conv.binop_conv <span class="entity">normalize</span><span class="main">,</span>
                             Conv.try_conv <span class="main">(</span><span class="entity">rewr_obj_eq</span> <span class="entity">unitl_th</span><span class="main">)</span><span class="main">,</span>
                             Conv.try_conv <span class="main">(</span><span class="entity">rewr_obj_eq</span> <span class="entity">unitr_th</span><span class="main">)</span><span class="main">]</span> <span class="entity">ct</span>
          <span class="keyword2"><span class="keyword">else</span></span>
            Conv.all_conv <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">normalize</span> <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Rearrange subterms of ct according to the given term
   ordering. Returns theorem ct == ct'.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">normalize_comm_gen</span> <span class="main">(</span><span class="entity">ac_info</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">{</span><span class="entity">comm_th</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="entity">termless</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span><span class="entity">has_comm_th</span> <span class="entity">ac_info</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> Conv.all_conv <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
      <span class="comment1">(* If there are two terms a.b, swap if a &gt; b. If there are at
         least three terms, in the left associate case this is
         (a.b).c, swap b and c if b &gt; c. If there is a swap,
         recursively call swap_last until the original outside term is
         swapped into position.
       *)</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">swap_last</span> <span class="entity">ct</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">head_agrees</span> <span class="entity">ac_info</span> <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
            <span class="keyword2"><span class="keyword">let</span></span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">a1</span><span class="main">,</span> <span class="entity">a2</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Util.dest_binop_args</span> <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span>
            <span class="keyword2"><span class="keyword">in</span></span>
              <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">head_agrees</span> <span class="entity">ac_info</span> <span class="entity">a1</span> <span class="keyword2"><span class="keyword">then</span></span>
                <span class="comment1">(* Structure of t is a1 . a2 = (_ . b2) . a2. *)</span>
                <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">termless</span> <span class="main">(</span><span class="entity">a2</span><span class="main">,</span> <span class="entity">dest_arg</span> <span class="entity">a1</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
                  <span class="main">(</span><span class="main">(</span><span class="entity">swap_cv</span> <span class="entity">ac_info</span><span class="main">)</span> then_conv <span class="main">(</span>Conv.arg1_conv <span class="entity">swap_last</span><span class="main">)</span><span class="main">)</span> <span class="entity">ct</span>
                <span class="keyword2"><span class="keyword">else</span></span> Conv.all_conv <span class="entity">ct</span>
              <span class="keyword2"><span class="keyword">else</span></span>
                <span class="comment1">(* Structure of t is a1 . a2. *)</span>
                <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">termless</span> <span class="main">(</span><span class="entity">a2</span><span class="main">,</span> <span class="entity">a1</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">rewr_obj_eq</span> <span class="entity">comm_th</span> <span class="entity">ct</span>
                <span class="keyword2"><span class="keyword">else</span></span> Conv.all_conv <span class="entity">ct</span>
            <span class="keyword2"><span class="keyword">end</span></span>
          <span class="keyword2"><span class="keyword">else</span></span>
            Conv.all_conv <span class="entity">ct</span>

      <span class="comment1">(* Full ordering. Recursively perform full ordering on all but
         the outermost, then swap outermost into position.
       *)</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">normalize</span> <span class="entity">ct</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">head_agrees</span> <span class="entity">ac_info</span> <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
            <span class="main">(</span><span class="main">(</span>Conv.arg1_conv <span class="entity">normalize</span><span class="main">)</span> then_conv <span class="entity">swap_last</span><span class="main">)</span> <span class="entity">ct</span>
          <span class="keyword2"><span class="keyword">else</span></span>
            Conv.all_conv <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">normalize</span> <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">normalize_comm</span> <span class="entity">ac_info</span> <span class="main">=</span> <span class="entity">normalize_comm_gen</span> <span class="entity">ac_info</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">s</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span> <span class="main">=&gt;</span> Term_Ord.term_ord <span class="main">(</span><span class="entity">s</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span> <span class="main">=</span> LESS<span class="main">)</span>

<span class="comment1">(* Normalize all except comm. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">normalize_au</span> <span class="entity">ac_info</span> <span class="main">=</span>
    Conv.every_conv <span class="main">[</span><span class="entity">normalize_unit</span> <span class="entity">ac_info</span><span class="main">,</span> <span class="entity">normalize_assoc</span> <span class="entity">ac_info</span><span class="main">]</span>

<span class="comment1">(* Normalize everything. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">normalize_all_ac</span> <span class="entity">ac_info</span> <span class="main">=</span>
    Conv.every_conv <span class="main">[</span><span class="entity">normalize_au</span> <span class="entity">ac_info</span><span class="main">,</span> <span class="entity">normalize_comm</span> <span class="entity">ac_info</span><span class="main">]</span>

<span class="comment1">(* Rewrite the last term in ct using cv. Assume associative to left. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ac_last_conv</span> <span class="entity">ac_info</span> <span class="entity">cv</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">head_agrees</span> <span class="entity">ac_info</span> <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
      Conv.arg_conv <span class="entity">cv</span> <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">cv</span> <span class="entity">ct</span>

<span class="comment1">(* Given ct in the form x_1 * ... * x_n, where some sequence of x_i
   satisfies predicate pred. Combine these x_i into a single term
   using the binary combinator cv.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">norm_combine</span> <span class="entity">ac_info</span> <span class="entity">pred</span> <span class="entity">cv</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Thm.term_of <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">head_agrees</span> <span class="entity">ac_info</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="entity">b</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Util.dest_binop_args</span> <span class="entity">t</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">pred</span> <span class="entity">b</span> <span class="keyword2"><span class="keyword">then</span></span>
            <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">pred</span> <span class="entity">a</span> <span class="keyword2"><span class="keyword">then</span></span>
              <span class="entity">cv</span> <span class="entity">ct</span>
            <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">head_agrees</span> <span class="entity">ac_info</span> <span class="entity">a</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">pred</span> <span class="main">(</span><span class="entity">dest_arg</span> <span class="entity">a</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
              Conv.every_conv <span class="main">[</span><span class="entity">assoc_cv</span> <span class="entity">ac_info</span><span class="main">,</span>
                               Conv.arg_conv <span class="entity">cv</span><span class="main">,</span>
                               <span class="entity">norm_combine</span> <span class="entity">ac_info</span> <span class="entity">pred</span> <span class="entity">cv</span><span class="main">]</span> <span class="entity">ct</span>
            <span class="keyword2"><span class="keyword">else</span></span>
              Conv.all_conv <span class="entity">ct</span>
          <span class="keyword2"><span class="keyword">else</span></span>
            Conv.arg1_conv <span class="main">(</span><span class="entity">norm_combine</span> <span class="entity">ac_info</span> <span class="entity">pred</span> <span class="entity">cv</span><span class="main">)</span> <span class="entity">ct</span>
        <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword2"><span class="keyword">else</span></span>
        Conv.all_conv <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>  <span class="comment1">(* structure ACUtil. *)</span>
</pre>
</div><div id="files/ac_steps.ML">
<div class="head">
<h1>File ‹ac_steps.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*
  File: ac_steps.ML
  Author: Bohua Zhan

  Proof steps related to associative-commutative operations.
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">AC_PROOFSTEPS</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> max_ac<span class="main">:</span> int Config.T
  <span class="keyword1"><span class="keyword">val</span></span> simp_ac_expr<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">ac_info</span> <span class="main">-&gt;</span> <span class="entity">box_id</span> * cterm <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * thm<span class="main">)</span> list
  <span class="keyword1"><span class="keyword">val</span></span> get_ac_head_equiv<span class="main">:</span>
      <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">ac_info</span> <span class="main">-&gt;</span> <span class="entity">box_id</span> * cterm <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * thm<span class="main">)</span> list
  <span class="keyword1"><span class="keyword">val</span></span> ac_expand_once<span class="main">:</span>
      <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">ac_info</span> <span class="main">-&gt;</span> <span class="entity">box_id</span> * cterm <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * thm<span class="main">)</span> list
  <span class="keyword1"><span class="keyword">val</span></span> ac_expand<span class="main">:</span>
      <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">ac_info</span> <span class="main">-&gt;</span> <span class="entity">box_id</span> * cterm <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * thm<span class="main">)</span> list
  <span class="keyword1"><span class="keyword">val</span></span> ac_expand_equiv<span class="main">:</span> <span class="entity">proofstep</span>
  <span class="keyword1"><span class="keyword">val</span></span> ac_expand_unit<span class="main">:</span> <span class="entity">proofstep</span>

  <span class="keyword1"><span class="keyword">val</span></span> add_ac_proofsteps<span class="main">:</span> theory <span class="main">-&gt;</span> theory
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">AC_ProofSteps</span> <span class="main">:</span> <span class="entity">AC_PROOFSTEPS</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">max_ac</span> <span class="main">=</span> <span class="entity">Attrib.setup_config_int</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">binding</span> "max_ac"<span class="antiquote">}</span></span></span> <span class="main">(</span>K <span class="inner_numeral">20</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rewrite_on_eqs</span> <span class="entity">ac_info</span> <span class="entity">eqs</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Thm.term_of <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">ACUtil.head_agrees</span> <span class="entity">ac_info</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
        Conv.binop_conv <span class="main">(</span><span class="entity">rewrite_on_eqs</span> <span class="entity">ac_info</span> <span class="entity">eqs</span><span class="main">)</span> <span class="entity">ct</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="keyword2"><span class="keyword">case</span></span> find_first <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">eq</span> <span class="main">=&gt;</span> <span class="entity">t</span> aconv <span class="main">(</span><span class="entity">Util.lhs_of</span> <span class="entity">eq</span><span class="main">)</span><span class="main">)</span> <span class="entity">eqs</span> <span class="keyword2"><span class="keyword">of</span></span>
            NONE <span class="main">=&gt;</span> Conv.all_conv <span class="entity">ct</span>
          <span class="main">|</span> SOME <span class="entity">eq_th</span> <span class="main">=&gt;</span> <span class="entity">eq_th</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_ac_full</span> <span class="entity">ac_info</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">ACUtil.head_agrees</span> <span class="entity">ac_info</span> <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">a1</span><span class="main">,</span> <span class="entity">a2</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Util.dest_binop_cargs</span> <span class="entity">ct</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sort_opt</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">ACUtil.has_comm_th</span> <span class="entity">ac_info</span> <span class="keyword2"><span class="keyword">then</span></span>
                         sort <span class="main">(</span>Term_Ord.term_ord o apply2 Thm.term_of<span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> I
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="entity">sort_opt</span> <span class="main">(</span><span class="entity">dest_ac_full</span> <span class="entity">ac_info</span> <span class="entity">a1</span> @ <span class="entity">dest_ac_full</span> <span class="entity">ac_info</span> <span class="entity">a2</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">ACUtil.eq_unit</span> <span class="entity">ac_info</span> <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="entity">ct</span><span class="main">]</span>

<span class="comment1">(* Simplify each term of the AC expression. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">simp_ac_expr</span> <span class="entity">ctxt</span> <span class="entity">ac_info</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">cu</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cus</span> <span class="main">=</span> <span class="entity">dest_ac_full</span> <span class="entity">ac_info</span> <span class="entity">cu</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">cus</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">(</span><span class="entity">id</span><span class="main">,</span> Thm.reflexive <span class="entity">cu</span><span class="main">)</span><span class="main">]</span> <span class="keyword2"><span class="keyword">else</span></span>
      <span class="entity">cus</span> |&gt; map <span class="main">(</span><span class="entity">RewriteTable.simplify_info</span> <span class="entity">ctxt</span><span class="main">)</span>
          |&gt; <span class="entity">BoxID.get_all_merges_info</span> <span class="entity">ctxt</span>
          |&gt; <span class="entity">BoxID.merge_box_with_info</span> <span class="entity">ctxt</span> <span class="entity">id</span>
          |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">eqs</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">rewrite_on_eqs</span> <span class="entity">ac_info</span> <span class="entity">eqs</span> <span class="entity">cu</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Obtain head equivalences of cu, where each term is simplified. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_ac_head_equiv</span> <span class="entity">ctxt</span> <span class="entity">ac_info</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">cu</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_head_equiv</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">eq_th</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">infos</span> <span class="main">=</span> <span class="entity">simp_ac_expr</span> <span class="entity">ctxt</span> <span class="entity">ac_info</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> Thm.rhs_of <span class="entity">eq_th</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            map <span class="main">(</span><span class="entity">BoxID.merge_eq_infos</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">eq_th</span><span class="main">)</span><span class="main">)</span> <span class="entity">infos</span>
          <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">cu</span> |&gt; <span class="entity">RewriteTable.get_head_equiv</span> <span class="entity">ctxt</span>
         |&gt; <span class="entity">BoxID.merge_box_with_info</span> <span class="entity">ctxt</span> <span class="entity">id</span>
         |&gt; maps <span class="entity">process_head_equiv</span>
         |&gt; filter_out <span class="main">(</span>Thm.is_reflexive o snd<span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Find ways to modify ct once by rewriting one of the subterms. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ac_expand_once</span> <span class="entity">ctxt</span> <span class="entity">ac_info</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">ct</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cus</span> <span class="main">=</span> <span class="entity">dest_ac_full</span> <span class="entity">ac_info</span> <span class="entity">ct</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_equiv</span> <span class="entity">cu</span> <span class="main">=</span> <span class="entity">get_ac_head_equiv</span> <span class="entity">ctxt</span> <span class="entity">ac_info</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">cu</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_info</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">eq</span><span class="main">)</span> <span class="main">=</span>
          <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">rewrite_on_eqs</span> <span class="entity">ac_info</span> <span class="main">[</span><span class="entity">eq</span><span class="main">]</span> <span class="entity">ct</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      map <span class="entity">process_info</span> <span class="main">(</span>maps <span class="entity">get_equiv</span> <span class="entity">cus</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Find all ways to write ct, up to a certain limit. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ac_expand</span> <span class="entity">ctxt</span> <span class="entity">ac_info</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">ct</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">max_ac</span> <span class="main">=</span> Config.get <span class="entity">ctxt</span> <span class="entity">max_ac</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ac_equiv_eq_better</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">th'</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">seq1</span> <span class="main">=</span> <span class="entity">dest_ac_full</span> <span class="entity">ac_info</span> <span class="main">(</span>Thm.rhs_of <span class="entity">th</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">seq2</span> <span class="main">=</span> <span class="entity">dest_ac_full</span> <span class="entity">ac_info</span> <span class="main">(</span>Thm.rhs_of <span class="entity">th'</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="entity">Util.is_subseq</span> <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv o apply2 Thm.term_of<span class="main">)</span> <span class="main">(</span><span class="entity">seq1</span><span class="main">,</span> <span class="entity">seq2</span><span class="main">)</span> <span class="keyword1"><span class="keyword">andalso</span></span>
            <span class="entity">BoxID.is_eq_ancestor</span> <span class="entity">ctxt</span> <span class="entity">id</span> <span class="entity">id'</span>
          <span class="keyword2"><span class="keyword">end</span></span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">has_ac_equiv_eq_better</span> <span class="entity">infos</span> <span class="entity">info'</span> <span class="main">=</span>
          exists <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">info</span> <span class="main">=&gt;</span> <span class="entity">ac_equiv_eq_better</span> <span class="entity">info</span> <span class="entity">info'</span><span class="main">)</span> <span class="entity">infos</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">helper</span> <span class="main">(</span><span class="entity">old</span><span class="main">,</span> <span class="entity">new</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">new</span> <span class="keyword2"><span class="keyword">of</span></span>
              <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="entity">old</span>
            <span class="main">|</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">eq_th</span><span class="main">)</span> :: <span class="entity">rest</span> <span class="main">=&gt;</span>
              <span class="keyword2"><span class="keyword">if</span></span> length <span class="entity">old</span> + length <span class="entity">new</span> &gt; <span class="entity">max_ac</span> <span class="keyword2"><span class="keyword">then</span></span>
                <span class="entity">old</span> @ take <span class="main">(</span><span class="entity">max_ac</span> - length <span class="entity">old</span><span class="main">)</span> <span class="entity">new</span>
              <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">old'</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">eq_th</span><span class="main">)</span> :: <span class="entity">old</span><span class="main">)</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs_expand</span> <span class="main">=</span>
                    <span class="main">(</span><span class="entity">ac_expand_once</span> <span class="entity">ctxt</span> <span class="entity">ac_info</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> Thm.rhs_of <span class="entity">eq_th</span><span class="main">)</span><span class="main">)</span>
                        |&gt; <span class="entity">Util.max_partial</span> <span class="entity">ac_equiv_eq_better</span>
                        |&gt; map <span class="main">(</span><span class="entity">BoxID.merge_eq_infos</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">eq_th</span><span class="main">)</span><span class="main">)</span>
                        |&gt; filter_out <span class="main">(</span><span class="entity">has_ac_equiv_eq_better</span> <span class="main">(</span><span class="entity">old'</span> @ <span class="entity">rest</span><span class="main">)</span><span class="main">)</span>
              <span class="keyword2"><span class="keyword">in</span></span>
                <span class="entity">helper</span> <span class="main">(</span><span class="entity">old'</span><span class="main">,</span> <span class="entity">rest</span> @ <span class="entity">rhs_expand</span><span class="main">)</span>
              <span class="keyword2"><span class="keyword">end</span></span>

      <span class="comment1">(* Start term *)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">start</span> <span class="main">=</span> <span class="entity">simp_ac_expr</span> <span class="entity">ctxt</span> <span class="entity">ac_info</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">ct</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">helper</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">start</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ac_expand_equiv_fn</span> <span class="entity">ctxt</span> <span class="entity">item1</span> <span class="entity">item2</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span>id <span class="main">=</span> <span class="entity">id1</span><span class="main">,</span> tname <span class="main">=</span> <span class="entity">tname1</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">item1</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span>id <span class="main">=</span> <span class="entity">id2</span><span class="main">,</span> tname <span class="main">=</span> <span class="entity">tname2</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">item2</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">ct1</span><span class="main">,</span> <span class="entity">ct2</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>the_single <span class="entity">tname1</span><span class="main">,</span> the_single <span class="entity">tname2</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Thm.term_of <span class="entity">ct1</span><span class="main">,</span> Thm.term_of <span class="entity">ct2</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">id</span> <span class="main">=</span> <span class="entity">BoxID.merge_boxes</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id1</span><span class="main">,</span> <span class="entity">id2</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">ACUtil.get_head_ac_info</span> <span class="entity">thy</span> <span class="entity">t1</span> <span class="keyword2"><span class="keyword">of</span></span>
          NONE <span class="main">=&gt;</span> <span class="main">[</span><span class="main">]</span>
        <span class="main">|</span> SOME <span class="entity">ac_info</span> <span class="main">=&gt;</span>
          <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span><span class="entity">ACUtil.head_agrees</span> <span class="entity">ac_info</span> <span class="entity">t2</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span>
          <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> Term_Ord.term_ord <span class="main">(</span><span class="entity">t2</span><span class="main">,</span> <span class="entity">t1</span><span class="main">)</span> <span class="main">=</span> LESS <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span>
          <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">RewriteTable.is_equiv</span> <span class="entity">id</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">ct1</span><span class="main">,</span> <span class="entity">ct2</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span>
          <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">expand1</span> <span class="main">=</span> <span class="entity">ac_expand</span> <span class="entity">ctxt</span> <span class="entity">ac_info</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">ct1</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">expand2</span> <span class="main">=</span> <span class="entity">ac_expand</span> <span class="entity">ctxt</span> <span class="entity">ac_info</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">ct2</span><span class="main">)</span>

            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_equiv</span> <span class="main">(</span><span class="main">(</span><span class="entity">id1</span><span class="main">,</span> <span class="entity">eq_th1</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">id2</span><span class="main">,</span> <span class="entity">eq_th2</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
                <span class="keyword2"><span class="keyword">let</span></span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ct1</span> <span class="main">=</span> Thm.rhs_of <span class="entity">eq_th1</span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ct2</span> <span class="main">=</span> Thm.rhs_of <span class="entity">eq_th2</span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ts1</span> <span class="main">=</span> <span class="entity">dest_ac_full</span> <span class="entity">ac_info</span> <span class="entity">ct1</span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ts2</span> <span class="main">=</span> <span class="entity">dest_ac_full</span> <span class="entity">ac_info</span> <span class="entity">ct2</span>
                <span class="keyword2"><span class="keyword">in</span></span>
                  <span class="keyword2"><span class="keyword">if</span></span> eq_list <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv o apply2 Thm.term_of<span class="main">)</span> <span class="main">(</span><span class="entity">ts1</span><span class="main">,</span> <span class="entity">ts2</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
                    <span class="keyword2"><span class="keyword">let</span></span>
                      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq_th1'</span> <span class="main">=</span> <span class="entity">ACUtil.normalize_all_ac</span> <span class="entity">ac_info</span> <span class="entity">ct1</span>
                      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq_th2'</span> <span class="main">=</span> <span class="entity">ACUtil.normalize_all_ac</span> <span class="entity">ac_info</span> <span class="entity">ct2</span>
                      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">id'</span> <span class="main">=</span> <span class="entity">BoxID.merge_boxes</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id1</span><span class="main">,</span> <span class="entity">id2</span><span class="main">)</span>
                      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq</span> <span class="main">=</span> <span class="entity">Util.transitive_list</span> <span class="main">[</span>
                            <span class="entity">eq_th1</span><span class="main">,</span> <span class="entity">eq_th1'</span><span class="main">,</span> <span class="entity">meta_sym</span> <span class="entity">eq_th2'</span><span class="main">,</span> <span class="entity">meta_sym</span> <span class="entity">eq_th2</span><span class="main">]</span>
                    <span class="keyword2"><span class="keyword">in</span></span>
                      <span class="main">[</span><span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">to_obj_eq</span> <span class="entity">eq</span><span class="main">)</span><span class="main">]</span>
                    <span class="keyword2"><span class="keyword">end</span></span>
                  <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="main">]</span>
                <span class="keyword2"><span class="keyword">end</span></span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="main">(</span>maps <span class="entity">get_equiv</span> <span class="main">(</span><span class="entity">Util.all_pairs</span> <span class="main">(</span><span class="entity">expand1</span><span class="main">,</span> <span class="entity">expand2</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
                |&gt; filter <span class="main">(</span><span class="entity">BoxID.has_incr_id</span> o fst<span class="main">)</span>
                |&gt; <span class="entity">Util.max_partial</span> <span class="main">(</span><span class="entity">BoxID.id_is_eq_ancestor</span> <span class="entity">ctxt</span><span class="main">)</span>
                |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">Update.thm_update_sc</span> <span class="inner_numeral">1</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ac_expand_equiv</span> <span class="main">=</span>
    <span class="main">{</span>name <span class="main">=</span> <span class="inner_quoted">"ac_expand_equiv"</span><span class="main">,</span>
     args <span class="main">=</span> <span class="main">[</span><span class="entity">TypedUniv</span> <span class="entity">TY_TERM</span><span class="main">,</span> <span class="entity">TypedUniv</span> <span class="entity">TY_TERM</span><span class="main">]</span><span class="main">,</span>
     func <span class="main">=</span> <span class="entity">TwoStep</span> <span class="entity">ac_expand_equiv_fn</span><span class="main">}</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ac_expand_unit_fn</span> <span class="entity">ctxt</span> <span class="entity">item</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">id</span><span class="main">,</span> <span class="entity">tname</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">item</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ct</span> <span class="main">=</span> the_single <span class="entity">tname</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Thm.term_of <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">ACUtil.get_head_ac_info</span> <span class="entity">thy</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
          NONE <span class="main">=&gt;</span> <span class="main">[</span><span class="main">]</span>
        <span class="main">|</span> SOME <span class="entity">ac_info</span> <span class="main">=&gt;</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">expand</span> <span class="main">=</span> <span class="entity">ac_expand</span> <span class="entity">ctxt</span> <span class="entity">ac_info</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">ct</span><span class="main">)</span>

            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_expand</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">eq_th</span><span class="main">)</span> <span class="main">=</span>
                <span class="keyword2"><span class="keyword">let</span></span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ct</span> <span class="main">=</span> Thm.rhs_of <span class="entity">eq_th</span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ts</span> <span class="main">=</span> <span class="entity">dest_ac_full</span> <span class="entity">ac_info</span> <span class="entity">ct</span>
                <span class="keyword2"><span class="keyword">in</span></span>
                  <span class="keyword2"><span class="keyword">if</span></span> length <span class="entity">ts</span> &lt;= <span class="inner_numeral">1</span> <span class="keyword2"><span class="keyword">then</span></span>
                    <span class="keyword2"><span class="keyword">let</span></span>
                      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq'</span> <span class="main">=</span> <span class="entity">ACUtil.normalize_all_ac</span> <span class="entity">ac_info</span> <span class="entity">ct</span>
                      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq</span> <span class="main">=</span> <span class="entity">Util.transitive_list</span> <span class="main">[</span><span class="entity">eq_th</span><span class="main">,</span> <span class="entity">eq'</span><span class="main">]</span>
                    <span class="keyword2"><span class="keyword">in</span></span>
                      <span class="main">[</span><span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">to_obj_eq</span> <span class="entity">eq</span><span class="main">)</span><span class="main">]</span>
                    <span class="keyword2"><span class="keyword">end</span></span>
                  <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="main">]</span>
                <span class="keyword2"><span class="keyword">end</span></span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="main">(</span>maps <span class="entity">process_expand</span> <span class="entity">expand</span><span class="main">)</span>
                |&gt; filter <span class="main">(</span><span class="entity">BoxID.has_incr_id</span> o fst<span class="main">)</span>
                |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">Update.thm_update_sc</span> <span class="inner_numeral">1</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ac_expand_unit</span> <span class="main">=</span>
    <span class="main">{</span>name <span class="main">=</span> <span class="inner_quoted">"ac_expand_unit"</span><span class="main">,</span>
     args <span class="main">=</span> <span class="main">[</span><span class="entity">TypedUniv</span> <span class="entity">TY_TERM</span><span class="main">]</span><span class="main">,</span>
     func <span class="main">=</span> <span class="entity">OneStep</span> <span class="entity">ac_expand_unit_fn</span><span class="main">}</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">add_ac_proofsteps</span> <span class="main">=</span>
    fold <span class="entity">add_prfstep</span> <span class="main">[</span>
      <span class="entity">ac_expand_equiv</span><span class="main">,</span> <span class="entity">ac_expand_unit</span>
   <span class="main">]</span>

<span class="keyword2"><span class="keyword">end</span></span>  <span class="comment1">(* structure AC_ProofSteps. *)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> Theory.setup <span class="entity">AC_ProofSteps.add_ac_proofsteps</span>
</pre>
</div><div id="files/unfolding.ML">
<div class="head">
<h1>File ‹unfolding.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*
  File: unfolding.ML
  Author: Bohua Zhan

  Unfolding of functional definitions.
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">UNFOLDING</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> get_unfold_thms_by_name<span class="main">:</span> theory <span class="main">-&gt;</span> string <span class="main">-&gt;</span> thm list
  <span class="keyword1"><span class="keyword">val</span></span> get_unfold_thms<span class="main">:</span> theory <span class="main">-&gt;</span> term <span class="main">-&gt;</span> thm list
  <span class="keyword1"><span class="keyword">val</span></span> unfold<span class="main">:</span> theory <span class="main">-&gt;</span> conv
  <span class="keyword1"><span class="keyword">val</span></span> unfold_cmd<span class="main">:</span> string <span class="main">-&gt;</span> <span class="entity">Proof.state</span> <span class="main">-&gt;</span> <span class="entity">Proof.state</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Unfolding</span> <span class="main">:</span> <span class="entity">UNFOLDING</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_unfold_thms_by_name</span> <span class="entity">thy</span> <span class="entity">nm</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simp_nm</span> <span class="main">=</span> <span class="entity">nm</span> ^ <span class="inner_quoted">".simps"</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">def_nm</span> <span class="main">=</span> <span class="entity">nm</span> ^ <span class="inner_quoted">"_def"</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      Global_Theory.get_thms <span class="entity">thy</span> <span class="entity">simp_nm</span>
      <span class="keyword3"><span class="keyword">handle</span></span> ERROR <span class="main">_</span> <span class="main">=&gt;</span> Global_Theory.get_thms <span class="entity">thy</span> <span class="entity">def_nm</span>
                        <span class="keyword3"><span class="keyword">handle</span></span> ERROR <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"get_unfold_thms"</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_unfold_thms</span> <span class="entity">thy</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="entity">get_unfold_thms_by_name</span> <span class="entity">thy</span> <span class="main">(</span><span class="entity">Util.get_head_name</span> <span class="entity">t</span><span class="main">)</span>

<span class="comment1">(* Unfold the given term. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">unfold</span> <span class="entity">thy</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ths</span> <span class="main">=</span> <span class="entity">get_unfold_thms</span> <span class="entity">thy</span> <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      Conv.first_conv <span class="main">(</span>map <span class="entity">rewr_obj_eq</span> <span class="entity">ths</span><span class="main">)</span> <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">unfold_cmd</span> <span class="entity">s</span> <span class="entity">state</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">Proof.goal</span> <span class="entity">state</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">(</span><span class="entity">As</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">ctxt</span> |&gt; <span class="entity">Auto2_State.get_subgoal</span>
                              |&gt; <span class="entity">Util.strip_meta_horn</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cAs</span> <span class="main">=</span> map <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">As</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Syntax.read_term <span class="entity">ctxt</span> <span class="entity">s</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq_th</span> <span class="main">=</span> <span class="entity">t</span> |&gt; Thm.cterm_of <span class="entity">ctxt</span> |&gt; <span class="entity">unfold</span> <span class="entity">thy</span>
                    |&gt; <span class="entity">to_obj_eq</span>
                    |&gt; fold Thm.implies_intr <span class="main">(</span>rev <span class="entity">cAs</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> writeln <span class="main">(</span><span class="inner_quoted">"Obtained "</span> ^ <span class="main">(</span><span class="entity">eq_th</span> |&gt; Thm.concl_of
                                            |&gt; Syntax.string_of_term <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">after_qed</span> <span class="main">=</span> <span class="entity">Auto2_Outer.have_after_qed</span> <span class="entity">ctxt</span> <span class="entity">eq_th</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">state</span> |&gt; <span class="entity">Proof.map_contexts</span> <span class="main">(</span><span class="entity">Auto2_State.map_head_th</span> <span class="entity">after_qed</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  <span class="entity">Outer_Syntax.command</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">command_keyword</span> "<span class="keyword1">@unfold</span>"<span class="antiquote">}</span></span></span> <span class="inner_quoted">"unfold a term"</span>
    <span class="main">(</span>Parse.term &gt;&gt;
        <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">s</span> <span class="main">=&gt;</span>
            <span class="entity">Toplevel.proof</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">state</span> <span class="main">=&gt;</span> <span class="entity">unfold_cmd</span> <span class="entity">s</span> <span class="entity">state</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>  <span class="comment1">(* structure Unfolding *)</span>
</pre>
</div><div id="files/induct_outer.ML">
<div class="head">
<h1>File ‹induct_outer.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*
  File: induct_outer.ML
  Author: Bohua Zhan

  Proof language for induction.
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">INDUCT_PROOFSTEPS</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> add_induct_data<span class="main">:</span> string <span class="main">-&gt;</span> term * thm <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> add_typed_induct_data<span class="main">:</span> string <span class="main">-&gt;</span> typ * thm <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> get_typed_ind_th<span class="main">:</span> theory <span class="main">-&gt;</span> string <span class="main">-&gt;</span> typ <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> get_term_ind_th<span class="main">:</span> theory <span class="main">-&gt;</span> string <span class="main">-&gt;</span> term <span class="main">-&gt;</span> thm

  <span class="keyword1"><span class="keyword">val</span></span> check_strong_ind_prop<span class="main">:</span> term <span class="main">-&gt;</span> term list * term
  <span class="keyword1"><span class="keyword">val</span></span> add_strong_induct_rule<span class="main">:</span> thm <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> add_case_induct_rule<span class="main">:</span> thm <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> add_prop_induct_rule<span class="main">:</span> thm <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> add_var_induct_rule<span class="main">:</span> thm <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> add_cases_rule<span class="main">:</span> thm <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> add_fun_induct_rule<span class="main">:</span> term * thm <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory

  <span class="keyword1"><span class="keyword">val</span></span> strong_induct_cmd<span class="main">:</span> string * string list <span class="main">-&gt;</span> <span class="entity">Proof.state</span> <span class="main">-&gt;</span> <span class="entity">Proof.state</span>
  <span class="keyword1"><span class="keyword">val</span></span> apply_induct_hyp_cmd<span class="main">:</span> string list <span class="main">-&gt;</span> <span class="entity">Proof.state</span> <span class="main">-&gt;</span> <span class="entity">Proof.state</span>
  <span class="keyword1"><span class="keyword">val</span></span> case_induct_cmd<span class="main">:</span> string <span class="main">-&gt;</span> <span class="entity">Proof.state</span> <span class="main">-&gt;</span> <span class="entity">Proof.state</span>
  <span class="keyword1"><span class="keyword">val</span></span> prop_induct_cmd<span class="main">:</span> string * string option <span class="main">-&gt;</span> <span class="entity">Proof.state</span> <span class="main">-&gt;</span> <span class="entity">Proof.state</span>
  <span class="keyword1"><span class="keyword">val</span></span> induct_cmd<span class="main">:</span>
      string <span class="main">-&gt;</span> string * string option * string list * string option <span class="main">-&gt;</span>
      <span class="entity">Proof.state</span> <span class="main">-&gt;</span> <span class="entity">Proof.state</span>
  <span class="keyword1"><span class="keyword">val</span></span> is_simple_fun_induct<span class="main">:</span> thm <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> fun_induct_cmd<span class="main">:</span>
      string * string list * string option <span class="main">-&gt;</span> <span class="entity">Proof.state</span> <span class="main">-&gt;</span> <span class="entity">Proof.state</span>
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Induct_ProofSteps</span> <span class="main">:</span> <span class="entity">INDUCT_PROOFSTEPS</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Data</span> <span class="main">=</span> Theory_Data <span class="main">(</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">T</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span>term * thm<span class="main">)</span> list<span class="main">)</span> Symtab.table<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">empty</span> <span class="main">=</span> Symtab.empty<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">extend</span> <span class="main">=</span> I<span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">merge</span> <span class="main">=</span> Symtab.merge_list <span class="main">(</span>eq_fst <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span><span class="main">)</span>
<span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_induct_data</span> <span class="entity">str</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">ind_th</span><span class="main">)</span> <span class="main">=</span>
    Data.map <span class="main">(</span>Symtab.map_default <span class="main">(</span><span class="entity">str</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="main">(</span>cons <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">ind_th</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_typed_induct_data</span> <span class="entity">str</span> <span class="main">(</span><span class="entity">ty</span><span class="main">,</span> <span class="entity">ind_th</span><span class="main">)</span> <span class="main">=</span>
    <span class="entity">add_induct_data</span> <span class="entity">str</span> <span class="main">(</span>Term.dummy_pattern <span class="entity">ty</span><span class="main">,</span> <span class="entity">ind_th</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_typed_ind_th</span> <span class="entity">thy</span> <span class="entity">ind_type</span> <span class="entity">ty</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">typ_can_match</span> <span class="main">=</span>
          can <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t'</span> <span class="main">=&gt;</span> Sign.typ_match <span class="entity">thy</span> <span class="main">(</span>type_of <span class="entity">t'</span><span class="main">,</span> <span class="entity">ty</span><span class="main">)</span> Vartab.empty<span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> Symtab.lookup <span class="main">(</span>Data.get <span class="entity">thy</span><span class="main">)</span> <span class="entity">ind_type</span> <span class="keyword2"><span class="keyword">of</span></span>
          NONE <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="main">(</span><span class="entity">ind_type</span> ^ <span class="inner_quoted">": cannot find theorem."</span><span class="main">)</span>
        <span class="main">|</span> SOME <span class="entity">lst</span> <span class="main">=&gt;</span>
          <span class="keyword2"><span class="keyword">case</span></span> find_first <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">t'</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">typ_can_match</span> <span class="entity">t'</span><span class="main">)</span> <span class="entity">lst</span> <span class="keyword2"><span class="keyword">of</span></span>
              NONE <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="main">(</span><span class="entity">ind_type</span> ^ <span class="inner_quoted">": cannot find theorem."</span><span class="main">)</span>
            <span class="main">|</span> SOME <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">ind_th</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">ind_th</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_term_ind_th</span> <span class="entity">thy</span> <span class="entity">ind_type</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">data</span> <span class="main">=</span> Symtab.lookup_list <span class="main">(</span>Data.get <span class="entity">thy</span><span class="main">)</span> <span class="entity">ind_type</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">match_data</span> <span class="main">(</span><span class="entity">pat</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inst</span> <span class="main">=</span> Pattern.first_order_match <span class="entity">thy</span> <span class="main">(</span><span class="entity">pat</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span> <span class="entity">fo_init</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            SOME <span class="main">(</span><span class="entity">Util.subst_thm_thy</span> <span class="entity">thy</span> <span class="entity">inst</span> <span class="entity">th</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>
          <span class="keyword3"><span class="keyword">handle</span></span> Pattern.MATCH <span class="main">=&gt;</span> NONE
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> get_first <span class="entity">match_data</span> <span class="entity">data</span> <span class="keyword2"><span class="keyword">of</span></span>
          NONE <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="main">(</span><span class="entity">ind_type</span> ^ <span class="inner_quoted">": cannot find theorem."</span><span class="main">)</span>
        <span class="main">|</span> SOME <span class="entity">ind_th</span> <span class="main">=&gt;</span> <span class="entity">ind_th</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Check a strong induction theorem ind_th is of the right form, and
   extract the induction variables and substitution.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">check_strong_ind_prop</span> <span class="entity">ind_prop</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">err</span> <span class="entity">str</span> <span class="main">=</span> <span class="inner_quoted">"Strong induction: "</span> ^ <span class="entity">str</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">cond_ind</span><span class="main">,</span> <span class="entity">concl</span><span class="main">)</span> <span class="main">=</span>
          <span class="entity">ind_prop</span> |&gt; Logic.dest_implies |&gt; apply2 <span class="entity">dest_Trueprop</span>

      <span class="comment1">(* concl must be of form ?P [?vars]. *)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">err_concl</span> <span class="main">=</span> <span class="entity">err</span> <span class="inner_quoted">"concl of ind_th must be ?P [?vars]."</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">P</span><span class="main">,</span> <span class="entity">pat_vars</span><span class="main">)</span> <span class="main">=</span> Term.strip_comb <span class="entity">concl</span>
                          <span class="keyword3"><span class="keyword">handle</span></span> TERM <span class="main">_</span> <span class="main">=&gt;</span> error <span class="entity">err_concl</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span>is_Var <span class="entity">P</span> <span class="keyword1"><span class="keyword">andalso</span></span> forall is_Var <span class="entity">pat_vars</span> <span class="keyword1"><span class="keyword">andalso</span></span>
                      <span class="main">(</span>dest_Var <span class="entity">P</span> |&gt; fst |&gt; fst<span class="main">)</span> <span class="main">=</span> <span class="inner_quoted">"P"</span><span class="main">)</span> <span class="entity">err_concl</span>

      <span class="comment1">(* cond_ind must be of form !n. P' n --&gt; ?P n. Return the
         substitution pattern P'.
       *)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">err_ind_hyp</span> <span class="main">=</span> <span class="entity">err</span> <span class="inner_quoted">"cond_ind of ind_th must be !n. P' --&gt; ?P vars."</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_one_all</span> <span class="entity">var</span> <span class="entity">body</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">body</span> <span class="keyword2"><span class="keyword">of</span></span>
              Const <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ Abs <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span> <span class="main">=&gt;</span>
              <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">c</span> <span class="main">=</span> <span class="entity">UtilBase.All_name</span> <span class="keyword2"><span class="keyword">then</span></span> subst_bound <span class="main">(</span><span class="entity">var</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span>
              <span class="keyword2"><span class="keyword">else</span></span> error <span class="entity">err_ind_hyp</span>
            <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> error <span class="entity">err_ind_hyp</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">pat_subst</span><span class="main">,</span> <span class="entity">P_vars</span><span class="main">)</span> <span class="main">=</span>
          <span class="entity">cond_ind</span> |&gt; fold <span class="entity">dest_one_all</span> <span class="entity">pat_vars</span> |&gt; <span class="entity">dest_imp</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span><span class="entity">P_vars</span> aconv <span class="entity">concl</span><span class="main">)</span> <span class="entity">err_ind_hyp</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">(</span><span class="entity">pat_vars</span><span class="main">,</span> <span class="entity">pat_subst</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_strong_induct_rule</span> <span class="entity">ind_th</span> <span class="entity">thy</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">name</span> <span class="main">=</span> <span class="entity">Util.name_of_thm</span> <span class="entity">ind_th</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt</span> <span class="main">=</span> Proof_Context.init_global <span class="entity">thy</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ind_th'</span> <span class="main">=</span> <span class="entity">apply_to_thm</span> <span class="main">(</span><span class="entity">UtilLogic.to_obj_conv_on_horn</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">ind_th</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">pat_var</span><span class="main">,</span> <span class="entity">pat_subst</span><span class="main">)</span> <span class="main">=</span>
          <span class="entity">check_strong_ind_prop</span> <span class="main">(</span>Thm.prop_of <span class="entity">ind_th'</span><span class="main">)</span> |&gt; apfst the_single
          <span class="keyword3"><span class="keyword">handle</span></span> List.Empty <span class="main">=&gt;</span> error <span class="inner_quoted">"Strong induction: more than one var."</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ty_var</span> <span class="main">=</span> type_of <span class="entity">pat_var</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> writeln <span class="main">(</span><span class="entity">name</span> ^ <span class="inner_quoted">"\nSubstitution: "</span> ^
                       <span class="main">(</span><span class="entity">Util.string_of_terms_global</span> <span class="entity">thy</span> <span class="main">[</span><span class="entity">pat_var</span><span class="main">,</span> <span class="entity">pat_subst</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">thy</span> |&gt; <span class="entity">add_typed_induct_data</span> <span class="inner_quoted">"strong_induct"</span> <span class="main">(</span><span class="entity">ty_var</span><span class="main">,</span> <span class="entity">ind_th'</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_case_induct_rule</span> <span class="entity">ind_th</span> <span class="entity">thy</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">init_assum</span> <span class="main">=</span> <span class="entity">ind_th</span> |&gt; Thm.prems_of |&gt; hd |&gt; <span class="entity">dest_Trueprop</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">thy</span> |&gt; <span class="entity">add_induct_data</span> <span class="inner_quoted">"case_induct"</span> <span class="main">(</span><span class="entity">init_assum</span><span class="main">,</span> <span class="entity">ind_th</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_prop_induct_rule</span> <span class="entity">ind_th</span> <span class="entity">thy</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">init_assum</span> <span class="main">=</span> <span class="entity">ind_th</span> |&gt; Thm.prems_of |&gt; hd |&gt; <span class="entity">dest_Trueprop</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">thy</span> |&gt; <span class="entity">add_induct_data</span> <span class="inner_quoted">"prop_induct"</span> <span class="main">(</span><span class="entity">init_assum</span><span class="main">,</span> <span class="entity">ind_th</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_var_induct_rule</span> <span class="entity">ind_th</span> <span class="entity">thy</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">P</span><span class="main">,</span> <span class="entity">n</span><span class="main">)</span> <span class="main">=</span> <span class="entity">ind_th</span> |&gt; <span class="entity">concl_of'</span> |&gt; Term.dest_comb
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span>Term.is_Var <span class="entity">P</span> <span class="keyword1"><span class="keyword">andalso</span></span> Term.is_Var <span class="entity">n</span><span class="main">)</span>
                     <span class="inner_quoted">"add_var_induct_rule: concl of ind_th must be ?P ?var"</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">thy</span> |&gt; <span class="entity">add_typed_induct_data</span> <span class="inner_quoted">"var_induct"</span> <span class="main">(</span>type_of <span class="entity">n</span><span class="main">,</span> <span class="entity">ind_th</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_cases_rule</span> <span class="entity">ind_th</span> <span class="entity">thy</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">P</span><span class="main">,</span> <span class="entity">n</span><span class="main">)</span> <span class="main">=</span> <span class="entity">ind_th</span> |&gt; <span class="entity">concl_of'</span> |&gt; Term.dest_comb
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span>Term.is_Var <span class="entity">P</span> <span class="keyword1"><span class="keyword">andalso</span></span> Term.is_Var <span class="entity">n</span><span class="main">)</span>
                     <span class="inner_quoted">"add_cases_rule: concl of ind_th must be ?P ?var"</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">thy</span> |&gt; <span class="entity">add_typed_induct_data</span> <span class="inner_quoted">"cases"</span> <span class="main">(</span>type_of <span class="entity">n</span><span class="main">,</span> <span class="entity">ind_th</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_fun_induct_rule</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">ind_th</span><span class="main">)</span> <span class="entity">thy</span> <span class="main">=</span>
    <span class="entity">thy</span> |&gt; <span class="entity">add_induct_data</span> <span class="inner_quoted">"fun_induct"</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">ind_th</span><span class="main">)</span>

<span class="comment1">(* Obtain the induction statement. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_induct_stmt</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">filt_A</span><span class="main">,</span> <span class="entity">ind_vars</span><span class="main">,</span> <span class="entity">stmt</span><span class="main">,</span> <span class="entity">arbitrary</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">stmt</span> <span class="keyword2"><span class="keyword">of</span></span>
        NONE <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">(</span><span class="entity">As</span><span class="main">,</span> <span class="entity">C</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">ctxt</span> |&gt; <span class="entity">Auto2_State.get_subgoal</span>
                                  |&gt; <span class="entity">Util.strip_meta_horn</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">obj_As</span> <span class="main">=</span> <span class="entity">As</span> |&gt; map <span class="entity">dest_Trueprop</span> |&gt; filter <span class="entity">filt_A</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">obj_C</span> <span class="main">=</span> <span class="entity">dest_Trueprop</span> <span class="entity">C</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="main">(</span><span class="entity">UtilLogic.list_obj_horn</span> <span class="main">(</span><span class="entity">arbitrary</span><span class="main">,</span> <span class="main">(</span><span class="entity">obj_As</span><span class="main">,</span> <span class="entity">obj_C</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
              |&gt; fold <span class="entity">Util.lambda_abstract</span> <span class="main">(</span>rev <span class="entity">ind_vars</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">end</span></span>
      <span class="main">|</span> SOME <span class="entity">s</span> <span class="main">=&gt;</span>
        <span class="main">(</span><span class="entity">UtilLogic.list_obj_horn</span> <span class="main">(</span><span class="entity">arbitrary</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> Syntax.read_term <span class="entity">ctxt</span> <span class="entity">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
            |&gt; fold <span class="entity">Util.lambda_abstract</span> <span class="main">(</span>rev <span class="entity">ind_vars</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">apply_simple_induct_th</span> <span class="entity">ind_th</span> <span class="entity">vars</span> <span class="entity">arbitraries</span> <span class="entity">prem_only</span> <span class="entity">state</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">Proof.goal</span> <span class="entity">state</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prop</span> <span class="main">=</span> <span class="entity">Auto2_State.get_selected</span> <span class="entity">ctxt</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">vars'</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">prop</span> |&gt; Thm.prems_of |&gt; the_single
                            |&gt; <span class="entity">Util.strip_meta_horn</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ind_th</span> <span class="main">=</span>
          <span class="entity">ind_th</span> |&gt; <span class="entity">apply_to_thm</span> <span class="main">(</span>Conv.binop_conv <span class="main">(</span><span class="entity">UtilLogic.to_meta_conv</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">assum</span> <span class="main">=</span> hd <span class="main">(</span>Drule.cprems_of <span class="entity">ind_th</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ind_th</span> <span class="main">=</span>
          <span class="entity">ind_th</span> |&gt; <span class="entity">Util.send_first_to_hyps</span>
                 |&gt; fold Thm.forall_elim <span class="main">(</span>map <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">arbitraries</span><span class="main">)</span>
                 |&gt; fold Thm.forall_intr <span class="main">(</span>map <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">vars'</span><span class="main">)</span>
                 |&gt; Thm.implies_intr <span class="entity">assum</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t'</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> Thm.prop_of <span class="entity">ind_th</span> <span class="keyword2"><span class="keyword">of</span></span>
                   <span class="entity">imp</span> $ <span class="entity">A</span> $ <span class="entity">B</span> <span class="main">=&gt;</span> <span class="entity">imp</span> $ <span class="entity">Util.rename_abs_term</span> <span class="entity">vars</span> <span class="entity">A</span> $ <span class="entity">B</span>
                 <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"strong_induct_cmd"</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ind_th</span> <span class="main">=</span> <span class="entity">ind_th</span> |&gt; Thm.renamed_prop <span class="entity">t'</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prop</span> <span class="main">=</span> <span class="entity">prop</span> |&gt; <span class="entity">Auto2_Outer.refine_subgoal_th</span> <span class="entity">ind_th</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">prem_only</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">(</span><span class="entity">As</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">prop</span> |&gt; Thm.prems_of |&gt; the_single
                                  |&gt; <span class="entity">Util.strip_meta_horn</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">stmt</span> <span class="main">=</span> <span class="entity">dest_Trueprop</span> <span class="main">(</span>hd <span class="entity">As</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="entity">state</span> |&gt; <span class="entity">Proof.map_contexts</span> <span class="main">(</span><span class="entity">Auto2_State.map_head_th</span> <span class="main">(</span>K <span class="entity">prop</span><span class="main">)</span><span class="main">)</span>
                |&gt; <span class="entity">Proof.map_contexts</span> <span class="main">(</span><span class="entity">Auto2_State.set_induct_stmt</span> <span class="entity">stmt</span><span class="main">)</span>
                |&gt; <span class="entity">Proof.map_contexts</span> <span class="main">(</span><span class="entity">Auto2_State.add_prem_only</span> <span class="entity">stmt</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="entity">state</span> |&gt; <span class="entity">Proof.map_contexts</span> <span class="main">(</span><span class="entity">Auto2_State.map_head_th</span> <span class="main">(</span>K <span class="entity">prop</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">strong_induct_cmd</span> <span class="main">(</span><span class="entity">s</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span> <span class="entity">state</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">Proof.goal</span> <span class="entity">state</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">var</span> <span class="main">=</span> Syntax.read_term <span class="entity">ctxt</span> <span class="entity">s</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arbitraries</span> <span class="main">=</span> map <span class="main">(</span>Syntax.read_term <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">t</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">P</span> <span class="main">=</span> <span class="entity">get_induct_stmt</span> <span class="entity">ctxt</span> <span class="main">(</span>K true<span class="main">,</span> <span class="main">[</span><span class="entity">var</span><span class="main">]</span><span class="main">,</span> NONE<span class="main">,</span> <span class="entity">arbitraries</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ind_th</span> <span class="main">=</span> <span class="entity">get_typed_ind_th</span> <span class="entity">thy</span> <span class="inner_quoted">"strong_induct"</span> <span class="main">(</span>type_of <span class="entity">var</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">var_P</span><span class="main">,</span> <span class="entity">var_n</span><span class="main">)</span> <span class="main">=</span> <span class="entity">ind_th</span> |&gt; <span class="entity">concl_of'</span> |&gt; Term.dest_comb
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inst</span> <span class="main">=</span> fold <span class="main">(</span>Pattern.match <span class="entity">thy</span><span class="main">)</span> <span class="main">[</span><span class="main">(</span><span class="entity">var_P</span><span class="main">,</span> <span class="entity">P</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">var_n</span><span class="main">,</span> <span class="entity">var</span><span class="main">)</span><span class="main">]</span> <span class="entity">fo_init</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ind_th</span> <span class="main">=</span> <span class="entity">Util.subst_thm</span> <span class="entity">ctxt</span> <span class="entity">inst</span> <span class="entity">ind_th</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">state</span> |&gt; <span class="entity">apply_simple_induct_th</span> <span class="entity">ind_th</span> <span class="main">[</span><span class="entity">var</span><span class="main">]</span> <span class="entity">arbitraries</span> true
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arbitrary</span> <span class="main">=</span>
    Scan.option <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">keyword</span> "<span class="keyword2">arbitrary</span>"<span class="antiquote">}</span></span></span> |-- Scan.repeat Parse.term<span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  <span class="entity">Outer_Syntax.command</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">command_keyword</span> "<span class="keyword1">@strong_induct</span>"<span class="antiquote">}</span></span></span>
    <span class="inner_quoted">"apply strong induction"</span>
    <span class="main">(</span><span class="main">(</span>Parse.term -- <span class="entity">arbitrary</span><span class="main">)</span> &gt;&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">s</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span> <span class="main">=&gt;</span>
         <span class="entity">Toplevel.proof</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">state</span> <span class="main">=&gt;</span> <span class="entity">strong_induct_cmd</span> <span class="main">(</span><span class="entity">s</span><span class="main">,</span> these <span class="entity">t</span><span class="main">)</span> <span class="entity">state</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">apply_induct_hyp_cmd</span> <span class="entity">s</span> <span class="entity">state</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">Proof.goal</span> <span class="entity">state</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ts</span> <span class="main">=</span> Syntax.read_terms <span class="entity">ctxt</span> <span class="entity">s</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">induct_stmt</span> <span class="main">=</span> <span class="entity">Auto2_State.get_last_induct_stmt</span> <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">stmt</span> <span class="main">=</span> <span class="entity">induct_stmt</span> |&gt; the |&gt; <span class="entity">mk_Trueprop</span> |&gt; Thm.cterm_of <span class="entity">ctxt</span>
                 <span class="keyword3"><span class="keyword">handle</span></span> Option.Option <span class="main">=&gt;</span>
                        <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"apply_induct_hyp: no induct_stmt"</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prop</span> <span class="main">=</span> <span class="entity">Auto2_State.get_selected</span> <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">(</span><span class="entity">As</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">prop</span> |&gt; Thm.prems_of |&gt; the_single
                              |&gt; <span class="entity">Util.strip_meta_horn</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span>member <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv<span class="main">)</span> <span class="entity">As</span> <span class="main">(</span>Thm.term_of <span class="entity">stmt</span><span class="main">)</span><span class="main">)</span>
                     <span class="inner_quoted">"apply_induct_hyp: induct_stmt not found among As."</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cAs</span> <span class="main">=</span> map <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">As</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th</span> <span class="main">=</span> <span class="entity">stmt</span> |&gt; Thm.assume
                    |&gt; <span class="entity">apply_to_thm</span> <span class="main">(</span><span class="entity">UtilLogic.to_meta_conv</span> <span class="entity">ctxt</span><span class="main">)</span>
                    |&gt; fold Thm.forall_elim <span class="main">(</span>map <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">ts</span><span class="main">)</span>
                    |&gt; <span class="entity">apply_to_thm</span> <span class="main">(</span><span class="entity">Util.normalize_meta_all_imp</span> <span class="entity">ctxt</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prems</span> <span class="main">=</span> <span class="entity">th</span> |&gt; Thm.prems_of
                     |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="main">=&gt;</span> Logic.list_implies <span class="main">(</span><span class="entity">As</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span>
                     |&gt; map <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prems_th</span> <span class="main">=</span> <span class="main">(</span>map <span class="main">(</span><span class="entity">Auto2_Outer.auto2_solve</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">prems</span><span class="main">)</span>
                         |&gt; map <span class="entity">Util.send_all_to_hyps</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">concl</span> <span class="main">=</span> <span class="entity">th</span> |&gt; fold Thm.elim_implies <span class="entity">prems_th</span>
                     |&gt; fold Thm.implies_intr <span class="main">(</span>rev <span class="entity">cAs</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> writeln <span class="main">(</span><span class="inner_quoted">"Obtained "</span> ^
                       Syntax.string_of_term <span class="entity">ctxt</span> <span class="main">(</span>Thm.concl_of <span class="entity">concl</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">state</span> |&gt; <span class="entity">Proof.map_contexts</span> <span class="main">(</span>
        <span class="entity">Auto2_State.map_head_th</span> <span class="main">(</span><span class="entity">Auto2_Outer.have_after_qed</span> <span class="entity">ctxt</span> <span class="entity">concl</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  <span class="entity">Outer_Syntax.command</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">command_keyword</span> "<span class="keyword1">@apply_induct_hyp</span>"<span class="antiquote">}</span></span></span>
    <span class="inner_quoted">"apply induction hypothesis"</span>
    <span class="main">(</span><span class="main">(</span>Scan.repeat Parse.term<span class="main">)</span> &gt;&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">s</span> <span class="main">=&gt;</span>
         <span class="entity">Toplevel.proof</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">state</span> <span class="main">=&gt;</span> <span class="entity">apply_induct_hyp_cmd</span> <span class="entity">s</span> <span class="entity">state</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">solve_goals</span> <span class="entity">ind_th</span> <span class="entity">pats_opt</span> <span class="entity">filt_As</span> <span class="entity">state</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">Proof.goal</span> <span class="entity">state</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">(</span><span class="entity">As</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">ctxt</span> |&gt; <span class="entity">Auto2_State.get_subgoal</span>
                              |&gt; <span class="entity">Util.strip_meta_horn</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">use_As</span> <span class="main">=</span> filter <span class="entity">filt_As</span> <span class="entity">As</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cAs</span> <span class="main">=</span> map <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">As</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ind_goals</span> <span class="main">=</span>
          <span class="entity">ind_th</span> |&gt; Thm.prems_of
                 |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="main">=&gt;</span> Logic.list_implies <span class="main">(</span><span class="entity">use_As</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span>
                 |&gt; map <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span><span class="main">)</span>
                 |&gt; map <span class="main">(</span><span class="entity">UtilLogic.to_meta_conv</span> <span class="entity">ctxt</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">pats_opt</span> <span class="keyword2"><span class="keyword">of</span></span>
        NONE <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="comment1">(* Solve the right side, obtain the left side. *)</span>
          <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">solve_eq</span> <span class="entity">eq</span> <span class="main">=</span>
              Thm.equal_elim <span class="main">(</span><span class="entity">meta_sym</span> <span class="entity">eq</span><span class="main">)</span>
                             <span class="main">(</span><span class="entity">Auto2_Outer.auto2_solve</span> <span class="entity">ctxt</span> <span class="main">(</span>Thm.rhs_of <span class="entity">eq</span><span class="main">)</span><span class="main">)</span>

          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ths</span> <span class="main">=</span> <span class="entity">ind_goals</span> |&gt; map <span class="entity">solve_eq</span>
                              |&gt; map <span class="entity">Util.send_all_to_hyps</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ind_concl</span> <span class="main">=</span> <span class="entity">ind_th</span> |&gt; fold Thm.elim_implies <span class="entity">ths</span>
                                 |&gt; fold Thm.implies_intr <span class="main">(</span>rev <span class="entity">cAs</span><span class="main">)</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">after_qed</span> <span class="main">=</span> <span class="entity">Auto2_Outer.have_after_qed</span> <span class="entity">ctxt</span> <span class="entity">ind_concl</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="entity">state</span> |&gt; <span class="entity">Proof.map_contexts</span> <span class="main">(</span><span class="entity">Auto2_State.map_head_th</span> <span class="entity">after_qed</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">end</span></span>
      <span class="main">|</span> SOME <span class="entity">pats</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="comment1">(* Create new block with the subgoals *)</span>
          <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">after_qed</span> <span class="entity">ths</span> <span class="entity">prop</span> <span class="main">=</span>
              <span class="keyword2"><span class="keyword">let</span></span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ths'</span> <span class="main">=</span>
                    <span class="main">(</span><span class="entity">ind_goals</span> ~~ <span class="entity">ths</span><span class="main">)</span>
                        |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">eq</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=&gt;</span> Thm.equal_elim <span class="main">(</span><span class="entity">meta_sym</span> <span class="entity">eq</span><span class="main">)</span> <span class="entity">th</span><span class="main">)</span>
                        |&gt; map <span class="entity">Util.send_all_to_hyps</span>

                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ind_concl</span> <span class="main">=</span>
                    <span class="entity">ind_th</span> |&gt; fold Thm.elim_implies <span class="entity">ths'</span>
                           |&gt; fold Thm.implies_intr <span class="main">(</span>rev <span class="entity">cAs</span><span class="main">)</span>
              <span class="keyword2"><span class="keyword">in</span></span>
                <span class="entity">Auto2_Outer.have_after_qed</span> <span class="entity">ctxt</span> <span class="entity">ind_concl</span> <span class="entity">prop</span>
              <span class="keyword2"><span class="keyword">end</span></span>

          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> writeln <span class="main">(</span><span class="inner_quoted">"Patterns: "</span> ^ <span class="entity">Util.string_of_terms</span> <span class="entity">ctxt</span> <span class="entity">pats</span><span class="main">)</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">new_frame</span> <span class="main">=</span>
              <span class="entity">Auto2_State.multiple_frame</span> <span class="main">(</span>
                <span class="entity">pats</span> ~~ map Thm.rhs_of <span class="entity">ind_goals</span><span class="main">,</span> SOME <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">after_qed</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="entity">state</span> |&gt; <span class="entity">Proof.map_contexts</span> <span class="main">(</span><span class="entity">Auto2_State.push_head</span> <span class="entity">new_frame</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">case_induct_cmd</span> <span class="entity">s</span> <span class="entity">state</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">Proof.goal</span> <span class="entity">state</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">start</span> <span class="main">=</span> Syntax.read_term <span class="entity">ctxt</span> <span class="entity">s</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ind_th</span> <span class="main">=</span> <span class="entity">get_term_ind_th</span> <span class="entity">thy</span> <span class="inner_quoted">"case_induct"</span> <span class="entity">start</span>

      <span class="comment1">(* Obtain list of assumptions *)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">C</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">ctxt</span> |&gt; <span class="entity">Auto2_State.get_subgoal</span>
                             |&gt; <span class="entity">Util.strip_meta_horn</span>

      <span class="comment1">(* Instantiate the induction theorem *)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">var_P</span> <span class="main">=</span> <span class="entity">concl_of'</span> <span class="entity">ind_th</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inst</span> <span class="main">=</span> Pattern.match <span class="entity">thy</span> <span class="main">(</span><span class="entity">var_P</span><span class="main">,</span> <span class="entity">dest_Trueprop</span> <span class="entity">C</span><span class="main">)</span> <span class="entity">fo_init</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ind_th</span> <span class="main">=</span> <span class="entity">Util.subst_thm_thy</span> <span class="entity">thy</span> <span class="entity">inst</span> <span class="entity">ind_th</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">state</span> |&gt; <span class="entity">solve_goals</span> <span class="entity">ind_th</span> NONE <span class="main">(</span>K true<span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  <span class="entity">Outer_Syntax.command</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">command_keyword</span> "<span class="keyword1">@case_induct</span>"<span class="antiquote">}</span></span></span> <span class="inner_quoted">"apply induction"</span>
    <span class="main">(</span>Parse.term &gt;&gt;
        <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">s</span> <span class="main">=&gt;</span>
            <span class="entity">Toplevel.proof</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">state</span> <span class="main">=&gt;</span> <span class="entity">case_induct_cmd</span> <span class="entity">s</span> <span class="entity">state</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">for_stmt</span> <span class="main">=</span>
    Scan.option <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">keyword</span> "<span class="keyword2">for</span>"<span class="antiquote">}</span></span></span> |-- Parse.term<span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prop_induct_cmd</span> <span class="main">(</span><span class="entity">s</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span> <span class="entity">state</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">Proof.goal</span> <span class="entity">state</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">start</span> <span class="main">=</span> Syntax.read_term <span class="entity">ctxt</span> <span class="entity">s</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ind_th</span> <span class="main">=</span> <span class="entity">get_term_ind_th</span> <span class="entity">thy</span> <span class="inner_quoted">"prop_induct"</span> <span class="entity">start</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">var_P</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span> <span class="main">=</span> <span class="entity">ind_th</span> |&gt; <span class="entity">concl_of'</span> |&gt; Term.strip_comb

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">start_As</span> <span class="main">=</span> <span class="entity">strip_conj</span> <span class="entity">start</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">filt_A</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="main">=&gt;</span> not <span class="main">(</span>member <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv<span class="main">)</span> <span class="entity">start_As</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">P</span> <span class="main">=</span> <span class="entity">get_induct_stmt</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">filt_A</span><span class="main">,</span> <span class="entity">args</span><span class="main">,</span> <span class="entity">t</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> writeln <span class="main">(</span><span class="inner_quoted">"Induct statement: "</span> ^ Syntax.string_of_term <span class="entity">ctxt</span> <span class="entity">P</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inst</span> <span class="main">=</span> Pattern.match <span class="entity">thy</span> <span class="main">(</span><span class="entity">var_P</span><span class="main">,</span> <span class="entity">P</span><span class="main">)</span> <span class="entity">fo_init</span>

      <span class="comment1">(* Instantiate the induction theorem *)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ind_th</span> <span class="main">=</span> <span class="entity">Util.subst_thm_thy</span> <span class="entity">thy</span> <span class="entity">inst</span> <span class="entity">ind_th</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">state</span> |&gt; <span class="entity">solve_goals</span> <span class="entity">ind_th</span> NONE <span class="main">(</span>K true<span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  <span class="entity">Outer_Syntax.command</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">command_keyword</span> "<span class="keyword1">@prop_induct</span>"<span class="antiquote">}</span></span></span> <span class="inner_quoted">"apply induction"</span>
    <span class="main">(</span><span class="main">(</span>Parse.term -- <span class="entity">for_stmt</span><span class="main">)</span> &gt;&gt;
        <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">s</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span> <span class="main">=&gt;</span>
            <span class="entity">Toplevel.proof</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">state</span> <span class="main">=&gt;</span> <span class="entity">prop_induct_cmd</span> <span class="main">(</span><span class="entity">s</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span> <span class="entity">state</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

<span class="comment1">(* Given an induction subgoal of the form !!x_i. A_i ==&gt; C, retrieve
   the list of induction patterns.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">retrieve_pat</span> <span class="entity">ind_vars</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">vars</span><span class="main">,</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">C</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Util.strip_meta_horn</span> <span class="entity">t</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">free_to_var</span> <span class="entity">t</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="main">=</span> Term.dest_Free <span class="entity">t</span> <span class="keyword2"><span class="keyword">in</span></span> Var <span class="main">(</span><span class="main">(</span><span class="entity">x</span><span class="main">,</span><span class="inner_numeral">0</span><span class="main">)</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pat_vars</span> <span class="main">=</span> map <span class="entity">free_to_var</span> <span class="entity">vars</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">=</span> <span class="entity">C</span> |&gt; <span class="entity">dest_Trueprop</span> |&gt; <span class="entity">Util.dest_args</span>
                   |&gt; map <span class="main">(</span>Term.subst_atomic <span class="main">(</span><span class="entity">vars</span> ~~ <span class="entity">pat_vars</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">HOLogic.mk_tuple</span> <span class="main">(</span>map <span class="entity">mk_eq</span> <span class="main">(</span><span class="entity">ind_vars</span> ~~ <span class="entity">args</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">induct_cmd</span> <span class="entity">ind_ty_str</span> <span class="main">(</span><span class="entity">s</span><span class="main">,</span> <span class="entity">t</span><span class="main">,</span> <span class="entity">u</span><span class="main">,</span> <span class="entity">v</span><span class="main">)</span> <span class="entity">state</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">Proof.goal</span> <span class="entity">state</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">var</span> <span class="main">=</span> Syntax.read_term <span class="entity">ctxt</span> <span class="entity">s</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arbitraries</span> <span class="main">=</span> map <span class="main">(</span>Syntax.read_term <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">u</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">filt_A</span> <span class="main">=</span> <span class="entity">Util.occurs_frees</span> <span class="main">(</span><span class="entity">var</span> :: <span class="entity">arbitraries</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">P</span> <span class="main">=</span> <span class="entity">get_induct_stmt</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">filt_A</span><span class="main">,</span> <span class="main">[</span><span class="entity">var</span><span class="main">]</span><span class="main">,</span> <span class="entity">t</span><span class="main">,</span> <span class="entity">arbitraries</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ind_th</span> <span class="main">=</span> <span class="entity">get_typed_ind_th</span> <span class="entity">thy</span> <span class="entity">ind_ty_str</span> <span class="main">(</span>type_of <span class="entity">var</span><span class="main">)</span>

      <span class="comment1">(* Instantiate the induction theorem *)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">concl</span> <span class="main">=</span> <span class="entity">concl_of'</span> <span class="entity">ind_th</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">var_P</span><span class="main">,</span> <span class="entity">var_n</span><span class="main">)</span> <span class="main">=</span> Term.dest_comb <span class="entity">concl</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inst</span> <span class="main">=</span> fold <span class="main">(</span>Pattern.match <span class="entity">thy</span><span class="main">)</span> <span class="main">[</span><span class="main">(</span><span class="entity">var_P</span><span class="main">,</span> <span class="entity">P</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">var_n</span><span class="main">,</span> <span class="entity">var</span><span class="main">)</span><span class="main">]</span> <span class="entity">fo_init</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ind_th'</span> <span class="main">=</span> <span class="entity">Util.subst_thm_thy</span> <span class="entity">thy</span> <span class="entity">inst</span> <span class="entity">ind_th</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pats</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">v</span> <span class="keyword2"><span class="keyword">of</span></span>
              NONE <span class="main">=&gt;</span> NONE
            <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> SOME <span class="main">(</span>map <span class="main">(</span><span class="entity">retrieve_pat</span> <span class="main">[</span><span class="entity">var</span><span class="main">]</span><span class="main">)</span> <span class="main">(</span>Thm.prems_of <span class="entity">ind_th</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">state</span> |&gt; <span class="entity">solve_goals</span> <span class="entity">ind_th'</span> <span class="entity">pats</span> <span class="main">(</span>not o <span class="entity">filt_A</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  <span class="entity">Outer_Syntax.command</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">command_keyword</span> "<span class="keyword1">@induct</span>"<span class="antiquote">}</span></span></span> <span class="inner_quoted">"apply induction"</span>
    <span class="main">(</span>Parse.term -- <span class="entity">for_stmt</span> -- <span class="entity">arbitrary</span> -- Scan.option <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">keyword</span> "<span class="keyword2">@with</span>"<span class="antiquote">}</span></span></span> &gt;&gt;
        <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">s</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">,</span> <span class="entity">u</span><span class="main">)</span><span class="main">,</span> <span class="entity">v</span><span class="main">)</span> <span class="main">=&gt;</span>
            <span class="entity">Toplevel.proof</span> <span class="main">(</span>
              <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">state</span> <span class="main">=&gt;</span> <span class="entity">induct_cmd</span> <span class="inner_quoted">"var_induct"</span> <span class="main">(</span><span class="entity">s</span><span class="main">,</span> <span class="entity">t</span><span class="main">,</span> these <span class="entity">u</span><span class="main">,</span> <span class="entity">v</span><span class="main">)</span> <span class="entity">state</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  <span class="entity">Outer_Syntax.command</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">command_keyword</span> "<span class="keyword1">@cases</span>"<span class="antiquote">}</span></span></span> <span class="inner_quoted">"apply induction"</span>
    <span class="main">(</span>Parse.term -- Scan.option <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">keyword</span> "<span class="keyword2">@with</span>"<span class="antiquote">}</span></span></span> &gt;&gt;
        <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">s</span><span class="main">,</span> <span class="entity">v</span><span class="main">)</span> <span class="main">=&gt;</span>
            <span class="entity">Toplevel.proof</span> <span class="main">(</span>
              <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">state</span> <span class="main">=&gt;</span> <span class="entity">induct_cmd</span> <span class="inner_quoted">"cases"</span> <span class="main">(</span><span class="entity">s</span><span class="main">,</span> NONE<span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">v</span><span class="main">)</span> <span class="entity">state</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_fun_induct_th</span> <span class="entity">thy</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ind_th</span> <span class="main">=</span>
          <span class="entity">get_term_ind_th</span> <span class="entity">thy</span> <span class="inner_quoted">"fun_induct"</span> <span class="main">(</span>Term.head_of <span class="entity">t</span><span class="main">)</span>
          <span class="keyword3"><span class="keyword">handle</span></span> Fail <span class="main">_</span> <span class="main">=&gt;</span>
                 Global_Theory.get_thm <span class="entity">thy</span> <span class="main">(</span><span class="entity">Util.get_head_name</span> <span class="entity">t</span> ^ <span class="inner_quoted">".induct"</span><span class="main">)</span>
                 <span class="keyword3"><span class="keyword">handle</span></span> ERROR <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"fun_induct: cannot find theorem."</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span> <span class="main">=</span> Term.strip_comb <span class="entity">t</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">pat_args</span><span class="main">)</span> <span class="main">=</span> <span class="entity">ind_th</span> |&gt; <span class="entity">concl_of'</span> |&gt; Term.strip_comb
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inst</span> <span class="main">=</span> <span class="entity">Util.first_order_match_list</span> <span class="entity">thy</span> <span class="main">(</span><span class="entity">pat_args</span> ~~ <span class="entity">args</span><span class="main">)</span> <span class="entity">fo_init</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">Util.subst_thm_thy</span> <span class="entity">thy</span> <span class="entity">inst</span> <span class="entity">ind_th</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_simple_fun_induct</span> <span class="entity">ind_th</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prems</span> <span class="main">=</span> Thm.prems_of <span class="entity">ind_th</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> length <span class="entity">prems</span> &gt; <span class="inner_numeral">1</span> <span class="keyword2"><span class="keyword">then</span></span> false
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">var</span><span class="main">,</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">C</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Util.strip_meta_horn</span> <span class="main">(</span>the_single <span class="entity">prems</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span> <span class="main">=</span> Term.strip_comb <span class="main">(</span><span class="entity">dest_Trueprop</span> <span class="entity">C</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        eq_list <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv<span class="main">)</span> <span class="main">(</span><span class="entity">var</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">fun_induct_cmd</span> <span class="main">(</span><span class="entity">s</span><span class="main">,</span> <span class="entity">t</span><span class="main">,</span> <span class="entity">u</span><span class="main">)</span> <span class="entity">state</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">Proof.goal</span> <span class="entity">state</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">expr</span> <span class="main">=</span> Syntax.read_term <span class="entity">ctxt</span> <span class="entity">s</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arbitraries</span> <span class="main">=</span> map <span class="main">(</span>Syntax.read_term <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">t</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ind_th</span> <span class="main">=</span> <span class="entity">get_fun_induct_th</span> <span class="entity">thy</span> <span class="entity">expr</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">var_P</span><span class="main">,</span> <span class="entity">vars</span><span class="main">)</span> <span class="main">=</span> <span class="entity">ind_th</span> |&gt; <span class="entity">concl_of'</span> |&gt; Term.strip_comb
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_simple_fun_induct</span> <span class="entity">ind_th</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span>is_none <span class="entity">u</span><span class="main">)</span> <span class="inner_quoted">"fun_induct: simple induction."</span>

          <span class="comment1">(* Instantiate the induction theorem *)</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">P</span> <span class="main">=</span> <span class="entity">get_induct_stmt</span> <span class="entity">ctxt</span> <span class="main">(</span>K true<span class="main">,</span> <span class="entity">vars</span><span class="main">,</span> NONE<span class="main">,</span> <span class="entity">arbitraries</span><span class="main">)</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inst</span> <span class="main">=</span> Pattern.match <span class="entity">thy</span> <span class="main">(</span><span class="entity">var_P</span><span class="main">,</span> <span class="entity">P</span><span class="main">)</span> <span class="entity">fo_init</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ind_th</span> <span class="main">=</span> <span class="entity">Util.subst_thm_thy</span> <span class="entity">thy</span> <span class="entity">inst</span> <span class="entity">ind_th</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="entity">state</span> |&gt; <span class="entity">apply_simple_induct_th</span> <span class="entity">ind_th</span> <span class="entity">vars</span> <span class="entity">arbitraries</span> false
        <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="comment1">(* Instantiate the induction theorem *)</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">filt_A</span> <span class="main">=</span> <span class="entity">Util.occurs_frees</span> <span class="main">(</span><span class="entity">vars</span> @ <span class="entity">arbitraries</span><span class="main">)</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">P</span> <span class="main">=</span> <span class="entity">get_induct_stmt</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">filt_A</span><span class="main">,</span> <span class="entity">vars</span><span class="main">,</span> NONE<span class="main">,</span> <span class="entity">arbitraries</span><span class="main">)</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">inst</span> <span class="main">=</span> Pattern.match <span class="entity">thy</span> <span class="main">(</span><span class="entity">var_P</span><span class="main">,</span> <span class="entity">P</span><span class="main">)</span> <span class="entity">fo_init</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ind_th'</span> <span class="main">=</span> <span class="entity">ind_th</span> |&gt; <span class="entity">Util.subst_thm_thy</span> <span class="entity">thy</span> <span class="entity">inst</span>

          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prems</span> <span class="main">=</span> Thm.prems_of <span class="entity">ind_th</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pats</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">u</span> <span class="keyword2"><span class="keyword">of</span></span> NONE <span class="main">=&gt;</span> NONE
                             <span class="main">|</span> SOME <span class="main">_</span> <span class="main">=&gt;</span> SOME <span class="main">(</span>map <span class="main">(</span><span class="entity">retrieve_pat</span> <span class="entity">vars</span><span class="main">)</span> <span class="entity">prems</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="entity">state</span> |&gt; <span class="entity">solve_goals</span> <span class="entity">ind_th'</span> <span class="entity">pats</span> <span class="main">(</span>not o <span class="entity">filt_A</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  <span class="entity">Outer_Syntax.command</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">command_keyword</span> "<span class="keyword1">@fun_induct</span>"<span class="antiquote">}</span></span></span> <span class="inner_quoted">"apply induction"</span>
    <span class="main">(</span>Parse.term -- <span class="entity">arbitrary</span> -- Scan.option <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">keyword</span> "<span class="keyword2">@with</span>"<span class="antiquote">}</span></span></span> &gt;&gt;
        <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">s</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">,</span> <span class="entity">u</span><span class="main">)</span> <span class="main">=&gt;</span>
            <span class="entity">Toplevel.proof</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">state</span> <span class="main">=&gt;</span> <span class="entity">fun_induct_cmd</span> <span class="main">(</span><span class="entity">s</span><span class="main">,</span> these <span class="entity">t</span><span class="main">,</span> <span class="entity">u</span><span class="main">)</span> <span class="entity">state</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>  <span class="comment1">(* structure Induct_ProofSteps. *)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">add_strong_induct_rule</span> <span class="main">=</span> <span class="entity">Induct_ProofSteps.add_strong_induct_rule</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">add_case_induct_rule</span> <span class="main">=</span> <span class="entity">Induct_ProofSteps.add_case_induct_rule</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">add_prop_induct_rule</span> <span class="main">=</span> <span class="entity">Induct_ProofSteps.add_prop_induct_rule</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">add_var_induct_rule</span> <span class="main">=</span> <span class="entity">Induct_ProofSteps.add_var_induct_rule</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">add_fun_induct_rule</span> <span class="main">=</span> <span class="entity">Induct_ProofSteps.add_fun_induct_rule</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">add_cases_rule</span> <span class="main">=</span> <span class="entity">Induct_ProofSteps.add_cases_rule</span>
</pre>
</div><div id="files/extra_hol.ML">
<div class="head">
<h1>File ‹extra_hol.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*
  File: extra_hol.ML
  Author: Bohua Zhan

  Extra setup for HOL.
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">EXTRA_HOL</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> add_forward_arg1_prfstep_cond<span class="main">:</span>
      thm <span class="main">-&gt;</span> <span class="entity">pre_prfstep_descriptor</span> list <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> add_forward_arg1_prfstep<span class="main">:</span> thm <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> add_forward_arg_prfstep_cond<span class="main">:</span>
      thm <span class="main">-&gt;</span> <span class="entity">pre_prfstep_descriptor</span> list <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> add_forward_arg_prfstep<span class="main">:</span> thm <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> add_rewrite_arg_rule_cond<span class="main">:</span>
      thm <span class="main">-&gt;</span> <span class="entity">pre_prfstep_descriptor</span> list <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> add_rewrite_arg_rule<span class="main">:</span> thm <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory

  <span class="keyword1"><span class="keyword">val</span></span> add_simple_datatype<span class="main">:</span> string <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> del_simple_datatype<span class="main">:</span> string <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Extra_HOL</span> <span class="main">:</span> <span class="entity">EXTRA_HOL</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_forward_arg1_prfstep_cond</span> <span class="entity">th</span> <span class="entity">conds</span> <span class="entity">thy</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">concl</span> <span class="main">=</span> <span class="entity">th</span> |&gt; <span class="entity">concl_of'</span> |&gt; <span class="entity">strip_conj</span> |&gt; hd
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">thy</span> |&gt; <span class="entity">add_forward_prfstep_cond</span>
          <span class="entity">th</span> <span class="main">(</span><span class="main">[</span>K <span class="main">(</span><span class="entity">WithTerm</span> <span class="main">(</span><span class="entity">dest_arg1</span> <span class="entity">concl</span><span class="main">)</span><span class="main">)</span><span class="main">]</span> @ <span class="entity">conds</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_forward_arg1_prfstep</span> <span class="entity">th</span> <span class="main">=</span> <span class="entity">add_forward_arg1_prfstep_cond</span> <span class="entity">th</span> <span class="main">[</span><span class="main">]</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_forward_arg_prfstep_cond</span> <span class="entity">th</span> <span class="entity">conds</span> <span class="entity">thy</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">concl</span> <span class="main">=</span> <span class="entity">th</span> |&gt; <span class="entity">concl_of'</span> |&gt; <span class="entity">strip_conj</span> |&gt; hd
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">thy</span> |&gt; <span class="entity">add_forward_prfstep_cond</span>
          <span class="entity">th</span> <span class="main">(</span><span class="main">[</span>K <span class="main">(</span><span class="entity">WithTerm</span> <span class="main">(</span><span class="entity">dest_arg</span> <span class="entity">concl</span><span class="main">)</span><span class="main">)</span><span class="main">]</span> @ <span class="entity">conds</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_forward_arg_prfstep</span> <span class="entity">th</span> <span class="main">=</span> <span class="entity">add_forward_arg_prfstep_cond</span> <span class="entity">th</span> <span class="main">[</span><span class="main">]</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_rewrite_arg_rule_cond</span> <span class="entity">th</span> <span class="entity">conds</span> <span class="entity">thy</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">concl</span> <span class="main">=</span> <span class="entity">th</span> |&gt; <span class="entity">concl_of'</span> |&gt; <span class="entity">strip_conj</span> |&gt; hd
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span><span class="entity">is_eq_term</span> <span class="entity">concl</span><span class="main">)</span> <span class="inner_quoted">"rewrite_arg"</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">dest_eq</span> <span class="entity">concl</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">thy</span> |&gt; <span class="entity">add_forward_prfstep_cond</span>
          <span class="entity">th</span> <span class="main">(</span><span class="main">[</span>K <span class="main">(</span><span class="entity">WithTerm</span> <span class="main">(</span><span class="entity">dest_arg</span> <span class="entity">lhs</span><span class="main">)</span><span class="main">)</span><span class="main">]</span> @ <span class="entity">conds</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_rewrite_arg_rule</span> <span class="entity">th</span> <span class="main">=</span> <span class="entity">add_rewrite_arg_rule_cond</span> <span class="entity">th</span> <span class="main">[</span><span class="main">]</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_simple_datatype</span> <span class="entity">s</span> <span class="entity">thy</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">collapse_th</span> <span class="main">=</span> Global_Theory.get_thm <span class="entity">thy</span> <span class="main">(</span><span class="entity">s</span> ^ <span class="inner_quoted">".collapse"</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">case_th</span> <span class="main">=</span> Global_Theory.get_thm <span class="entity">thy</span> <span class="main">(</span><span class="entity">s</span> ^ <span class="inner_quoted">".case"</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sel_th</span> <span class="main">=</span> Global_Theory.get_thms <span class="entity">thy</span> <span class="main">(</span><span class="entity">s</span> ^ <span class="inner_quoted">".sel"</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simp_th</span> <span class="main">=</span> hd <span class="main">(</span>Global_Theory.get_thms <span class="entity">thy</span> <span class="main">(</span><span class="entity">s</span> ^ <span class="inner_quoted">".simps"</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">var</span> <span class="main">=</span> <span class="entity">collapse_th</span> |&gt; <span class="entity">prop_of'</span> |&gt; <span class="entity">dest_arg</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">f</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span> <span class="main">=</span> <span class="entity">collapse_th</span> |&gt; <span class="entity">prop_of'</span> |&gt; <span class="entity">dest_arg1</span> |&gt; Term.strip_comb
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">vars</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">n</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="main">=&gt;</span> Var <span class="main">(</span><span class="main">(</span><span class="inner_quoted">"x"</span><span class="main">,</span><span class="entity">n</span><span class="main">)</span><span class="main">,</span><span class="entity">T</span><span class="main">)</span><span class="main">)</span>
                     <span class="main">(</span>tag_list <span class="inner_numeral">1</span> <span class="main">(</span>map fastype_of <span class="entity">args</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs</span> <span class="main">=</span> Term.list_comb <span class="main">(</span><span class="entity">f</span><span class="main">,</span> <span class="entity">vars</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">neq</span> <span class="main">=</span> <span class="entity">get_neg</span> <span class="main">(</span><span class="entity">mk_eq</span> <span class="main">(</span><span class="entity">var</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">filt</span> <span class="main">=</span> <span class="main">[</span><span class="entity">with_filt</span> <span class="main">(</span><span class="entity">neq_filter</span> <span class="entity">neq</span><span class="main">)</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">thy</span> |&gt; <span class="entity">add_rewrite_rule_back_cond</span> <span class="entity">collapse_th</span> <span class="entity">filt</span>
          |&gt; <span class="entity">add_rewrite_rule</span> <span class="entity">case_th</span>
          |&gt; fold <span class="entity">add_rewrite_rule</span> <span class="entity">sel_th</span>
          |&gt; <span class="entity">add_forward_prfstep</span> <span class="main">(</span><span class="entity">equiv_forward_th</span> <span class="entity">simp_th</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">del_simple_datatype</span> <span class="entity">s</span> <span class="entity">thy</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">collapse_th</span> <span class="main">=</span> Global_Theory.get_thm <span class="entity">thy</span> <span class="main">(</span><span class="entity">s</span> ^ <span class="inner_quoted">".collapse"</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">case_th</span> <span class="main">=</span> Global_Theory.get_thm <span class="entity">thy</span> <span class="main">(</span><span class="entity">s</span> ^ <span class="inner_quoted">".case"</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sel_th</span> <span class="main">=</span> Global_Theory.get_thms <span class="entity">thy</span> <span class="main">(</span><span class="entity">s</span> ^ <span class="inner_quoted">".sel"</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simp_th</span> <span class="main">=</span> hd <span class="main">(</span>Global_Theory.get_thms <span class="entity">thy</span> <span class="main">(</span><span class="entity">s</span> ^ <span class="inner_quoted">".simps"</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">thy</span> |&gt; fold <span class="entity">del_prfstep_thm</span> <span class="main">(</span><span class="entity">collapse_th</span> :: <span class="entity">case_th</span> :: <span class="entity">simp_th</span> :: <span class="entity">sel_th</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>  <span class="comment1">(* structure Extra_HOL *)</span>

<span class="keyword3"><span class="keyword">open</span></span> <span class="entity">Extra_HOL</span>
</pre>
</div><div id="Logic_Thms">
<div class="head">
<h1>Theory Logic_Thms</h1>
</div>
<pre class="source"><span class="comment1">(*
  File: Logic_Thms.thy
  Author: Bohua Zhan

  Setup for proof steps related to logic.
*)</span>

<span class="keyword1"><span class="command">theory</span></span> Logic_Thms
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Auto2_HOL.html">Auto2_HOL</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(* Trivial contradictions. *)</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_resolve_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> HOL.refl<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> contra_triv<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_resolve_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> TrueI<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">theorem</span></span> FalseD <span class="main">[</span><span class="operator">resolve</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>False"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">lemma</span></span> exists_triv_eq <span class="main">[</span><span class="operator">resolve</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="comment1">(* Not. *)</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> HOL.not_sym<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_filt</span> <span class="main">(</span><span class="entity">not_type_filter</span> <span class="inner_quoted">"s"</span> <span class="entity">boolT</span><span class="main">)</span><span class="main">]</span>›</span>

<span class="comment1">(* Iff. *)</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_gen_prfstep</span> <span class="main">(</span><span class="inner_quoted">"iff_intro1"</span><span class="main">,</span>
  <span class="main">[</span><span class="entity">WithGoal</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term_pat</span> <span class="quoted">"<span class="main">(</span><span class="var">?A</span><span class="main">::</span>bool<span class="main">)</span> <span class="main">=</span> <span class="var">?B</span>"</span><span class="antiquote">}</span></span><span class="main">,</span>
   <span class="entity">CreateCase</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term_pat</span> <span class="quoted">"<span class="var">?A</span><span class="main">::</span>bool"</span><span class="antiquote">}</span></span><span class="main">,</span>
   <span class="entity">WithScore</span> <span class="inner_numeral">25</span><span class="main">]</span><span class="main">)</span>›</span>
<span class="keyword1"><span class="command">theorem</span></span> iff_goal<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">≠</span> <span class="free">B</span> <span class="main">⟹</span> <span class="free">A</span> <span class="main">⟹</span> <span class="main">¬</span><span class="free">B</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">≠</span> <span class="free">B</span> <span class="main">⟹</span> <span class="free">B</span> <span class="main">⟹</span> <span class="main">¬</span><span class="free">A</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">≠</span> <span class="free">B</span> <span class="main">⟹</span> <span class="main">¬</span><span class="free">A</span> <span class="main">⟹</span> <span class="free">B</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">≠</span> <span class="free">B</span> <span class="main">⟹</span> <span class="main">¬</span><span class="free">B</span> <span class="main">⟹</span> <span class="free">A</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">¬</span><span class="free">A</span><span class="main">)</span> <span class="main">≠</span> <span class="free">B</span> <span class="main">⟹</span> <span class="free">A</span> <span class="main">⟹</span> <span class="free">B</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">≠</span> <span class="main">(</span><span class="main">¬</span><span class="free">B</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">B</span> <span class="main">⟹</span> <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹fold <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">th</span> <span class="main">=&gt;</span> <span class="entity">add_forward_prfstep_cond</span> <span class="entity">th</span> <span class="main">[</span><span class="entity">with_score</span> <span class="inner_numeral">1</span><span class="main">]</span><span class="main">)</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> iff_goal<span class="antiquote">}</span></span></span>›</span>

<span class="comment1">(* Quantifiers: normalization *)</span>
<span class="keyword1"><span class="command">theorem</span></span> exists_split<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∃</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span> <span class="main">∧</span> <span class="free">Q</span> <span class="bound">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∃</span><span class="bound">y</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_backward_prfstep</span> <span class="main">(</span><span class="entity">equiv_backward_th</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> exists_split<span class="antiquote">}</span></span></span><span class="main">)</span>›</span>

<span class="comment1">(* Case analysis. *)</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_gen_prfstep</span> <span class="main">(</span><span class="inner_quoted">"case_intro"</span><span class="main">,</span>
  <span class="main">[</span><span class="entity">WithTerm</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term_pat</span> <span class="quoted">"<span class="keyword1">if</span> <span class="var">?cond</span> <span class="keyword1">then</span> <span class="main">(</span><span class="var">?yes</span><span class="main">::</span><span class="tvar">?'a</span><span class="main">)</span> <span class="keyword1">else</span> <span class="var">?no</span>"</span><span class="antiquote">}</span></span><span class="main">,</span>
   <span class="entity">CreateCase</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term_pat</span> <span class="quoted">"<span class="var">?cond</span><span class="main">::</span>bool"</span><span class="antiquote">}</span></span><span class="main">]</span><span class="main">)</span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_gen_prfstep</span> <span class="main">(</span><span class="inner_quoted">"case_intro_fact"</span><span class="main">,</span>
  <span class="main">[</span><span class="entity">WithFact</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term_pat</span> <span class="quoted">"<span class="keyword1">if</span> <span class="var">?cond</span> <span class="keyword1">then</span> <span class="main">(</span><span class="var">?yes</span><span class="main">::</span>bool<span class="main">)</span> <span class="keyword1">else</span> <span class="var">?no</span>"</span><span class="antiquote">}</span></span><span class="main">,</span>
   <span class="entity">CreateCase</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term_pat</span> <span class="quoted">"<span class="var">?cond</span><span class="main">::</span>bool"</span><span class="antiquote">}</span></span><span class="main">]</span><span class="main">)</span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_gen_prfstep</span> <span class="main">(</span><span class="inner_quoted">"case_intro_goal"</span><span class="main">,</span>
  <span class="main">[</span><span class="entity">WithGoal</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term_pat</span> <span class="quoted">"<span class="keyword1">if</span> <span class="var">?cond</span> <span class="keyword1">then</span> <span class="main">(</span><span class="var">?yes</span><span class="main">::</span>bool<span class="main">)</span> <span class="keyword1">else</span> <span class="var">?no</span>"</span><span class="antiquote">}</span></span><span class="main">,</span>
   <span class="entity">CreateCase</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term_pat</span> <span class="quoted">"<span class="var">?cond</span><span class="main">::</span>bool"</span><span class="antiquote">}</span></span><span class="main">]</span><span class="main">)</span>›</span>
<span class="keyword1"><span class="command">lemma</span></span> if_eval'<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">⟹</span> <span class="main">(</span><span class="keyword1">if</span> <span class="main">¬</span><span class="free">P</span> <span class="keyword1">then</span> <span class="free">x</span> <span class="keyword1">else</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">lemma</span></span> ifb_eval<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">⟹</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">P</span> <span class="keyword1">then</span> <span class="main">(</span><span class="free">x</span><span class="main">::</span>bool<span class="main">)</span> <span class="keyword1">else</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="free">P</span> <span class="main">⟹</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">P</span> <span class="keyword1">then</span> <span class="main">(</span><span class="free">x</span><span class="main">::</span>bool<span class="main">)</span> <span class="keyword1">else</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="free">y</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">⟹</span> <span class="main">(</span><span class="keyword1">if</span> <span class="main">¬</span><span class="free">P</span> <span class="keyword1">then</span> <span class="main">(</span><span class="free">x</span><span class="main">::</span>bool<span class="main">)</span> <span class="keyword1">else</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹fold <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">th</span> <span class="main">=&gt;</span> <span class="entity">add_rewrite_rule_cond</span> <span class="entity">th</span> <span class="main">[</span><span class="entity">with_score</span> <span class="inner_numeral">1</span><span class="main">]</span><span class="main">)</span>
  <span class="main">(</span><span class="main">[</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> HOL.if_P<span class="antiquote">}</span></span></span><span class="main">,</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> HOL.if_not_P<span class="antiquote">}</span></span></span><span class="main">,</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> if_eval'<span class="antiquote">}</span></span></span><span class="main">]</span> @ <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> ifb_eval<span class="antiquote">}</span></span></span><span class="main">)</span>›</span>

<span class="comment1">(* THE and ∃! *)</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> theI'<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_term</span> <span class="inner_quoted">"THE x. ?P x"</span><span class="main">]</span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_gen_prfstep</span> <span class="main">(</span><span class="inner_quoted">"ex1_case"</span><span class="main">,</span>
  <span class="main">[</span><span class="entity">WithGoal</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term_pat</span> <span class="quoted">"<span class="main">∃!</span><span class="bound">x</span><span class="main">.</span> <span class="var">?P</span> <span class="bound">x</span>"</span><span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">CreateConcl</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term_pat</span> <span class="quoted">"<span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="var">?P</span> <span class="bound">x</span>"</span><span class="antiquote">}</span></span><span class="main">]</span><span class="main">)</span>›</span>
<span class="keyword1"><span class="command">theorem</span></span> ex_ex1I' <span class="main">[</span><span class="operator">backward1</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">y</span><span class="main">.</span> <span class="free">P</span> <span class="bound">y</span> <span class="main">⟶</span> <span class="free">x</span> <span class="main">=</span> <span class="bound">y</span> <span class="main">⟹</span> <span class="free">P</span> <span class="free">x</span> <span class="main">⟹</span> <span class="main">∃!</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">theorem</span></span> the1_equality'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">a</span> <span class="main">⟹</span> <span class="main">∃!</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span> <span class="main">⟹</span> <span class="main">(</span><span class="keyword1">THE</span> <span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">a</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> the1_equality<span class="main">)</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> the1_equality'<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_term</span> <span class="inner_quoted">"THE x. ?P x"</span><span class="main">]</span>›</span>

<span class="comment1">(* Hilbert choice. *)</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_gen_prfstep</span> <span class="main">(</span><span class="inner_quoted">"SOME_case_intro"</span><span class="main">,</span>
  <span class="main">[</span><span class="entity">WithTerm</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term_pat</span> <span class="quoted">"<span class="keyword1">SOME</span> <span class="bound">k</span><span class="main">.</span> <span class="var">?P</span> <span class="bound">k</span>"</span><span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">CreateConcl</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term_pat</span> <span class="quoted">"<span class="main">∃</span><span class="bound">k</span><span class="main">.</span> <span class="var">?P</span> <span class="bound">k</span>"</span><span class="antiquote">}</span></span><span class="main">]</span><span class="main">)</span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> someI<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_term</span> <span class="inner_quoted">"SOME x. ?P x"</span><span class="main">]</span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> someI_ex<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_term</span> <span class="inner_quoted">"SOME x. ?P x"</span><span class="main">]</span>›</span>

<span class="comment1">(* Axiom of choice *)</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_prfstep_custom</span> <span class="main">(</span><span class="inner_quoted">"ex_choice"</span><span class="main">,</span>
  <span class="main">[</span><span class="entity">WithGoal</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term_pat</span> <span class="quoted">"<span class="keyword1">EX</span> <span class="bound">f</span><span class="main">.</span> <span class="main">!</span><span class="bound">x</span><span class="main">.</span> <span class="var">?Q</span> <span class="bound">f</span> <span class="bound">x</span>"</span><span class="antiquote">}</span></span><span class="main">]</span><span class="main">,</span>
  <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="entity">ths</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">choice</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> choice<span class="antiquote">}</span></span></span> |&gt; <span class="entity">apply_to_thm</span> <span class="main">(</span>Conv.rewr_conv <span class="entity">UtilBase.backward_conv_th</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">[</span><span class="entity">Update.thm_update</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="main">(</span><span class="entity">ths</span> MRS <span class="entity">choice</span><span class="main">)</span><span class="main">)</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword3"><span class="keyword">handle</span></span> THM <span class="main">_</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
›</span>

<span class="comment1">(* Least operator. *)</span>
<span class="keyword1"><span class="command">theorem</span></span> Least_equality' <span class="main">[</span><span class="operator">backward1</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">(</span><span class="free">x</span><span class="main">::</span><span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>order<span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">∀</span><span class="bound">y</span><span class="main">.</span> <span class="free">P</span> <span class="bound">y</span> <span class="main">⟶</span> <span class="free">x</span> <span class="main">≤</span> <span class="bound">y</span> <span class="main">⟹</span> Least <span class="free">P</span> <span class="main">=</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Least_equality<span class="main">)</span>

<span class="comment1">(* Pairs. *)</span>
<span class="keyword1"><span class="command">lemma</span></span> pair_inj<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">b</span><span class="main">)</span> <span class="main">=</span> <span class="free">c</span> <span class="main">⟷</span> <span class="free">a</span> <span class="main">=</span> fst <span class="free">c</span> <span class="main">∧</span> <span class="free">b</span> <span class="main">=</span> snd <span class="free">c</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">Normalizer.add_inj_struct_data</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> pair_inj<span class="antiquote">}</span></span></span>›</span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> fst_conv<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> snd_conv<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep</span> <span class="main">(</span><span class="entity">equiv_forward_th</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> prod.simps<span class="main">(</span>1<span class="main">)</span><span class="antiquote">}</span></span></span><span class="main">)</span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> surjective_pairing<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_cond</span> <span class="inner_quoted">"?t ≠ (?a, ?b)"</span><span class="main">]</span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">Normalizer.add_rewr_normalizer</span> <span class="main">(</span><span class="inner_quoted">"rewr_case"</span><span class="main">,</span> <span class="main">(</span><span class="entity">to_meta_eq</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> case_prod_beta'<span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">)</span>›</span>

<span class="comment1">(* Let. *)</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">Normalizer.add_rewr_normalizer</span> <span class="main">(</span><span class="inner_quoted">"rewr_let"</span><span class="main">,</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Let_def<span class="antiquote">}</span></span></span><span class="main">)</span>›</span>

<span class="comment1">(* Equivalence relations *)</span>  
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Relation.symD<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_backward_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Relation.symI<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Relation.transD<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_backward_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Relation.transI<span class="antiquote">}</span></span></span>›</span>

<span class="comment1">(* Options *)</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_resolve_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> option.distinct<span class="main">(</span>1<span class="main">)</span><span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Option.option.sel<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> option.collapse<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep</span> <span class="main">(</span><span class="entity">equiv_forward_th</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> option.simps<span class="main">(</span>1<span class="main">)</span><span class="antiquote">}</span></span></span><span class="main">)</span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹fold <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">th</span> <span class="main">=&gt;</span> <span class="entity">add_rewrite_rule_cond</span> <span class="entity">th</span> <span class="main">[</span><span class="entity">with_score</span> <span class="inner_numeral">1</span><span class="main">]</span><span class="main">)</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> Option.option.case<span class="antiquote">}</span></span></span>›</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Order_Thms">
<div class="head">
<h1>Theory Order_Thms</h1>
</div>
<pre class="source"><span class="comment1">(*
  File: Order_Thms.thy
  Author: Bohua Zhan

  Setup for proof steps related to ordering.
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Setup for ordering›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Order_Thms
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="Logic_Thms.html">Logic_Thms</a> <a href="../../HOL/HOL/Rat.html">HOL.Rat</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹util_arith.ML›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">Consts.add_const_data</span> <span class="main">(</span><span class="inner_quoted">"NUMC"</span><span class="main">,</span> <span class="entity">UtilArith.is_numc</span><span class="main">)</span>›</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Results in class order or preorder›</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Orderings.order_class.order.trans<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_filt</span> <span class="main">(</span><span class="entity">not_type_filter</span> <span class="inner_quoted">"a"</span> <span class="entity">natT</span><span class="main">)</span><span class="main">]</span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Orderings.order_class.order.strict_trans<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_filt</span> <span class="main">(</span><span class="entity">not_type_filter</span> <span class="inner_quoted">"a"</span> <span class="entity">natT</span><span class="main">)</span><span class="main">]</span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Orderings.order_le_less_trans<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_filt</span> <span class="main">(</span><span class="entity">not_type_filter</span> <span class="inner_quoted">"x"</span> <span class="entity">natT</span><span class="main">)</span><span class="main">]</span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Orderings.order_less_le_trans<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_filt</span> <span class="main">(</span><span class="entity">not_type_filter</span> <span class="inner_quoted">"x"</span> <span class="entity">natT</span><span class="main">)</span><span class="main">]</span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_resolve_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Orderings.order_class.order.irrefl<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Orderings.le_neq_trans<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_cond</span> <span class="inner_quoted">"?a ≠ ?b"</span><span class="main">]</span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Orderings.order_antisym<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_filt</span> <span class="main">(</span><span class="entity">order_filter</span> <span class="inner_quoted">"x"</span> <span class="inner_quoted">"y"</span><span class="main">)</span><span class="main">,</span> <span class="entity">with_cond</span> <span class="inner_quoted">"?x ≠ ?y"</span><span class="main">]</span>›</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Rewriting of negation, in linorder›</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹fold <span class="entity">add_gen_prfstep</span> <span class="main">[</span>
  <span class="main">(</span><span class="inner_quoted">"not_less"</span><span class="main">,</span>
   <span class="main">[</span><span class="entity">WithProp</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term_pat</span> <span class="quoted">"<span class="main">¬</span> <span class="main">(</span><span class="var">?x</span><span class="main">::</span><span class="main">(</span><span class="tvar">?'a</span><span class="main">::</span>linorder<span class="main">)</span><span class="main">)</span> <span class="main">&lt;</span> <span class="var">?y</span>"</span><span class="antiquote">}</span></span><span class="main">,</span>
    <span class="entity">GetFact</span> <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term_pat</span> <span class="quoted">"<span class="var">?y</span> <span class="main">≤</span> <span class="main">(</span><span class="var">?x</span><span class="main">::</span><span class="main">(</span><span class="tvar">?'a</span><span class="main">::</span>linorder<span class="main">)</span><span class="main">)</span>"</span><span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">equiv_forward_th</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> linorder_not_less<span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">,</span>
    <span class="entity">WithScore</span> <span class="inner_numeral">1</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
  <span class="main">(</span><span class="inner_quoted">"not_le"</span><span class="main">,</span>
   <span class="main">[</span><span class="entity">WithProp</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term_pat</span> <span class="quoted">"<span class="main">¬</span> <span class="main">(</span><span class="var">?x</span><span class="main">::</span><span class="main">(</span><span class="tvar">?'a</span><span class="main">::</span>linorder<span class="main">)</span><span class="main">)</span> <span class="main">≤</span> <span class="var">?y</span>"</span><span class="antiquote">}</span></span><span class="main">,</span>
    <span class="entity">GetFact</span> <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term_pat</span> <span class="quoted">"<span class="var">?y</span> <span class="main">&lt;</span> <span class="main">(</span><span class="var">?x</span><span class="main">::</span><span class="main">(</span><span class="tvar">?'a</span><span class="main">::</span>linorder<span class="main">)</span><span class="main">)</span>"</span><span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">equiv_forward_th</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> linorder_not_le<span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">,</span>
    <span class="entity">WithScore</span> <span class="inner_numeral">1</span><span class="main">]</span><span class="main">)</span><span class="main">]</span>
›</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Properties of max and min (in linorder)›</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> min.commute<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> min.idem<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> min.cobounded1<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_term</span> <span class="inner_quoted">"min ?a ?b"</span><span class="main">]</span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> min.cobounded2<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_term</span> <span class="inner_quoted">"min ?a ?b"</span><span class="main">]</span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_backward2_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> min.boundedI<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_backward2_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> min.mono<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> min.absorb1<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> min.absorb2<span class="antiquote">}</span></span></span>›</span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> max.commute<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> max.idem<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> max.cobounded1<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_term</span> <span class="inner_quoted">"max ?a ?b"</span><span class="main">]</span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> max.cobounded2<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_term</span> <span class="inner_quoted">"max ?a ?b"</span><span class="main">]</span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_backward2_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> max.boundedI<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_backward2_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> max.mono<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> max.absorb1<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> max.absorb2<span class="antiquote">}</span></span></span>›</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Min›</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_backward_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Min_in<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_backward_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Min_le<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_backward2_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Min_eqI<span class="antiquote">}</span></span></span>›</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Existence of numbers satisfying inequalities›</span></span>

<span class="keyword1"><span class="command">theorem</span></span> exists_ge <span class="main">[</span><span class="operator">resolve</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">k</span><span class="main">.</span> <span class="bound">k</span> <span class="main">≥</span> <span class="main">(</span><span class="free">i</span><span class="main">::</span><span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>order<span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹fold <span class="entity">add_resolve_prfstep</span> <span class="main">[</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> lt_ex<span class="antiquote">}</span></span></span><span class="main">,</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> gt_ex<span class="antiquote">}</span></span></span><span class="main">]</span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_backward_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> dense<span class="antiquote">}</span></span></span>›</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="files/util_arith.ML">
<div class="head">
<h1>File ‹util_arith.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*
  File: util_arith.ML
  Author: Bohua Zhan

  Utility functions related to arithmetic.
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">UTIL_ARITH</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="comment1">(* Types. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> natT<span class="main">:</span> typ
  <span class="keyword1"><span class="keyword">val</span></span> intT<span class="main">:</span> typ
  <span class="keyword1"><span class="keyword">val</span></span> ratT<span class="main">:</span> typ
  <span class="keyword1"><span class="keyword">val</span></span> rat_zero<span class="main">:</span> Rat.rat

  <span class="comment1">(* Terms. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> is_numc<span class="main">:</span> term <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> dest_numc<span class="main">:</span> term <span class="main">-&gt;</span> int
  <span class="keyword1"><span class="keyword">val</span></span> dest_numc_rat<span class="main">:</span> term <span class="main">-&gt;</span> Rat.rat
  <span class="keyword1"><span class="keyword">val</span></span> is_order<span class="main">:</span> term <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> is_linorder<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> is_plus<span class="main">:</span> term <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> is_minus<span class="main">:</span> term <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> is_times<span class="main">:</span> term <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> is_divide<span class="main">:</span> term <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> is_zero<span class="main">:</span> term <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> is_one<span class="main">:</span> term <span class="main">-&gt;</span> bool

  <span class="comment1">(* Theorems. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> neg_ineq_cv<span class="main">:</span> conv
  <span class="keyword1"><span class="keyword">val</span></span> neg_ineq_back_cv<span class="main">:</span> conv

  <span class="comment1">(* Arith tactic. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> prove_by_arith<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> term <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> contra_by_arith<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> thm
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">UtilArith</span> <span class="main">:</span> <span class="entity">UTIL_ARITH</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">natT</span> <span class="main">=</span> <span class="entity">HOLogic.natT</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">intT</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">int</span><span class="antiquote">}</span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ratT</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">rat</span><span class="antiquote">}</span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rat_zero</span> <span class="main">=</span> Rat.of_int <span class="inner_numeral">0</span>

<span class="comment1">(* Test if a term represents a numerical constant. In addition to use
   dest_number from HOLogic, test for inverse, uminus, of_rat, etc.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_numc</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
        Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> inverse<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="entity">t'</span> <span class="main">=&gt;</span> <span class="entity">is_numc</span> <span class="entity">t'</span>
      <span class="main">|</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> uminus<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="entity">t'</span> <span class="main">=&gt;</span> <span class="entity">is_numc</span> <span class="entity">t'</span>
      <span class="main">|</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> of_rat<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="entity">r</span> <span class="main">=&gt;</span> <span class="entity">is_numc</span> <span class="entity">r</span>
      <span class="main">|</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Fract<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="entity">n</span> $ <span class="entity">d</span> <span class="main">=&gt;</span> <span class="entity">is_numc</span> <span class="entity">n</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_numc</span> <span class="entity">d</span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">HOLogic.dest_number</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">in</span></span> true <span class="keyword2"><span class="keyword">end</span></span>
             <span class="keyword3"><span class="keyword">handle</span></span> TERM <span class="main">(</span><span class="inner_quoted">"dest_number"</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> false

<span class="comment1">(* Deconstruct numerical constant. Discard type. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_numc</span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">HOLogic.dest_number</span> <span class="entity">t</span> |&gt; snd
                  <span class="keyword3"><span class="keyword">handle</span></span> TERM <span class="main">(</span><span class="inner_quoted">"dest_number"</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"dest_numc"</span>

<span class="comment1">(* Rational numbers version of dest_numc. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_numc_rat</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
        Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> inverse<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="entity">t'</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">r'</span> <span class="main">=</span> <span class="entity">dest_numc_rat</span> <span class="entity">t'</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">r'</span> <span class="main">=</span> <span class="entity">rat_zero</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">rat_zero</span>
          <span class="keyword2"><span class="keyword">else</span></span> Rat.inv <span class="entity">r'</span>
        <span class="keyword2"><span class="keyword">end</span></span>
      <span class="main">|</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> uminus<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="entity">t'</span> <span class="main">=&gt;</span> Rat.neg <span class="main">(</span><span class="entity">dest_numc_rat</span> <span class="entity">t'</span><span class="main">)</span>
      <span class="main">|</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> of_rat<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="entity">r</span> <span class="main">=&gt;</span> <span class="entity">dest_numc_rat</span> <span class="entity">r</span>
      <span class="main">|</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Fract<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="entity">n</span> $ <span class="entity">d</span> <span class="main">=&gt;</span>
        Rat.make <span class="main">(</span><span class="entity">dest_numc</span> <span class="entity">n</span><span class="main">,</span> <span class="entity">dest_numc</span> <span class="entity">d</span><span class="main">)</span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> Rat.of_int <span class="main">(</span><span class="entity">dest_numc</span> <span class="entity">t</span><span class="main">)</span>

<span class="comment1">(* Whether the given term is a &lt; b or a &lt;= b. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_order</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span>fastype_of <span class="entity">t</span> <span class="main">=</span> <span class="entity">boolT</span><span class="main">)</span> <span class="inner_quoted">"is_order: wrong type"</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> less<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="main">_</span> $ <span class="main">_</span> <span class="main">=&gt;</span> true
              <span class="main">|</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> less_eq<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="main">_</span> $ <span class="main">_</span> <span class="main">=&gt;</span> true
              <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_linorder</span> <span class="entity">ctxt</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">T</span> <span class="main">=</span> fastype_of <span class="main">(</span><span class="entity">dest_arg</span> <span class="entity">t</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">is_order</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">andalso</span></span> Sign.of_sort <span class="entity">thy</span> <span class="main">(</span><span class="entity">T</span><span class="main">,</span> <span class="main">[</span><span class="inner_quoted">"Orderings.linorder"</span><span class="main">]</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Check whether t is in the form a + b. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_plus</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
        Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> plus<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="main">_</span> $ <span class="main">_</span> <span class="main">=&gt;</span> true
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false

<span class="comment1">(* Check whether t is in the form a - b. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_minus</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
        Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> minus<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="main">_</span> $ <span class="main">_</span> <span class="main">=&gt;</span> true
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_times</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
        Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> times<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="main">_</span> $ <span class="main">_</span> <span class="main">=&gt;</span> true
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_divide</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
        Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> divide<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="main">_</span> $ <span class="main">_</span> <span class="main">=&gt;</span> true
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_zero</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
        Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> zero_class.zero<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> true
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_one</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
        Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> one_class.one<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> true
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false

<span class="comment1">(* Convert ~ x &lt; y to y &lt;= x, and ~ x &lt;= y to y &lt; x. *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">neg_ineq_cv</span> <span class="main">=</span>
    <span class="main">(</span>Conv.try_conv o Conv.first_conv<span class="main">)</span>
        <span class="main">(</span>map <span class="entity">rewr_obj_eq</span> <span class="main">[</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Orderings.linorder_not_less<span class="antiquote">}</span></span></span><span class="main">,</span>
                          <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Orderings.linorder_not_le<span class="antiquote">}</span></span></span><span class="main">]</span><span class="main">)</span>

<span class="comment1">(* Convert x &lt; y to ~ y &lt;= x, and x &lt;= y to ~ y &lt; x. *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">neg_ineq_back_cv</span> <span class="main">=</span>
    <span class="main">(</span>Conv.try_conv o Conv.first_conv<span class="main">)</span>
        <span class="main">(</span>map <span class="main">(</span><span class="entity">rewr_obj_eq</span> o <span class="entity">obj_sym</span><span class="main">)</span> <span class="main">[</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Orderings.linorder_not_less<span class="antiquote">}</span></span></span><span class="main">,</span>
                                      <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Orderings.linorder_not_le<span class="antiquote">}</span></span></span><span class="main">]</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prove_by_arith</span> <span class="main">=</span> <span class="entity">UtilLogic.prove_by_tac</span> <span class="entity">Arith_Data.arith_tac</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">contra_by_arith</span> <span class="main">=</span> <span class="entity">UtilLogic.contra_by_tac</span> <span class="entity">Arith_Data.arith_tac</span>

<span class="keyword2"><span class="keyword">end</span></span>  <span class="comment1">(* structure UtilArith *)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">natT</span> <span class="main">=</span> <span class="entity">UtilArith.natT</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">intT</span> <span class="main">=</span> <span class="entity">UtilArith.intT</span>
</pre>
</div><div id="Arith_Thms">
<div class="head">
<h1>Theory Arith_Thms</h1>
</div>
<pre class="source"><span class="comment1">(*
  File: Arith_Thms.thy
  Author: Bohua Zhan

  Setup for proof steps related to arithmetic, mostly on natural numbers.
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Setup for arithmetic›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Arith_Thms
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="Order_Thms.html">Order_Thms</a> <a href="../../HOL/HOL/Binomial.html">HOL.Binomial</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(* Reducing inequality on natural numbers. *)</span>
<span class="keyword1"><span class="command">theorem</span></span> reduce_le_plus_consts<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">+</span> <span class="free">n1</span> <span class="main">≤</span> <span class="free">y</span> <span class="main">+</span> <span class="free">n2</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">≤</span> <span class="free">y</span> <span class="main">+</span> <span class="main">(</span><span class="free">n2</span><span class="main">-</span><span class="free">n1</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">theorem</span></span> reduce_le_plus_consts'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">n1</span> <span class="main">≥</span> <span class="free">n2</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">x</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">+</span> <span class="free">n1</span> <span class="main">≤</span> <span class="free">y</span> <span class="main">+</span> <span class="free">n2</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">+</span> <span class="main">(</span><span class="free">n1</span><span class="main">-</span><span class="free">n2</span><span class="main">)</span> <span class="main">≤</span> <span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">theorem</span></span> reduce_less_plus_consts<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">+</span> <span class="free">n1</span> <span class="main">&lt;</span> <span class="free">y</span> <span class="main">+</span> <span class="free">n2</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">&lt;</span> <span class="free">y</span> <span class="main">+</span> <span class="main">(</span><span class="free">n2</span><span class="main">-</span><span class="free">n1</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">theorem</span></span> reduce_less_plus_consts'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">n1</span> <span class="main">≥</span> <span class="free">n2</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">x</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">+</span> <span class="free">n1</span> <span class="main">&lt;</span> <span class="free">y</span> <span class="main">+</span> <span class="free">n2</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">+</span> <span class="main">(</span><span class="free">n1</span><span class="main">-</span><span class="free">n2</span><span class="main">)</span> <span class="main">&lt;</span> <span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="comment1">(* To normal form. *)</span>
<span class="keyword1"><span class="command">theorem</span></span> norm_less_lminus<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">-</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="free">y</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">≤</span> <span class="free">y</span> <span class="main">+</span> <span class="main">(</span><span class="free">n</span><span class="main">-</span><span class="main">1</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">theorem</span></span> norm_less_lplus<span class="main">:</span>  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">+</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="free">y</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">+</span> <span class="main">(</span><span class="free">n</span><span class="main">+</span><span class="main">1</span><span class="main">)</span> <span class="main">≤</span> <span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">theorem</span></span> norm_less_rminus<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">&lt;</span> <span class="free">y</span> <span class="main">-</span> <span class="free">n</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">+</span> <span class="main">(</span><span class="free">n</span><span class="main">+</span><span class="main">1</span><span class="main">)</span> <span class="main">≤</span> <span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">theorem</span></span> norm_less_rplus<span class="main">:</span>  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">&lt;</span> <span class="free">y</span> <span class="main">+</span> <span class="free">n</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">≤</span> <span class="free">y</span> <span class="main">+</span> <span class="main">(</span><span class="free">n</span><span class="main">-</span><span class="main">1</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">theorem</span></span> norm_less<span class="main">:</span>        <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">&lt;</span> <span class="free">y</span>     <span class="main">⟹</span> <span class="free">x</span> <span class="main">+</span> <span class="main">1</span> <span class="main">≤</span> <span class="free">y</span>"</span></span>     <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">theorem</span></span> norm_le_lminus<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">-</span> <span class="free">n</span> <span class="main">≤</span> <span class="free">y</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">≤</span> <span class="free">y</span> <span class="main">+</span> <span class="free">n</span>"</span></span>  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">theorem</span></span> norm_le_rminus<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">≤</span> <span class="free">y</span> <span class="main">-</span> <span class="free">n</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">≤</span> <span class="free">y</span> <span class="main">+</span> <span class="main">0</span>"</span></span>  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">theorem</span></span> norm_le<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">≤</span> <span class="free">y</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">≤</span> <span class="free">y</span> <span class="main">+</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">theorem</span></span> norm_le_lplus0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">+</span> <span class="main">0</span> <span class="main">≤</span> <span class="free">y</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">≤</span> <span class="free">y</span> <span class="main">+</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="comment1">(* Transitive resolve. *)</span>
<span class="keyword1"><span class="command">theorem</span></span> trans_resolve1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">n1</span> <span class="main">&gt;</span> <span class="main">0</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">x</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">+</span> <span class="free">n1</span> <span class="main">≤</span> <span class="free">y</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">y</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">+</span> <span class="free">n2</span> <span class="main">≤</span> <span class="free">x</span> <span class="main">⟹</span> False"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">theorem</span></span> trans_resolve2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">n1</span> <span class="main">&gt;</span> <span class="free">n2</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">x</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">+</span> <span class="free">n1</span> <span class="main">≤</span> <span class="free">y</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">y</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">≤</span> <span class="free">x</span> <span class="main">+</span> <span class="free">n2</span> <span class="main">⟹</span> False"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="comment1">(* Transitive. *)</span>
<span class="keyword1"><span class="command">theorem</span></span> trans1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">+</span> <span class="free">n1</span> <span class="main">≤</span> <span class="free">y</span> <span class="main">⟹</span> <span class="free">y</span> <span class="main">+</span> <span class="free">n2</span> <span class="main">≤</span> <span class="free">z</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">+</span> <span class="main">(</span><span class="free">n1</span><span class="main">+</span><span class="free">n2</span><span class="main">)</span> <span class="main">≤</span> <span class="free">z</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">theorem</span></span> trans2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">≤</span> <span class="free">y</span> <span class="main">+</span> <span class="free">n1</span> <span class="main">⟹</span> <span class="free">y</span> <span class="main">≤</span> <span class="free">z</span> <span class="main">+</span> <span class="free">n2</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">≤</span> <span class="free">z</span> <span class="main">+</span> <span class="main">(</span><span class="free">n1</span><span class="main">+</span><span class="free">n2</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">theorem</span></span> trans3<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">+</span> <span class="free">n1</span> <span class="main">≤</span> <span class="free">y</span> <span class="main">⟹</span> <span class="free">y</span> <span class="main">≤</span> <span class="free">z</span> <span class="main">+</span> <span class="free">n2</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">≤</span> <span class="free">z</span> <span class="main">+</span> <span class="main">(</span><span class="free">n2</span><span class="main">-</span><span class="free">n1</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">theorem</span></span> trans4<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">n1</span> <span class="main">&gt;</span> <span class="free">n2</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">x</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">+</span> <span class="free">n1</span> <span class="main">≤</span> <span class="free">y</span> <span class="main">⟹</span> <span class="free">y</span> <span class="main">≤</span> <span class="free">z</span> <span class="main">+</span> <span class="free">n2</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">+</span> <span class="main">(</span><span class="free">n1</span><span class="main">-</span><span class="free">n2</span><span class="main">)</span> <span class="main">≤</span> <span class="free">z</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">theorem</span></span> trans5<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">≤</span> <span class="free">y</span> <span class="main">+</span> <span class="free">n1</span> <span class="main">⟹</span> <span class="free">y</span> <span class="main">+</span> <span class="free">n2</span> <span class="main">≤</span> <span class="free">z</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">≤</span> <span class="free">z</span> <span class="main">+</span> <span class="main">(</span><span class="free">n1</span><span class="main">-</span><span class="free">n2</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">theorem</span></span> trans6<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">n2</span> <span class="main">&gt;</span> <span class="free">n1</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">x</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">≤</span> <span class="free">y</span> <span class="main">+</span> <span class="free">n1</span> <span class="main">⟹</span> <span class="free">y</span> <span class="main">+</span> <span class="free">n2</span> <span class="main">≤</span> <span class="free">z</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">+</span> <span class="main">(</span><span class="free">n2</span><span class="main">-</span><span class="free">n1</span><span class="main">)</span> <span class="main">≤</span> <span class="free">z</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="comment1">(* Resolve. *)</span>
<span class="keyword1"><span class="command">theorem</span></span> single_resolve<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">&gt;</span> <span class="main">0</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">x</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">+</span> <span class="free">n</span> <span class="main">≤</span> <span class="free">x</span> <span class="main">⟹</span> False"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">theorem</span></span> single_resolve_const<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">&gt;</span> <span class="main">0</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">x</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">+</span> <span class="free">n</span> <span class="main">≤</span> <span class="main">0</span> <span class="main">⟹</span> False"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="comment1">(* Comparison with constants. *)</span>
<span class="keyword1"><span class="command">theorem</span></span> cv_const1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">+</span> <span class="free">n</span> <span class="main">≤</span> <span class="free">y</span> <span class="main">⟹</span> <span class="main">0</span> <span class="main">+</span> <span class="main">(</span><span class="free">x</span><span class="main">+</span><span class="free">n</span><span class="main">)</span> <span class="main">≤</span> <span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>  <span class="comment1">(* x is const *)</span>
<span class="keyword1"><span class="command">theorem</span></span> cv_const2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">+</span> <span class="free">n</span> <span class="main">≤</span> <span class="free">y</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">≤</span> <span class="main">0</span> <span class="main">+</span> <span class="main">(</span><span class="free">y</span><span class="main">-</span><span class="free">n</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>  <span class="comment1">(* y is const *)</span>
<span class="keyword1"><span class="command">theorem</span></span> cv_const3<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">&lt;</span> <span class="free">n</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">x</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">+</span> <span class="free">n</span> <span class="main">≤</span> <span class="free">y</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">+</span> <span class="main">(</span><span class="free">n</span><span class="main">-</span><span class="free">y</span><span class="main">)</span> <span class="main">≤</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>  <span class="comment1">(* y is const (contradiction with 0 ≤ x) *)</span>
<span class="keyword1"><span class="command">theorem</span></span> cv_const4<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">≤</span> <span class="free">y</span> <span class="main">+</span> <span class="free">n</span> <span class="main">⟹</span> <span class="main">0</span> <span class="main">+</span> <span class="main">(</span><span class="free">x</span><span class="main">-</span><span class="free">n</span><span class="main">)</span> <span class="main">≤</span> <span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>  <span class="comment1">(* x is const *)</span>
<span class="keyword1"><span class="command">theorem</span></span> cv_const5<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">≤</span> <span class="free">y</span> <span class="main">+</span> <span class="free">n</span> <span class="main">⟹</span> <span class="main">0</span> <span class="main">≤</span> <span class="free">y</span> <span class="main">+</span> <span class="main">(</span><span class="free">n</span><span class="main">-</span><span class="free">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>  <span class="comment1">(* x is const (trivial) *)</span>
<span class="keyword1"><span class="command">theorem</span></span> cv_const6<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">≤</span> <span class="free">y</span> <span class="main">+</span> <span class="free">n</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">≤</span> <span class="main">0</span> <span class="main">+</span> <span class="main">(</span><span class="free">y</span><span class="main">+</span><span class="free">n</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>  <span class="comment1">(* y is const *)</span>

<span class="comment1">(* Misc *)</span>
<span class="keyword1"><span class="command">theorem</span></span> nat_eq_to_ineqs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">=</span> <span class="free">y</span> <span class="main">+</span> <span class="free">n</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">≤</span> <span class="free">y</span> <span class="main">+</span> <span class="free">n</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">≥</span> <span class="free">y</span> <span class="main">+</span> <span class="free">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">theorem</span></span> nat_ineq_impl_not_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">+</span> <span class="free">n</span> <span class="main">≤</span> <span class="free">y</span> <span class="main">⟹</span> <span class="free">n</span> <span class="main">&gt;</span> <span class="main">0</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">≠</span> <span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">theorem</span></span> eq_to_ineqs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">≡</span> <span class="free">y</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">≤</span> <span class="free">y</span> <span class="main">∧</span> <span class="free">y</span> <span class="main">≤</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">theorem</span></span> ineq_to_eqs1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">≤</span> <span class="free">y</span> <span class="main">+</span> <span class="main">0</span> <span class="main">⟹</span> <span class="free">y</span> <span class="main">≤</span> <span class="free">x</span> <span class="main">+</span> <span class="main">0</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹arith.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹order.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹order_test.ML›</span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">register_wellform_data</span> <span class="main">(</span><span class="inner_quoted">"(a::nat) - b"</span><span class="main">,</span> <span class="main">[</span><span class="inner_quoted">"a ≥ b"</span><span class="main">]</span><span class="main">)</span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_prfstep_check_req</span> <span class="main">(</span><span class="inner_quoted">"(a::nat) - b"</span><span class="main">,</span> <span class="inner_quoted">"(a::nat) ≥ b"</span><span class="main">)</span>›</span>

<span class="comment1">(* Normalize any expression to "a - b" form. *)</span>
<span class="keyword1"><span class="command">lemma</span></span> nat_sub_norm<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">=</span> <span class="free">a</span> <span class="main">-</span> <span class="main">0</span> <span class="main">∧</span> <span class="free">a</span> <span class="main">≥</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="comment1">(* Adding and subtracting two normalized expressions. *)</span>
<span class="keyword1"><span class="command">lemma</span></span> nat_sub1<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">≥</span> <span class="free">b</span> <span class="main">⟹</span> <span class="free">c</span> <span class="main">≥</span> <span class="free">d</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">a</span> <span class="main">-</span> <span class="free">b</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="free">c</span> <span class="main">-</span> <span class="free">d</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">a</span> <span class="main">+</span> <span class="free">c</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span><span class="free">b</span> <span class="main">+</span> <span class="free">d</span><span class="main">)</span> <span class="main">∧</span> <span class="free">a</span> <span class="main">+</span> <span class="free">c</span> <span class="main">≥</span> <span class="free">b</span> <span class="main">+</span> <span class="free">d</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> nat_sub2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">≥</span> <span class="free">b</span> <span class="main">⟹</span> <span class="free">c</span> <span class="main">≥</span> <span class="free">d</span> <span class="main">⟹</span> <span class="free">a</span> <span class="main">-</span> <span class="free">b</span> <span class="main">≥</span> <span class="free">c</span> <span class="main">-</span> <span class="free">d</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">a</span> <span class="main">-</span> <span class="free">b</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span><span class="free">c</span> <span class="main">-</span> <span class="free">d</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">a</span> <span class="main">+</span> <span class="free">d</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span><span class="free">b</span> <span class="main">+</span> <span class="free">c</span><span class="main">)</span> <span class="main">∧</span> <span class="free">a</span> <span class="main">+</span> <span class="free">d</span> <span class="main">≥</span> <span class="free">b</span> <span class="main">+</span> <span class="free">c</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> nat_sub3<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">≥</span> <span class="free">b</span> <span class="main">⟹</span> <span class="free">c</span> <span class="main">≥</span> <span class="free">d</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">a</span> <span class="main">-</span> <span class="free">b</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span><span class="free">c</span> <span class="main">-</span> <span class="free">d</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">a</span> <span class="main">*</span> <span class="free">c</span> <span class="main">+</span> <span class="free">b</span> <span class="main">*</span> <span class="free">d</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span><span class="free">a</span> <span class="main">*</span> <span class="free">d</span> <span class="main">+</span> <span class="free">b</span> <span class="main">*</span> <span class="free">c</span><span class="main">)</span> <span class="main">∧</span> <span class="free">a</span> <span class="main">*</span> <span class="free">c</span> <span class="main">+</span> <span class="free">b</span> <span class="main">*</span> <span class="free">d</span> <span class="main">≥</span> <span class="free">a</span> <span class="main">*</span> <span class="free">d</span> <span class="main">+</span> <span class="free">b</span> <span class="main">*</span> <span class="free">c</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> diff_mult_distrib mult.commute mult_le_mono1 nat_sub2<span class="main">)</span>

<span class="comment1">(* Cancel identical terms on two sides, yielding a normalized expression. *)</span>
<span class="keyword1"><span class="command">lemma</span></span> nat_sub_combine<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">+</span> <span class="free">b</span> <span class="main">≥</span> <span class="free">c</span> <span class="main">+</span> <span class="free">b</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">a</span> <span class="main">+</span> <span class="free">b</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span><span class="free">c</span> <span class="main">+</span> <span class="free">b</span><span class="main">)</span> <span class="main">=</span> <span class="free">a</span> <span class="main">-</span> <span class="free">c</span> <span class="main">∧</span> <span class="free">a</span> <span class="main">≥</span> <span class="free">c</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> nat_sub_combine2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">≥</span> <span class="free">m</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">a</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">+</span> <span class="free">b</span> <span class="main">*</span> <span class="free">n</span> <span class="main">≥</span> <span class="free">c</span> <span class="main">+</span> <span class="free">b</span> <span class="main">*</span> <span class="free">m</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">a</span> <span class="main">+</span> <span class="free">b</span> <span class="main">*</span> <span class="free">n</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span><span class="free">c</span> <span class="main">+</span> <span class="free">b</span> <span class="main">*</span> <span class="free">m</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">a</span> <span class="main">+</span> <span class="free">b</span> <span class="main">*</span> <span class="main">(</span><span class="free">n</span> <span class="main">-</span> <span class="free">m</span><span class="main">)</span><span class="main">)</span> <span class="main">-</span> <span class="free">c</span> <span class="main">∧</span> <span class="free">a</span> <span class="main">+</span> <span class="free">b</span> <span class="main">*</span> <span class="main">(</span><span class="free">n</span> <span class="main">-</span> <span class="free">m</span><span class="main">)</span> <span class="main">≥</span> <span class="free">c</span> <span class="main">∧</span> <span class="free">n</span> <span class="main">≥</span> <span class="free">m</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> add.commute right_diff_distrib'<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> nat_sub_combine3<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">≤</span> <span class="free">m</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">a</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">+</span> <span class="free">b</span> <span class="main">*</span> <span class="free">n</span> <span class="main">≥</span> <span class="free">c</span> <span class="main">+</span> <span class="free">b</span> <span class="main">*</span> <span class="free">m</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">a</span> <span class="main">+</span> <span class="free">b</span> <span class="main">*</span> <span class="free">n</span><span class="main">)</span> <span class="main">-</span> <span class="main">(</span><span class="free">c</span> <span class="main">+</span> <span class="free">b</span> <span class="main">*</span> <span class="free">m</span><span class="main">)</span> <span class="main">=</span> <span class="free">a</span> <span class="main">-</span> <span class="main">(</span><span class="free">c</span> <span class="main">+</span> <span class="free">b</span> <span class="main">*</span> <span class="main">(</span><span class="free">m</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> <span class="free">a</span> <span class="main">≥</span> <span class="free">c</span> <span class="main">+</span> <span class="free">b</span> <span class="main">*</span> <span class="main">(</span><span class="free">m</span> <span class="main">-</span> <span class="free">n</span><span class="main">)</span> <span class="main">∧</span> <span class="free">m</span> <span class="main">≥</span> <span class="free">n</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> add.commute mult.commute nat_diff_add_eq2 nat_le_add_iff1<span class="main">)</span>

<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹nat_sub.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹nat_sub_test.ML›</span>

<span class="comment1">(* Ordering on Nats. *)</span>
<span class="keyword1"><span class="command">lemma</span></span> le_neq_implies_less' <span class="main">[</span><span class="operator">forward</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">m</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">≠</span> <span class="free">n</span> <span class="main">⟹</span> <span class="free">m</span> <span class="main">≤</span> <span class="free">n</span> <span class="main">⟹</span> <span class="free">m</span> <span class="main">&lt;</span> <span class="free">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">lemma</span></span> le_zero_to_equal_zero <span class="main">[</span><span class="operator">forward</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">n</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">≤</span> <span class="main">0</span> <span class="main">⟹</span> <span class="free">n</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">lemma</span></span> less_one_to_equal_zero <span class="main">[</span><span class="operator">forward</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">n</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">&lt;</span> <span class="main">1</span> <span class="main">⟹</span> <span class="free">n</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_backward_prfstep_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Nat.mult_le_mono1<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_cond</span> <span class="inner_quoted">"?k ≠ 1"</span><span class="main">]</span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_resolve_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Nat.not_add_less1<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">lemma</span></span> not_minus_less <span class="main">[</span><span class="operator">resolve</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="main">(</span><span class="free">i</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">&lt;</span> <span class="main">(</span><span class="free">i</span> <span class="main">-</span> <span class="free">j</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">lemma</span></span> nat_le_prod_with_same <span class="main">[</span><span class="operator">backward</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">n</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">≤</span> <span class="free">m</span> <span class="main">*</span> <span class="free">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">lemma</span></span> nat_le_prod_with_le <span class="main">[</span><span class="operator">backward1</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">n</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">≤</span> <span class="free">m</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">n</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">≤</span> <span class="free">k</span> <span class="main">*</span> <span class="free">m</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> le_trans nat_le_prod_with_same <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">lemma</span></span> nat_plus_le_to_less <span class="main">[</span><span class="operator">backward1</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">a</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">+</span> <span class="free">b</span> <span class="main">≤</span> <span class="free">c</span> <span class="main">⟹</span> <span class="free">a</span> <span class="main">&lt;</span> <span class="free">c</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">lemma</span></span> nat_plus_le_to_less2 <span class="main">[</span><span class="operator">backward1</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">a</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">+</span> <span class="free">b</span> <span class="main">≤</span> <span class="free">c</span> <span class="main">⟹</span> <span class="free">b</span> <span class="main">&lt;</span> <span class="free">c</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> add_right_imp_eq<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> add_left_imp_eq<span class="antiquote">}</span></span></span>›</span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Nat.le_diff_conv2<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_term</span> <span class="inner_quoted">"?i + ?k"</span><span class="main">]</span>›</span>
<span class="keyword1"><span class="command">lemma</span></span> nat_less_diff_conv<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">i</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">&lt;</span> <span class="free">j</span> <span class="main">-</span> <span class="free">k</span> <span class="main">⟹</span> <span class="free">i</span> <span class="main">+</span> <span class="free">k</span> <span class="main">&lt;</span> <span class="free">j</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> nat_less_diff_conv<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_cond</span> <span class="inner_quoted">"?k ≠ ?NUMC"</span><span class="main">,</span> <span class="entity">with_term</span> <span class="inner_quoted">"?i + ?k"</span><span class="main">]</span>›</span>
<span class="keyword1"><span class="command">lemma</span></span> Nat_le_diff_conv2_same <span class="main">[</span><span class="operator">forward</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">≥</span> <span class="free">j</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">i</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">≤</span> <span class="free">i</span> <span class="main">-</span> <span class="free">j</span> <span class="main">⟹</span> <span class="free">j</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">lemma</span></span> nat_gt_zero <span class="main">[</span><span class="operator">forward</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">-</span> <span class="free">a</span> <span class="main">&gt;</span> <span class="main">0</span> <span class="main">⟹</span> <span class="free">b</span> <span class="main">&gt;</span> <span class="main">(</span><span class="free">a</span><span class="main">::</span>nat<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">lemma</span></span> n_minus_1_less_n<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">n</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">≥</span> <span class="main">1</span> <span class="main">⟹</span> <span class="free">n</span> <span class="main">-</span> <span class="main">1</span> <span class="main">&lt;</span> <span class="free">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> n_minus_1_less_n<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_term</span> <span class="inner_quoted">"?n - 1"</span><span class="main">]</span>›</span>

<span class="comment1">(* Monotonicity of ordering *)</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_backward_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Nat.diff_le_mono<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_backward2_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Nat.diff_less_mono<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_backward_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Nat.mult_le_mono2<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_resolve_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Nat.le_add1<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_resolve_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Nat.le_add2<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_backward_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> add_left_mono<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_backward_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> add_right_mono<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">lemma</span></span> add_mono_neutr <span class="main">[</span><span class="operator">backward</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">0</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>linordered_ring<span class="main">)</span> <span class="main">≤</span> <span class="free">b</span> <span class="main">⟹</span> <span class="free">a</span> <span class="main">≤</span> <span class="free">a</span> <span class="main">+</span> <span class="free">b</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">lemma</span></span> add_mono_neutl <span class="main">[</span><span class="operator">backward</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">0</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>linordered_ring<span class="main">)</span> <span class="main">≤</span> <span class="free">b</span> <span class="main">⟹</span> <span class="free">a</span> <span class="main">≤</span> <span class="free">b</span> <span class="main">+</span> <span class="free">a</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> add_less_imp_less_left<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">lemma</span></span> sum_le_zero1 <span class="main">[</span><span class="operator">forward</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>linordered_ring<span class="main">)</span> <span class="main">+</span> <span class="free">b</span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">⟹</span> <span class="free">a</span> <span class="main">≥</span> <span class="main">0</span> <span class="main">⟹</span> <span class="free">b</span> <span class="main">&lt;</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> add_less_same_cancel1 less_le_trans<span class="main">)</span>
<span class="keyword1"><span class="command">lemma</span></span> less_sum1 <span class="main">[</span><span class="operator">backward</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">&gt;</span> <span class="main">0</span> <span class="main">⟹</span> <span class="free">a</span> <span class="main">&lt;</span> <span class="free">a</span> <span class="main">+</span> <span class="main">(</span><span class="free">b</span><span class="main">::</span>nat<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_backward_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Nat.trans_less_add2<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_backward_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Nat.add_less_mono1<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_backward1_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Nat.add_less_mono<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_backward1_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Nat.add_le_mono<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_backward1_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> add_increasing2<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_backward1_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> add_mono<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_backward_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> add_strict_left_mono<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_backward1_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Nat.mult_le_mono<span class="antiquote">}</span></span></span>›</span>

<span class="comment1">(* Addition. *)</span>
<span class="keyword1"><span class="command">theorem</span></span> nat_add_eq_self_zero <span class="main">[</span><span class="operator">forward</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">m</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">=</span> <span class="free">m</span> <span class="main">+</span> <span class="free">n</span> <span class="main">⟹</span> <span class="free">n</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">theorem</span></span> nat_add_eq_self_zero' <span class="main">[</span><span class="operator">forward</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">m</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">=</span> <span class="free">n</span> <span class="main">+</span> <span class="free">m</span> <span class="main">⟹</span> <span class="free">n</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">theorem</span></span> nat_mult_2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">+</span> <span class="free">a</span> <span class="main">=</span> <span class="numeral">2</span> <span class="main">*</span> <span class="free">a</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> nat_mult_2<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_cond</span> <span class="inner_quoted">"?a ≠ 0"</span><span class="main">]</span>›</span>
<span class="keyword1"><span class="command">theorem</span></span> plus_one_non_zero <span class="main">[</span><span class="operator">resolve</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="main">(</span><span class="free">n</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">+</span> <span class="main">1</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="comment1">(* Diff. *)</span>
<span class="keyword1"><span class="command">lemma</span></span> nat_same_minus_ge <span class="main">[</span><span class="operator">forward</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">c</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">-</span> <span class="free">a</span> <span class="main">≥</span> <span class="free">c</span> <span class="main">-</span> <span class="free">b</span> <span class="main">⟹</span> <span class="free">a</span> <span class="main">≤</span> <span class="free">c</span> <span class="main">⟹</span> <span class="free">a</span> <span class="main">≤</span> <span class="free">b</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">arith</span>
<span class="keyword1"><span class="command">lemma</span></span> diff_eq_zero <span class="main">[</span><span class="operator">forward</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">k</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">≤</span> <span class="free">j</span> <span class="main">⟹</span> <span class="free">j</span> <span class="main">-</span> <span class="free">k</span> <span class="main">=</span> <span class="main">0</span> <span class="main">⟹</span> <span class="free">j</span> <span class="main">=</span> <span class="free">k</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">lemma</span></span> diff_eq_zero' <span class="main">[</span><span class="operator">forward</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">k</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">≤</span> <span class="free">j</span> <span class="main">⟹</span> <span class="free">j</span> <span class="main">-</span> <span class="free">k</span> <span class="main">+</span> <span class="free">i</span> <span class="main">=</span> <span class="free">j</span> <span class="main">⟹</span> <span class="free">k</span> <span class="main">=</span> <span class="free">i</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="comment1">(* Divides. *)</span>
<span class="keyword1"><span class="command">theorem</span></span> dvd_defD1 <span class="main">[</span><span class="operator">resolve</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span><span class="main">::</span>nat<span class="main">)</span> <span class="keyword1">dvd</span> <span class="free">b</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">k</span><span class="main">.</span> <span class="free">b</span> <span class="main">=</span> <span class="free">a</span> <span class="main">*</span> <span class="bound">k</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> dvdE <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">theorem</span></span> dvd_defD2 <span class="main">[</span><span class="operator">resolve</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span><span class="main">::</span>nat<span class="main">)</span> <span class="keyword1">dvd</span> <span class="free">b</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">k</span><span class="main">.</span> <span class="free">b</span> <span class="main">=</span> <span class="bound">k</span> <span class="main">*</span> <span class="free">a</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> dvd_mult_div_cancel mult.commute<span class="main">)</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Nat.dvd_imp_le<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">theorem</span></span> dvd_ineq2 <span class="main">[</span><span class="operator">forward</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">k</span><span class="main">::</span>nat<span class="main">)</span> <span class="keyword1">dvd</span> <span class="free">n</span> <span class="main">⟹</span> <span class="free">n</span> <span class="main">&gt;</span> <span class="main">0</span> <span class="main">⟹</span> <span class="free">k</span> <span class="main">≥</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Suc_leI dvd_pos_nat<span class="main">)</span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> dvd_trans<span class="antiquote">}</span></span></span> <span class="main">(</span><span class="entity">with_conds</span> <span class="main">[</span><span class="inner_quoted">"?a ≠ ?b"</span><span class="main">,</span> <span class="inner_quoted">"?b ≠ ?c"</span><span class="main">,</span> <span class="inner_quoted">"?a ≠ ?c"</span><span class="main">]</span><span class="main">)</span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Nat.dvd_antisym<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_cond</span> <span class="inner_quoted">"?m ≠ ?n"</span><span class="main">]</span>›</span>
<span class="keyword1"><span class="command">theorem</span></span> dvd_cancel <span class="main">[</span><span class="operator">backward1</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">&gt;</span> <span class="main">0</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">a</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">*</span> <span class="free">c</span> <span class="keyword1">dvd</span> <span class="free">b</span> <span class="main">*</span> <span class="free">c</span> <span class="main">⟹</span> <span class="free">a</span> <span class="keyword1">dvd</span> <span class="free">b</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep</span> <span class="main">(</span><span class="entity">equiv_forward_th</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> dvd_add_right_iff<span class="antiquote">}</span></span></span><span class="main">)</span>›</span>

<span class="comment1">(* Divisibility: existence. *)</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_resolve_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> dvd_refl<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">theorem</span></span> exists_n_dvd_n <span class="main">[</span><span class="operator">backward</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">(</span><span class="free">n</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">k</span><span class="main">.</span> <span class="bound">k</span> <span class="keyword1">dvd</span> <span class="free">n</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">k</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> dvd_refl <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_resolve_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> one_dvd<span class="antiquote">}</span></span></span>›</span>

<span class="keyword1"><span class="command">theorem</span></span> any_n_dvd_0 <span class="main">[</span><span class="operator">forward</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="main">(</span><span class="main">∃</span> <span class="bound">k</span><span class="main">.</span> <span class="bound">k</span> <span class="keyword1">dvd</span> <span class="main">(</span><span class="main">0</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">k</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">¬</span> <span class="main">(</span><span class="main">∃</span> <span class="bound">k</span><span class="main">.</span> <span class="free">P</span> <span class="bound">k</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">theorem</span></span> n_dvd_one<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">n</span><span class="main">::</span>nat<span class="main">)</span> <span class="keyword1">dvd</span> <span class="main">1</span> <span class="main">⟹</span> <span class="free">n</span> <span class="main">=</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> n_dvd_one<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_cond</span> <span class="inner_quoted">"?n ≠ 1"</span><span class="main">]</span>›</span>

<span class="comment1">(* Products. *)</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> mult_zero_left<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">lemma</span></span> prod_ineqs1 <span class="main">[</span><span class="operator">forward</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">m</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">*</span> <span class="free">k</span> <span class="main">&gt;</span> <span class="main">0</span> <span class="main">⟹</span> <span class="free">m</span> <span class="main">&gt;</span> <span class="main">0</span> <span class="main">∧</span> <span class="free">k</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">lemma</span></span> prod_ineqs2 <span class="main">[</span><span class="operator">backward</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">k</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">&gt;</span> <span class="main">0</span> <span class="main">⟹</span> <span class="free">m</span> <span class="main">≤</span> <span class="free">m</span> <span class="main">*</span> <span class="free">k</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">theorem</span></span> prod_cancel<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">*</span> <span class="free">b</span> <span class="main">=</span> <span class="free">a</span> <span class="main">*</span> <span class="free">c</span> <span class="main">⟹</span> <span class="free">a</span> <span class="main">&gt;</span> <span class="main">0</span> <span class="main">⟹</span> <span class="free">b</span> <span class="main">=</span> <span class="free">c</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> prod_cancel<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_cond</span> <span class="inner_quoted">"?b ≠ ?c"</span><span class="main">]</span>›</span>

<span class="keyword1"><span class="command">theorem</span></span> mult_n1n<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">n</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">=</span> <span class="free">m</span> <span class="main">*</span> <span class="free">n</span> <span class="main">⟹</span> <span class="free">n</span> <span class="main">&gt;</span> <span class="main">0</span> <span class="main">⟹</span> <span class="free">m</span> <span class="main">=</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> mult_n1n<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_cond</span> <span class="inner_quoted">"?m ≠ 1"</span><span class="main">]</span>›</span>

<span class="keyword1"><span class="command">theorem</span></span> prod_is_one <span class="main">[</span><span class="operator">forward</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">*</span> <span class="free">y</span> <span class="main">=</span> <span class="main">1</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">=</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">theorem</span></span> prod_dvd_intro <span class="main">[</span><span class="operator">backward</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">k</span><span class="main">::</span>nat<span class="main">)</span> <span class="keyword1">dvd</span> <span class="free">m</span> <span class="main">∨</span> <span class="free">k</span> <span class="keyword1">dvd</span> <span class="free">n</span> <span class="main">⟹</span> <span class="free">k</span> <span class="keyword1">dvd</span> <span class="free">m</span> <span class="main">*</span> <span class="free">n</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> dvd_mult dvd_mult2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="comment1">(* Definition of gcd. *)</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> gcd_dvd1<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_term</span> <span class="inner_quoted">"gcd ?a ?b"</span><span class="main">]</span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> gcd_dvd2<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_term</span> <span class="inner_quoted">"gcd ?a ?b"</span><span class="main">]</span>›</span>

<span class="comment1">(* Coprimality. *)</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule_bidir</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> coprime_iff_gcd_eq_1<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">lemma</span></span> coprime_exp <span class="main">[</span><span class="operator">backward</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"coprime <span class="free">d</span> <span class="free">a</span> <span class="main">⟹</span> coprime <span class="main">(</span><span class="free">d</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">(</span><span class="free">a</span> <span class="main">^</span> <span class="free">n</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_backward_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> coprime_exp<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> gcd.commute<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">lemma</span></span> coprime_dvd_mult <span class="main">[</span><span class="operator">backward1</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"coprime <span class="main">(</span><span class="free">a</span><span class="main">::</span>nat<span class="main">)</span> <span class="free">b</span> <span class="main">⟹</span> <span class="free">a</span> <span class="keyword1">dvd</span> <span class="free">c</span> <span class="main">*</span> <span class="free">b</span> <span class="main">⟹</span> <span class="free">a</span> <span class="keyword1">dvd</span> <span class="free">c</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> coprime_dvd_mult_left_iff<span class="main">)</span>
<span class="keyword1"><span class="command">lemma</span></span> coprime_dvd_mult' <span class="main">[</span><span class="operator">backward1</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"coprime <span class="main">(</span><span class="free">a</span><span class="main">::</span>nat<span class="main">)</span> <span class="free">b</span> <span class="main">⟹</span> <span class="free">a</span> <span class="keyword1">dvd</span> <span class="free">b</span> <span class="main">*</span> <span class="free">c</span> <span class="main">⟹</span> <span class="free">a</span> <span class="keyword1">dvd</span> <span class="free">c</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> coprime_dvd_mult_right_iff<span class="main">)</span>

<span class="keyword1"><span class="command">theorem</span></span> coprime_dvd <span class="main">[</span><span class="operator">forward</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"coprime <span class="main">(</span><span class="free">a</span><span class="main">::</span>nat<span class="main">)</span> <span class="free">b</span> <span class="main">⟹</span> <span class="free">p</span> <span class="keyword1">dvd</span> <span class="free">a</span> <span class="main">⟹</span> <span class="free">p</span> <span class="main">&gt;</span> <span class="main">1</span> <span class="main">⟹</span> <span class="main">¬</span> <span class="free">p</span> <span class="keyword1">dvd</span> <span class="free">b</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> coprime_common_divisor_nat <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="comment1">(* Powers. *)</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> power_0<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">theorem</span></span> power_ge_0 <span class="main">[</span><span class="operator">rewrite</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">⟹</span> <span class="free">p</span> <span class="main">^</span> <span class="free">m</span> <span class="main">=</span> <span class="free">p</span> <span class="main">*</span> <span class="main">(</span><span class="free">p</span> <span class="main">^</span> <span class="main">(</span><span class="free">m</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> power_eq_if<span class="main">)</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> power_one<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_cond</span> <span class="inner_quoted">"?n ≠ 0"</span><span class="main">]</span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> power_one_right<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_cond</span> <span class="inner_quoted">"?a ≠ 1"</span><span class="main">]</span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_gen_prfstep</span> <span class="main">(</span><span class="inner_quoted">"power_case_intro"</span><span class="main">,</span>
  <span class="main">[</span><span class="entity">WithTerm</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term_pat</span> <span class="quoted">"<span class="var">?p</span> <span class="main">^</span> <span class="main">(</span><span class="var">?FREE</span><span class="main">::</span>nat<span class="main">)</span>"</span><span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">CreateCase</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term_pat</span> <span class="quoted">"<span class="main">(</span><span class="var">?FREE</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span><span class="antiquote">}</span></span><span class="main">]</span><span class="main">)</span>›</span>

<span class="keyword1"><span class="command">lemma</span></span> one_is_power_of_any <span class="main">[</span><span class="operator">resolve</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">i</span><span class="main">.</span> <span class="main">(</span><span class="main">1</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">=</span> <span class="free">a</span> <span class="main">^</span> <span class="bound">i</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> power.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> power_Suc<span class="antiquote">}</span></span></span>›</span>

<span class="keyword1"><span class="command">theorem</span></span> power_dvd <span class="main">[</span><span class="operator">forward</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span><span class="main">::</span>nat<span class="main">)</span><span class="main">^</span><span class="free">n</span> <span class="keyword1">dvd</span> <span class="free">a</span> <span class="main">⟹</span> <span class="free">n</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">⟹</span> <span class="free">p</span> <span class="keyword1">dvd</span> <span class="free">a</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> dvd_power dvd_trans <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">theorem</span></span> power_eq_one<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">b</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">^</span> <span class="free">n</span> <span class="main">=</span> <span class="main">1</span> <span class="main">⟹</span> <span class="free">b</span> <span class="main">=</span> <span class="main">1</span> <span class="main">∨</span> <span class="free">n</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> One_nat_def Suc_lessI nat_zero_less_power_iff power_0 power_inject_exp<span class="main">)</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> power_eq_one<span class="antiquote">}</span></span></span> <span class="main">(</span><span class="entity">with_conds</span> <span class="main">[</span><span class="inner_quoted">"?b ≠ 1"</span><span class="main">,</span> <span class="inner_quoted">"?n ≠ 0"</span><span class="main">]</span><span class="main">)</span>›</span>

<span class="comment1">(* Factorial. *)</span>
<span class="keyword1"><span class="command">theorem</span></span> fact_ge_1_nat<span class="main">:</span> <span class="quoted"><span class="quoted">"fact <span class="main">(</span><span class="free">n</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">≥</span> <span class="main">(</span><span class="main">1</span><span class="main">::</span>nat<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> fact_ge_1_nat<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_term</span> <span class="inner_quoted">"fact ?n"</span><span class="main">]</span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_backward1_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> dvd_fact<span class="antiquote">}</span></span></span>›</span>

<span class="comment1">(* Successor function. *)</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Nat.Suc_eq_plus1<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_backward_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Nat.gr0_implies_Suc<span class="antiquote">}</span></span></span>›</span>

<span class="comment1">(* Cases *)</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹fold <span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> Nat.nat.case<span class="antiquote">}</span></span></span>›</span>

<span class="comment1">(* Induction. *)</span>
<span class="keyword1"><span class="command">lemma</span></span> nat_cases<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">0</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">⋀</span><span class="bound">n</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span>Suc <span class="bound">n</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">P</span> <span class="free">n</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> nat_induct <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="comment1">(* div *)</span>
<span class="keyword1"><span class="command">declare</span></span> times_div_less_eq_dividend <span class="main">[</span><span class="operator">resolve</span><span class="main">]</span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹
  <span class="entity">add_var_induct_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> nat_induct<span class="antiquote">}</span></span></span> #&gt;
  <span class="entity">add_strong_induct_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> nat_less_induct<span class="antiquote">}</span></span></span> #&gt;
  <span class="entity">add_cases_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> nat_cases<span class="antiquote">}</span></span></span>
›</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="files/arith.ML">
<div class="head">
<h1>File ‹arith.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*
  File: arith.ML
  Author: Bohua Zhan

  Arithmetic proof steps.
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">NAT_UTIL</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> lookup_numc<span class="main">:</span> Type.tyenv * Envir.tenv <span class="main">-&gt;</span> int <span class="main">-&gt;</span> int
  <span class="keyword1"><span class="keyword">val</span></span> lookup_numc0<span class="main">:</span> Type.tyenv * Envir.tenv <span class="main">-&gt;</span> int
  <span class="keyword1"><span class="keyword">val</span></span> lookup_numc1<span class="main">:</span> Type.tyenv * Envir.tenv <span class="main">-&gt;</span> int
  <span class="keyword1"><span class="keyword">val</span></span> lookup_numc2<span class="main">:</span> Type.tyenv * Envir.tenv <span class="main">-&gt;</span> int
  <span class="keyword1"><span class="keyword">val</span></span> mk_nat<span class="main">:</span> int <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> mk_int<span class="main">:</span> int <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> nat0<span class="main">:</span> term
  <span class="keyword1"><span class="keyword">val</span></span> cnat0<span class="main">:</span> cterm

  <span class="keyword1"><span class="keyword">val</span></span> mk_less<span class="main">:</span> term * term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> mk_le<span class="main">:</span> term * term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> nat_le_th<span class="main">:</span> int <span class="main">-&gt;</span> int <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> nat_less_th<span class="main">:</span> int <span class="main">-&gt;</span> int <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> nat_neq_th<span class="main">:</span> int <span class="main">-&gt;</span> int <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> nat_fold_reduce<span class="main">:</span> term <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> nat_fold_conv<span class="main">:</span> conv

  <span class="keyword1"><span class="keyword">val</span></span> plus_ac_on_typ<span class="main">:</span> theory <span class="main">-&gt;</span> typ <span class="main">-&gt;</span> <span class="entity">ac_info</span>
  <span class="keyword1"><span class="keyword">val</span></span> times_ac_on_typ<span class="main">:</span> theory <span class="main">-&gt;</span> typ <span class="main">-&gt;</span> <span class="entity">ac_info</span>
  <span class="keyword1"><span class="keyword">val</span></span> add_arith_ac_data<span class="main">:</span> theory <span class="main">-&gt;</span> theory
  <span class="keyword1"><span class="keyword">val</span></span> add_arith_proofsteps<span class="main">:</span> theory <span class="main">-&gt;</span> theory
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Nat_Util</span> <span class="main">:</span> <span class="entity">NAT_UTIL</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">lookup_numc</span> <span class="entity">inst</span> <span class="entity">n</span> <span class="main">=</span> <span class="entity">UtilArith.dest_numc</span> <span class="main">(</span><span class="entity">lookup_instn</span> <span class="entity">inst</span> <span class="main">(</span><span class="inner_quoted">"NUMC"</span><span class="main">,</span> <span class="entity">n</span><span class="main">)</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">lookup_numc0</span> <span class="entity">inst</span> <span class="main">=</span> <span class="entity">lookup_numc</span> <span class="entity">inst</span> <span class="inner_numeral">0</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">lookup_numc1</span> <span class="entity">inst</span> <span class="main">=</span> <span class="entity">lookup_numc</span> <span class="entity">inst</span> <span class="inner_numeral">1</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">lookup_numc2</span> <span class="entity">inst</span> <span class="main">=</span> <span class="entity">lookup_numc</span> <span class="entity">inst</span> <span class="inner_numeral">2</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_nat</span> <span class="entity">n</span> <span class="main">=</span> <span class="entity">HOLogic.mk_number</span> <span class="entity">natT</span> <span class="entity">n</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_int</span> <span class="entity">n</span> <span class="main">=</span> <span class="entity">HOLogic.mk_number</span> <span class="entity">intT</span> <span class="entity">n</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">nat0</span> <span class="main">=</span> <span class="entity">mk_nat</span> <span class="inner_numeral">0</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cnat0</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">cterm</span> <span class="quoted">"<span class="main">0</span><span class="main">::</span>nat"</span><span class="antiquote">}</span></span></span>

<span class="keyword2"><span class="keyword">local</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span>
<span class="keyword2"><span class="keyword">in</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_less</span> <span class="main">(</span><span class="entity">m</span><span class="main">,</span> <span class="entity">n</span><span class="main">)</span> <span class="main">=</span>
    Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> less<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">natT</span> --&gt; <span class="entity">natT</span> --&gt; <span class="entity">boolT</span><span class="main">)</span> $ <span class="entity">m</span> $ <span class="entity">n</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_le</span> <span class="main">(</span><span class="entity">m</span><span class="main">,</span> <span class="entity">n</span><span class="main">)</span> <span class="main">=</span>
    Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> less_eq<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">natT</span> --&gt; <span class="entity">natT</span> --&gt; <span class="entity">boolT</span><span class="main">)</span> $ <span class="entity">m</span> $ <span class="entity">n</span>

<span class="comment1">(* Obtain the theorem m &lt;= n. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">nat_le_th</span> <span class="entity">m</span> <span class="entity">n</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">m</span> &gt; <span class="entity">n</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"nat_le_th: input"</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">UtilArith.prove_by_arith</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span><span class="entity">mk_le</span> <span class="main">(</span><span class="entity">mk_nat</span> <span class="entity">m</span><span class="main">,</span> <span class="entity">mk_nat</span> <span class="entity">n</span><span class="main">)</span><span class="main">)</span>

<span class="comment1">(* Obtain the theorem m &lt; n. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">nat_less_th</span> <span class="entity">m</span> <span class="entity">n</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">m</span> &gt;= <span class="entity">n</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"nat_less_th: input"</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">UtilArith.prove_by_arith</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span><span class="entity">mk_less</span> <span class="main">(</span><span class="entity">mk_nat</span> <span class="entity">m</span><span class="main">,</span> <span class="entity">mk_nat</span> <span class="entity">n</span><span class="main">)</span><span class="main">)</span>

<span class="comment1">(* Obtain the theorem m ~= n. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">nat_neq_th</span> <span class="entity">m</span> <span class="entity">n</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">m</span> <span class="main">=</span> <span class="entity">n</span> <span class="keyword1"><span class="keyword">orelse</span></span> <span class="entity">m</span> &lt; <span class="inner_numeral">0</span> <span class="keyword1"><span class="keyword">orelse</span></span> <span class="entity">n</span> &lt; <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"nat_neq_th: input"</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">UtilArith.prove_by_arith</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span><span class="entity">mk_not</span> <span class="main">(</span><span class="entity">mk_eq</span> <span class="main">(</span><span class="entity">mk_nat</span> <span class="entity">m</span><span class="main">,</span> <span class="entity">mk_nat</span> <span class="entity">n</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">nat_fold_reduce</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> fastype_of <span class="entity">t</span> &lt;&gt; <span class="entity">natT</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">else</span></span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">f</span><span class="main">,</span> <span class="main">(</span><span class="entity">n1</span><span class="main">,</span> <span class="entity">n2</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">t</span> |&gt; <span class="entity">Util.dest_binop</span> |&gt; apsnd <span class="main">(</span>apply2 <span class="entity">UtilArith.dest_numc</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">f</span> <span class="keyword2"><span class="keyword">of</span></span>
          Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> plus<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">mk_nat</span> <span class="main">(</span><span class="entity">n1</span> + <span class="entity">n2</span><span class="main">)</span>
        <span class="main">|</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> minus<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">mk_nat</span> <span class="main">(</span>Int.max <span class="main">(</span><span class="inner_numeral">0</span><span class="main">,</span> <span class="entity">n1</span> - <span class="entity">n2</span><span class="main">)</span><span class="main">)</span>
        <span class="main">|</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> times<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">mk_nat</span> <span class="main">(</span><span class="entity">n1</span> * <span class="entity">n2</span><span class="main">)</span>
        <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">t</span>
    <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword3"><span class="keyword">handle</span></span> Fail <span class="inner_quoted">"dest_binop"</span> <span class="main">=&gt;</span> <span class="entity">t</span> <span class="main">|</span> Fail <span class="inner_quoted">"dest_numc"</span> <span class="main">=&gt;</span> <span class="entity">t</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">nat_fold_conv</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Thm.term_of <span class="entity">ct</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t'</span> <span class="main">=</span> <span class="entity">nat_fold_reduce</span> <span class="entity">t</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">t</span> aconv <span class="entity">t'</span> <span class="keyword2"><span class="keyword">then</span></span> Conv.all_conv <span class="entity">ct</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">to_meta_eq</span> <span class="main">(</span><span class="entity">UtilArith.prove_by_arith</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span><span class="entity">mk_eq</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">t'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>  <span class="comment1">(* local ctxt = @{context}. *)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">plus_ac</span> <span class="main">=</span>
    <span class="main">{</span>cfhead <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">cterm</span> <span class="quoted">plus</span><span class="antiquote">}</span></span></span><span class="main">,</span> unit <span class="main">=</span> SOME <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">cterm</span> <span class="quoted"><span class="main">0</span></span><span class="antiquote">}</span></span></span><span class="main">,</span>
     assoc_th <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> add_ac<span class="main">(</span>1<span class="main">)</span><span class="antiquote">}</span></span></span><span class="main">,</span> comm_th <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> add_ac<span class="main">(</span>2<span class="main">)</span><span class="antiquote">}</span></span></span><span class="main">,</span>
     unitl_th <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> add_0<span class="antiquote">}</span></span></span><span class="main">,</span> unitr_th <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> add_0_right<span class="antiquote">}</span></span></span><span class="main">}</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">times_ac</span> <span class="main">=</span>
    <span class="main">{</span>cfhead <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">cterm</span> <span class="quoted">times</span><span class="antiquote">}</span></span></span><span class="main">,</span> unit <span class="main">=</span> SOME <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">cterm</span> <span class="quoted"><span class="main">1</span></span><span class="antiquote">}</span></span></span><span class="main">,</span>
     assoc_th <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> mult_ac<span class="main">(</span>1<span class="main">)</span><span class="antiquote">}</span></span></span><span class="main">,</span> comm_th <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> mult_ac<span class="main">(</span>2<span class="main">)</span><span class="antiquote">}</span></span></span><span class="main">,</span>
     unitl_th <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> mult_1<span class="antiquote">}</span></span></span><span class="main">,</span> unitr_th <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> mult_1_right<span class="antiquote">}</span></span></span><span class="main">}</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">gcd_ac</span> <span class="main">=</span>
    <span class="main">{</span>cfhead <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">cterm</span> <span class="quoted">gcd</span><span class="antiquote">}</span></span></span><span class="main">,</span> unit <span class="main">=</span> SOME <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">cterm</span> <span class="quoted"><span class="main">0</span></span><span class="antiquote">}</span></span></span><span class="main">,</span>
     assoc_th <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> gcd.assoc<span class="antiquote">}</span></span></span><span class="main">,</span> comm_th <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> gcd.commute<span class="antiquote">}</span></span></span><span class="main">,</span>
     unitl_th <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> gcd_0_left_nat<span class="antiquote">}</span></span></span><span class="main">,</span> unitr_th <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> gcd_0_nat<span class="antiquote">}</span></span></span><span class="main">}</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">add_arith_ac_data</span> <span class="main">=</span>
    fold <span class="entity">ACUtil.add_ac_data</span> <span class="main">[</span><span class="entity">plus_ac</span><span class="main">,</span> <span class="entity">times_ac</span><span class="main">,</span> <span class="entity">gcd_ac</span><span class="main">]</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">plus_ac_on_typ</span> <span class="entity">thy</span> <span class="entity">T</span> <span class="main">=</span>
    the <span class="main">(</span><span class="entity">ACUtil.inst_ac_info</span> <span class="entity">thy</span> <span class="entity">T</span> <span class="entity">plus_ac</span><span class="main">)</span>
    <span class="keyword3"><span class="keyword">handle</span></span> Option.Option <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"plus_ac_on_typ: cannot inst ac_info."</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">times_ac_on_typ</span> <span class="entity">thy</span> <span class="entity">T</span> <span class="main">=</span>
    the <span class="main">(</span><span class="entity">ACUtil.inst_ac_info</span> <span class="entity">thy</span> <span class="entity">T</span> <span class="entity">times_ac</span><span class="main">)</span>
    <span class="keyword3"><span class="keyword">handle</span></span> Option.Option <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"times_ac_on_typ: cannot inst ac_info."</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">add_arith_proofsteps</span> <span class="main">=</span>
    fold <span class="entity">add_prfstep_custom</span> <span class="main">[</span>
      <span class="comment1">(* Resolve equality facts with constants. *)</span>
      <span class="main">(</span><span class="inner_quoted">"compare_consts"</span><span class="main">,</span>
       <span class="main">[</span><span class="entity">WithFact</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term_pat</span> <span class="quoted">"<span class="main">(</span><span class="var">?NUMC1</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">=</span> <span class="var">?NUMC2</span>"</span><span class="antiquote">}</span></span><span class="main">,</span>
        <span class="entity">Filter</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span> <span class="main">=&gt;</span>
                   <span class="entity">lookup_numc1</span> <span class="entity">inst</span> &lt;&gt; <span class="entity">lookup_numc2</span> <span class="entity">inst</span><span class="main">)</span><span class="main">]</span><span class="main">,</span>
       <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="entity">ths</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span>
          <span class="main">[</span><span class="entity">Update.thm_update</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">UtilArith.contra_by_arith</span> <span class="entity">ctxt</span> <span class="entity">ths</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>

      <span class="main">(</span><span class="inner_quoted">"compare_consts_le"</span><span class="main">,</span>
       <span class="main">[</span><span class="entity">WithFact</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term_pat</span> <span class="quoted">"<span class="main">(</span><span class="var">?NUMC1</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">&lt;=</span> <span class="var">?NUMC2</span>"</span><span class="antiquote">}</span></span><span class="main">,</span>
        <span class="entity">Filter</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span> <span class="main">=&gt;</span>
                   <span class="entity">lookup_numc1</span> <span class="entity">inst</span> &gt; <span class="entity">lookup_numc2</span> <span class="entity">inst</span><span class="main">)</span><span class="main">]</span><span class="main">,</span>
       <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="entity">ths</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span>
          <span class="main">[</span><span class="entity">Update.thm_update</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">UtilArith.contra_by_arith</span> <span class="entity">ctxt</span> <span class="entity">ths</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>

      <span class="main">(</span><span class="inner_quoted">"compare_consts_less"</span><span class="main">,</span>
       <span class="main">[</span><span class="entity">WithFact</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term_pat</span> <span class="quoted">"<span class="main">(</span><span class="var">?NUMC1</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">&lt;</span> <span class="var">?NUMC2</span>"</span><span class="antiquote">}</span></span><span class="main">,</span>
        <span class="entity">Filter</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span> <span class="main">=&gt;</span>
                   <span class="entity">lookup_numc1</span> <span class="entity">inst</span> &gt;= <span class="entity">lookup_numc2</span> <span class="entity">inst</span><span class="main">)</span><span class="main">]</span><span class="main">,</span>
       <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="entity">ths</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span>
          <span class="main">[</span><span class="entity">Update.thm_update</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">UtilArith.contra_by_arith</span> <span class="entity">ctxt</span> <span class="entity">ths</span><span class="main">)</span><span class="main">]</span><span class="main">)</span>

    <span class="main">]</span> #&gt; fold <span class="entity">add_prfstep_conv</span> <span class="main">[</span>
      <span class="main">(</span><span class="inner_quoted">"eval_plus_consts"</span><span class="main">,</span>
       <span class="main">[</span><span class="entity">WithTerm</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term_pat</span> <span class="quoted">"<span class="main">(</span><span class="var">?NUMC1</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">+</span> <span class="var">?NUMC2</span>"</span><span class="antiquote">}</span></span><span class="main">,</span>
        <span class="entity">Filter</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span> <span class="main">=&gt;</span>
                   <span class="entity">lookup_numc1</span> <span class="entity">inst</span> &gt; <span class="inner_numeral">0</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">lookup_numc2</span> <span class="entity">inst</span> &gt; <span class="inner_numeral">0</span><span class="main">)</span><span class="main">]</span><span class="main">,</span>
       <span class="entity">nat_fold_conv</span><span class="main">)</span><span class="main">,</span>

      <span class="main">(</span><span class="inner_quoted">"eval_mult_consts"</span><span class="main">,</span>
       <span class="main">[</span><span class="entity">WithTerm</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term_pat</span> <span class="quoted">"<span class="main">(</span><span class="var">?NUMC1</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">*</span> <span class="var">?NUMC2</span>"</span><span class="antiquote">}</span></span><span class="main">,</span>
        <span class="entity">Filter</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span> <span class="main">=&gt;</span>
                   <span class="entity">lookup_numc1</span> <span class="entity">inst</span> &lt;&gt; <span class="inner_numeral">1</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">lookup_numc2</span> <span class="entity">inst</span> &lt;&gt; <span class="inner_numeral">1</span><span class="main">)</span><span class="main">]</span><span class="main">,</span>
       <span class="entity">nat_fold_conv</span><span class="main">)</span><span class="main">,</span>

      <span class="main">(</span><span class="inner_quoted">"eval_minus_consts"</span><span class="main">,</span>
       <span class="main">[</span><span class="entity">WithTerm</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term_pat</span> <span class="quoted">"<span class="main">(</span><span class="var">?NUMC1</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">-</span> <span class="var">?NUMC2</span>"</span><span class="antiquote">}</span></span><span class="main">,</span>
        <span class="entity">Filter</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">lookup_numc2</span> <span class="entity">inst</span> &gt;= <span class="inner_numeral">1</span><span class="main">)</span><span class="main">]</span><span class="main">,</span>
       <span class="entity">nat_fold_conv</span><span class="main">)</span><span class="main">]</span>

<span class="keyword2"><span class="keyword">end</span></span>  <span class="comment1">(* structure Nat_Util. *)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mk_nat</span> <span class="main">=</span> <span class="entity">Nat_Util.mk_nat</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mk_int</span> <span class="main">=</span> <span class="entity">Nat_Util.mk_int</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">plus_ac_on_typ</span> <span class="main">=</span> <span class="entity">Nat_Util.plus_ac_on_typ</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">times_ac_on_typ</span> <span class="main">=</span> <span class="entity">Nat_Util.times_ac_on_typ</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> Theory.setup <span class="entity">Nat_Util.add_arith_ac_data</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> Theory.setup <span class="entity">Nat_Util.add_arith_proofsteps</span>
</pre>
</div><div id="files/order.ML">
<div class="head">
<h1>File ‹order.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*
  File: order.ML
  Author: Bohua Zhan

  Ordering on natural numbers. We implement something like a decision
  procedure for difference logic using proof steps.
*)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">TY_NAT_ORDER</span> <span class="main">=</span> <span class="inner_quoted">"NAT_ORDER"</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">NAT_ORDER</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> is_order<span class="main">:</span> term <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> is_plus_const<span class="main">:</span> term <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> is_minus_const<span class="main">:</span> term <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> is_standard_ineq<span class="main">:</span> term <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> dest_ineq<span class="main">:</span> term <span class="main">-&gt;</span> term * term * int
  <span class="keyword1"><span class="keyword">val</span></span> dest_ineq_th<span class="main">:</span> thm <span class="main">-&gt;</span> term * term * int

  <span class="keyword1"><span class="keyword">val</span></span> fold_double_plus<span class="main">:</span> conv
  <span class="keyword1"><span class="keyword">val</span></span> norm_ineq_th'<span class="main">:</span> thm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> convert_const_x<span class="main">:</span> thm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> convert_const_y<span class="main">:</span> thm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> norm_ineq_th<span class="main">:</span> thm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> norm_ineq_minus_th'<span class="main">:</span> thm <span class="main">-&gt;</span> thm option
  <span class="keyword1"><span class="keyword">val</span></span> norm_ineq_minus_th<span class="main">:</span> thm <span class="main">-&gt;</span> thm option

  <span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">order_type</span> <span class="main">=</span>
           <span class="entity">LESS</span> <span class="main">|</span> <span class="entity">LESS_LMINUS</span> <span class="main">|</span> <span class="entity">LESS_LPLUS</span> <span class="main">|</span> <span class="entity">LESS_RMINUS</span> <span class="main">|</span> <span class="entity">LESS_RPLUS</span> <span class="main">|</span>
           <span class="entity">LE</span> <span class="main">|</span> <span class="entity">LE_LMINUS</span> <span class="main">|</span> <span class="entity">LE_LPLUS</span> <span class="main">|</span> <span class="entity">LE_RMINUS</span> <span class="main">|</span> <span class="entity">LE_RPLUS</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">order_info</span>
  <span class="keyword1"><span class="keyword">val</span></span> to_normal_th<span class="main">:</span> <span class="entity">order_type</span> <span class="main">-&gt;</span> thm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> th_to_ritem<span class="main">:</span> thm <span class="main">-&gt;</span> <span class="entity">raw_item</span>
  <span class="keyword1"><span class="keyword">val</span></span> th_to_normed_ritems<span class="main">:</span> thm <span class="main">-&gt;</span> <span class="entity">raw_item</span> list
  <span class="keyword1"><span class="keyword">val</span></span> nat_order_normalizer<span class="main">:</span> <span class="entity">normalizer</span>
  <span class="keyword1"><span class="keyword">val</span></span> nat_eq_diff_prfstep<span class="main">:</span> <span class="entity">proofstep</span>

  <span class="keyword1"><span class="keyword">val</span></span> get_nat_order_info<span class="main">:</span> <span class="entity">box_item</span> <span class="main">-&gt;</span> <span class="entity">order_info</span>
  <span class="keyword1"><span class="keyword">val</span></span> nat_order_typed_matcher<span class="main">:</span> <span class="entity">item_matcher</span>
  <span class="keyword1"><span class="keyword">val</span></span> transitive<span class="main">:</span> <span class="entity">proofstep</span>
  <span class="keyword1"><span class="keyword">val</span></span> transitive_resolve<span class="main">:</span> <span class="entity">proofstep</span>
  <span class="keyword1"><span class="keyword">val</span></span> single_resolve<span class="main">:</span> <span class="entity">proofstep</span>
  <span class="keyword1"><span class="keyword">val</span></span> single_resolve_zero<span class="main">:</span> <span class="entity">proofstep</span>

  <span class="keyword1"><span class="keyword">val</span></span> nat_order_match<span class="main">:</span> term <span class="main">-&gt;</span> <span class="entity">box_item</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">id_inst</span> <span class="main">-&gt;</span>
                       <span class="entity">id_inst_th</span> list
  <span class="keyword1"><span class="keyword">val</span></span> nat_order_matcher<span class="main">:</span> <span class="entity">item_matcher</span>
  <span class="keyword1"><span class="keyword">val</span></span> nat_order_noteq_matcher<span class="main">:</span> <span class="entity">item_matcher</span>
  <span class="keyword1"><span class="keyword">val</span></span> nat_order_single_match<span class="main">:</span> term <span class="main">-&gt;</span> <span class="entity">box_item</span> <span class="main">-&gt;</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">id_inst</span> <span class="main">-&gt;</span>
                              <span class="entity">id_inst_th</span> list
  <span class="keyword1"><span class="keyword">val</span></span> nat_order_single_matcher<span class="main">:</span> <span class="entity">item_matcher</span>

  <span class="keyword1"><span class="keyword">val</span></span> shadow_nat_order_prfstep<span class="main">:</span> <span class="entity">proofstep</span>
  <span class="keyword1"><span class="keyword">val</span></span> shadow_nat_order_single<span class="main">:</span> <span class="entity">proofstep</span>

  <span class="keyword1"><span class="keyword">val</span></span> string_of_nat_order<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term * term * int * thm <span class="main">-&gt;</span> string
  <span class="keyword1"><span class="keyword">val</span></span> output_nat_order<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> term list * thm <span class="main">-&gt;</span> string
  <span class="keyword1"><span class="keyword">val</span></span> shadow_nat_order<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">box_id</span> <span class="main">-&gt;</span> term list * cterm list <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> add_nat_order_proofsteps<span class="main">:</span> theory <span class="main">-&gt;</span> theory
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Nat_Order</span> <span class="main">:</span> <span class="entity">NAT_ORDER</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">is_numc</span> <span class="main">=</span> <span class="entity">UtilArith.is_numc</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dest_numc</span> <span class="main">=</span> <span class="entity">UtilArith.dest_numc</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">nat0</span> <span class="main">=</span> <span class="entity">Nat_Util.nat0</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">nat_less_th</span> <span class="main">=</span> <span class="entity">Nat_Util.nat_less_th</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">nat_fold_conv0_right</span> <span class="main">=</span>
    Conv.try_conv <span class="main">(</span><span class="entity">rewr_obj_eq</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Nat.add_0_right<span class="antiquote">}</span></span></span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">nat_fold_conv0_left</span> <span class="main">=</span>
    Conv.try_conv <span class="main">(</span><span class="entity">rewr_obj_eq</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Nat.plus_nat.add_0<span class="antiquote">}</span></span></span><span class="main">)</span>

<span class="comment1">(* Whether the given term is &lt; or &lt;= on natural numbers. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_less</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> less<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="main">_</span> $ <span class="main">_</span> <span class="main">=&gt;</span> true
            <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_less_eq</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> less_eq<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="main">_</span> $ <span class="main">_</span> <span class="main">=&gt;</span> true
            <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_order</span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">is_less</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">orelse</span></span> <span class="entity">is_less_eq</span> <span class="entity">t</span>

<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">order_type</span> <span class="main">=</span>
         <span class="entity">LESS_LMINUS</span> <span class="main">|</span> <span class="entity">LESS_LPLUS</span> <span class="main">|</span> <span class="entity">LESS_RMINUS</span> <span class="main">|</span> <span class="entity">LESS_RPLUS</span> <span class="main">|</span> <span class="entity">LESS</span> <span class="main">|</span>
         <span class="entity">LE_LMINUS</span> <span class="main">|</span> <span class="entity">LE_LPLUS</span> <span class="main">|</span> <span class="entity">LE_RMINUS</span> <span class="main">|</span> <span class="entity">LE_RPLUS</span> <span class="main">|</span> <span class="entity">LE</span>

<span class="comment1">(* Check whether t is in the form a + n, where n is a constant. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_plus_const</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="entity">UtilArith.is_plus</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">UtilArith.is_numc</span> <span class="main">(</span><span class="entity">dest_arg</span> <span class="entity">t</span><span class="main">)</span>

<span class="comment1">(* Check whether t is in the form a - n, where n is a constant. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_minus_const</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="entity">UtilArith.is_minus</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">UtilArith.is_numc</span> <span class="main">(</span><span class="entity">dest_arg</span> <span class="entity">t</span><span class="main">)</span>

<span class="comment1">(* Check whether t is an inequality in the standard form. This means t
   is either a + n &lt;= b with n &gt; 0, or a &lt;= b + n with n &gt;= 0.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_standard_ineq</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_less_eq</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Util.dest_binop_args</span> <span class="entity">t</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        fastype_of <span class="entity">lhs</span> <span class="main">=</span> <span class="entity">natT</span> <span class="keyword1"><span class="keyword">andalso</span></span>
        <span class="main">(</span><span class="main">(</span><span class="entity">is_plus_const</span> <span class="entity">lhs</span> <span class="keyword1"><span class="keyword">andalso</span></span> not <span class="main">(</span><span class="entity">is_plus_const</span> <span class="entity">rhs</span><span class="main">)</span> <span class="keyword1"><span class="keyword">andalso</span></span>
          <span class="entity">UtilArith.dest_numc</span> <span class="main">(</span><span class="entity">dest_arg</span> <span class="entity">lhs</span><span class="main">)</span> &gt; <span class="inner_numeral">0</span><span class="main">)</span> <span class="keyword1"><span class="keyword">orelse</span></span>
         <span class="main">(</span><span class="entity">is_plus_const</span> <span class="entity">rhs</span> <span class="keyword1"><span class="keyword">andalso</span></span> not <span class="main">(</span><span class="entity">is_plus_const</span> <span class="entity">lhs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">else</span></span> false

<span class="comment1">(* Assume t is in the form x + n &lt;= y or x &lt;= y + n, deconstruct into
   the triple (x, y, d), where d = -n in the first case and n in the
   second case.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_ineq</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span><span class="entity">is_standard_ineq</span> <span class="entity">t</span><span class="main">)</span> <span class="inner_quoted">"dest_ineq"</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Util.dest_binop_args</span> <span class="entity">t</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_plus_const</span> <span class="entity">lhs</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="main">(</span><span class="entity">dest_arg1</span> <span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">,</span> ~ <span class="main">(</span><span class="entity">UtilArith.dest_numc</span> <span class="main">(</span><span class="entity">dest_arg</span> <span class="entity">lhs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">dest_arg1</span> <span class="entity">rhs</span><span class="main">,</span> <span class="entity">UtilArith.dest_numc</span> <span class="main">(</span><span class="entity">dest_arg</span> <span class="entity">rhs</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_ineq_th</span> <span class="entity">th</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">UtilLogic.is_Trueprop</span> <span class="main">(</span>Thm.prop_of <span class="entity">th</span><span class="main">)</span> <span class="keyword1"><span class="keyword">andalso</span></span>
       <span class="entity">is_standard_ineq</span> <span class="main">(</span><span class="entity">prop_of'</span> <span class="entity">th</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
      <span class="entity">dest_ineq</span> <span class="main">(</span><span class="entity">prop_of'</span> <span class="entity">th</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_thm_global</span> <span class="inner_quoted">"th:"</span> <span class="entity">th</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"dest_ineq_th"</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* In expression x + n &lt; y, fold n. *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fold_const_left</span> <span class="main">=</span>
    <span class="entity">apply_to_thm'</span> <span class="main">(</span>Conv.arg1_conv <span class="main">(</span>Conv.arg_conv <span class="entity">Nat_Util.nat_fold_conv</span><span class="main">)</span><span class="main">)</span>

<span class="comment1">(* In expression x &lt; y + n, fold n. *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fold_const_right</span> <span class="main">=</span>
    <span class="entity">apply_to_thm'</span> <span class="main">(</span>Conv.arg_conv <span class="main">(</span>Conv.arg_conv <span class="entity">Nat_Util.nat_fold_conv</span><span class="main">)</span><span class="main">)</span>

<span class="comment1">(* In expression (x + c1) + c2, fold c1 + c2. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">fold_double_plus</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Thm.term_of <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_plus_const</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_plus_const</span> <span class="main">(</span><span class="entity">dest_arg1</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
        Conv.every_conv <span class="main">[</span><span class="entity">rewr_obj_eq</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> add_ac<span class="main">(</span>1<span class="main">)</span><span class="antiquote">}</span></span></span><span class="main">,</span>
                         Conv.arg_conv <span class="entity">Nat_Util.nat_fold_conv</span><span class="main">,</span>
                         <span class="entity">fold_double_plus</span><span class="main">]</span> <span class="entity">ct</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        Conv.all_conv <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Normalize inequality to standard form. This function is able to
   process any theorem of the form a &lt;/&lt;= b.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">norm_ineq_th'</span> <span class="entity">th</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">prop_of'</span> <span class="entity">th</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span><span class="entity">is_less_eq</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">orelse</span></span> <span class="entity">is_less</span> <span class="entity">t</span><span class="main">)</span> <span class="inner_quoted">"norm_ineq_th"</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Util.dest_binop_args</span> <span class="entity">t</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">try_fold0</span> <span class="main">=</span> Conv.try_conv <span class="main">(</span>Conv.arg_conv <span class="entity">nat_fold_conv0_right</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_less_eq</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_plus_const</span> <span class="entity">lhs</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_plus_const</span> <span class="entity">rhs</span> <span class="keyword2"><span class="keyword">then</span></span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Util.dest_binop_args</span> <span class="entity">t</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">n1</span><span class="main">,</span> <span class="entity">n2</span><span class="main">)</span> <span class="main">=</span> apply2 <span class="main">(</span><span class="entity">UtilArith.dest_numc</span> o <span class="entity">dest_arg</span><span class="main">)</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">n1</span> &lt;= <span class="entity">n2</span> <span class="keyword2"><span class="keyword">then</span></span>
              <span class="main">(</span><span class="entity">th</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> reduce_le_plus_consts<span class="antiquote">}</span></span></span><span class="main">)</span> |&gt; <span class="entity">fold_const_right</span>
            <span class="keyword2"><span class="keyword">else</span></span>
              <span class="main">(</span><span class="main">[</span><span class="entity">Nat_Util.nat_le_th</span> <span class="entity">n2</span> <span class="entity">n1</span><span class="main">,</span> <span class="entity">th</span><span class="main">]</span>
                   MRS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> reduce_le_plus_consts'<span class="antiquote">}</span></span></span><span class="main">)</span> |&gt; <span class="entity">fold_const_left</span>
          <span class="keyword2"><span class="keyword">end</span></span>
        <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_plus_const</span> <span class="entity">lhs</span> <span class="keyword2"><span class="keyword">then</span></span>
          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">UtilArith.dest_numc</span> <span class="main">(</span><span class="entity">dest_arg</span> <span class="entity">lhs</span><span class="main">)</span> <span class="main">=</span> <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span>
            <span class="entity">th</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> norm_le_lplus0<span class="antiquote">}</span></span></span>
          <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">th</span>
        <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_plus_const</span> <span class="entity">rhs</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">th</span>
        <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_minus_const</span> <span class="entity">lhs</span> <span class="keyword2"><span class="keyword">then</span></span>
          <span class="entity">th</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> norm_le_lminus<span class="antiquote">}</span></span></span>
        <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_minus_const</span> <span class="entity">rhs</span> <span class="keyword2"><span class="keyword">then</span></span>
          <span class="entity">th</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> norm_le_rminus<span class="antiquote">}</span></span></span>
        <span class="keyword2"><span class="keyword">else</span></span>
          <span class="entity">th</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> norm_le<span class="antiquote">}</span></span></span>
      <span class="keyword2"><span class="keyword">else</span></span>  <span class="comment1">(* is_less t *)</span>
        <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_plus_const</span> <span class="entity">lhs</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_plus_const</span> <span class="entity">rhs</span> <span class="keyword2"><span class="keyword">then</span></span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Util.dest_binop_args</span> <span class="entity">t</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">n1</span><span class="main">,</span> <span class="entity">n2</span><span class="main">)</span> <span class="main">=</span> apply2 <span class="main">(</span><span class="entity">UtilArith.dest_numc</span> o <span class="entity">dest_arg</span><span class="main">)</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">n1</span> &lt;= <span class="entity">n2</span> <span class="keyword2"><span class="keyword">then</span></span>
              <span class="main">(</span><span class="entity">th</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> reduce_less_plus_consts<span class="antiquote">}</span></span></span><span class="main">)</span> |&gt; <span class="entity">fold_const_right</span>
                                                     |&gt; <span class="entity">apply_to_thm'</span> <span class="entity">try_fold0</span>
                                                     |&gt; <span class="entity">norm_ineq_th'</span>
            <span class="keyword2"><span class="keyword">else</span></span>
              <span class="main">(</span><span class="main">[</span><span class="entity">Nat_Util.nat_le_th</span> <span class="entity">n2</span> <span class="entity">n1</span><span class="main">,</span> <span class="entity">th</span><span class="main">]</span>
                   MRS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> reduce_less_plus_consts'<span class="antiquote">}</span></span></span><span class="main">)</span> |&gt; <span class="entity">fold_const_left</span>
                                                        |&gt; <span class="entity">norm_ineq_th'</span>
          <span class="keyword2"><span class="keyword">end</span></span>
        <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_plus_const</span> <span class="entity">lhs</span> <span class="keyword2"><span class="keyword">then</span></span>
          <span class="main">(</span><span class="entity">th</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> norm_less_lplus<span class="antiquote">}</span></span></span><span class="main">)</span> |&gt; <span class="entity">fold_const_left</span>
        <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_plus_const</span> <span class="entity">rhs</span> <span class="keyword2"><span class="keyword">then</span></span>
          <span class="main">(</span><span class="entity">th</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> norm_less_rplus<span class="antiquote">}</span></span></span><span class="main">)</span> |&gt; <span class="entity">fold_const_right</span>
        <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_minus_const</span> <span class="entity">lhs</span> <span class="keyword2"><span class="keyword">then</span></span>
          <span class="main">(</span><span class="entity">th</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> norm_less_lminus<span class="antiquote">}</span></span></span><span class="main">)</span> |&gt; <span class="entity">fold_const_right</span>
        <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_minus_const</span> <span class="entity">rhs</span> <span class="keyword2"><span class="keyword">then</span></span>
          <span class="main">(</span><span class="entity">th</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> norm_less_rminus<span class="antiquote">}</span></span></span><span class="main">)</span> |&gt; <span class="entity">fold_const_left</span>
        <span class="keyword2"><span class="keyword">else</span></span>
          <span class="entity">th</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> norm_less<span class="antiquote">}</span></span></span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Handle the case of x &lt;/&lt;= y where x is itself a constant. Reduce to
   the case where x = 0.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">convert_const_x</span> <span class="entity">th</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">d</span><span class="main">)</span> <span class="main">=</span> <span class="entity">dest_ineq_th</span> <span class="entity">th</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">UtilArith.is_numc</span> <span class="entity">x</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">xn</span> <span class="main">=</span> <span class="entity">UtilArith.dest_numc</span> <span class="entity">x</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">xn</span> <span class="main">=</span> <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">th</span>
          <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">d</span> &lt; <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span>
            <span class="main">(</span><span class="entity">th</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> cv_const1<span class="antiquote">}</span></span></span><span class="main">)</span> |&gt; <span class="entity">fold_const_left</span>
          <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">d</span> - <span class="entity">xn</span> &lt; <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span>
            <span class="main">(</span><span class="entity">th</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> cv_const4<span class="antiquote">}</span></span></span><span class="main">)</span> |&gt; <span class="entity">fold_const_left</span>
          <span class="keyword2"><span class="keyword">else</span></span>
            <span class="main">(</span><span class="entity">th</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> cv_const5<span class="antiquote">}</span></span></span><span class="main">)</span> |&gt; <span class="entity">fold_const_right</span>
        <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">th</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Handle the case of x &lt;/&lt;= y where y is itself a constant. Reduce to
   the case where y = 0.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">convert_const_y</span> <span class="entity">th</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">y</span><span class="main">,</span> <span class="entity">d</span><span class="main">)</span> <span class="main">=</span> <span class="entity">dest_ineq_th</span> <span class="entity">th</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">UtilArith.is_numc</span> <span class="entity">y</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">yn</span> <span class="main">=</span> <span class="entity">UtilArith.dest_numc</span> <span class="entity">y</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">yn</span> <span class="main">=</span> <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">th</span>
          <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">d</span> &lt; <span class="inner_numeral">0</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">yn</span> + <span class="entity">d</span> &gt;= <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span>
            <span class="main">(</span><span class="entity">th</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> cv_const2<span class="antiquote">}</span></span></span><span class="main">)</span> |&gt; <span class="entity">fold_const_right</span>
          <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">d</span> &lt; <span class="inner_numeral">0</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">yn</span> + <span class="entity">d</span> &lt; <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span>
            <span class="main">(</span><span class="main">[</span><span class="entity">Nat_Util.nat_less_th</span> <span class="entity">yn</span> <span class="main">(</span>~<span class="entity">d</span><span class="main">)</span><span class="main">,</span> <span class="entity">th</span><span class="main">]</span> MRS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> cv_const3<span class="antiquote">}</span></span></span><span class="main">)</span>
                |&gt; <span class="entity">fold_const_left</span>
          <span class="keyword2"><span class="keyword">else</span></span>
            <span class="main">(</span><span class="entity">th</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> cv_const6<span class="antiquote">}</span></span></span><span class="main">)</span> |&gt; <span class="entity">fold_const_right</span>
        <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">th</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Overall normalization function. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">norm_ineq_th</span> <span class="entity">th</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th'</span> <span class="main">=</span>
          <span class="entity">th</span> |&gt; <span class="entity">apply_to_thm'</span> <span class="main">(</span>Conv.arg1_conv <span class="entity">fold_double_plus</span><span class="main">)</span>
             |&gt; <span class="entity">apply_to_thm'</span> <span class="main">(</span>Conv.arg_conv <span class="entity">fold_double_plus</span><span class="main">)</span>
             |&gt; <span class="entity">norm_ineq_th'</span> |&gt; <span class="entity">convert_const_x</span> |&gt; <span class="entity">convert_const_y</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_standard_ineq</span> <span class="main">(</span><span class="entity">prop_of'</span> <span class="entity">th'</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">th'</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_thm_global</span> <span class="inner_quoted">"th':"</span> <span class="entity">th'</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"norm_ineq_th: invalid output."</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Normalization function that does not consider the minus case. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">norm_ineq_minus_th'</span> <span class="entity">th</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">prop_of'</span> <span class="entity">th</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span><span class="entity">is_less_eq</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">orelse</span></span> <span class="entity">is_less</span> <span class="entity">t</span><span class="main">)</span> <span class="inner_quoted">"norm_ineq_minus_th"</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Util.dest_binop_args</span> <span class="entity">t</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_less_eq</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_minus_const</span> <span class="entity">lhs</span> <span class="keyword1"><span class="keyword">andalso</span></span> not <span class="main">(</span><span class="entity">is_plus_const</span> <span class="entity">rhs</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
          SOME <span class="main">(</span><span class="entity">th</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> norm_le<span class="antiquote">}</span></span></span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_minus_const</span> <span class="entity">rhs</span> <span class="keyword1"><span class="keyword">andalso</span></span> not <span class="main">(</span><span class="entity">is_plus_const</span> <span class="entity">lhs</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
          SOME <span class="main">(</span><span class="entity">th</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> norm_le<span class="antiquote">}</span></span></span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">else</span></span> NONE
      <span class="keyword2"><span class="keyword">else</span></span>  <span class="comment1">(* is_less t *)</span>
        <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_minus_const</span> <span class="entity">lhs</span> <span class="keyword1"><span class="keyword">andalso</span></span> not <span class="main">(</span><span class="entity">is_plus_const</span> <span class="entity">rhs</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
          SOME <span class="main">(</span><span class="entity">th</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> norm_less<span class="antiquote">}</span></span></span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_minus_const</span> <span class="entity">rhs</span> <span class="keyword1"><span class="keyword">andalso</span></span> not <span class="main">(</span><span class="entity">is_plus_const</span> <span class="entity">lhs</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
          SOME <span class="main">(</span><span class="entity">th</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> norm_less<span class="antiquote">}</span></span></span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">else</span></span> NONE
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">norm_ineq_minus_th</span> <span class="entity">th</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">norm_ineq_minus_th'</span> <span class="entity">th</span> <span class="keyword2"><span class="keyword">of</span></span>
        NONE <span class="main">=&gt;</span> NONE
      <span class="main">|</span> SOME <span class="entity">th'</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th''</span> <span class="main">=</span> <span class="entity">th'</span> |&gt; <span class="entity">convert_const_x</span> |&gt; <span class="entity">convert_const_y</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_standard_ineq</span> <span class="main">(</span><span class="entity">prop_of'</span> <span class="entity">th''</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> SOME <span class="entity">th''</span>
          <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_thm_global</span> <span class="inner_quoted">"th'':"</span> <span class="entity">th''</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"norm_ineq_minus_th: invalid output."</span>
          <span class="keyword2"><span class="keyword">end</span></span>
        <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* The first three values (x, y, n) specify a NAT_ORDER item, and the
   last value provides theorem justifying it. If n &gt;= 0, then the
   theorem is x &lt;= y + n. Otherwise, the theorem is x + (~n) &lt;= y.
 *)</span>
<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">order_info</span> <span class="main">=</span> cterm * cterm * int * thm

<span class="comment1">(* Conversion from a theorem to its normal form. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">to_normal_th</span> <span class="entity">order_ty</span> <span class="entity">th</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">order_ty</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="entity">LESS_LMINUS</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">th</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> norm_less_lminus<span class="antiquote">}</span></span></span><span class="main">)</span> |&gt; <span class="entity">fold_const_right</span>
      <span class="main">|</span> <span class="entity">LESS_LPLUS</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">th</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> norm_less_lplus<span class="antiquote">}</span></span></span><span class="main">)</span> |&gt; <span class="entity">fold_const_left</span>
      <span class="main">|</span> <span class="entity">LESS_RMINUS</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">th</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> norm_less_rminus<span class="antiquote">}</span></span></span><span class="main">)</span> |&gt; <span class="entity">fold_const_left</span>
      <span class="main">|</span> <span class="entity">LESS_RPLUS</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">th</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> norm_less_rplus<span class="antiquote">}</span></span></span><span class="main">)</span> |&gt; <span class="entity">fold_const_right</span>
      <span class="main">|</span> <span class="entity">LESS</span> <span class="main">=&gt;</span> <span class="entity">th</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> norm_less<span class="antiquote">}</span></span></span>
      <span class="main">|</span> <span class="entity">LE_LMINUS</span> <span class="main">=&gt;</span> <span class="entity">th</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> norm_le_lminus<span class="antiquote">}</span></span></span>
      <span class="main">|</span> <span class="entity">LE_RMINUS</span> <span class="main">=&gt;</span> <span class="entity">th</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> norm_le_rminus<span class="antiquote">}</span></span></span>
      <span class="main">|</span> <span class="entity">LE</span> <span class="main">=&gt;</span> <span class="entity">th</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> norm_le<span class="antiquote">}</span></span></span>
      <span class="main">|</span> <span class="entity">LE_LPLUS</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">UtilArith.dest_numc</span> <span class="main">(</span><span class="entity">dest_arg</span> <span class="main">(</span><span class="entity">dest_arg1</span> <span class="main">(</span><span class="entity">prop_of'</span> <span class="entity">th</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span>
          <span class="entity">th</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> norm_le_lplus0<span class="antiquote">}</span></span></span>
        <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">th</span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">th</span>

<span class="comment1">(* eq_x is a meta equality. Use it to rewrite x in an order info. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rewrite_info_x</span> <span class="entity">eq_x</span> <span class="main">(</span><span class="entity">cx</span><span class="main">,</span> <span class="entity">cy</span><span class="main">,</span> <span class="entity">diff</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span>Thm.lhs_of <span class="entity">eq_x</span> aconvc <span class="entity">cx</span><span class="main">)</span>
                     <span class="inner_quoted">"rewrite_info_x: invalid equality."</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th'</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">diff</span> &gt;= <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span>  <span class="comment1">(* rewrite x in x &lt;= y + n. *)</span>
            <span class="entity">th</span> |&gt; <span class="entity">apply_to_thm'</span> <span class="main">(</span>Conv.arg1_conv <span class="main">(</span>Conv.rewr_conv <span class="entity">eq_x</span><span class="main">)</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">else</span></span>  <span class="comment1">(* rewrite x in x + n &lt;= y. *)</span>
            <span class="entity">th</span> |&gt; <span class="entity">apply_to_thm'</span> <span class="main">(</span>Conv.arg1_conv <span class="main">(</span>
                                    Conv.arg1_conv <span class="main">(</span>Conv.rewr_conv <span class="entity">eq_x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">(</span>Thm.rhs_of <span class="entity">eq_x</span><span class="main">,</span> <span class="entity">cy</span><span class="main">,</span> <span class="entity">diff</span><span class="main">,</span> <span class="entity">th'</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* eq_y is a meta equality. Use it to rewrite y in an order info. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rewrite_info_y</span> <span class="entity">eq_y</span> <span class="main">(</span><span class="entity">cx</span><span class="main">,</span> <span class="entity">cy</span><span class="main">,</span> <span class="entity">diff</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span>Thm.lhs_of <span class="entity">eq_y</span> aconvc <span class="entity">cy</span><span class="main">)</span>
                     <span class="inner_quoted">"rewrite_info_y: invalid equality."</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th'</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">diff</span> &gt;= <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span>  <span class="comment1">(* rewrite y in x &lt;= y + n. *)</span>
            <span class="entity">th</span> |&gt; <span class="entity">apply_to_thm'</span> <span class="main">(</span>Conv.arg_conv <span class="main">(</span>
                                   Conv.arg1_conv <span class="main">(</span>Conv.rewr_conv <span class="entity">eq_y</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">else</span></span>  <span class="comment1">(* rewrite y in x + n &lt;= y. *)</span>
            <span class="entity">th</span> |&gt; <span class="entity">apply_to_thm'</span> <span class="main">(</span>Conv.arg_conv <span class="main">(</span>Conv.rewr_conv <span class="entity">eq_y</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">(</span><span class="entity">cx</span><span class="main">,</span> Thm.rhs_of <span class="entity">eq_y</span><span class="main">,</span> <span class="entity">diff</span><span class="main">,</span> <span class="entity">th'</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Conversion from a normalized order theorem to an raw item. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">th_to_ritem</span> <span class="entity">th</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">,</span> <span class="entity">n</span><span class="main">)</span> <span class="main">=</span> <span class="entity">dest_ineq_th</span> <span class="entity">th</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">Fact</span> <span class="main">(</span><span class="entity">TY_NAT_ORDER</span><span class="main">,</span> <span class="main">[</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">,</span> <span class="entity">mk_int</span> <span class="entity">n</span><span class="main">]</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Overall normalization function. Include both strategies (with and
   without considering the minus case).
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">th_to_normed_ritems</span> <span class="entity">th</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th'</span> <span class="main">=</span> <span class="entity">norm_ineq_th</span> <span class="entity">th</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">minus_th</span> <span class="main">=</span> the_list <span class="main">(</span><span class="entity">norm_ineq_minus_th</span> <span class="entity">th</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      map <span class="entity">th_to_ritem</span> <span class="main">(</span><span class="entity">th'</span> :: <span class="entity">minus_th</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">nat_order_normalizer</span> <span class="main">_</span> <span class="entity">ritem</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">ritem</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="entity">Handler</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="entity">ritem</span><span class="main">]</span>
      <span class="main">|</span> <span class="entity">Fact</span> <span class="main">(</span><span class="entity">ty_str</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=&gt;</span>
        <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">ty_str</span> &lt;&gt; <span class="entity">TY_PROP</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="entity">ritem</span><span class="main">]</span>
        <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_order</span> <span class="main">(</span><span class="entity">prop_of'</span> <span class="entity">th</span><span class="main">)</span> <span class="keyword1"><span class="keyword">andalso</span></span>
                fastype_of <span class="main">(</span><span class="entity">dest_arg</span> <span class="main">(</span><span class="entity">prop_of'</span> <span class="entity">th</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">natT</span> <span class="keyword2"><span class="keyword">then</span></span>
          <span class="entity">th_to_normed_ritems</span> <span class="entity">th</span>
        <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="entity">ritem</span><span class="main">]</span>

<span class="comment1">(* Given an equality such as x + n = y, produce inequalities x + n &lt;=
   y and x + n &gt;= y. Applies also when one side of the inequality is a
   constant.
 *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">nat_eq_diff_prfstep</span> <span class="main">=</span>
    <span class="entity">ProofStep.prfstep_custom</span>
      <span class="inner_quoted">"nat_eq_diff"</span>
      <span class="main">[</span><span class="entity">WithItem</span> <span class="main">(</span><span class="entity">TY_EQ</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term_pat</span> <span class="quoted">"<span class="main">(</span><span class="var">?x</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">=</span> <span class="var">?y</span>"</span><span class="antiquote">}</span></span><span class="main">)</span><span class="main">]</span>
      <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">items</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">prop</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> the_single <span class="entity">items</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">prop</span> |&gt; <span class="entity">prop_of'</span> |&gt; <span class="entity">Util.dest_binop_args</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_plus_const</span> <span class="entity">lhs</span> <span class="keyword1"><span class="keyword">orelse</span></span> <span class="entity">is_plus_const</span> <span class="entity">rhs</span> <span class="keyword1"><span class="keyword">orelse</span></span>
               <span class="entity">is_numc</span> <span class="entity">lhs</span> <span class="keyword1"><span class="keyword">orelse</span></span> <span class="entity">is_numc</span> <span class="entity">rhs</span> <span class="keyword2"><span class="keyword">then</span></span>
              <span class="keyword2"><span class="keyword">let</span></span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prop'</span> <span class="main">=</span> <span class="entity">to_meta_eq</span> <span class="entity">prop</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ths</span> <span class="main">=</span> <span class="main">(</span><span class="entity">prop'</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> eq_to_ineqs<span class="antiquote">}</span></span></span><span class="main">)</span>
                              |&gt; <span class="entity">UtilLogic.split_conj_th</span>
              <span class="keyword2"><span class="keyword">in</span></span>
                <span class="main">[</span><span class="entity">AddItems</span> <span class="main">{</span>id <span class="main">=</span> <span class="entity">id</span><span class="main">,</span> sc <span class="main">=</span> NONE<span class="main">,</span>
                           raw_items <span class="main">=</span> maps <span class="entity">th_to_normed_ritems</span> <span class="entity">ths</span><span class="main">}</span><span class="main">]</span>
              <span class="keyword2"><span class="keyword">end</span></span>
            <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="main">]</span>
          <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>

<span class="comment1">(* Obtain quadruple x, y, diff, and theorem from item. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_nat_order_info</span> <span class="main">{</span><span class="entity">tname</span><span class="main">,</span> <span class="entity">prop</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">cx</span><span class="main">,</span> <span class="entity">cy</span><span class="main">,</span> <span class="entity">cdiff_t</span><span class="main">)</span> <span class="main">=</span> <span class="entity">the_triple</span> <span class="entity">tname</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">(</span><span class="entity">cx</span><span class="main">,</span> <span class="entity">cy</span><span class="main">,</span> <span class="entity">dest_numc</span> <span class="main">(</span>Thm.term_of <span class="entity">cdiff_t</span><span class="main">)</span><span class="main">,</span> <span class="entity">prop</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Matching function for retrieving a NAT_ORDER item. The pattern
   should be a triple (?x, ?y, ?m).
 *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">nat_order_typed_matcher</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pre_match</span> <span class="entity">pat</span> <span class="main">{</span><span class="entity">tname</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="entity">ctxt</span> <span class="main">=</span>
          <span class="entity">Matcher.pre_match_head</span>
              <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">pat</span><span class="main">,</span> Thm.cterm_of <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">HOLogic.mk_tuple</span> <span class="main">(</span>map Thm.term_of <span class="entity">tname</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">match</span> <span class="entity">pat</span> <span class="main">(</span><span class="entity">item</span> <span class="keyword1"><span class="keyword">as</span></span> <span class="main">{</span>tname <span class="main">=</span> <span class="entity">cts</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pats</span> <span class="main">=</span> <span class="entity">HOLogic.strip_tuple</span> <span class="entity">pat</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">insts'</span> <span class="main">=</span> <span class="entity">Matcher.rewrite_match_list</span>
                             <span class="entity">ctxt</span> <span class="main">(</span>map <span class="main">(</span>pair false<span class="main">)</span> <span class="main">(</span><span class="entity">pats</span> ~~ <span class="entity">cts</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_inst</span> <span class="main">(</span><span class="entity">inst</span><span class="main">,</span> <span class="entity">ths</span><span class="main">)</span> <span class="main">=</span>
                <span class="keyword2"><span class="keyword">let</span></span>
                  <span class="comment1">(* eq_x: pat_x(env) == x, eq_y: pat_y(env) = y *)</span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">eq_x</span><span class="main">,</span> <span class="entity">eq_y</span><span class="main">,</span> <span class="entity">eq_n</span><span class="main">)</span> <span class="main">=</span> <span class="entity">the_triple</span> <span class="entity">ths</span>
                <span class="keyword2"><span class="keyword">in</span></span>
                  <span class="keyword2"><span class="keyword">if</span></span> Thm.is_reflexive <span class="entity">eq_n</span> <span class="keyword2"><span class="keyword">then</span></span>
                    <span class="keyword2"><span class="keyword">let</span></span>
                      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">prop</span><span class="main">)</span> <span class="main">=</span>
                          <span class="entity">item</span> |&gt; <span class="entity">get_nat_order_info</span>
                               |&gt; <span class="entity">rewrite_info_x</span> <span class="main">(</span><span class="entity">meta_sym</span> <span class="entity">eq_x</span><span class="main">)</span>
                               |&gt; <span class="entity">rewrite_info_y</span> <span class="main">(</span><span class="entity">meta_sym</span> <span class="entity">eq_y</span><span class="main">)</span>
                    <span class="keyword2"><span class="keyword">in</span></span>
                      <span class="main">[</span><span class="main">(</span><span class="entity">inst</span><span class="main">,</span> <span class="entity">prop</span><span class="main">)</span><span class="main">]</span>
                    <span class="keyword2"><span class="keyword">end</span></span>
                  <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="main">]</span>
                <span class="keyword2"><span class="keyword">end</span></span>
          <span class="keyword2"><span class="keyword">in</span></span>
            maps <span class="entity">process_inst</span> <span class="entity">insts'</span>
          <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">{</span>pre_match <span class="main">=</span> <span class="entity">pre_match</span><span class="main">,</span> match <span class="main">=</span> <span class="entity">match</span><span class="main">}</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Helper function for transitivity of two inequalities. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">order_trans</span> <span class="entity">th1</span> <span class="entity">th2</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">y1</span><span class="main">,</span> <span class="entity">d1</span><span class="main">)</span> <span class="main">=</span> <span class="entity">dest_ineq_th</span> <span class="entity">th1</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">x2</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">d2</span><span class="main">)</span> <span class="main">=</span> <span class="entity">dest_ineq_th</span> <span class="entity">th2</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span><span class="entity">y1</span> aconv <span class="entity">x2</span><span class="main">)</span> <span class="inner_quoted">"order_trans"</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">d1</span> &lt; <span class="inner_numeral">0</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">d2</span> &lt; <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="main">(</span><span class="main">[</span><span class="entity">th1</span><span class="main">,</span> <span class="entity">th2</span><span class="main">]</span> MRS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> trans1<span class="antiquote">}</span></span></span><span class="main">)</span> |&gt; <span class="entity">fold_const_left</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">d1</span> &gt;= <span class="inner_numeral">0</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">d2</span> &gt;= <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="main">(</span><span class="main">[</span><span class="entity">th1</span><span class="main">,</span> <span class="entity">th2</span><span class="main">]</span> MRS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> trans2<span class="antiquote">}</span></span></span><span class="main">)</span> |&gt; <span class="entity">fold_const_right</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">d1</span> &lt; <span class="inner_numeral">0</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">d2</span> &gt;= <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">d2</span> &gt;= <span class="main">(</span>~<span class="entity">d1</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
          <span class="main">(</span><span class="main">[</span><span class="entity">th1</span><span class="main">,</span> <span class="entity">th2</span><span class="main">]</span> MRS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> trans3<span class="antiquote">}</span></span></span><span class="main">)</span> |&gt; <span class="entity">fold_const_right</span>
        <span class="keyword2"><span class="keyword">else</span></span>  <span class="comment1">(* d2 &lt; (~d1) *)</span>
          <span class="main">(</span><span class="main">[</span><span class="entity">Nat_Util.nat_less_th</span> <span class="entity">d2</span> <span class="main">(</span>~<span class="entity">d1</span><span class="main">)</span><span class="main">,</span> <span class="entity">th1</span><span class="main">,</span> <span class="entity">th2</span><span class="main">]</span> MRS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> trans4<span class="antiquote">}</span></span></span><span class="main">)</span>
              |&gt; <span class="entity">fold_const_left</span>
      <span class="keyword2"><span class="keyword">else</span></span>  <span class="comment1">(* d1 &gt;= 0 andalso d2 &lt; 0 *)</span>
        <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">d1</span> &gt;= <span class="main">(</span>~<span class="entity">d2</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
          <span class="main">(</span><span class="main">[</span><span class="entity">th1</span><span class="main">,</span> <span class="entity">th2</span><span class="main">]</span> MRS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> trans5<span class="antiquote">}</span></span></span><span class="main">)</span> |&gt; <span class="entity">fold_const_right</span>
        <span class="keyword2"><span class="keyword">else</span></span>
          <span class="main">(</span><span class="main">[</span><span class="entity">Nat_Util.nat_less_th</span> <span class="entity">d1</span> <span class="main">(</span>~<span class="entity">d2</span><span class="main">)</span><span class="main">,</span> <span class="entity">th1</span><span class="main">,</span> <span class="entity">th2</span><span class="main">]</span> MRS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> trans6<span class="antiquote">}</span></span></span><span class="main">)</span>
              |&gt; <span class="entity">fold_const_left</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Apply transitivity to two NAT_ORDER infos. *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">transitive</span> <span class="main">=</span>
    <span class="entity">ProofStep.prfstep_custom</span>
        <span class="inner_quoted">"nat_order_transitive"</span>
        <span class="main">[</span><span class="entity">WithItem</span> <span class="main">(</span><span class="entity">TY_NAT_ORDER</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term_pat</span> <span class="quoted">"<span class="main">(</span><span class="var">?x</span><span class="main">,</span> <span class="var">?y</span><span class="main">,</span> <span class="var">?m</span><span class="main">)</span>"</span><span class="antiquote">}</span></span><span class="main">)</span><span class="main">,</span>
         <span class="entity">WithItem</span> <span class="main">(</span><span class="entity">TY_NAT_ORDER</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term_pat</span> <span class="quoted">"<span class="main">(</span><span class="var">?y</span><span class="main">,</span> <span class="var">?z</span><span class="main">,</span> <span class="var">?n</span><span class="main">)</span>"</span><span class="antiquote">}</span></span><span class="main">)</span><span class="main">,</span>
         <span class="entity">Filter</span> <span class="main">(</span><span class="entity">neq_filter</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term_pat</span> <span class="quoted">"<span class="var">?x</span> <span class="main">~=</span> <span class="var">?y</span>"</span><span class="antiquote">}</span></span><span class="main">)</span><span class="main">,</span>
         <span class="entity">Filter</span> <span class="main">(</span><span class="entity">neq_filter</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term_pat</span> <span class="quoted">"<span class="var">?y</span> <span class="main">~=</span> <span class="var">?z</span>"</span><span class="antiquote">}</span></span><span class="main">)</span><span class="main">,</span>
         <span class="entity">Filter</span> <span class="main">(</span><span class="entity">neq_filter</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term_pat</span> <span class="quoted">"<span class="var">?x</span> <span class="main">~=</span> <span class="var">?z</span>"</span><span class="antiquote">}</span></span><span class="main">)</span><span class="main">]</span>
        <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="entity">ths</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span>
            <span class="keyword2"><span class="keyword">let</span></span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">th1</span><span class="main">,</span> <span class="entity">th2</span><span class="main">)</span> <span class="main">=</span> <span class="entity">the_pair</span> <span class="entity">ths</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">item'</span> <span class="main">=</span> <span class="entity">th_to_ritem</span> <span class="main">(</span><span class="entity">order_trans</span> <span class="entity">th1</span> <span class="entity">th2</span><span class="main">)</span>
            <span class="keyword2"><span class="keyword">in</span></span>
              <span class="main">[</span><span class="entity">AddItems</span> <span class="main">{</span>id <span class="main">=</span> <span class="entity">id</span><span class="main">,</span> sc <span class="main">=</span> NONE<span class="main">,</span> raw_items <span class="main">=</span> <span class="main">[</span><span class="entity">item'</span><span class="main">]</span><span class="main">}</span><span class="main">]</span>
            <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>

<span class="comment1">(* Helper function for obtaining a contradiction from two inequalities. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">order_trans_resolve</span> <span class="entity">th1</span> <span class="entity">th2</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">d1</span><span class="main">)</span> <span class="main">=</span> <span class="entity">dest_ineq_th</span> <span class="entity">th1</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">d2</span><span class="main">)</span> <span class="main">=</span> <span class="entity">dest_ineq_th</span> <span class="entity">th2</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">d1</span> &lt; <span class="inner_numeral">0</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">d2</span> &lt; <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="main">[</span><span class="entity">nat_less_th</span> <span class="inner_numeral">0</span> <span class="main">(</span>~<span class="entity">d1</span><span class="main">)</span><span class="main">,</span> <span class="entity">th1</span><span class="main">,</span> <span class="entity">th2</span><span class="main">]</span> MRS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> trans_resolve1<span class="antiquote">}</span></span></span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">d1</span> &lt; <span class="inner_numeral">0</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">d2</span> &gt;= <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="main">[</span><span class="entity">nat_less_th</span> <span class="entity">d2</span> <span class="main">(</span>~<span class="entity">d1</span><span class="main">)</span><span class="main">,</span> <span class="entity">th1</span><span class="main">,</span> <span class="entity">th2</span><span class="main">]</span> MRS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> trans_resolve2<span class="antiquote">}</span></span></span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="comment1">(* d1 &gt;= 0 andalso d2 &lt; 0 *)</span>
        <span class="main">[</span><span class="entity">nat_less_th</span> <span class="entity">d1</span> <span class="main">(</span>~<span class="entity">d2</span><span class="main">)</span><span class="main">,</span> <span class="entity">th2</span><span class="main">,</span> <span class="entity">th1</span><span class="main">]</span> MRS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> trans_resolve2<span class="antiquote">}</span></span></span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Try to derive a contradiction from two NAT_ORDER items. *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">transitive_resolve</span> <span class="main">=</span>
    <span class="entity">ProofStep.prfstep_custom</span>
        <span class="inner_quoted">"nat_order_transitive_resolve"</span>
        <span class="main">[</span><span class="entity">WithItem</span> <span class="main">(</span><span class="entity">TY_NAT_ORDER</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term_pat</span> <span class="quoted">"<span class="main">(</span><span class="var">?x</span><span class="main">,</span> <span class="var">?y</span><span class="main">,</span> <span class="var">?m</span><span class="main">)</span>"</span><span class="antiquote">}</span></span><span class="main">)</span><span class="main">,</span>
         <span class="entity">WithItem</span> <span class="main">(</span><span class="entity">TY_NAT_ORDER</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term_pat</span> <span class="quoted">"<span class="main">(</span><span class="var">?y</span><span class="main">,</span> <span class="var">?x</span><span class="main">,</span> <span class="var">?n</span><span class="main">)</span>"</span><span class="antiquote">}</span></span><span class="main">)</span><span class="main">]</span>
        <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span><span class="main">,</span> <span class="entity">ths</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span>
            <span class="keyword2"><span class="keyword">let</span></span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">m</span> <span class="main">=</span> <span class="entity">dest_numc</span> <span class="main">(</span><span class="entity">lookup_inst</span> <span class="entity">inst</span> <span class="inner_quoted">"m"</span><span class="main">)</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">n</span> <span class="main">=</span> <span class="entity">dest_numc</span> <span class="main">(</span><span class="entity">lookup_inst</span> <span class="entity">inst</span> <span class="inner_quoted">"n"</span><span class="main">)</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">th1</span><span class="main">,</span> <span class="entity">th2</span><span class="main">)</span> <span class="main">=</span> <span class="entity">the_pair</span> <span class="entity">ths</span>
              <span class="comment1">(* Fold x &lt;= y + 0 to x &lt;= y. *)</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fold0</span> <span class="main">=</span> <span class="entity">apply_to_thm'</span> <span class="main">(</span>Conv.arg_conv <span class="entity">nat_fold_conv0_right</span><span class="main">)</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">try_fold0l</span> <span class="main">=</span> Conv.try_conv <span class="entity">nat_fold_conv0_left</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">res_ths</span> <span class="main">=</span>
                  <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">m</span> + <span class="entity">n</span> &lt; <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="entity">order_trans_resolve</span> <span class="entity">th1</span> <span class="entity">th2</span><span class="main">]</span>
                  <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">m</span> <span class="main">=</span> <span class="inner_numeral">0</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">n</span> <span class="main">=</span> <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span>
                    <span class="main">[</span><span class="main">(</span>map <span class="entity">fold0</span> <span class="main">[</span><span class="entity">th1</span><span class="main">,</span> <span class="entity">th2</span><span class="main">]</span><span class="main">)</span> MRS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Orderings.order_antisym<span class="antiquote">}</span></span></span><span class="main">]</span>
                  <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">m</span> + <span class="entity">n</span> <span class="main">=</span> <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span>
                    <span class="comment1">(* Fold 0 at left in case x or y is zero. *)</span>
                    <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="entity">th1</span><span class="main">,</span> <span class="entity">th2</span><span class="main">]</span> MRS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Orderings.order_antisym<span class="antiquote">}</span></span></span><span class="main">)</span>
                         |&gt; <span class="entity">apply_to_thm'</span> <span class="main">(</span>Conv.arg_conv <span class="entity">try_fold0l</span><span class="main">)</span>
                         |&gt; <span class="entity">apply_to_thm'</span> <span class="main">(</span>Conv.arg1_conv <span class="entity">try_fold0l</span><span class="main">)</span><span class="main">]</span>
                  <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="main">]</span>
            <span class="keyword2"><span class="keyword">in</span></span>
              map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">th</span> <span class="main">=&gt;</span> <span class="entity">Update.thm_update</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">)</span> <span class="entity">res_ths</span>
            <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>

<span class="comment1">(* Try to derive a contradiction from a single NAT_ORDER item. There
   are two types of resolves: when two sides are equal, and when the
   right side is zero (both with negative diff).
 *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">single_resolve</span> <span class="main">=</span>
    <span class="entity">ProofStep.prfstep_custom</span>
        <span class="inner_quoted">"nat_order_single_resolve"</span>
        <span class="main">[</span><span class="entity">WithItem</span> <span class="main">(</span><span class="entity">TY_NAT_ORDER</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term_pat</span> <span class="quoted">"<span class="main">(</span><span class="var">?x</span><span class="main">,</span> <span class="var">?x</span><span class="main">,</span> <span class="var">?n</span><span class="main">)</span>"</span><span class="antiquote">}</span></span><span class="main">)</span><span class="main">]</span>
        <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span><span class="main">,</span> <span class="entity">ths</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span>
            <span class="keyword2"><span class="keyword">let</span></span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">n</span> <span class="main">=</span> <span class="entity">dest_numc</span> <span class="main">(</span><span class="entity">lookup_inst</span> <span class="entity">inst</span> <span class="inner_quoted">"n"</span><span class="main">)</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th</span> <span class="main">=</span> the_single <span class="entity">ths</span>
            <span class="keyword2"><span class="keyword">in</span></span>
              <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">n</span> &lt; <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span>
                <span class="main">[</span><span class="entity">Update.thm_update</span> <span class="main">(</span>
                    <span class="entity">id</span><span class="main">,</span> <span class="main">[</span><span class="entity">nat_less_th</span> <span class="inner_numeral">0</span> <span class="main">(</span>~<span class="entity">n</span><span class="main">)</span><span class="main">,</span> <span class="entity">th</span><span class="main">]</span> MRS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> single_resolve<span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">]</span>
              <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="main">]</span>
            <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">single_resolve_zero</span> <span class="main">=</span>
    <span class="entity">ProofStep.prfstep_custom</span>
        <span class="inner_quoted">"nat_order_single_resolve_zero"</span>
        <span class="main">[</span><span class="entity">WithItem</span> <span class="main">(</span><span class="entity">TY_NAT_ORDER</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term_pat</span> <span class="quoted">"<span class="main">(</span><span class="var">?x</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="var">?n</span><span class="main">)</span>"</span><span class="antiquote">}</span></span><span class="main">)</span><span class="main">]</span>
        <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span><span class="main">,</span> <span class="entity">ths</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span>
            <span class="keyword2"><span class="keyword">let</span></span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">n</span> <span class="main">=</span> <span class="entity">dest_numc</span> <span class="main">(</span><span class="entity">lookup_inst</span> <span class="entity">inst</span> <span class="inner_quoted">"n"</span><span class="main">)</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th</span> <span class="main">=</span> the_single <span class="entity">ths</span>
            <span class="keyword2"><span class="keyword">in</span></span>
              <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">n</span> &lt; <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span>
                <span class="main">[</span><span class="entity">Update.thm_update</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="main">[</span><span class="entity">nat_less_th</span> <span class="inner_numeral">0</span> <span class="main">(</span>~<span class="entity">n</span><span class="main">)</span><span class="main">,</span> <span class="entity">th</span><span class="main">]</span>
                                            MRS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> single_resolve_const<span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">]</span>
              <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="main">]</span>
            <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span>

<span class="comment1">(* Returns true if ty is either natT or a schematic type of sort
   linorder.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">valid_type</span> <span class="entity">ctxt</span> <span class="entity">ty</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">ty</span> <span class="keyword2"><span class="keyword">of</span></span>
        TVar <span class="main">_</span> <span class="main">=&gt;</span> Sign.of_sort <span class="main">(</span>Proof_Context.theory_of <span class="entity">ctxt</span><span class="main">)</span>
                               <span class="main">(</span><span class="entity">ty</span><span class="main">,</span> <span class="main">[</span><span class="inner_quoted">"Orderings.linorder"</span><span class="main">]</span><span class="main">)</span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">ty</span> <span class="main">=</span> <span class="entity">natT</span><span class="main">)</span>

<span class="comment1">(* Given t in inequality form, return whether the type of the argument
   is appropriate for nat_order_match: that is, either natT or a
   schematic type of sort linorder.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">valid_arg_type</span> <span class="entity">ctxt</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="entity">valid_type</span> <span class="entity">ctxt</span> <span class="main">(</span>fastype_of <span class="main">(</span><span class="entity">dest_arg</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_order_pat</span> <span class="entity">ctxt</span> <span class="entity">pat</span> <span class="main">=</span>
    <span class="main">(</span><span class="entity">is_order</span> <span class="entity">pat</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">valid_arg_type</span> <span class="entity">ctxt</span> <span class="entity">pat</span><span class="main">)</span> <span class="keyword1"><span class="keyword">orelse</span></span>
    <span class="main">(</span><span class="entity">is_order</span> <span class="main">(</span><span class="entity">get_neg</span> <span class="entity">pat</span><span class="main">)</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">valid_arg_type</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">get_neg</span> <span class="entity">pat</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">less_nat</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="main">(&lt;)</span><span class="main">::</span>nat <span class="main">=&gt;</span> nat <span class="main">=&gt;</span> bool"</span><span class="antiquote">}</span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">le_nat</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="main">(&lt;=)</span><span class="main">::</span>nat <span class="main">=&gt;</span> nat <span class="main">=&gt;</span> bool"</span><span class="antiquote">}</span></span>

<span class="comment1">(* Assuming t is an order. Return the simplified form of the negation of t. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_neg_order</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_neg</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">dest_not</span> <span class="entity">t</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_less</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">le_nat</span> $ <span class="entity">dest_arg</span> <span class="entity">t</span> $ <span class="entity">dest_arg1</span> <span class="entity">t</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_less_eq</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">less_nat</span> $ <span class="entity">dest_arg</span> <span class="entity">t</span> $ <span class="entity">dest_arg1</span> <span class="entity">t</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"get_neg_order"</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_plus_const_gen</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="entity">is_plus_const</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">orelse</span></span> <span class="main">(</span><span class="entity">is_numc</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">andalso</span></span> not <span class="main">(</span><span class="entity">t</span> aconv <span class="entity">nat0</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">plus_const_of_gen</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_plus_const</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">dest_arg1</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">nat0</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rewr_side</span> <span class="entity">eq_th</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> Thm.lhs_of <span class="entity">eq_th</span> aconvc <span class="entity">ct</span> <span class="keyword2"><span class="keyword">then</span></span>
      Conv.rewr_conv <span class="entity">eq_th</span> <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_numc</span> <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
      Conv.every_conv <span class="main">[</span><span class="entity">rewr_obj_eq</span> <span class="main">(</span><span class="entity">obj_sym</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Nat.plus_nat.add_0<span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">,</span>
                       Conv.arg1_conv <span class="main">(</span>Conv.rewr_conv <span class="entity">eq_th</span><span class="main">)</span><span class="main">]</span> <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">else</span></span>
      Conv.arg1_conv <span class="main">(</span>Conv.rewr_conv <span class="entity">eq_th</span><span class="main">)</span> <span class="entity">ct</span>

<span class="comment1">(* Return a pair of terms to be matched. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">analyze_pattern</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Util.dest_binop_args</span> <span class="entity">t</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_plus_const_gen</span> <span class="entity">lhs</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="main">(</span><span class="entity">plus_const_of_gen</span> <span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">,</span>
         <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_less</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">LESS_LPLUS</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">LE_LPLUS</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_plus_const_gen</span> <span class="entity">rhs</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">plus_const_of_gen</span> <span class="entity">rhs</span><span class="main">,</span>
         <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_less</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">LESS_RPLUS</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">LE_RPLUS</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_minus_const</span> <span class="entity">lhs</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="main">(</span><span class="entity">dest_arg1</span> <span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">,</span>
         <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_less</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">LESS_LMINUS</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">LE_LMINUS</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_minus_const</span> <span class="entity">rhs</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">dest_arg1</span> <span class="entity">rhs</span><span class="main">,</span>
         <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_less</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">LESS_RMINUS</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">LE_RMINUS</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">,</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_less</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">LESS</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">LE</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">analyze_pattern2</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Util.dest_binop_args</span> <span class="entity">t</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_minus_const</span> <span class="entity">lhs</span> <span class="keyword1"><span class="keyword">andalso</span></span> not <span class="main">(</span><span class="entity">is_plus_const_gen</span> <span class="entity">rhs</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
        SOME <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">,</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_less</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">LESS</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">LE</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_minus_const</span> <span class="entity">rhs</span> <span class="keyword1"><span class="keyword">andalso</span></span> not <span class="main">(</span><span class="entity">is_plus_const_gen</span> <span class="entity">lhs</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
        SOME <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">,</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_less</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">LESS</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">LE</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">else</span></span> NONE
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Matching function. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">find_contradiction_item</span> <span class="entity">pat</span> <span class="entity">item</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">,</span> <span class="entity">d1</span><span class="main">,</span> <span class="entity">th1</span><span class="main">)</span> <span class="main">=</span> <span class="entity">get_nat_order_info</span> <span class="entity">item</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_pattern</span> <span class="main">(</span><span class="entity">pat_l</span><span class="main">,</span> <span class="entity">pat_r</span><span class="main">,</span> <span class="entity">order_ty</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pairs</span> <span class="main">=</span> <span class="main">[</span><span class="main">(</span>false<span class="main">,</span> <span class="main">(</span><span class="entity">pat_l</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span>false<span class="main">,</span> <span class="main">(</span><span class="entity">pat_r</span><span class="main">,</span> <span class="entity">x</span><span class="main">)</span><span class="main">)</span><span class="main">]</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            map <span class="main">(</span>pair <span class="entity">order_ty</span><span class="main">)</span>
                <span class="main">(</span><span class="entity">Matcher.rewrite_match_list</span> <span class="entity">ctxt</span> <span class="entity">pairs</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">insts</span> <span class="main">=</span> <span class="entity">process_pattern</span> <span class="main">(</span><span class="entity">analyze_pattern</span> <span class="entity">pat</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">insts2</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">analyze_pattern2</span> <span class="entity">pat</span> <span class="keyword2"><span class="keyword">of</span></span>
                       NONE <span class="main">=&gt;</span> <span class="main">[</span><span class="main">]</span> <span class="main">|</span> SOME <span class="entity">pattern</span> <span class="main">=&gt;</span> <span class="entity">process_pattern</span> <span class="entity">pattern</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_inst</span> <span class="main">(</span><span class="entity">order_ty</span><span class="main">,</span> <span class="main">(</span><span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">inst'</span><span class="main">)</span><span class="main">,</span> <span class="entity">eq_ths</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">eq_th1</span><span class="main">,</span> <span class="entity">eq_th2</span><span class="main">)</span> <span class="main">=</span> <span class="entity">the_pair</span> <span class="entity">eq_ths</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">assum</span> <span class="main">=</span> <span class="entity">pat</span> |&gt; <span class="entity">Util.subst_term_norm</span> <span class="entity">inst'</span>
                            |&gt; <span class="entity">mk_Trueprop</span> |&gt; Thm.cterm_of <span class="entity">ctxt</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th2</span> <span class="main">=</span> <span class="entity">assum</span> |&gt; Thm.assume
                            |&gt; <span class="entity">apply_to_thm'</span> <span class="main">(</span>Conv.arg1_conv <span class="main">(</span><span class="entity">rewr_side</span> <span class="entity">eq_th1</span><span class="main">)</span><span class="main">)</span>
                            |&gt; <span class="entity">apply_to_thm'</span> <span class="main">(</span>Conv.arg_conv <span class="main">(</span><span class="entity">rewr_side</span> <span class="entity">eq_th2</span><span class="main">)</span><span class="main">)</span>
                            |&gt; <span class="entity">to_normal_th</span> <span class="entity">order_ty</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">d2</span><span class="main">)</span> <span class="main">=</span> <span class="entity">dest_ineq_th</span> <span class="entity">th2</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">d1</span> + <span class="entity">d2</span> &lt; <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span>
              <span class="main">[</span><span class="main">(</span><span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">inst'</span><span class="main">)</span><span class="main">,</span>
                <span class="main">(</span><span class="entity">order_trans_resolve</span> <span class="entity">th1</span> <span class="entity">th2</span><span class="main">)</span>
                    |&gt; Thm.implies_intr <span class="entity">assum</span>
                    |&gt; <span class="entity">apply_to_thm</span> <span class="entity">UtilLogic.rewrite_from_contra_form</span><span class="main">)</span><span class="main">]</span>
            <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="main">]</span>
          <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">in</span></span>
      maps <span class="entity">process_inst</span> <span class="main">(</span><span class="entity">insts</span> @ <span class="entity">insts2</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">nat_order_match</span> <span class="entity">pat</span> <span class="entity">item</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span><span class="entity">is_order_pat</span> <span class="entity">ctxt</span> <span class="entity">pat</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span> <span class="keyword2"><span class="keyword">else</span></span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">is_neg</span> <span class="main">=</span> <span class="entity">is_neg</span> <span class="entity">pat</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">neg_pat</span> <span class="main">=</span> <span class="entity">get_neg_order</span> <span class="entity">pat</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">res</span> <span class="main">=</span> <span class="entity">find_contradiction_item</span> <span class="entity">neg_pat</span> <span class="entity">item</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_neg</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">res</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">res</span> |&gt; map <span class="main">(</span>apsnd <span class="main">(</span><span class="entity">apply_to_thm'</span> <span class="entity">UtilArith.neg_ineq_cv</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">nat_order_pre_match</span> <span class="entity">pat</span> <span class="entity">item</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span><span class="entity">is_order_pat</span> <span class="entity">ctxt</span> <span class="entity">pat</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> false <span class="keyword2"><span class="keyword">else</span></span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">neg_pat</span> <span class="main">=</span> <span class="entity">get_neg_order</span> <span class="entity">pat</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">get_nat_order_info</span> <span class="entity">item</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_pattern</span> <span class="main">(</span><span class="entity">pat_l</span><span class="main">,</span> <span class="entity">pat_r</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span>
          <span class="entity">Matcher.pre_match</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">pat_l</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span> <span class="keyword1"><span class="keyword">andalso</span></span>
          <span class="entity">Matcher.pre_match</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">pat_r</span><span class="main">,</span> <span class="entity">x</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">match1</span> <span class="main">=</span> <span class="entity">process_pattern</span> <span class="main">(</span><span class="entity">analyze_pattern</span> <span class="entity">neg_pat</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">match2</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">analyze_pattern2</span> <span class="entity">neg_pat</span> <span class="keyword2"><span class="keyword">of</span></span>
                       NONE <span class="main">=&gt;</span> false <span class="main">|</span> SOME <span class="entity">pattern</span> <span class="main">=&gt;</span> <span class="entity">process_pattern</span> <span class="entity">pattern</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">match1</span> <span class="keyword1"><span class="keyword">orelse</span></span> <span class="entity">match2</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Prop-matching with a NAT_ORDER item. *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">nat_order_matcher</span> <span class="main">=</span>
    <span class="main">{</span>pre_match <span class="main">=</span> <span class="entity">nat_order_pre_match</span><span class="main">,</span> match <span class="main">=</span> <span class="entity">nat_order_match</span><span class="main">}</span>

<span class="comment1">(* Use x &lt; y to match x ~= y. *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">nat_order_noteq_matcher</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_insts</span> <span class="entity">pat</span> <span class="entity">item</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span><span class="entity">is_neg</span> <span class="entity">pat</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_eq_term</span> <span class="main">(</span><span class="entity">dest_not</span> <span class="entity">pat</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">A</span><span class="main">,</span> <span class="entity">B</span><span class="main">)</span> <span class="main">=</span> <span class="entity">pat</span> |&gt; <span class="entity">dest_not</span> |&gt; <span class="entity">dest_eq</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">cx</span><span class="main">,</span> <span class="entity">cy</span><span class="main">,</span> <span class="entity">n</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">get_nat_order_info</span> <span class="entity">item</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">n</span> &gt;= <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
            <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="entity">Matcher.rewrite_match_list</span>
                      <span class="entity">ctxt</span> <span class="main">[</span><span class="main">(</span>false<span class="main">,</span> <span class="main">(</span><span class="entity">A</span><span class="main">,</span> <span class="entity">cx</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span>false<span class="main">,</span> <span class="main">(</span><span class="entity">B</span><span class="main">,</span> <span class="entity">cy</span><span class="main">)</span><span class="main">)</span><span class="main">]</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span><span class="main">,</span>
                  <span class="entity">Matcher.rewrite_match_list</span>
                      <span class="entity">ctxt</span> <span class="main">[</span><span class="main">(</span>false<span class="main">,</span> <span class="main">(</span><span class="entity">B</span><span class="main">,</span> <span class="entity">cx</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span>false<span class="main">,</span> <span class="main">(</span><span class="entity">A</span><span class="main">,</span> <span class="entity">cy</span><span class="main">)</span><span class="main">)</span><span class="main">]</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pre_match</span> <span class="entity">pat</span> <span class="entity">item</span> <span class="entity">ctxt</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span><span class="entity">is_neg</span> <span class="entity">pat</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_eq_term</span> <span class="main">(</span><span class="entity">dest_not</span> <span class="entity">pat</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> false
          <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">A</span><span class="main">,</span> <span class="entity">B</span><span class="main">)</span> <span class="main">=</span> <span class="entity">pat</span> |&gt; <span class="entity">dest_not</span> |&gt; <span class="entity">dest_eq</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">cx</span><span class="main">,</span> <span class="entity">cy</span><span class="main">,</span> <span class="entity">n</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">get_nat_order_info</span> <span class="entity">item</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="entity">n</span> &lt; <span class="inner_numeral">0</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">Matcher.pre_match</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">A</span><span class="main">,</span> <span class="entity">cx</span><span class="main">)</span> <span class="keyword1"><span class="keyword">andalso</span></span>
                            <span class="entity">Matcher.pre_match</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">B</span><span class="main">,</span> <span class="entity">cy</span><span class="main">)</span><span class="main">)</span> <span class="keyword1"><span class="keyword">orelse</span></span>
                           <span class="main">(</span><span class="entity">Matcher.pre_match</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">A</span><span class="main">,</span> <span class="entity">cy</span><span class="main">)</span> <span class="keyword1"><span class="keyword">andalso</span></span>
                            <span class="entity">Matcher.pre_match</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">A</span><span class="main">,</span> <span class="entity">cx</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">match</span> <span class="entity">pat</span> <span class="entity">item</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">Util.has_vars</span> <span class="entity">pat</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span> <span class="keyword2"><span class="keyword">else</span></span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">instAB</span><span class="main">,</span> <span class="entity">instBA</span><span class="main">)</span> <span class="main">=</span> <span class="entity">get_insts</span> <span class="entity">pat</span> <span class="entity">item</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_inst</span> <span class="main">(</span><span class="entity">inst'</span><span class="main">,</span> <span class="entity">ths</span><span class="main">)</span> <span class="main">=</span>
                <span class="keyword2"><span class="keyword">let</span></span>
                  <span class="comment1">(* eq_x: (A/B) = x, eq_y: (B/A) = y *)</span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">eq_x</span><span class="main">,</span> <span class="entity">eq_y</span><span class="main">)</span> <span class="main">=</span> <span class="entity">the_pair</span> <span class="entity">ths</span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">n</span><span class="main">,</span> <span class="entity">prop</span><span class="main">)</span> <span class="main">=</span> <span class="entity">item</span> |&gt; <span class="entity">get_nat_order_info</span>
                                             |&gt; <span class="entity">rewrite_info_x</span> <span class="main">(</span><span class="entity">meta_sym</span> <span class="entity">eq_x</span><span class="main">)</span>
                                             |&gt; <span class="entity">rewrite_info_y</span> <span class="main">(</span><span class="entity">meta_sym</span> <span class="entity">eq_y</span><span class="main">)</span>
                <span class="keyword2"><span class="keyword">in</span></span>
                  <span class="main">(</span><span class="entity">inst'</span><span class="main">,</span> <span class="main">[</span><span class="entity">prop</span><span class="main">,</span> <span class="entity">nat_less_th</span> <span class="inner_numeral">0</span> <span class="main">(</span>~<span class="entity">n</span><span class="main">)</span><span class="main">]</span>
                              MRS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> nat_ineq_impl_not_eq<span class="antiquote">}</span></span></span><span class="main">)</span>
                <span class="keyword2"><span class="keyword">end</span></span>
            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">switch_ineq</span> <span class="main">(</span><span class="entity">inst'</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">inst'</span><span class="main">,</span> <span class="entity">th</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> HOL.not_sym<span class="antiquote">}</span></span></span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            map <span class="entity">process_inst</span> <span class="entity">instAB</span> @ <span class="main">(</span>map <span class="main">(</span><span class="entity">switch_ineq</span> o <span class="entity">process_inst</span><span class="main">)</span> <span class="entity">instBA</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">{</span>pre_match <span class="main">=</span> <span class="entity">pre_match</span><span class="main">,</span> match <span class="main">=</span> <span class="entity">match</span><span class="main">}</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Given pattern pat, find substitutions of pat that give rise to a
   contradiction.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">find_contradiction</span> <span class="entity">pat</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_pattern</span> <span class="main">(</span><span class="entity">pat_l</span><span class="main">,</span> <span class="entity">pat_r</span><span class="main">,</span> <span class="entity">order_ty</span><span class="main">)</span> <span class="main">=</span>
          map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">eq_th</span><span class="main">)</span> <span class="main">=&gt;</span>
                  <span class="main">(</span><span class="entity">order_ty</span><span class="main">,</span>
                   <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">eq_th</span><span class="main">,</span> Thm.reflexive <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">pat_r</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
              <span class="main">(</span><span class="entity">RewriteTable.equiv_info_t</span> <span class="entity">ctxt</span> <span class="entity">id</span> <span class="main">(</span><span class="entity">pat_l</span><span class="main">,</span> <span class="entity">pat_r</span><span class="main">)</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">insts</span> <span class="main">=</span> <span class="entity">process_pattern</span> <span class="main">(</span><span class="entity">analyze_pattern</span> <span class="entity">pat</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">insts2</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">analyze_pattern2</span> <span class="entity">pat</span> <span class="keyword2"><span class="keyword">of</span></span>
                       NONE <span class="main">=&gt;</span> <span class="main">[</span><span class="main">]</span> <span class="main">|</span> SOME <span class="entity">pattern</span> <span class="main">=&gt;</span> <span class="entity">process_pattern</span> <span class="entity">pattern</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_inst</span> <span class="main">(</span><span class="entity">order_ty</span><span class="main">,</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">eq_th1</span><span class="main">,</span> <span class="entity">eq_th2</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">assum</span> <span class="main">=</span> <span class="entity">pat</span> |&gt; <span class="entity">Util.subst_term_norm</span> <span class="entity">inst</span>
                            |&gt; <span class="entity">mk_Trueprop</span> |&gt; Thm.cterm_of <span class="entity">ctxt</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">norm_th</span> <span class="main">=</span>
                <span class="entity">assum</span> |&gt; Thm.assume
                      |&gt; <span class="entity">apply_to_thm'</span> <span class="main">(</span>Conv.arg1_conv <span class="main">(</span><span class="entity">rewr_side</span> <span class="entity">eq_th1</span><span class="main">)</span><span class="main">)</span>
                      |&gt; <span class="entity">apply_to_thm'</span> <span class="main">(</span>Conv.arg_conv <span class="main">(</span><span class="entity">rewr_side</span> <span class="entity">eq_th2</span><span class="main">)</span><span class="main">)</span>
                      |&gt; <span class="entity">to_normal_th</span> <span class="entity">order_ty</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Util.dest_binop_args</span> <span class="main">(</span><span class="entity">prop_of'</span> <span class="entity">norm_th</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_plus_const</span> <span class="entity">lhs</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">dest_arg1</span> <span class="entity">lhs</span> aconv <span class="entity">rhs</span> <span class="keyword2"><span class="keyword">then</span></span>
              <span class="keyword2"><span class="keyword">let</span></span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">d</span> <span class="main">=</span> <span class="entity">dest_numc</span> <span class="main">(</span><span class="entity">dest_arg</span> <span class="entity">lhs</span><span class="main">)</span>
              <span class="keyword2"><span class="keyword">in</span></span>
                <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">d</span> <span class="main">=</span> <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span> <span class="keyword2"><span class="keyword">else</span></span>
                <span class="main">[</span><span class="main">(</span><span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span><span class="main">,</span>
                  <span class="main">(</span><span class="main">[</span><span class="entity">nat_less_th</span> <span class="inner_numeral">0</span> <span class="entity">d</span><span class="main">,</span> <span class="entity">norm_th</span><span class="main">]</span> MRS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> single_resolve<span class="antiquote">}</span></span></span><span class="main">)</span>
                      |&gt; Thm.implies_intr <span class="entity">assum</span>
                      |&gt; <span class="entity">apply_to_thm</span> <span class="entity">UtilLogic.rewrite_from_contra_form</span><span class="main">)</span><span class="main">]</span>
              <span class="keyword2"><span class="keyword">end</span></span>
            <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="main">]</span>
          <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">in</span></span>
      maps <span class="entity">process_inst</span> <span class="main">(</span><span class="entity">insts</span> @ <span class="entity">insts2</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* For patterns in the form m &lt; n, where m and n are constants. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">find_contradiction_trivial</span> <span class="entity">pat</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">A</span><span class="main">,</span> <span class="entity">B</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Util.dest_binop_args</span> <span class="entity">pat</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span><span class="entity">is_numc</span> <span class="entity">A</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_numc</span> <span class="entity">B</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span> <span class="keyword2"><span class="keyword">else</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span><span class="entity">is_less</span> <span class="entity">pat</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">dest_numc</span> <span class="entity">A</span> &gt;= <span class="entity">dest_numc</span> <span class="entity">B</span><span class="main">)</span> <span class="keyword1"><span class="keyword">andalso</span></span>
         not <span class="main">(</span><span class="entity">is_less_eq</span> <span class="entity">pat</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">dest_numc</span> <span class="entity">A</span> &gt; <span class="entity">dest_numc</span> <span class="entity">B</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">assum</span> <span class="main">=</span> <span class="entity">pat</span> |&gt; <span class="entity">mk_Trueprop</span> |&gt; Thm.cterm_of <span class="entity">ctxt</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">[</span><span class="main">(</span><span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span><span class="main">,</span>
          <span class="main">(</span><span class="entity">UtilArith.contra_by_arith</span> <span class="entity">ctxt</span> <span class="main">[</span>Thm.assume <span class="entity">assum</span><span class="main">]</span><span class="main">)</span>
              |&gt; Thm.implies_intr <span class="entity">assum</span>
              |&gt; <span class="entity">apply_to_thm</span> <span class="entity">UtilLogic.rewrite_from_contra_form</span><span class="main">)</span><span class="main">]</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* For patterns in the form x &lt; 0. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">find_contradiction_trivial2</span> <span class="entity">pat</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">B</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Util.dest_binop_args</span> <span class="entity">pat</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_less</span> <span class="entity">pat</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">B</span> aconv <span class="entity">nat0</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">assum</span> <span class="main">=</span> <span class="entity">pat</span> |&gt; <span class="entity">mk_Trueprop</span> |&gt; Thm.cterm_of <span class="entity">ctxt</span>
        <span class="keyword2"><span class="keyword">in</span></span>
          <span class="main">[</span><span class="main">(</span><span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span><span class="main">,</span>
            <span class="main">(</span><span class="main">[</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Nat.not_less0<span class="antiquote">}</span></span></span><span class="main">,</span> Thm.assume <span class="entity">assum</span><span class="main">]</span> MRS <span class="entity">UtilBase.contra_triv_th</span><span class="main">)</span>
                |&gt; Thm.implies_intr <span class="entity">assum</span>
                |&gt; <span class="entity">apply_to_thm</span> <span class="entity">UtilLogic.rewrite_from_contra_form</span><span class="main">)</span><span class="main">]</span>
        <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Using term x to justify propositions of the form x &lt;= x + n, where
   n &gt;= 0. This follows the same general outline as nat_order_match.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">nat_order_single_match</span> <span class="entity">pat</span> <span class="main">_</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span><span class="entity">is_order_pat</span> <span class="entity">ctxt</span> <span class="entity">pat</span><span class="main">)</span> <span class="keyword1"><span class="keyword">orelse</span></span> <span class="entity">Util.has_vars</span> <span class="entity">pat</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span> <span class="keyword2"><span class="keyword">else</span></span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">is_neg</span> <span class="main">=</span> <span class="entity">is_neg</span> <span class="entity">pat</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">neg_pat</span> <span class="main">=</span> <span class="entity">get_neg_order</span> <span class="entity">pat</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">A</span><span class="main">,</span> <span class="entity">B</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Util.dest_binop_args</span> <span class="entity">neg_pat</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">res</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_less</span> <span class="entity">neg_pat</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">B</span> aconv <span class="entity">nat0</span> <span class="keyword2"><span class="keyword">then</span></span>
            <span class="entity">find_contradiction_trivial2</span> <span class="entity">neg_pat</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_numc</span> <span class="entity">A</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_numc</span> <span class="entity">B</span> <span class="keyword2"><span class="keyword">then</span></span>
            <span class="entity">find_contradiction_trivial</span> <span class="entity">neg_pat</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">else</span></span>
            <span class="entity">find_contradiction</span> <span class="entity">neg_pat</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_neg</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">res</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">res</span> |&gt; map <span class="main">(</span>apsnd <span class="main">(</span><span class="entity">apply_to_thm'</span> <span class="entity">UtilArith.neg_ineq_cv</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">nat_order_single_matcher</span> <span class="main">=</span>
    <span class="main">{</span>pre_match <span class="main">=</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">pat</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> <span class="entity">is_order_pat</span> <span class="entity">ctxt</span> <span class="entity">pat</span><span class="main">)</span><span class="main">,</span>
     match <span class="main">=</span> <span class="entity">nat_order_single_match</span><span class="main">}</span>

<span class="comment1">(* Shadow the second item if it is looser than the first (same x and
   y, but larger diff.
 *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">shadow_nat_order_prfstep</span> <span class="main">=</span>
    <span class="entity">ProofStep.gen_prfstep</span>
        <span class="inner_quoted">"shadow_nat_order"</span>
        <span class="main">[</span><span class="entity">WithItem</span> <span class="main">(</span><span class="entity">TY_NAT_ORDER</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term_pat</span> <span class="quoted">"<span class="main">(</span><span class="var">?x</span><span class="main">,</span> <span class="var">?y</span><span class="main">,</span> <span class="var">?m</span><span class="main">)</span>"</span><span class="antiquote">}</span></span><span class="main">)</span><span class="main">,</span>
         <span class="entity">WithItem</span> <span class="main">(</span><span class="entity">TY_NAT_ORDER</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term_pat</span> <span class="quoted">"<span class="main">(</span><span class="var">?x</span><span class="main">,</span> <span class="var">?y</span><span class="main">,</span> <span class="var">?n</span><span class="main">)</span>"</span><span class="antiquote">}</span></span><span class="main">)</span><span class="main">,</span>
         <span class="entity">Filter</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span> <span class="main">=&gt;</span>
                    <span class="entity">dest_numc</span> <span class="main">(</span><span class="entity">lookup_inst</span> <span class="entity">inst</span> <span class="inner_quoted">"m"</span><span class="main">)</span> &lt;=
                    <span class="entity">dest_numc</span> <span class="main">(</span><span class="entity">lookup_inst</span> <span class="entity">inst</span> <span class="inner_quoted">"n"</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
         <span class="entity">ShadowSecond</span><span class="main">]</span>

<span class="comment1">(* Shadow the given item if it is trivial. There are two cases: when
   two sides are equal, and when the left side is zero (both with
   nonnegative diff).
 *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">shadow_nat_order_single</span> <span class="main">=</span>
    <span class="entity">ProofStep.gen_prfstep</span>
        <span class="inner_quoted">"shadow_nat_order_single"</span>
        <span class="main">[</span><span class="entity">WithItem</span> <span class="main">(</span><span class="entity">TY_NAT_ORDER</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term_pat</span> <span class="quoted">"<span class="main">(</span><span class="var">?x</span><span class="main">,</span> <span class="var">?x</span><span class="main">,</span> <span class="var">?n</span><span class="main">)</span>"</span><span class="antiquote">}</span></span><span class="main">)</span><span class="main">,</span>
         <span class="entity">Filter</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">dest_numc</span> <span class="main">(</span><span class="entity">lookup_inst</span> <span class="entity">inst</span> <span class="inner_quoted">"n"</span><span class="main">)</span> &gt;= <span class="inner_numeral">0</span><span class="main">)</span><span class="main">,</span>
         <span class="entity">ShadowFirst</span><span class="main">]</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">shadow_nat_order_single_zero</span> <span class="main">=</span>
    <span class="entity">ProofStep.gen_prfstep</span>
        <span class="inner_quoted">"shadow_nat_order_single_zero"</span>
        <span class="main">[</span><span class="entity">WithItem</span> <span class="main">(</span><span class="entity">TY_NAT_ORDER</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term_pat</span> <span class="quoted">"<span class="main">(</span><span class="main">0</span><span class="main">,</span> <span class="var">?x</span><span class="main">,</span> <span class="var">?n</span><span class="main">)</span>"</span><span class="antiquote">}</span></span><span class="main">)</span><span class="main">,</span>
         <span class="entity">Filter</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">dest_numc</span> <span class="main">(</span><span class="entity">lookup_inst</span> <span class="entity">inst</span> <span class="inner_quoted">"n"</span><span class="main">)</span> &gt;= <span class="inner_numeral">0</span><span class="main">)</span><span class="main">,</span>
         <span class="entity">ShadowFirst</span><span class="main">]</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">string_of_nat_order</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">,</span> <span class="entity">diff</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">x</span> aconv <span class="entity">nat0</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">diff</span> &lt; <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span>  <span class="comment1">(* 0 + n &lt;= y *)</span>
      <span class="entity">th</span> |&gt; <span class="entity">apply_to_thm'</span> <span class="main">(</span>Conv.arg1_conv <span class="entity">nat_fold_conv0_left</span><span class="main">)</span>
         |&gt; Thm.prop_of |&gt; Syntax.string_of_term <span class="entity">ctxt</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">y</span> aconv <span class="entity">nat0</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">diff</span> &gt;= <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span>  <span class="comment1">(* x &lt;= 0 + n *)</span>
      <span class="entity">th</span> |&gt; <span class="entity">apply_to_thm'</span> <span class="main">(</span>Conv.arg_conv <span class="entity">nat_fold_conv0_left</span><span class="main">)</span>
         |&gt; Thm.prop_of |&gt; Syntax.string_of_term <span class="entity">ctxt</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">diff</span> <span class="main">=</span> <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span>  <span class="comment1">(* x &lt;= y + 0 *)</span>
      <span class="entity">th</span> |&gt; <span class="entity">apply_to_thm'</span> <span class="main">(</span>Conv.arg_conv <span class="entity">nat_fold_conv0_right</span><span class="main">)</span>
         |&gt; Thm.prop_of |&gt; Syntax.string_of_term <span class="entity">ctxt</span>
    <span class="keyword2"><span class="keyword">else</span></span>
      <span class="entity">th</span> |&gt; Thm.prop_of |&gt; Syntax.string_of_term <span class="entity">ctxt</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">output_nat_order</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">ts</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">,</span> <span class="entity">diff_t</span><span class="main">)</span> <span class="main">=</span> <span class="entity">the_triple</span> <span class="entity">ts</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">diff</span> <span class="main">=</span> <span class="entity">dest_numc</span> <span class="entity">diff_t</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="inner_quoted">"ORDER "</span> ^ <span class="entity">string_of_nat_order</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">,</span> <span class="entity">diff</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">shadow_nat_order</span> <span class="main">_</span> <span class="main">_</span> <span class="main">(</span><span class="entity">ts1</span><span class="main">,</span> <span class="entity">cts2</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">x1</span><span class="main">,</span> <span class="entity">y1</span><span class="main">,</span> <span class="entity">m</span><span class="main">)</span> <span class="main">=</span> <span class="entity">the_triple</span> <span class="entity">ts1</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">cx2</span><span class="main">,</span> <span class="entity">cy2</span><span class="main">,</span> <span class="entity">n</span><span class="main">)</span> <span class="main">=</span> <span class="entity">the_triple</span> <span class="entity">cts2</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">m</span> <span class="main">=</span> <span class="entity">dest_numc</span> <span class="entity">m</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">n</span> <span class="main">=</span> <span class="entity">dest_numc</span> <span class="main">(</span>Thm.term_of <span class="entity">n</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">m</span> &lt; <span class="entity">n</span> <span class="keyword2"><span class="keyword">then</span></span> false <span class="keyword2"><span class="keyword">else</span></span>
      <span class="entity">x1</span> aconv Thm.term_of <span class="entity">cx2</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">y1</span> aconv Thm.term_of <span class="entity">cy2</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">add_nat_order_proofsteps</span> <span class="main">=</span>
    <span class="entity">ItemIO.add_item_type</span> <span class="main">(</span>
      <span class="entity">TY_NAT_ORDER</span><span class="main">,</span> SOME <span class="main">(</span>take <span class="inner_numeral">2</span><span class="main">)</span><span class="main">,</span> SOME <span class="entity">output_nat_order</span><span class="main">,</span> SOME <span class="entity">shadow_nat_order</span>

    <span class="main">)</span> #&gt; <span class="entity">ItemIO.add_typed_matcher</span> <span class="main">(</span>
      <span class="entity">TY_NAT_ORDER</span><span class="main">,</span> <span class="entity">nat_order_typed_matcher</span>

    <span class="main">)</span> #&gt; fold <span class="entity">ItemIO.add_prop_matcher</span> <span class="main">[</span>
      <span class="main">(</span><span class="entity">TY_NAT_ORDER</span><span class="main">,</span> <span class="entity">nat_order_matcher</span><span class="main">)</span><span class="main">,</span>
      <span class="main">(</span><span class="entity">TY_NAT_ORDER</span><span class="main">,</span> <span class="entity">nat_order_noteq_matcher</span><span class="main">)</span><span class="main">,</span>
      <span class="main">(</span><span class="entity">TY_NULL</span><span class="main">,</span> <span class="entity">nat_order_single_matcher</span><span class="main">)</span>

    <span class="main">]</span> #&gt; <span class="entity">Normalizer.add_normalizer</span> <span class="main">(</span>
      <span class="main">(</span><span class="inner_quoted">"nat_order"</span><span class="main">,</span> <span class="entity">nat_order_normalizer</span><span class="main">)</span>

    <span class="main">)</span> #&gt; fold <span class="entity">add_prfstep</span> <span class="main">[</span>
      <span class="entity">nat_eq_diff_prfstep</span><span class="main">,</span>
      <span class="entity">transitive</span><span class="main">,</span> <span class="entity">transitive_resolve</span><span class="main">,</span> <span class="entity">single_resolve</span><span class="main">,</span> <span class="entity">single_resolve_zero</span><span class="main">,</span>
      <span class="entity">shadow_nat_order_prfstep</span><span class="main">,</span> <span class="entity">shadow_nat_order_single</span><span class="main">,</span>
      <span class="entity">shadow_nat_order_single_zero</span>
    <span class="main">]</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> Theory.setup <span class="main">(</span><span class="entity">Nat_Order.add_nat_order_proofsteps</span><span class="main">)</span>
</pre>
</div><div id="files/order_test.ML">
<div class="head">
<h1>File ‹order_test.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*
  File: order_test.ML
  Author: Bohua Zhan

  Unit test for order.ML.
*)</span>

<span class="keyword2"><span class="keyword">local</span></span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">theory</span><span class="antiquote">}</span></span></span>

  <span class="comment1">(* Set up rewrite table and incremental context. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">x</span> <span class="main">=</span> Free <span class="main">(</span><span class="inner_quoted">"x"</span><span class="main">,</span> <span class="entity">natT</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">x'</span> <span class="main">=</span> Free <span class="main">(</span><span class="inner_quoted">"x'"</span><span class="main">,</span> <span class="entity">natT</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">y</span> <span class="main">=</span> Free <span class="main">(</span><span class="inner_quoted">"y"</span><span class="main">,</span> <span class="entity">natT</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">y'</span> <span class="main">=</span> Free <span class="main">(</span><span class="inner_quoted">"y'"</span><span class="main">,</span> <span class="entity">natT</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">z</span> <span class="main">=</span> Free <span class="main">(</span><span class="inner_quoted">"z"</span><span class="main">,</span> <span class="entity">natT</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">w</span> <span class="main">=</span> Free <span class="main">(</span><span class="inner_quoted">"w"</span><span class="main">,</span> <span class="entity">natT</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">px</span> <span class="main">=</span> Var <span class="main">(</span><span class="main">(</span><span class="inner_quoted">"x"</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span><span class="main">,</span> <span class="entity">natT</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">py</span> <span class="main">=</span> Var <span class="main">(</span><span class="main">(</span><span class="inner_quoted">"y"</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span><span class="main">,</span> <span class="entity">natT</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt'</span> <span class="main">=</span> <span class="entity">ctxt</span> |&gt; fold Variable.declare_term <span class="main">[</span><span class="entity">x</span><span class="main">,</span> <span class="entity">x'</span><span class="main">,</span> <span class="entity">y</span><span class="main">,</span> <span class="entity">y'</span><span class="main">,</span> <span class="entity">z</span><span class="main">,</span> <span class="entity">w</span><span class="main">,</span> <span class="entity">px</span><span class="main">,</span> <span class="entity">py</span><span class="main">]</span>
                   |&gt; <span class="entity">RewriteTable.add_rewrite</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">assume_eq</span> <span class="entity">thy</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">x'</span><span class="main">)</span><span class="main">)</span> |&gt; snd
<span class="keyword2"><span class="keyword">in</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_fold_double_plus</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">err_str</span> <span class="main">=</span> <span class="inner_quoted">"test_fold_double_plus"</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_data</span> <span class="main">=</span> <span class="main">[</span>
        <span class="main">(</span><span class="inner_quoted">"x"</span><span class="main">,</span> <span class="inner_quoted">"x"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"x + 1"</span><span class="main">,</span> <span class="inner_quoted">"x + 1"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"(x + 1) + 1"</span><span class="main">,</span> <span class="inner_quoted">"x + 2"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"((x + 1) + 1) + 1"</span><span class="main">,</span> <span class="inner_quoted">"x + 3"</span><span class="main">)</span>
      <span class="main">]</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      map <span class="main">(</span><span class="entity">Util.test_conv</span> <span class="entity">ctxt'</span> <span class="entity">Nat_Order.fold_double_plus</span> <span class="entity">err_str</span><span class="main">)</span> <span class="entity">test_data</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Convert proposition to nat_order item, by applying one of the
   proofsteps in to_nat_order_prfsteps.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">convert_prop_to_nat_order</span> <span class="entity">prop</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th</span> <span class="main">=</span> <span class="entity">prop</span> |&gt; <span class="entity">mk_Trueprop</span> |&gt; <span class="entity">Util.assume_thm</span> <span class="entity">ctxt'</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">Nat_Order.th_to_normed_ritems</span> <span class="entity">th</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_parse_prop</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">string_of_spec</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">,</span> <span class="entity">diff</span><span class="main">)</span> <span class="main">=</span>
          <span class="inner_quoted">"("</span> ^ <span class="main">(</span><span class="entity">Util.string_of_terms</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">,</span> <span class="entity">mk_nat</span> <span class="entity">diff</span><span class="main">]</span><span class="main">)</span> ^ <span class="inner_quoted">")"</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ritem_to_spec</span> <span class="entity">ritem</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">ritem</span> <span class="keyword2"><span class="keyword">of</span></span>
              <span class="entity">Fact</span> <span class="main">(</span><span class="inner_quoted">"NAT_ORDER"</span><span class="main">,</span> <span class="entity">tname</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span>
              <span class="keyword2"><span class="keyword">let</span></span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">,</span> <span class="entity">diff_t</span><span class="main">)</span> <span class="main">=</span> <span class="entity">the_triple</span> <span class="entity">tname</span>
              <span class="keyword2"><span class="keyword">in</span></span>
                <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">,</span> <span class="entity">UtilArith.dest_numc</span> <span class="entity">diff_t</span><span class="main">)</span>
              <span class="keyword2"><span class="keyword">end</span></span>
            <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"ritem_to_spec"</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">eq_specs</span> <span class="main">(</span><span class="main">(</span><span class="entity">x1</span><span class="main">,</span> <span class="entity">y1</span><span class="main">,</span> <span class="entity">diff1</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">x2</span><span class="main">,</span> <span class="entity">y2</span><span class="main">,</span> <span class="entity">diff2</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
          <span class="entity">x1</span> aconv <span class="entity">x2</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">y1</span> aconv <span class="entity">y2</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">diff1</span> <span class="main">=</span> <span class="entity">diff2</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">test</span> <span class="main">(</span><span class="entity">prop_str</span><span class="main">,</span> <span class="entity">specs_str</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prop</span> <span class="main">=</span> Syntax.read_term <span class="entity">ctxt'</span> <span class="entity">prop_str</span>
            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">read_spec</span> <span class="main">(</span><span class="entity">x_str</span><span class="main">,</span> <span class="entity">y_str</span><span class="main">,</span> <span class="entity">diff</span><span class="main">)</span> <span class="main">=</span>
                <span class="main">(</span>Syntax.read_term <span class="entity">ctxt'</span> <span class="entity">x_str</span><span class="main">,</span>
                 Syntax.read_term <span class="entity">ctxt'</span> <span class="entity">y_str</span><span class="main">,</span> <span class="entity">diff</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">specs</span> <span class="main">=</span> map <span class="entity">read_spec</span> <span class="entity">specs_str</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">specs'</span> <span class="main">=</span> <span class="entity">convert_prop_to_nat_order</span> <span class="entity">prop</span> |&gt; map <span class="entity">ritem_to_spec</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="keyword2"><span class="keyword">if</span></span> eq_set <span class="entity">eq_specs</span> <span class="main">(</span><span class="entity">specs</span><span class="main">,</span> <span class="entity">specs'</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">)</span>
            <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> tracing <span class="main">(</span>
                    <span class="inner_quoted">"Expected:"</span> ^ <span class="main">(</span><span class="entity">Util.string_of_list</span> <span class="entity">string_of_spec</span> <span class="entity">specs</span><span class="main">)</span> ^ <span class="inner_quoted">"\n"</span> ^
                    <span class="inner_quoted">"Actual:"</span> ^ <span class="main">(</span><span class="entity">Util.string_of_list</span> <span class="entity">string_of_spec</span> <span class="entity">specs'</span><span class="main">)</span><span class="main">)</span>
            <span class="keyword2"><span class="keyword">in</span></span>
              <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"test_parse_prop"</span>
            <span class="keyword2"><span class="keyword">end</span></span>
          <span class="keyword2"><span class="keyword">end</span></span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_data</span> <span class="main">=</span> <span class="main">[</span>
        <span class="main">(</span><span class="inner_quoted">"x &lt;= y"</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="inner_quoted">"x"</span><span class="main">,</span> <span class="inner_quoted">"y"</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"x + 1 &lt;= y"</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="inner_quoted">"x"</span><span class="main">,</span> <span class="inner_quoted">"y"</span><span class="main">,</span> <span class="inner_numeral">~1</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"x - 1 &lt;= y"</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="inner_quoted">"x"</span><span class="main">,</span> <span class="inner_quoted">"y"</span><span class="main">,</span> <span class="inner_numeral">1</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="inner_quoted">"x-1"</span><span class="main">,</span> <span class="inner_quoted">"y"</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"x &lt;= y + 1"</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="inner_quoted">"x"</span><span class="main">,</span> <span class="inner_quoted">"y"</span><span class="main">,</span> <span class="inner_numeral">1</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"x &lt;= y - 1"</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="inner_quoted">"x"</span><span class="main">,</span> <span class="inner_quoted">"y"</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="inner_quoted">"x"</span><span class="main">,</span> <span class="inner_quoted">"y-1"</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>  <span class="comment1">(* special case *)</span>
        <span class="main">(</span><span class="inner_quoted">"x &lt; y"</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="inner_quoted">"x"</span><span class="main">,</span> <span class="inner_quoted">"y"</span><span class="main">,</span> <span class="inner_numeral">~1</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"x + 1 &lt; y"</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="inner_quoted">"x"</span><span class="main">,</span> <span class="inner_quoted">"y"</span><span class="main">,</span> <span class="inner_numeral">~2</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"x - 1 &lt; y"</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="inner_quoted">"x"</span><span class="main">,</span> <span class="inner_quoted">"y"</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="inner_quoted">"x-1"</span><span class="main">,</span> <span class="inner_quoted">"y"</span><span class="main">,</span> <span class="inner_numeral">~1</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"x &lt; y + 1"</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="inner_quoted">"x"</span><span class="main">,</span> <span class="inner_quoted">"y"</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"x &lt; y - 1"</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="inner_quoted">"x"</span><span class="main">,</span> <span class="inner_quoted">"y"</span><span class="main">,</span> <span class="inner_numeral">~2</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="inner_quoted">"x"</span><span class="main">,</span> <span class="inner_quoted">"y-1"</span><span class="main">,</span> <span class="inner_numeral">~1</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"x &lt;= 3"</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="inner_quoted">"x"</span><span class="main">,</span> <span class="inner_quoted">"0::nat"</span><span class="main">,</span> <span class="inner_numeral">3</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"x &lt; 3"</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="inner_quoted">"x"</span><span class="main">,</span> <span class="inner_quoted">"0::nat"</span><span class="main">,</span> <span class="inner_numeral">2</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"x &lt;= 0"</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="inner_quoted">"x"</span><span class="main">,</span> <span class="inner_quoted">"0::nat"</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"x &lt; 0"</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="inner_quoted">"x"</span><span class="main">,</span> <span class="inner_quoted">"0::nat"</span><span class="main">,</span> <span class="inner_numeral">~1</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"x &gt;= 3"</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="inner_quoted">"0::nat"</span><span class="main">,</span> <span class="inner_quoted">"x"</span><span class="main">,</span> <span class="inner_numeral">~3</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"x &gt; 3"</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="inner_quoted">"0::nat"</span><span class="main">,</span> <span class="inner_quoted">"x"</span><span class="main">,</span> <span class="inner_numeral">~4</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"x &gt;= 0"</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="inner_quoted">"0::nat"</span><span class="main">,</span> <span class="inner_quoted">"x"</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"x &gt; 0"</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="inner_quoted">"0::nat"</span><span class="main">,</span> <span class="inner_quoted">"x"</span><span class="main">,</span> <span class="inner_numeral">~1</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"x + 0 &lt;= y"</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="inner_quoted">"x"</span><span class="main">,</span> <span class="inner_quoted">"y"</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"x + 1 &lt;= 3"</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="inner_quoted">"x"</span><span class="main">,</span> <span class="inner_quoted">"0::nat"</span><span class="main">,</span> <span class="inner_numeral">2</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"x - 1 &lt;= 3"</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="inner_quoted">"x"</span><span class="main">,</span> <span class="inner_quoted">"0::nat"</span><span class="main">,</span> <span class="inner_numeral">4</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="inner_quoted">"x-1"</span><span class="main">,</span> <span class="inner_quoted">"0::nat"</span><span class="main">,</span> <span class="inner_numeral">3</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"(x + 1) + 1 &lt;= y + 1"</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="inner_quoted">"x"</span><span class="main">,</span> <span class="inner_quoted">"y"</span><span class="main">,</span> <span class="inner_numeral">~1</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"x + 1 &lt;= (y + 1) + 1"</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="inner_quoted">"x"</span><span class="main">,</span> <span class="inner_quoted">"y"</span><span class="main">,</span> <span class="inner_numeral">1</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"(x + 1) + 1 &lt;= (y + 1) + 1"</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="inner_quoted">"x"</span><span class="main">,</span> <span class="inner_quoted">"y"</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span><span class="main">]</span><span class="main">)</span>
      <span class="main">]</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> map <span class="entity">test</span> <span class="entity">test_data</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">(</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_nat_order_match</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">test</span> <span class="entity">match_fn</span> <span class="main">(</span><span class="entity">pat_str</span><span class="main">,</span> <span class="entity">prop_str</span><span class="main">,</span> <span class="entity">res_strs</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pat</span> <span class="main">=</span> Proof_Context.read_term_pattern <span class="entity">ctxt'</span> <span class="entity">pat_str</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prop</span> <span class="main">=</span> Syntax.read_term <span class="entity">ctxt'</span> <span class="entity">prop_str</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ritems</span> <span class="main">=</span> <span class="entity">convert_prop_to_nat_order</span> <span class="entity">prop</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ritem</span> <span class="main">=</span> the_single <span class="entity">ritems</span>
                        <span class="keyword3"><span class="keyword">handle</span></span> List.Empty <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"ambiguous input"</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">item</span> <span class="main">=</span> <span class="entity">BoxItem.mk_box_item</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="inner_numeral">0</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">,</span> <span class="entity">ritem</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">res</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">mk_Trueprop</span> o Syntax.read_term <span class="entity">ctxt'</span><span class="main">)</span> <span class="entity">res_strs</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">res'</span> <span class="main">=</span> <span class="entity">match_fn</span> <span class="entity">pat</span> <span class="entity">item</span> <span class="entity">ctxt'</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">fo_init</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">check_inst</span> <span class="main">(</span><span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=</span>
                <span class="main">(</span><span class="entity">Util.subst_term_norm</span> <span class="entity">inst</span> <span class="entity">pat</span><span class="main">)</span> aconv <span class="main">(</span><span class="entity">prop_of'</span> <span class="entity">th</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">check_res</span> <span class="main">=</span>
                eq_list <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv<span class="main">)</span> <span class="main">(</span><span class="entity">res</span><span class="main">,</span> map <span class="main">(</span>Thm.prop_of o snd<span class="main">)</span> <span class="entity">res'</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="keyword2"><span class="keyword">if</span></span> forall <span class="entity">check_inst</span> <span class="entity">res'</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">check_res</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">)</span>
            <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_tlist</span> <span class="entity">ctxt'</span> <span class="inner_quoted">"pat, prop:"</span> <span class="main">[</span><span class="entity">pat</span><span class="main">,</span> <span class="entity">prop</span><span class="main">]</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_tlist</span> <span class="entity">ctxt'</span> <span class="inner_quoted">"Expected:"</span> <span class="entity">res</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_tlist</span> <span class="entity">ctxt'</span> <span class="inner_quoted">"Actual:"</span> <span class="main">(</span>map <span class="main">(</span>Thm.prop_of o snd<span class="main">)</span> <span class="entity">res'</span><span class="main">)</span>
            <span class="keyword2"><span class="keyword">in</span></span>
              <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"test_nat_order_match"</span>
            <span class="keyword2"><span class="keyword">end</span></span>
          <span class="keyword2"><span class="keyword">end</span></span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_data</span> <span class="main">=</span> <span class="main">[</span>
        <span class="main">(</span><span class="inner_quoted">"x &lt;= y"</span><span class="main">,</span> <span class="inner_quoted">"x &lt;= y"</span><span class="main">,</span> <span class="main">[</span><span class="inner_quoted">"x &lt;= y"</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"x &lt; y"</span><span class="main">,</span> <span class="inner_quoted">"x &lt;= y"</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"x &lt; y"</span><span class="main">,</span> <span class="inner_quoted">"x &lt; y"</span><span class="main">,</span> <span class="main">[</span><span class="inner_quoted">"x &lt; y"</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"x &lt;= y"</span><span class="main">,</span> <span class="inner_quoted">"x &lt; y"</span><span class="main">,</span> <span class="main">[</span><span class="inner_quoted">"x &lt;= y"</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"x &lt;= y"</span><span class="main">,</span> <span class="inner_quoted">"x' &lt;= y"</span><span class="main">,</span> <span class="main">[</span><span class="inner_quoted">"x &lt;= y"</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"x' &lt;= y"</span><span class="main">,</span> <span class="inner_quoted">"x &lt;= y"</span><span class="main">,</span> <span class="main">[</span><span class="inner_quoted">"x' &lt;= y"</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"x + 1 &lt;= y"</span><span class="main">,</span> <span class="inner_quoted">"x &lt;= y"</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"x - 1 &lt;= y"</span><span class="main">,</span> <span class="inner_quoted">"x &lt;= y"</span><span class="main">,</span> <span class="main">[</span><span class="inner_quoted">"x - 1 &lt;= y"</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"x &lt;= y + 1"</span><span class="main">,</span> <span class="inner_quoted">"x &lt;= y"</span><span class="main">,</span> <span class="main">[</span><span class="inner_quoted">"x &lt;= y + 1"</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"min ?a ?b &lt;= z"</span><span class="main">,</span> <span class="inner_quoted">"min x y &lt;= z"</span><span class="main">,</span> <span class="main">[</span><span class="inner_quoted">"min x y &lt;= z"</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"min ?a ?b + 1 &lt;= z"</span><span class="main">,</span> <span class="inner_quoted">"min x y &lt;= z"</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"min ?a ?b - 1 &lt;= z"</span><span class="main">,</span> <span class="inner_quoted">"min x y &lt;= z"</span><span class="main">,</span> <span class="main">[</span><span class="inner_quoted">"min x y - 1 &lt;= z"</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"min ?a ?b &lt;= z + 1"</span><span class="main">,</span> <span class="inner_quoted">"min x y &lt;= z"</span><span class="main">,</span> <span class="main">[</span><span class="inner_quoted">"min x y &lt;= z + 1"</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"?x &lt;= y"</span><span class="main">,</span> <span class="inner_quoted">"x &lt; y"</span><span class="main">,</span> <span class="main">[</span><span class="inner_quoted">"x &lt;= y"</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"?x &lt;= ?y"</span><span class="main">,</span> <span class="inner_quoted">"x &lt; y"</span><span class="main">,</span> <span class="main">[</span><span class="inner_quoted">"x &lt;= y"</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"?x &lt; ?y + 1"</span><span class="main">,</span> <span class="inner_quoted">"x &lt; y"</span><span class="main">,</span> <span class="main">[</span><span class="inner_quoted">"x &lt; y + 1"</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"?x &lt; ?y - 1"</span><span class="main">,</span> <span class="inner_quoted">"x + 1 &lt; y"</span><span class="main">,</span> <span class="main">[</span><span class="inner_quoted">"x &lt; y - 1"</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"0 &lt; ?x"</span><span class="main">,</span> <span class="inner_quoted">"x &gt; 3"</span><span class="main">,</span> <span class="main">[</span><span class="inner_quoted">"0 &lt; x"</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"0 &lt; ?x"</span><span class="main">,</span> <span class="inner_quoted">"x &gt;= 0"</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"0 &lt;= ?x"</span><span class="main">,</span> <span class="inner_quoted">"x &gt;= 0"</span><span class="main">,</span> <span class="main">[</span><span class="inner_quoted">"0 &lt;= x"</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"?x &lt;= 0"</span><span class="main">,</span> <span class="inner_quoted">"x &lt; 1"</span><span class="main">,</span> <span class="main">[</span><span class="inner_quoted">"x &lt;= 0"</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"?x &lt;= 0"</span><span class="main">,</span> <span class="inner_quoted">"x &lt; 2"</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"~ x &lt; y"</span><span class="main">,</span> <span class="inner_quoted">"x &gt;= y"</span><span class="main">,</span> <span class="main">[</span><span class="inner_quoted">"~ x &lt; y"</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"~ x &lt; 3"</span><span class="main">,</span> <span class="inner_quoted">"x &gt; 3"</span><span class="main">,</span> <span class="main">[</span><span class="inner_quoted">"~ x &lt; 3"</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"x &lt;= 3"</span><span class="main">,</span> <span class="inner_quoted">"x &lt; 3"</span><span class="main">,</span> <span class="main">[</span><span class="inner_quoted">"x &lt;= 3"</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"x &lt;= 3"</span><span class="main">,</span> <span class="inner_quoted">"x &lt; 4"</span><span class="main">,</span> <span class="main">[</span><span class="inner_quoted">"x &lt;= 3"</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"~ ?x &lt; ?y"</span><span class="main">,</span> <span class="inner_quoted">"x &gt;= y"</span><span class="main">,</span> <span class="main">[</span><span class="inner_quoted">"~ x &lt; y"</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"~ x &lt;= y"</span><span class="main">,</span> <span class="inner_quoted">"x &gt; y"</span><span class="main">,</span> <span class="main">[</span><span class="inner_quoted">"~ x &lt;= y"</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"~ min (?a::nat) ?b &lt;= min ?c ?d"</span><span class="main">,</span> <span class="inner_quoted">"min x y &lt; min z w"</span><span class="main">,</span>
         <span class="main">[</span><span class="inner_quoted">"~ min z w &lt;= min x y"</span><span class="main">]</span><span class="main">)</span>
      <span class="main">]</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">test</span> <span class="entity">Nat_Order.nat_order_match</span><span class="main">)</span> <span class="entity">test_data</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_noteq_data</span> <span class="main">=</span> <span class="main">[</span>
        <span class="main">(</span><span class="inner_quoted">"x ~= y"</span><span class="main">,</span> <span class="inner_quoted">"x &lt; y"</span><span class="main">,</span> <span class="main">[</span><span class="inner_quoted">"x ~= y"</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"x ~= y"</span><span class="main">,</span> <span class="inner_quoted">"y &lt; x"</span><span class="main">,</span> <span class="main">[</span><span class="inner_quoted">"x ~= y"</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"x ~= y"</span><span class="main">,</span> <span class="inner_quoted">"x &lt;= y"</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"x ~= y"</span><span class="main">,</span> <span class="inner_quoted">"y &lt;= x"</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"x ~= 0"</span><span class="main">,</span> <span class="inner_quoted">"x &gt; 0"</span><span class="main">,</span> <span class="main">[</span><span class="inner_quoted">"x ~= 0"</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"x ~= 0"</span><span class="main">,</span> <span class="inner_quoted">"x &gt; 3"</span><span class="main">,</span> <span class="main">[</span><span class="inner_quoted">"x ~= 0"</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"?a ~= y"</span><span class="main">,</span> <span class="inner_quoted">"x &lt; y"</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
      <span class="main">]</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">test</span> <span class="main">(</span><span class="main">#</span>match <span class="entity">Nat_Order.nat_order_noteq_matcher</span><span class="main">)</span><span class="main">)</span> <span class="entity">test_noteq_data</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">(</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_nat_order_single_match</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">test</span> <span class="entity">ineq_str</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ineq</span> <span class="main">=</span> Syntax.read_term <span class="entity">ctxt'</span> <span class="entity">ineq_str</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">res</span> <span class="main">=</span> <span class="entity">Nat_Order.nat_order_single_match</span>
                          <span class="entity">ineq</span> <span class="entity">BoxItem.null_item</span> <span class="entity">ctxt'</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">fo_init</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="keyword2"><span class="keyword">if</span></span> length <span class="entity">res</span> <span class="main">=</span> <span class="inner_numeral">1</span> <span class="keyword1"><span class="keyword">andalso</span></span>
               <span class="entity">res</span> |&gt; the_single |&gt; snd |&gt; <span class="entity">prop_of'</span> aconv <span class="entity">ineq</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">)</span>
            <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_t</span> <span class="entity">ctxt'</span> <span class="inner_quoted">"ineq:"</span> <span class="entity">ineq</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_tlist</span> <span class="entity">ctxt'</span> <span class="inner_quoted">"Output:"</span>
                                       <span class="main">(</span>map <span class="main">(</span>Thm.prop_of o snd<span class="main">)</span> <span class="entity">res</span><span class="main">)</span>
            <span class="keyword2"><span class="keyword">in</span></span>
              <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"test_nat_order_single_match"</span>
            <span class="keyword2"><span class="keyword">end</span></span>
          <span class="keyword2"><span class="keyword">end</span></span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_data</span> <span class="main">=</span> <span class="main">[</span>
        <span class="inner_quoted">"x &gt;= x"</span><span class="main">,</span> <span class="inner_quoted">"x + 1 &gt; x"</span><span class="main">,</span> <span class="inner_quoted">"x &gt;= x'"</span><span class="main">,</span> <span class="inner_quoted">"x + 1 &gt; x'"</span><span class="main">,</span> <span class="inner_quoted">"x' + 1 &gt; x"</span><span class="main">,</span>
        <span class="inner_quoted">"x &gt;= x - 1"</span><span class="main">,</span> <span class="inner_quoted">"x &gt;= x' - 1"</span><span class="main">,</span> <span class="inner_quoted">"x' &gt;= x - 1"</span><span class="main">,</span>
        <span class="inner_quoted">"~ x &gt; x"</span><span class="main">,</span> <span class="inner_quoted">"~ x &lt; x"</span><span class="main">,</span> <span class="inner_quoted">"(3::nat) &lt; 4"</span><span class="main">,</span> <span class="inner_quoted">"(3::nat) &lt;= 3"</span>
      <span class="main">]</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> map <span class="entity">test</span> <span class="entity">test_data</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">(</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="files/nat_sub.ML">
<div class="head">
<h1>File ‹nat_sub.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*
  File: nat_sub.ML
  Author: Bohua Zhan

  Normalization of expressions involving subtraction on natural numbers.
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">NAT_SUB</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> fheads<span class="main">:</span> term list
  <span class="keyword1"><span class="keyword">val</span></span> norm_plus1<span class="main">:</span> <span class="entity">wfconv</span>
  <span class="keyword1"><span class="keyword">val</span></span> norm_plus<span class="main">:</span> <span class="entity">wfconv</span>
  <span class="keyword1"><span class="keyword">val</span></span> norm_minus'<span class="main">:</span> <span class="entity">wfconv</span>
  <span class="keyword1"><span class="keyword">val</span></span> move_outmost<span class="main">:</span> term <span class="main">-&gt;</span> <span class="entity">wfconv</span>
  <span class="keyword1"><span class="keyword">val</span></span> cancel_terms<span class="main">:</span> <span class="entity">wfconv</span>
  <span class="keyword1"><span class="keyword">val</span></span> norm_minus<span class="main">:</span> <span class="entity">wfconv</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">monomial</span> <span class="main">=</span> cterm list * int
  <span class="keyword1"><span class="keyword">val</span></span> reduce_monomial_list<span class="main">:</span> <span class="entity">monomial</span> list <span class="main">-&gt;</span> <span class="entity">monomial</span> list
  <span class="keyword1"><span class="keyword">val</span></span> add_polynomial_list<span class="main">:</span> <span class="entity">monomial</span> list * <span class="entity">monomial</span> list <span class="main">-&gt;</span> <span class="entity">monomial</span> list
  <span class="keyword1"><span class="keyword">val</span></span> norm_minus_ct<span class="main">:</span> cterm <span class="main">-&gt;</span> <span class="entity">monomial</span> list
  <span class="keyword1"><span class="keyword">val</span></span> norm_ring_term<span class="main">:</span> cterm <span class="main">-&gt;</span> term

  <span class="keyword1"><span class="keyword">val</span></span> get_sub_head_equiv<span class="main">:</span>
      <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">box_id</span> * cterm <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * <span class="main">(</span><span class="entity">wfterm</span> * thm<span class="main">)</span><span class="main">)</span> list
  <span class="keyword1"><span class="keyword">val</span></span> nat_sub_expand_once<span class="main">:</span>
      <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">box_id</span> * <span class="entity">wfterm</span> <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * <span class="main">(</span><span class="entity">wfterm</span> * thm<span class="main">)</span><span class="main">)</span> list
  <span class="keyword1"><span class="keyword">val</span></span> nat_sub_expand<span class="main">:</span>
      <span class="entity">Proof.context</span> <span class="main">-&gt;</span> <span class="entity">box_id</span> * cterm <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * <span class="main">(</span><span class="entity">wfterm</span> * thm<span class="main">)</span><span class="main">)</span> list

  <span class="keyword1"><span class="keyword">val</span></span> nat_sub_expand_equiv<span class="main">:</span> <span class="entity">proofstep</span>
  <span class="keyword1"><span class="keyword">val</span></span> nat_sub_expand_unit<span class="main">:</span> <span class="entity">proofstep</span>

  <span class="keyword1"><span class="keyword">val</span></span> add_nat_sub_proofsteps<span class="main">:</span> theory <span class="main">-&gt;</span> theory
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">NatSub</span> <span class="main">:</span> <span class="entity">NAT_SUB</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fheads</span> <span class="main">=</span> <span class="main">[</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="main">(+)</span> <span class="main">::</span> <span class="main">(</span>nat <span class="main">=&gt;</span> nat <span class="main">=&gt;</span> nat<span class="main">)</span>"</span><span class="antiquote">}</span></span><span class="main">,</span>
              <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="main">(-)</span> <span class="main">::</span> <span class="main">(</span>nat <span class="main">=&gt;</span> nat <span class="main">=&gt;</span> nat<span class="main">)</span>"</span><span class="antiquote">}</span></span><span class="main">,</span>
              <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="main">(*)</span> <span class="main">::</span> <span class="main">(</span>nat <span class="main">=&gt;</span> nat <span class="main">=&gt;</span> nat<span class="main">)</span>"</span><span class="antiquote">}</span></span><span class="main">]</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">plus_info</span> <span class="main">=</span> <span class="entity">Nat_Util.plus_ac_on_typ</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">theory</span><span class="antiquote">}</span></span></span> <span class="entity">natT</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">is_numc</span> <span class="main">=</span> <span class="entity">UtilArith.is_numc</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dest_numc</span> <span class="main">=</span> <span class="entity">UtilArith.dest_numc</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">is_plus</span> <span class="main">=</span> <span class="entity">UtilArith.is_plus</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">is_minus</span> <span class="main">=</span> <span class="entity">UtilArith.is_minus</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">is_times</span> <span class="main">=</span> <span class="entity">UtilArith.is_times</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">is_zero</span> <span class="main">=</span> <span class="entity">UtilArith.is_zero</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">is_one</span> <span class="main">=</span> <span class="entity">UtilArith.is_one</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">wf_rewr_obj_eq</span> <span class="main">=</span> <span class="entity">WfTerm.rewr_obj_eq</span> <span class="entity">fheads</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">nat0</span> <span class="main">=</span> <span class="entity">Nat_Util.nat0</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mult_1</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> mult_1<span class="antiquote">}</span></span></span>  <span class="comment1">(* 1 * a = a *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mult_1_right</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> mult_1_right<span class="antiquote">}</span></span></span>  <span class="comment1">(* a * 1 = a *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mult_0</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> mult_0<span class="antiquote">}</span></span></span>  <span class="comment1">(* 0 * a = 0 *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mult_0_right</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> mult_0_right<span class="antiquote">}</span></span></span>  <span class="comment1">(* a * 0 = 0 *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">add_0</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> add_0<span class="antiquote">}</span></span></span>  <span class="comment1">(* 0 + a = a *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">add_0_right</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> add_0_right<span class="antiquote">}</span></span></span>  <span class="comment1">(* a + 0 = a *)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">add_assoc</span> <span class="main">=</span> <span class="entity">wf_rewr_obj_eq</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> add_ac<span class="main">(</span>1<span class="main">)</span><span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">add_assoc_sym</span> <span class="main">=</span> <span class="entity">wf_rewr_obj_eq</span> <span class="main">(</span><span class="entity">obj_sym</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> add_ac<span class="main">(</span>1<span class="main">)</span><span class="antiquote">}</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">add_comm</span> <span class="main">=</span> <span class="entity">wf_rewr_obj_eq</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> add_ac<span class="main">(</span>2<span class="main">)</span><span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">swap_add</span> <span class="main">=</span> <span class="entity">WfTerm.every_conv</span> <span class="main">[</span><span class="entity">add_assoc</span><span class="main">,</span> <span class="entity">WfTerm.arg_conv</span> <span class="entity">add_comm</span><span class="main">,</span>
                                  <span class="entity">add_assoc_sym</span><span class="main">]</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">times_assoc</span> <span class="main">=</span> <span class="entity">wf_rewr_obj_eq</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> mult_ac<span class="main">(</span>1<span class="main">)</span><span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">times_assoc_sym</span> <span class="main">=</span> <span class="entity">wf_rewr_obj_eq</span> <span class="main">(</span><span class="entity">obj_sym</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> mult_ac<span class="main">(</span>1<span class="main">)</span><span class="antiquote">}</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">times_comm</span> <span class="main">=</span> <span class="entity">wf_rewr_obj_eq</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> mult_ac<span class="main">(</span>2<span class="main">)</span><span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">swap_times</span> <span class="main">=</span> <span class="entity">WfTerm.every_conv</span> <span class="main">[</span><span class="entity">times_assoc</span><span class="main">,</span> <span class="entity">WfTerm.arg_conv</span> <span class="entity">times_comm</span><span class="main">,</span>
                                    <span class="entity">times_assoc_sym</span><span class="main">]</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">distrib_r_th</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> nat_distrib<span class="main">(</span>1<span class="main">)</span><span class="antiquote">}</span></span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">distrib_l_th</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> nat_distrib<span class="main">(</span>2<span class="main">)</span><span class="antiquote">}</span></span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">nat_fold_wfconv</span> <span class="main">=</span> <span class="entity">WfTerm.conv_of</span> <span class="entity">Nat_Util.nat_fold_conv</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cancel_0_left</span> <span class="main">=</span> <span class="entity">WfTerm.try_conv</span> <span class="main">(</span><span class="entity">wf_rewr_obj_eq</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> add_0_left<span class="antiquote">}</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">append_0_left</span> <span class="main">=</span> <span class="entity">wf_rewr_obj_eq</span> <span class="main">(</span><span class="entity">obj_sym</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> add_0_left<span class="antiquote">}</span></span></span><span class="main">)</span>

<span class="comment1">(* When comparing atoms, constants are greater than non-constants. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">compare_atom</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_numc</span> <span class="entity">t1</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_numc</span> <span class="entity">t2</span> <span class="keyword2"><span class="keyword">then</span></span> EQUAL
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_numc</span> <span class="entity">t1</span> <span class="keyword2"><span class="keyword">then</span></span> GREATER
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_numc</span> <span class="entity">t2</span> <span class="keyword2"><span class="keyword">then</span></span> LESS
    <span class="keyword2"><span class="keyword">else</span></span> Term_Ord.term_ord <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span>

<span class="comment1">(* Multiply a monomial with an atom. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">norm_mult_atom</span> <span class="entity">wft</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">WfTerm.term_of</span> <span class="entity">wft</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">arg1</span><span class="main">,</span> <span class="entity">arg2</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Util.dest_binop_args</span> <span class="entity">t</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_one</span> <span class="entity">arg1</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">wf_rewr_obj_eq</span> <span class="entity">mult_1</span> <span class="entity">wft</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_one</span> <span class="entity">arg2</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">wf_rewr_obj_eq</span> <span class="entity">mult_1_right</span> <span class="entity">wft</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_zero</span> <span class="entity">arg1</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">wf_rewr_obj_eq</span> <span class="entity">mult_0</span> <span class="entity">wft</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_zero</span> <span class="entity">arg2</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">wf_rewr_obj_eq</span> <span class="entity">mult_0_right</span> <span class="entity">wft</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_times</span> <span class="entity">arg1</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">compare_atom</span> <span class="main">(</span><span class="entity">dest_arg</span> <span class="entity">arg1</span><span class="main">,</span> <span class="entity">arg2</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
            GREATER <span class="main">=&gt;</span>
            <span class="entity">WfTerm.every_conv</span> <span class="main">[</span><span class="entity">swap_times</span><span class="main">,</span>
                               <span class="entity">WfTerm.arg1_conv</span> <span class="entity">norm_mult_atom</span><span class="main">]</span> <span class="entity">wft</span>
          <span class="main">|</span> EQUAL <span class="main">=&gt;</span>
            <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_numc</span> <span class="main">(</span><span class="entity">dest_arg</span> <span class="entity">arg1</span><span class="main">)</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_numc</span> <span class="entity">arg2</span> <span class="keyword2"><span class="keyword">then</span></span>
              <span class="entity">WfTerm.every_conv</span> <span class="main">[</span><span class="entity">times_assoc</span><span class="main">,</span>
                                 <span class="entity">WfTerm.arg_conv</span> <span class="entity">nat_fold_wfconv</span><span class="main">]</span> <span class="entity">wft</span>
            <span class="keyword2"><span class="keyword">else</span></span>
              <span class="entity">WfTerm.all_conv</span> <span class="entity">wft</span>
          <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">WfTerm.all_conv</span> <span class="entity">wft</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">compare_atom</span> <span class="main">(</span><span class="entity">arg1</span><span class="main">,</span> <span class="entity">arg2</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
            GREATER <span class="main">=&gt;</span> <span class="entity">times_comm</span> <span class="entity">wft</span>
          <span class="main">|</span> EQUAL <span class="main">=&gt;</span>
            <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_numc</span> <span class="entity">arg1</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_numc</span> <span class="entity">arg2</span> <span class="keyword2"><span class="keyword">then</span></span>
              <span class="entity">nat_fold_wfconv</span> <span class="entity">wft</span>
            <span class="keyword2"><span class="keyword">else</span></span>
              <span class="entity">WfTerm.all_conv</span> <span class="entity">wft</span>
          <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="entity">WfTerm.all_conv</span> <span class="entity">wft</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Multiply two monomials. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">norm_mult_monomial</span> <span class="entity">wft</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">WfTerm.term_of</span> <span class="entity">wft</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">arg2</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Util.dest_binop_args</span> <span class="entity">t</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_times</span> <span class="entity">arg2</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="entity">WfTerm.every_conv</span> <span class="main">[</span><span class="entity">times_assoc_sym</span><span class="main">,</span>
                           <span class="entity">WfTerm.arg1_conv</span> <span class="entity">norm_mult_monomial</span><span class="main">,</span>
                           <span class="entity">norm_mult_atom</span><span class="main">]</span> <span class="entity">wft</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="entity">norm_mult_atom</span> <span class="entity">wft</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Destruct t into the form arg * coeff, where coeff is a constant. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_monomial</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_times</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_numc</span> <span class="main">(</span><span class="entity">dest_arg</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
      <span class="main">(</span><span class="entity">dest_arg1</span> <span class="entity">t</span><span class="main">,</span> <span class="entity">UtilArith.dest_numc</span> <span class="main">(</span><span class="entity">dest_arg</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_numc</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
      <span class="main">(</span><span class="entity">Nat_Util.mk_nat</span> <span class="inner_numeral">1</span><span class="main">,</span> <span class="entity">UtilArith.dest_numc</span> <span class="entity">t</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">else</span></span>
      <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="inner_numeral">1</span><span class="main">)</span>

<span class="comment1">(* Normalize ct into the form arg * coeff.

   Example: a * 4 == a * 4, a == a * 1, 4 == 1 * 4.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">norm_monomial</span> <span class="entity">wft</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">WfTerm.term_of</span> <span class="entity">wft</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_times</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_numc</span> <span class="main">(</span><span class="entity">dest_arg</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="entity">WfTerm.all_conv</span> <span class="entity">wft</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_numc</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="entity">wf_rewr_obj_eq</span> <span class="main">(</span><span class="entity">obj_sym</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> mult_1<span class="antiquote">}</span></span></span><span class="main">)</span> <span class="entity">wft</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="entity">wf_rewr_obj_eq</span> <span class="main">(</span><span class="entity">obj_sym</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> mult_1_right<span class="antiquote">}</span></span></span><span class="main">)</span> <span class="entity">wft</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Compare two monomials by removing coefficient. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">compare_monomial</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">arg1</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">dest_monomial</span> <span class="entity">t1</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">arg2</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">dest_monomial</span> <span class="entity">t2</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_one</span> <span class="entity">arg1</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_one</span> <span class="entity">arg2</span> <span class="keyword2"><span class="keyword">then</span></span> EQUAL
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_one</span> <span class="entity">arg1</span> <span class="keyword2"><span class="keyword">then</span></span> GREATER
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_one</span> <span class="entity">arg2</span> <span class="keyword2"><span class="keyword">then</span></span> LESS
      <span class="keyword2"><span class="keyword">else</span></span> Term_Ord.term_ord <span class="main">(</span><span class="entity">arg1</span><span class="main">,</span> <span class="entity">arg2</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Combine two monomials. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">combine_monomial</span> <span class="entity">wft</span> <span class="main">=</span>
    <span class="entity">WfTerm.every_conv</span> <span class="main">[</span><span class="entity">WfTerm.binop_conv</span> <span class="entity">norm_monomial</span><span class="main">,</span>
                       <span class="entity">wf_rewr_obj_eq</span> <span class="main">(</span><span class="entity">obj_sym</span> <span class="entity">distrib_l_th</span><span class="main">)</span><span class="main">,</span>
                       <span class="entity">WfTerm.arg_conv</span> <span class="entity">nat_fold_wfconv</span><span class="main">]</span> <span class="entity">wft</span>

<span class="comment1">(* Normalize a + b, where a is a sum and b is an atom. If b is a
   constant, add it to the end of a. Otherwise, insert b into sorted
   position.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">norm_plus1</span> <span class="entity">wft</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="entity">b</span><span class="main">)</span> <span class="main">=</span> <span class="entity">wft</span> |&gt; <span class="entity">WfTerm.term_of</span> |&gt; <span class="entity">Util.dest_binop_args</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_zero</span> <span class="entity">a</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">wf_rewr_obj_eq</span> <span class="entity">add_0</span> <span class="entity">wft</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_zero</span> <span class="entity">b</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">wf_rewr_obj_eq</span> <span class="entity">add_0_right</span> <span class="entity">wft</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_plus</span> <span class="entity">a</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">compare_monomial</span> <span class="main">(</span><span class="entity">dest_arg</span> <span class="entity">a</span><span class="main">,</span> <span class="entity">b</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
            LESS <span class="main">=&gt;</span> <span class="entity">WfTerm.all_conv</span> <span class="entity">wft</span>
          <span class="main">|</span> EQUAL <span class="main">=&gt;</span>
            <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_numc</span> <span class="main">(</span><span class="entity">dest_arg</span> <span class="entity">a</span><span class="main">)</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_numc</span> <span class="entity">b</span> <span class="keyword2"><span class="keyword">then</span></span>
              <span class="entity">WfTerm.every_conv</span> <span class="main">[</span><span class="entity">add_assoc</span><span class="main">,</span>
                                 <span class="entity">WfTerm.arg_conv</span> <span class="entity">nat_fold_wfconv</span><span class="main">]</span> <span class="entity">wft</span>
            <span class="keyword2"><span class="keyword">else</span></span>
              <span class="entity">WfTerm.every_conv</span> <span class="main">[</span><span class="entity">add_assoc</span><span class="main">,</span>
                                 <span class="entity">WfTerm.arg_conv</span> <span class="entity">combine_monomial</span><span class="main">]</span> <span class="entity">wft</span>
          <span class="main">|</span> GREATER <span class="main">=&gt;</span>
            <span class="entity">WfTerm.every_conv</span> <span class="main">[</span><span class="entity">swap_add</span><span class="main">,</span> <span class="entity">WfTerm.arg1_conv</span> <span class="entity">norm_plus1</span><span class="main">]</span> <span class="entity">wft</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">compare_monomial</span> <span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="entity">b</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
            LESS <span class="main">=&gt;</span> <span class="entity">WfTerm.all_conv</span> <span class="entity">wft</span>
          <span class="main">|</span> EQUAL <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_numc</span> <span class="entity">a</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">is_numc</span> <span class="entity">b</span> <span class="keyword2"><span class="keyword">then</span></span>
                       <span class="entity">nat_fold_wfconv</span> <span class="entity">wft</span>
                     <span class="keyword2"><span class="keyword">else</span></span>
                       <span class="entity">combine_monomial</span> <span class="entity">wft</span>
          <span class="main">|</span> GREATER <span class="main">=&gt;</span> <span class="entity">wf_rewr_obj_eq</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> add_ac<span class="main">(</span>2<span class="main">)</span><span class="antiquote">}</span></span></span> <span class="entity">wft</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Normalize a + b, where a and b are both sums. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">norm_plus</span> <span class="entity">wft</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">b</span><span class="main">)</span> <span class="main">=</span> <span class="entity">wft</span> |&gt; <span class="entity">WfTerm.term_of</span> |&gt; <span class="entity">Util.dest_binop_args</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_plus</span> <span class="entity">b</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="entity">WfTerm.every_conv</span> <span class="main">[</span>
          <span class="entity">add_assoc_sym</span><span class="main">,</span> <span class="entity">WfTerm.arg1_conv</span> <span class="entity">norm_plus</span><span class="main">,</span> <span class="entity">norm_plus1</span><span class="main">]</span> <span class="entity">wft</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="entity">norm_plus1</span> <span class="entity">wft</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Assume wft is a sum containing u. Move u into the outermost position. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">move_outmost</span> <span class="entity">u</span> <span class="entity">wft</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">u</span> aconv <span class="main">(</span><span class="entity">WfTerm.term_of</span> <span class="entity">wft</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">WfTerm.all_conv</span> <span class="entity">wft</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span><span class="entity">is_plus</span> <span class="main">(</span><span class="entity">WfTerm.term_of</span> <span class="entity">wft</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
      <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"move_outmost: u not found in wft."</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="entity">b</span><span class="main">)</span> <span class="main">=</span> <span class="entity">wft</span> |&gt; <span class="entity">WfTerm.term_of</span> |&gt; <span class="entity">Util.dest_binop_args</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">u</span> aconv <span class="entity">b</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">WfTerm.all_conv</span> <span class="entity">wft</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_plus</span> <span class="entity">a</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="entity">WfTerm.every_conv</span> <span class="main">[</span><span class="entity">WfTerm.arg1_conv</span> <span class="main">(</span><span class="entity">move_outmost</span> <span class="entity">u</span><span class="main">)</span><span class="main">,</span> <span class="entity">swap_add</span><span class="main">]</span> <span class="entity">wft</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">u</span> aconv <span class="entity">a</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="entity">add_comm</span> <span class="entity">wft</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"move_outmost: u not found in wft."</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Cancel terms with the same argument from the two sides. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">cancel_terms</span> <span class="entity">wft</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="entity">b</span><span class="main">)</span> <span class="main">=</span> <span class="entity">wft</span> |&gt; <span class="entity">WfTerm.term_of</span> |&gt; <span class="entity">Util.dest_binop_args</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">ts1</span><span class="main">,</span> <span class="entity">ts2</span><span class="main">)</span> <span class="main">=</span> apply2 <span class="main">(</span><span class="entity">ACUtil.dest_ac</span> <span class="entity">plus_info</span><span class="main">)</span> <span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="entity">b</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">find_same_arg</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">compare_monomial</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
              EQUAL <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">t1</span> aconv <span class="entity">nat0</span> <span class="keyword1"><span class="keyword">orelse</span></span> <span class="entity">t2</span> aconv <span class="entity">nat0</span> <span class="keyword2"><span class="keyword">then</span></span> NONE
                       <span class="keyword2"><span class="keyword">else</span></span> SOME <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span>
            <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> NONE

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prepare_left</span> <span class="entity">t1</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">if</span></span> length <span class="entity">ts1</span> <span class="main">=</span> <span class="inner_numeral">1</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">WfTerm.arg1_conv</span> <span class="entity">append_0_left</span>
          <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">WfTerm.arg1_conv</span> <span class="main">(</span><span class="entity">move_outmost</span> <span class="entity">t1</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prepare_right</span> <span class="entity">t2</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">if</span></span> length <span class="entity">ts2</span> <span class="main">=</span> <span class="inner_numeral">1</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">WfTerm.arg_conv</span> <span class="entity">append_0_left</span>
          <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">WfTerm.arg_conv</span> <span class="main">(</span><span class="entity">move_outmost</span> <span class="entity">t2</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">apply_th</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="entity">wft</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">n1</span><span class="main">)</span> <span class="main">=</span> <span class="entity">dest_monomial</span> <span class="entity">t1</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">n2</span><span class="main">)</span> <span class="main">=</span> <span class="entity">dest_monomial</span> <span class="entity">t2</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fold_cv</span> <span class="main">=</span>
                <span class="entity">WfTerm.every_conv</span> <span class="main">[</span>
                  <span class="entity">WfTerm.arg_conv</span> <span class="entity">nat_fold_wfconv</span><span class="main">,</span>
                  <span class="entity">WfTerm.try_conv</span> <span class="main">(</span><span class="entity">wf_rewr_obj_eq</span> <span class="entity">mult_1</span><span class="main">)</span><span class="main">,</span>
                  <span class="entity">WfTerm.try_conv</span> <span class="main">(</span><span class="entity">wf_rewr_obj_eq</span> <span class="entity">mult_1_right</span><span class="main">)</span><span class="main">]</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">le_th</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">n1</span> &gt;= <span class="entity">n2</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">Nat_Util.nat_le_th</span> <span class="entity">n2</span> <span class="entity">n1</span>
                        <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">Nat_Util.nat_le_th</span> <span class="entity">n1</span> <span class="entity">n2</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">n1</span> <span class="main">=</span> <span class="entity">n2</span> <span class="keyword2"><span class="keyword">then</span></span>
              <span class="entity">wf_rewr_obj_eq</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> nat_sub_combine<span class="antiquote">}</span></span></span> <span class="entity">wft</span>
            <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">n1</span> &gt; <span class="entity">n2</span> <span class="keyword2"><span class="keyword">then</span></span>
              <span class="entity">WfTerm.every_conv</span> <span class="main">[</span>
                <span class="entity">WfTerm.binop_conv</span> <span class="main">(</span><span class="entity">WfTerm.arg_conv</span> <span class="entity">norm_monomial</span><span class="main">)</span><span class="main">,</span>
                <span class="entity">wf_rewr_obj_eq</span> <span class="main">(</span><span class="entity">le_th</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> nat_sub_combine2<span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">,</span>
                <span class="entity">WfTerm.arg1_conv</span> <span class="main">(</span><span class="entity">WfTerm.arg_conv</span> <span class="entity">fold_cv</span><span class="main">)</span><span class="main">,</span>
                <span class="entity">WfTerm.arg1_conv</span> <span class="entity">norm_plus</span><span class="main">]</span> <span class="entity">wft</span>
            <span class="keyword2"><span class="keyword">else</span></span>
              <span class="entity">WfTerm.every_conv</span> <span class="main">[</span>
                <span class="entity">WfTerm.binop_conv</span> <span class="main">(</span><span class="entity">WfTerm.arg_conv</span> <span class="entity">norm_monomial</span><span class="main">)</span><span class="main">,</span>
                <span class="entity">wf_rewr_obj_eq</span> <span class="main">(</span><span class="entity">le_th</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> nat_sub_combine3<span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">,</span>
                <span class="entity">WfTerm.arg_conv</span> <span class="main">(</span><span class="entity">WfTerm.arg_conv</span> <span class="entity">fold_cv</span><span class="main">)</span><span class="main">,</span>
                <span class="entity">WfTerm.arg_conv</span> <span class="entity">norm_plus</span><span class="main">]</span> <span class="entity">wft</span>
          <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> get_first <span class="entity">find_same_arg</span> <span class="main">(</span><span class="entity">Util.all_pairs</span> <span class="main">(</span><span class="entity">ts1</span><span class="main">,</span> <span class="entity">ts2</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
          NONE <span class="main">=&gt;</span> <span class="entity">WfTerm.all_conv</span> <span class="entity">wft</span>
        <span class="main">|</span> SOME <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=&gt;</span>
          <span class="entity">WfTerm.every_conv</span> <span class="main">[</span><span class="entity">prepare_left</span> <span class="entity">t1</span><span class="main">,</span> <span class="entity">prepare_right</span> <span class="entity">t2</span><span class="main">,</span>
                             <span class="entity">apply_th</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span><span class="main">,</span>
                             <span class="entity">WfTerm.arg1_conv</span> <span class="entity">cancel_0_left</span><span class="main">,</span>
                             <span class="entity">WfTerm.arg_conv</span> <span class="entity">cancel_0_left</span><span class="main">,</span>
                             <span class="entity">cancel_terms</span><span class="main">]</span> <span class="entity">wft</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">norm_mult_poly_monomial</span> <span class="entity">wft</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">WfTerm.term_of</span> <span class="entity">wft</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">arg1</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Util.dest_binop_args</span> <span class="entity">t</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_plus</span> <span class="entity">arg1</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="entity">WfTerm.every_conv</span> <span class="main">[</span><span class="entity">wf_rewr_obj_eq</span> <span class="entity">distrib_r_th</span><span class="main">,</span>
                           <span class="entity">WfTerm.arg1_conv</span> <span class="entity">norm_mult_poly_monomial</span><span class="main">,</span>
                           <span class="entity">WfTerm.arg_conv</span> <span class="entity">norm_mult_monomial</span><span class="main">,</span>
                           <span class="entity">norm_plus</span><span class="main">]</span> <span class="entity">wft</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="entity">norm_mult_monomial</span> <span class="entity">wft</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">norm_mult_polynomials</span> <span class="entity">wft</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">WfTerm.term_of</span> <span class="entity">wft</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">arg2</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Util.dest_binop_args</span> <span class="entity">t</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_plus</span> <span class="entity">arg2</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="entity">WfTerm.every_conv</span> <span class="main">[</span><span class="entity">wf_rewr_obj_eq</span> <span class="entity">distrib_l_th</span><span class="main">,</span>
                           <span class="entity">WfTerm.arg1_conv</span> <span class="entity">norm_mult_polynomials</span><span class="main">,</span>
                           <span class="entity">WfTerm.arg_conv</span> <span class="entity">norm_mult_poly_monomial</span><span class="main">,</span>
                           <span class="entity">norm_plus</span><span class="main">]</span> <span class="entity">wft</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="entity">norm_mult_poly_monomial</span> <span class="entity">wft</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* First step, put wft into the form a - b, where a and b are
   normalized sums.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">norm_minus'</span> <span class="entity">wft</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">WfTerm.term_of</span> <span class="entity">wft</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_plus</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="comment1">(* (a - b) + (c - d) = (a + c) - (b + d) *)</span>
        <span class="entity">WfTerm.every_conv</span> <span class="main">[</span><span class="entity">WfTerm.binop_conv</span> <span class="entity">norm_minus'</span><span class="main">,</span>
                           <span class="entity">wf_rewr_obj_eq</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> nat_sub1<span class="antiquote">}</span></span></span><span class="main">,</span>
                           <span class="entity">WfTerm.binop_conv</span> <span class="entity">norm_plus</span><span class="main">,</span>
                           <span class="entity">cancel_terms</span><span class="main">]</span> <span class="entity">wft</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_minus</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="comment1">(* (a - b) - (c - d) = (a + d) - (b + c) *)</span>
        <span class="entity">WfTerm.every_conv</span> <span class="main">[</span><span class="entity">WfTerm.binop_conv</span> <span class="entity">norm_minus'</span><span class="main">,</span>
                           <span class="entity">wf_rewr_obj_eq</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> nat_sub2<span class="antiquote">}</span></span></span><span class="main">,</span>
                           <span class="entity">WfTerm.binop_conv</span> <span class="entity">norm_plus</span><span class="main">,</span>
                           <span class="entity">cancel_terms</span><span class="main">]</span> <span class="entity">wft</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_times</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="comment1">(* (a - b) * (c - d) = (ac + bd) - (ad + bc) *)</span>
        <span class="entity">WfTerm.every_conv</span> <span class="main">[</span>
          <span class="entity">WfTerm.binop_conv</span> <span class="entity">norm_minus'</span><span class="main">,</span>
          <span class="entity">wf_rewr_obj_eq</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> nat_sub3<span class="antiquote">}</span></span></span><span class="main">,</span>
          <span class="entity">WfTerm.binop_conv</span> <span class="main">(</span><span class="entity">WfTerm.binop_conv</span> <span class="entity">norm_mult_polynomials</span><span class="main">)</span><span class="main">,</span>
          <span class="entity">WfTerm.binop_conv</span> <span class="entity">norm_plus</span><span class="main">,</span>
          <span class="entity">cancel_terms</span><span class="main">]</span> <span class="entity">wft</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="comment1">(* Normalize a into a - 0. *)</span>
        <span class="entity">wf_rewr_obj_eq</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> nat_sub_norm<span class="antiquote">}</span></span></span> <span class="entity">wft</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">norm_minus</span> <span class="entity">wft</span> <span class="main">=</span>
    <span class="entity">WfTerm.every_conv</span> <span class="main">[</span>
      <span class="entity">norm_minus'</span><span class="main">,</span>
      <span class="entity">WfTerm.try_conv</span> <span class="main">(</span><span class="entity">wf_rewr_obj_eq</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> diff_zero<span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">]</span> <span class="entity">wft</span>

<span class="comment1">(* Fast computation of the expected normalization. Return a list of
   monomials.
 *)</span>
<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">monomial</span> <span class="main">=</span> cterm list * int

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_plus</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span>
    Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> plus<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">natT</span> --&gt; <span class="entity">natT</span> --&gt; <span class="entity">natT</span><span class="main">)</span> $ <span class="entity">t1</span> $ <span class="entity">t2</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">list_plus</span> <span class="entity">ts</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">list_rev</span> <span class="entity">ts</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">ts</span> <span class="keyword2"><span class="keyword">of</span></span>
              <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="entity">Nat_Util.mk_nat</span> <span class="inner_numeral">0</span>
            <span class="main">|</span> <span class="main">[</span><span class="entity">t</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="entity">t</span>
            <span class="main">|</span> <span class="entity">t</span> :: <span class="entity">ts'</span> <span class="main">=&gt;</span> <span class="entity">mk_plus</span> <span class="main">(</span><span class="entity">list_rev</span> <span class="entity">ts'</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">list_rev</span> <span class="main">(</span>rev <span class="entity">ts</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_times</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span>
    Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> times<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">natT</span> --&gt; <span class="entity">natT</span> --&gt; <span class="entity">natT</span><span class="main">)</span> $ <span class="entity">t1</span> $ <span class="entity">t2</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">list_times</span> <span class="entity">ts</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">list_rev</span> <span class="entity">ts</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">ts</span> <span class="keyword2"><span class="keyword">of</span></span>
              <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="entity">Nat_Util.mk_nat</span> <span class="inner_numeral">1</span>
            <span class="main">|</span> <span class="main">[</span><span class="entity">t</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="entity">t</span>
            <span class="main">|</span> <span class="entity">t</span> :: <span class="entity">ts'</span> <span class="main">=&gt;</span> <span class="entity">mk_times</span> <span class="main">(</span><span class="entity">list_rev</span> <span class="entity">ts'</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">list_rev</span> <span class="main">(</span>rev <span class="entity">ts</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Compare two monomials *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">compare_monomial_list</span> <span class="main">(</span><span class="main">(</span><span class="entity">l1</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">l2</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">l1</span> <span class="keyword1"><span class="keyword">andalso</span></span> null <span class="entity">l2</span> <span class="keyword2"><span class="keyword">then</span></span> EQUAL
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">l1</span> <span class="keyword2"><span class="keyword">then</span></span> GREATER
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">l2</span> <span class="keyword2"><span class="keyword">then</span></span> LESS
    <span class="keyword2"><span class="keyword">else</span></span> Term_Ord.term_ord <span class="main">(</span><span class="entity">list_times</span> <span class="main">(</span>map Thm.term_of <span class="entity">l1</span><span class="main">)</span><span class="main">,</span>
                            <span class="entity">list_times</span> <span class="main">(</span>map Thm.term_of <span class="entity">l2</span><span class="main">)</span><span class="main">)</span>

<span class="comment1">(* Reduce a list of monomials: combine monomials of the same body. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">reduce_monomial_list</span> <span class="entity">ls</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">ls</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">l1</span><span class="main">,</span> <span class="entity">c1</span><span class="main">)</span><span class="main">,</span> <span class="entity">rest</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>hd <span class="entity">ls</span><span class="main">,</span> <span class="entity">reduce_monomial_list</span> <span class="main">(</span>tl <span class="entity">ls</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">rest</span> <span class="keyword2"><span class="keyword">of</span></span>
          <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="main">(</span><span class="entity">l1</span><span class="main">,</span> <span class="entity">c1</span><span class="main">)</span><span class="main">]</span>
        <span class="main">|</span> <span class="main">[</span><span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="main">(</span><span class="entity">l1</span><span class="main">,</span> <span class="entity">c1</span><span class="main">)</span><span class="main">]</span>
        <span class="main">|</span> <span class="main">(</span><span class="entity">l2</span><span class="main">,</span> <span class="entity">c2</span><span class="main">)</span> :: <span class="entity">rest'</span> <span class="main">=&gt;</span>
          <span class="keyword2"><span class="keyword">if</span></span> eq_list <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconvc<span class="main">)</span> <span class="main">(</span><span class="entity">l1</span><span class="main">,</span> <span class="entity">l2</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
            <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">c1</span> + <span class="entity">c2</span> <span class="main">=</span> <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">rest'</span>
            <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="entity">l1</span><span class="main">,</span> <span class="entity">c1</span> + <span class="entity">c2</span><span class="main">)</span> :: <span class="entity">rest'</span>
          <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="entity">l1</span><span class="main">,</span> <span class="entity">c1</span><span class="main">)</span> :: <span class="main">(</span><span class="entity">l2</span><span class="main">,</span> <span class="entity">c2</span><span class="main">)</span> :: <span class="entity">rest'</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Multiply two monomials. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mult_monomial</span> <span class="main">(</span><span class="main">(</span><span class="entity">l1</span><span class="main">,</span> <span class="entity">c1</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">l2</span><span class="main">,</span> <span class="entity">c2</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
    <span class="main">(</span><span class="main">(</span><span class="entity">l1</span> @ <span class="entity">l2</span><span class="main">)</span> |&gt; sort <span class="main">(</span><span class="entity">compare_atom</span> o apply2 Thm.term_of<span class="main">)</span><span class="main">,</span> <span class="entity">c1</span> * <span class="entity">c2</span><span class="main">)</span>

<span class="comment1">(* Multiply two such lists: take the pairwise product, sort within
   each monomial, then sort the list of monomials.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mult_polynomial_term</span> <span class="main">(</span><span class="entity">ls1</span><span class="main">,</span> <span class="entity">ls2</span><span class="main">)</span> <span class="main">=</span>
    <span class="main">(</span><span class="entity">Util.all_pairs</span> <span class="main">(</span><span class="entity">ls1</span><span class="main">,</span> <span class="entity">ls2</span><span class="main">)</span><span class="main">)</span>
        |&gt; map <span class="entity">mult_monomial</span>
        |&gt; sort <span class="entity">compare_monomial_list</span>
        |&gt; <span class="entity">reduce_monomial_list</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_polynomial_list</span> <span class="main">(</span><span class="entity">ls1</span><span class="main">,</span> <span class="entity">ls2</span><span class="main">)</span> <span class="main">=</span>
    <span class="main">(</span><span class="entity">ls1</span> @ <span class="entity">ls2</span><span class="main">)</span> |&gt; sort <span class="entity">compare_monomial_list</span> |&gt; <span class="entity">reduce_monomial_list</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">negate_polynomial_list</span> <span class="entity">ls</span> <span class="main">=</span>
    map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">ls</span><span class="main">,</span> <span class="entity">n</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">ls</span><span class="main">,</span> ~<span class="entity">n</span><span class="main">)</span><span class="main">)</span> <span class="entity">ls</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">norm_minus_ct</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Thm.term_of <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_plus</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="entity">add_polynomial_list</span> <span class="main">(</span><span class="entity">norm_minus_ct</span> <span class="main">(</span>Thm.dest_arg1 <span class="entity">ct</span><span class="main">)</span><span class="main">,</span>
                             <span class="entity">norm_minus_ct</span> <span class="main">(</span>Thm.dest_arg <span class="entity">ct</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_minus</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="entity">add_polynomial_list</span> <span class="main">(</span>
          <span class="entity">norm_minus_ct</span> <span class="main">(</span>Thm.dest_arg1 <span class="entity">ct</span><span class="main">)</span><span class="main">,</span>
          <span class="entity">negate_polynomial_list</span> <span class="main">(</span><span class="entity">norm_minus_ct</span> <span class="main">(</span>Thm.dest_arg <span class="entity">ct</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_times</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="entity">mult_polynomial_term</span> <span class="main">(</span><span class="entity">norm_minus_ct</span> <span class="main">(</span>Thm.dest_arg1 <span class="entity">ct</span><span class="main">)</span><span class="main">,</span>
                              <span class="entity">norm_minus_ct</span> <span class="main">(</span>Thm.dest_arg <span class="entity">ct</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_numc</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
        <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">dest_numc</span> <span class="entity">t</span><span class="main">)</span><span class="main">]</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="entity">ct</span><span class="main">]</span><span class="main">,</span> <span class="inner_numeral">1</span><span class="main">)</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">subterms_of</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="entity">ct</span> |&gt; <span class="entity">norm_minus_ct</span> |&gt; map fst |&gt; flat

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">to_monomial</span> <span class="main">(</span><span class="entity">l</span><span class="main">,</span> <span class="entity">c</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">l</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">mk_nat</span> <span class="entity">c</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">c</span> <span class="main">=</span> <span class="inner_numeral">1</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">list_times</span> <span class="main">(</span>map Thm.term_of <span class="entity">l</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">mk_times</span> <span class="main">(</span><span class="entity">list_times</span> <span class="main">(</span>map Thm.term_of <span class="entity">l</span><span class="main">)</span><span class="main">,</span> <span class="entity">mk_nat</span> <span class="entity">c</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">norm_ring_term</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dest_ring</span> <span class="main">=</span> <span class="entity">norm_minus_ct</span> <span class="entity">ct</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">ps</span><span class="main">,</span> <span class="entity">ms</span><span class="main">)</span> <span class="main">=</span> <span class="entity">filter_split</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">n</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">n</span> &gt;= <span class="inner_numeral">0</span><span class="main">)</span> <span class="entity">dest_ring</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> length <span class="entity">ms</span> &gt; <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span>
        Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> minus<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">natT</span> --&gt; <span class="entity">natT</span> --&gt; <span class="entity">natT</span><span class="main">)</span> $
              <span class="entity">list_plus</span> <span class="main">(</span>map <span class="entity">to_monomial</span> <span class="entity">ps</span><span class="main">)</span> $
              <span class="entity">list_plus</span> <span class="main">(</span>map <span class="entity">to_monomial</span> <span class="main">(</span><span class="entity">negate_polynomial_list</span> <span class="entity">ms</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">else</span></span>
        <span class="entity">list_plus</span> <span class="main">(</span>map <span class="entity">to_monomial</span> <span class="entity">ps</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Obtain head equivalences of cu, normalized to a - b form, and where
   each term is simplified.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_sub_head_equiv</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">ct</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_wf_head_equiv</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="main">(</span><span class="entity">wft</span><span class="main">,</span> <span class="entity">eq_th</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cts</span> <span class="main">=</span> <span class="entity">subterms_of</span> <span class="main">(</span>Thm.rhs_of <span class="entity">eq_th</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">simps</span> <span class="main">=</span> <span class="entity">WellformData.simplify</span> <span class="entity">ctxt</span> <span class="entity">fheads</span> <span class="entity">cts</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">wft</span><span class="main">)</span>

            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_simp</span> <span class="main">(</span><span class="entity">id''</span><span class="main">,</span> <span class="main">(</span><span class="entity">wft'</span><span class="main">,</span> <span class="entity">eq_th'</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
                <span class="main">(</span><span class="entity">BoxID.merge_boxes</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">id''</span><span class="main">)</span><span class="main">,</span>
                 <span class="main">(</span><span class="entity">wft'</span><span class="main">,</span> <span class="entity">Util.transitive_list</span> <span class="main">[</span><span class="entity">eq_th</span><span class="main">,</span> <span class="entity">eq_th'</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            map <span class="entity">process_simp</span> <span class="entity">simps</span>
          <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">ct</span><span class="main">)</span> |&gt; <span class="entity">WellformData.get_head_equiv</span> <span class="entity">ctxt</span> <span class="entity">fheads</span>
               |&gt; maps <span class="entity">process_wf_head_equiv</span>
               |&gt; filter_out <span class="main">(</span>Thm.is_reflexive o snd o snd<span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Given wft in normalized form a - b, expand one of the subterms
   once. Calls the corresponding function in ac_steps on a and b, then
   combine the results.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">nat_sub_expand_once</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">wft</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ct</span> <span class="main">=</span> <span class="entity">WfTerm.cterm_of</span> <span class="entity">wft</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">subt</span> <span class="main">=</span> <span class="entity">subterms_of</span> <span class="entity">ct</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_equiv</span> <span class="entity">cu</span> <span class="main">=</span> <span class="entity">get_sub_head_equiv</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">cu</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_info</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">wf_eq</span><span class="main">)</span> <span class="main">=</span>
          <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">WfTerm.rewrite_on_eqs</span> <span class="entity">fheads</span> <span class="main">[</span><span class="entity">wf_eq</span><span class="main">]</span> <span class="entity">wft</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      map <span class="entity">process_info</span> <span class="main">(</span>maps <span class="entity">get_equiv</span> <span class="entity">subt</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Find all ways to write ct, up to a certain limit. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">nat_sub_expand</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">ct</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">max_ac</span> <span class="main">=</span> Config.get <span class="entity">ctxt</span> <span class="entity">AC_ProofSteps.max_ac</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">ac_equiv_eq_better</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">th'</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">seq1</span> <span class="main">=</span> <span class="entity">subterms_of</span> <span class="main">(</span>Thm.rhs_of <span class="entity">th</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">seq2</span> <span class="main">=</span> <span class="entity">subterms_of</span> <span class="main">(</span>Thm.rhs_of <span class="entity">th'</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="entity">Util.is_subseq</span> <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconvc<span class="main">)</span> <span class="main">(</span><span class="entity">seq1</span><span class="main">,</span> <span class="entity">seq2</span><span class="main">)</span> <span class="keyword1"><span class="keyword">andalso</span></span>
            <span class="entity">BoxID.is_eq_ancestor</span> <span class="entity">ctxt</span> <span class="entity">id</span> <span class="entity">id'</span>
          <span class="keyword2"><span class="keyword">end</span></span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">has_ac_equiv_eq_better</span> <span class="entity">infos</span> <span class="entity">info'</span> <span class="main">=</span>
          exists <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">info</span> <span class="main">=&gt;</span> <span class="entity">ac_equiv_eq_better</span> <span class="entity">info</span> <span class="entity">info'</span><span class="main">)</span> <span class="entity">infos</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">helper</span> <span class="main">(</span><span class="entity">old</span><span class="main">,</span> <span class="entity">new</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">new</span> <span class="keyword2"><span class="keyword">of</span></span>
              <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="entity">old</span>
            <span class="main">|</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="main">(</span><span class="entity">wft</span><span class="main">,</span> <span class="entity">eq_th</span><span class="main">)</span><span class="main">)</span> :: <span class="entity">rest</span> <span class="main">=&gt;</span>
              <span class="keyword2"><span class="keyword">if</span></span> length <span class="entity">old</span> + length <span class="entity">new</span> &gt; <span class="entity">max_ac</span> <span class="keyword2"><span class="keyword">then</span></span>
                <span class="entity">old</span> @ take <span class="main">(</span><span class="entity">max_ac</span> - length <span class="entity">old</span><span class="main">)</span> <span class="entity">new</span>
              <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">old'</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="main">(</span><span class="entity">wft</span><span class="main">,</span> <span class="entity">eq_th</span><span class="main">)</span><span class="main">)</span> :: <span class="entity">old</span><span class="main">)</span>

                <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">merge_info</span> <span class="main">(</span><span class="entity">id''</span><span class="main">,</span> <span class="main">(</span><span class="entity">wft'</span><span class="main">,</span> <span class="entity">eq_th'</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
                    <span class="main">(</span><span class="entity">BoxID.merge_boxes</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">id''</span><span class="main">)</span><span class="main">,</span>
                     <span class="main">(</span><span class="entity">wft'</span><span class="main">,</span> <span class="entity">Util.transitive_list</span> <span class="main">[</span><span class="entity">eq_th</span><span class="main">,</span> <span class="entity">eq_th'</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>

                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs_expand</span> <span class="main">=</span>
                    <span class="main">(</span><span class="entity">nat_sub_expand_once</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">wft</span><span class="main">)</span><span class="main">)</span>
                        |&gt; <span class="entity">Util.max_partial</span> <span class="entity">ac_equiv_eq_better</span>
                        |&gt; map <span class="entity">merge_info</span>
                        |&gt; filter_out <span class="main">(</span><span class="entity">has_ac_equiv_eq_better</span> <span class="main">(</span><span class="entity">old'</span> @ <span class="entity">rest</span><span class="main">)</span><span class="main">)</span>
              <span class="keyword2"><span class="keyword">in</span></span>
                <span class="entity">helper</span> <span class="main">(</span><span class="entity">old'</span><span class="main">,</span> <span class="entity">rest</span> @ <span class="entity">rhs_expand</span><span class="main">)</span>
              <span class="keyword2"><span class="keyword">end</span></span>

      <span class="comment1">(* Start term *)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ts</span> <span class="main">=</span> <span class="entity">subterms_of</span> <span class="entity">ct</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">start</span> <span class="main">=</span> <span class="main">(</span><span class="entity">WellformData.cterm_to_wfterm</span> <span class="entity">ctxt</span> <span class="entity">fheads</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">ct</span><span class="main">)</span><span class="main">)</span>
                      |&gt; maps <span class="main">(</span><span class="entity">WellformData.simplify</span> <span class="entity">ctxt</span> <span class="entity">fheads</span> <span class="entity">ts</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">helper</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">start</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_nat_sub_form</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_plus</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">orelse</span></span> <span class="entity">is_minus</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">orelse</span></span> <span class="entity">is_times</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span>
      fastype_of <span class="main">(</span><span class="entity">dest_arg</span> <span class="entity">t</span><span class="main">)</span> <span class="main">=</span> <span class="entity">natT</span>
    <span class="keyword2"><span class="keyword">else</span></span> false

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">nat_sub_expand_equiv_fn</span> <span class="entity">ctxt</span> <span class="entity">item1</span> <span class="entity">item2</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span>id <span class="main">=</span> <span class="entity">id1</span><span class="main">,</span> tname <span class="main">=</span> <span class="entity">tname1</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">item1</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span>id <span class="main">=</span> <span class="entity">id2</span><span class="main">,</span> tname <span class="main">=</span> <span class="entity">tname2</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">item2</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">ct1</span><span class="main">,</span> <span class="entity">ct2</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>the_single <span class="entity">tname1</span><span class="main">,</span> the_single <span class="entity">tname2</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Thm.term_of <span class="entity">ct1</span><span class="main">,</span> Thm.term_of <span class="entity">ct2</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">id</span> <span class="main">=</span> <span class="entity">BoxID.merge_boxes</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id1</span><span class="main">,</span> <span class="entity">id2</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span><span class="entity">is_nat_sub_form</span> <span class="entity">t1</span><span class="main">)</span> <span class="keyword1"><span class="keyword">orelse</span></span> not <span class="main">(</span><span class="entity">is_nat_sub_form</span> <span class="entity">t2</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> Term_Ord.term_ord <span class="main">(</span><span class="entity">t2</span><span class="main">,</span> <span class="entity">t1</span><span class="main">)</span> <span class="main">=</span> LESS <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">RewriteTable.is_equiv</span> <span class="entity">id</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">ct1</span><span class="main">,</span> <span class="entity">ct2</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">expand1</span> <span class="main">=</span> <span class="entity">nat_sub_expand</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">ct1</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">expand2</span> <span class="main">=</span> <span class="entity">nat_sub_expand</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">ct2</span><span class="main">)</span>

        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_equiv</span> <span class="main">(</span><span class="main">(</span><span class="entity">id1</span><span class="main">,</span> <span class="main">(</span><span class="entity">wft1</span><span class="main">,</span> <span class="entity">eq_th1</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">id2</span><span class="main">,</span> <span class="main">(</span><span class="entity">wft2</span><span class="main">,</span> <span class="entity">eq_th2</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
            <span class="keyword2"><span class="keyword">let</span></span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ct1</span> <span class="main">=</span> Thm.rhs_of <span class="entity">eq_th1</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ct2</span> <span class="main">=</span> Thm.rhs_of <span class="entity">eq_th2</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ts1</span> <span class="main">=</span> <span class="entity">norm_minus_ct</span> <span class="entity">ct1</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ts2</span> <span class="main">=</span> <span class="entity">norm_minus_ct</span> <span class="entity">ct2</span>
            <span class="keyword2"><span class="keyword">in</span></span>
              <span class="keyword2"><span class="keyword">if</span></span> eq_list <span class="main">(</span>eq_pair <span class="main">(</span>eq_list <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconvc<span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="entity">ts1</span><span class="main">,</span> <span class="entity">ts2</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
                <span class="keyword2"><span class="keyword">let</span></span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">wft1'</span><span class="main">,</span> <span class="entity">eq1</span><span class="main">)</span> <span class="main">=</span> <span class="entity">norm_minus</span> <span class="entity">wft1</span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">wft2'</span><span class="main">,</span> <span class="entity">eq2</span><span class="main">)</span> <span class="main">=</span> <span class="entity">norm_minus</span> <span class="entity">wft2</span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span><span class="entity">WfTerm.term_of</span> <span class="entity">wft1'</span> aconv <span class="entity">WfTerm.term_of</span> <span class="entity">wft2'</span><span class="main">)</span>
                                 <span class="inner_quoted">"nat_sub_expand_equiv_fn"</span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">id'</span> <span class="main">=</span> <span class="entity">BoxID.merge_boxes</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id1</span><span class="main">,</span> <span class="entity">id2</span><span class="main">)</span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq</span> <span class="main">=</span> <span class="entity">Util.transitive_list</span> <span class="main">[</span>
                        <span class="entity">eq_th1</span><span class="main">,</span> <span class="entity">eq1</span><span class="main">,</span> <span class="entity">meta_sym</span> <span class="entity">eq2</span><span class="main">,</span> <span class="entity">meta_sym</span> <span class="entity">eq_th2</span><span class="main">]</span>
                <span class="keyword2"><span class="keyword">in</span></span>
                  <span class="main">[</span><span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">to_obj_eq</span> <span class="entity">eq</span><span class="main">)</span><span class="main">]</span>
                <span class="keyword2"><span class="keyword">end</span></span>
              <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="main">]</span>
            <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span>maps <span class="entity">get_equiv</span> <span class="main">(</span><span class="entity">Util.all_pairs</span> <span class="main">(</span><span class="entity">expand1</span><span class="main">,</span> <span class="entity">expand2</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
            |&gt; filter <span class="main">(</span><span class="entity">BoxID.has_incr_id</span> o fst<span class="main">)</span>
            |&gt; <span class="entity">Util.max_partial</span> <span class="main">(</span><span class="entity">BoxID.id_is_eq_ancestor</span> <span class="entity">ctxt</span><span class="main">)</span>
            |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">Update.thm_update_sc</span> <span class="inner_numeral">1</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">nat_sub_expand_equiv</span> <span class="main">=</span>
    <span class="main">{</span>name <span class="main">=</span> <span class="inner_quoted">"nat_sub_expand_equiv"</span><span class="main">,</span>
     args <span class="main">=</span> <span class="main">[</span><span class="entity">TypedMatch</span> <span class="main">(</span><span class="entity">TY_TERM</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term_pat</span> <span class="quoted">"<span class="var">?A</span><span class="main">::</span>nat"</span><span class="antiquote">}</span></span><span class="main">)</span><span class="main">,</span>
             <span class="entity">TypedMatch</span> <span class="main">(</span><span class="entity">TY_TERM</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term_pat</span> <span class="quoted">"<span class="var">?B</span><span class="main">::</span>nat"</span><span class="antiquote">}</span></span><span class="main">)</span><span class="main">]</span><span class="main">,</span>
     func <span class="main">=</span> <span class="entity">TwoStep</span> <span class="entity">nat_sub_expand_equiv_fn</span><span class="main">}</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">nat_sub_expand_unit_fn</span> <span class="entity">ctxt</span> <span class="entity">item</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">id</span><span class="main">,</span> <span class="entity">tname</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">item</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ct</span> <span class="main">=</span> the_single <span class="entity">tname</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Thm.term_of <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span><span class="entity">is_nat_sub_form</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">expand</span> <span class="main">=</span> <span class="entity">nat_sub_expand</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">ct</span><span class="main">)</span>

        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_expand</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="main">(</span><span class="entity">wft</span><span class="main">,</span> <span class="entity">eq_th</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
            <span class="keyword2"><span class="keyword">let</span></span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ct</span> <span class="main">=</span> Thm.rhs_of <span class="entity">eq_th</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ts</span> <span class="main">=</span> <span class="entity">norm_minus_ct</span> <span class="entity">ct</span>
            <span class="keyword2"><span class="keyword">in</span></span>
              <span class="keyword2"><span class="keyword">if</span></span> length <span class="entity">ts</span> <span class="main">=</span> <span class="inner_numeral">0</span> <span class="keyword1"><span class="keyword">orelse</span></span>
                 <span class="main">(</span>length <span class="entity">ts</span> <span class="main">=</span> <span class="inner_numeral">1</span> <span class="keyword1"><span class="keyword">andalso</span></span> snd <span class="main">(</span>the_single <span class="entity">ts</span><span class="main">)</span> <span class="main">=</span> <span class="inner_numeral">1</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
                <span class="keyword2"><span class="keyword">let</span></span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">eq'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">norm_minus</span> <span class="entity">wft</span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq</span> <span class="main">=</span> <span class="entity">Util.transitive_list</span> <span class="main">[</span><span class="entity">eq_th</span><span class="main">,</span> <span class="entity">eq'</span><span class="main">]</span>
                <span class="keyword2"><span class="keyword">in</span></span>
                  <span class="main">[</span><span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">to_obj_eq</span> <span class="entity">eq</span><span class="main">)</span><span class="main">]</span>
                <span class="keyword2"><span class="keyword">end</span></span>
              <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="main">]</span>
            <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span>maps <span class="entity">process_expand</span> <span class="entity">expand</span><span class="main">)</span>
            |&gt; filter <span class="main">(</span><span class="entity">BoxID.has_incr_id</span> o fst<span class="main">)</span>
            |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">Update.thm_update_sc</span> <span class="inner_numeral">1</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">nat_sub_expand_unit</span> <span class="main">=</span>
    <span class="main">{</span>name <span class="main">=</span> <span class="inner_quoted">"nat_sub_expand_unit"</span><span class="main">,</span>
     args <span class="main">=</span> <span class="main">[</span><span class="entity">TypedMatch</span> <span class="main">(</span><span class="entity">TY_TERM</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term_pat</span> <span class="quoted">"<span class="var">?A</span><span class="main">::</span>nat"</span><span class="antiquote">}</span></span><span class="main">)</span><span class="main">]</span><span class="main">,</span>
     func <span class="main">=</span> <span class="entity">OneStep</span> <span class="entity">nat_sub_expand_unit_fn</span><span class="main">}</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">add_nat_sub_proofsteps</span> <span class="main">=</span>
    fold <span class="entity">add_prfstep</span> <span class="main">[</span>
      <span class="entity">nat_sub_expand_equiv</span><span class="main">,</span> <span class="entity">nat_sub_expand_unit</span>
    <span class="main">]</span>

<span class="keyword2"><span class="keyword">end</span></span>  <span class="comment1">(* NatSub *)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> Theory.setup <span class="entity">NatSub.add_nat_sub_proofsteps</span>
</pre>
</div><div id="files/nat_sub_test.ML">
<div class="head">
<h1>File ‹nat_sub_test.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*
  File: nat_sub_test.ML
  Author: Bohua Zhan

  Unit test for nat_sub.ML.
*)</span>

<span class="keyword2"><span class="keyword">local</span></span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ts</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span> Free <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">natT</span><span class="main">)</span><span class="main">)</span> <span class="main">[</span><span class="inner_quoted">"a"</span><span class="main">,</span> <span class="inner_quoted">"b"</span><span class="main">,</span> <span class="inner_quoted">"c"</span><span class="main">,</span> <span class="inner_quoted">"m"</span><span class="main">,</span> <span class="inner_quoted">"n"</span><span class="main">]</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt</span> <span class="main">=</span> fold <span class="entity">Util.declare_free_term</span> <span class="entity">ts</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span>

<span class="keyword2"><span class="keyword">in</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">test_term</span> <span class="entity">ctxt</span> <span class="entity">f</span> <span class="entity">err_str</span> <span class="main">(</span><span class="entity">str1</span><span class="main">,</span> <span class="entity">str2</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Proof_Context.read_term_pattern <span class="entity">ctxt</span> <span class="entity">str1</span><span class="main">,</span>
                      Proof_Context.read_term_pattern <span class="entity">ctxt</span> <span class="entity">str2</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t2'</span> <span class="main">=</span> <span class="entity">f</span> <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">t1</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">t2</span> aconv <span class="entity">t2'</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_t</span> <span class="entity">ctxt</span> <span class="inner_quoted">"Input:"</span> <span class="entity">t1</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_t</span> <span class="entity">ctxt</span> <span class="inner_quoted">"Expected:"</span> <span class="entity">t2</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_t</span> <span class="entity">ctxt</span> <span class="inner_quoted">"Actual:"</span> <span class="entity">t2'</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="entity">err_str</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_data</span> <span class="main">=</span> <span class="main">[</span>
        <span class="comment1">(* No repeated terms. *)</span>
        <span class="main">(</span><span class="inner_quoted">"a"</span><span class="main">,</span> <span class="inner_quoted">"a"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"a + b"</span><span class="main">,</span> <span class="inner_quoted">"a + b"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"a - b"</span><span class="main">,</span> <span class="inner_quoted">"a - b"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"a - b + c"</span><span class="main">,</span> <span class="inner_quoted">"a + c - b"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"a - b - c"</span><span class="main">,</span> <span class="inner_quoted">"a - (b + c)"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"a - b + (c - d)"</span><span class="main">,</span> <span class="inner_quoted">"a + c - (b + d)"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"a - b - (c - d)"</span><span class="main">,</span> <span class="inner_quoted">"a + d - (b + c)"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"a + b + c - d - e - f"</span><span class="main">,</span> <span class="inner_quoted">"a + b + c - (d + e + f)"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"a - b + c - d + e - f"</span><span class="main">,</span> <span class="inner_quoted">"a + c + e - (b + d + f)"</span><span class="main">)</span><span class="main">,</span>

        <span class="comment1">(* Numerical constants (on one side only). *)</span>
        <span class="main">(</span><span class="inner_quoted">"0::nat"</span><span class="main">,</span> <span class="inner_quoted">"0::nat"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"2::nat"</span><span class="main">,</span> <span class="inner_quoted">"2::nat"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"a + 2 + 3"</span><span class="main">,</span> <span class="inner_quoted">"a + 5"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"a - b - 2 - 3"</span><span class="main">,</span> <span class="inner_quoted">"a - (b + 5)"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"2 + 3 + a"</span><span class="main">,</span> <span class="inner_quoted">"a + 5"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"a - 2 - b - 3"</span><span class="main">,</span> <span class="inner_quoted">"a - (b + 5)"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"0 + a - 0 - b"</span><span class="main">,</span> <span class="inner_quoted">"a - b"</span><span class="main">)</span><span class="main">,</span>

        <span class="comment1">(* Cancellation needed. *)</span>
        <span class="main">(</span><span class="inner_quoted">"a - a"</span><span class="main">,</span> <span class="inner_quoted">"(0::nat)"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"a - 0"</span><span class="main">,</span> <span class="inner_quoted">"a"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"a + b - a"</span><span class="main">,</span> <span class="inner_quoted">"b"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"a - (a - a)"</span><span class="main">,</span> <span class="inner_quoted">"a"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"a + b - a - c"</span><span class="main">,</span> <span class="inner_quoted">"b - c"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"a + b - a - b"</span><span class="main">,</span> <span class="inner_quoted">"0::nat"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"a + b + c - a - b"</span><span class="main">,</span> <span class="inner_quoted">"c"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"c + (b + (b + a - b) - b)"</span><span class="main">,</span> <span class="inner_quoted">"a + c"</span><span class="main">)</span><span class="main">,</span>

        <span class="comment1">(* Cancellation of constants needed. *)</span>
        <span class="main">(</span><span class="inner_quoted">"a + 5 - b - 3"</span><span class="main">,</span> <span class="inner_quoted">"a + 2 - b"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"a + 3 - b - 5"</span><span class="main">,</span> <span class="inner_quoted">"a - (b + 2)"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"a + 5 - b - 5"</span><span class="main">,</span> <span class="inner_quoted">"a - b"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"a - 5 - (b - 3)"</span><span class="main">,</span> <span class="inner_quoted">"a - (b + 2)"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"a - 3 - (b - 5)"</span><span class="main">,</span> <span class="inner_quoted">"(a + 2) - b"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"a + 5 - 3"</span><span class="main">,</span> <span class="inner_quoted">"a + 2"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"a - 5 + 3"</span><span class="main">,</span> <span class="inner_quoted">"a - 2"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"5 - a - 3"</span><span class="main">,</span> <span class="inner_quoted">"2 - a"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"3 - a - 3"</span><span class="main">,</span> <span class="inner_quoted">"0 - a"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"(5::nat) - 3"</span><span class="main">,</span> <span class="inner_quoted">"2::nat"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"(3::nat) - 3"</span><span class="main">,</span> <span class="inner_quoted">"0::nat"</span><span class="main">)</span><span class="main">,</span>

        <span class="comment1">(* Monomial *)</span>
        <span class="main">(</span><span class="inner_quoted">"a * 3"</span><span class="main">,</span> <span class="inner_quoted">"a * 3"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"a * b + b * a"</span><span class="main">,</span> <span class="inner_quoted">"a * b * 2"</span><span class="main">)</span><span class="main">,</span>

        <span class="comment1">(* Cancellation between terms *)</span>
        <span class="main">(</span><span class="inner_quoted">"a * 3 + a * 2"</span><span class="main">,</span> <span class="inner_quoted">"a * 5"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"a * 3 - a * 2"</span><span class="main">,</span> <span class="inner_quoted">"a"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"a * 3 + b - a * 2"</span><span class="main">,</span> <span class="inner_quoted">"a + b"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"a * 2 + b - a * 3"</span><span class="main">,</span> <span class="inner_quoted">"b - a"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"a * 2 + b * 3 - a * 3 - b * 2"</span><span class="main">,</span> <span class="inner_quoted">"b - a"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"a * 3 - a * 2 - a"</span><span class="main">,</span> <span class="inner_quoted">"0::nat"</span><span class="main">)</span><span class="main">,</span>

        <span class="comment1">(* Distributivity *)</span>
        <span class="main">(</span><span class="inner_quoted">"(a + 2) * b"</span><span class="main">,</span> <span class="inner_quoted">"b * 2 + a * b"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"(a + 2) * 2"</span><span class="main">,</span> <span class="inner_quoted">"a * 2 + 4"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"(a - 2) * b"</span><span class="main">,</span> <span class="inner_quoted">"a * b - b * 2"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"(a - 2) * 2"</span><span class="main">,</span> <span class="inner_quoted">"a * 2 - 4"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"(a + 1) * (a - 1)"</span><span class="main">,</span> <span class="inner_quoted">"a * a - 1"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"(a + 3) * (a - 2)"</span><span class="main">,</span> <span class="inner_quoted">"a + a * a - 6"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"(a - 1) * (a - 1)"</span><span class="main">,</span> <span class="inner_quoted">"a * a + 1 - a * 2"</span><span class="main">)</span>
      <span class="main">]</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      map <span class="main">(</span><span class="entity">WfTerm.test_wfconv</span> <span class="entity">ctxt</span> <span class="entity">NatSub.fheads</span> <span class="entity">NatSub.norm_minus</span> <span class="inner_quoted">"test"</span><span class="main">)</span> <span class="entity">test_data</span> @
      map <span class="main">(</span><span class="entity">test_term</span> <span class="entity">ctxt</span> <span class="entity">NatSub.norm_ring_term</span> <span class="inner_quoted">"test_t"</span><span class="main">)</span> <span class="entity">test_data</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Set_Thms">
<div class="head">
<h1>Theory Set_Thms</h1>
</div>
<pre class="source"><span class="comment1">(*
  File: Set_Thms.thy
  Author: Bohua Zhan

  Setup of proof steps related to sets.
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Setup for sets and multisets›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Set_Thms
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Logic_Thms.html">Logic_Thms</a> <span class="quoted">"<a href="../../HOL/HOL-Library/Multiset.html">HOL-Library.Multiset</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Set›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Injective functions›</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_backward_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> injI<span class="antiquote">}</span></span></span>›</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹AC property of intersection and union›</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹fold <span class="entity">ACUtil.add_ac_data</span> <span class="main">[</span>
  <span class="main">{</span>cfhead <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">cterm</span> <span class="quoted">inf</span><span class="antiquote">}</span></span></span><span class="main">,</span> unit <span class="main">=</span> SOME <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">cterm</span> <span class="quoted">inf</span><span class="antiquote">}</span></span></span><span class="main">,</span>
   assoc_th <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> inf_assoc<span class="antiquote">}</span></span></span><span class="main">,</span> comm_th <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> inf_commute<span class="antiquote">}</span></span></span><span class="main">,</span>
   unitl_th <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> inf_top_left<span class="antiquote">}</span></span></span><span class="main">,</span> unitr_th <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> inf_top_right<span class="antiquote">}</span></span></span><span class="main">}</span><span class="main">,</span>

  <span class="main">{</span>cfhead <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">cterm</span> <span class="quoted">sup</span><span class="antiquote">}</span></span></span><span class="main">,</span> unit <span class="main">=</span> SOME <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">cterm</span> <span class="quoted">bot</span><span class="antiquote">}</span></span></span><span class="main">,</span>
   assoc_th <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> sup_assoc<span class="antiquote">}</span></span></span><span class="main">,</span> comm_th <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> sup_commute<span class="antiquote">}</span></span></span><span class="main">,</span>
   unitl_th <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> sup_bot_left<span class="antiquote">}</span></span></span><span class="main">,</span> unitr_th <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> sup_bot_right<span class="antiquote">}</span></span></span><span class="main">}</span><span class="main">]</span>
›</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Collection and bounded quantification›</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Set.mem_Collect_eq<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">lemma</span></span> ball_single <span class="main">[</span><span class="operator">rewrite</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">∈</span><span class="main">{</span><span class="free">x</span><span class="main">}</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">P</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Membership›</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Set.singleton_iff<span class="antiquote">}</span></span></span>›</span> 
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep</span> <span class="main">(</span><span class="entity">equiv_forward_th</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Set.empty_iff<span class="antiquote">}</span></span></span><span class="main">)</span>›</span>
<span class="keyword1"><span class="command">lemma</span></span> set_membership_distinct <span class="main">[</span><span class="operator">forward</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">s</span> <span class="main">⟹</span> <span class="free">y</span> <span class="main">∉</span> <span class="free">s</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">≠</span> <span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">lemma</span></span> non_empty_exist_elt <span class="main">[</span><span class="operator">backward</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">U</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">U</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">lemma</span></span> non_univ_exist_compl <span class="main">[</span><span class="operator">backward</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">U</span> <span class="main">≠</span> UNIV <span class="main">⟹</span> <span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∉</span> <span class="free">U</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_resolve_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Set.UNIV_I<span class="antiquote">}</span></span></span>›</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Insert›</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_backward_prfstep_cond</span> <span class="main">(</span><span class="entity">equiv_backward_th</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Set.insert_iff<span class="antiquote">}</span></span></span><span class="main">)</span> <span class="main">[</span><span class="entity">with_cond</span> <span class="inner_quoted">"?A ≠ {}"</span><span class="main">]</span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep_cond</span> <span class="main">(</span><span class="entity">equiv_forward_th</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Set.insert_iff<span class="antiquote">}</span></span></span><span class="main">)</span>
  <span class="main">[</span><span class="entity">with_score</span> <span class="inner_numeral">500</span><span class="main">,</span> <span class="entity">with_cond</span> <span class="inner_quoted">"?A ≠ {}"</span><span class="main">]</span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep_cond</span> <span class="main">(</span><span class="entity">equiv_forward_th</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Set.insert_subset<span class="antiquote">}</span></span></span><span class="main">)</span> <span class="main">[</span><span class="entity">with_cond</span> <span class="inner_quoted">"?A ≠ {}"</span><span class="main">]</span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_backward_prfstep_cond</span> <span class="main">(</span><span class="entity">equiv_backward_th</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Set.insert_subset<span class="antiquote">}</span></span></span><span class="main">)</span>
  <span class="main">[</span><span class="entity">with_score</span> <span class="inner_numeral">500</span><span class="main">,</span> <span class="entity">with_cond</span> <span class="inner_quoted">"?A ≠ {}"</span><span class="main">]</span>›</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Extensionality›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> set_ext <span class="main">[</span><span class="operator">forward</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">a</span><span class="main">.</span> <span class="bound">a</span> <span class="main">∈</span> <span class="free">S</span> <span class="main">⟷</span> <span class="bound">a</span> <span class="main">∈</span> <span class="free">T</span> <span class="main">⟹</span> <span class="free">S</span> <span class="main">=</span> <span class="free">T</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_backward_prfstep_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> set_ext<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_score</span> <span class="inner_numeral">500</span><span class="main">,</span> <span class="entity">with_filt</span> <span class="main">(</span><span class="entity">order_filter</span> <span class="inner_quoted">"S"</span> <span class="inner_quoted">"T"</span><span class="main">)</span><span class="main">]</span>›</span>

<span class="keyword1"><span class="command">lemma</span></span> set_pair_ext <span class="main">[</span><span class="operator">forward</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">a</span> <span class="bound">b</span><span class="main">.</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∈</span> <span class="free">S</span> <span class="main">⟷</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span> <span class="main">∈</span> <span class="free">T</span> <span class="main">⟹</span> <span class="free">S</span> <span class="main">=</span> <span class="free">T</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Union›</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep_cond</span> <span class="main">(</span><span class="entity">equiv_forward_th</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Set.Un_iff<span class="antiquote">}</span></span></span><span class="main">)</span> <span class="main">[</span><span class="entity">with_score</span> <span class="inner_numeral">500</span><span class="main">]</span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_backward_prfstep</span> <span class="main">(</span><span class="entity">equiv_backward_th</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Set.Un_iff<span class="antiquote">}</span></span></span><span class="main">)</span>›</span>

<span class="keyword1"><span class="command">lemma</span></span> UnD1 <span class="main">[</span><span class="operator">forward</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">∈</span> <span class="free">A</span> <span class="main">∪</span> <span class="free">B</span> <span class="main">⟹</span> <span class="free">c</span> <span class="main">∉</span> <span class="free">A</span> <span class="main">⟹</span> <span class="free">c</span> <span class="main">∈</span> <span class="free">B</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">lemma</span></span> UnD2 <span class="main">[</span><span class="operator">forward</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">∈</span> <span class="free">A</span> <span class="main">∪</span> <span class="free">B</span> <span class="main">⟹</span> <span class="free">c</span> <span class="main">∉</span> <span class="free">B</span> <span class="main">⟹</span> <span class="free">c</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">lemma</span></span> UnD1_single <span class="main">[</span><span class="operator">forward</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">∈</span> <span class="main">{</span><span class="free">a</span><span class="main">}</span> <span class="main">∪</span> <span class="free">B</span> <span class="main">⟹</span> <span class="free">c</span> <span class="main">≠</span> <span class="free">a</span> <span class="main">⟹</span> <span class="free">c</span> <span class="main">∈</span> <span class="free">B</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">lemma</span></span> UnD2_single <span class="main">[</span><span class="operator">forward</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">∈</span> <span class="free">A</span> <span class="main">∪</span> <span class="main">{</span><span class="free">b</span><span class="main">}</span> <span class="main">⟹</span> <span class="free">c</span> <span class="main">≠</span> <span class="free">b</span> <span class="main">⟹</span> <span class="free">c</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Set.UnI1<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_term</span> <span class="inner_quoted">"?A ∪ ?B"</span><span class="main">]</span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Set.UnI2<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_term</span> <span class="inner_quoted">"?A ∪ ?B"</span><span class="main">]</span>›</span>
<span class="keyword1"><span class="command">lemma</span></span> UnI1_single<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">∈</span> <span class="main">{</span><span class="free">a</span><span class="main">}</span> <span class="main">∪</span> <span class="free">B</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">lemma</span></span> UnI2_single<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">∈</span> <span class="free">A</span> <span class="main">∪</span> <span class="main">{</span><span class="free">b</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> UnI1_single<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_term</span> <span class="inner_quoted">"{?a} ∪ ?B"</span><span class="main">]</span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> UnI2_single<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_term</span> <span class="inner_quoted">"?A ∪ {?b}"</span><span class="main">]</span>›</span>
  
<span class="keyword1"><span class="command">lemma</span></span> union_single_eq <span class="main">[</span><span class="operator">rewrite</span><span class="main">,</span> <span class="operator">backward</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">p</span> <span class="main">⟹</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span> <span class="main">∪</span> <span class="free">p</span> <span class="main">=</span> <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Intersection›</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep</span> <span class="main">(</span><span class="entity">equiv_forward_th</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Set.Int_iff<span class="antiquote">}</span></span></span><span class="main">)</span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_backward_prfstep_cond</span> <span class="main">(</span><span class="entity">equiv_backward_th</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Set.Int_iff<span class="antiquote">}</span></span></span><span class="main">)</span> <span class="main">[</span><span class="entity">with_score</span> <span class="inner_numeral">500</span><span class="main">]</span>›</span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Set.Int_empty_left<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Set.Int_empty_right<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Set.Int_absorb<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">lemma</span></span> set_disjoint_mp <span class="main">[</span><span class="operator">forward</span><span class="main">,</span> <span class="operator">backward2</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">∩</span> <span class="free">B</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">⟹</span> <span class="free">p</span> <span class="main">∈</span> <span class="free">A</span> <span class="main">⟹</span> <span class="free">p</span> <span class="main">∉</span> <span class="free">B</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">lemma</span></span> set_disjoint_single <span class="main">[</span><span class="operator">rewrite</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="free">x</span><span class="main">}</span> <span class="main">∩</span> <span class="free">B</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">∉</span> <span class="free">B</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹subset›</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> subsetI<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_backward_prfstep_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> subsetI<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_score</span> <span class="inner_numeral">500</span><span class="main">]</span>›</span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_resolve_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> empty_subsetI<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> subsetD<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">lemma</span></span> subset_single <span class="main">[</span><span class="operator">rewrite</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="free">a</span><span class="main">}</span> <span class="main">⊆</span> <span class="free">B</span> <span class="main">⟷</span> <span class="free">a</span> <span class="main">∈</span> <span class="free">B</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_resolve_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Set.basic_monos<span class="main">(</span>1<span class="main">)</span><span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_resolve_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Set.Un_upper1<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_resolve_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Set.Un_upper2<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">lemma</span></span> union_is_subset <span class="main">[</span><span class="operator">forward</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">∪</span> <span class="free">B</span> <span class="main">⊆</span> <span class="free">C</span> <span class="main">⟹</span> <span class="free">A</span> <span class="main">⊆</span> <span class="free">C</span> <span class="main">∧</span> <span class="free">B</span> <span class="main">⊆</span> <span class="free">C</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_backward1_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Set.Un_least<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_backward2_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Set.Un_least<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">lemma</span></span> subset_union_same1 <span class="main">[</span><span class="operator">backward</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">B</span> <span class="main">⊆</span> <span class="free">C</span> <span class="main">⟹</span> <span class="free">A</span> <span class="main">∪</span> <span class="free">B</span> <span class="main">⊆</span> <span class="free">A</span> <span class="main">∪</span> <span class="free">C</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">lemma</span></span> subset_union_same2 <span class="main">[</span><span class="operator">backward</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊆</span> <span class="free">B</span> <span class="main">⟹</span> <span class="free">A</span> <span class="main">∪</span> <span class="free">C</span> <span class="main">⊆</span> <span class="free">B</span> <span class="main">∪</span> <span class="free">C</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Diff›</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep</span> <span class="main">(</span><span class="entity">equiv_forward_th</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Set.Diff_iff<span class="antiquote">}</span></span></span><span class="main">)</span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_backward_prfstep_cond</span> <span class="main">(</span><span class="entity">equiv_backward_th</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Set.Diff_iff<span class="antiquote">}</span></span></span><span class="main">)</span> <span class="main">[</span><span class="entity">with_score</span> <span class="inner_numeral">500</span><span class="main">]</span>›</span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Set.empty_Diff<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">lemma</span></span> mem_diff <span class="main">[</span><span class="operator">rewrite</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">A</span> <span class="main">-</span> <span class="free">B</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">∈</span> <span class="free">A</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">∉</span> <span class="free">B</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">lemma</span></span> set_union_minus_same1 <span class="main">[</span><span class="operator">rewrite</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">A</span> <span class="main">∪</span> <span class="free">B</span><span class="main">)</span> <span class="main">-</span> <span class="free">B</span> <span class="main">=</span> <span class="free">A</span> <span class="main">-</span> <span class="free">B</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">lemma</span></span> set_union_minus_same2 <span class="main">[</span><span class="operator">rewrite</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">B</span> <span class="main">∪</span> <span class="free">A</span><span class="main">)</span> <span class="main">-</span> <span class="free">B</span> <span class="main">=</span> <span class="free">A</span> <span class="main">-</span> <span class="free">B</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">lemma</span></span> set_union_minus_distinct <span class="main">[</span><span class="operator">rewrite</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">≠</span> <span class="free">c</span> <span class="main">⟹</span> <span class="main">{</span><span class="free">a</span><span class="main">}</span> <span class="main">∪</span> <span class="main">(</span><span class="free">B</span> <span class="main">-</span> <span class="main">{</span><span class="free">c</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="free">a</span><span class="main">}</span> <span class="main">∪</span> <span class="free">B</span> <span class="main">-</span> <span class="main">{</span><span class="free">c</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Set.Diff_subset<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_term</span> <span class="inner_quoted">"?A - ?B"</span><span class="main">]</span>›</span>
<span class="keyword1"><span class="command">lemma</span></span> union_subtract_elt1 <span class="main">[</span><span class="operator">rewrite</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∉</span> <span class="free">B</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">{</span><span class="free">x</span><span class="main">}</span> <span class="main">∪</span> <span class="free">B</span><span class="main">)</span> <span class="main">-</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span> <span class="main">=</span> <span class="free">B</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">lemma</span></span> union_subtract_elt2 <span class="main">[</span><span class="operator">rewrite</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∉</span> <span class="free">B</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">B</span> <span class="main">∪</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span><span class="main">)</span> <span class="main">-</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span> <span class="main">=</span> <span class="free">B</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">lemma</span></span> subset_sub1 <span class="main">[</span><span class="operator">backward</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">A</span> <span class="main">⟹</span> <span class="free">A</span> <span class="main">-</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span> <span class="main">⊂</span> <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">lemma</span></span> member_notin <span class="main">[</span><span class="operator">forward</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">S</span> <span class="main">-</span> <span class="main">{</span><span class="free">y</span><span class="main">}</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">≠</span> <span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">lemma</span></span> member_notin_contra<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">S</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">≠</span> <span class="free">y</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">∈</span> <span class="free">S</span> <span class="main">-</span> <span class="main">{</span><span class="free">y</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> member_notin_contra<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_term</span> <span class="inner_quoted">"?S - {?y}"</span><span class="main">]</span>›</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Results on finite sets›</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_resolve_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Finite_Set.finite.emptyI<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">lemma</span></span> set_finite_single <span class="main">[</span><span class="operator">resolve</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">{</span><span class="free">x</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Finite_Set.finite_Un<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">lemma</span></span> Max_ge' <span class="main">[</span><span class="operator">forward</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">&gt;</span> Max <span class="free">A</span> <span class="main">⟹</span> <span class="main">¬</span><span class="main">(</span><span class="free">x</span> <span class="main">∈</span> <span class="free">A</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Max_ge leD <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_backward_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> finite_image_set<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> finite_atLeastAtMost<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> rev_finite_subset<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_backward1_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> rev_finite_subset<span class="antiquote">}</span></span></span>›</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Cardinality›</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> card.empty<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">lemma</span></span> card_emptyD <span class="main">[</span><span class="operator">rewrite</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">S</span> <span class="main">⟹</span> card <span class="free">S</span> <span class="main">=</span> <span class="main">0</span> <span class="main">⟹</span> <span class="free">S</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">lemma</span></span> card_minus1 <span class="main">[</span><span class="operator">rewrite</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">S</span> <span class="main">⟹</span> card <span class="main">(</span><span class="free">S</span> <span class="main">-</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> card <span class="free">S</span> <span class="main">-</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> card_Diff_subset<span class="main">)</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> finite_Diff<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_resolve_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> card_mono<span class="antiquote">}</span></span></span>›</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Image set›</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Set.image_Un<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> image_set_diff<span class="antiquote">}</span></span></span>›</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Multiset›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Basic properties›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> mset_member_empty <span class="main">[</span><span class="operator">resolve</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="free">p</span> <span class="main">∈#</span> <span class="main">{#}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">lemma</span></span> mem_multiset_single <span class="main">[</span><span class="operator">rewrite</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈#</span> <span class="main">{#</span><span class="free">y</span><span class="main">#}</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_backward2_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> subset_mset.antisym<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_resolve_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Multiset.empty_le<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> mset_subsetD<span class="antiquote">}</span></span></span>›</span>

<span class="keyword1"><span class="command">lemma</span></span> multi_contain_add_self1 <span class="main">[</span><span class="operator">resolve</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊂#</span> <span class="main">{#</span><span class="free">x</span><span class="main">#}</span> <span class="main">+</span> <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">lemma</span></span> multi_contain_add_self2 <span class="main">[</span><span class="operator">resolve</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊂#</span> <span class="free">A</span> <span class="main">+</span> <span class="main">{#</span><span class="free">x</span><span class="main">#}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Multiset.multi_member_this<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_term</span> <span class="inner_quoted">"{#?x#} + ?XS"</span><span class="main">]</span>›</span>
<span class="keyword1"><span class="command">lemma</span></span> multi_member_this2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈#</span> <span class="free">XS</span> <span class="main">+</span> <span class="main">{#</span><span class="free">x</span><span class="main">#}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> multi_member_this2<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_term</span> <span class="inner_quoted">"?XS + {#?x#}"</span><span class="main">]</span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_backward_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Multiset.subset_mset.add_left_mono<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_backward_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Multiset.subset_mset.add_right_mono<span class="antiquote">}</span></span></span>›</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Case checking and induction›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> multi_nonempty_split' <span class="main">[</span><span class="operator">resolve</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">M</span> <span class="main">≠</span> <span class="main">{#}</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">M'</span> <span class="bound">m</span><span class="main">.</span> <span class="free">M</span> <span class="main">=</span> <span class="bound">M'</span> <span class="main">+</span> <span class="main">{#</span><span class="bound">m</span><span class="main">#}</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> multi_nonempty_split <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> multi_member_split' <span class="main">[</span><span class="operator">backward</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈#</span> <span class="free">M</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">M'</span><span class="main">.</span> <span class="free">M</span> <span class="main">=</span> <span class="bound">M'</span> <span class="main">+</span> <span class="main">{#</span><span class="free">x</span><span class="main">#}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> insert_DiffM2<span class="main">)</span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_strong_induct_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> full_multiset_induct<span class="antiquote">}</span></span></span>›</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Results on mset›</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> set_mset_empty<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> set_mset_single<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> set_mset_union<span class="antiquote">}</span></span></span>›</span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> image_mset_empty<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> image_mset_single<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> image_mset_union<span class="antiquote">}</span></span></span>›</span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> prod_mset_empty<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> prod_mset_singleton<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> prod_mset_Un<span class="antiquote">}</span></span></span>›</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Set interval›</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Set_Interval.ord_class.lessThan_iff<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Set_Interval.ord_class.atLeastAtMost_iff<span class="antiquote">}</span></span></span>›</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Lists_Thms">
<div class="head">
<h1>Theory Lists_Thms</h1>
</div>
<pre class="source"><span class="comment1">(*
  File: Lists_Thms.thy
  Author: Bohua Zhan

  Setup for proof steps related to lists.
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Setup for lists›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Lists_Thms
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="Set_Thms.html">Set_Thms</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Definition of lists›</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_resolve_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> list.distinct<span class="main">(</span>2<span class="main">)</span><span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep</span> <span class="main">(</span><span class="entity">equiv_forward_th</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> list.simps<span class="main">(</span>1<span class="main">)</span><span class="antiquote">}</span></span></span><span class="main">)</span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹fold <span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> List.list.sel<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> list.collapse<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_var_induct_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> list.induct<span class="antiquote">}</span></span></span>›</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Length›</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> List.list.size<span class="main">(</span>3<span class="main">)</span><span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">lemma</span></span> length_one <span class="main">[</span><span class="operator">rewrite</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="main">[</span><span class="free">x</span><span class="main">]</span> <span class="main">=</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">lemma</span></span> length_Cons <span class="main">[</span><span class="operator">rewrite</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="main">(</span><span class="free">a</span> <span class="main">#</span> <span class="free">b</span><span class="main">)</span> <span class="main">=</span> length <span class="free">b</span> <span class="main">+</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">lemma</span></span> length_snoc <span class="main">[</span><span class="operator">rewrite</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="main">[</span><span class="free">x</span><span class="main">]</span><span class="main">)</span> <span class="main">=</span> length <span class="free">xs</span> <span class="main">+</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">lemma</span></span> length_zero_is_nil <span class="main">[</span><span class="operator">forward</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="free">xs</span> <span class="main">=</span> <span class="main">0</span> <span class="main">⟹</span> <span class="free">xs</span> <span class="main">=</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">lemma</span></span> length_gt_zero <span class="main">[</span><span class="operator">forward</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="free">xs</span> <span class="main">&gt;</span> <span class="main">0</span> <span class="main">⟹</span> <span class="free">xs</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Append›</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> List.length_append<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> List.append.simps<span class="main">(</span>2<span class="main">)</span><span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_cond</span> <span class="inner_quoted">"?xs ≠ []"</span><span class="main">]</span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> List.hd_append2<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">lemma</span></span> append_is_empty <span class="main">[</span><span class="operator">forward</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span> <span class="main">=</span> <span class="main">[]</span> <span class="main">⟹</span> <span class="free">xs</span> <span class="main">=</span> <span class="main">[]</span> <span class="main">∧</span> <span class="free">ys</span> <span class="main">=</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> cons_to_append <span class="main">[</span><span class="operator">rewrite_back</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">#</span> <span class="free">b</span> <span class="main">=</span> <span class="main">[</span><span class="free">a</span><span class="main">]</span> <span class="main">@</span> <span class="free">b</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹list_ac.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹list_ac_test.ML›</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Showing two lists are equal›</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_backward2_prfstep_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> nth_equalityI<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_filt</span> <span class="main">(</span><span class="entity">order_filter</span> <span class="inner_quoted">"xs"</span> <span class="inner_quoted">"ys"</span><span class="main">)</span><span class="main">]</span>›</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Set of elements of a list›</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> List.set_simps<span class="main">(</span>1<span class="main">)</span><span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">lemma</span></span> set_one <span class="main">[</span><span class="operator">rewrite</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">[</span><span class="free">u</span><span class="main">]</span> <span class="main">=</span> <span class="main">{</span><span class="free">u</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">lemma</span></span> set_two <span class="main">[</span><span class="operator">rewrite</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">[</span><span class="free">u</span><span class="main">,</span> <span class="free">v</span><span class="main">]</span> <span class="main">=</span> <span class="main">{</span><span class="free">u</span><span class="main">,</span> <span class="free">v</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">lemma</span></span> set_simps2<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span> <span class="main">∪</span> set <span class="free">xs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> set_simps2<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_cond</span> <span class="inner_quoted">"?xs ≠ []"</span><span class="main">,</span> <span class="entity">with_cond</span> <span class="inner_quoted">"?xs ≠ [?y]"</span><span class="main">]</span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> List.set_append<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> List.set_rev<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_resolve_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> List.finite_set<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_backward_prfstep</span> <span class="main">(</span><span class="entity">equiv_forward_th</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> in_set_conv_nth<span class="antiquote">}</span></span></span><span class="main">)</span>›</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹hd›</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">register_wellform_data</span> <span class="main">(</span><span class="inner_quoted">"hd xs"</span><span class="main">,</span> <span class="main">[</span><span class="inner_quoted">"xs ≠ []"</span><span class="main">]</span><span class="main">)</span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> List.hd_in_set<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_term</span> <span class="inner_quoted">"hd ?xs"</span><span class="main">]</span>›</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹tl›</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> length_tl<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">lemma</span></span> nth_tl' <span class="main">[</span><span class="operator">rewrite</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">&lt;</span> length <span class="main">(</span>tl <span class="free">xs</span><span class="main">)</span> <span class="main">⟹</span> tl <span class="free">xs</span> <span class="main">!</span> <span class="free">i</span> <span class="main">=</span> <span class="free">xs</span> <span class="main">!</span> <span class="main">(</span><span class="free">i</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nth_tl<span class="main">)</span>
<span class="keyword1"><span class="command">lemma</span></span> set_tl_subset <span class="main">[</span><span class="operator">forward_arg1</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>tl <span class="free">xs</span><span class="main">)</span> <span class="main">⊆</span> set <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> list.set_sel<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> subsetI tl_Nil<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹nth›</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">register_wellform_data</span> <span class="main">(</span><span class="inner_quoted">"xs ! i"</span><span class="main">,</span> <span class="main">[</span><span class="inner_quoted">"i &lt; length xs"</span><span class="main">]</span><span class="main">)</span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_prfstep_check_req</span> <span class="main">(</span><span class="inner_quoted">"xs ! i"</span><span class="main">,</span> <span class="inner_quoted">"i &lt; length xs"</span><span class="main">)</span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule_back</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> hd_conv_nth<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> List.nth_Cons'<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> List.nth_append<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> nth_mem<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_term</span> <span class="inner_quoted">"?xs ! ?n"</span><span class="main">]</span>›</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹sorted›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> sorted_Nil <span class="main">[</span><span class="operator">resolve</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"sorted <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">lemma</span></span> sorted_single <span class="main">[</span><span class="operator">resolve</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"sorted <span class="main">[</span><span class="free">x</span><span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_backward_prfstep</span> <span class="main">(</span><span class="entity">equiv_backward_th</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> sorted.simps<span class="main">(</span>2<span class="main">)</span><span class="antiquote">}</span></span></span><span class="main">)</span>›</span>

<span class="keyword1"><span class="command">lemma</span></span> sorted_ConsD1 <span class="main">[</span><span class="operator">forward</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"sorted <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⟹</span> sorted <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> sorted.simps<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">lemma</span></span> sorted_ConsD2 <span class="main">[</span><span class="operator">forward</span><span class="main">,</span> <span class="operator">backward2</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"sorted <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">y</span> <span class="main">∈</span> set <span class="free">xs</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">≤</span> <span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> sorted.simps<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> sorted_appendI <span class="main">[</span><span class="operator">backward</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"sorted <span class="free">xs</span> <span class="main">∧</span> sorted <span class="free">ys</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">∈</span>set <span class="free">xs</span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span><span class="main">∈</span>set <span class="free">ys</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="bound">y</span><span class="main">)</span> <span class="main">⟹</span> sorted <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sorted_append<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> sorted_appendE <span class="main">[</span><span class="operator">forward</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"sorted <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span> <span class="main">⟹</span> sorted <span class="free">xs</span> <span class="main">∧</span> sorted <span class="free">ys</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sorted_append<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> sorted_appendE2 <span class="main">[</span><span class="operator">forward</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"sorted <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">∈</span> set <span class="free">xs</span> <span class="main">⟹</span> <span class="main">∀</span><span class="bound">y</span><span class="main">∈</span>set <span class="free">ys</span><span class="main">.</span> <span class="free">x</span> <span class="main">≤</span> <span class="bound">y</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> sorted_append <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> sorted_nth_mono' <span class="main">[</span><span class="operator">backward</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"sorted <span class="free">xs</span> <span class="main">⟹</span> <span class="free">j</span> <span class="main">&lt;</span> length <span class="free">xs</span> <span class="main">⟹</span> <span class="free">i</span> <span class="main">≤</span> <span class="free">j</span> <span class="main">⟹</span> <span class="free">xs</span> <span class="main">!</span> <span class="free">i</span> <span class="main">≤</span> <span class="free">xs</span> <span class="main">!</span> <span class="free">j</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> sorted_nth_mono <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> sorted_nth_mono_less <span class="main">[</span><span class="operator">forward</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"sorted <span class="free">xs</span> <span class="main">⟹</span> <span class="free">i</span> <span class="main">&lt;</span> length <span class="free">xs</span> <span class="main">⟹</span> <span class="free">xs</span> <span class="main">!</span> <span class="free">i</span> <span class="main">&lt;</span> <span class="free">xs</span> <span class="main">!</span> <span class="free">j</span> <span class="main">⟹</span> <span class="free">i</span> <span class="main">&lt;</span> <span class="free">j</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> leD not_le_imp_less sorted_nth_mono<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹sort›</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> sorted_sort<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_term</span> <span class="inner_quoted">"sort ?xs"</span><span class="main">]</span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> length_sort<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> mset_sort<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> set_sort<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_backward_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> properties_for_sort<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">lemma</span></span> sort_Nil <span class="main">[</span><span class="operator">rewrite</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"sort <span class="main">[]</span> <span class="main">=</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">lemma</span></span> sort_singleton <span class="main">[</span><span class="operator">rewrite</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"sort <span class="main">[</span><span class="free">a</span><span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="free">a</span><span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹distinct›</span></span>
  
<span class="keyword1"><span class="command">lemma</span></span> distinct_Nil <span class="main">[</span><span class="operator">resolve</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_resolve_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> List.distinct_singleton<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> distinct.simps<span class="main">(</span>2<span class="main">)</span><span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_cond</span> <span class="inner_quoted">"?xs ≠ []"</span><span class="main">]</span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> distinct_append<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> distinct_rev<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> distinct_sort<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_resolve_prfstep</span> <span class="main">(</span><span class="entity">equiv_backward_th</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> distinct_conv_nth<span class="antiquote">}</span></span></span><span class="main">)</span>›</span>

<span class="keyword1"><span class="command">lemma</span></span> distinct_nthE <span class="main">[</span><span class="operator">forward</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"distinct <span class="free">xs</span> <span class="main">⟹</span> <span class="free">i</span> <span class="main">&lt;</span> length <span class="free">xs</span> <span class="main">⟹</span> <span class="free">j</span> <span class="main">&lt;</span> length <span class="free">xs</span> <span class="main">⟹</span> <span class="free">xs</span> <span class="main">!</span> <span class="free">i</span> <span class="main">=</span> <span class="free">xs</span> <span class="main">!</span> <span class="free">j</span> <span class="main">⟹</span> <span class="free">i</span> <span class="main">=</span> <span class="free">j</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> nth_eq_iff_index_eq <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹map function›</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹fold <span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> List.list.map<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> List.length_map<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> List.nth_map<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> List.map_append<span class="antiquote">}</span></span></span>›</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Replicate›</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_arg_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> length_replicate<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> List.nth_replicate<span class="antiquote">}</span></span></span>›</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹last›</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">register_wellform_data</span> <span class="main">(</span><span class="inner_quoted">"last xs"</span><span class="main">,</span> <span class="main">[</span><span class="inner_quoted">"xs ≠ []"</span><span class="main">]</span><span class="main">)</span>›</span>
<span class="keyword1"><span class="command">lemma</span></span> last_eval1 <span class="main">[</span><span class="operator">rewrite</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"last <span class="main">[</span><span class="free">x</span><span class="main">]</span> <span class="main">=</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">lemma</span></span> last_eval2 <span class="main">[</span><span class="operator">rewrite</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"last <span class="main">[</span><span class="free">u</span><span class="main">,</span> <span class="free">v</span><span class="main">]</span> <span class="main">=</span> <span class="free">v</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> List.last_ConsR<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> List.last_appendR<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> List.last_snoc<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule_back</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> last_conv_nth<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> List.last_in_set<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_term</span> <span class="inner_quoted">"last ?as"</span><span class="main">]</span>›</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹butlast›</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_arg_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> List.length_butlast<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> List.nth_butlast<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule_back</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> List.butlast_conv_take<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> List.butlast_snoc<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">lemma</span></span> butlast_eval1 <span class="main">[</span><span class="operator">rewrite</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"butlast <span class="main">[</span><span class="free">x</span><span class="main">]</span> <span class="main">=</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">lemma</span></span> butlast_eval2 <span class="main">[</span><span class="operator">rewrite</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"butlast <span class="main">[</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="free">x</span><span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">lemma</span></span> butlast_cons <span class="main">[</span><span class="operator">rewrite</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">as</span> <span class="main">≠</span> <span class="main">[]</span> <span class="main">⟹</span> butlast <span class="main">(</span><span class="free">a</span> <span class="main">#</span> <span class="free">as</span><span class="main">)</span> <span class="main">=</span> <span class="free">a</span> <span class="main">#</span> butlast <span class="free">as</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">lemma</span></span> butlast_append' <span class="main">[</span><span class="operator">rewrite</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">bs</span> <span class="main">≠</span> <span class="main">[]</span> <span class="main">⟹</span> butlast <span class="main">(</span><span class="free">as</span> <span class="main">@</span> <span class="free">bs</span><span class="main">)</span> <span class="main">=</span> <span class="free">as</span> <span class="main">@</span> butlast <span class="free">bs</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> butlast_append<span class="main">)</span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> List.append_butlast_last_id<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">lemma</span></span> set_butlast_is_subset<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>butlast <span class="free">xs</span><span class="main">)</span> <span class="main">⊆</span> set <span class="free">xs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> in_set_butlastD subsetI<span class="main">)</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_arg1_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> set_butlast_is_subset<span class="antiquote">}</span></span></span>›</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹List update›</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">register_wellform_data</span> <span class="main">(</span><span class="inner_quoted">"xs[i := x]"</span><span class="main">,</span> <span class="main">[</span><span class="inner_quoted">"i &lt; length xs"</span><span class="main">]</span><span class="main">)</span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_arg_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> List.length_list_update<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> List.nth_list_update_eq<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> List.nth_list_update_neq<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> List.nth_list_update<span class="antiquote">}</span></span></span>›</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹take›</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">register_wellform_data</span> <span class="main">(</span><span class="inner_quoted">"take n xs"</span><span class="main">,</span> <span class="main">[</span><span class="inner_quoted">"n ≤ length xs"</span><span class="main">]</span><span class="main">)</span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_prfstep_check_req</span> <span class="main">(</span><span class="inner_quoted">"take n xs"</span><span class="main">,</span> <span class="inner_quoted">"n ≤ length xs"</span><span class="main">)</span>›</span>

<span class="keyword1"><span class="command">lemma</span></span> length_take <span class="main">[</span><span class="operator">rewrite_arg</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">≤</span> length <span class="free">xs</span> <span class="main">⟹</span> length <span class="main">(</span>take <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="free">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">lemma</span></span> nth_take <span class="main">[</span><span class="operator">rewrite</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">&lt;</span> length <span class="main">(</span>take <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⟹</span> take <span class="free">n</span> <span class="free">xs</span> <span class="main">!</span> <span class="free">i</span> <span class="main">=</span> <span class="free">xs</span> <span class="main">!</span> <span class="free">i</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> List.take_0<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> List.take_Suc_conv_app_nth<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">lemma</span></span> take_length <span class="main">[</span><span class="operator">rewrite</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"take <span class="main">(</span>length <span class="free">xs</span><span class="main">)</span> <span class="free">xs</span> <span class="main">=</span> <span class="free">xs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_arg1_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> List.set_take_subset<span class="antiquote">}</span></span></span>›</span>

<span class="keyword1"><span class="command">lemma</span></span> take_Suc <span class="main">[</span><span class="operator">rewrite</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Suc <span class="free">n</span> <span class="main">≤</span> length <span class="free">xs</span> <span class="main">⟹</span> take <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="free">xs</span> <span class="main">=</span> take <span class="free">n</span> <span class="free">xs</span> <span class="main">@</span> <span class="main">[</span>nth <span class="free">xs</span> <span class="free">n</span><span class="main">]</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> Suc_le_lessD take_Suc_conv_app_nth <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> List.take_update_cancel<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> List.append_take_drop_id<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> List.take_all<span class="antiquote">}</span></span></span>›</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹drop›</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_arg_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> List.length_drop<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">lemma</span></span> nth_drop <span class="main">[</span><span class="operator">rewrite</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">&lt;</span> length <span class="main">(</span>drop <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⟹</span> drop <span class="free">n</span> <span class="free">xs</span> <span class="main">!</span> <span class="free">i</span> <span class="main">=</span> <span class="free">xs</span> <span class="main">!</span> <span class="main">(</span><span class="free">n</span> <span class="main">+</span> <span class="free">i</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> List.drop_0<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> List.drop_all<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule_back</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> List.take_drop<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> List.drop_drop<span class="antiquote">}</span></span></span>›</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹rev›</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_arg_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> List.length_rev<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹fold <span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> List.rev.simps<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> List.rev_append<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> List.rev_rev_ident<span class="antiquote">}</span></span></span>›</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹filter›</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹fold <span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> filter.simps<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> filter_append<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule_bidir</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> rev_filter<span class="antiquote">}</span></span></span>›</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹concat›</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹fold <span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> concat.simps<span class="antiquote">}</span></span></span>›</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹mset›</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> mset.simps<span class="main">(</span>1<span class="main">)</span><span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">lemma</span></span> mset_simps_2 <span class="main">[</span><span class="operator">rewrite</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"mset <span class="main">(</span><span class="free">a</span> <span class="main">#</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> mset <span class="free">x</span> <span class="main">+</span> <span class="main">{#</span><span class="free">a</span><span class="main">#}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> mset_append<span class="antiquote">}</span></span></span>›</span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> mset_eq_setD<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> in_multiset_in_set<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_term</span> <span class="inner_quoted">"set ?xs"</span><span class="main">]</span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule_back_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> in_multiset_in_set<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_term</span> <span class="inner_quoted">"mset ?xs"</span><span class="main">]</span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_backward_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Multiset.nth_mem_mset<span class="antiquote">}</span></span></span>›</span>

<span class="keyword1"><span class="command">lemma</span></span> in_mset_conv_nth <span class="main">[</span><span class="operator">resolve</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈#</span> mset <span class="free">xs</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound"><span class="bound">i</span></span><span class="main">&lt;</span>length <span class="free">xs</span><span class="main">.</span> <span class="free">x</span> <span class="main">=</span> <span class="free">xs</span> <span class="main">!</span> <span class="bound">i</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> in_multiset_in_set in_set_conv_nth<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> hd_in_mset<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≠</span> <span class="main">[]</span> <span class="main">⟹</span> hd <span class="free">xs</span> <span class="main">∈#</span> mset <span class="free">xs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> hd_in_mset<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_term</span> <span class="inner_quoted">"hd ?xs"</span><span class="main">,</span> <span class="entity">with_term</span> <span class="inner_quoted">"mset ?xs"</span><span class="main">]</span>›</span>

<span class="keyword1"><span class="command">lemma</span></span> last_in_mset<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≠</span> <span class="main">[]</span> <span class="main">⟹</span> last <span class="free">xs</span> <span class="main">∈#</span> mset <span class="free">xs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> last_in_mset<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_term</span> <span class="inner_quoted">"last ?xs"</span><span class="main">,</span> <span class="entity">with_term</span> <span class="inner_quoted">"mset ?xs"</span><span class="main">]</span>›</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Relationship between mset and set of lists›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> mset_butlast <span class="main">[</span><span class="operator">rewrite</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≠</span> <span class="main">[]</span> <span class="main">⟹</span> mset <span class="main">(</span>butlast <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> mset <span class="free">xs</span> <span class="main">-</span> <span class="main">{#</span> last <span class="free">xs</span> <span class="main">#}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> add_diff_cancel_right' append_butlast_last_id mset.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> mset.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> union_code<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> insert_mset_to_set <span class="main">[</span><span class="operator">rewrite</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"mset <span class="free">xs'</span> <span class="main">=</span> mset <span class="free">xs</span> <span class="main">+</span> <span class="main">{#</span> <span class="free">x</span> <span class="main">#}</span> <span class="main">⟹</span> set <span class="free">xs'</span> <span class="main">=</span> set <span class="free">xs</span> <span class="main">∪</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> set_mset_mset set_mset_single set_mset_union<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> delete_mset_to_set <span class="main">[</span><span class="operator">rewrite</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"distinct <span class="free">xs</span> <span class="main">⟹</span> mset <span class="free">xs'</span> <span class="main">=</span> mset <span class="free">xs</span> <span class="main">-</span> <span class="main">{#</span> <span class="free">x</span> <span class="main">#}</span> <span class="main">⟹</span> set <span class="free">xs'</span> <span class="main">=</span> set <span class="free">xs</span> <span class="main">-</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> mset_eq_setD mset_remove1 set_remove1_eq<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> update_mset_to_set <span class="main">[</span><span class="operator">rewrite</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"distinct <span class="free">xs</span> <span class="main">⟹</span> mset <span class="free">xs'</span> <span class="main">=</span> <span class="main">{#</span> <span class="free">y</span> <span class="main">#}</span> <span class="main">+</span> <span class="main">(</span>mset <span class="free">xs</span> <span class="main">-</span> <span class="main">{#</span> <span class="free">x</span> <span class="main">#}</span><span class="main">)</span> <span class="main">⟹</span> set <span class="free">xs'</span> <span class="main">=</span> <span class="main">(</span>set <span class="free">xs</span> <span class="main">-</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span><span class="main">)</span> <span class="main">∪</span> <span class="main">{</span><span class="free">y</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> insert_mset_to_set mset_remove1 set_remove1_eq union_commute<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> mset_update' <span class="main">[</span><span class="operator">rewrite</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">&lt;</span> length <span class="free">ls</span> <span class="main">⟹</span> mset <span class="main">(</span><span class="free">ls</span><span class="main">[</span><span class="free">i</span> <span class="main">:=</span> <span class="free">v</span><span class="main">]</span><span class="main">)</span> <span class="main">=</span> <span class="main">{#</span><span class="free">v</span><span class="main">#}</span> <span class="main">+</span> <span class="main">(</span>mset <span class="free">ls</span> <span class="main">-</span> <span class="main">{#</span> <span class="free">ls</span> <span class="main">!</span> <span class="free">i</span> <span class="main">#}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> mset_update <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹swap›</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> mset_swap<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> set_swap<span class="antiquote">}</span></span></span>›</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹upto lists›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> upt_zero_length <span class="main">[</span><span class="operator">rewrite</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">]</span> <span class="main">=</span> <span class="free">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">lemma</span></span> nth_upt_zero <span class="main">[</span><span class="operator">rewrite</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">&lt;</span> length <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">]</span> <span class="main">⟹</span> <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">]</span> <span class="main">!</span> <span class="free">i</span> <span class="main">=</span> <span class="free">i</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Lambda lists›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">list</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nat <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⇒</span> nat <span class="main">⇒</span> <span class="tfree">'a</span> list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">list</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> map <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">[</span><span class="main">0</span> <span class="main">..&lt;</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">]</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> list_length <span class="main">[</span><span class="operator">rewrite_arg</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>list <span class="free">s</span> <span class="free">n</span><span class="main">)</span> <span class="main">=</span> <span class="free">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> list_def<span class="main">)</span>
<span class="keyword1"><span class="command">lemma</span></span> list_nth <span class="main">[</span><span class="operator">rewrite</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">&lt;</span> length <span class="main">(</span>list <span class="free">s</span> <span class="free">n</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span>list <span class="free">s</span> <span class="free">n</span><span class="main">)</span> <span class="main">!</span> <span class="free">i</span> <span class="main">=</span> <span class="free">s</span> <span class="free">i</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> list_def<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Splitting of lists›</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_resolve_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> split_list<span class="antiquote">}</span></span></span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_backward_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> not_distinct_decomp<span class="antiquote">}</span></span></span>›</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Finiteness›</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_resolve_prfstep</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> finite_lists_length_le<span class="antiquote">}</span></span></span>›</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Cardinality›</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_rewrite_rule</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> distinct_card<span class="antiquote">}</span></span></span>›</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="files/list_ac.ML">
<div class="head">
<h1>File ‹list_ac.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*
  File: list_ac.ML
  Author: Bohua Zhan

  Special normalization procedure for list append.

  In addition to normalizing the AC function append, also normalize a # xs to
  [a] @ xs.
*)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">LIST_AC</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">heads</span> <span class="main">=</span> <span class="entity">LIST_APPEND</span> <span class="main">|</span> <span class="entity">LIST_CONS</span> <span class="main">|</span> <span class="entity">LIST_NIL</span> <span class="main">|</span> <span class="entity">LIST_OTHER</span>
  <span class="keyword1"><span class="keyword">val</span></span> append_const<span class="main">:</span> typ <span class="main">-&gt;</span> term
  <span class="keyword1"><span class="keyword">val</span></span> case_head<span class="main">:</span> typ <span class="main">-&gt;</span> term <span class="main">-&gt;</span> <span class="entity">heads</span>
  <span class="keyword1"><span class="keyword">val</span></span> is_list_head<span class="main">:</span> typ <span class="main">-&gt;</span> term <span class="main">-&gt;</span> bool
  <span class="keyword1"><span class="keyword">val</span></span> get_list_ty<span class="main">:</span> term <span class="main">-&gt;</span> typ option
  <span class="keyword1"><span class="keyword">val</span></span> rewrite_on_eqs<span class="main">:</span> typ <span class="main">-&gt;</span> thm list <span class="main">-&gt;</span> cterm <span class="main">-&gt;</span> thm
  <span class="keyword1"><span class="keyword">val</span></span> dest_list_full<span class="main">:</span> <span class="entity">Proof.context</span> <span class="main">-&gt;</span> typ <span class="main">-&gt;</span> cterm <span class="main">-&gt;</span> cterm list
  <span class="keyword1"><span class="keyword">val</span></span> simp_list_expr<span class="main">:</span>
      <span class="entity">Proof.context</span> <span class="main">-&gt;</span> typ <span class="main">-&gt;</span> <span class="entity">box_id</span> * cterm <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * thm<span class="main">)</span> list
  <span class="keyword1"><span class="keyword">val</span></span> get_list_head_equiv<span class="main">:</span>
      <span class="entity">Proof.context</span> <span class="main">-&gt;</span> typ <span class="main">-&gt;</span> <span class="entity">box_id</span> * cterm <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * thm<span class="main">)</span> list
  <span class="keyword1"><span class="keyword">val</span></span> list_expand_once<span class="main">:</span>
      <span class="entity">Proof.context</span> <span class="main">-&gt;</span> typ <span class="main">-&gt;</span> <span class="entity">box_id</span> * cterm <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * thm<span class="main">)</span> list
  <span class="keyword1"><span class="keyword">val</span></span> list_expand<span class="main">:</span>
      <span class="entity">Proof.context</span> <span class="main">-&gt;</span> typ <span class="main">-&gt;</span> <span class="entity">box_id</span> * cterm <span class="main">-&gt;</span> <span class="main">(</span><span class="entity">box_id</span> * thm<span class="main">)</span> list
  <span class="keyword1"><span class="keyword">val</span></span> normalize_list_assoc<span class="main">:</span> typ <span class="main">-&gt;</span> conv
  <span class="keyword1"><span class="keyword">val</span></span> normalize_list<span class="main">:</span> typ <span class="main">-&gt;</span> conv
  <span class="keyword1"><span class="keyword">val</span></span> list_expand_equiv<span class="main">:</span> <span class="entity">proofstep</span>
  <span class="keyword1"><span class="keyword">val</span></span> list_expand_unit<span class="main">:</span> <span class="entity">proofstep</span>
  <span class="keyword1"><span class="keyword">val</span></span> add_list_proofsteps<span class="main">:</span> theory <span class="main">-&gt;</span> theory
<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">List_AC</span> <span class="main">:</span> <span class="entity">LIST_AC</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">datatype</span></span> <span class="entity">heads</span> <span class="main">=</span> <span class="entity">LIST_APPEND</span> <span class="main">|</span> <span class="entity">LIST_CONS</span> <span class="main">|</span> <span class="entity">LIST_NIL</span> <span class="main">|</span> <span class="entity">LIST_OTHER</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">append_const</span> <span class="entity">T</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lT</span> <span class="main">=</span> <span class="entity">HOLogic.listT</span> <span class="entity">T</span>
    <span class="keyword2"><span class="keyword">in</span></span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> append<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">lT</span> --&gt; <span class="entity">lT</span> --&gt; <span class="entity">lT</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">case_head</span> <span class="entity">T</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">Util.is_head</span> <span class="main">(</span><span class="entity">append_const</span> <span class="entity">T</span><span class="main">)</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">LIST_APPEND</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">Util.is_head</span> <span class="main">(</span><span class="entity">HOLogic.cons_const</span> <span class="entity">T</span><span class="main">)</span> <span class="entity">t</span> <span class="keyword1"><span class="keyword">andalso</span></span>
            not <span class="main">(</span><span class="entity">dest_arg</span> <span class="entity">t</span> aconv <span class="entity">HOLogic.nil_const</span> <span class="entity">T</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">LIST_CONS</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">t</span> aconv <span class="entity">HOLogic.nil_const</span> <span class="entity">T</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">LIST_NIL</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">LIST_OTHER</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_list_head</span> <span class="entity">T</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">case_head</span> <span class="entity">T</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="entity">LIST_APPEND</span> <span class="main">=&gt;</span> true
      <span class="main">|</span> <span class="entity">LIST_CONS</span> <span class="main">=&gt;</span> true
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_list_ty</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> fastype_of <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
        Type <span class="main">(</span><span class="inner_quoted">"List.list"</span><span class="main">,</span> <span class="main">[</span><span class="entity">T</span><span class="main">]</span><span class="main">)</span> <span class="main">=&gt;</span> SOME <span class="entity">T</span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> NONE

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rewrite_on_eqs</span> <span class="entity">T</span> <span class="entity">eqs</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">case_head</span> <span class="entity">T</span> <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="entity">LIST_APPEND</span> <span class="main">=&gt;</span> Conv.binop_conv <span class="main">(</span><span class="entity">rewrite_on_eqs</span> <span class="entity">T</span> <span class="entity">eqs</span><span class="main">)</span> <span class="entity">ct</span>
      <span class="main">|</span> <span class="entity">LIST_CONS</span> <span class="main">=&gt;</span> Conv.binop_conv <span class="main">(</span><span class="entity">rewrite_on_eqs</span> <span class="entity">T</span> <span class="entity">eqs</span><span class="main">)</span> <span class="entity">ct</span>
      <span class="main">|</span> <span class="entity">LIST_NIL</span> <span class="main">=&gt;</span> Conv.all_conv <span class="entity">ct</span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span>
        <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> find_first <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">eq</span> <span class="main">=&gt;</span> <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span> aconv <span class="main">(</span><span class="entity">Util.lhs_of</span> <span class="entity">eq</span><span class="main">)</span><span class="main">)</span> <span class="entity">eqs</span> <span class="keyword2"><span class="keyword">of</span></span>
             NONE <span class="main">=&gt;</span> Conv.all_conv <span class="entity">ct</span>
           <span class="main">|</span> SOME <span class="entity">eq_th</span> <span class="main">=&gt;</span> <span class="entity">eq_th</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_list_full</span> <span class="entity">ctxt</span> <span class="entity">T</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">case_head</span> <span class="entity">T</span> <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="entity">LIST_APPEND</span> <span class="main">=&gt;</span> <span class="entity">dest_list_full</span> <span class="entity">ctxt</span> <span class="entity">T</span> <span class="main">(</span>Thm.dest_arg1 <span class="entity">ct</span><span class="main">)</span> @
                       <span class="entity">dest_list_full</span> <span class="entity">ctxt</span> <span class="entity">T</span> <span class="main">(</span>Thm.dest_arg <span class="entity">ct</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">LIST_CONS</span> <span class="main">=&gt;</span> Thm.cterm_of <span class="entity">ctxt</span> <span class="main">(</span>
                      <span class="entity">HOLogic.mk_list</span> <span class="entity">T</span> <span class="main">[</span><span class="entity">dest_arg1</span> <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> ::
                     <span class="entity">dest_list_full</span> <span class="entity">ctxt</span> <span class="entity">T</span> <span class="main">(</span>Thm.dest_arg <span class="entity">ct</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">LIST_NIL</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="main">]</span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="entity">ct</span><span class="main">]</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_subs</span> <span class="entity">ctxt</span> <span class="entity">T</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">case_head</span> <span class="entity">T</span> <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="entity">LIST_APPEND</span> <span class="main">=&gt;</span> <span class="entity">dest_subs</span> <span class="entity">ctxt</span> <span class="entity">T</span> <span class="main">(</span>Thm.dest_arg1 <span class="entity">ct</span><span class="main">)</span> @
                       <span class="entity">dest_subs</span> <span class="entity">ctxt</span> <span class="entity">T</span> <span class="main">(</span>Thm.dest_arg <span class="entity">ct</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">LIST_CONS</span> <span class="main">=&gt;</span> Thm.dest_arg1 <span class="entity">ct</span> ::
                     <span class="entity">dest_subs</span> <span class="entity">ctxt</span> <span class="entity">T</span> <span class="main">(</span>Thm.dest_arg <span class="entity">ct</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">LIST_NIL</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="main">]</span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="entity">ct</span><span class="main">]</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">simp_list_expr</span> <span class="entity">ctxt</span> <span class="entity">T</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">cu</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cus</span> <span class="main">=</span> <span class="entity">dest_subs</span> <span class="entity">ctxt</span> <span class="entity">T</span> <span class="entity">cu</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">cus</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">(</span><span class="entity">id</span><span class="main">,</span> Thm.reflexive <span class="entity">cu</span><span class="main">)</span><span class="main">]</span> <span class="keyword2"><span class="keyword">else</span></span>
      <span class="entity">cus</span> |&gt; map <span class="main">(</span><span class="entity">RewriteTable.simplify_info</span> <span class="entity">ctxt</span><span class="main">)</span>
          |&gt; <span class="entity">BoxID.get_all_merges_info</span> <span class="entity">ctxt</span>
          |&gt; <span class="entity">BoxID.merge_box_with_info</span> <span class="entity">ctxt</span> <span class="entity">id</span>
          |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">eqs</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">rewrite_on_eqs</span> <span class="entity">T</span> <span class="entity">eqs</span> <span class="entity">cu</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Obtain head equivalences of cu, where each term is simplified. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_list_head_equiv</span> <span class="entity">ctxt</span> <span class="entity">T</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">cu</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_head_equiv</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">eq_th</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">infos</span> <span class="main">=</span> <span class="entity">simp_list_expr</span> <span class="entity">ctxt</span> <span class="entity">T</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> Thm.rhs_of <span class="entity">eq_th</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            map <span class="main">(</span><span class="entity">BoxID.merge_eq_infos</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">eq_th</span><span class="main">)</span><span class="main">)</span> <span class="entity">infos</span>
          <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">cu</span> |&gt; <span class="entity">RewriteTable.get_head_equiv</span> <span class="entity">ctxt</span>
         |&gt; <span class="entity">BoxID.merge_box_with_info</span> <span class="entity">ctxt</span> <span class="entity">id</span>
         |&gt; maps <span class="entity">process_head_equiv</span>
         |&gt; filter_out <span class="main">(</span>Thm.is_reflexive o snd<span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Find ways to modify ct once by rewriting one of the subterms. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">list_expand_once</span> <span class="entity">ctxt</span> <span class="entity">T</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">ct</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cus</span> <span class="main">=</span> <span class="entity">dest_subs</span> <span class="entity">ctxt</span> <span class="entity">T</span> <span class="entity">ct</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_equiv</span> <span class="entity">cu</span> <span class="main">=</span> <span class="entity">get_list_head_equiv</span> <span class="entity">ctxt</span> <span class="entity">T</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">cu</span><span class="main">)</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_info</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">eq</span><span class="main">)</span> <span class="main">=</span>
          <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">rewrite_on_eqs</span> <span class="entity">T</span> <span class="main">[</span><span class="entity">eq</span><span class="main">]</span> <span class="entity">ct</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      map <span class="entity">process_info</span> <span class="main">(</span>maps <span class="entity">get_equiv</span> <span class="entity">cus</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Find all ways to write ct, up to a certain limit. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">list_expand</span> <span class="entity">ctxt</span> <span class="entity">T</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">ct</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">max_ac</span> <span class="main">=</span> Config.get <span class="entity">ctxt</span> <span class="entity">AC_ProofSteps.max_ac</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">list_equiv_eq_better</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">th'</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">seq1</span> <span class="main">=</span> <span class="entity">dest_list_full</span> <span class="entity">ctxt</span> <span class="entity">T</span> <span class="main">(</span>Thm.rhs_of <span class="entity">th</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">seq2</span> <span class="main">=</span> <span class="entity">dest_list_full</span> <span class="entity">ctxt</span> <span class="entity">T</span> <span class="main">(</span>Thm.rhs_of <span class="entity">th'</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="entity">Util.is_subseq</span> <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv o apply2 Thm.term_of<span class="main">)</span> <span class="main">(</span><span class="entity">seq1</span><span class="main">,</span> <span class="entity">seq2</span><span class="main">)</span> <span class="keyword1"><span class="keyword">andalso</span></span>
            <span class="entity">BoxID.is_eq_ancestor</span> <span class="entity">ctxt</span> <span class="entity">id</span> <span class="entity">id'</span>
          <span class="keyword2"><span class="keyword">end</span></span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">has_list_equiv_eq_better</span> <span class="entity">infos</span> <span class="entity">info'</span> <span class="main">=</span>
          exists <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">info</span> <span class="main">=&gt;</span> <span class="entity">list_equiv_eq_better</span> <span class="entity">info</span> <span class="entity">info'</span><span class="main">)</span> <span class="entity">infos</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">helper</span> <span class="main">(</span><span class="entity">old</span><span class="main">,</span> <span class="entity">new</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">new</span> <span class="keyword2"><span class="keyword">of</span></span>
              <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="entity">old</span>
            <span class="main">|</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">eq_th</span><span class="main">)</span> :: <span class="entity">rest</span> <span class="main">=&gt;</span>
              <span class="keyword2"><span class="keyword">if</span></span> length <span class="entity">old</span> + length <span class="entity">new</span> &gt; <span class="entity">max_ac</span> <span class="keyword2"><span class="keyword">then</span></span>
                <span class="entity">old</span> @ take <span class="main">(</span><span class="entity">max_ac</span> - length <span class="entity">old</span><span class="main">)</span> <span class="entity">new</span>
              <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">old'</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">eq_th</span><span class="main">)</span> :: <span class="entity">old</span><span class="main">)</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs_expand</span> <span class="main">=</span>
                    <span class="main">(</span><span class="entity">list_expand_once</span> <span class="entity">ctxt</span> <span class="entity">T</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> Thm.rhs_of <span class="entity">eq_th</span><span class="main">)</span><span class="main">)</span>
                        |&gt; <span class="entity">Util.max_partial</span> <span class="entity">list_equiv_eq_better</span>
                        |&gt; map <span class="main">(</span><span class="entity">BoxID.merge_eq_infos</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">eq_th</span><span class="main">)</span><span class="main">)</span>
                        |&gt; filter_out <span class="main">(</span><span class="entity">has_list_equiv_eq_better</span> <span class="main">(</span><span class="entity">old'</span> @ <span class="entity">rest</span><span class="main">)</span><span class="main">)</span>
              <span class="keyword2"><span class="keyword">in</span></span>
                <span class="entity">helper</span> <span class="main">(</span><span class="entity">old'</span><span class="main">,</span> <span class="entity">rest</span> @ <span class="entity">rhs_expand</span><span class="main">)</span>
              <span class="keyword2"><span class="keyword">end</span></span>

      <span class="comment1">(* Start term *)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">start</span> <span class="main">=</span> <span class="entity">simp_list_expr</span> <span class="entity">ctxt</span> <span class="entity">T</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">ct</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">helper</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">start</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">normalize_list_assoc</span> <span class="entity">T</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">case_head</span> <span class="entity">T</span> <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="entity">LIST_APPEND</span> <span class="main">=&gt;</span>
        <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">case_head</span> <span class="entity">T</span> <span class="main">(</span><span class="entity">dest_arg1</span> <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
             <span class="entity">LIST_APPEND</span> <span class="main">=&gt;</span>
             Conv.every_conv <span class="main">[</span><span class="entity">rewr_obj_eq</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> List.append_assoc<span class="antiquote">}</span></span></span><span class="main">,</span>
                              Conv.arg_conv <span class="main">(</span><span class="entity">normalize_list_assoc</span> <span class="entity">T</span><span class="main">)</span><span class="main">]</span> <span class="entity">ct</span>
           <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> Conv.all_conv <span class="entity">ct</span><span class="main">)</span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> Conv.all_conv <span class="entity">ct</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">normalize_list</span> <span class="entity">T</span> <span class="entity">ct</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">case_head</span> <span class="entity">T</span> <span class="main">(</span>Thm.term_of <span class="entity">ct</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="entity">LIST_APPEND</span> <span class="main">=&gt;</span>
        Conv.every_conv <span class="main">[</span>
          Conv.binop_conv <span class="main">(</span><span class="entity">normalize_list</span> <span class="entity">T</span><span class="main">)</span><span class="main">,</span>
          Conv.try_conv <span class="main">(</span><span class="entity">rewr_obj_eq</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> List.append.append_Nil<span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">,</span>
          Conv.try_conv <span class="main">(</span><span class="entity">rewr_obj_eq</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> List.append_Nil2<span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">,</span>
          <span class="entity">normalize_list_assoc</span> <span class="entity">T</span><span class="main">]</span> <span class="entity">ct</span>
      <span class="main">|</span> <span class="entity">LIST_CONS</span> <span class="main">=&gt;</span>
        Conv.every_conv <span class="main">[</span><span class="entity">rewr_obj_eq</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> cons_to_append<span class="antiquote">}</span></span></span><span class="main">,</span>
                         <span class="entity">normalize_list</span> <span class="entity">T</span><span class="main">]</span> <span class="entity">ct</span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> Conv.all_conv <span class="entity">ct</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">list_expand_equiv_fn</span> <span class="entity">ctxt</span> <span class="entity">item1</span> <span class="entity">item2</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span>id <span class="main">=</span> <span class="entity">id1</span><span class="main">,</span> tname <span class="main">=</span> <span class="entity">tname1</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">item1</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span>id <span class="main">=</span> <span class="entity">id2</span><span class="main">,</span> tname <span class="main">=</span> <span class="entity">tname2</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">item2</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">ct1</span><span class="main">,</span> <span class="entity">ct2</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>the_single <span class="entity">tname1</span><span class="main">,</span> the_single <span class="entity">tname2</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Thm.term_of <span class="entity">ct1</span><span class="main">,</span> Thm.term_of <span class="entity">ct2</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">id</span> <span class="main">=</span> <span class="entity">BoxID.merge_boxes</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id1</span><span class="main">,</span> <span class="entity">id2</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">T</span> <span class="main">=</span> the <span class="main">(</span><span class="entity">get_list_ty</span> <span class="entity">t1</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> Term_Ord.term_ord <span class="main">(</span><span class="entity">t2</span><span class="main">,</span> <span class="entity">t1</span><span class="main">)</span> <span class="main">=</span> LESS <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">RewriteTable.is_equiv</span> <span class="entity">id</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">ct1</span><span class="main">,</span> <span class="entity">ct2</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span><span class="entity">is_list_head</span> <span class="entity">T</span> <span class="entity">t1</span><span class="main">)</span> <span class="keyword1"><span class="keyword">orelse</span></span> not <span class="main">(</span><span class="entity">is_list_head</span> <span class="entity">T</span> <span class="entity">t2</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">expand1</span> <span class="main">=</span> <span class="entity">list_expand</span> <span class="entity">ctxt</span> <span class="entity">T</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">ct1</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">expand2</span> <span class="main">=</span> <span class="entity">list_expand</span> <span class="entity">ctxt</span> <span class="entity">T</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">ct2</span><span class="main">)</span>

        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_equiv</span> <span class="main">(</span><span class="main">(</span><span class="entity">id1</span><span class="main">,</span> <span class="entity">eq_th1</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">id2</span><span class="main">,</span> <span class="entity">eq_th2</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
            <span class="keyword2"><span class="keyword">let</span></span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ct1</span> <span class="main">=</span> Thm.rhs_of <span class="entity">eq_th1</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ct2</span> <span class="main">=</span> Thm.rhs_of <span class="entity">eq_th2</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ts1</span> <span class="main">=</span> <span class="entity">dest_list_full</span> <span class="entity">ctxt</span> <span class="entity">T</span> <span class="entity">ct1</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ts2</span> <span class="main">=</span> <span class="entity">dest_list_full</span> <span class="entity">ctxt</span> <span class="entity">T</span> <span class="entity">ct2</span>
            <span class="keyword2"><span class="keyword">in</span></span>
              <span class="keyword2"><span class="keyword">if</span></span> eq_list <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv o apply2 Thm.term_of<span class="main">)</span> <span class="main">(</span><span class="entity">ts1</span><span class="main">,</span> <span class="entity">ts2</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
                <span class="keyword2"><span class="keyword">let</span></span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq_th1'</span> <span class="main">=</span> <span class="entity">normalize_list</span> <span class="entity">T</span> <span class="entity">ct1</span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq_th2'</span> <span class="main">=</span> <span class="entity">normalize_list</span> <span class="entity">T</span> <span class="entity">ct2</span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">id'</span> <span class="main">=</span> <span class="entity">BoxID.merge_boxes</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id1</span><span class="main">,</span> <span class="entity">id2</span><span class="main">)</span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq</span> <span class="main">=</span> <span class="entity">Util.transitive_list</span> <span class="main">[</span>
                        <span class="entity">eq_th1</span><span class="main">,</span> <span class="entity">eq_th1'</span><span class="main">,</span> <span class="entity">meta_sym</span> <span class="entity">eq_th2'</span><span class="main">,</span> <span class="entity">meta_sym</span> <span class="entity">eq_th2</span><span class="main">]</span>
                <span class="keyword2"><span class="keyword">in</span></span>
                  <span class="main">[</span><span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">to_obj_eq</span> <span class="entity">eq</span><span class="main">)</span><span class="main">]</span>
                <span class="keyword2"><span class="keyword">end</span></span>
              <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="main">]</span>
            <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span>maps <span class="entity">get_equiv</span> <span class="main">(</span><span class="entity">Util.all_pairs</span> <span class="main">(</span><span class="entity">expand1</span><span class="main">,</span> <span class="entity">expand2</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
            |&gt; filter <span class="main">(</span><span class="entity">BoxID.has_incr_id</span> o fst<span class="main">)</span>
            |&gt; <span class="entity">Util.max_partial</span> <span class="main">(</span><span class="entity">BoxID.id_is_eq_ancestor</span> <span class="entity">ctxt</span><span class="main">)</span>
            |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">Update.thm_update_sc</span> <span class="inner_numeral">1</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">list_expand_equiv</span> <span class="main">=</span>
    <span class="main">{</span>name <span class="main">=</span> <span class="inner_quoted">"list_expand_equiv"</span><span class="main">,</span>
     args <span class="main">=</span> <span class="main">[</span><span class="entity">TypedMatch</span> <span class="main">(</span><span class="entity">TY_TERM</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term_pat</span> <span class="quoted">"<span class="var">?A</span><span class="main">::</span><span class="tvar">?'a</span> list"</span><span class="antiquote">}</span></span><span class="main">)</span><span class="main">,</span>
             <span class="entity">TypedMatch</span> <span class="main">(</span><span class="entity">TY_TERM</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term_pat</span> <span class="quoted">"<span class="var">?B</span><span class="main">::</span><span class="tvar">?'a</span> list"</span><span class="antiquote">}</span></span><span class="main">)</span><span class="main">]</span><span class="main">,</span>
     func <span class="main">=</span> <span class="entity">TwoStep</span> <span class="entity">list_expand_equiv_fn</span><span class="main">}</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">list_expand_unit_fn</span> <span class="entity">ctxt</span> <span class="entity">item</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span><span class="entity">id</span><span class="main">,</span> <span class="entity">tname</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">item</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ct</span> <span class="main">=</span> the_single <span class="entity">tname</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Thm.term_of <span class="entity">ct</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">T</span> <span class="main">=</span> the <span class="main">(</span><span class="entity">get_list_ty</span> <span class="entity">t</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span><span class="entity">is_list_head</span> <span class="entity">T</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span><span class="main">]</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">expand</span> <span class="main">=</span> <span class="entity">list_expand</span> <span class="entity">ctxt</span> <span class="entity">T</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">ct</span><span class="main">)</span>

        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">process_expand</span> <span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">eq_th</span><span class="main">)</span> <span class="main">=</span>
            <span class="keyword2"><span class="keyword">let</span></span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ct</span> <span class="main">=</span> Thm.rhs_of <span class="entity">eq_th</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ts</span> <span class="main">=</span> <span class="entity">dest_list_full</span> <span class="entity">ctxt</span> <span class="entity">T</span> <span class="entity">ct</span>
            <span class="keyword2"><span class="keyword">in</span></span>
              <span class="keyword2"><span class="keyword">if</span></span> length <span class="entity">ts</span> &lt;= <span class="inner_numeral">1</span> <span class="keyword2"><span class="keyword">then</span></span>
                <span class="keyword2"><span class="keyword">let</span></span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq'</span> <span class="main">=</span> <span class="entity">normalize_list</span> <span class="entity">T</span> <span class="entity">ct</span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq</span> <span class="main">=</span> <span class="entity">Util.transitive_list</span> <span class="main">[</span><span class="entity">eq_th</span><span class="main">,</span> <span class="entity">eq'</span><span class="main">]</span>
                <span class="keyword2"><span class="keyword">in</span></span>
                  <span class="main">[</span><span class="main">(</span><span class="entity">id'</span><span class="main">,</span> <span class="entity">to_obj_eq</span> <span class="entity">eq</span><span class="main">)</span><span class="main">]</span>
                <span class="keyword2"><span class="keyword">end</span></span>
              <span class="keyword2"><span class="keyword">else</span></span> <span class="main">[</span><span class="main">]</span>
            <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span>maps <span class="entity">process_expand</span> <span class="entity">expand</span><span class="main">)</span>
            |&gt; filter <span class="main">(</span><span class="entity">BoxID.has_incr_id</span> o fst<span class="main">)</span>
            |&gt; map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">Update.thm_update_sc</span> <span class="inner_numeral">1</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">list_expand_unit</span> <span class="main">=</span>
    <span class="main">{</span>name <span class="main">=</span> <span class="inner_quoted">"list_expand_unit"</span><span class="main">,</span>
     args <span class="main">=</span> <span class="main">[</span><span class="entity">TypedMatch</span> <span class="main">(</span><span class="entity">TY_TERM</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term_pat</span> <span class="quoted">"<span class="var">?A</span><span class="main">::</span><span class="tvar">?'a</span> list"</span><span class="antiquote">}</span></span><span class="main">)</span><span class="main">]</span><span class="main">,</span>
     func <span class="main">=</span> <span class="entity">OneStep</span> <span class="entity">list_expand_unit_fn</span><span class="main">}</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">add_list_proofsteps</span> <span class="main">=</span>
    fold <span class="entity">add_prfstep</span> <span class="main">[</span>
      <span class="entity">list_expand_equiv</span><span class="main">,</span> <span class="entity">list_expand_unit</span>
    <span class="main">]</span>

<span class="keyword2"><span class="keyword">end</span></span>  <span class="comment1">(* structure List_AC. *)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> Theory.setup <span class="entity">List_AC.add_list_proofsteps</span>
</pre>
</div><div id="files/list_ac_test.ML">
<div class="head">
<h1>File ‹list_ac_test.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*
  File: list_ac_test.ML
  Author: Bohua Zhan

  Unit test for list_ac.ML.
*)</span>

<span class="keyword2"><span class="keyword">local</span></span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ts</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span> Free <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"nat list"</span><span class="antiquote">}</span></span><span class="main">)</span><span class="main">)</span> <span class="main">[</span><span class="inner_quoted">"xs"</span><span class="main">]</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt</span> <span class="main">=</span> fold <span class="entity">Util.declare_free_term</span> <span class="entity">ts</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">T</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">nat</span><span class="antiquote">}</span></span>

<span class="keyword2"><span class="keyword">in</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">test_norm_t</span> <span class="entity">err_str</span> <span class="main">(</span><span class="entity">str1</span><span class="main">,</span> <span class="entity">str2</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span> apply2 <span class="main">(</span>Syntax.read_term <span class="entity">ctxt</span><span class="main">)</span> <span class="main">(</span><span class="entity">str1</span><span class="main">,</span> <span class="entity">str2</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">ct1</span><span class="main">,</span> <span class="entity">ct2</span><span class="main">)</span> <span class="main">=</span> apply2 <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span><span class="main">)</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ts1</span> <span class="main">=</span> <span class="entity">List_AC.dest_list_full</span> <span class="entity">ctxt</span> <span class="entity">T</span> <span class="entity">ct1</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ts2</span> <span class="main">=</span> <span class="entity">List_AC.dest_list_full</span> <span class="entity">ctxt</span> <span class="entity">T</span> <span class="entity">ct2</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> eq_list <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconvc<span class="main">)</span> <span class="main">(</span><span class="entity">ts1</span><span class="main">,</span> <span class="entity">ts2</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_tlist</span> <span class="entity">ctxt</span> <span class="inner_quoted">"Inputs"</span> <span class="main">[</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">]</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_tlist</span> <span class="entity">ctxt</span> <span class="inner_quoted">"ts1"</span> <span class="main">(</span>map Thm.term_of <span class="entity">ts1</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_tlist</span> <span class="entity">ctxt</span> <span class="inner_quoted">"ts2"</span> <span class="main">(</span>map Thm.term_of <span class="entity">ts2</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="entity">err_str</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_data</span> <span class="main">=</span> <span class="main">[</span>
        <span class="main">(</span><span class="inner_quoted">"xs @ ys"</span><span class="main">,</span> <span class="inner_quoted">"xs @ ys"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"a # xs"</span><span class="main">,</span> <span class="inner_quoted">"[a] @ xs"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"[] @ xs"</span><span class="main">,</span> <span class="inner_quoted">"xs"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"xs @ []"</span><span class="main">,</span> <span class="inner_quoted">"xs"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"xs @ ys @ zs @ []"</span><span class="main">,</span> <span class="inner_quoted">"xs @ ys @ zs"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"(xs @ ys @ zs) @ []"</span><span class="main">,</span> <span class="inner_quoted">"xs @ ys @ zs"</span><span class="main">)</span>
      <span class="main">]</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      map <span class="main">(</span><span class="entity">Util.test_conv</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">List_AC.normalize_list</span> <span class="entity">T</span><span class="main">)</span> <span class="inner_quoted">"test"</span><span class="main">)</span> <span class="entity">test_data</span> @
      map <span class="main">(</span><span class="entity">test_norm_t</span> <span class="inner_quoted">"test_norm"</span><span class="main">)</span> <span class="entity">test_data</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Auto2_Main">
<div class="head">
<h1>Theory Auto2_Main</h1>
</div>
<pre class="source"><span class="comment1">(*
  File: Auto2_Main.thy
  Author: Bohua Zhan

  Setup of auto2 for basic theorems in Main.
*)</span>

<span class="keyword1"><span class="command">theory</span></span> Auto2_Main
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="Arith_Thms.html">Arith_Thms</a> <a href="Lists_Thms.html">Lists_Thms</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Auto2_Test">
<div class="head">
<h1>Theory Auto2_Test</h1>
</div>
<pre class="source"><span class="comment1">(*
  File: Auto2_Test.thy
  Author: Bohua Zhan

  Unit tests for auto2.
*)</span>

<span class="keyword1"><span class="command">theory</span></span> Auto2_Test
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="Auto2_Main.html">Auto2_Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹util_test.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹rewrite_test.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹matcher_test.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹normalize_test.ML›</span>
<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹logic_steps_test.ML›</span>

<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹acdata_test.ML›</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="files/util_test.ML">
<div class="head">
<h1>File ‹util_test.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*
  File: util_test.ML
  Author: Bohua Zhan

  Unit test for util.ML.
*)</span>

<span class="keyword2"><span class="keyword">local</span></span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span>

<span class="keyword2"><span class="keyword">in</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_normalize_meta_all_imp</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_data</span> <span class="main">=</span> <span class="main">[</span>
        <span class="main">(</span><span class="inner_quoted">"!!x. (A ==&gt; B x)"</span><span class="main">,</span> <span class="inner_quoted">"A ==&gt; (!!x. B x)"</span><span class="main">)</span>
      <span class="main">]</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      map <span class="main">(</span><span class="entity">Util.test_conv</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">Util.normalize_meta_all_imp</span> <span class="entity">ctxt</span><span class="main">)</span>
                          <span class="inner_quoted">"normalize_meta_all_imp"</span><span class="main">)</span> <span class="entity">test_data</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_to_obj_conv</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">err</span> <span class="entity">n</span> <span class="main">=</span> <span class="inner_quoted">"test_to_obj_conv: "</span> ^ <span class="main">(</span>string_of_int <span class="entity">n</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">assert_eq</span> <span class="entity">th</span> <span class="entity">ct</span> <span class="entity">txt</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ct'</span> <span class="main">=</span> Thm.rhs_of <span class="entity">th</span>
          <span class="keyword2"><span class="keyword">in</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">ct'</span> aconvc <span class="entity">ct</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="entity">txt</span> <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ct1</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">cprop</span> <span class="quoted">"<span class="free">A</span> <span class="main">==&gt;</span> <span class="free">B</span> <span class="main">==&gt;</span> <span class="main">(</span><span class="main">!!</span><span class="main">(</span><span class="bound">n</span><span class="main">::</span>nat<span class="main">)</span><span class="main">.</span> <span class="free">C</span> <span class="bound">n</span><span class="main">)</span> <span class="main">==&gt;</span> <span class="free">D</span>"</span><span class="antiquote">}</span></span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ct2</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">cprop</span> <span class="quoted">"<span class="free">A</span> <span class="main">--&gt;</span> <span class="free">B</span> <span class="main">--&gt;</span> <span class="main">(</span><span class="main">!</span><span class="main">(</span><span class="bound">n</span><span class="main">::</span>nat<span class="main">)</span><span class="main">.</span> <span class="free">C</span> <span class="bound">n</span><span class="main">)</span> <span class="main">--&gt;</span> <span class="free">D</span>"</span><span class="antiquote">}</span></span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ct3</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">cprop</span> <span class="quoted">"<span class="main">!</span><span class="main">(</span><span class="bound">y</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">(</span><span class="bound">x</span><span class="main">::</span>nat<span class="main">)</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span> <span class="bound">y</span> <span class="main">--&gt;</span> <span class="main">(</span><span class="main">!</span><span class="bound">z</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">x</span> <span class="bound">y</span> <span class="bound">z</span><span class="main">)</span>"</span><span class="antiquote">}</span></span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert_eq</span> <span class="main">(</span><span class="entity">UtilLogic.to_obj_conv</span> <span class="entity">ctxt</span> <span class="entity">ct1</span><span class="main">)</span> <span class="entity">ct2</span> <span class="main">(</span><span class="entity">err</span> <span class="inner_numeral">0</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert_eq</span> <span class="main">(</span><span class="entity">UtilLogic.to_meta_conv</span> <span class="entity">ctxt</span> <span class="entity">ct2</span><span class="main">)</span>
              <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">cprop</span> <span class="quoted">"<span class="free">A</span> <span class="main">==&gt;</span> <span class="free">B</span> <span class="main">==&gt;</span> <span class="main">(</span><span class="main">!</span><span class="main">(</span><span class="bound">n</span><span class="main">::</span>nat<span class="main">)</span><span class="main">.</span> <span class="free">C</span> <span class="bound">n</span><span class="main">)</span> <span class="main">==&gt;</span> <span class="free">D</span>"</span><span class="antiquote">}</span></span></span> <span class="main">(</span><span class="entity">err</span> <span class="inner_numeral">1</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert_eq</span> <span class="main">(</span><span class="entity">UtilLogic.to_meta_conv</span> <span class="entity">ctxt</span> <span class="entity">ct3</span><span class="main">)</span>
              <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">cprop</span> <span class="quoted">"<span class="main">!!</span><span class="main">(</span><span class="bound">y</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">(</span><span class="bound">x</span><span class="main">::</span>nat<span class="main">)</span> <span class="bound">z</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span> <span class="bound">y</span> <span class="main">==&gt;</span> <span class="free">Q</span> <span class="bound">x</span> <span class="bound">y</span> <span class="bound">z</span>"</span><span class="antiquote">}</span></span></span> <span class="main">(</span><span class="entity">err</span> <span class="inner_numeral">2</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert_eq</span> <span class="main">(</span><span class="entity">UtilLogic.to_obj_conv_on_horn</span> <span class="entity">ctxt</span> <span class="entity">ct1</span><span class="main">)</span>
              <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">cprop</span> <span class="quoted">"<span class="free">A</span> <span class="main">==&gt;</span> <span class="free">B</span> <span class="main">==&gt;</span> <span class="main">(</span><span class="main">!</span><span class="main">(</span><span class="bound">n</span><span class="main">::</span>nat<span class="main">)</span><span class="main">.</span> <span class="free">C</span> <span class="bound">n</span><span class="main">)</span> <span class="main">==&gt;</span> <span class="free">D</span>"</span><span class="antiquote">}</span></span></span> <span class="main">(</span><span class="entity">err</span> <span class="inner_numeral">4</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_is_pattern</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">test</span> <span class="entity">b</span> <span class="entity">str</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Proof_Context.read_term_pattern <span class="entity">ctxt</span> <span class="entity">str</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">b</span> <span class="main">=</span> <span class="entity">Util.is_pattern</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">)</span>
            <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"test_is_pattern"</span>
          <span class="keyword2"><span class="keyword">end</span></span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_positive</span> <span class="main">=</span> <span class="main">[</span><span class="inner_quoted">"?f"</span><span class="main">,</span> <span class="inner_quoted">"!n. ?f n"</span><span class="main">,</span> <span class="inner_quoted">"!m n. ?f m n"</span><span class="main">,</span>
                           <span class="inner_quoted">"!n. ?f n &lt; ?f (n + 1)"</span><span class="main">,</span>
                           <span class="inner_quoted">"!n. ?f (n + 1) &lt; ?f n"</span><span class="main">,</span> <span class="inner_quoted">"!n. ?g (?f n) &amp; ?g n"</span><span class="main">]</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_negative</span> <span class="main">=</span> <span class="main">[</span><span class="inner_quoted">"?f ?n"</span><span class="main">,</span> <span class="inner_quoted">"!n. ?f n n"</span><span class="main">,</span> <span class="inner_quoted">"!n. ?f (?f n)"</span><span class="main">,</span>
                           <span class="inner_quoted">"!n. (?f n &lt; ?g (n + 1)) &amp; (?f (n + 1) &lt; ?g n)"</span><span class="main">]</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      map <span class="main">(</span><span class="entity">test</span> true<span class="main">)</span> <span class="entity">test_positive</span> @ map <span class="main">(</span><span class="entity">test</span> false<span class="main">)</span> <span class="entity">test_negative</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="files/rewrite_test.ML">
<div class="head">
<h1>File ‹rewrite_test.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*
  File: rewrite_test.ML
  Author: Bohua Zhan

  Unit test for rewrite.ML.
*)</span>

<span class="keyword2"><span class="keyword">local</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">init</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_prim_id</span> <span class="main">(</span><span class="entity">prim_id</span><span class="main">,</span> <span class="entity">id</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">prim_id'</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">BoxID.add_prim_id</span> <span class="entity">id</span> <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span><span class="entity">prim_id</span> <span class="main">=</span> <span class="entity">prim_id'</span><span class="main">)</span> <span class="inner_quoted">"add_prim_id"</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">ctxt'</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Conversion between (id, th) used in rewrite.ML and (id, t) used in
   test cases.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">to_term_info</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">Util.rhs_of</span> <span class="entity">th</span><span class="main">)</span>
<span class="comment1">(* Comparison of list of box_ids. *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq_id_list</span> <span class="main">=</span> eq_set <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span>
<span class="comment1">(* Comparison of list of (box_id, term) pairs. *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq_info_list</span> <span class="main">=</span> eq_set <span class="main">(</span>eq_pair <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv<span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">print_term_info</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span> <span class="main">=</span>
    <span class="inner_quoted">"("</span> ^ <span class="main">(</span><span class="entity">BoxID.string_of_box_id</span> <span class="entity">id</span><span class="main">)</span> ^ <span class="inner_quoted">", "</span> ^ <span class="main">(</span>Syntax.string_of_term <span class="entity">ctxt</span> <span class="entity">t</span><span class="main">)</span> ^ <span class="inner_quoted">")"</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">print_term_infos</span> <span class="entity">ctxt</span> <span class="entity">lst</span> <span class="main">=</span>
    commas <span class="main">(</span>map <span class="main">(</span><span class="entity">print_term_info</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">lst</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">string_of_box_id_list</span> <span class="main">=</span> <span class="entity">Util.string_of_list</span> <span class="entity">BoxID.string_of_box_id</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">done</span> <span class="entity">str</span> <span class="main">_</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> tracing <span class="main">(</span><span class="inner_quoted">"Finished "</span> ^ <span class="entity">str</span><span class="main">)</span> <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* info is expected, in box_id * term form, info' is returned value,
   in box_id * thm form (to be printed).
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">assert_eq_info</span> <span class="main">(</span><span class="entity">info</span><span class="main">,</span> <span class="entity">info'</span><span class="main">)</span> <span class="entity">txt</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">eq_info_list</span> <span class="main">(</span><span class="entity">info</span><span class="main">,</span> map <span class="entity">to_term_info</span> <span class="entity">info'</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">ctxt</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> tracing <span class="main">(</span><span class="inner_quoted">"Expected: "</span> ^ <span class="entity">print_term_infos</span> <span class="entity">ctxt</span> <span class="entity">info</span> ^ <span class="inner_quoted">"\n"</span> ^
                       <span class="inner_quoted">"Actual: "</span> ^ <span class="entity">print_infos</span> <span class="entity">ctxt</span> <span class="entity">info'</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="entity">txt</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">assert_rew_info</span> <span class="entity">str</span> <span class="entity">info_str</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Syntax.read_term <span class="entity">ctxt</span> <span class="entity">str</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ct</span> <span class="main">=</span> Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">t</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">info</span> <span class="main">=</span> map <span class="main">(</span>apsnd <span class="main">(</span>Syntax.read_term <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span> <span class="entity">info_str</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">assert_eq_info</span> <span class="main">(</span><span class="entity">info</span><span class="main">,</span> <span class="entity">RewriteTable.get_rewrite_info</span> <span class="entity">ctxt</span> <span class="entity">ct</span><span class="main">)</span>
                     <span class="inner_quoted">"assert_rew_info"</span> <span class="entity">ctxt</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">assert_srew_info</span> <span class="entity">str</span> <span class="entity">info_str</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Syntax.read_term <span class="entity">ctxt</span> <span class="entity">str</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ct</span> <span class="main">=</span> Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">t</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">info</span> <span class="main">=</span> map <span class="main">(</span>apsnd <span class="main">(</span>Syntax.read_term <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span> <span class="entity">info_str</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">assert_eq_info</span> <span class="main">(</span><span class="entity">info</span><span class="main">,</span> <span class="entity">RewriteTable.get_subterm_rewrite_info</span> <span class="entity">ctxt</span> <span class="entity">ct</span><span class="main">)</span>
                     <span class="inner_quoted">"assert_srew_info"</span> <span class="entity">ctxt</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">assert_head_rep</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">str</span><span class="main">)</span> <span class="entity">info_str</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Syntax.read_term <span class="entity">ctxt</span> <span class="entity">str</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ct</span> <span class="main">=</span> Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">t</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">info</span> <span class="main">=</span> map <span class="main">(</span>apsnd <span class="main">(</span>Syntax.read_term <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span> <span class="entity">info_str</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th</span> <span class="main">=</span> Thm.reflexive <span class="entity">ct</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">assert_eq_info</span> <span class="main">(</span><span class="entity">info</span><span class="main">,</span> <span class="entity">RewriteTable.get_head_rep_with_id_th</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span><span class="main">)</span>
                     <span class="inner_quoted">"assert_head_rep"</span> <span class="entity">ctxt</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">assert_equiv_gen</span> <span class="entity">exp_equiv</span> <span class="entity">id</span> <span class="main">(</span><span class="entity">str1</span><span class="main">,</span> <span class="entity">str2</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Syntax.read_term <span class="entity">ctxt</span> <span class="entity">str1</span><span class="main">,</span> Syntax.read_term <span class="entity">ctxt</span> <span class="entity">str2</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">exp_equiv</span> <span class="main">=</span> <span class="entity">RewriteTable.is_equiv_t</span> <span class="entity">id</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">ctxt</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> tracing <span class="main">(</span><span class="inner_quoted">"id: "</span> ^ <span class="main">(</span><span class="entity">BoxID.string_of_box_id</span> <span class="entity">id</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_tlist</span> <span class="entity">ctxt</span> <span class="inner_quoted">"Input:"</span> <span class="main">[</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">]</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">exp_equiv</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="inner_quoted">"assert_equiv"</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="inner_quoted">"assert_not_equiv"</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">assert_equiv</span> <span class="main">=</span> <span class="entity">assert_equiv_gen</span> true
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">assert_not_equiv</span> <span class="main">=</span> <span class="entity">assert_equiv_gen</span> false

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">assert_simpl_info</span> <span class="entity">str</span> <span class="entity">info_str</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Syntax.read_term <span class="entity">ctxt</span> <span class="entity">str</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ct</span> <span class="main">=</span> Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">t</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">info</span> <span class="main">=</span> map <span class="main">(</span>apsnd <span class="main">(</span>Syntax.read_term <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span> <span class="entity">info_str</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">assert_eq_info</span> <span class="main">(</span><span class="entity">info</span><span class="main">,</span> <span class="entity">RewriteTable.simplify_info</span> <span class="entity">ctxt</span> <span class="entity">ct</span><span class="main">)</span>
                     <span class="inner_quoted">"assert_simpl_info"</span> <span class="entity">ctxt</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">assert_simpl</span> <span class="entity">id</span> <span class="main">(</span><span class="entity">str</span><span class="main">,</span> <span class="entity">str'</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">t'</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Syntax.read_term <span class="entity">ctxt</span> <span class="entity">str</span><span class="main">,</span> Syntax.read_term <span class="entity">ctxt</span> <span class="entity">str'</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ct</span> <span class="main">=</span> Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">t</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">res</span> <span class="main">=</span> <span class="entity">Util.rhs_of</span> <span class="main">(</span><span class="entity">RewriteTable.simplify</span> <span class="entity">id</span> <span class="entity">ctxt</span> <span class="entity">ct</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">res</span> aconv <span class="entity">t'</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">ctxt</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_t</span> <span class="entity">ctxt</span> <span class="inner_quoted">"Input:"</span> <span class="entity">t</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_t</span> <span class="entity">ctxt</span> <span class="inner_quoted">"Expected:"</span> <span class="entity">t'</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_t</span> <span class="entity">ctxt</span> <span class="inner_quoted">"Actual:"</span> <span class="entity">res</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"assert_simpl"</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Collect all head equivs under box id. The return value of
   get_head_equiv is in the form [(head, [((id, th), groups), ...]), ...],
   and we want to collect the set of (id, th).
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">assert_head_equivs</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">str</span><span class="main">)</span> <span class="entity">info_str</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cu</span> <span class="main">=</span> Thm.cterm_of <span class="entity">ctxt</span> <span class="main">(</span>Syntax.read_term <span class="entity">ctxt</span> <span class="entity">str</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">info</span> <span class="main">=</span> map <span class="main">(</span>apsnd <span class="main">(</span>Syntax.read_term <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span> <span class="entity">info_str</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">res</span> <span class="main">=</span> <span class="main">(</span><span class="entity">RewriteTable.get_head_equiv</span> <span class="entity">ctxt</span> <span class="entity">cu</span><span class="main">)</span>
                    |&gt; <span class="entity">BoxID.merge_box_with_info</span> <span class="entity">ctxt</span> <span class="entity">id</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">assert_eq_info</span> <span class="main">(</span><span class="entity">info</span><span class="main">,</span> <span class="entity">res</span><span class="main">)</span> <span class="inner_quoted">"assert_head_equivs"</span> <span class="entity">ctxt</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">index_reps</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">index_reps_t</span> <span class="entity">t</span> <span class="main">=</span>
          fold <span class="entity">RewriteTable.update_subsimp</span>
               <span class="main">(</span><span class="entity">RewriteTable.get_subterm_rewrite_info</span> <span class="entity">ctxt</span> <span class="entity">t</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      fold <span class="entity">index_reps_t</span> <span class="main">(</span><span class="entity">RewriteTable.get_all_terms</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">ctxt</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">declare_term</span> <span class="entity">str</span> <span class="entity">ctxt</span> <span class="main">=</span>
    Proof_Context.augment <span class="main">(</span>Syntax.read_term <span class="entity">ctxt</span> <span class="entity">str</span><span class="main">)</span> <span class="entity">ctxt</span>

<span class="comment1">(* First part: test internal functions. *)</span>

<span class="comment1">(* Modification functions using terms. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_equiv</span> <span class="entity">id</span> <span class="main">(</span><span class="entity">str1</span><span class="main">,</span> <span class="entity">str2</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Syntax.read_term <span class="entity">ctxt</span> <span class="entity">str1</span><span class="main">,</span> Syntax.read_term <span class="entity">ctxt</span> <span class="entity">str2</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq_th</span> <span class="main">=</span> <span class="entity">Util.assume_meta_eq</span> <span class="entity">thy</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">ctxt</span> |&gt; <span class="entity">RewriteTable.add_equiv</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">eq_th</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_term</span> <span class="entity">str</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="entity">ctxt</span> |&gt; <span class="entity">RewriteTable.add_term</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> Thm.cterm_of <span class="entity">ctxt</span> <span class="main">(</span>Syntax.read_term <span class="entity">ctxt</span> <span class="entity">str</span><span class="main">)</span><span class="main">)</span> |&gt; snd

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">assert_eq_edges</span> <span class="main">(</span><span class="entity">str1</span><span class="main">,</span> <span class="entity">str2</span><span class="main">)</span> <span class="entity">ids</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Syntax.read_term <span class="entity">ctxt</span> <span class="entity">str1</span><span class="main">,</span> Syntax.read_term <span class="entity">ctxt</span> <span class="entity">str2</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ids'</span> <span class="main">=</span> <span class="main">(</span><span class="entity">RewriteTable.equiv_neighs</span> <span class="entity">ctxt</span> <span class="entity">t1</span><span class="main">)</span>
                     |&gt; map <span class="entity">to_term_info</span>
                     |&gt; filter <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">t2'</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">t2</span> aconv <span class="entity">t2'</span><span class="main">)</span> |&gt; map fst
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">eq_id_list</span> <span class="main">(</span><span class="entity">ids</span><span class="main">,</span> <span class="entity">ids'</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">ctxt</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_tlist</span> <span class="entity">ctxt</span> <span class="inner_quoted">"Input:"</span> <span class="main">[</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">]</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> tracing <span class="main">(</span><span class="inner_quoted">"Expected: "</span> ^ <span class="main">(</span><span class="entity">string_of_box_id_list</span> <span class="entity">ids</span><span class="main">)</span> ^ <span class="inner_quoted">"\n"</span> ^
                         <span class="inner_quoted">"Actual: "</span> ^ <span class="main">(</span><span class="entity">string_of_box_id_list</span> <span class="entity">ids'</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"assert_eq_edges"</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">update_simp</span> <span class="entity">id</span> <span class="main">(</span><span class="entity">str1</span><span class="main">,</span> <span class="entity">str2</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Syntax.read_term <span class="entity">ctxt</span> <span class="entity">str1</span><span class="main">,</span> Syntax.read_term <span class="entity">ctxt</span> <span class="entity">str2</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq_th</span> <span class="main">=</span> <span class="entity">Util.assume_meta_eq</span> <span class="entity">thy</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">ctxt</span> |&gt; <span class="entity">RewriteTable.update_simp</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">eq_th</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">assert_rewrite</span> <span class="entity">id</span> <span class="main">(</span><span class="entity">str</span><span class="main">,</span> <span class="entity">str'</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">t'</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Syntax.read_term <span class="entity">ctxt</span> <span class="entity">str</span><span class="main">,</span> Syntax.read_term <span class="entity">ctxt</span> <span class="entity">str'</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">res</span> <span class="main">=</span> <span class="entity">Util.rhs_of</span> <span class="main">(</span><span class="entity">RewriteTable.get_rewrite</span> <span class="entity">id</span> <span class="entity">ctxt</span> <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">res</span> aconv <span class="entity">t'</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">ctxt</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_t</span> <span class="entity">ctxt</span> <span class="inner_quoted">"Input:"</span> <span class="entity">t</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_t</span> <span class="entity">ctxt</span> <span class="inner_quoted">"Expected:"</span> <span class="entity">t'</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_t</span> <span class="entity">ctxt</span> <span class="inner_quoted">"Actual:"</span> <span class="entity">res</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"assert_rewrite"</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_rewrite</span> <span class="entity">id</span> <span class="main">(</span><span class="entity">str1</span><span class="main">,</span> <span class="entity">str2</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Syntax.read_term <span class="entity">ctxt</span> <span class="entity">str1</span><span class="main">,</span> Syntax.read_term <span class="entity">ctxt</span> <span class="entity">str2</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th</span> <span class="main">=</span> <span class="entity">assume_eq</span> <span class="entity">thy</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">ctxt</span> |&gt; <span class="entity">RewriteTable.add_rewrite</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> |&gt; snd
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">in</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_equiv_basic</span> <span class="main">=</span>
    <span class="entity">init</span> |&gt; fold <span class="entity">add_prim_id</span> <span class="main">[</span><span class="main">(</span><span class="inner_numeral">1</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="inner_numeral">2</span><span class="main">,</span> <span class="main">[</span><span class="inner_numeral">1</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="inner_numeral">3</span><span class="main">,</span> <span class="main">[</span><span class="inner_numeral">1</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="inner_numeral">4</span><span class="main">,</span> <span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span><span class="main">)</span><span class="main">]</span>
         |&gt; <span class="entity">declare_term</span> <span class="inner_quoted">"[a, b, c, d]"</span>
         |&gt; fold <span class="entity">add_term</span> <span class="main">[</span><span class="inner_quoted">"a"</span><span class="main">,</span> <span class="inner_quoted">"b"</span><span class="main">,</span> <span class="inner_quoted">"c"</span><span class="main">,</span> <span class="inner_quoted">"d"</span><span class="main">]</span>
         |&gt; <span class="entity">add_equiv</span> <span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"a"</span><span class="main">,</span> <span class="inner_quoted">"b"</span><span class="main">)</span> |&gt; <span class="entity">assert_eq_edges</span> <span class="main">(</span><span class="inner_quoted">"a"</span><span class="main">,</span> <span class="inner_quoted">"b"</span><span class="main">)</span> <span class="main">[</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span><span class="main">]</span>
         |&gt; <span class="entity">add_equiv</span> <span class="main">[</span><span class="inner_numeral">3</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"b"</span><span class="main">,</span> <span class="inner_quoted">"c"</span><span class="main">)</span> |&gt; <span class="entity">assert_eq_edges</span> <span class="main">(</span><span class="inner_quoted">"b"</span><span class="main">,</span> <span class="inner_quoted">"c"</span><span class="main">)</span> <span class="main">[</span><span class="main">[</span><span class="inner_numeral">3</span><span class="main">]</span><span class="main">]</span>
         |&gt; <span class="entity">add_equiv</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"a"</span><span class="main">,</span> <span class="inner_quoted">"b"</span><span class="main">)</span>  |&gt; <span class="entity">assert_eq_edges</span> <span class="main">(</span><span class="inner_quoted">"a"</span><span class="main">,</span> <span class="inner_quoted">"b"</span><span class="main">)</span> <span class="main">[</span><span class="main">[</span><span class="main">]</span><span class="main">]</span>
         |&gt; <span class="entity">add_equiv</span> <span class="main">[</span><span class="inner_numeral">4</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"a"</span><span class="main">,</span> <span class="inner_quoted">"d"</span><span class="main">)</span> |&gt; <span class="entity">assert_eq_edges</span> <span class="main">(</span><span class="inner_quoted">"a"</span><span class="main">,</span> <span class="inner_quoted">"d"</span><span class="main">)</span> <span class="main">[</span><span class="main">[</span><span class="inner_numeral">4</span><span class="main">]</span><span class="main">]</span>
         |&gt; <span class="entity">add_equiv</span> <span class="main">[</span><span class="inner_numeral">3</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"a"</span><span class="main">,</span> <span class="inner_quoted">"d"</span><span class="main">)</span> |&gt; <span class="entity">assert_eq_edges</span> <span class="main">(</span><span class="inner_quoted">"a"</span><span class="main">,</span> <span class="inner_quoted">"d"</span><span class="main">)</span> <span class="main">[</span><span class="main">[</span><span class="inner_numeral">3</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="inner_numeral">4</span><span class="main">]</span><span class="main">]</span>
         |&gt; <span class="entity">add_equiv</span> <span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"a"</span><span class="main">,</span> <span class="inner_quoted">"d"</span><span class="main">)</span> |&gt; <span class="entity">assert_eq_edges</span> <span class="main">(</span><span class="inner_quoted">"a"</span><span class="main">,</span> <span class="inner_quoted">"d"</span><span class="main">)</span> <span class="main">[</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="inner_numeral">3</span><span class="main">]</span><span class="main">]</span>
         |&gt; <span class="entity">add_equiv</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"a"</span><span class="main">,</span> <span class="inner_quoted">"d"</span><span class="main">)</span>  |&gt; <span class="entity">assert_eq_edges</span> <span class="main">(</span><span class="inner_quoted">"a"</span><span class="main">,</span> <span class="inner_quoted">"d"</span><span class="main">)</span> <span class="main">[</span><span class="main">[</span><span class="main">]</span><span class="main">]</span>
         |&gt; <span class="entity">done</span> <span class="inner_quoted">"test_equiv_basic"</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_simp_basic</span> <span class="main">=</span>
    <span class="entity">init</span> |&gt; fold <span class="entity">add_prim_id</span> <span class="main">[</span><span class="main">(</span><span class="inner_numeral">1</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="inner_numeral">2</span><span class="main">,</span> <span class="main">[</span><span class="inner_numeral">1</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="inner_numeral">3</span><span class="main">,</span> <span class="main">[</span><span class="inner_numeral">1</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="inner_numeral">4</span><span class="main">,</span> <span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span><span class="main">)</span><span class="main">]</span>
         |&gt; <span class="entity">declare_term</span> <span class="inner_quoted">"[a, b, c, d, e]"</span>
         |&gt; fold <span class="entity">add_term</span> <span class="main">[</span><span class="inner_quoted">"a"</span><span class="main">,</span> <span class="inner_quoted">"b"</span><span class="main">,</span> <span class="inner_quoted">"c"</span><span class="main">,</span> <span class="inner_quoted">"d"</span><span class="main">,</span> <span class="inner_quoted">"e"</span><span class="main">]</span>
         |&gt; <span class="entity">update_simp</span> <span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"e"</span><span class="main">,</span> <span class="inner_quoted">"d"</span><span class="main">)</span> |&gt; <span class="entity">assert_rewrite</span> <span class="main">[</span><span class="inner_numeral">2</span><span class="main">,</span> <span class="inner_numeral">3</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"e"</span><span class="main">,</span> <span class="inner_quoted">"d"</span><span class="main">)</span>
         |&gt; <span class="entity">update_simp</span> <span class="main">[</span><span class="inner_numeral">3</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"e"</span><span class="main">,</span> <span class="inner_quoted">"c"</span><span class="main">)</span> |&gt; <span class="entity">assert_rewrite</span> <span class="main">[</span><span class="inner_numeral">3</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"e"</span><span class="main">,</span> <span class="inner_quoted">"c"</span><span class="main">)</span>
         |&gt; <span class="entity">update_simp</span> <span class="main">[</span><span class="inner_numeral">3</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"e"</span><span class="main">,</span> <span class="inner_quoted">"b"</span><span class="main">)</span> |&gt; <span class="entity">assert_rewrite</span> <span class="main">[</span><span class="inner_numeral">2</span><span class="main">,</span> <span class="inner_numeral">3</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"e"</span><span class="main">,</span> <span class="inner_quoted">"b"</span><span class="main">)</span>
         |&gt; <span class="entity">update_simp</span> <span class="main">[</span><span class="inner_numeral">4</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"e"</span><span class="main">,</span> <span class="inner_quoted">"a"</span><span class="main">)</span> |&gt; <span class="entity">assert_rewrite</span> <span class="main">[</span><span class="inner_numeral">2</span><span class="main">,</span> <span class="inner_numeral">3</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"e"</span><span class="main">,</span> <span class="inner_quoted">"b"</span><span class="main">)</span>
         |&gt; <span class="entity">update_simp</span> <span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"e"</span><span class="main">,</span> <span class="inner_quoted">"b"</span><span class="main">)</span>
         |&gt; <span class="entity">update_simp</span> <span class="main">[</span><span class="inner_numeral">2</span><span class="main">,</span> <span class="inner_numeral">3</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"e"</span><span class="main">,</span> <span class="inner_quoted">"a"</span><span class="main">)</span>
         |&gt; <span class="entity">assert_rew_info</span> <span class="inner_quoted">"e"</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"e"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">4</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"a"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">3</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"b"</span><span class="main">)</span><span class="main">,</span>
                                 <span class="main">(</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"b"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">,</span> <span class="inner_numeral">3</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"a"</span><span class="main">)</span><span class="main">]</span>
         |&gt; <span class="entity">done</span> <span class="inner_quoted">"test_simp_basic"</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_head_rep</span> <span class="main">=</span>
    <span class="entity">init</span> |&gt; fold <span class="entity">add_prim_id</span> <span class="main">[</span><span class="main">(</span><span class="inner_numeral">1</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="inner_numeral">2</span><span class="main">,</span> <span class="main">[</span><span class="inner_numeral">1</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="inner_numeral">3</span><span class="main">,</span> <span class="main">[</span><span class="inner_numeral">1</span><span class="main">]</span><span class="main">)</span><span class="main">]</span>
         |&gt; fold <span class="entity">declare_term</span> <span class="main">[</span><span class="inner_quoted">"[a, b, c, d]"</span><span class="main">,</span> <span class="inner_quoted">"f a b"</span><span class="main">]</span>
         |&gt; <span class="entity">add_term</span> <span class="inner_quoted">"f b d"</span>
         |&gt; <span class="entity">update_simp</span> <span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"d"</span><span class="main">,</span> <span class="inner_quoted">"c"</span><span class="main">)</span>
         |&gt; <span class="entity">update_simp</span> <span class="main">[</span><span class="inner_numeral">3</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"b"</span><span class="main">,</span> <span class="inner_quoted">"a"</span><span class="main">)</span>
         |&gt; <span class="entity">assert_srew_info</span> <span class="inner_quoted">"f b d"</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f b d"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f b c"</span><span class="main">)</span><span class="main">,</span>
                                      <span class="main">(</span><span class="main">[</span><span class="inner_numeral">3</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f a d"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">,</span> <span class="inner_numeral">3</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f a c"</span><span class="main">)</span><span class="main">]</span>
         |&gt; <span class="entity">index_reps</span>
         |&gt; <span class="entity">assert_head_rep</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f a c"</span><span class="main">)</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">,</span> <span class="inner_numeral">3</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f b d"</span><span class="main">)</span><span class="main">]</span>
         |&gt; <span class="entity">assert_head_rep</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f b c"</span><span class="main">)</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f b d"</span><span class="main">)</span><span class="main">]</span>
         |&gt; <span class="entity">assert_head_rep</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f a d"</span><span class="main">)</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="inner_numeral">3</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f b d"</span><span class="main">)</span><span class="main">]</span>
         |&gt; <span class="entity">assert_head_rep</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f b d"</span><span class="main">)</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f b d"</span><span class="main">)</span><span class="main">]</span>
         |&gt; <span class="entity">assert_head_rep</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">3</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f b c"</span><span class="main">)</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">,</span> <span class="inner_numeral">3</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f b d"</span><span class="main">)</span><span class="main">]</span>
         |&gt; <span class="entity">done</span> <span class="inner_quoted">"test_head_rep"</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_head_rep3</span> <span class="main">=</span>
    <span class="entity">init</span> |&gt; fold <span class="entity">add_prim_id</span> <span class="main">[</span><span class="main">(</span><span class="inner_numeral">1</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="inner_numeral">2</span><span class="main">,</span> <span class="main">[</span><span class="inner_numeral">1</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="inner_numeral">3</span><span class="main">,</span> <span class="main">[</span><span class="inner_numeral">1</span><span class="main">]</span><span class="main">)</span><span class="main">]</span>
         |&gt; fold <span class="entity">declare_term</span> <span class="main">[</span><span class="inner_quoted">"[a, b, c, d]"</span><span class="main">,</span> <span class="inner_quoted">"f a b"</span><span class="main">]</span>
         |&gt; <span class="entity">add_term</span> <span class="inner_quoted">"f b c"</span> |&gt; <span class="entity">add_term</span> <span class="inner_quoted">"f a d"</span>
         |&gt; <span class="entity">update_simp</span> <span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"d"</span><span class="main">,</span> <span class="inner_quoted">"c"</span><span class="main">)</span>
         |&gt; <span class="entity">update_simp</span> <span class="main">[</span><span class="inner_numeral">3</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"b"</span><span class="main">,</span> <span class="inner_quoted">"a"</span><span class="main">)</span>
         |&gt; <span class="entity">index_reps</span>
         |&gt; <span class="entity">assert_head_rep</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f a c"</span><span class="main">)</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f a d"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">3</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f b c"</span><span class="main">)</span><span class="main">]</span>
         |&gt; <span class="entity">assert_head_rep</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f a c"</span><span class="main">)</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f a d"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">,</span> <span class="inner_numeral">3</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f b c"</span><span class="main">)</span><span class="main">]</span>
         |&gt; <span class="entity">assert_head_rep</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">3</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f a c"</span><span class="main">)</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="inner_numeral">3</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f b c"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">,</span> <span class="inner_numeral">3</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f a d"</span><span class="main">)</span><span class="main">]</span>
         |&gt; <span class="entity">done</span> <span class="inner_quoted">"test_head_rep3"</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_add_term</span> <span class="main">=</span>
    <span class="entity">init</span> |&gt; fold <span class="entity">add_prim_id</span> <span class="main">[</span><span class="main">(</span><span class="inner_numeral">1</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="inner_numeral">2</span><span class="main">,</span> <span class="main">[</span><span class="inner_numeral">1</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="inner_numeral">3</span><span class="main">,</span> <span class="main">[</span><span class="inner_numeral">1</span><span class="main">]</span><span class="main">)</span><span class="main">]</span>
         |&gt; fold <span class="entity">declare_term</span> <span class="main">[</span><span class="inner_quoted">"[a, b, c, d]"</span><span class="main">,</span> <span class="inner_quoted">"f a b"</span><span class="main">]</span>
         |&gt; <span class="entity">add_rewrite</span> <span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"d"</span><span class="main">,</span> <span class="inner_quoted">"c"</span><span class="main">)</span>
         |&gt; <span class="entity">add_rewrite</span> <span class="main">[</span><span class="inner_numeral">3</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"b"</span><span class="main">,</span> <span class="inner_quoted">"a"</span><span class="main">)</span>
         |&gt; <span class="entity">index_reps</span>
         |&gt; <span class="entity">add_term</span> <span class="inner_quoted">"f b c"</span> |&gt; <span class="entity">add_term</span> <span class="inner_quoted">"f a d"</span>
         |&gt; <span class="entity">assert_head_rep</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f a c"</span><span class="main">)</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f a d"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">3</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f b c"</span><span class="main">)</span><span class="main">]</span>
         |&gt; <span class="entity">assert_eq_edges</span> <span class="main">(</span><span class="inner_quoted">"f a d"</span><span class="main">,</span> <span class="inner_quoted">"f b c"</span><span class="main">)</span> <span class="main">[</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">,</span> <span class="inner_numeral">3</span><span class="main">]</span><span class="main">]</span>
         |&gt; <span class="entity">add_term</span> <span class="inner_quoted">"f a c"</span> |&gt; <span class="entity">add_term</span> <span class="inner_quoted">"f b d"</span>
         |&gt; <span class="entity">assert_head_rep</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f a c"</span><span class="main">)</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f a c"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f a d"</span><span class="main">)</span><span class="main">,</span>
                                           <span class="main">(</span><span class="main">[</span><span class="inner_numeral">3</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f b c"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">,</span> <span class="inner_numeral">3</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f b d"</span><span class="main">)</span><span class="main">]</span>
         |&gt; <span class="entity">assert_equiv</span> <span class="main">[</span><span class="inner_numeral">2</span><span class="main">,</span> <span class="inner_numeral">3</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"f a c"</span><span class="main">,</span> <span class="inner_quoted">"f b d"</span><span class="main">)</span>
         |&gt; <span class="entity">assert_not_equiv</span> <span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"f a c"</span><span class="main">,</span> <span class="inner_quoted">"f b d"</span><span class="main">)</span>
         |&gt; <span class="entity">assert_not_equiv</span> <span class="main">[</span><span class="inner_numeral">3</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"f a c"</span><span class="main">,</span> <span class="inner_quoted">"f b d"</span><span class="main">)</span>
         |&gt; <span class="entity">done</span> <span class="inner_quoted">"test_add_term"</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_add_rewrite</span> <span class="main">=</span>
    <span class="entity">init</span> |&gt; fold <span class="entity">add_prim_id</span> <span class="main">[</span><span class="main">(</span><span class="inner_numeral">1</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="inner_numeral">2</span><span class="main">,</span> <span class="main">[</span><span class="inner_numeral">1</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="inner_numeral">3</span><span class="main">,</span> <span class="main">[</span><span class="inner_numeral">1</span><span class="main">]</span><span class="main">)</span><span class="main">]</span>
         |&gt; fold <span class="entity">declare_term</span> <span class="main">[</span><span class="inner_quoted">"[a, b, c, d]"</span><span class="main">,</span> <span class="inner_quoted">"f a b"</span><span class="main">]</span>
         |&gt; <span class="entity">add_term</span> <span class="inner_quoted">"f a d"</span>
         |&gt; <span class="entity">add_rewrite</span> <span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"d"</span><span class="main">,</span> <span class="inner_quoted">"c"</span><span class="main">)</span>
         |&gt; <span class="entity">assert_head_rep</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f a c"</span><span class="main">)</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f a d"</span><span class="main">)</span><span class="main">]</span>
         |&gt; <span class="entity">add_term</span> <span class="inner_quoted">"f b d"</span>
         |&gt; <span class="entity">assert_head_rep</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f b c"</span><span class="main">)</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f b d"</span><span class="main">)</span><span class="main">]</span>
         |&gt; <span class="entity">add_rewrite</span> <span class="main">[</span><span class="inner_numeral">3</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"a"</span><span class="main">,</span> <span class="inner_quoted">"b"</span><span class="main">)</span>
         |&gt; <span class="entity">assert_eq_edges</span> <span class="main">(</span><span class="inner_quoted">"f a d"</span><span class="main">,</span> <span class="inner_quoted">"f b d"</span><span class="main">)</span> <span class="main">[</span><span class="main">[</span><span class="inner_numeral">3</span><span class="main">]</span><span class="main">]</span>
         |&gt; <span class="entity">assert_rew_info</span> <span class="inner_quoted">"f b d"</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f b d"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f b c"</span><span class="main">)</span><span class="main">,</span>
                                     <span class="main">(</span><span class="main">[</span><span class="inner_numeral">3</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f a d"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">,</span> <span class="inner_numeral">3</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f a c"</span><span class="main">)</span><span class="main">]</span>
         |&gt; <span class="entity">add_term</span> <span class="inner_quoted">"f b c"</span>
         |&gt; <span class="entity">assert_head_rep</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f a c"</span><span class="main">)</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f a d"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">3</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f b c"</span><span class="main">)</span><span class="main">,</span>
                                           <span class="main">(</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">,</span> <span class="inner_numeral">3</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f b d"</span><span class="main">)</span><span class="main">]</span>
         |&gt; <span class="entity">done</span> <span class="inner_quoted">"test_add_rewrite"</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_simplify</span> <span class="main">=</span>
    <span class="entity">init</span> |&gt; fold <span class="entity">add_prim_id</span> <span class="main">[</span><span class="main">(</span><span class="inner_numeral">1</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="inner_numeral">2</span><span class="main">,</span> <span class="main">[</span><span class="inner_numeral">1</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="inner_numeral">3</span><span class="main">,</span> <span class="main">[</span><span class="inner_numeral">1</span><span class="main">]</span><span class="main">)</span><span class="main">]</span>
         |&gt; fold <span class="entity">declare_term</span> <span class="main">[</span><span class="inner_quoted">"[a, b, c, d]"</span><span class="main">,</span> <span class="inner_quoted">"[f a b, e]"</span><span class="main">]</span>
         |&gt; <span class="entity">add_rewrite</span> <span class="main">[</span><span class="inner_numeral">1</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"f b d"</span><span class="main">,</span> <span class="inner_quoted">"e"</span><span class="main">)</span>
         |&gt; <span class="entity">add_rewrite</span> <span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"d"</span><span class="main">,</span> <span class="inner_quoted">"c"</span><span class="main">)</span>
         |&gt; <span class="entity">add_rewrite</span> <span class="main">[</span><span class="inner_numeral">3</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"b"</span><span class="main">,</span> <span class="inner_quoted">"a"</span><span class="main">)</span>
         |&gt; <span class="entity">assert_simpl_info</span> <span class="inner_quoted">"f a c"</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f a c"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">,</span> <span class="inner_numeral">3</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"e"</span><span class="main">)</span><span class="main">]</span>
         |&gt; <span class="entity">assert_simpl_info</span> <span class="inner_quoted">"f a d"</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f a d"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f a c"</span><span class="main">)</span><span class="main">,</span>
                                       <span class="main">(</span><span class="main">[</span><span class="inner_numeral">3</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"e"</span><span class="main">)</span><span class="main">]</span>
         |&gt; <span class="entity">assert_simpl_info</span> <span class="inner_quoted">"f b c"</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f b c"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">3</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f a c"</span><span class="main">)</span><span class="main">,</span>
                                       <span class="main">(</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"e"</span><span class="main">)</span><span class="main">]</span>
         |&gt; <span class="entity">assert_simpl_info</span> <span class="inner_quoted">"f b d"</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f b d"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">1</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"e"</span><span class="main">)</span><span class="main">]</span>
         |&gt; <span class="entity">assert_simpl</span> <span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"f a c"</span><span class="main">,</span> <span class="inner_quoted">"f a c"</span><span class="main">)</span>
         |&gt; <span class="entity">assert_simpl</span> <span class="main">[</span><span class="inner_numeral">2</span><span class="main">,</span> <span class="inner_numeral">3</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"f a c"</span><span class="main">,</span> <span class="inner_quoted">"e"</span><span class="main">)</span>
         |&gt; <span class="entity">assert_simpl</span> <span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"f a d"</span><span class="main">,</span> <span class="inner_quoted">"f a c"</span><span class="main">)</span>
         |&gt; <span class="entity">assert_simpl</span> <span class="main">[</span><span class="inner_numeral">3</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"f a d"</span><span class="main">,</span> <span class="inner_quoted">"e"</span><span class="main">)</span>
         |&gt; <span class="entity">assert_simpl</span> <span class="main">[</span><span class="inner_numeral">2</span><span class="main">,</span> <span class="inner_numeral">3</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"f a d"</span><span class="main">,</span> <span class="inner_quoted">"e"</span><span class="main">)</span>
         |&gt; <span class="entity">add_rewrite</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"f b d"</span><span class="main">,</span> <span class="inner_quoted">"e"</span><span class="main">)</span>
         |&gt; <span class="entity">assert_simpl_info</span> <span class="inner_quoted">"f b d"</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"e"</span><span class="main">)</span><span class="main">]</span>
         |&gt; <span class="entity">add_term</span> <span class="inner_quoted">"f a c"</span>
         |&gt; <span class="entity">assert_equiv</span> <span class="main">[</span><span class="inner_numeral">2</span><span class="main">,</span> <span class="inner_numeral">3</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"f a c"</span><span class="main">,</span> <span class="inner_quoted">"f b d"</span><span class="main">)</span>
         |&gt; <span class="entity">done</span> <span class="inner_quoted">"test_simplify"</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_simplify2</span> <span class="main">=</span>
    <span class="entity">init</span> |&gt; fold <span class="entity">add_prim_id</span> <span class="main">[</span><span class="main">(</span><span class="inner_numeral">1</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="inner_numeral">2</span><span class="main">,</span> <span class="main">[</span><span class="inner_numeral">1</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="inner_numeral">3</span><span class="main">,</span> <span class="main">[</span><span class="inner_numeral">1</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="inner_numeral">4</span><span class="main">,</span> <span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span><span class="main">)</span><span class="main">]</span>
         |&gt; <span class="entity">declare_term</span> <span class="inner_quoted">"[a, b, c, d]"</span>
         |&gt; <span class="entity">add_rewrite</span> <span class="main">[</span><span class="inner_numeral">3</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"b"</span><span class="main">,</span> <span class="inner_quoted">"c"</span><span class="main">)</span>
         |&gt; <span class="entity">add_rewrite</span> <span class="main">[</span><span class="inner_numeral">4</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"a"</span><span class="main">,</span> <span class="inner_quoted">"b"</span><span class="main">)</span>
         |&gt; <span class="entity">add_rewrite</span> <span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"c"</span><span class="main">,</span> <span class="inner_quoted">"d"</span><span class="main">)</span>
         |&gt; <span class="entity">assert_simpl_info</span> <span class="inner_quoted">"c"</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"c"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">3</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"b"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">3</span><span class="main">,</span> <span class="inner_numeral">4</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"a"</span><span class="main">)</span><span class="main">]</span>
         |&gt; <span class="entity">assert_simpl_info</span> <span class="inner_quoted">"d"</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"d"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"c"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">,</span> <span class="inner_numeral">3</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"b"</span><span class="main">)</span><span class="main">,</span>
                                   <span class="main">(</span><span class="main">[</span><span class="inner_numeral">3</span><span class="main">,</span> <span class="inner_numeral">4</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"a"</span><span class="main">)</span><span class="main">]</span>
         |&gt; <span class="entity">done</span> <span class="inner_quoted">"test_simplify2"</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_simplify3</span> <span class="main">=</span>
    <span class="entity">init</span> |&gt; fold <span class="entity">add_prim_id</span> <span class="main">[</span><span class="main">(</span><span class="inner_numeral">1</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="inner_numeral">2</span><span class="main">,</span> <span class="main">[</span><span class="inner_numeral">1</span><span class="main">]</span><span class="main">)</span><span class="main">]</span>
         |&gt; <span class="entity">declare_term</span> <span class="inner_quoted">"[a, b, c, d, e, g]"</span>
         |&gt; <span class="entity">add_rewrite</span> <span class="main">[</span><span class="inner_numeral">1</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"e"</span><span class="main">,</span> <span class="inner_quoted">"c"</span><span class="main">)</span> |&gt; <span class="entity">add_rewrite</span> <span class="main">[</span><span class="inner_numeral">1</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"g"</span><span class="main">,</span> <span class="inner_quoted">"d"</span><span class="main">)</span>
         |&gt; <span class="entity">add_rewrite</span> <span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"e"</span><span class="main">,</span> <span class="inner_quoted">"b"</span><span class="main">)</span> |&gt; <span class="entity">add_rewrite</span> <span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"g"</span><span class="main">,</span> <span class="inner_quoted">"a"</span><span class="main">)</span>
         |&gt; <span class="entity">add_rewrite</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"e"</span><span class="main">,</span> <span class="inner_quoted">"g"</span><span class="main">)</span>
         |&gt; <span class="entity">assert_simpl_info</span> <span class="inner_quoted">"e"</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"e"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">1</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"c"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"a"</span><span class="main">)</span><span class="main">]</span>
         |&gt; <span class="entity">assert_simpl_info</span> <span class="inner_quoted">"g"</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"e"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">1</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"c"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"a"</span><span class="main">)</span><span class="main">]</span>
         |&gt; <span class="entity">done</span> <span class="inner_quoted">"test_simplify3"</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_head_equivs</span> <span class="main">=</span>
    <span class="entity">init</span> |&gt; fold <span class="entity">add_prim_id</span> <span class="main">[</span><span class="main">(</span><span class="inner_numeral">1</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="inner_numeral">2</span><span class="main">,</span> <span class="main">[</span><span class="inner_numeral">1</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="inner_numeral">3</span><span class="main">,</span> <span class="main">[</span><span class="inner_numeral">1</span><span class="main">]</span><span class="main">)</span><span class="main">]</span>
         |&gt; fold <span class="entity">declare_term</span> <span class="main">[</span><span class="inner_quoted">"[a, b, c, d]"</span><span class="main">,</span> <span class="inner_quoted">"[f a b, e]"</span><span class="main">]</span>
         |&gt; <span class="entity">add_rewrite</span> <span class="main">[</span><span class="inner_numeral">1</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"f b d"</span><span class="main">,</span> <span class="inner_quoted">"e"</span><span class="main">)</span>
         |&gt; <span class="entity">add_rewrite</span> <span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"d"</span><span class="main">,</span> <span class="inner_quoted">"c"</span><span class="main">)</span>
         |&gt; <span class="entity">add_rewrite</span> <span class="main">[</span><span class="inner_numeral">3</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"b"</span><span class="main">,</span> <span class="inner_quoted">"a"</span><span class="main">)</span>
         |&gt; <span class="entity">assert_head_equivs</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"c"</span><span class="main">)</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"c"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"d"</span><span class="main">)</span><span class="main">]</span>
         |&gt; <span class="entity">assert_head_equivs</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f b d"</span><span class="main">)</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f b d"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">1</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"e"</span><span class="main">)</span><span class="main">]</span>
         |&gt; <span class="entity">assert_head_equivs</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f b c"</span><span class="main">)</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f b c"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"e"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f b d"</span><span class="main">)</span><span class="main">]</span>
         |&gt; <span class="entity">assert_head_equivs</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f b c"</span><span class="main">)</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f b c"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"e"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f b d"</span><span class="main">)</span><span class="main">]</span>
         |&gt; <span class="entity">assert_head_equivs</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f a c"</span><span class="main">)</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f a c"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">,</span> <span class="inner_numeral">3</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"e"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">,</span> <span class="inner_numeral">3</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f b d"</span><span class="main">)</span><span class="main">]</span>
         |&gt; <span class="entity">add_term</span> <span class="inner_quoted">"f a c"</span>
         |&gt; <span class="entity">assert_head_equivs</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f b d"</span><span class="main">)</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f b d"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">1</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"e"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">,</span> <span class="inner_numeral">3</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f a c"</span><span class="main">)</span><span class="main">]</span>
         |&gt; <span class="entity">assert_head_equivs</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f a c"</span><span class="main">)</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f a c"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">,</span> <span class="inner_numeral">3</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"e"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">,</span> <span class="inner_numeral">3</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f b d"</span><span class="main">)</span><span class="main">]</span>
         |&gt; <span class="entity">assert_head_equivs</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f b c"</span><span class="main">)</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f b c"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"e"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f b d"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">3</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f a c"</span><span class="main">)</span><span class="main">]</span>
         |&gt; <span class="entity">done</span> <span class="inner_quoted">"test_head_equivs"</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_head_equivs2</span> <span class="main">=</span>
    <span class="entity">init</span> |&gt; fold <span class="entity">add_prim_id</span> <span class="main">[</span><span class="main">(</span><span class="inner_numeral">1</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="inner_numeral">2</span><span class="main">,</span> <span class="main">[</span><span class="inner_numeral">1</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="inner_numeral">3</span><span class="main">,</span> <span class="main">[</span><span class="inner_numeral">1</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="inner_numeral">4</span><span class="main">,</span> <span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span><span class="main">)</span><span class="main">]</span>
         |&gt; <span class="entity">declare_term</span> <span class="inner_quoted">"[a, b, c, d]"</span>
         |&gt; <span class="entity">add_rewrite</span> <span class="main">[</span><span class="inner_numeral">3</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"b"</span><span class="main">,</span> <span class="inner_quoted">"c"</span><span class="main">)</span>
         |&gt; <span class="entity">add_rewrite</span> <span class="main">[</span><span class="inner_numeral">4</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"a"</span><span class="main">,</span> <span class="inner_quoted">"b"</span><span class="main">)</span>
         |&gt; <span class="entity">assert_head_equivs</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"b"</span><span class="main">)</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"b"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">3</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"c"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">4</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"a"</span><span class="main">)</span><span class="main">]</span>
         |&gt; <span class="entity">add_rewrite</span> <span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"c"</span><span class="main">,</span> <span class="inner_quoted">"d"</span><span class="main">)</span>
         |&gt; <span class="entity">assert_head_equivs</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"b"</span><span class="main">)</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"b"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">3</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"c"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">4</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"a"</span><span class="main">)</span><span class="main">,</span>
                                          <span class="main">(</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">,</span> <span class="inner_numeral">3</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"d"</span><span class="main">)</span><span class="main">]</span>
         |&gt; <span class="entity">done</span> <span class="inner_quoted">"test_head_equivs2"</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_head_equivs3</span> <span class="main">=</span>
    <span class="entity">init</span> |&gt; fold <span class="entity">add_prim_id</span> <span class="main">[</span><span class="main">(</span><span class="inner_numeral">1</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="inner_numeral">2</span><span class="main">,</span> <span class="main">[</span><span class="inner_numeral">1</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="inner_numeral">3</span><span class="main">,</span> <span class="main">[</span><span class="inner_numeral">1</span><span class="main">]</span><span class="main">)</span><span class="main">]</span>
         |&gt; fold <span class="entity">declare_term</span> <span class="main">[</span><span class="inner_quoted">"[a, b, c, d]"</span><span class="main">,</span> <span class="inner_quoted">"[f a b, e]"</span><span class="main">]</span>
         |&gt; <span class="entity">add_rewrite</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"b"</span><span class="main">,</span> <span class="inner_quoted">"a"</span><span class="main">)</span>
         |&gt; <span class="entity">add_rewrite</span> <span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"f b d"</span><span class="main">,</span> <span class="inner_quoted">"e"</span><span class="main">)</span>
         |&gt; <span class="entity">add_rewrite</span> <span class="main">[</span><span class="inner_numeral">3</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"f a d"</span><span class="main">,</span> <span class="inner_quoted">"e"</span><span class="main">)</span>
         <span class="comment1">(* Both fbd and fad are ok in the result. *)</span>
         |&gt; <span class="entity">assert_head_equivs</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f a d"</span><span class="main">)</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f b d"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"e"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">3</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"e"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f a d"</span><span class="main">)</span><span class="main">]</span>
         |&gt; <span class="entity">assert_head_equivs</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f b d"</span><span class="main">)</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f a d"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"e"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">3</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"e"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f b d"</span><span class="main">)</span><span class="main">]</span>
         |&gt; <span class="entity">done</span> <span class="inner_quoted">"test_head_equivs3"</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_head_equivs4</span> <span class="main">=</span>
    <span class="entity">init</span> |&gt; fold <span class="entity">add_prim_id</span> <span class="main">[</span><span class="main">(</span><span class="inner_numeral">1</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="inner_numeral">2</span><span class="main">,</span> <span class="main">[</span><span class="inner_numeral">1</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="inner_numeral">3</span><span class="main">,</span> <span class="main">[</span><span class="inner_numeral">1</span><span class="main">]</span><span class="main">)</span><span class="main">]</span>
         |&gt; fold <span class="entity">declare_term</span> <span class="main">[</span><span class="inner_quoted">"[a, b, c, d]"</span><span class="main">,</span> <span class="inner_quoted">"[f a b, e]"</span><span class="main">]</span>
         |&gt; <span class="entity">add_rewrite</span> <span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"b"</span><span class="main">,</span> <span class="inner_quoted">"a"</span><span class="main">)</span>
         |&gt; <span class="entity">add_rewrite</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"f b c"</span><span class="main">,</span> <span class="inner_quoted">"e"</span><span class="main">)</span>
         |&gt; <span class="entity">add_rewrite</span> <span class="main">[</span><span class="inner_numeral">3</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"f a c"</span><span class="main">,</span> <span class="inner_quoted">"e"</span><span class="main">)</span>  <span class="comment1">(* Note fbc ~ fac under 3. *)</span>
         |&gt; <span class="entity">assert_head_equivs</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f b c"</span><span class="main">)</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f b c"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"e"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">3</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f a c"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f a c"</span><span class="main">)</span><span class="main">]</span>
         |&gt; <span class="entity">assert_head_equivs</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f a c"</span><span class="main">)</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f a c"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"e"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">3</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"e"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">3</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f b c"</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f b c"</span><span class="main">)</span><span class="main">]</span>
         |&gt; <span class="entity">done</span> <span class="inner_quoted">"test_head_equivs4"</span>

<span class="comment1">(* Simplify with nat variables. *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_simplify_nat</span> <span class="main">=</span>
    <span class="entity">init</span> |&gt; <span class="entity">declare_term</span> <span class="inner_quoted">"[a::nat, b, c]"</span>
         |&gt; <span class="entity">add_rewrite</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"a + b"</span><span class="main">,</span> <span class="inner_quoted">"b + a"</span><span class="main">)</span>
         |&gt; <span class="entity">add_rewrite</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"a"</span><span class="main">,</span> <span class="inner_quoted">"c"</span><span class="main">)</span>
         |&gt; <span class="entity">assert_simpl</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"b + c"</span><span class="main">,</span> <span class="inner_quoted">"a + b"</span><span class="main">)</span>
         |&gt; <span class="entity">assert_equiv</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"b + c"</span><span class="main">,</span> <span class="inner_quoted">"a + b"</span><span class="main">)</span>
         |&gt; <span class="entity">done</span> <span class="inner_quoted">"test_simplify_nat"</span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>  <span class="comment1">(* local *)</span>
</pre>
</div><div id="files/matcher_test.ML">
<div class="head">
<h1>File ‹matcher_test.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*
  File: matcher_test.ML
  Author: Bohua Zhan

  Unit test of matcher.ML.
*)</span>

<span class="keyword2"><span class="keyword">local</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">init</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span>

<span class="comment1">(* Conversion between (id, th) used in rewrite.ML and (id, t) used in
   test cases.
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">to_term_info</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">Util.rhs_of</span> <span class="entity">th</span><span class="main">)</span>

<span class="comment1">(* Comparison of list of (box_id, term) pairs. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">eq_info_list</span> <span class="main">(</span><span class="entity">l1</span><span class="main">,</span> <span class="entity">l2</span><span class="main">)</span> <span class="main">=</span>
    <span class="main">(</span>length <span class="entity">l1</span> <span class="main">=</span> length <span class="entity">l2</span><span class="main">)</span> <span class="keyword1"><span class="keyword">andalso</span></span> eq_set <span class="main">(</span>eq_pair <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv<span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="entity">l1</span><span class="main">,</span> <span class="entity">l2</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">print_term_info</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span> <span class="main">=</span>
    <span class="inner_quoted">"("</span> ^ <span class="main">(</span><span class="entity">BoxID.string_of_box_id</span> <span class="entity">id</span><span class="main">)</span> ^ <span class="inner_quoted">", "</span> ^ <span class="main">(</span>Syntax.string_of_term <span class="entity">ctxt</span> <span class="entity">t</span><span class="main">)</span> ^ <span class="inner_quoted">")"</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">print_term_infos</span> <span class="entity">ctxt</span> <span class="entity">lst</span> <span class="main">=</span>
    commas <span class="main">(</span>map <span class="main">(</span><span class="entity">print_term_info</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">lst</span><span class="main">)</span>

<span class="comment1">(* info is expected, in box_id * term form, info' is returned value,
   in box_id * thm form (to be printed).
 *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">assert_eq_info</span> <span class="main">(</span><span class="entity">info</span><span class="main">,</span> <span class="entity">info'</span><span class="main">)</span> <span class="entity">txt</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">eq_info_list</span> <span class="main">(</span><span class="entity">info</span><span class="main">,</span> map <span class="entity">to_term_info</span> <span class="entity">info'</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">ctxt</span>
    <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> tracing <span class="main">(</span><span class="inner_quoted">"Expected: "</span> ^ <span class="entity">print_term_infos</span> <span class="entity">ctxt</span> <span class="entity">info</span> ^ <span class="inner_quoted">"\n"</span> ^
                       <span class="inner_quoted">"Actual: "</span> ^ <span class="entity">print_infos</span> <span class="entity">ctxt</span> <span class="entity">info'</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="entity">txt</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_prim_id</span> <span class="main">(</span><span class="entity">prim_id</span><span class="main">,</span> <span class="entity">id</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">prim_id'</span><span class="main">,</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="main">=</span> <span class="entity">BoxID.add_prim_id</span> <span class="entity">id</span> <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">assert</span> <span class="main">(</span><span class="entity">prim_id</span> <span class="main">=</span> <span class="entity">prim_id'</span><span class="main">)</span> <span class="inner_quoted">"add_prim_id"</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">ctxt'</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">declare_term</span> <span class="entity">str</span> <span class="entity">ctxt</span> <span class="main">=</span>
    Proof_Context.augment <span class="main">(</span>Syntax.read_term <span class="entity">ctxt</span> <span class="entity">str</span><span class="main">)</span> <span class="entity">ctxt</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">declare_pat</span> <span class="entity">str</span> <span class="entity">ctxt</span> <span class="main">=</span>
    Proof_Context.augment <span class="main">(</span>Proof_Context.read_term_pattern <span class="entity">ctxt</span> <span class="entity">str</span><span class="main">)</span> <span class="entity">ctxt</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_rewrite</span> <span class="entity">id</span> <span class="main">(</span><span class="entity">str1</span><span class="main">,</span> <span class="entity">str2</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Syntax.read_term <span class="entity">ctxt</span> <span class="entity">str1</span><span class="main">,</span> Syntax.read_term <span class="entity">ctxt</span> <span class="entity">str2</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th</span> <span class="main">=</span> <span class="entity">assume_eq</span> <span class="entity">thy</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">ctxt</span> |&gt; <span class="entity">RewriteTable.add_rewrite</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> |&gt; snd
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Check th is actually t(env) == u. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">check_info</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">u</span><span class="main">)</span> <span class="entity">txt</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">inst</span><span class="main">)</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t'</span> <span class="main">=</span> <span class="entity">Util.subst_term_norm</span> <span class="entity">inst</span> <span class="entity">t</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="main">=</span> Logic.dest_equals <span class="main">(</span>Thm.prop_of <span class="entity">th</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">lhs</span> aconv <span class="entity">t'</span> <span class="keyword1"><span class="keyword">andalso</span></span> <span class="entity">rhs</span> aconv <span class="entity">u</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> tracing <span class="main">(</span><span class="inner_quoted">"inst does not match th.\nt', u' = "</span> ^
                         <span class="main">(</span><span class="entity">Util.string_of_terms</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">t'</span><span class="main">,</span> <span class="entity">u</span><span class="main">]</span><span class="main">)</span> ^
                         <span class="inner_quoted">"\nth = "</span> ^
                         <span class="main">(</span>Syntax.string_of_term <span class="entity">ctxt</span> <span class="main">(</span>Thm.prop_of <span class="entity">th</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="entity">txt</span> <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">assert_match_gen</span> <span class="entity">matcher</span> <span class="main">(</span><span class="main">(</span><span class="entity">str_t</span><span class="main">,</span> <span class="entity">str_u</span><span class="main">)</span><span class="main">,</span> <span class="entity">info_str</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">u</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Proof_Context.read_term_pattern <span class="entity">ctxt</span> <span class="entity">str_t</span><span class="main">,</span>
                    Syntax.read_term <span class="entity">ctxt</span> <span class="entity">str_u</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_tlist</span> <span class="entity">ctxt</span> <span class="inner_quoted">"Matching"</span> <span class="main">[</span><span class="entity">t</span><span class="main">,</span> <span class="entity">u</span><span class="main">]</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">info</span> <span class="main">=</span> map <span class="main">(</span>apsnd <span class="main">(</span>Syntax.read_term <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span> <span class="entity">info_str</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">info'</span> <span class="main">=</span> <span class="entity">matcher</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">u</span><span class="main">)</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">fo_init</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">check_info</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">u</span><span class="main">)</span> <span class="inner_quoted">"assert_match"</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">info'</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">info''</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">meta_sym</span> <span class="entity">th</span><span class="main">)</span><span class="main">)</span> <span class="entity">info'</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="entity">assert_eq_info</span> <span class="main">(</span><span class="entity">info</span><span class="main">,</span> <span class="entity">info''</span><span class="main">)</span> <span class="inner_quoted">"assert_match"</span> <span class="entity">ctxt</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">assert_match</span> <span class="main">=</span> <span class="entity">assert_match_gen</span> <span class="entity">Matcher.match</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">assert_match_list</span> <span class="main">(</span><span class="entity">pairs_str</span><span class="main">,</span> <span class="entity">info_str</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pairs</span> <span class="main">=</span>
          map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">is_head</span><span class="main">,</span> <span class="main">(</span><span class="entity">str_t</span><span class="main">,</span> <span class="entity">str_u</span><span class="main">)</span><span class="main">)</span> <span class="main">=&gt;</span>
                  <span class="main">(</span><span class="entity">is_head</span><span class="main">,</span> <span class="main">(</span>Proof_Context.read_term_pattern <span class="entity">ctxt</span> <span class="entity">str_t</span><span class="main">,</span>
                             Thm.cterm_of <span class="entity">ctxt</span> <span class="main">(</span>Syntax.read_term <span class="entity">ctxt</span> <span class="entity">str_u</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
              <span class="entity">pairs_str</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">info</span> <span class="main">=</span> map <span class="main">(</span>apsnd <span class="main">(</span>map <span class="main">(</span>Syntax.read_term <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="entity">info_str</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">info'</span> <span class="main">=</span> <span class="entity">Matcher.rewrite_match_list</span> <span class="entity">ctxt</span> <span class="entity">pairs</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">fo_init</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">check_info_list</span> <span class="main">(</span><span class="entity">instsp</span><span class="main">,</span> <span class="entity">ths</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">check_pair</span> <span class="main">(</span><span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">cu</span><span class="main">)</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span> <span class="main">=</span>
                <span class="entity">check_info</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> Thm.term_of <span class="entity">cu</span><span class="main">)</span>
                           <span class="inner_quoted">"assert_match_list"</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">instsp</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            map <span class="entity">check_pair</span> <span class="main">(</span>map snd <span class="entity">pairs</span> ~~ <span class="entity">ths</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> map <span class="entity">check_info_list</span> <span class="entity">info'</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">info''</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="entity">ths</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> map <span class="entity">meta_sym</span> <span class="entity">ths</span><span class="main">)</span><span class="main">)</span> <span class="entity">info'</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eq_info_list'</span> <span class="main">=</span> eq_set <span class="main">(</span>eq_pair <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="main">(</span>eq_list <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv<span class="main">)</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">to_term_info'</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> <span class="entity">ths</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">id</span><span class="main">,</span> map <span class="entity">Util.rhs_of</span> <span class="entity">ths</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">eq_info_list'</span> <span class="main">(</span><span class="entity">info</span><span class="main">,</span> map <span class="entity">to_term_info'</span> <span class="entity">info''</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">ctxt</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> tracing <span class="main">(</span><span class="inner_quoted">"got "</span> ^ <span class="entity">print_infos'</span> <span class="entity">ctxt</span> <span class="entity">info''</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"assert_match_list"</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">done</span> <span class="entity">str</span> <span class="main">_</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> tracing <span class="main">(</span><span class="inner_quoted">"Finished "</span> ^ <span class="entity">str</span><span class="main">)</span> <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">in</span></span>

<span class="comment1">(* Basic rewriting. *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_rewrite</span> <span class="main">=</span>
    <span class="entity">init</span> |&gt; <span class="entity">add_prim_id</span> <span class="main">(</span><span class="inner_numeral">1</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> |&gt; <span class="entity">add_prim_id</span> <span class="main">(</span><span class="inner_numeral">2</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
         |&gt; <span class="entity">declare_term</span> <span class="inner_quoted">"[a::nat, b, c]"</span>
         |&gt; <span class="entity">declare_term</span> <span class="inner_quoted">"f::(nat =&gt; nat =&gt; nat)"</span>
         |&gt; <span class="entity">declare_pat</span> <span class="inner_quoted">"[?m::nat, ?n]"</span>
         |&gt; <span class="entity">declare_pat</span> <span class="inner_quoted">"?A::('a::{plus})"</span>
         |&gt; <span class="entity">add_rewrite</span> <span class="main">[</span><span class="inner_numeral">1</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"a"</span><span class="main">,</span> <span class="inner_quoted">"b"</span><span class="main">)</span>
         |&gt; <span class="entity">add_rewrite</span> <span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"a"</span><span class="main">,</span> <span class="inner_quoted">"c"</span><span class="main">)</span>
         |&gt; fold <span class="entity">assert_match</span>
         <span class="main">[</span><span class="main">(</span><span class="main">(</span><span class="inner_quoted">"a"</span><span class="main">,</span> <span class="inner_quoted">"b"</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="inner_numeral">1</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"a"</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
          <span class="main">(</span><span class="main">(</span><span class="inner_quoted">"c"</span><span class="main">,</span> <span class="inner_quoted">"a"</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"c"</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
          <span class="main">(</span><span class="main">(</span><span class="inner_quoted">"?n + ?n"</span><span class="main">,</span> <span class="inner_quoted">"a + b"</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="inner_numeral">1</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"a + a"</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
          <span class="main">(</span><span class="main">(</span><span class="inner_quoted">"?A + ?A"</span><span class="main">,</span> <span class="inner_quoted">"c + a"</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"c + c"</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
          <span class="main">(</span><span class="main">(</span><span class="inner_quoted">"?A + ?A + ?A"</span><span class="main">,</span> <span class="inner_quoted">"a + b + c"</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="inner_numeral">1</span><span class="main">,</span> <span class="inner_numeral">2</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"a + a + a"</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
          <span class="main">(</span><span class="main">(</span><span class="inner_quoted">"f ?m ?n"</span><span class="main">,</span> <span class="inner_quoted">"f a b"</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f a b"</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
          <span class="main">(</span><span class="main">(</span><span class="inner_quoted">"f ?m ?m"</span><span class="main">,</span> <span class="inner_quoted">"f c a"</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"f c c"</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">]</span>
         |&gt; <span class="entity">done</span> <span class="inner_quoted">"test_rewrite"</span>

<span class="comment1">(* Rewriting from atomic to function application. *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_rewrite2</span> <span class="main">=</span>
    <span class="entity">init</span> |&gt; <span class="entity">add_prim_id</span> <span class="main">(</span><span class="inner_numeral">1</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span> |&gt; <span class="entity">add_prim_id</span> <span class="main">(</span><span class="inner_numeral">2</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
         |&gt; <span class="entity">declare_term</span> <span class="inner_quoted">"[a::nat, b, c]"</span>
         |&gt; <span class="entity">declare_pat</span> <span class="inner_quoted">"[?n::nat]"</span>
         |&gt; <span class="entity">add_rewrite</span> <span class="main">[</span><span class="inner_numeral">1</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"a"</span><span class="main">,</span> <span class="inner_quoted">"b + c"</span><span class="main">)</span>
         |&gt; <span class="entity">add_rewrite</span> <span class="main">[</span><span class="inner_numeral">2</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"b"</span><span class="main">,</span> <span class="inner_quoted">"c"</span><span class="main">)</span>
         |&gt; <span class="entity">assert_match</span> <span class="main">(</span><span class="main">(</span><span class="inner_quoted">"?n + ?n"</span><span class="main">,</span> <span class="inner_quoted">"a"</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="inner_numeral">1</span><span class="main">,</span> <span class="inner_numeral">2</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"b + b"</span><span class="main">)</span><span class="main">]</span><span class="main">)</span>
         |&gt; <span class="entity">done</span> <span class="inner_quoted">"test_rewrite2"</span>

<span class="comment1">(* Abstractions. *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_abstraction</span> <span class="main">=</span>
    <span class="entity">init</span> |&gt; <span class="entity">declare_term</span> <span class="inner_quoted">"[m::nat, n]"</span>
         |&gt; <span class="entity">declare_term</span> <span class="inner_quoted">"P::(nat =&gt; nat =&gt; nat)"</span>
         |&gt; <span class="entity">declare_pat</span> <span class="inner_quoted">"?A::(nat =&gt; nat =&gt; 'a::{plus})"</span>
         |&gt; fold <span class="entity">assert_match</span>
         <span class="main">[</span><span class="main">(</span><span class="main">(</span><span class="inner_quoted">"%x y. ?A x y"</span><span class="main">,</span> <span class="inner_quoted">"%m n. P m n"</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"%m n. P m n"</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
          <span class="main">(</span><span class="main">(</span><span class="inner_quoted">"%x y. ?A x y + ?A y x"</span><span class="main">,</span> <span class="inner_quoted">"%m n. P m n + P n m"</span><span class="main">)</span><span class="main">,</span>
           <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"%m n. P m n + P n m"</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
          <span class="main">(</span><span class="main">(</span><span class="inner_quoted">"%x y. ?A x y"</span><span class="main">,</span> <span class="inner_quoted">"%x y. (x::nat) + y + y"</span><span class="main">)</span><span class="main">,</span>
           <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"%x y. (x::nat) + y + y"</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">]</span>
         |&gt; <span class="entity">done</span> <span class="inner_quoted">"test_abstraction"</span>

<span class="comment1">(* Abstractions with rewriting. *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_abstraction_rewrite</span> <span class="main">=</span>
    <span class="entity">init</span> |&gt; <span class="entity">declare_term</span> <span class="inner_quoted">"[m::nat, n, p]"</span>
         |&gt; <span class="entity">declare_term</span> <span class="inner_quoted">"P::(nat =&gt; nat =&gt; nat)"</span>
         |&gt; <span class="entity">declare_term</span> <span class="inner_quoted">"f::(nat =&gt; nat =&gt; 'a::{plus})"</span>
         |&gt; <span class="entity">declare_pat</span> <span class="inner_quoted">"?A::(nat =&gt; ?'a::{plus})"</span>
         |&gt; <span class="entity">add_rewrite</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"m"</span><span class="main">,</span> <span class="inner_quoted">"n"</span><span class="main">)</span>
         |&gt; <span class="entity">add_rewrite</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"p"</span><span class="main">,</span> <span class="inner_quoted">"0::nat"</span><span class="main">)</span>
         |&gt; <span class="entity">assert_match</span> <span class="main">(</span><span class="main">(</span><span class="inner_quoted">"%x. ?A x + ?A x"</span><span class="main">,</span> <span class="inner_quoted">"%x. P x m + P x n"</span><span class="main">)</span><span class="main">,</span>
                          <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"%x. P x m + P x m"</span><span class="main">)</span><span class="main">]</span><span class="main">)</span>
         |&gt; <span class="entity">assert_match</span> <span class="main">(</span><span class="main">(</span><span class="inner_quoted">"%x. f x 0"</span><span class="main">,</span> <span class="inner_quoted">"%x. f x p"</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"%x. f x 0"</span><span class="main">)</span><span class="main">]</span><span class="main">)</span>
         |&gt; <span class="entity">done</span> <span class="inner_quoted">"test_abstraction_rewrite"</span>

<span class="comment1">(* Test matching of higher order patterns. *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_higher_order</span> <span class="main">=</span>
    <span class="entity">init</span> |&gt; <span class="entity">declare_term</span> <span class="inner_quoted">"f::(nat =&gt; nat)"</span>
         |&gt; <span class="entity">declare_pat</span> <span class="inner_quoted">"?f::(nat =&gt; nat)"</span>
         |&gt; <span class="entity">assert_match</span> <span class="main">(</span><span class="main">(</span><span class="inner_quoted">"%n. (?f n, ?f (n + 1))"</span><span class="main">,</span> <span class="inner_quoted">"%n. (f n, f (n + 1))"</span><span class="main">)</span><span class="main">,</span>
                          <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"%n. (f n, f (n + 1))"</span><span class="main">)</span><span class="main">]</span><span class="main">)</span>
         |&gt; <span class="entity">assert_match</span> <span class="main">(</span><span class="main">(</span><span class="inner_quoted">"%n. (?f (n + 1), ?f n)"</span><span class="main">,</span> <span class="inner_quoted">"%n. (f (n + 1), f n)"</span><span class="main">)</span><span class="main">,</span>
                          <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"%n. (f (n + 1), f n)"</span><span class="main">)</span><span class="main">]</span><span class="main">)</span>
         |&gt; <span class="entity">done</span> <span class="inner_quoted">"test_higher_order"</span>

<span class="comment1">(* Test handling of schematic type variables. *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_match_type</span> <span class="main">=</span>
    <span class="entity">init</span> |&gt; <span class="entity">assert_match</span> <span class="main">(</span><span class="main">(</span><span class="inner_quoted">"image_mset ?f {#}"</span><span class="main">,</span> <span class="inner_quoted">"{#i. i :# {#}#}"</span><span class="main">)</span><span class="main">,</span>
                          <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"{#i. i :# {#}#}"</span><span class="main">)</span><span class="main">]</span><span class="main">)</span>
         |&gt; <span class="entity">assert_match</span> <span class="main">(</span><span class="main">(</span><span class="inner_quoted">"image_mset ?f {#}"</span><span class="main">,</span> <span class="inner_quoted">"{#(i::nat). i :# {#}#}"</span><span class="main">)</span><span class="main">,</span>
                          <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"{#(i::nat). i :# {#}#}"</span><span class="main">)</span><span class="main">]</span><span class="main">)</span>
         <span class="comment1">(* sorted [] has concrete type, but not []. *)</span>
         |&gt; <span class="entity">assert_match</span> <span class="main">(</span><span class="main">(</span><span class="inner_quoted">"sorted []"</span><span class="main">,</span> <span class="inner_quoted">"sorted []"</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"sorted []"</span><span class="main">)</span><span class="main">]</span><span class="main">)</span>
         |&gt; <span class="entity">done</span> <span class="inner_quoted">"test_match_type"</span>

<span class="comment1">(* Test special schematic variable ?NUMC. *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_numc</span> <span class="main">=</span>
    <span class="entity">init</span> |&gt; <span class="entity">declare_term</span> <span class="inner_quoted">"[k::int, m]"</span>
         |&gt; <span class="entity">add_rewrite</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"k"</span><span class="main">,</span> <span class="inner_quoted">"1::int"</span><span class="main">)</span>
         |&gt; <span class="entity">assert_match</span> <span class="main">(</span><span class="main">(</span><span class="inner_quoted">"?NUMC::int"</span><span class="main">,</span> <span class="inner_quoted">"k"</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"1::int"</span><span class="main">)</span><span class="main">]</span><span class="main">)</span>
         |&gt; <span class="entity">assert_match</span> <span class="main">(</span><span class="main">(</span><span class="inner_quoted">"?NUMC"</span><span class="main">,</span> <span class="inner_quoted">"k"</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_quoted">"1::int"</span><span class="main">)</span><span class="main">]</span><span class="main">)</span>
         |&gt; <span class="entity">assert_match</span> <span class="main">(</span><span class="main">(</span><span class="inner_quoted">"?NUMC"</span><span class="main">,</span> <span class="inner_quoted">"m"</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
         |&gt; <span class="entity">done</span> <span class="inner_quoted">"test_numc"</span>

<span class="comment1">(* Test match list. *)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_match_list</span> <span class="main">=</span>
    <span class="entity">init</span> |&gt; <span class="entity">declare_term</span> <span class="inner_quoted">"[k::nat, l]"</span>
         |&gt; <span class="entity">declare_pat</span> <span class="inner_quoted">"?a::nat"</span>
         |&gt; <span class="entity">add_rewrite</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span><span class="inner_quoted">"k"</span><span class="main">,</span> <span class="inner_quoted">"l"</span><span class="main">)</span>
         |&gt; <span class="entity">assert_match_list</span> <span class="main">(</span><span class="main">[</span><span class="main">(</span>false<span class="main">,</span> <span class="main">(</span><span class="inner_quoted">"?a"</span><span class="main">,</span> <span class="inner_quoted">"k"</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span>false<span class="main">,</span> <span class="main">(</span><span class="inner_quoted">"?a"</span><span class="main">,</span> <span class="inner_quoted">"l"</span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">,</span>
                               <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="inner_quoted">"k"</span><span class="main">,</span> <span class="inner_quoted">"k"</span><span class="main">]</span><span class="main">)</span><span class="main">]</span><span class="main">)</span>
         |&gt; <span class="entity">assert_match_list</span> <span class="main">(</span><span class="main">[</span><span class="main">(</span>false<span class="main">,</span> <span class="main">(</span><span class="inner_quoted">"?a"</span><span class="main">,</span> <span class="inner_quoted">"k"</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span>true<span class="main">,</span> <span class="main">(</span><span class="inner_quoted">"?a"</span><span class="main">,</span> <span class="inner_quoted">"l"</span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
         |&gt; <span class="entity">assert_match_list</span> <span class="main">(</span><span class="main">[</span><span class="main">(</span>true<span class="main">,</span> <span class="main">(</span><span class="inner_quoted">"?a"</span><span class="main">,</span> <span class="inner_quoted">"k"</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span>false<span class="main">,</span> <span class="main">(</span><span class="inner_quoted">"?a"</span><span class="main">,</span> <span class="inner_quoted">"l"</span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">,</span>
                               <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="inner_quoted">"k"</span><span class="main">,</span> <span class="inner_quoted">"k"</span><span class="main">]</span><span class="main">)</span><span class="main">]</span><span class="main">)</span>
         |&gt; <span class="entity">assert_match_list</span> <span class="main">(</span><span class="main">[</span><span class="main">(</span>true<span class="main">,</span> <span class="main">(</span><span class="inner_quoted">"?a + b"</span><span class="main">,</span> <span class="inner_quoted">"k + b"</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
                                <span class="main">(</span>true<span class="main">,</span> <span class="main">(</span><span class="inner_quoted">"?a + b"</span><span class="main">,</span> <span class="inner_quoted">"l + b"</span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">,</span>
                               <span class="main">[</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="inner_quoted">"k + b"</span><span class="main">,</span> <span class="inner_quoted">"k + b"</span><span class="main">]</span><span class="main">)</span><span class="main">]</span><span class="main">)</span>
         |&gt; <span class="entity">done</span> <span class="inner_quoted">"test_match_list"</span>

<span class="comment1">(* Test of pre-matcher. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">assert_pre_match_gen</span> <span class="entity">res</span> <span class="entity">at_head</span> <span class="main">(</span><span class="entity">str_t</span><span class="main">,</span> <span class="entity">str_u</span><span class="main">)</span> <span class="entity">ctxt</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">cu</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Proof_Context.read_term_pattern <span class="entity">ctxt</span> <span class="entity">str_t</span><span class="main">,</span>
                     Thm.cterm_of <span class="entity">ctxt</span> <span class="main">(</span>Syntax.read_term <span class="entity">ctxt</span> <span class="entity">str_u</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">pre_match_fn</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">at_head</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">Matcher.pre_match_head</span>
                         <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">Matcher.pre_match</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">pre_match_fn</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">cu</span><span class="main">)</span> <span class="main">=</span> <span class="entity">res</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">ctxt</span>
      <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_tlist</span> <span class="entity">ctxt</span> <span class="inner_quoted">"Pattern, term: "</span> <span class="main">[</span><span class="entity">t</span><span class="main">,</span> Thm.term_of <span class="entity">cu</span><span class="main">]</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="main">(</span><span class="inner_quoted">"assert_pre_match (expected "</span> ^ <span class="main">(</span><span class="entity">Util.string_of_bool</span> <span class="entity">res</span><span class="main">)</span> ^ <span class="inner_quoted">")"</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">assert_pre_match</span> <span class="main">=</span> <span class="entity">assert_pre_match_gen</span> true false
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">assert_not_pre_match</span> <span class="main">=</span> <span class="entity">assert_pre_match_gen</span> false false

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_pre_match</span> <span class="main">=</span>
    <span class="entity">init</span> |&gt; <span class="entity">declare_term</span> <span class="inner_quoted">"[m::nat, n]"</span>
         |&gt; <span class="entity">declare_term</span> <span class="inner_quoted">"[a::'a]"</span>
         |&gt; <span class="entity">declare_pat</span> <span class="inner_quoted">"?n::nat"</span>
         |&gt; <span class="entity">declare_pat</span> <span class="inner_quoted">"?a::?'a"</span>
         |&gt; <span class="entity">assert_pre_match</span> <span class="main">(</span><span class="inner_quoted">"?a"</span><span class="main">,</span> <span class="inner_quoted">"n"</span><span class="main">)</span>
         |&gt; <span class="entity">assert_pre_match</span> <span class="main">(</span><span class="inner_quoted">"?n"</span><span class="main">,</span> <span class="inner_quoted">"n"</span><span class="main">)</span>
         |&gt; <span class="entity">assert_not_pre_match</span> <span class="main">(</span><span class="inner_quoted">"?n"</span><span class="main">,</span> <span class="inner_quoted">"a"</span><span class="main">)</span>
         |&gt; <span class="entity">assert_not_pre_match</span> <span class="main">(</span><span class="inner_quoted">"m"</span><span class="main">,</span> <span class="inner_quoted">"n"</span><span class="main">)</span>
         |&gt; <span class="entity">done</span> <span class="inner_quoted">"test_pre_match"</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_pre_match_quant</span> <span class="main">=</span>
    <span class="entity">init</span> |&gt; <span class="entity">declare_term</span> <span class="inner_quoted">"[P::(nat =&gt; bool), Q]"</span>
         |&gt; <span class="entity">declare_term</span> <span class="inner_quoted">"[S::(nat =&gt; nat =&gt; bool), T]"</span>
         |&gt; <span class="entity">declare_term</span> <span class="inner_quoted">"[x::nat, y, z]"</span>
         |&gt; <span class="entity">assert_pre_match</span> <span class="main">(</span><span class="inner_quoted">"ALL x. P x"</span><span class="main">,</span> <span class="inner_quoted">"ALL y. P y"</span><span class="main">)</span>
         |&gt; <span class="entity">assert_not_pre_match</span> <span class="main">(</span><span class="inner_quoted">"ALL x. P x"</span><span class="main">,</span> <span class="inner_quoted">"ALL x. Q x"</span><span class="main">)</span>
         |&gt; <span class="entity">assert_pre_match</span> <span class="main">(</span><span class="inner_quoted">"ALL x y. S x y"</span><span class="main">,</span> <span class="inner_quoted">"ALL y z. S y z"</span><span class="main">)</span>
         |&gt; <span class="entity">assert_not_pre_match</span> <span class="main">(</span><span class="inner_quoted">"ALL x y. S x y"</span><span class="main">,</span> <span class="inner_quoted">"ALL x y. S y x"</span><span class="main">)</span>
         |&gt; <span class="entity">assert_not_pre_match</span> <span class="main">(</span><span class="inner_quoted">"ALL x y. S x y"</span><span class="main">,</span> <span class="inner_quoted">"ALL x y. T x y"</span><span class="main">)</span>
         |&gt; <span class="entity">assert_pre_match</span> <span class="main">(</span><span class="inner_quoted">"ALL x y. ?S x y"</span><span class="main">,</span> <span class="inner_quoted">"ALL x y. x &lt; y"</span><span class="main">)</span>
         |&gt; <span class="entity">assert_pre_match</span> <span class="main">(</span><span class="inner_quoted">"ALL x. x + y = z &amp; ?P x"</span><span class="main">,</span>
                              <span class="inner_quoted">"ALL x. x + y = z &amp; P x"</span><span class="main">)</span>
         |&gt; <span class="entity">done</span> <span class="inner_quoted">"test_pre_match_quant"</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="files/normalize_test.ML">
<div class="head">
<h1>File ‹normalize_test.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*
  File: normalize_test.ML
  Author: Bohua Zhan

  Unit test for normalizer.ML.
*)</span>

<span class="keyword2"><span class="keyword">local</span></span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ts</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span> Free <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">boolT</span><span class="main">)</span><span class="main">)</span> <span class="main">[</span><span class="inner_quoted">"A"</span><span class="main">,</span> <span class="inner_quoted">"B"</span><span class="main">,</span> <span class="inner_quoted">"C"</span><span class="main">]</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt</span> <span class="main">=</span> fold <span class="entity">Util.declare_free_term</span> <span class="entity">ts</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span>

<span class="keyword2"><span class="keyword">in</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_normalize</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">test</span> <span class="main">(</span><span class="entity">str</span><span class="main">,</span> <span class="entity">strs</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t</span> <span class="main">=</span> Syntax.read_term <span class="entity">ctxt</span> <span class="entity">str</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ts</span> <span class="main">=</span> map <span class="main">(</span>Syntax.read_term <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">strs</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ritem</span> <span class="main">=</span>
                <span class="entity">Update.thm_to_ritem</span> <span class="main">(</span><span class="entity">Util.assume_thm</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">mk_Trueprop</span> <span class="entity">t</span><span class="main">)</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ritems'</span> <span class="main">=</span> <span class="entity">Normalizer.normalize</span> <span class="entity">ctxt</span> <span class="entity">ritem</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ts'</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">dest_Trueprop</span> o Thm.prop_of o <span class="entity">BoxItem.get_thm_raw</span><span class="main">)</span>
                          <span class="entity">ritems'</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="keyword2"><span class="keyword">if</span></span> length <span class="entity">ts</span> <span class="main">=</span> length <span class="entity">ts'</span> <span class="keyword1"><span class="keyword">andalso</span></span>
               eq_set <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv<span class="main">)</span> <span class="main">(</span><span class="entity">ts</span><span class="main">,</span> <span class="entity">ts'</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">)</span>
            <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_t</span> <span class="entity">ctxt</span> <span class="inner_quoted">"Input:"</span> <span class="entity">t</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_tlist</span> <span class="entity">ctxt</span> <span class="inner_quoted">"Expected:"</span> <span class="entity">ts</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_tlist</span> <span class="entity">ctxt</span> <span class="inner_quoted">"Actual:"</span> <span class="entity">ts'</span>
            <span class="keyword2"><span class="keyword">in</span></span>
              <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"test_normalize"</span>
            <span class="keyword2"><span class="keyword">end</span></span>
          <span class="keyword2"><span class="keyword">end</span></span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_data</span> <span class="main">=</span> <span class="main">[</span>
        <span class="main">(</span><span class="inner_quoted">"A &amp; B &amp; C"</span><span class="main">,</span> <span class="main">[</span><span class="inner_quoted">"A"</span><span class="main">,</span> <span class="inner_quoted">"B"</span><span class="main">,</span> <span class="inner_quoted">"C"</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"~ (A | B | C)"</span><span class="main">,</span> <span class="main">[</span><span class="inner_quoted">"~ A"</span><span class="main">,</span> <span class="inner_quoted">"~ B"</span><span class="main">,</span> <span class="inner_quoted">"~ C"</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"~ ~ (~ A &amp; (~ ~ B))"</span><span class="main">,</span> <span class="main">[</span><span class="inner_quoted">"~ A"</span><span class="main">,</span> <span class="inner_quoted">"B"</span><span class="main">]</span><span class="main">)</span>
      <span class="main">]</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      map <span class="entity">test</span> <span class="entity">test_data</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_use_vardefs</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">test</span> <span class="main">(</span><span class="entity">s1</span><span class="main">,</span> <span class="entity">s2</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span> <span class="entity">the_pair</span> <span class="main">(</span>Syntax.read_terms <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">s1</span><span class="main">,</span> <span class="entity">s2</span><span class="main">]</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t2</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> fastype_of <span class="entity">t2</span> <span class="main">=</span> <span class="entity">propT</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">t2</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">mk_Trueprop</span> <span class="entity">t2</span>

            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th1</span> <span class="main">=</span> <span class="entity">t1</span> |&gt; <span class="entity">mk_Trueprop</span> |&gt; Thm.cterm_of <span class="entity">ctxt</span> |&gt; Thm.assume
                         |&gt; <span class="entity">apply_to_thm</span> <span class="main">(</span><span class="entity">UtilLogic.to_meta_conv</span> <span class="entity">ctxt</span><span class="main">)</span>
                         |&gt; <span class="entity">Util.forall_elim_sch</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">th2</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Normalizer.meta_use_vardefs</span> <span class="entity">th1</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="keyword2"><span class="keyword">if</span></span> Thm.prop_of <span class="entity">th2</span> aconv <span class="entity">t2</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">)</span>
            <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_t</span> <span class="entity">ctxt</span> <span class="inner_quoted">"Input:"</span> <span class="entity">t1</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_t</span> <span class="entity">ctxt</span> <span class="inner_quoted">"Expected:"</span> <span class="entity">t2</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_t</span> <span class="entity">ctxt</span> <span class="inner_quoted">"Actual:"</span> <span class="main">(</span>Thm.prop_of <span class="entity">th2</span><span class="main">)</span>
            <span class="keyword2"><span class="keyword">in</span></span>
              <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"test_use_vardefs"</span>
            <span class="keyword2"><span class="keyword">end</span></span>
          <span class="keyword2"><span class="keyword">end</span></span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_data</span> <span class="main">=</span> <span class="main">[</span>
        <span class="main">(</span><span class="inner_quoted">"!s. s = f x --&gt; P s"</span><span class="main">,</span> <span class="inner_quoted">"P (f x)"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"!s t. s = f x --&gt; t = g x --&gt; P s t"</span><span class="main">,</span> <span class="inner_quoted">"P (f x) (g x)"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"!s t. x &lt; y --&gt; s = f x --&gt; t = g y --&gt; P s t"</span><span class="main">,</span>
         <span class="inner_quoted">"x &lt; y ==&gt; P (f x) (g y)"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"!s. ~s = f x | P s"</span><span class="main">,</span> <span class="inner_quoted">"P (f x)"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"!s t. ~s = f x | ~t = g x | P s t"</span><span class="main">,</span> <span class="inner_quoted">"P (f x) (g x)"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"!s t. ~x &lt; y | ~s = f x | ~t = g y | P s t"</span><span class="main">,</span> <span class="inner_quoted">"~x &lt; y | P (f x) (g y)"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"!s. P s | ~s = f x"</span><span class="main">,</span> <span class="inner_quoted">"P (f x)"</span><span class="main">)</span><span class="main">,</span>

        <span class="main">(</span><span class="inner_quoted">"!a b. (a,b) = c --&gt; P a b"</span><span class="main">,</span> <span class="inner_quoted">"P (fst c) (snd c)"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"!a b. (a,b) ~= c | P a b"</span><span class="main">,</span> <span class="inner_quoted">"P (fst c) (snd c)"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"!a b c. (a,(b,c)) = d --&gt; P a b c"</span><span class="main">,</span>
         <span class="inner_quoted">"P (fst d) (fst (snd d)) (snd (snd d))"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"!a b c. ((a,b),c) = d --&gt; P a b c"</span><span class="main">,</span>
         <span class="inner_quoted">"P (fst (fst d)) (snd (fst d)) (snd d)"</span><span class="main">)</span>
      <span class="main">]</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      map <span class="entity">test</span> <span class="entity">test_data</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>  <span class="comment1">(* local *)</span>
</pre>
</div><div id="files/logic_steps_test.ML">
<div class="head">
<h1>File ‹logic_steps_test.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*
  File: logic_steps_test.ML
  Author: Bohua Zhan

  Unit test for logic_steps.ML.
*)</span>

<span class="keyword2"><span class="keyword">local</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">theory</span><span class="antiquote">}</span></span></span>
<span class="keyword2"><span class="keyword">in</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_norm_all_disj</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">test</span> <span class="main">(</span><span class="entity">str1</span><span class="main">,</span> <span class="entity">str2</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Proof_Context.read_term_pattern <span class="entity">ctxt</span> <span class="entity">str1</span><span class="main">,</span>
                            Proof_Context.read_term_pattern <span class="entity">ctxt</span> <span class="entity">str2</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ct1</span> <span class="main">=</span> Thm.cterm_of <span class="entity">ctxt</span> <span class="entity">t1</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">vars</span><span class="main">,</span> <span class="entity">ts</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Logic_ProofSteps.strip_all_disj</span> <span class="entity">t1</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">res_th</span> <span class="main">=</span> <span class="entity">Logic_ProofSteps.norm_all_disj</span> <span class="entity">ctxt</span> <span class="entity">ct1</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span><span class="entity">Logic_ProofSteps.mk_all_disj</span> <span class="main">(</span><span class="entity">vars</span><span class="main">,</span> <span class="entity">ts</span><span class="main">)</span> aconv <span class="entity">t2</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
              <span class="keyword2"><span class="keyword">let</span></span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_t</span> <span class="entity">ctxt</span> <span class="inner_quoted">"Input"</span> <span class="entity">t1</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_t</span> <span class="entity">ctxt</span> <span class="inner_quoted">"Output"</span> <span class="main">(</span><span class="entity">Logic_ProofSteps.mk_all_disj</span> <span class="main">(</span><span class="entity">vars</span><span class="main">,</span> <span class="entity">ts</span><span class="main">)</span><span class="main">)</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_t</span> <span class="entity">ctxt</span> <span class="inner_quoted">"Expected"</span> <span class="entity">t2</span>
              <span class="keyword2"><span class="keyword">in</span></span>
                <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"test_strip_all_disj"</span>
              <span class="keyword2"><span class="keyword">end</span></span>
            <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">if</span></span> not <span class="main">(</span><span class="entity">Util.rhs_of</span> <span class="entity">res_th</span> aconv <span class="entity">t2</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span>
              <span class="keyword2"><span class="keyword">let</span></span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_t</span> <span class="entity">ctxt</span> <span class="inner_quoted">"Input"</span> <span class="entity">t1</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_t</span> <span class="entity">ctxt</span> <span class="inner_quoted">"Output"</span> <span class="main">(</span><span class="entity">Util.rhs_of</span> <span class="entity">res_th</span><span class="main">)</span>
                <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_t</span> <span class="entity">ctxt</span> <span class="inner_quoted">"Expected"</span> <span class="entity">t2</span>
              <span class="keyword2"><span class="keyword">in</span></span>
                <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"test_norm_all_disj"</span>
              <span class="keyword2"><span class="keyword">end</span></span>
            <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_data</span> <span class="main">=</span> <span class="main">[</span>
        <span class="main">(</span><span class="inner_quoted">"A::bool"</span><span class="main">,</span> <span class="inner_quoted">"A::bool"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"A | B"</span><span class="main">,</span> <span class="inner_quoted">"A | B"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"A | B | C | D"</span><span class="main">,</span> <span class="inner_quoted">"A | B | C | D"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"((A | B) | C) | D"</span><span class="main">,</span> <span class="inner_quoted">"A | B | C | D"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"(A | B | C) | (D | E) | F"</span><span class="main">,</span> <span class="inner_quoted">"A | B | C | D | E | F"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"~~A"</span><span class="main">,</span> <span class="inner_quoted">"A::bool"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"~~((A | B) | C)"</span><span class="main">,</span> <span class="inner_quoted">"A | B | C"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"~(A &amp; B)"</span><span class="main">,</span> <span class="inner_quoted">"~A | ~B"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"~(A &amp; B &amp; C &amp; D)"</span><span class="main">,</span> <span class="inner_quoted">"~A | ~B | ~C | ~D"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"~(((A &amp; B) &amp; C) &amp; D)"</span><span class="main">,</span> <span class="inner_quoted">"~A | ~B | ~C | ~D"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"A --&gt; B"</span><span class="main">,</span> <span class="inner_quoted">"~A | B"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"A --&gt; B --&gt; C --&gt; D"</span><span class="main">,</span> <span class="inner_quoted">"~A | ~B | ~C | D"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"A &amp; B --&gt; C"</span><span class="main">,</span> <span class="inner_quoted">"~A | ~B | C"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"A --&gt; B | C"</span><span class="main">,</span> <span class="inner_quoted">"~A | B | C"</span><span class="main">)</span><span class="main">,</span>

        <span class="main">(</span><span class="inner_quoted">"p &amp; (q --&gt; r) --&gt; s"</span><span class="main">,</span> <span class="inner_quoted">"~p | ~(q --&gt; r) | s"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"~ (p &amp; (q --&gt; r)) | s"</span><span class="main">,</span> <span class="inner_quoted">"~p | ~(q --&gt; r) | s"</span><span class="main">)</span><span class="main">,</span>

        <span class="main">(</span><span class="inner_quoted">"!x. A x"</span><span class="main">,</span> <span class="inner_quoted">"!x. A x"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"!x y z. P x y z"</span><span class="main">,</span> <span class="inner_quoted">"!x y z. P x y z"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"!x:S. A x"</span><span class="main">,</span> <span class="inner_quoted">"!x. x ~: S | A x"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"!x:S. !y:S. !z:S. P x y z"</span><span class="main">,</span>
         <span class="inner_quoted">"!x y z. x ~: S | y ~: S | z ~: S | P x y z"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"!x. A x --&gt; B x --&gt; C x"</span><span class="main">,</span> <span class="inner_quoted">"!x. ~A x | ~B x | C x"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"!x. A x --&gt; (!y. B x y --&gt; (!z. C x y z))"</span><span class="main">,</span>
         <span class="inner_quoted">"!x y z. ~A x | ~B x y | C x y z"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"!x:S. A x --&gt; (!y:S. B x y --&gt; (!z:S. C x y z))"</span><span class="main">,</span>
         <span class="inner_quoted">"!x y z. x ~: S | ~A x | y ~: S | ~B x y | z ~: S | C x y z"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"!x. (!y. A y) --&gt; B x"</span><span class="main">,</span> <span class="inner_quoted">"!x. ~(!y. A y) | B x"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"~(EX x. P x)"</span><span class="main">,</span> <span class="inner_quoted">"!x. ~P x"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"~(EX x:S. P x)"</span><span class="main">,</span> <span class="inner_quoted">"!x. x ~: S | ~P x"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"~(EX x. P x &amp; Q x)"</span><span class="main">,</span> <span class="inner_quoted">"!x. ~P x | ~Q x"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"~(EX x:S. P x &amp; Q x)"</span><span class="main">,</span> <span class="inner_quoted">"!x. x ~: S | ~P x | ~Q x"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"~(EX x y. P x y)"</span><span class="main">,</span> <span class="inner_quoted">"!x y. ~P x y"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"~(EX x:S. EX y:S. P x y)"</span><span class="main">,</span> <span class="inner_quoted">"!x y. x ~: S | y ~: S | ~P x y"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"~(EX x. P x &amp; (EX y. Q x y))"</span><span class="main">,</span> <span class="inner_quoted">"!x y. ~P x | ~Q x y"</span><span class="main">)</span><span class="main">,</span>

        <span class="main">(</span><span class="inner_quoted">"p &amp; (q --&gt; r) --&gt; s"</span><span class="main">,</span> <span class="inner_quoted">"~p | ~(q --&gt; r) | s"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"~ (p &amp; (q --&gt; r)) | s"</span><span class="main">,</span> <span class="inner_quoted">"~p | ~(q --&gt; r) | s"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"!x. ?P x"</span><span class="main">,</span> <span class="inner_quoted">"!x. ?P x"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"(!x. P x) | (!y. Q y)"</span><span class="main">,</span> <span class="inner_quoted">"!x y. P x | Q y"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"!x. (P::'a=&gt;bool) y"</span><span class="main">,</span> <span class="inner_quoted">"(P::'a=&gt;bool) y"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"!x. P (y::'a) --&gt; Q y"</span><span class="main">,</span> <span class="inner_quoted">"~P (y::'a) | Q y"</span><span class="main">)</span>
      <span class="main">]</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      map <span class="entity">test</span> <span class="entity">test_data</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">free_to_var</span> <span class="entity">t</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
        Free <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="main">=&gt;</span> Var <span class="main">(</span><span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">)</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"free_to_var"</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_disj_prop_match</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">test</span> <span class="main">(</span><span class="entity">str1</span><span class="main">,</span> <span class="entity">str2</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">u</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Proof_Context.read_term_pattern <span class="entity">ctxt</span> <span class="entity">str1</span><span class="main">,</span>
                          Syntax.read_term <span class="entity">ctxt</span> <span class="entity">str2</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">var_u</span><span class="main">,</span> <span class="entity">us</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Logic_ProofSteps.strip_all_disj</span> <span class="entity">u</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">var_u'</span> <span class="main">=</span> map <span class="entity">free_to_var</span> <span class="entity">var_u</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">us'</span> <span class="main">=</span> map <span class="main">(</span>subst_atomic <span class="main">(</span><span class="entity">var_u</span> ~~ <span class="entity">var_u'</span><span class="main">)</span><span class="main">)</span> <span class="entity">us</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">cvar_u</span><span class="main">,</span> <span class="entity">cus</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>map Term.dest_Var <span class="entity">var_u'</span><span class="main">,</span> map <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">us'</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">var_t</span><span class="main">,</span> <span class="entity">ts</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">Logic_ProofSteps.strip_all_disj</span> <span class="entity">t</span><span class="main">)</span> |&gt; <span class="entity">Logic_ProofSteps.replace_disj_vars</span> <span class="entity">ctxt</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">res</span> <span class="main">=</span> <span class="entity">Logic_ProofSteps.disj_prop_match</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">fo_init</span><span class="main">)</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="main">(</span><span class="entity">var_t</span><span class="main">,</span> <span class="entity">ts</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">cvar_u</span><span class="main">,</span> <span class="entity">cus</span><span class="main">)</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">u'</span> <span class="main">=</span> <span class="entity">Logic_ProofSteps.mk_all_disj</span> <span class="main">(</span><span class="entity">var_u</span><span class="main">,</span> <span class="entity">us</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">res</span> <span class="keyword2"><span class="keyword">of</span></span>
                <span class="main">[</span><span class="main">(</span><span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">instsp</span><span class="main">)</span><span class="main">,</span> <span class="entity">eq</span><span class="main">)</span><span class="main">]</span> <span class="main">=&gt;</span>
                <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">Util.lhs_of</span> <span class="entity">eq</span> aconv <span class="main">(</span><span class="entity">Util.subst_term_norm</span> <span class="entity">instsp</span> <span class="entity">t</span><span class="main">)</span> <span class="keyword1"><span class="keyword">andalso</span></span>
                   <span class="entity">Util.rhs_of</span> <span class="entity">eq</span> aconv <span class="entity">u'</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span>
                <span class="keyword2"><span class="keyword">let</span></span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_t</span> <span class="entity">ctxt</span> <span class="inner_quoted">"t"</span> <span class="entity">t</span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_t</span> <span class="entity">ctxt</span> <span class="inner_quoted">"u"</span> <span class="entity">u</span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_thm</span> <span class="entity">ctxt</span> <span class="inner_quoted">"Output"</span> <span class="entity">eq</span>
                <span class="keyword2"><span class="keyword">in</span></span>
                  <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"disj_prop_match: wrong equation"</span>
                <span class="keyword2"><span class="keyword">end</span></span>
              <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span>
                <span class="keyword2"><span class="keyword">let</span></span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_t</span> <span class="entity">ctxt</span> <span class="inner_quoted">"t"</span> <span class="entity">t</span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_t</span> <span class="entity">ctxt</span> <span class="inner_quoted">"u"</span> <span class="entity">u</span>
                  <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> tracing <span class="main">(</span><span class="inner_quoted">"Number of results: "</span> ^
                                   <span class="main">(</span>string_of_int <span class="main">(</span>length <span class="entity">res</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
                <span class="keyword2"><span class="keyword">in</span></span>
                  <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"disj_prop_match: wrong number of equations"</span>
                <span class="keyword2"><span class="keyword">end</span></span>
          <span class="keyword2"><span class="keyword">end</span></span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_data</span> <span class="main">=</span> <span class="main">[</span>
        <span class="main">(</span><span class="inner_quoted">"A::bool"</span><span class="main">,</span> <span class="inner_quoted">"A::bool"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"A | B | C"</span><span class="main">,</span> <span class="inner_quoted">"A | B | C"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"(A | B) | C"</span><span class="main">,</span> <span class="inner_quoted">"A | B | C"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"A --&gt; B --&gt; C"</span><span class="main">,</span> <span class="inner_quoted">"~A | ~B | C"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"B --&gt; A --&gt; C"</span><span class="main">,</span> <span class="inner_quoted">"C | ~B | ~A"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"A &amp; (B --&gt; C) --&gt; D"</span><span class="main">,</span> <span class="inner_quoted">"A &amp; (B --&gt; C) --&gt; D"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"p &amp; (q --&gt; r) --&gt; s"</span><span class="main">,</span> <span class="inner_quoted">"~ (p &amp; (q --&gt; r)) | s"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"!x. P x | Q x"</span><span class="main">,</span> <span class="inner_quoted">"!x. P x | Q x"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"!x::nat. Q x | P x"</span><span class="main">,</span> <span class="inner_quoted">"!x::nat. P x | Q x"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"!x::nat. P x --&gt; Q x"</span><span class="main">,</span> <span class="inner_quoted">"!x::nat. Q x | ~P x"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"!x y. P x y | Q x y"</span><span class="main">,</span> <span class="inner_quoted">"!x y. Q x y | P x y"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"!a. P a | Q a"</span><span class="main">,</span> <span class="inner_quoted">"!x. P x | Q x"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"~(EX x. P x)"</span><span class="main">,</span> <span class="inner_quoted">"~(EX x. P x)"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"~(EX x. P x)"</span><span class="main">,</span> <span class="inner_quoted">"!x. ~P x"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"!x. ~P x"</span><span class="main">,</span> <span class="inner_quoted">"~(EX x. P x)"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"~(EX x:S. P x)"</span><span class="main">,</span> <span class="inner_quoted">"~(EX x:S. P x)"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"~(EX x:S. P x)"</span><span class="main">,</span> <span class="inner_quoted">"!x:S. ~P x"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"~(EX x:S. EX y:S. P x y)"</span><span class="main">,</span> <span class="inner_quoted">"!x:S. !y:S. ~P x y"</span><span class="main">)</span><span class="main">,</span>

        <span class="main">(</span><span class="inner_quoted">"!x. P x ?a"</span><span class="main">,</span> <span class="inner_quoted">"!x. P x a"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"!x:?S. P x"</span><span class="main">,</span> <span class="inner_quoted">"!x:S. P x"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"~(EX x. P x ?a)"</span><span class="main">,</span> <span class="inner_quoted">"!x. ~P x a"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"~(EX x:?S. P x)"</span><span class="main">,</span> <span class="inner_quoted">"!x:S. ~P x"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"!x. ?P x"</span><span class="main">,</span> <span class="inner_quoted">"!x. P x"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"!x y. ?P x | ?Q y"</span><span class="main">,</span> <span class="inner_quoted">"!x y. P x | Q y"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"~(EX x. EX y. ?P x &amp; ?Q y)"</span><span class="main">,</span> <span class="inner_quoted">"~(EX x. EX y. P x &amp; Q y)"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"!x y. ?P x | ?Q y"</span><span class="main">,</span> <span class="inner_quoted">"!x y. P y | Q x"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"!x. P y --&gt; Q y"</span><span class="main">,</span> <span class="inner_quoted">"P y --&gt; Q y"</span><span class="main">)</span>
      <span class="main">]</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      map <span class="entity">test</span> <span class="entity">test_data</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_disj_prop_no_match</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">test</span> <span class="main">(</span><span class="entity">str1</span><span class="main">,</span> <span class="entity">str2</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">u</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Proof_Context.read_term_pattern <span class="entity">ctxt</span> <span class="entity">str1</span><span class="main">,</span>
                          Syntax.read_term <span class="entity">ctxt</span> <span class="entity">str2</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">var_u</span><span class="main">,</span> <span class="entity">us</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Logic_ProofSteps.strip_all_disj</span> <span class="entity">u</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">var_u'</span> <span class="main">=</span> map <span class="entity">free_to_var</span> <span class="entity">var_u</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">us'</span> <span class="main">=</span> map <span class="main">(</span>subst_atomic <span class="main">(</span><span class="entity">var_u</span> ~~ <span class="entity">var_u'</span><span class="main">)</span><span class="main">)</span> <span class="entity">us</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">cvar_u</span><span class="main">,</span> <span class="entity">cus</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>map Term.dest_Var <span class="entity">var_u'</span><span class="main">,</span> map <span class="main">(</span>Thm.cterm_of <span class="entity">ctxt</span><span class="main">)</span> <span class="entity">us'</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">var_t</span><span class="main">,</span> <span class="entity">ts</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">Logic_ProofSteps.strip_all_disj</span> <span class="entity">t</span><span class="main">)</span> |&gt; <span class="entity">Logic_ProofSteps.replace_disj_vars</span> <span class="entity">ctxt</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">res</span> <span class="main">=</span> <span class="entity">Logic_ProofSteps.disj_prop_match</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">fo_init</span><span class="main">)</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="main">(</span><span class="entity">var_t</span><span class="main">,</span> <span class="entity">ts</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">cvar_u</span><span class="main">,</span> <span class="entity">cus</span><span class="main">)</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">res</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">)</span>
            <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_t</span> <span class="entity">ctxt</span> <span class="inner_quoted">"t"</span> <span class="entity">t</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_t</span> <span class="entity">ctxt</span> <span class="inner_quoted">"u"</span> <span class="entity">u</span>
            <span class="keyword2"><span class="keyword">in</span></span>
              <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"disj_prop_no_match: expected no match"</span>
            <span class="keyword2"><span class="keyword">end</span></span>
          <span class="keyword2"><span class="keyword">end</span></span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_data</span> <span class="main">=</span> <span class="main">[</span>
        <span class="main">(</span><span class="inner_quoted">"!x y. ?P x | ?Q y"</span><span class="main">,</span> <span class="inner_quoted">"!x y. P x y | Q x y"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"!x::'a. P (a::'a) | Q x"</span><span class="main">,</span> <span class="inner_quoted">"!a::'a. P (a::'a) | Q a"</span><span class="main">)</span>
      <span class="main">]</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      map <span class="entity">test</span> <span class="entity">test_data</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_match_update</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">x</span> <span class="main">=</span> Free <span class="main">(</span><span class="inner_quoted">"x"</span><span class="main">,</span> <span class="entity">natT</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">y</span> <span class="main">=</span> Free <span class="main">(</span><span class="inner_quoted">"y"</span><span class="main">,</span> <span class="entity">natT</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">A</span> <span class="main">=</span> Free <span class="main">(</span><span class="inner_quoted">"A"</span><span class="main">,</span> <span class="entity">boolT</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">B</span> <span class="main">=</span> Free <span class="main">(</span><span class="inner_quoted">"B"</span><span class="main">,</span> <span class="entity">natT</span> --&gt; <span class="entity">boolT</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">D</span> <span class="main">=</span> Free <span class="main">(</span><span class="inner_quoted">"D"</span><span class="main">,</span> <span class="entity">boolT</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt'</span> <span class="main">=</span> <span class="entity">ctxt</span> |&gt; fold Variable.declare_term <span class="main">[</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">,</span> <span class="entity">A</span><span class="main">,</span> <span class="entity">B</span><span class="main">,</span> <span class="entity">D</span><span class="main">]</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt''</span> <span class="main">=</span> <span class="entity">ctxt'</span> |&gt; <span class="entity">RewriteTable.add_rewrite</span> <span class="main">(</span><span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="entity">assume_eq</span> <span class="entity">thy</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">y</span><span class="main">)</span><span class="main">)</span> |&gt; snd

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">disj_to_ritem</span> <span class="entity">th</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">subs</span> <span class="main">=</span> <span class="entity">strip_disj</span> <span class="main">(</span><span class="entity">prop_of'</span> <span class="entity">th</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="entity">Fact</span> <span class="main">(</span><span class="entity">TY_DISJ</span><span class="main">,</span> <span class="entity">bFalse</span> :: <span class="entity">disj</span> :: <span class="entity">subs</span><span class="main">,</span> <span class="entity">th</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">read_prop</span> <span class="entity">str</span> <span class="main">=</span>
          <span class="entity">str</span> |&gt; Proof_Context.read_term_pattern <span class="entity">ctxt'</span> |&gt; <span class="entity">mk_Trueprop</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">updt_to_thm</span> <span class="entity">updt</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">updt</span> <span class="keyword2"><span class="keyword">of</span></span>
              <span class="entity">AddItems</span> <span class="main">{</span><span class="entity">raw_items</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span> map <span class="entity">BoxItem.get_thm_raw</span> <span class="entity">raw_items</span>
            <span class="main">|</span> <span class="entity">ResolveBox</span> <span class="main">{</span><span class="entity">th</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="entity">th</span><span class="main">]</span>
            <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="main">]</span>

      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">test_updt</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">disj_str</span><span class="main">,</span> <span class="entity">t_str</span><span class="main">,</span> <span class="entity">res_strs</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">disj_th</span> <span class="main">=</span> <span class="entity">Util.assume_thm</span> <span class="entity">ctxt'</span> <span class="main">(</span><span class="entity">read_prop</span> <span class="entity">disj_str</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th</span> <span class="main">=</span> <span class="entity">Util.assume_thm</span> <span class="entity">ctxt'</span> <span class="main">(</span><span class="entity">read_prop</span> <span class="entity">t_str</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">res_ts</span> <span class="main">=</span> map <span class="entity">read_prop</span> <span class="entity">res_strs</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mk_box_item</span> <span class="main">=</span> <span class="entity">BoxItem.mk_box_item</span> <span class="entity">ctxt'</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">items</span> <span class="main">=</span> <span class="main">[</span><span class="entity">mk_box_item</span> <span class="main">(</span><span class="inner_numeral">0</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">,</span> <span class="entity">disj_to_ritem</span> <span class="entity">disj_th</span><span class="main">)</span><span class="main">,</span>
                         <span class="entity">mk_box_item</span> <span class="main">(</span><span class="inner_numeral">0</span><span class="main">,</span> <span class="main">[</span><span class="inner_numeral">0</span><span class="main">]</span><span class="main">,</span> <span class="inner_numeral">0</span><span class="main">,</span> <span class="entity">Update.thm_to_ritem</span> <span class="entity">th</span><span class="main">)</span><span class="main">]</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">updts</span> <span class="main">=</span> <span class="entity">ProofStep.apply_prfstep</span> <span class="entity">ctxt</span> <span class="entity">items</span> <span class="entity">Logic_ProofSteps.match_update_prfstep</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">res_ts'</span> <span class="main">=</span> maps <span class="entity">updt_to_thm</span> <span class="entity">updts</span> |&gt; map Thm.prop_of
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="keyword2"><span class="keyword">if</span></span> eq_set <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> aconv<span class="main">)</span> <span class="main">(</span><span class="entity">res_ts</span><span class="main">,</span> <span class="entity">res_ts'</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">)</span>
            <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword2"><span class="keyword">let</span></span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_t</span> <span class="entity">ctxt'</span> <span class="inner_quoted">"Input disj:"</span> <span class="main">(</span><span class="entity">prop_of'</span> <span class="entity">disj_th</span><span class="main">)</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_t</span> <span class="entity">ctxt'</span> <span class="inner_quoted">"Input t:"</span> <span class="main">(</span><span class="entity">prop_of'</span> <span class="entity">th</span><span class="main">)</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_tlist</span> <span class="entity">ctxt'</span> <span class="inner_quoted">"Expected:"</span> <span class="entity">res_ts</span>
              <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_tlist</span> <span class="entity">ctxt'</span> <span class="inner_quoted">"Actual:"</span> <span class="entity">res_ts'</span>
            <span class="keyword2"><span class="keyword">in</span></span>
              <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"test_match_update"</span>
            <span class="keyword2"><span class="keyword">end</span></span>
          <span class="keyword2"><span class="keyword">end</span></span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">data1</span> <span class="main">=</span> <span class="main">[</span><span class="main">(</span><span class="inner_quoted">"B x | B y | ~A"</span><span class="main">,</span> <span class="inner_quoted">"A"</span><span class="main">,</span> <span class="main">[</span><span class="inner_quoted">"B x | B y"</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
                   <span class="main">(</span><span class="inner_quoted">"B x | B y | ~A"</span><span class="main">,</span> <span class="inner_quoted">"~B x"</span><span class="main">,</span> <span class="main">[</span><span class="inner_quoted">"B y | ~A"</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
                   <span class="main">(</span><span class="inner_quoted">"B x | B y | ~A"</span><span class="main">,</span> <span class="inner_quoted">"~B y"</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">]</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">test_updt</span> <span class="entity">ctxt'</span><span class="main">)</span> <span class="entity">data1</span>

      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">data2</span> <span class="main">=</span> <span class="main">[</span><span class="main">(</span><span class="inner_quoted">"B x | B y | ~A"</span><span class="main">,</span> <span class="inner_quoted">"~B x"</span><span class="main">,</span> <span class="main">[</span><span class="inner_quoted">"B y | ~A"</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
                   <span class="main">(</span><span class="inner_quoted">"B x | B y | ~A"</span><span class="main">,</span> <span class="inner_quoted">"D"</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
                   <span class="main">(</span><span class="inner_quoted">"B x | B y"</span><span class="main">,</span> <span class="inner_quoted">"~B x"</span><span class="main">,</span> <span class="main">[</span><span class="inner_quoted">"False"</span><span class="main">]</span><span class="main">)</span><span class="main">]</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> map <span class="main">(</span><span class="entity">test_updt</span> <span class="entity">ctxt''</span><span class="main">)</span> <span class="entity">data2</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="main">(</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="files/acdata_test.ML">
<div class="head">
<h1>File ‹acdata_test.ML›</h1>
</div>
<pre class="source"><span class="comment1">(*
  File: acdata_test.ML
  Author: Bohua Zhan

  Unit test for acdata.ML.
*)</span>

<span class="keyword2"><span class="keyword">local</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">theory</span><span class="antiquote">}</span></span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span>
<span class="keyword2"><span class="keyword">in</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_comb_ac_equiv</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">err</span> <span class="entity">n</span> <span class="main">=</span> <span class="inner_quoted">"test_comb_ac_equiv: "</span> ^ <span class="main">(</span>string_of_int <span class="entity">n</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">test</span> <span class="entity">n</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ac_info</span> <span class="main">=</span> the <span class="main">(</span><span class="entity">ACUtil.get_head_ac_info</span> <span class="entity">thy</span> <span class="entity">t1</span><span class="main">)</span>
                          <span class="keyword3"><span class="keyword">handle</span></span> Option.Option <span class="main">=&gt;</span>
                                 <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"test_comb_ac_equiv: ac_info"</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ts1</span> <span class="main">=</span> <span class="entity">ACUtil.dest_ac</span> <span class="entity">ac_info</span> <span class="entity">t1</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ts2</span> <span class="main">=</span> <span class="entity">ACUtil.dest_ac</span> <span class="entity">ac_info</span> <span class="entity">t2</span>
            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">eq</span> <span class="main">(</span><span class="entity">t1'</span><span class="main">,</span> <span class="entity">t2'</span><span class="main">)</span> <span class="main">=</span>
                Thm.assume <span class="main">(</span>Thm.global_cterm_of <span class="entity">thy</span> <span class="main">(</span>Logic.mk_equals <span class="main">(</span><span class="entity">t1'</span><span class="main">,</span> <span class="entity">t2'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eqs</span> <span class="main">=</span> map <span class="entity">eq</span> <span class="main">(</span><span class="entity">ts1</span> ~~ <span class="entity">ts2</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">th</span> <span class="main">=</span> <span class="entity">ACUtil.comb_ac_equiv</span> <span class="entity">ac_info</span> <span class="entity">eqs</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="keyword2"><span class="keyword">if</span></span> Thm.prop_of <span class="entity">th</span> aconv Logic.mk_equals <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">)</span>
            <span class="keyword2"><span class="keyword">else</span></span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="main">(</span><span class="entity">err</span> <span class="entity">n</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">test</span> <span class="inner_numeral">0</span> <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="main">(</span><span class="free">a</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">+</span> <span class="free">b</span> <span class="main">+</span> <span class="free">c</span>"</span><span class="antiquote">}</span></span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="main">(</span><span class="free">d</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">+</span> <span class="free">e</span> <span class="main">+</span> <span class="free">f</span>"</span><span class="antiquote">}</span></span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(* Generic function for testing conv with ac_info argument. *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">test_ac_conv</span> <span class="entity">ctxt</span> <span class="entity">cv</span> <span class="entity">err_str</span> <span class="main">(</span><span class="entity">str1</span><span class="main">,</span> <span class="entity">str2</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t1</span> <span class="main">=</span> Proof_Context.read_term_pattern <span class="entity">ctxt</span> <span class="entity">str1</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">ACUtil.get_head_ac_info</span> <span class="entity">thy</span> <span class="entity">t1</span> <span class="keyword2"><span class="keyword">of</span></span>
          NONE <span class="main">=&gt;</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">trace_t</span> <span class="entity">ctxt</span> <span class="inner_quoted">"t1:"</span> <span class="entity">t1</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="inner_quoted">"test_ac_conv: ac_info"</span>
          <span class="keyword2"><span class="keyword">end</span></span>
        <span class="main">|</span> SOME <span class="entity">ac_info</span> <span class="main">=&gt;</span> <span class="entity">Util.test_conv</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">cv</span> <span class="entity">ac_info</span><span class="main">)</span> <span class="entity">err_str</span> <span class="main">(</span><span class="entity">str1</span><span class="main">,</span> <span class="entity">str2</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_normalize_assoc</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_data</span> <span class="main">=</span> <span class="main">[</span>
        <span class="main">(</span><span class="inner_quoted">"(a::nat) + (b + d) + (c + e)"</span><span class="main">,</span> <span class="inner_quoted">"(a::nat) + b + d + c + e"</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"((a::nat) + 0) + (b + 0)"</span><span class="main">,</span> <span class="inner_quoted">"(a::nat) + 0 + b + 0"</span><span class="main">)</span>
      <span class="main">]</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      map <span class="main">(</span><span class="entity">test_ac_conv</span> <span class="entity">ctxt</span> <span class="entity">ACUtil.normalize_assoc</span> <span class="inner_quoted">"test_normalize_assoc"</span><span class="main">)</span> <span class="entity">test_data</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_move_outmost</span> <span class="main">=</span>
    <span class="keyword2"><span class="keyword">let</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">err_str</span> <span class="main">=</span> <span class="inner_quoted">"test_move_outmost"</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">test</span> <span class="main">(</span><span class="entity">stru</span><span class="main">,</span> <span class="main">(</span><span class="entity">str1</span><span class="main">,</span> <span class="entity">str2</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">u</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Proof_Context.read_term_pattern <span class="entity">ctxt</span> <span class="entity">str1</span><span class="main">,</span>
                           Proof_Context.read_term_pattern <span class="entity">ctxt</span> <span class="entity">stru</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ac_info</span> <span class="main">=</span>
                the <span class="main">(</span><span class="entity">ACUtil.get_head_ac_info</span> <span class="entity">thy</span> <span class="entity">t1</span><span class="main">)</span>
                <span class="keyword3"><span class="keyword">handle</span></span> Option.Option <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> Fail <span class="main">(</span><span class="entity">err_str</span> ^ <span class="inner_quoted">": ac_info"</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="entity">Util.test_conv</span> <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">ACUtil.move_outmost</span> <span class="entity">ac_info</span> <span class="entity">u</span><span class="main">)</span> <span class="entity">err_str</span> <span class="main">(</span><span class="entity">str1</span><span class="main">,</span> <span class="entity">str2</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_data</span> <span class="main">=</span> <span class="main">[</span>
        <span class="main">(</span><span class="inner_quoted">"a::nat"</span><span class="main">,</span> <span class="main">(</span><span class="inner_quoted">"(a::nat) + b"</span><span class="main">,</span> <span class="inner_quoted">"(b::nat) + a"</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"a::nat"</span><span class="main">,</span> <span class="main">(</span><span class="inner_quoted">"(a::nat) + b + c"</span><span class="main">,</span> <span class="inner_quoted">"(b::nat) + c + a"</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"a::nat"</span><span class="main">,</span> <span class="main">(</span><span class="inner_quoted">"(b::nat) + a"</span><span class="main">,</span> <span class="inner_quoted">"(b::nat) + a"</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
        <span class="main">(</span><span class="inner_quoted">"a::nat"</span><span class="main">,</span> <span class="main">(</span><span class="inner_quoted">"(b::nat) + a + c"</span><span class="main">,</span> <span class="inner_quoted">"(b::nat) + c + a"</span><span class="main">)</span><span class="main">)</span>
      <span class="main">]</span>
    <span class="keyword2"><span class="keyword">in</span></span>
      map <span class="entity">test</span> <span class="entity">test_data</span>
    <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span><span class="main">;</span>  <span class="comment1">(* local *)</span>
</pre>
</div><div id="Pelletier">
<div class="head">
<h1>Theory Pelletier</h1>
</div>
<pre class="source"><span class="comment1">(*
  File: Pelletier.thy
  Author: Bohua Zhan

  Pelletier's problems. From the paper "Seventy-five problems for testing
  automatic theorem provers" by Francis Jeffry Pelletier.
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Pelletier's problems›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Pelletier
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="Logic_Thms.html">Logic_Thms</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">theorem</span></span> p1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">⟶</span> <span class="free">q</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">¬</span><span class="free">q</span> <span class="main">⟶</span> <span class="main">¬</span><span class="free">p</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto2</span>

<span class="keyword1"><span class="command">theorem</span></span> p2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">¬</span><span class="main">¬</span><span class="free">p</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto2</span>

<span class="keyword1"><span class="command">theorem</span></span> p3<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="main">(</span><span class="free">p</span> <span class="main">⟶</span> <span class="free">q</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">q</span> <span class="main">⟶</span> <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto2</span>

<span class="keyword1"><span class="command">theorem</span></span> p4<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">¬</span><span class="free">p</span> <span class="main">⟶</span> <span class="free">q</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">¬</span><span class="free">q</span> <span class="main">⟶</span> <span class="free">p</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto2</span>

<span class="keyword1"><span class="command">theorem</span></span> p5<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">∨</span> <span class="free">q</span><span class="main">)</span> <span class="main">⟶</span> <span class="main">(</span><span class="free">p</span> <span class="main">∨</span> <span class="free">r</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">p</span> <span class="main">∨</span> <span class="main">(</span><span class="free">q</span> <span class="main">⟶</span> <span class="free">r</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto2</span>

<span class="keyword1"><span class="command">theorem</span></span> p6<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∨</span> <span class="main">¬</span><span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto2</span>

<span class="keyword1"><span class="command">theorem</span></span> p7<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∨</span> <span class="main">¬</span><span class="main">¬</span><span class="main">¬</span><span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto2</span>

<span class="keyword1"><span class="command">theorem</span></span> p8<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">p</span> <span class="main">⟶</span> <span class="free">q</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">p</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto2</span>

<span class="keyword1"><span class="command">theorem</span></span> p9<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">∨</span> <span class="free">q</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">¬</span><span class="free">p</span> <span class="main">∨</span> <span class="free">q</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="free">p</span> <span class="main">∨</span> <span class="main">¬</span><span class="free">q</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">¬</span><span class="main">(</span><span class="main">¬</span><span class="free">p</span> <span class="main">∨</span> <span class="main">¬</span><span class="free">q</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto2</span>

<span class="keyword1"><span class="command">theorem</span></span> p10<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">q</span> <span class="main">⟶</span> <span class="free">r</span> <span class="main">⟹</span> <span class="free">r</span> <span class="main">⟶</span> <span class="free">p</span> <span class="main">∧</span> <span class="free">q</span> <span class="main">⟹</span> <span class="free">p</span> <span class="main">⟶</span> <span class="free">q</span> <span class="main">∨</span> <span class="free">r</span> <span class="main">⟹</span> <span class="free">p</span> <span class="main">⟷</span> <span class="free">q</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto2</span>

<span class="keyword1"><span class="command">theorem</span></span> p11<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">⟷</span> <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto2</span>

<span class="keyword1"><span class="command">theorem</span></span> p12<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">p</span> <span class="main">⟷</span> <span class="free">q</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">r</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">p</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">q</span> <span class="main">⟷</span> <span class="free">r</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">@proof</span></span>
  <span class="keyword1"><span class="command">@case</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span>"</span></span>
  <span class="keyword1"><span class="command">@case</span></span> <span class="quoted"><span class="quoted">"<span class="free">q</span>"</span></span>
<span class="keyword1"><span class="command">@qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> p13<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">∨</span> <span class="main">(</span><span class="free">q</span> <span class="main">∧</span> <span class="free">r</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">p</span> <span class="main">∨</span> <span class="free">q</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="free">p</span> <span class="main">∨</span> <span class="free">r</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto2</span>

<span class="keyword1"><span class="command">theorem</span></span> p14<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">⟷</span> <span class="free">q</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">(</span><span class="free">q</span> <span class="main">∨</span> <span class="main">¬</span><span class="free">p</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">¬</span><span class="free">q</span> <span class="main">∨</span> <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto2</span>

<span class="keyword1"><span class="command">theorem</span></span> p15<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">⟶</span> <span class="free">q</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">¬</span><span class="free">p</span> <span class="main">∨</span> <span class="free">q</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto2</span>

<span class="keyword1"><span class="command">theorem</span></span> p16<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">⟶</span> <span class="free">q</span><span class="main">)</span> <span class="main">∨</span> <span class="main">(</span><span class="free">q</span> <span class="main">⟶</span> <span class="free">p</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto2</span>

<span class="keyword1"><span class="command">theorem</span></span> p17<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">∧</span> <span class="main">(</span><span class="free">q</span> <span class="main">⟶</span> <span class="free">r</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">s</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">¬</span><span class="free">p</span> <span class="main">∨</span> <span class="free">q</span> <span class="main">∨</span> <span class="free">s</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">¬</span><span class="free">p</span> <span class="main">∨</span> <span class="main">¬</span><span class="free">r</span> <span class="main">∨</span> <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto2</span>

<span class="keyword1"><span class="command">theorem</span></span> p18<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">y</span><span class="main">::</span><span class="tfree">'a</span><span class="main">.</span> <span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">F</span><span class="main">(</span><span class="bound">y</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">F</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">@proof</span></span>
  <span class="keyword1"><span class="command">@case</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">F</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span>"</span></span> <span class="main">@with</span>
    <span class="keyword1"><span class="command">@obtain</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span><span class="main">::</span><span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">=</span> <span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">@have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">F</span><span class="main">(</span><span class="free">y</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">F</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">@end</span></span>
  <span class="keyword1"><span class="command">@obtain</span></span> <span class="quoted"><span class="free">y</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="free">F</span><span class="main">(</span><span class="free">y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">@have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">F</span><span class="main">(</span><span class="free">y</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">F</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">@qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> p19<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">x</span><span class="main">::</span><span class="tfree">'a</span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span> <span class="bound">z</span><span class="main">.</span> <span class="main">(</span><span class="free">P</span><span class="main">(</span><span class="bound">y</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">Q</span><span class="main">(</span><span class="bound">z</span><span class="main">)</span><span class="main">)</span> <span class="main">⟶</span> <span class="main">(</span><span class="free">P</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">Q</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">@proof</span></span>
  <span class="keyword1"><span class="command">@case</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">Q</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span>"</span></span> <span class="main">@with</span>
    <span class="keyword1"><span class="command">@obtain</span></span> <span class="quoted"><span class="free">x</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span><span class="main">(</span><span class="free">x</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">Q</span><span class="main">(</span><span class="free">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">@have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">y</span> <span class="bound">z</span><span class="main">.</span> <span class="main">(</span><span class="free">P</span><span class="main">(</span><span class="bound">y</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">Q</span><span class="main">(</span><span class="bound">z</span><span class="main">)</span><span class="main">)</span> <span class="main">⟶</span> <span class="main">(</span><span class="free">P</span><span class="main">(</span><span class="free">x</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">Q</span><span class="main">(</span><span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">@end</span></span>
  <span class="keyword1"><span class="command">@obtain</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span><span class="main">::</span><span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">@have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">y</span> <span class="bound">z</span><span class="main">.</span> <span class="main">(</span><span class="free">P</span><span class="main">(</span><span class="bound">y</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">Q</span><span class="main">(</span><span class="bound">z</span><span class="main">)</span><span class="main">)</span> <span class="main">⟶</span> <span class="main">(</span><span class="free">P</span><span class="main">(</span><span class="free">x</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">Q</span><span class="main">(</span><span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">@qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> p20<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="main">∃</span><span class="bound">z</span><span class="main">.</span> <span class="main">∀</span><span class="bound">w</span><span class="main">.</span> <span class="free">P</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">∧</span> <span class="free">Q</span><span class="main">(</span><span class="bound">y</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">R</span><span class="main">(</span><span class="bound">z</span><span class="main">)</span> <span class="main">∧</span> <span class="free">S</span><span class="main">(</span><span class="bound">w</span><span class="main">)</span> <span class="main">⟹</span>
  <span class="main">∃</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">P</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">∧</span> <span class="free">Q</span><span class="main">(</span><span class="bound">y</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">z</span><span class="main">.</span> <span class="free">R</span><span class="main">(</span><span class="bound">z</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">@proof</span></span>
  <span class="keyword1"><span class="command">@obtain</span></span> <span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="free">y</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span><span class="main">(</span><span class="free">x</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">Q</span><span class="main">(</span><span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">@obtain</span></span> <span class="quoted"><span class="free">z</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">w</span><span class="main">.</span> <span class="free">P</span><span class="main">(</span><span class="free">x</span><span class="main">)</span> <span class="main">∧</span> <span class="free">Q</span><span class="main">(</span><span class="free">y</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">R</span><span class="main">(</span><span class="free">z</span><span class="main">)</span> <span class="main">∧</span> <span class="free">S</span><span class="main">(</span><span class="bound">w</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">@qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> p21<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="free">p</span> <span class="main">⟶</span> <span class="free">F</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="free">F</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">p</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="free">p</span> <span class="main">⟷</span> <span class="free">F</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">@proof</span></span>
  <span class="keyword1"><span class="command">@case</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span>"</span></span> <span class="main">@with</span> <span class="keyword1"><span class="command">@obtain</span></span> <span class="quoted"><span class="free">x</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">F</span><span class="main">(</span><span class="free">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">@have</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">⟷</span> <span class="free">F</span><span class="main">(</span><span class="free">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">@end</span></span>
  <span class="keyword1"><span class="command">@case</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="free">p</span>"</span></span> <span class="main">@with</span> <span class="keyword1"><span class="command">@obtain</span></span> <span class="quoted"><span class="free">x</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="free">F</span><span class="main">(</span><span class="free">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">@have</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">⟷</span> <span class="free">F</span><span class="main">(</span><span class="free">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">@end</span></span>
<span class="keyword1"><span class="command">@qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> p22<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">::</span><span class="tfree">'a</span><span class="main">.</span> <span class="free">p</span> <span class="main">⟷</span> <span class="free">F</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">p</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">F</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">@proof</span></span>
  <span class="keyword1"><span class="command">@case</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">@obtain</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span><span class="main">::</span><span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">@qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> p23<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">::</span><span class="tfree">'a</span><span class="main">.</span> <span class="free">p</span> <span class="main">∨</span> <span class="free">F</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">p</span> <span class="main">∨</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">F</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto2</span>

<span class="keyword1"><span class="command">theorem</span></span> p29<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="free">F</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="free">G</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">⟹</span>
  <span class="main">(</span><span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">F</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">H</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">G</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">J</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span>
  <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">F</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">∧</span> <span class="free">G</span><span class="main">(</span><span class="bound">y</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">H</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">∧</span> <span class="free">J</span><span class="main">(</span><span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">@proof</span></span>
  <span class="keyword1"><span class="command">@obtain</span></span> <span class="quoted"><span class="free">a</span></span> <span class="quoted"><span class="free">b</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">F</span><span class="main">(</span><span class="free">a</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">G</span><span class="main">(</span><span class="free">b</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">@case</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">F</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">∧</span> <span class="free">G</span><span class="main">(</span><span class="bound">y</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">H</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">∧</span> <span class="free">J</span><span class="main">(</span><span class="bound">y</span><span class="main">)</span>"</span></span> <span class="main">@with</span>
    <span class="keyword1"><span class="command">@have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">F</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">H</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span>"</span></span> <span class="main">@with</span> <span class="keyword1"><span class="command">@have</span></span> <span class="quoted"><span class="quoted">"<span class="free">F</span><span class="main">(</span><span class="free">x</span><span class="main">)</span> <span class="main">∧</span> <span class="free">G</span><span class="main">(</span><span class="free">b</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">@end</span></span>
    <span class="keyword1"><span class="command">@have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">y</span><span class="main">.</span> <span class="free">G</span><span class="main">(</span><span class="bound">y</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">J</span><span class="main">(</span><span class="bound">y</span><span class="main">)</span>"</span></span> <span class="main">@with</span> <span class="keyword1"><span class="command">@have</span></span> <span class="quoted"><span class="quoted">"<span class="free">F</span><span class="main">(</span><span class="free">a</span><span class="main">)</span> <span class="main">∧</span> <span class="free">G</span><span class="main">(</span><span class="free">y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">@end</span></span>
  <span class="keyword1"><span class="command">@end</span></span>
<span class="keyword1"><span class="command">@qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> p30<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">F</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">∨</span> <span class="free">G</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">⟶</span> <span class="main">¬</span><span class="free">H</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">⟹</span>
  <span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="free">G</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">⟶</span> <span class="main">¬</span><span class="free">I</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">F</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">∧</span> <span class="free">H</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">I</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">@proof</span></span>
  <span class="keyword1"><span class="command">@have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">I</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span>"</span></span> <span class="main">@with</span> <span class="keyword1"><span class="command">@case</span></span> <span class="quoted"><span class="quoted">"<span class="free">F</span><span class="main">(</span><span class="free">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">@end</span></span>
<span class="keyword1"><span class="command">@qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> p31<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="main">(</span><span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="free">F</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="free">G</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">∨</span> <span class="free">H</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="free">I</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">∧</span> <span class="free">F</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="main">¬</span><span class="free">H</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">J</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">⟹</span>
  <span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="free">I</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">∧</span> <span class="free">J</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto2</span>

<span class="keyword1"><span class="command">theorem</span></span> p32<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="free">F</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="free">G</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">∨</span> <span class="free">H</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">I</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">I</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">∧</span> <span class="free">H</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">J</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">⟹</span>
  <span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">K</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">H</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">F</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">∧</span> <span class="free">K</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">J</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto2</span>

<span class="keyword1"><span class="command">theorem</span></span> p33<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">p</span><span class="main">(</span><span class="free">a</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="free">p</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">p</span><span class="main">(</span><span class="free">b</span><span class="main">)</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">p</span><span class="main">(</span><span class="free">c</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span>
  <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="main">¬</span><span class="free">p</span><span class="main">(</span><span class="free">a</span><span class="main">)</span> <span class="main">∨</span> <span class="free">p</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">∨</span> <span class="free">p</span><span class="main">(</span><span class="free">c</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">¬</span><span class="free">p</span><span class="main">(</span><span class="free">a</span><span class="main">)</span> <span class="main">∨</span> <span class="main">¬</span><span class="free">p</span><span class="main">(</span><span class="free">b</span><span class="main">)</span> <span class="main">∨</span> <span class="free">p</span><span class="main">(</span><span class="free">c</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto2</span>

<span class="keyword1"><span class="command">theorem</span></span> p35<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="main">(</span><span class="bound">x</span><span class="main">::</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">(</span><span class="bound">y</span><span class="main">::</span><span class="tfree">'b</span><span class="main">)</span><span class="main">.</span> <span class="free">P</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">P</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto2</span>

<span class="keyword1"><span class="command">theorem</span></span> p39<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="main">(</span><span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span><span class="main">.</span> <span class="free">F</span><span class="main">(</span><span class="bound">y</span><span class="main">,</span><span class="bound">x</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">¬</span><span class="free">F</span><span class="main">(</span><span class="bound">y</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">@proof</span></span>
  <span class="keyword1"><span class="command">@contradiction</span></span>
  <span class="keyword1"><span class="command">@obtain</span></span> <span class="quoted"><span class="free">x</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">y</span><span class="main">.</span> <span class="free">F</span><span class="main">(</span><span class="bound">y</span><span class="main">,</span><span class="free">x</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">¬</span><span class="free">F</span><span class="main">(</span><span class="bound">y</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">@case</span></span> <span class="quoted"><span class="quoted">"<span class="free">F</span><span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">@qed</span></span>

<span class="comment1">(* Note there is a typo in the original text. *)</span>
<span class="keyword1"><span class="command">theorem</span></span> p40<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">y</span><span class="main">.</span> <span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">F</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">F</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">x</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">¬</span><span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="main">∃</span><span class="bound">y</span><span class="main">.</span> <span class="main">∀</span><span class="bound">z</span><span class="main">.</span> <span class="free">F</span><span class="main">(</span><span class="bound">z</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">¬</span><span class="free">F</span><span class="main">(</span><span class="bound">z</span><span class="main">,</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">@proof</span></span>
  <span class="keyword1"><span class="command">@obtain</span></span> <span class="quoted"><span class="free">A</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">F</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="free">A</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">F</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">@have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="main">(</span><span class="main">∃</span><span class="bound">y</span><span class="main">.</span> <span class="main">∀</span><span class="bound">z</span><span class="main">.</span> <span class="free">F</span><span class="main">(</span><span class="bound">z</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">¬</span><span class="free">F</span><span class="main">(</span><span class="bound">z</span><span class="main">,</span><span class="free">A</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">@with</span>
    <span class="keyword1"><span class="command">@have</span></span> <span class="main">(</span><span class="main">@rule</span><span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">y</span><span class="main">.</span> <span class="main">¬</span><span class="main">(</span><span class="main">∀</span><span class="bound">z</span><span class="main">.</span> <span class="free">F</span><span class="main">(</span><span class="bound">z</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">¬</span><span class="free">F</span><span class="main">(</span><span class="bound">z</span><span class="main">,</span><span class="free">A</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">@with</span>
      <span class="keyword1"><span class="command">@have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="main">(</span><span class="free">F</span><span class="main">(</span><span class="free">y</span><span class="main">,</span><span class="free">y</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">¬</span><span class="free">F</span><span class="main">(</span><span class="free">y</span><span class="main">,</span><span class="free">A</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">@with</span> <span class="keyword1"><span class="command">@case</span></span> <span class="quoted"><span class="quoted">"<span class="free">F</span><span class="main">(</span><span class="free">y</span><span class="main">,</span><span class="free">y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">@end</span></span>
    <span class="keyword1"><span class="command">@end</span></span>
  <span class="keyword1"><span class="command">@end</span></span>
<span class="keyword1"><span class="command">@qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> p42<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="main">(</span><span class="main">∃</span><span class="bound">y</span><span class="main">.</span> <span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">F</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">¬</span><span class="main">(</span><span class="main">∃</span><span class="bound">z</span><span class="main">.</span> <span class="free">F</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">z</span><span class="main">)</span> <span class="main">∧</span> <span class="free">F</span><span class="main">(</span><span class="bound">z</span><span class="main">,</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">@proof</span></span>
  <span class="keyword1"><span class="command">@contradiction</span></span>
  <span class="keyword1"><span class="command">@obtain</span></span> <span class="quoted"><span class="free">y</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">F</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="free">y</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">¬</span><span class="main">(</span><span class="main">∃</span><span class="bound">z</span><span class="main">.</span> <span class="free">F</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">z</span><span class="main">)</span> <span class="main">∧</span> <span class="free">F</span><span class="main">(</span><span class="bound">z</span><span class="main">,</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">@case</span></span> <span class="quoted"><span class="quoted">"<span class="free">F</span><span class="main">(</span><span class="free">y</span><span class="main">,</span><span class="free">y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">@qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> p43<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">Q</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">z</span><span class="main">.</span> <span class="free">F</span><span class="main">(</span><span class="bound">z</span><span class="main">,</span><span class="bound">x</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">F</span><span class="main">(</span><span class="bound">z</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span>
  <span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">Q</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">Q</span><span class="main">(</span><span class="bound">y</span><span class="main">,</span><span class="bound">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto2</span>

<span class="keyword1"><span class="command">theorem</span></span> p47<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">P1</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">P0</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="free">P1</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span>
   <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">P2</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">P0</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="free">P2</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span>
   <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">P3</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">P0</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="free">P3</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span>
   <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">P4</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">P0</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="free">P4</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span>
   <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">P5</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">P0</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="free">P5</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span>
   <span class="main">(</span><span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="free">Q1</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">Q1</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">Q0</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span>
   <span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">P0</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">⟶</span> <span class="main">(</span><span class="main">(</span><span class="main">∀</span><span class="bound">y</span><span class="main">.</span> <span class="free">Q0</span><span class="main">(</span><span class="bound">y</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">R</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="main">∨</span>
                   <span class="main">(</span><span class="main">∀</span><span class="bound">y</span><span class="main">.</span> <span class="free">P0</span><span class="main">(</span><span class="bound">y</span><span class="main">)</span> <span class="main">∧</span> <span class="free">S</span><span class="main">(</span><span class="bound">y</span><span class="main">,</span><span class="bound">x</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∃</span><span class="bound">z</span><span class="main">.</span> <span class="free">Q0</span><span class="main">(</span><span class="bound">z</span><span class="main">)</span> <span class="main">∧</span> <span class="free">R</span><span class="main">(</span><span class="bound">y</span><span class="main">,</span><span class="bound">z</span><span class="main">)</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">R</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span>
   <span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">P3</span><span class="main">(</span><span class="bound">y</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="free">P5</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">∨</span> <span class="free">P4</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">S</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span> <span class="main">⟹</span>
   <span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">P3</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">∧</span> <span class="free">P2</span><span class="main">(</span><span class="bound">y</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">S</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span> <span class="main">⟹</span>
   <span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">P2</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">∧</span> <span class="free">P1</span><span class="main">(</span><span class="bound">y</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">S</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span> <span class="main">⟹</span>
   <span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">P1</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="free">P2</span><span class="main">(</span><span class="bound">y</span><span class="main">)</span> <span class="main">∨</span> <span class="free">Q1</span><span class="main">(</span><span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="main">⟶</span> <span class="main">¬</span><span class="free">R</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span> <span class="main">⟹</span>
   <span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">P3</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">∧</span> <span class="free">P4</span><span class="main">(</span><span class="bound">y</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">R</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span> <span class="main">⟹</span>
   <span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">P3</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">∧</span> <span class="free">P5</span><span class="main">(</span><span class="bound">y</span><span class="main">)</span> <span class="main">⟶</span> <span class="main">¬</span><span class="free">R</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span> <span class="main">⟹</span>
   <span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">P4</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">∨</span> <span class="free">P5</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∃</span><span class="bound">y</span><span class="main">.</span> <span class="free">Q0</span><span class="main">(</span><span class="bound">y</span><span class="main">)</span> <span class="main">∧</span> <span class="free">R</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span>
   <span class="main">∃</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">P0</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">∧</span> <span class="free">P0</span><span class="main">(</span><span class="bound">y</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∃</span><span class="bound">z</span><span class="main">.</span> <span class="free">Q1</span><span class="main">(</span><span class="bound">z</span><span class="main">)</span> <span class="main">∧</span> <span class="free">R</span><span class="main">(</span><span class="bound">y</span><span class="main">,</span><span class="bound">z</span><span class="main">)</span> <span class="main">∧</span> <span class="free">R</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">@proof</span></span>
  <span class="keyword1"><span class="command">@obtain</span></span> <span class="quoted"><span class="free">x1</span></span> <span class="quoted"><span class="free">x2</span></span> <span class="quoted"><span class="free">x3</span></span> <span class="quoted"><span class="free">x4</span></span> <span class="quoted"><span class="free">x5</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">P1</span><span class="main">(</span><span class="free">x1</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">P2</span><span class="main">(</span><span class="free">x2</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">P3</span><span class="main">(</span><span class="free">x3</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">P4</span><span class="main">(</span><span class="free">x4</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">P5</span><span class="main">(</span><span class="free">x5</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">@have</span></span> <span class="quoted"><span class="quoted">"<span class="free">S</span><span class="main">(</span><span class="free">x3</span><span class="main">,</span><span class="free">x2</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">@have</span></span> <span class="quoted"><span class="quoted">"<span class="free">S</span><span class="main">(</span><span class="free">x2</span><span class="main">,</span><span class="free">x1</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">@have</span></span> <span class="quoted"><span class="quoted">"<span class="free">R</span><span class="main">(</span><span class="free">x3</span><span class="main">,</span><span class="free">x4</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">@have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="free">R</span><span class="main">(</span><span class="free">x3</span><span class="main">,</span><span class="free">x5</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">@qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> p48<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">=</span> <span class="free">b</span> <span class="main">∨</span> <span class="free">c</span> <span class="main">=</span> <span class="free">d</span> <span class="main">⟹</span> <span class="free">a</span> <span class="main">=</span> <span class="free">c</span> <span class="main">∨</span> <span class="free">b</span> <span class="main">=</span> <span class="free">d</span> <span class="main">⟹</span> <span class="free">a</span> <span class="main">=</span> <span class="free">d</span> <span class="main">∨</span> <span class="free">b</span> <span class="main">=</span> <span class="free">c</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto2</span>

<span class="keyword1"><span class="command">theorem</span></span> p49<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="main">∀</span><span class="main">(</span><span class="bound">z</span><span class="main">::</span><span class="tfree">'a</span><span class="main">)</span><span class="main">.</span> <span class="bound">z</span> <span class="main">=</span> <span class="bound">x</span> <span class="main">∨</span> <span class="bound">z</span> <span class="main">=</span> <span class="bound">y</span> <span class="main">⟹</span> <span class="free">P</span><span class="main">(</span><span class="free">a</span><span class="main">)</span> <span class="main">∧</span> <span class="free">P</span><span class="main">(</span><span class="free">b</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">a</span><span class="main">::</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">≠</span> <span class="free">b</span> <span class="main">⟹</span> <span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">@proof</span></span>
  <span class="keyword1"><span class="command">@obtain</span></span> <span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="free">y</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="main">(</span><span class="bound">z</span><span class="main">::</span><span class="tfree">'a</span><span class="main">)</span><span class="main">.</span> <span class="bound">z</span> <span class="main">=</span> <span class="free">x</span> <span class="main">∨</span> <span class="bound">z</span> <span class="main">=</span> <span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">@have</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="free">a</span> <span class="main">∨</span> <span class="free">x</span> <span class="main">=</span> <span class="free">b</span>"</span></span>
  <span class="keyword1"><span class="command">@have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">c</span><span class="main">.</span> <span class="free">P</span><span class="main">(</span><span class="bound">c</span><span class="main">)</span>"</span></span> <span class="main">@with</span> <span class="keyword1"><span class="command">@have</span></span> <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">=</span> <span class="free">a</span> <span class="main">∨</span> <span class="free">c</span> <span class="main">=</span> <span class="free">b</span>"</span></span> <span class="keyword1"><span class="command">@end</span></span>
<span class="keyword1"><span class="command">@qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> p50<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">F</span><span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="bound">x</span><span class="main">)</span> <span class="main">∨</span> <span class="main">(</span><span class="main">∀</span><span class="bound">y</span><span class="main">.</span> <span class="free">F</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span><span class="main">.</span> <span class="free">F</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">@proof</span></span>
  <span class="keyword1"><span class="command">@case</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">y</span><span class="main">.</span> <span class="free">F</span><span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">@obtain</span></span> <span class="quoted"><span class="free">y</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="free">F</span><span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">@have</span></span> <span class="main">(</span><span class="main">@rule</span><span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">z</span><span class="main">.</span> <span class="free">F</span><span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">y</span><span class="main">)</span> <span class="main">∨</span> <span class="free">F</span><span class="main">(</span><span class="free">y</span><span class="main">,</span><span class="bound">z</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">@qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> p51<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">z</span> <span class="bound">w</span><span class="main">.</span> <span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">F</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span> <span class="main">⟷</span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">z</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">=</span> <span class="bound">w</span> <span class="main">⟹</span>
  <span class="main">∃</span><span class="bound">z</span><span class="main">.</span> <span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="main">∃</span><span class="bound">w</span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span><span class="main">.</span> <span class="free">F</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span> <span class="main">⟷</span> <span class="bound">y</span> <span class="main">=</span> <span class="bound">w</span><span class="main">)</span> <span class="main">⟷</span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">z</span>"</span></span>
<span class="keyword1"><span class="command">@proof</span></span>
  <span class="keyword1"><span class="command">@obtain</span></span> <span class="quoted"><span class="free">z</span></span> <span class="quoted"><span class="free">w</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">F</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span> <span class="main">⟷</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">z</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">=</span> <span class="free">w</span>"</span></span>
  <span class="keyword1"><span class="command">@have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="main">∃</span><span class="bound">w</span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span><span class="main">.</span> <span class="free">F</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span> <span class="main">⟷</span> <span class="bound">y</span> <span class="main">=</span> <span class="bound">w</span><span class="main">)</span> <span class="main">⟷</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">z</span>"</span></span> <span class="main">@with</span>
    <span class="keyword1"><span class="command">@case</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="free">z</span>"</span></span> <span class="main">@with</span> <span class="keyword1"><span class="command">@have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">y</span><span class="main">.</span> <span class="free">F</span><span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span> <span class="main">⟷</span> <span class="bound">y</span> <span class="main">=</span> <span class="free">w</span>"</span></span> <span class="keyword1"><span class="command">@end</span></span>
  <span class="keyword1"><span class="command">@end</span></span>
<span class="keyword1"><span class="command">@qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> p52<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">z</span> <span class="bound">w</span><span class="main">.</span> <span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">F</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span> <span class="main">⟷</span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">z</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">=</span> <span class="bound">w</span> <span class="main">⟹</span>
  <span class="main">∃</span><span class="bound">w</span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span><span class="main">.</span> <span class="main">(</span><span class="main">∃</span><span class="bound">z</span><span class="main">.</span> <span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">F</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span> <span class="main">⟷</span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">z</span><span class="main">)</span> <span class="main">⟷</span> <span class="bound">y</span> <span class="main">=</span> <span class="bound">w</span>"</span></span>
<span class="keyword1"><span class="command">@proof</span></span>
  <span class="keyword1"><span class="command">@obtain</span></span> <span class="quoted"><span class="free">z</span></span> <span class="quoted"><span class="free">w</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">F</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span> <span class="main">⟷</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">z</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">=</span> <span class="free">w</span>"</span></span>
  <span class="keyword1"><span class="command">@have</span></span><span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">y</span><span class="main">.</span> <span class="main">(</span><span class="main">∃</span><span class="bound">z</span><span class="main">.</span> <span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">F</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span> <span class="main">⟷</span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">z</span><span class="main">)</span> <span class="main">⟷</span> <span class="bound">y</span> <span class="main">=</span> <span class="free">w</span>"</span></span> <span class="main">@with</span>
    <span class="keyword1"><span class="command">@case</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">=</span> <span class="free">w</span>"</span></span> <span class="main">@with</span> <span class="keyword1"><span class="command">@have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">F</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="free">y</span><span class="main">)</span> <span class="main">⟷</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">z</span>"</span></span> <span class="keyword1"><span class="command">@end</span></span>
  <span class="keyword1"><span class="command">@end</span></span>
<span class="keyword1"><span class="command">@qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> p55<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="free">L</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">∧</span> <span class="free">K</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="free">a</span><span class="main">)</span> <span class="main">⟹</span>
   <span class="free">L</span><span class="main">(</span><span class="free">a</span><span class="main">)</span> <span class="main">∧</span> <span class="free">L</span><span class="main">(</span><span class="free">b</span><span class="main">)</span> <span class="main">∧</span> <span class="free">L</span><span class="main">(</span><span class="free">c</span><span class="main">)</span> <span class="main">⟹</span>
   <span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">L</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">⟶</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">a</span> <span class="main">∨</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">b</span> <span class="main">∨</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">c</span> <span class="main">⟹</span>
   <span class="main">∀</span><span class="bound">y</span> <span class="bound">x</span><span class="main">.</span> <span class="free">K</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">H</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span> <span class="main">⟹</span>
   <span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">K</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span> <span class="main">⟶</span> <span class="main">¬</span><span class="free">R</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span> <span class="main">⟹</span>
   <span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">H</span><span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="bound">x</span><span class="main">)</span> <span class="main">⟶</span> <span class="main">¬</span><span class="free">H</span><span class="main">(</span><span class="free">c</span><span class="main">,</span><span class="bound">x</span><span class="main">)</span> <span class="main">⟹</span>
   <span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≠</span> <span class="free">b</span> <span class="main">⟶</span> <span class="free">H</span><span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="bound">x</span><span class="main">)</span> <span class="main">⟹</span>
   <span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="main">¬</span><span class="free">R</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="free">a</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">H</span><span class="main">(</span><span class="free">b</span><span class="main">,</span><span class="bound">x</span><span class="main">)</span> <span class="main">⟹</span>
   <span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">H</span><span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="bound">x</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">H</span><span class="main">(</span><span class="free">b</span><span class="main">,</span><span class="bound">x</span><span class="main">)</span> <span class="main">⟹</span>  <span class="comment1">―‹typo in text›</span>
   <span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="main">∃</span><span class="bound">y</span><span class="main">.</span> <span class="main">¬</span><span class="free">H</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span> <span class="main">⟹</span>
   <span class="free">a</span> <span class="main">≠</span> <span class="free">b</span> <span class="main">⟹</span>
   <span class="free">K</span><span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">a</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">@proof</span></span>
  <span class="keyword1"><span class="command">@case</span></span> <span class="quoted"><span class="quoted">"<span class="free">K</span><span class="main">(</span><span class="free">b</span><span class="main">,</span><span class="free">a</span><span class="main">)</span>"</span></span> <span class="main">@with</span> <span class="keyword1"><span class="command">@have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">H</span><span class="main">(</span><span class="free">b</span><span class="main">,</span><span class="bound">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">@end</span></span>
<span class="keyword1"><span class="command">@qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> p56<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="main">∃</span><span class="bound">y</span><span class="main">.</span> <span class="free">F</span><span class="main">(</span><span class="bound">y</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">f</span><span class="main">(</span><span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">F</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">F</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">F</span><span class="main">(</span><span class="free">f</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto2</span>

<span class="keyword1"><span class="command">theorem</span></span> p57<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">F</span><span class="main">(</span><span class="free">f</span><span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">b</span><span class="main">)</span><span class="main">,</span><span class="free">f</span><span class="main">(</span><span class="free">b</span><span class="main">,</span><span class="free">c</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">F</span><span class="main">(</span><span class="free">f</span><span class="main">(</span><span class="free">b</span><span class="main">,</span><span class="free">c</span><span class="main">)</span><span class="main">,</span><span class="free">f</span><span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">c</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span>
  <span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span> <span class="bound">z</span><span class="main">.</span> <span class="free">F</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span> <span class="main">∧</span> <span class="free">F</span><span class="main">(</span><span class="bound">y</span><span class="main">,</span><span class="bound">z</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">F</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">z</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">F</span><span class="main">(</span><span class="free">f</span><span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">b</span><span class="main">)</span><span class="main">,</span><span class="free">f</span><span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">c</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto2</span>

<span class="keyword1"><span class="command">theorem</span></span> p58<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">f</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">g</span><span class="main">(</span><span class="bound">y</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">f</span><span class="main">(</span><span class="free">f</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span><span class="main">(</span><span class="free">g</span><span class="main">(</span><span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">@proof</span></span>
  <span class="keyword1"><span class="command">@have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">f</span><span class="main">(</span><span class="free">f</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span><span class="main">(</span><span class="free">g</span><span class="main">(</span><span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">@with</span>
    <span class="keyword1"><span class="command">@have</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span><span class="main">(</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">g</span><span class="main">(</span><span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">@end</span></span>
<span class="keyword1"><span class="command">@qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> p59<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">::</span><span class="tfree">'a</span><span class="main">.</span> <span class="free">F</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">¬</span><span class="free">F</span><span class="main">(</span><span class="free">f</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="free">F</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span> <span class="main">∧</span> <span class="main">¬</span><span class="free">F</span><span class="main">(</span><span class="free">f</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">@proof</span></span>
  <span class="keyword1"><span class="command">@obtain</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span><span class="main">::</span><span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">@case</span></span> <span class="quoted"><span class="quoted">"<span class="free">F</span><span class="main">(</span><span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">@qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> p60<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">F</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="free">f</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">y</span><span class="main">.</span> <span class="main">(</span><span class="main">∀</span><span class="bound">z</span><span class="main">.</span> <span class="free">F</span><span class="main">(</span><span class="bound">z</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">F</span><span class="main">(</span><span class="bound">z</span><span class="main">,</span><span class="free">f</span><span class="main">(</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> <span class="free">F</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto2</span>

<span class="keyword1"><span class="command">theorem</span></span> p61<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span> <span class="bound">z</span><span class="main">.</span> <span class="free">f</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="free">f</span><span class="main">(</span><span class="bound">y</span><span class="main">,</span><span class="bound">z</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span><span class="main">(</span><span class="free">f</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span><span class="main">,</span><span class="bound">z</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span> <span class="bound">z</span> <span class="bound">w</span><span class="main">.</span> <span class="free">f</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="free">f</span><span class="main">(</span><span class="bound">y</span><span class="main">,</span><span class="free">f</span><span class="main">(</span><span class="bound">z</span><span class="main">,</span><span class="bound">w</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span><span class="main">(</span><span class="free">f</span><span class="main">(</span><span class="free">f</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span><span class="main">,</span><span class="bound">z</span><span class="main">)</span><span class="main">,</span><span class="bound">w</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto2</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Primes_Ex">
<div class="head">
<h1>Theory Primes_Ex</h1>
</div>
<pre class="source"><span class="comment1">(*
  File: Primes_Ex.thy
  Author: Bohua Zhan

  Elementary number theory of primes, up to the proof of infinitude
  of primes and the unique factorization theorem.

  Follows the development in HOL/Computational_Algebra/Primes.thy.
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Primes›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Primes_Ex
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="Auto2_Main.html">Auto2_Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Basic definition›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">prime</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">rewrite</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">prime</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">1</span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">m</span><span class="main">.</span> <span class="bound">m</span> <span class="keyword1">dvd</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">⟶</span> <span class="bound">m</span> <span class="main">=</span> <span class="main">1</span> <span class="main">∨</span> <span class="bound">m</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> primeD1 <span class="main">[</span><span class="operator">forward</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"prime <span class="free">p</span> <span class="main">⟹</span> <span class="main">1</span> <span class="main">&lt;</span> <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto2</span>
<span class="keyword1"><span class="command">lemma</span></span> primeD2<span class="main">:</span> <span class="quoted"><span class="quoted">"prime <span class="free">p</span> <span class="main">⟹</span> <span class="free">m</span> <span class="keyword1">dvd</span> <span class="free">p</span> <span class="main">⟹</span> <span class="free">m</span> <span class="main">=</span> <span class="main">1</span> <span class="main">∨</span> <span class="free">m</span> <span class="main">=</span> <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto2</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> primeD2<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_cond</span> <span class="inner_quoted">"?m ≠ 1"</span><span class="main">,</span> <span class="entity">with_cond</span> <span class="inner_quoted">"?m ≠ ?p"</span><span class="main">]</span>›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">del_prfstep_thm_eqforward</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> prime_def<span class="antiquote">}</span></span></span>›</span>

<span class="comment1">(* Exists a prime p. *)</span>
<span class="keyword1"><span class="command">theorem</span></span> exists_prime <span class="main">[</span><span class="operator">resolve</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">p</span><span class="main">.</span> prime <span class="bound">p</span>"</span></span>
<span class="keyword1"><span class="command">@proof</span></span> <span class="keyword1"><span class="command">@have</span></span> <span class="quoted"><span class="quoted">"prime <span class="numeral">2</span>"</span></span> <span class="keyword1"><span class="command">@qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> prime_odd_nat<span class="main">:</span> <span class="quoted"><span class="quoted">"prime <span class="free">p</span> <span class="main">⟹</span> <span class="free">p</span> <span class="main">&gt;</span> <span class="numeral">2</span> <span class="main">⟹</span> odd <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto2</span>

<span class="keyword1"><span class="command">lemma</span></span> prime_imp_coprime_nat <span class="main">[</span><span class="operator">backward2</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"prime <span class="free">p</span> <span class="main">⟹</span> <span class="main">¬</span> <span class="free">p</span> <span class="keyword1">dvd</span> <span class="free">n</span> <span class="main">⟹</span> coprime <span class="free">p</span> <span class="free">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto2</span>

<span class="keyword1"><span class="command">lemma</span></span> prime_dvd_mult_nat<span class="main">:</span> <span class="quoted"><span class="quoted">"prime <span class="free">p</span> <span class="main">⟹</span> <span class="free">p</span> <span class="keyword1">dvd</span> <span class="free">m</span> <span class="main">*</span> <span class="free">n</span> <span class="main">⟹</span> <span class="free">p</span> <span class="keyword1">dvd</span> <span class="free">m</span> <span class="main">∨</span> <span class="free">p</span> <span class="keyword1">dvd</span> <span class="free">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto2</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> prime_dvd_mult_nat<span class="antiquote">}</span></span></span>
  <span class="main">(</span><span class="entity">with_conds</span> <span class="main">[</span><span class="inner_quoted">"?m ≠ ?p"</span><span class="main">,</span> <span class="inner_quoted">"?n ≠ ?p"</span><span class="main">,</span> <span class="inner_quoted">"?m ≠ ?p * ?m'"</span><span class="main">,</span> <span class="inner_quoted">"?n ≠ ?p * ?n'"</span><span class="main">]</span><span class="main">)</span>›</span>

<span class="keyword1"><span class="command">theorem</span></span> prime_dvd_intro<span class="main">:</span> <span class="quoted"><span class="quoted">"prime <span class="free">p</span> <span class="main">⟹</span> <span class="free">p</span> <span class="main">*</span> <span class="free">q</span> <span class="main">=</span> <span class="free">m</span> <span class="main">*</span> <span class="free">n</span> <span class="main">⟹</span> <span class="free">p</span> <span class="keyword1">dvd</span> <span class="free">m</span> <span class="main">∨</span> <span class="free">p</span> <span class="keyword1">dvd</span> <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">@proof</span></span> <span class="keyword1"><span class="command">@have</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="keyword1">dvd</span> <span class="free">m</span> <span class="main">*</span> <span class="free">n</span>"</span></span> <span class="keyword1"><span class="command">@qed</span></span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> prime_dvd_intro<span class="antiquote">}</span></span></span>
  <span class="main">(</span><span class="entity">with_conds</span> <span class="main">[</span><span class="inner_quoted">"?m ≠ ?p"</span><span class="main">,</span> <span class="inner_quoted">"?n ≠ ?p"</span><span class="main">,</span> <span class="inner_quoted">"?m ≠ ?p * ?m'"</span><span class="main">,</span> <span class="inner_quoted">"?n ≠ ?p * ?n'"</span><span class="main">]</span><span class="main">)</span>›</span>

<span class="keyword1"><span class="command">lemma</span></span> prime_dvd_mult_eq_nat<span class="main">:</span> <span class="quoted"><span class="quoted">"prime <span class="free">p</span> <span class="main">⟹</span> <span class="free">p</span> <span class="keyword1">dvd</span> <span class="free">m</span> <span class="main">*</span> <span class="free">n</span> <span class="main">=</span> <span class="main">(</span><span class="free">p</span> <span class="keyword1">dvd</span> <span class="free">m</span> <span class="main">∨</span> <span class="free">p</span> <span class="keyword1">dvd</span> <span class="free">n</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto2</span>

<span class="keyword1"><span class="command">lemma</span></span> not_prime_eq_prod_nat <span class="main">[</span><span class="operator">backward1</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">&gt;</span> <span class="main">1</span> <span class="main">⟹</span> <span class="main">¬</span> prime <span class="free">n</span> <span class="main">⟹</span>
    <span class="main">∃</span><span class="bound">m</span> <span class="bound">k</span><span class="main">.</span> <span class="free">n</span> <span class="main">=</span> <span class="bound">m</span> <span class="main">*</span> <span class="bound">k</span> <span class="main">∧</span> <span class="main">1</span> <span class="main">&lt;</span> <span class="bound">m</span> <span class="main">∧</span> <span class="bound">m</span> <span class="main">&lt;</span> <span class="free">n</span> <span class="main">∧</span> <span class="main">1</span> <span class="main">&lt;</span> <span class="bound">k</span> <span class="main">∧</span> <span class="bound">k</span> <span class="main">&lt;</span> <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">@proof</span></span>
  <span class="keyword1"><span class="command">@obtain</span></span> <span class="quoted"><span class="free">m</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="keyword1">dvd</span> <span class="free">n</span> <span class="main">∧</span> <span class="free">m</span> <span class="main">≠</span> <span class="main">1</span> <span class="main">∧</span> <span class="free">m</span> <span class="main">≠</span> <span class="free">n</span>"</span></span>
  <span class="keyword1"><span class="command">@obtain</span></span> <span class="quoted"><span class="free">k</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">=</span> <span class="free">m</span> <span class="main">*</span> <span class="free">k</span>"</span></span> <span class="keyword1"><span class="command">@have</span></span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">≤</span> <span class="free">m</span> <span class="main">*</span> <span class="free">k</span>"</span></span> <span class="keyword1"><span class="command">@have</span></span> <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">≤</span> <span class="free">m</span> <span class="main">*</span> <span class="free">k</span>"</span></span>
<span class="keyword1"><span class="command">@qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> prime_dvd_power_nat<span class="main">:</span> <span class="quoted"><span class="quoted">"prime <span class="free">p</span> <span class="main">⟹</span> <span class="free">p</span> <span class="keyword1">dvd</span> <span class="free">x</span><span class="main">^</span><span class="free">n</span> <span class="main">⟹</span> <span class="free">p</span> <span class="keyword1">dvd</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto2</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> prime_dvd_power_nat<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_cond</span> <span class="inner_quoted">"?p ≠ ?x"</span><span class="main">]</span>›</span>

<span class="keyword1"><span class="command">lemma</span></span> prime_dvd_power_nat_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"prime <span class="free">p</span> <span class="main">⟹</span> <span class="free">n</span> <span class="main">&gt;</span> <span class="main">0</span> <span class="main">⟹</span> <span class="free">p</span> <span class="keyword1">dvd</span> <span class="free">x</span><span class="main">^</span><span class="free">n</span> <span class="main">⟷</span> <span class="free">p</span> <span class="keyword1">dvd</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto2</span>

<span class="keyword1"><span class="command">lemma</span></span> prime_nat_code<span class="main">:</span> <span class="quoted"><span class="quoted">"prime <span class="free">p</span> <span class="main">=</span> <span class="main">(</span><span class="main">1</span> <span class="main">&lt;</span> <span class="free">p</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="main">1</span> <span class="main">&lt;</span> <span class="bound">x</span> <span class="main">∧</span> <span class="bound">x</span> <span class="main">&lt;</span> <span class="free">p</span> <span class="main">⟶</span> <span class="main">¬</span> <span class="bound">x</span> <span class="keyword1">dvd</span> <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto2</span>

<span class="keyword1"><span class="command">lemma</span></span> prime_factor_nat <span class="main">[</span><span class="operator">backward</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">≠</span> <span class="main">1</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">p</span><span class="main">.</span> <span class="bound">p</span> <span class="keyword1">dvd</span> <span class="free">n</span> <span class="main">∧</span> prime <span class="bound">p</span>"</span></span>
<span class="keyword1"><span class="command">@proof</span></span>
  <span class="keyword1"><span class="command">@strong_induct</span></span> <span class="quoted"><span class="free">n</span></span>
  <span class="keyword1"><span class="command">@case</span></span> <span class="quoted"><span class="quoted">"prime <span class="free">n</span>"</span></span> <span class="keyword1"><span class="command">@case</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">@obtain</span></span> <span class="quoted"><span class="free">k</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">≠</span> <span class="main">1</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">≠</span> <span class="free">n</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="keyword1">dvd</span> <span class="free">n</span>"</span></span>
  <span class="keyword1"><span class="command">@apply_induct_hyp</span></span> <span class="quoted"><span class="free">k</span></span>
<span class="keyword1"><span class="command">@qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> prime_divprod_pow_nat<span class="main">:</span>
  <span class="quoted"><span class="quoted">"prime <span class="free">p</span> <span class="main">⟹</span> coprime <span class="free">a</span> <span class="free">b</span> <span class="main">⟹</span> <span class="free">p</span><span class="main">^</span><span class="free">n</span> <span class="keyword1">dvd</span> <span class="free">a</span> <span class="main">*</span> <span class="free">b</span> <span class="main">⟹</span> <span class="free">p</span><span class="main">^</span><span class="free">n</span> <span class="keyword1">dvd</span> <span class="free">a</span> <span class="main">∨</span> <span class="free">p</span><span class="main">^</span><span class="free">n</span> <span class="keyword1">dvd</span> <span class="free">b</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto2</span>

<span class="keyword1"><span class="command">lemma</span></span> prime_product <span class="main">[</span><span class="operator">forward</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"prime <span class="main">(</span><span class="free">p</span> <span class="main">*</span> <span class="free">q</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">p</span> <span class="main">=</span> <span class="main">1</span> <span class="main">∨</span> <span class="free">q</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command">@proof</span></span> <span class="keyword1"><span class="command">@have</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="keyword1">dvd</span> <span class="free">q</span> <span class="main">*</span> <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">@qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> prime_exp<span class="main">:</span> <span class="quoted"><span class="quoted">"prime <span class="main">(</span><span class="free">p</span> <span class="main">^</span> <span class="free">n</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">n</span> <span class="main">=</span> <span class="main">1</span> <span class="main">∧</span> prime <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto2</span>

<span class="keyword1"><span class="command">lemma</span></span> prime_power_mult<span class="main">:</span> <span class="quoted"><span class="quoted">"prime <span class="free">p</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">*</span> <span class="free">y</span> <span class="main">=</span> <span class="free">p</span> <span class="main">^</span> <span class="free">k</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">i</span> <span class="bound">j</span><span class="main">.</span> <span class="free">x</span> <span class="main">=</span> <span class="free">p</span> <span class="main">^</span> <span class="bound">i</span> <span class="main">∧</span> <span class="free">y</span> <span class="main">=</span> <span class="free">p</span> <span class="main">^</span> <span class="bound">j</span>"</span></span>
<span class="keyword1"><span class="command">@proof</span></span>
  <span class="keyword1"><span class="command">@induct</span></span> <span class="quoted"><span class="free">k</span></span> <span class="keyword2"><span class="keyword">arbitrary</span></span> <span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="free">y</span></span> <span class="main">@with</span>
    <span class="keyword1"><span class="command">@subgoal</span></span> <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">=</span> Suc <span class="free">k'</span>"</span></span>
      <span class="keyword1"><span class="command">@case</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="keyword1">dvd</span> <span class="free">x</span>"</span></span> <span class="main">@with</span>
        <span class="keyword1"><span class="command">@obtain</span></span> <span class="quoted"><span class="free">x'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="free">p</span> <span class="main">*</span> <span class="free">x'</span>"</span></span> <span class="keyword1"><span class="command">@have</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">*</span> <span class="free">y</span> <span class="main">=</span> <span class="free">p</span> <span class="main">*</span> <span class="main">(</span><span class="free">x'</span> <span class="main">*</span> <span class="free">y</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">@obtain</span></span> <span class="quoted"><span class="free">i</span></span> <span class="quoted"><span class="free">j</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">x'</span> <span class="main">=</span> <span class="free">p</span> <span class="main">^</span> <span class="free">i</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">=</span> <span class="free">p</span> <span class="main">^</span> <span class="free">j</span>"</span></span> <span class="keyword1"><span class="command">@have</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="free">p</span> <span class="main">^</span> Suc <span class="free">i</span>"</span></span> <span class="keyword1"><span class="command">@end</span></span>
      <span class="keyword1"><span class="command">@case</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="keyword1">dvd</span> <span class="free">y</span>"</span></span> <span class="main">@with</span>
        <span class="keyword1"><span class="command">@obtain</span></span> <span class="quoted"><span class="free">y'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">=</span> <span class="free">p</span> <span class="main">*</span> <span class="free">y'</span>"</span></span> <span class="keyword1"><span class="command">@have</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">*</span> <span class="free">y</span> <span class="main">=</span> <span class="free">p</span> <span class="main">*</span> <span class="main">(</span><span class="free">x</span> <span class="main">*</span> <span class="free">y'</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">@obtain</span></span> <span class="quoted"><span class="free">i</span></span> <span class="quoted"><span class="free">j</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="free">p</span> <span class="main">^</span> <span class="free">i</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">y'</span> <span class="main">=</span> <span class="free">p</span> <span class="main">^</span> <span class="free">j</span>"</span></span> <span class="keyword1"><span class="command">@have</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">=</span> <span class="free">p</span> <span class="main">^</span> Suc <span class="free">j</span>"</span></span> <span class="keyword1"><span class="command">@end</span></span>
    <span class="keyword1"><span class="command">@endgoal</span></span>
  <span class="keyword1"><span class="command">@end</span></span>
<span class="keyword1"><span class="command">@qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Infinitude of primes›</span></span>

<span class="keyword1"><span class="command">theorem</span></span> bigger_prime <span class="main">[</span><span class="operator">resolve</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">p</span><span class="main">.</span> prime <span class="bound">p</span> <span class="main">∧</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="bound">p</span>"</span></span>
<span class="keyword1"><span class="command">@proof</span></span>
  <span class="keyword1"><span class="command">@obtain</span></span> <span class="quoted"><span class="free">p</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"prime <span class="free">p</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="keyword1">dvd</span> fact <span class="free">n</span> <span class="main">+</span> <span class="main">1</span>"</span></span>
  <span class="keyword1"><span class="command">@case</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">≥</span> <span class="free">p</span>"</span></span> <span class="main">@with</span> <span class="keyword1"><span class="command">@have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span><span class="main">::</span>nat<span class="main">)</span> <span class="keyword1">dvd</span> fact <span class="free">n</span>"</span></span> <span class="keyword1"><span class="command">@end</span></span>
<span class="keyword1"><span class="command">@qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> primes_infinite<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> finite <span class="main">{</span><span class="bound">p</span><span class="main">.</span> prime <span class="bound">p</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">@proof</span></span>
  <span class="keyword1"><span class="command">@obtain</span></span> <span class="quoted"><span class="free">b</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"prime <span class="free">b</span>"</span></span> <span class="quoted"><span class="quoted">"Max <span class="main">{</span><span class="bound">p</span><span class="main">.</span> prime <span class="bound">p</span><span class="main">}</span> <span class="main">&lt;</span> <span class="free">b</span>"</span></span>
<span class="keyword1"><span class="command">@qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Existence and uniqueness of prime factorization›</span></span>

<span class="keyword1"><span class="command">theorem</span></span> factorization_exists<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">&gt;</span> <span class="main">0</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">M</span><span class="main">.</span> <span class="main">(</span><span class="main">∀</span><span class="bound">p</span><span class="main">∈#</span><span class="bound">M</span><span class="main">.</span> prime <span class="bound">p</span><span class="main">)</span> <span class="main">∧</span> <span class="free">n</span> <span class="main">=</span> <span class="main">(</span><span class="main">∏</span><span class="bound">i</span><span class="main">∈#</span><span class="bound">M</span><span class="main">.</span> <span class="bound">i</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">@proof</span></span>
  <span class="keyword1"><span class="command">@strong_induct</span></span> <span class="quoted"><span class="free">n</span></span>
  <span class="keyword1"><span class="command">@case</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">=</span> <span class="main">1</span>"</span></span> <span class="main">@with</span> <span class="keyword1"><span class="command">@have</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">=</span> <span class="main">(</span><span class="main">∏</span><span class="bound">i</span><span class="main">∈#</span> <span class="main">{#}</span><span class="main">.</span> <span class="bound">i</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">@end</span></span>
  <span class="keyword1"><span class="command">@case</span></span> <span class="quoted"><span class="quoted">"prime <span class="free">n</span>"</span></span> <span class="main">@with</span> <span class="keyword1"><span class="command">@have</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">=</span> <span class="main">(</span><span class="main">∏</span><span class="bound">i</span><span class="main">∈#</span> <span class="main">{#</span><span class="free">n</span><span class="main">#}</span><span class="main">.</span> <span class="bound">i</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">@end</span></span>
  <span class="keyword1"><span class="command">@obtain</span></span> <span class="quoted"><span class="free">m</span></span> <span class="quoted"><span class="free">k</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">=</span> <span class="free">m</span> <span class="main">*</span> <span class="free">k</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">&lt;</span> <span class="free">m</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">&lt;</span> <span class="free">n</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">&lt;</span> <span class="free">k</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">&lt;</span> <span class="free">n</span>"</span></span>
  <span class="keyword1"><span class="command">@apply_induct_hyp</span></span> <span class="quoted"><span class="free">m</span></span>
  <span class="keyword1"><span class="command">@obtain</span></span> <span class="quoted"><span class="free">M</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">p</span><span class="main">∈#</span><span class="free">M</span><span class="main">.</span> prime <span class="bound">p</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">=</span> <span class="main">(</span><span class="main">∏</span><span class="bound">i</span><span class="main">∈#</span><span class="free">M</span><span class="main">.</span> <span class="bound">i</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">@apply_induct_hyp</span></span> <span class="quoted"><span class="free">k</span></span>
  <span class="keyword1"><span class="command">@obtain</span></span> <span class="quoted"><span class="free">K</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">p</span><span class="main">∈#</span><span class="free">K</span><span class="main">.</span> prime <span class="bound">p</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">=</span> <span class="main">(</span><span class="main">∏</span><span class="bound">i</span><span class="main">∈#</span><span class="free">K</span><span class="main">.</span> <span class="bound">i</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">@have</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">=</span> <span class="main">(</span><span class="main">∏</span><span class="bound">i</span><span class="main">∈#</span><span class="main">(</span><span class="free">M</span><span class="main">+</span><span class="free">K</span><span class="main">)</span><span class="main">.</span> <span class="bound">i</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">@qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> prime_dvd_multiset <span class="main">[</span><span class="operator">backward1</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"prime <span class="free">p</span> <span class="main">⟹</span> <span class="free">p</span> <span class="keyword1">dvd</span> <span class="main">(</span><span class="main">∏</span><span class="bound">i</span><span class="main">∈#</span><span class="free">M</span><span class="main">.</span> <span class="bound">i</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">n</span><span class="main">.</span> <span class="bound">n</span><span class="main">∈#</span><span class="free">M</span> <span class="main">∧</span> <span class="free">p</span> <span class="keyword1">dvd</span> <span class="bound">n</span>"</span></span>
<span class="keyword1"><span class="command">@proof</span></span>
  <span class="keyword1"><span class="command">@strong_induct</span></span> <span class="quoted"><span class="free">M</span></span>
  <span class="keyword1"><span class="command">@case</span></span> <span class="quoted"><span class="quoted">"<span class="free">M</span> <span class="main">=</span> <span class="main">{#}</span>"</span></span>
  <span class="keyword1"><span class="command">@obtain</span></span> <span class="quoted"><span class="free">M'</span></span> <span class="quoted"><span class="free">m</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">M</span> <span class="main">=</span> <span class="free">M'</span> <span class="main">+</span> <span class="main">{#</span><span class="free">m</span><span class="main">#}</span>"</span></span>
  <span class="keyword1"><span class="command">@contradiction</span></span> <span class="keyword1"><span class="command">@apply_induct_hyp</span></span> <span class="quoted"><span class="free">M'</span></span>
<span class="keyword1"><span class="command">@qed</span></span>
  
<span class="keyword1"><span class="command">theorem</span></span> factorization_unique_aux<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">p</span><span class="main">∈#</span><span class="free">M</span><span class="main">.</span> prime <span class="bound">p</span> <span class="main">⟹</span> <span class="main">∀</span><span class="bound">p</span><span class="main">∈#</span><span class="free">N</span><span class="main">.</span> prime <span class="bound">p</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">∏</span><span class="bound">i</span><span class="main">∈#</span><span class="free">M</span><span class="main">.</span> <span class="bound">i</span><span class="main">)</span> <span class="keyword1">dvd</span> <span class="main">(</span><span class="main">∏</span><span class="bound">i</span><span class="main">∈#</span><span class="free">N</span><span class="main">.</span> <span class="bound">i</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">M</span> <span class="main">⊆#</span> <span class="free">N</span>"</span></span>
<span class="keyword1"><span class="command">@proof</span></span>
  <span class="keyword1"><span class="command">@strong_induct</span></span> <span class="quoted"><span class="free">M</span></span> <span class="keyword2"><span class="keyword">arbitrary</span></span> <span class="quoted"><span class="free">N</span></span>
  <span class="keyword1"><span class="command">@case</span></span> <span class="quoted"><span class="quoted">"<span class="free">M</span> <span class="main">=</span> <span class="main">{#}</span>"</span></span>
  <span class="keyword1"><span class="command">@obtain</span></span> <span class="quoted"><span class="free">M'</span></span> <span class="quoted"><span class="free">m</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">M</span> <span class="main">=</span> <span class="free">M'</span> <span class="main">+</span> <span class="main">{#</span><span class="free">m</span><span class="main">#}</span>"</span></span>
  <span class="keyword1"><span class="command">@have</span></span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="keyword1">dvd</span> <span class="main">(</span><span class="main">∏</span><span class="bound">i</span><span class="main">∈#</span><span class="free">M</span><span class="main">.</span> <span class="bound">i</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">@obtain</span></span> <span class="quoted"><span class="free">n</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">∈#</span> <span class="free">N</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="keyword1">dvd</span> <span class="free">n</span>"</span></span>
  <span class="keyword1"><span class="command">@obtain</span></span> <span class="quoted"><span class="free">N'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">N</span> <span class="main">=</span> <span class="free">N'</span> <span class="main">+</span> <span class="main">{#</span><span class="free">n</span><span class="main">#}</span>"</span></span>
  <span class="keyword1"><span class="command">@have</span></span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">=</span> <span class="free">n</span>"</span></span>
  <span class="keyword1"><span class="command">@have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∏</span><span class="bound">i</span><span class="main">∈#</span><span class="free">M'</span><span class="main">.</span> <span class="bound">i</span><span class="main">)</span> <span class="keyword1">dvd</span> <span class="main">(</span><span class="main">∏</span><span class="bound">i</span><span class="main">∈#</span><span class="free">N'</span><span class="main">.</span> <span class="bound">i</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">@apply_induct_hyp</span></span> <span class="quoted"><span class="free">M'</span></span> <span class="quoted"><span class="free">N'</span></span>
<span class="keyword1"><span class="command">@qed</span></span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">add_forward_prfstep_cond</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> factorization_unique_aux<span class="antiquote">}</span></span></span> <span class="main">[</span><span class="entity">with_cond</span> <span class="inner_quoted">"?M ≠ ?N"</span><span class="main">]</span>›</span>

<span class="keyword1"><span class="command">theorem</span></span> factorization_unique<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">p</span><span class="main">∈#</span><span class="free">M</span><span class="main">.</span> prime <span class="bound">p</span> <span class="main">⟹</span> <span class="main">∀</span><span class="bound">p</span><span class="main">∈#</span><span class="free">N</span><span class="main">.</span> prime <span class="bound">p</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">∏</span><span class="bound">i</span><span class="main">∈#</span><span class="free">M</span><span class="main">.</span> <span class="bound">i</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∏</span><span class="bound">i</span><span class="main">∈#</span><span class="free">N</span><span class="main">.</span> <span class="bound">i</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">M</span> <span class="main">=</span> <span class="free">N</span>"</span></span>
<span class="keyword1"><span class="command">@proof</span></span> <span class="keyword1"><span class="command">@have</span></span> <span class="quoted"><span class="quoted">"<span class="free">M</span> <span class="main">⊆#</span> <span class="free">N</span>"</span></span> <span class="keyword1"><span class="command">@qed</span></span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">del_prfstep_thm</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> factorization_unique_aux<span class="antiquote">}</span></span></span>›</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div>