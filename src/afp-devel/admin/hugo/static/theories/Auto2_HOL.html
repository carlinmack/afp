<div id="HOL_Base">
<div class="head"><h1>Theory HOL_Base</h1>
<span class="command">theory</span> <span class="name">HOL_Base</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Main.html"><span class="name">Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  File: HOL_Base.thy
  Author: Bohua Zhan

  Extra theorems in logic used by auto2.
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>HOL_Base</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Main</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>to_contra_form</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Trueprop A ≡ (¬A ⟹ False)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>equal_intr_rule</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>to_contra_form'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Trueprop (¬A) ≡ (A ⟹ False)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>equal_intr_rule</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>contra_triv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬A ⟹ A ⟹ False"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>or_intro1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ (P ∨ Q) ⟹ ¬ P"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>or_intro2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ (P ∨ Q) ⟹ ¬ Q"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>or_cancel1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬Q ⟹ (P ∨ Q) = P"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>or_cancel2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬P ⟹ (P ∨ Q) = Q"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>exE'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋀x. P x ⟹ Q) ⟹ ∃x. P x ⟹ Q"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>nn_create</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ⟹ ¬¬A"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>iffD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ⟷ B ⟹ (A ⟶ B) ∧ (B ⟶ A)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>obj_sym</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Trueprop (t = s) ≡ Trueprop (s = t)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>equal_intr_rule</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>to_meta_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Trueprop (t = s) ≡ (t ≡ s)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>equal_intr_rule</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>inv_backward</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ⟷ B ⟹ ¬A ⟹ ¬B"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>backward_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(A ⟹ B) ≡ (¬B ⟹ ¬A)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>equal_intr_rule</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>backward1_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(A ⟹ B ⟹ C) ≡ (¬C ⟹ B ⟹ ¬A)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>equal_intr_rule</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>backward2_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(A ⟹ B ⟹ C) ≡ (¬C ⟹ A ⟹ ¬B)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>equal_intr_rule</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>resolve_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(A ⟹ B) ≡ (¬B ⟹ A ⟹ False)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>equal_intr_rule</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Quantifiers: swapping out of ALL or EX *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>swap_ex_conj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(P ∧ (∃x. Q x)) ⟷ (∃x. P ∧ Q x)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>swap_all_disj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(P ∨ (∀x. Q x)) ⟷ (∀x. P ∨ Q x)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Use these instead of original versions to keep names in abstractions. *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>Bex_def'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃x∈S. P x) ⟷ (∃x. x ∈ S ∧ P x)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>Ball_def'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀x∈S. P x) ⟷ (∀x. x ∈ S ⟶ P x)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Taking conjunction of assumptions *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>atomize_conjL</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(A ⟹ B ⟹ PROP C) ≡ (A ∧ B ⟹ PROP C)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>equal_intr_rule</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Auto2_HOL">
<div class="head"><h1>Theory Auto2_HOL</h1>
<span class="command">theory</span> <span class="name">Auto2_HOL</span><br/>
<span class="keyword">imports</span> <a href="HOL_Base.html"><span class="name">HOL_Base</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  File: Auto2_HOL.thy
  Author: Bohua Zhan

  Main file for auto2 setup in HOL.
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Auto2_HOL</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>HOL_Base</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">keywords</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"@proof"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span>prf_block</span><span> </span><span class="delimiter">%</span><span> </span><span class="string"><span class="delete"><span class="delete">"proof"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"@have"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"@case"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"@obtain"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"@let"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"@contradiction"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"@strong_induct"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span>prf_decl</span><span> </span><span class="delimiter">%</span><span> </span><span class="string"><span class="delete"><span class="delete">"proof"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"@unfold"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span>prf_decl</span><span> </span><span class="delimiter">%</span><span> </span><span class="string"><span class="delete"><span class="delete">"proof"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"@induct"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"@fun_induct"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"@case_induct"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"@prop_induct"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"@cases"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span>prf_decl</span><span> </span><span class="delimiter">%</span><span> </span><span class="string"><span class="delete"><span class="delete">"proof"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"@apply_induct_hyp"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span>prf_decl</span><span> </span><span class="delimiter">%</span><span> </span><span class="string"><span class="delete"><span class="delete">"proof"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"@subgoal"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"@endgoal"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"@end"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span>prf_decl</span><span> </span><span class="delimiter">%</span><span> </span><span class="string"><span class="delete"><span class="delete">"proof"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"@qed"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span>qed_block</span><span> </span><span class="delimiter">%</span><span> </span><span class="string"><span class="delete"><span class="delete">"proof"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"@with"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"where"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"arbitrary"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"@rule"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span>quasi_command</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹../util.ML›</span></span></span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹../util_base.ML›</span></span></span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹auto2_hol.ML›</span></span></span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹../util_logic.ML›</span></span></span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹../box_id.ML›</span></span></span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹../consts.ML›</span></span></span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹../property.ML›</span></span></span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹../wellform.ML›</span></span></span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹../wfterm.ML›</span></span></span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹../rewrite.ML›</span></span></span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹../propertydata.ML›</span></span></span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹../matcher.ML›</span></span></span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹../items.ML›</span></span></span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹../wfdata.ML›</span></span></span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹../auto2_data.ML›</span></span></span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹../status.ML›</span></span></span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹../normalize.ML›</span></span></span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹../proofsteps.ML›</span></span></span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹../auto2_state.ML›</span></span></span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹../logic_steps.ML›</span></span></span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹../auto2.ML›</span></span></span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹../auto2_outer.ML›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹acdata.ML›</span></span></span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ac_steps.ML›</span></span></span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹unfolding.ML›</span></span></span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹induct_outer.ML›</span></span></span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹extra_hol.ML›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">method_setup</span></span><span> </span><span>auto2</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Scan.succeed (SIMPLE_METHOD o Auto2.auto2_tac)›</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"auto2 prover"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">attribute_setup</span></span><span> </span><span>forward</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹setup_attrib add_forward_prfstep›</span></span></span><span>
</span><span class="keyword1"><span class="command">attribute_setup</span></span><span> </span><span>backward</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹setup_attrib add_backward_prfstep›</span></span></span><span>
</span><span class="keyword1"><span class="command">attribute_setup</span></span><span> </span><span>backward1</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹setup_attrib add_backward1_prfstep›</span></span></span><span>
</span><span class="keyword1"><span class="command">attribute_setup</span></span><span> </span><span>backward2</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹setup_attrib add_backward2_prfstep›</span></span></span><span>
</span><span class="keyword1"><span class="command">attribute_setup</span></span><span> </span><span>resolve</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹setup_attrib add_resolve_prfstep›</span></span></span><span>
</span><span class="keyword1"><span class="command">attribute_setup</span></span><span> </span><span>rewrite</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹setup_attrib add_rewrite_rule›</span></span></span><span>
</span><span class="keyword1"><span class="command">attribute_setup</span></span><span> </span><span>rewrite_back</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹setup_attrib add_rewrite_rule_back›</span></span></span><span>
</span><span class="keyword1"><span class="command">attribute_setup</span></span><span> </span><span>rewrite_bidir</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹setup_attrib add_rewrite_rule_bidir›</span></span></span><span>
</span><span class="keyword1"><span class="command">attribute_setup</span></span><span> </span><span>forward_arg1</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹setup_attrib add_forward_arg1_prfstep›</span></span></span><span>
</span><span class="keyword1"><span class="command">attribute_setup</span></span><span> </span><span>forward_arg</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹setup_attrib add_forward_arg_prfstep›</span></span></span><span>
</span><span class="keyword1"><span class="command">attribute_setup</span></span><span> </span><span>rewrite_arg</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹setup_attrib add_rewrite_arg_rule›</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Logic_Thms">
<div class="head"><h1>Theory Logic_Thms</h1>
<span class="command">theory</span> <span class="name">Logic_Thms</span><br/>
<span class="keyword">imports</span> <a href="Auto2_HOL.html"><span class="name">Auto2_HOL</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  File: Logic_Thms.thy
  Author: Bohua Zhan

  Setup for proof steps related to logic.
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Logic_Thms</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Auto2_HOL</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Trivial contradictions. *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_resolve_prfstep @{thm HOL.refl}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep @{thm contra_triv}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_resolve_prfstep @{thm TrueI}›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>FalseD</span><span> </span><span class="delimiter">[</span><span>resolve</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬False"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exists_triv_eq</span><span> </span><span class="delimiter">[</span><span>resolve</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃x. x = x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Not. *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm HOL.not_sym} [with_filt (not_type_filter "s" boolT)]›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Iff. *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_gen_prfstep ("iff_intro1",
  [WithGoal @{term_pat "(?A::bool) = ?B"},
   CreateCase @{term_pat "?A::bool"},
   WithScore 25])›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>iff_goal</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"A ≠ B ⟹ A ⟹ ¬B"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A ≠ B ⟹ B ⟹ ¬A"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"A ≠ B ⟹ ¬A ⟹ B"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A ≠ B ⟹ ¬B ⟹ A"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(¬A) ≠ B ⟹ A ⟹ B"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A ≠ (¬B) ⟹ B ⟹ A"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold (fn th =&gt; add_forward_prfstep_cond th [with_score 1]) @{thms iff_goal}›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Quantifiers: normalization *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>exists_split</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃x y. P x ∧ Q y) = ((∃x. P x) ∧ (∃y. Q y))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward_prfstep (equiv_backward_th @{thm exists_split})›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Case analysis. *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_gen_prfstep ("case_intro",
  [WithTerm @{term_pat "if ?cond then (?yes::?'a) else ?no"},
   CreateCase @{term_pat "?cond::bool"}])›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_gen_prfstep ("case_intro_fact",
  [WithFact @{term_pat "if ?cond then (?yes::bool) else ?no"},
   CreateCase @{term_pat "?cond::bool"}])›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_gen_prfstep ("case_intro_goal",
  [WithGoal @{term_pat "if ?cond then (?yes::bool) else ?no"},
   CreateCase @{term_pat "?cond::bool"}])›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>if_eval'</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"P ⟹ (if ¬P then x else y) = y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ifb_eval</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"P ⟹ (if P then (x::bool) else y) = x"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"¬P ⟹ (if P then (x::bool) else y) = y"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"P ⟹ (if ¬P then (x::bool) else y) = y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold (fn th =&gt; add_rewrite_rule_cond th [with_score 1])
  ([@{thm HOL.if_P}, @{thm HOL.if_not_P}, @{thm if_eval'}] @ @{thms ifb_eval})›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* THE and ∃! *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm theI'} [with_term "THE x. ?P x"]›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_gen_prfstep ("ex1_case",
  [WithGoal @{term_pat "∃!x. ?P x"}, CreateConcl @{term_pat "∃x. ?P x"}])›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>ex_ex1I'</span><span> </span><span class="delimiter">[</span><span>backward1</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀y. P y ⟶ x = y ⟹ P x ⟹ ∃!x. P x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>the1_equality'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P a ⟹ ∃!x. P x ⟹ (THE x. P x) = a"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>the1_equality</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm the1_equality'} [with_term "THE x. ?P x"]›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Hilbert choice. *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_gen_prfstep ("SOME_case_intro",
  [WithTerm @{term_pat "SOME k. ?P k"}, CreateConcl @{term_pat "∃k. ?P k"}])›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm someI} [with_term "SOME x. ?P x"]›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm someI_ex} [with_term "SOME x. ?P x"]›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Axiom of choice *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_prfstep_custom ("ex_choice",
  [WithGoal @{term_pat "EX f. !x. ?Q f x"}],
  (fn ((id, _), ths) =&gt; fn _ =&gt; fn _ =&gt;
    let
      val choice = @{thm choice} |&gt; apply_to_thm (Conv.rewr_conv UtilBase.backward_conv_th)
    in
      [Update.thm_update (id, (ths MRS choice))]
    end
    handle THM _ =&gt; []))
›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Least operator. *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>Least_equality'</span><span> </span><span class="delimiter">[</span><span>backward1</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"P (x::('a::order)) ⟹ ∀y. P y ⟶ x ≤ y ⟹ Least P = x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Least_equality</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Pairs. *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pair_inj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a,b) = c ⟷ a = fst c ∧ b = snd c"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Normalizer.add_inj_struct_data @{thm pair_inj}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm fst_conv}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm snd_conv}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep (equiv_forward_th @{thm prod.simps(1)})›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule_cond @{thm surjective_pairing} [with_cond "?t ≠ (?a, ?b)"]›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Normalizer.add_rewr_normalizer ("rewr_case", (to_meta_eq @{thm case_prod_beta'}))›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Let. *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Normalizer.add_rewr_normalizer ("rewr_let", @{thm Let_def})›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Equivalence relations *)</span></span></span></span></span><span>  
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep @{thm Relation.symD}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward_prfstep @{thm Relation.symI}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep @{thm Relation.transD}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward_prfstep @{thm Relation.transI}›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Options *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_resolve_prfstep @{thm option.distinct(1)}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm Option.option.sel}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep @{thm option.collapse}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep (equiv_forward_th @{thm option.simps(1)})›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold (fn th =&gt; add_rewrite_rule_cond th [with_score 1]) @{thms Option.option.case}›</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Order_Thms">
<div class="head"><h1>Theory Order_Thms</h1>
<span class="command">theory</span> <span class="name">Order_Thms</span><br/>
<span class="keyword">imports</span> <a href="Logic_Thms.html"><span class="name">Logic_Thms</span></a> <a href="../../HOL/HOL/Rat.html"><span class="name">Rat</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  File: Order_Thms.thy
  Author: Bohua Zhan

  Setup for proof steps related to ordering.
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Setup for ordering›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Order_Thms</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Logic_Thms</span><span> </span><span>HOL.Rat</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹util_arith.ML›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Consts.add_const_data ("NUMC", UtilArith.is_numc)›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Results in class order or preorder›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm Orderings.order_class.order.trans} [with_filt (not_type_filter "a" natT)]›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm Orderings.order_class.order.strict_trans} [with_filt (not_type_filter "a" natT)]›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm Orderings.order_le_less_trans} [with_filt (not_type_filter "x" natT)]›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm Orderings.order_less_le_trans} [with_filt (not_type_filter "x" natT)]›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_resolve_prfstep @{thm Orderings.order_class.order.irrefl}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm Orderings.le_neq_trans} [with_cond "?a ≠ ?b"]›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm Orderings.order_antisym} [with_filt (order_filter "x" "y"), with_cond "?x ≠ ?y"]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Rewriting of negation, in linorder›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_gen_prfstep [
  ("not_less",
   [WithProp @{term_pat "¬ (?x::(?'a::linorder)) &lt; ?y"},
    GetFact (@{term_pat "?y ≤ (?x::(?'a::linorder))"}, equiv_forward_th @{thm linorder_not_less}),
    WithScore 1]),
  ("not_le",
   [WithProp @{term_pat "¬ (?x::(?'a::linorder)) ≤ ?y"},
    GetFact (@{term_pat "?y &lt; (?x::(?'a::linorder))"}, equiv_forward_th @{thm linorder_not_le}),
    WithScore 1])]
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Properties of max and min (in linorder)›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm min.commute}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm min.idem}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm min.cobounded1} [with_term "min ?a ?b"]›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm min.cobounded2} [with_term "min ?a ?b"]›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward2_prfstep @{thm min.boundedI}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward2_prfstep @{thm min.mono}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm min.absorb1}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm min.absorb2}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm max.commute}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm max.idem}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm max.cobounded1} [with_term "max ?a ?b"]›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm max.cobounded2} [with_term "max ?a ?b"]›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward2_prfstep @{thm max.boundedI}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward2_prfstep @{thm max.mono}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm max.absorb1}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm max.absorb2}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Min›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward_prfstep @{thm Min_in}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward_prfstep @{thm Min_le}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward2_prfstep @{thm Min_eqI}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Existence of numbers satisfying inequalities›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>exists_ge</span><span> </span><span class="delimiter">[</span><span>resolve</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃k. k ≥ (i::('a::order))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_resolve_prfstep [@{thm lt_ex}, @{thm gt_ex}]›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward_prfstep @{thm dense}›</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Arith_Thms">
<div class="head"><h1>Theory Arith_Thms</h1>
<span class="command">theory</span> <span class="name">Arith_Thms</span><br/>
<span class="keyword">imports</span> <a href="Order_Thms.html"><span class="name">Order_Thms</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  File: Arith_Thms.thy
  Author: Bohua Zhan

  Setup for proof steps related to arithmetic, mostly on natural numbers.
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Setup for arithmetic›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Arith_Thms</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Order_Thms</span><span> </span><span>HOL.Binomial</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Reducing inequality on natural numbers. *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>reduce_le_plus_consts</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x::nat) + n1 ≤ y + n2 ⟹ x ≤ y + (n2-n1)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>reduce_le_plus_consts'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n1 ≥ n2 ⟹ (x::nat) + n1 ≤ y + n2 ⟹ x + (n1-n2) ≤ y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>reduce_less_plus_consts</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x::nat) + n1 &lt; y + n2 ⟹ x &lt; y + (n2-n1)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>reduce_less_plus_consts'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n1 ≥ n2 ⟹ (x::nat) + n1 &lt; y + n2 ⟹ x + (n1-n2) &lt; y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* To normal form. *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>norm_less_lminus</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x::nat) - n &lt; y ⟹ x ≤ y + (n-1)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>norm_less_lplus</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(x::nat) + n &lt; y ⟹ x + (n+1) ≤ y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>norm_less_rminus</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x::nat) &lt; y - n ⟹ x + (n+1) ≤ y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>norm_less_rplus</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(x::nat) &lt; y + n ⟹ x ≤ y + (n-1)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>norm_less</span><span class="delimiter">:</span><span>        </span><span class="string"><span class="delete"><span class="delete">"(x::nat) &lt; y     ⟹ x + 1 ≤ y"</span></span></span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>norm_le_lminus</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x::nat) - n ≤ y ⟹ x ≤ y + n"</span></span></span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>norm_le_rminus</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x::nat) ≤ y - n ⟹ x ≤ y + 0"</span></span></span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>norm_le</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x::nat) ≤ y ⟹ x ≤ y + 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>norm_le_lplus0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x::nat) + 0 ≤ y ⟹ x ≤ y + 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Transitive resolve. *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>trans_resolve1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n1 &gt; 0 ⟹ (x::nat) + n1 ≤ y ⟹ (y::nat) + n2 ≤ x ⟹ False"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>trans_resolve2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n1 &gt; n2 ⟹ (x::nat) + n1 ≤ y ⟹ (y::nat) ≤ x + n2 ⟹ False"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Transitive. *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>trans1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x::nat) + n1 ≤ y ⟹ y + n2 ≤ z ⟹ x + (n1+n2) ≤ z"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>trans2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x::nat) ≤ y + n1 ⟹ y ≤ z + n2 ⟹ x ≤ z + (n1+n2)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>trans3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x::nat) + n1 ≤ y ⟹ y ≤ z + n2 ⟹ x ≤ z + (n2-n1)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>trans4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n1 &gt; n2 ⟹ (x::nat) + n1 ≤ y ⟹ y ≤ z + n2 ⟹ x + (n1-n2) ≤ z"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>trans5</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x::nat) ≤ y + n1 ⟹ y + n2 ≤ z ⟹ x ≤ z + (n1-n2)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>trans6</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n2 &gt; n1 ⟹ (x::nat) ≤ y + n1 ⟹ y + n2 ≤ z ⟹ x + (n2-n1) ≤ z"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Resolve. *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>single_resolve</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n &gt; 0 ⟹ (x::nat) + n ≤ x ⟹ False"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>single_resolve_const</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n &gt; 0 ⟹ (x::nat) + n ≤ 0 ⟹ False"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Comparison with constants. *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>cv_const1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x::nat) + n ≤ y ⟹ 0 + (x+n) ≤ y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* x is const *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>cv_const2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x::nat) + n ≤ y ⟹ x ≤ 0 + (y-n)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* y is const *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>cv_const3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y &lt; n ⟹ (x::nat) + n ≤ y ⟹ x + (n-y) ≤ 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* y is const (contradiction with 0 ≤ x) *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>cv_const4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x::nat) ≤ y + n ⟹ 0 + (x-n) ≤ y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* x is const *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>cv_const5</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x::nat) ≤ y + n ⟹ 0 ≤ y + (n-x)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* x is const (trivial) *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>cv_const6</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x::nat) ≤ y + n ⟹ x ≤ 0 + (y+n)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* y is const *)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Misc *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>nat_eq_to_ineqs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x::nat) = y + n ⟹ x ≤ y + n ∧ x ≥ y + n"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>nat_ineq_impl_not_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x::nat) + n ≤ y ⟹ n &gt; 0 ⟹ x ≠ y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>eq_to_ineqs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x::nat) ≡ y ⟹ x ≤ y ∧ y ≤ x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>ineq_to_eqs1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x::nat) ≤ y + 0 ⟹ y ≤ x + 0 ⟹ x = y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹arith.ML›</span></span></span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹order.ML›</span></span></span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹order_test.ML›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹register_wellform_data ("(a::nat) - b", ["a ≥ b"])›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_prfstep_check_req ("(a::nat) - b", "(a::nat) ≥ b")›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Normalize any expression to "a - b" form. *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nat_sub_norm</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(a::nat) = a - 0 ∧ a ≥ 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Adding and subtracting two normalized expressions. *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nat_sub1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(a::nat) ≥ b ⟹ c ≥ d ⟹ (a - b) + (c - d) = (a + c) - (b + d) ∧ a + c ≥ b + d"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nat_sub2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(a::nat) ≥ b ⟹ c ≥ d ⟹ a - b ≥ c - d ⟹ (a - b) - (c - d) = (a + d) - (b + c) ∧ a + d ≥ b + c"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nat_sub3</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(a::nat) ≥ b ⟹ c ≥ d ⟹ (a - b) * (c - d) = (a * c + b * d) - (a * d + b * c) ∧ a * c + b * d ≥ a * d + b * c"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>diff_mult_distrib</span><span> </span><span>mult.commute</span><span> </span><span>mult_le_mono1</span><span> </span><span>nat_sub2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Cancel identical terms on two sides, yielding a normalized expression. *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nat_sub_combine</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(a::nat) + b ≥ c + b ⟹ (a + b) - (c + b) = a - c ∧ a ≥ c"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nat_sub_combine2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"n ≥ m ⟹ (a::nat) + b * n ≥ c + b * m ⟹ (a + b * n) - (c + b * m) = (a + b * (n - m)) - c ∧ a + b * (n - m) ≥ c ∧ n ≥ m"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add.commute</span><span> </span><span>right_diff_distrib'</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nat_sub_combine3</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"n ≤ m ⟹ (a::nat) + b * n ≥ c + b * m ⟹ (a + b * n) - (c + b * m) = a - (c + b * (m - n)) ∧ a ≥ c + b * (m - n) ∧ m ≥ n"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>add.commute</span><span> </span><span>mult.commute</span><span> </span><span>nat_diff_add_eq2</span><span> </span><span>nat_le_add_iff1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹nat_sub.ML›</span></span></span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹nat_sub_test.ML›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Ordering on Nats. *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>le_neq_implies_less'</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(m::nat) ≠ n ⟹ m ≤ n ⟹ m &lt; n"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>le_zero_to_equal_zero</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(n::nat) ≤ 0 ⟹ n = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>less_one_to_equal_zero</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(n::nat) &lt; 1 ⟹ n = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward_prfstep_cond @{thm Nat.mult_le_mono1} [with_cond "?k ≠ 1"]›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_resolve_prfstep @{thm Nat.not_add_less1}›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_minus_less</span><span> </span><span class="delimiter">[</span><span>resolve</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬(i::nat) &lt; (i - j)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nat_le_prod_with_same</span><span> </span><span class="delimiter">[</span><span>backward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"m ≠ 0 ⟹ (n::nat) ≤ m * n"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nat_le_prod_with_le</span><span> </span><span class="delimiter">[</span><span>backward1</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"k ≠ 0 ⟹ (n::nat) ≤ m ⟹ (n::nat) ≤ k * m"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le_trans</span><span> </span><span>nat_le_prod_with_same</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nat_plus_le_to_less</span><span> </span><span class="delimiter">[</span><span>backward1</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b ≠ 0 ⟹ (a::nat) + b ≤ c ⟹ a &lt; c"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nat_plus_le_to_less2</span><span> </span><span class="delimiter">[</span><span>backward1</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≠ 0 ⟹ (a::nat) + b ≤ c ⟹ b &lt; c"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep @{thm add_right_imp_eq}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep @{thm add_left_imp_eq}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule_cond @{thm Nat.le_diff_conv2} [with_term "?i + ?k"]›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nat_less_diff_conv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(i::nat) &lt; j - k ⟹ i + k &lt; j"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm nat_less_diff_conv} [with_cond "?k ≠ ?NUMC", with_term "?i + ?k"]›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Nat_le_diff_conv2_same</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i ≥ j ⟹ (i::nat) ≤ i - j ⟹ j = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nat_gt_zero</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b - a &gt; 0 ⟹ b &gt; (a::nat)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_minus_1_less_n</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(n::nat) ≥ 1 ⟹ n - 1 &lt; n"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm n_minus_1_less_n} [with_term "?n - 1"]›</span></span></span><span>
</span><span>  
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Monotonicity of ordering *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward_prfstep @{thm Nat.diff_le_mono}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward2_prfstep @{thm Nat.diff_less_mono}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward_prfstep @{thm Nat.mult_le_mono2}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_resolve_prfstep @{thm Nat.le_add1}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_resolve_prfstep @{thm Nat.le_add2}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward_prfstep @{thm add_left_mono}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward_prfstep @{thm add_right_mono}›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>add_mono_neutr</span><span> </span><span class="delimiter">[</span><span>backward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(0::'a::linordered_ring) ≤ b ⟹ a ≤ a + b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>add_mono_neutl</span><span> </span><span class="delimiter">[</span><span>backward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(0::'a::linordered_ring) ≤ b ⟹ a ≤ b + a"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep @{thm add_less_imp_less_left}›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sum_le_zero1</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a::'a::linordered_ring) + b &lt; 0 ⟹ a ≥ 0 ⟹ b &lt; 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>add_less_same_cancel1</span><span> </span><span>less_le_trans</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>less_sum1</span><span> </span><span class="delimiter">[</span><span>backward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b &gt; 0 ⟹ a &lt; a + (b::nat)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward_prfstep @{thm Nat.trans_less_add2}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward_prfstep @{thm Nat.add_less_mono1}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward1_prfstep @{thm Nat.add_less_mono}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward1_prfstep @{thm Nat.add_le_mono}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward1_prfstep @{thm add_increasing2}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward1_prfstep @{thm add_mono}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward_prfstep @{thm add_strict_left_mono}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward1_prfstep @{thm Nat.mult_le_mono}›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Addition. *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>nat_add_eq_self_zero</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(m::nat) = m + n ⟹ n = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>nat_add_eq_self_zero'</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(m::nat) = n + m ⟹ n = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>nat_mult_2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a::nat) + a = 2 * a"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule_cond @{thm nat_mult_2} [with_cond "?a ≠ 0"]›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>plus_one_non_zero</span><span> </span><span class="delimiter">[</span><span>resolve</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬(n::nat) + 1 = 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Diff. *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nat_same_minus_ge</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(c::nat) - a ≥ c - b ⟹ a ≤ c ⟹ a ≤ b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>arith</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_eq_zero</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(k::nat) ≤ j ⟹ j - k = 0 ⟹ j = k"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>diff_eq_zero'</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(k::nat) ≤ j ⟹ j - k + i = j ⟹ k = i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Divides. *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>dvd_defD1</span><span> </span><span class="delimiter">[</span><span>resolve</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a::nat) dvd b ⟹ ∃k. b = a * k"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dvdE</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>dvd_defD2</span><span> </span><span class="delimiter">[</span><span>resolve</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a::nat) dvd b ⟹ ∃k. b = k * a"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>dvd_mult_div_cancel</span><span> </span><span>mult.commute</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep @{thm Nat.dvd_imp_le}›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>dvd_ineq2</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(k::nat) dvd n ⟹ n &gt; 0 ⟹ k ≥ 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Suc_leI</span><span> </span><span>dvd_pos_nat</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm dvd_trans} (with_conds ["?a ≠ ?b", "?b ≠ ?c", "?a ≠ ?c"])›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm Nat.dvd_antisym} [with_cond "?m ≠ ?n"]›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>dvd_cancel</span><span> </span><span class="delimiter">[</span><span>backward1</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c &gt; 0 ⟹ (a::nat) * c dvd b * c ⟹ a dvd b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep (equiv_forward_th @{thm dvd_add_right_iff})›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Divisibility: existence. *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_resolve_prfstep @{thm dvd_refl}›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>exists_n_dvd_n</span><span> </span><span class="delimiter">[</span><span>backward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P (n::nat) ⟹ ∃k. k dvd n ∧ P k"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dvd_refl</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_resolve_prfstep @{thm one_dvd}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>any_n_dvd_0</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ (∃ k. k dvd (0::nat) ∧ P k) ⟹ ¬ (∃ k. P k)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>n_dvd_one</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(n::nat) dvd 1 ⟹ n = 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm n_dvd_one} [with_cond "?n ≠ 1"]›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Products. *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm mult_zero_left}›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prod_ineqs1</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(m::nat) * k &gt; 0 ⟹ m &gt; 0 ∧ k &gt; 0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prod_ineqs2</span><span> </span><span class="delimiter">[</span><span>backward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(k::nat) &gt; 0 ⟹ m ≤ m * k"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>prod_cancel</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a::nat) * b = a * c ⟹ a &gt; 0 ⟹ b = c"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm prod_cancel} [with_cond "?b ≠ ?c"]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>mult_n1n</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(n::nat) = m * n ⟹ n &gt; 0 ⟹ m = 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm mult_n1n} [with_cond "?m ≠ 1"]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>prod_is_one</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x::nat) * y = 1 ⟹ x = 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>prod_dvd_intro</span><span> </span><span class="delimiter">[</span><span>backward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(k::nat) dvd m ∨ k dvd n ⟹ k dvd m * n"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dvd_mult</span><span> </span><span>dvd_mult2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Definition of gcd. *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm gcd_dvd1} [with_term "gcd ?a ?b"]›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm gcd_dvd2} [with_term "gcd ?a ?b"]›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Coprimality. *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule_bidir @{thm coprime_iff_gcd_eq_1}›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>coprime_exp</span><span> </span><span class="delimiter">[</span><span>backward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"coprime d a ⟹ coprime (d::nat) (a ^ n)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward_prfstep @{thm coprime_exp}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm gcd.commute}›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>coprime_dvd_mult</span><span> </span><span class="delimiter">[</span><span>backward1</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"coprime (a::nat) b ⟹ a dvd c * b ⟹ a dvd c"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>coprime_dvd_mult_left_iff</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>coprime_dvd_mult'</span><span> </span><span class="delimiter">[</span><span>backward1</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"coprime (a::nat) b ⟹ a dvd b * c ⟹ a dvd c"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>coprime_dvd_mult_right_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>coprime_dvd</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"coprime (a::nat) b ⟹ p dvd a ⟹ p &gt; 1 ⟹ ¬ p dvd b"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>coprime_common_divisor_nat</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Powers. *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm power_0}›</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>power_ge_0</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"m ≠ 0 ⟹ p ^ m = p * (p ^ (m - 1))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>power_eq_if</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule_cond @{thm power_one} [with_cond "?n ≠ 0"]›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule_cond @{thm power_one_right} [with_cond "?a ≠ 1"]›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_gen_prfstep ("power_case_intro",
  [WithTerm @{term_pat "?p ^ (?FREE::nat)"}, CreateCase @{term_pat "(?FREE::nat) = 0"}])›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>one_is_power_of_any</span><span> </span><span class="delimiter">[</span><span>resolve</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃i. (1::nat) = a ^ i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>power.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm power_Suc}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>power_dvd</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(p::nat)^n dvd a ⟹ n ≠ 0 ⟹ p dvd a"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dvd_power</span><span> </span><span>dvd_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>power_eq_one</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(b::nat) ^ n = 1 ⟹ b = 1 ∨ n = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>Suc_lessI</span><span> </span><span>nat_zero_less_power_iff</span><span> </span><span>power_0</span><span> </span><span>power_inject_exp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm power_eq_one} (with_conds ["?b ≠ 1", "?n ≠ 0"])›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Factorial. *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>fact_ge_1_nat</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fact (n::nat) ≥ (1::nat)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm fact_ge_1_nat} [with_term "fact ?n"]›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward1_prfstep @{thm dvd_fact}›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Successor function. *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm Nat.Suc_eq_plus1}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward_prfstep @{thm Nat.gr0_implies_Suc}›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Cases *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms Nat.nat.case}›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Induction. *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nat_cases</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P 0 ⟹ (⋀n. P (Suc n)) ⟹ P n"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nat_induct</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* div *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>times_div_less_eq_dividend</span><span> </span><span class="delimiter">[</span><span>resolve</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  add_var_induct_rule @{thm nat_induct} #&gt;
  add_strong_induct_rule @{thm nat_less_induct} #&gt;
  add_cases_rule @{thm nat_cases}
›</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Set_Thms">
<div class="head"><h1>Theory Set_Thms</h1>
<span class="command">theory</span> <span class="name">Set_Thms</span><br/>
<span class="keyword">imports</span> <a href="Logic_Thms.html"><span class="name">Logic_Thms</span></a> <a href="Multiset.html"><span class="name">Multiset</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  File: Set_Thms.thy
  Author: Bohua Zhan

  Setup of proof steps related to sets.
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Setup for sets and multisets›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Set_Thms</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Logic_Thms</span><span> </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Multiset"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Set›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Injective functions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward_prfstep @{thm injI}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹AC property of intersection and union›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold ACUtil.add_ac_data [
  {cfhead = @{cterm inf}, unit = SOME @{cterm inf},
   assoc_th = @{thm inf_assoc}, comm_th = @{thm inf_commute},
   unitl_th = @{thm inf_top_left}, unitr_th = @{thm inf_top_right}},

  {cfhead = @{cterm sup}, unit = SOME @{cterm bot},
   assoc_th = @{thm sup_assoc}, comm_th = @{thm sup_commute},
   unitl_th = @{thm sup_bot_left}, unitr_th = @{thm sup_bot_right}}]
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Collection and bounded quantification›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm Set.mem_Collect_eq}›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ball_single</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀x∈{x}. P x) = P x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Membership›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm Set.singleton_iff}›</span></span></span><span> 
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep (equiv_forward_th @{thm Set.empty_iff})›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_membership_distinct</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ s ⟹ y ∉ s ⟹ x ≠ y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>non_empty_exist_elt</span><span> </span><span class="delimiter">[</span><span>backward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"U ≠ {} ⟹ ∃x. x ∈ U"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>non_univ_exist_compl</span><span> </span><span class="delimiter">[</span><span>backward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"U ≠ UNIV ⟹ ∃x. x ∉ U"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_resolve_prfstep @{thm Set.UNIV_I}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Insert›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward_prfstep_cond (equiv_backward_th @{thm Set.insert_iff}) [with_cond "?A ≠ {}"]›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond (equiv_forward_th @{thm Set.insert_iff})
  [with_score 500, with_cond "?A ≠ {}"]›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond (equiv_forward_th @{thm Set.insert_subset}) [with_cond "?A ≠ {}"]›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward_prfstep_cond (equiv_backward_th @{thm Set.insert_subset})
  [with_score 500, with_cond "?A ≠ {}"]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Extensionality›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_ext</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀a. a ∈ S ⟷ a ∈ T ⟹ S = T"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward_prfstep_cond @{thm set_ext} [with_score 500, with_filt (order_filter "S" "T")]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_pair_ext</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀a b. (a, b) ∈ S ⟷ (a, b) ∈ T ⟹ S = T"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Union›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond (equiv_forward_th @{thm Set.Un_iff}) [with_score 500]›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward_prfstep (equiv_backward_th @{thm Set.Un_iff})›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>UnD1</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c ∈ A ∪ B ⟹ c ∉ A ⟹ c ∈ B"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>UnD2</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c ∈ A ∪ B ⟹ c ∉ B ⟹ c ∈ A"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>UnD1_single</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c ∈ {a} ∪ B ⟹ c ≠ a ⟹ c ∈ B"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>UnD2_single</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"c ∈ A ∪ {b} ⟹ c ≠ b ⟹ c ∈ A"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm Set.UnI1} [with_term "?A ∪ ?B"]›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm Set.UnI2} [with_term "?A ∪ ?B"]›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>UnI1_single</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ {a} ∪ B"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>UnI2_single</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∈ A ∪ {b}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm UnI1_single} [with_term "{?a} ∪ ?B"]›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm UnI2_single} [with_term "?A ∪ {?b}"]›</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>union_single_eq</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">,</span><span> </span><span>backward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ p ⟹ {x} ∪ p = p"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Intersection›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep (equiv_forward_th @{thm Set.Int_iff})›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward_prfstep_cond (equiv_backward_th @{thm Set.Int_iff}) [with_score 500]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm Set.Int_empty_left}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm Set.Int_empty_right}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm Set.Int_absorb}›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_disjoint_mp</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">,</span><span> </span><span>backward2</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ∩ B = {} ⟹ p ∈ A ⟹ p ∉ B"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_disjoint_single</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{x} ∩ B = {} ⟷ x ∉ B"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹subset›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep @{thm subsetI}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward_prfstep_cond @{thm subsetI} [with_score 500]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_resolve_prfstep @{thm empty_subsetI}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep @{thm subsetD}›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subset_single</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{a} ⊆ B ⟷ a ∈ B"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_resolve_prfstep @{thm Set.basic_monos(1)}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_resolve_prfstep @{thm Set.Un_upper1}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_resolve_prfstep @{thm Set.Un_upper2}›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>union_is_subset</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ∪ B ⊆ C ⟹ A ⊆ C ∧ B ⊆ C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward1_prfstep @{thm Set.Un_least}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward2_prfstep @{thm Set.Un_least}›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subset_union_same1</span><span> </span><span class="delimiter">[</span><span>backward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"B ⊆ C ⟹ A ∪ B ⊆ A ∪ C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subset_union_same2</span><span> </span><span class="delimiter">[</span><span>backward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ⊆ B ⟹ A ∪ C ⊆ B ∪ C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Diff›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep (equiv_forward_th @{thm Set.Diff_iff})›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward_prfstep_cond (equiv_backward_th @{thm Set.Diff_iff}) [with_score 500]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm Set.empty_Diff}›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mem_diff</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ A - B ⟷ x ∈ A ∧ x ∉ B"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_union_minus_same1</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(A ∪ B) - B = A - B"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_union_minus_same2</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(B ∪ A) - B = A - B"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_union_minus_distinct</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≠ c ⟹ {a} ∪ (B - {c}) = {a} ∪ B - {c}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm Set.Diff_subset} [with_term "?A - ?B"]›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>union_subtract_elt1</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∉ B ⟹ ({x} ∪ B) - {x} = B"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>union_subtract_elt2</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∉ B ⟹ (B ∪ {x}) - {x} = B"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subset_sub1</span><span> </span><span class="delimiter">[</span><span>backward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ A ⟹ A - {x} ⊂ A"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>member_notin</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ S - {y} ⟹ x ≠ y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>member_notin_contra</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ S ⟹ x ≠ y ⟹ x ∈ S - {y}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm member_notin_contra} [with_term "?S - {?y}"]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Results on finite sets›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_resolve_prfstep @{thm Finite_Set.finite.emptyI}›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_finite_single</span><span> </span><span class="delimiter">[</span><span>resolve</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite {x}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm Finite_Set.finite_Un}›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Max_ge'</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite A ⟹ x &gt; Max A ⟹ ¬(x ∈ A)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Max_ge</span><span> </span><span>leD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward_prfstep @{thm finite_image_set}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep @{thm finite_atLeastAtMost}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep @{thm rev_finite_subset}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward1_prfstep @{thm rev_finite_subset}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Cardinality›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm card_empty}›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>card_emptyD</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite S ⟹ card S = 0 ⟹ S = {}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>card_minus1</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ S ⟹ card (S - {x}) = card S - 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>card_Diff_subset</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep @{thm finite_Diff}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_resolve_prfstep @{thm card_mono}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Image set›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm Set.image_Un}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm image_set_diff}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Multiset›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Basic properties›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mset_member_empty</span><span> </span><span class="delimiter">[</span><span>resolve</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬p ∈# {#}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mem_multiset_single</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈# {#y#} ⟷ x = y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward2_prfstep @{thm subset_mset.antisym}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_resolve_prfstep @{thm Multiset.empty_le}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep @{thm mset_subsetD}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>multi_contain_add_self1</span><span> </span><span class="delimiter">[</span><span>resolve</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ⊂# {#x#} + A"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>multi_contain_add_self2</span><span> </span><span class="delimiter">[</span><span>resolve</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ⊂# A + {#x#}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm Multiset.multi_member_this} [with_term "{#?x#} + ?XS"]›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>multi_member_this2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈# XS + {#x#}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm multi_member_this2} [with_term "?XS + {#?x#}"]›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward_prfstep @{thm Multiset.subset_mset.add_left_mono}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward_prfstep @{thm Multiset.subset_mset.add_right_mono}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Case checking and induction›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>multi_nonempty_split'</span><span> </span><span class="delimiter">[</span><span>resolve</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"M ≠ {#} ⟹ ∃M' m. M = M' + {#m#}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>multi_nonempty_split</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>multi_member_split'</span><span> </span><span class="delimiter">[</span><span>backward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈# M ⟹ ∃M'. M = M' + {#x#}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>insert_DiffM2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_strong_induct_rule @{thm full_multiset_induct}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Results on mset›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm set_mset_empty}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm set_mset_single}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm set_mset_union}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm image_mset_empty}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm image_mset_single}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm image_mset_union}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm prod_mset_empty}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm prod_mset_singleton}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm prod_mset_Un}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Set interval›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm Set_Interval.ord_class.lessThan_iff}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm Set_Interval.ord_class.atLeastAtMost_iff}›</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Lists_Thms">
<div class="head"><h1>Theory Lists_Thms</h1>
<span class="command">theory</span> <span class="name">Lists_Thms</span><br/>
<span class="keyword">imports</span> <a href="Set_Thms.html"><span class="name">Set_Thms</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  File: Lists_Thms.thy
  Author: Bohua Zhan

  Setup for proof steps related to lists.
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Setup for lists›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Lists_Thms</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Set_Thms</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Definition of lists›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_resolve_prfstep @{thm list.distinct(2)}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep (equiv_forward_th @{thm list.simps(1)})›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms List.list.sel}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm list.collapse}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_var_induct_rule @{thm list.induct}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Length›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm List.list.size(3)}›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>length_one</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length [x] = 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>length_Cons</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length (a # b) = length b + 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>length_snoc</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length (xs @ [x]) = length xs + 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>length_zero_is_nil</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length xs = 0 ⟹ xs = []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>length_gt_zero</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length xs &gt; 0 ⟹ xs ≠ []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Append›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm List.length_append}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule_cond @{thm List.append.simps(2)} [with_cond "?xs ≠ []"]›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm List.hd_append2}›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>append_is_empty</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"xs @ ys = [] ⟹ xs = [] ∧ ys = []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cons_to_append</span><span> </span><span class="delimiter">[</span><span>rewrite_back</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a # b = [a] @ b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹list_ac.ML›</span></span></span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹list_ac_test.ML›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Showing two lists are equal›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward2_prfstep_cond @{thm nth_equalityI} [with_filt (order_filter "xs" "ys")]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Set of elements of a list›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm List.set_simps(1)}›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_one</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set [u] = {u}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_two</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set [u, v] = {u, v}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_simps2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set (x # xs) = {x} ∪ set xs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule_cond @{thm set_simps2} [with_cond "?xs ≠ []", with_cond "?xs ≠ [?y]"]›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm List.set_append}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm List.set_rev}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_resolve_prfstep @{thm List.finite_set}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward_prfstep (equiv_forward_th @{thm in_set_conv_nth})›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹hd›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹register_wellform_data ("hd xs", ["xs ≠ []"])›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm List.hd_in_set} [with_term "hd ?xs"]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹tl›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm length_tl}›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nth_tl'</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length (tl xs) ⟹ tl xs ! i = xs ! (i + 1)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nth_tl</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_tl_subset</span><span> </span><span class="delimiter">[</span><span>forward_arg1</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set (tl xs) ⊆ set xs"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>list.set_sel</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>subsetI</span><span> </span><span>tl_Nil</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹nth›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹register_wellform_data ("xs ! i", ["i &lt; length xs"])›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_prfstep_check_req ("xs ! i", "i &lt; length xs")›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule_back @{thm hd_conv_nth}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm List.nth_Cons'}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm List.nth_append}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm nth_mem} [with_term "?xs ! ?n"]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sorted›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sorted_Nil</span><span> </span><span class="delimiter">[</span><span>resolve</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sorted []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sorted_single</span><span> </span><span class="delimiter">[</span><span>resolve</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sorted [x]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward_prfstep (equiv_backward_th @{thm sorted.simps(2)})›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sorted_ConsD1</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sorted (x # xs) ⟹ sorted xs"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sorted.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sorted_ConsD2</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">,</span><span> </span><span>backward2</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sorted (x # xs) ⟹ y ∈ set xs ⟹ x ≤ y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sorted.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sorted_appendI</span><span> </span><span class="delimiter">[</span><span>backward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sorted xs ∧ sorted ys ∧ (∀x∈set xs. ∀y∈set ys. x ≤ y) ⟹ sorted (xs @ ys)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sorted_append</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sorted_appendE</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sorted (xs @ ys) ⟹ sorted xs ∧ sorted ys"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>sorted_append</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sorted_appendE2</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sorted (xs @ ys) ⟹ x ∈ set xs ⟹ ∀y∈set ys. x ≤ y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sorted_append</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sorted_nth_mono'</span><span> </span><span class="delimiter">[</span><span>backward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sorted xs ⟹ j &lt; length xs ⟹ i ≤ j ⟹ xs ! i ≤ xs ! j"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sorted_nth_mono</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sorted_nth_mono_less</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sorted xs ⟹ i &lt; length xs ⟹ xs ! i &lt; xs ! j ⟹ i &lt; j"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>leD</span><span> </span><span>not_le_imp_less</span><span> </span><span>sorted_nth_mono</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sort›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm sorted_sort} [with_term "sort ?xs"]›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm length_sort}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm mset_sort}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm set_sort}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward_prfstep @{thm properties_for_sort}›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sort_Nil</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sort [] = []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sort_singleton</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sort [a] = [a]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹distinct›</span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>distinct_Nil</span><span> </span><span class="delimiter">[</span><span>resolve</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"distinct []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_resolve_prfstep @{thm List.distinct_singleton}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule_cond @{thm distinct.simps(2)} [with_cond "?xs ≠ []"]›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm distinct_append}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm distinct_rev}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm distinct_sort}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_resolve_prfstep (equiv_backward_th @{thm distinct_conv_nth})›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>distinct_nthE</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"distinct xs ⟹ i &lt; length xs ⟹ j &lt; length xs ⟹ xs ! i = xs ! j ⟹ i = j"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nth_eq_iff_index_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹map function›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms List.list.map}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm List.length_map}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm List.nth_map}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm List.map_append}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Replicate›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_arg_rule @{thm length_replicate}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm List.nth_replicate}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹last›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹register_wellform_data ("last xs", ["xs ≠ []"])›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>last_eval1</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"last [x] = x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>last_eval2</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"last [u, v] = v"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm List.last_ConsR}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm List.last_appendR}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm List.last_snoc}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule_back @{thm last_conv_nth}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm List.last_in_set} [with_term "last ?as"]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹butlast›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_arg_rule @{thm List.length_butlast}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm List.nth_butlast}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule_back @{thm List.butlast_conv_take}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm List.butlast_snoc}›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>butlast_eval1</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"butlast [x] = []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>butlast_eval2</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"butlast [x, y] = [x]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>butlast_cons</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"as ≠ [] ⟹ butlast (a # as) = a # butlast as"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>butlast_append'</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bs ≠ [] ⟹ butlast (as @ bs) = as @ butlast bs"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>butlast_append</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm List.append_butlast_last_id}›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_butlast_is_subset</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set (butlast xs) ⊆ set xs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>in_set_butlastD</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_arg1_prfstep @{thm set_butlast_is_subset}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹List update›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹register_wellform_data ("xs[i := x]", ["i &lt; length xs"])›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_arg_rule @{thm List.length_list_update}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm List.nth_list_update_eq}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm List.nth_list_update_neq}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm List.nth_list_update}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹take›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹register_wellform_data ("take n xs", ["n ≤ length xs"])›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_prfstep_check_req ("take n xs", "n ≤ length xs")›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>length_take</span><span> </span><span class="delimiter">[</span><span>rewrite_arg</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n ≤ length xs ⟹ length (take n xs) = n"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nth_take</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length (take n xs) ⟹ take n xs ! i = xs ! i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm List.take_0}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm List.take_Suc_conv_app_nth}›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>take_length</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"take (length xs) xs = xs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_arg1_prfstep @{thm List.set_take_subset}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>take_Suc</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc n ≤ length xs ⟹ take (Suc n) xs = take n xs @ [nth xs n]"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc_le_lessD</span><span> </span><span>take_Suc_conv_app_nth</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm List.take_update_cancel}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm List.append_take_drop_id}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm List.take_all}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹drop›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_arg_rule @{thm List.length_drop}›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nth_drop</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"i &lt; length (drop n xs) ⟹ drop n xs ! i = xs ! (n + i)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm List.drop_0}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm List.drop_all}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule_back @{thm List.take_drop}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm List.drop_drop}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹rev›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_arg_rule @{thm List.length_rev}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms List.rev.simps}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm List.rev_append}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm List.rev_rev_ident}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹filter›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms filter.simps}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm filter_append}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule_bidir @{thm rev_filter}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹concat›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹fold add_rewrite_rule @{thms concat.simps}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹mset›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm mset.simps(1)}›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mset_simps_2</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mset (a # x) = mset x + {#a#}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm mset_append}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm mset_eq_setD}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule_cond @{thm in_multiset_in_set} [with_term "set ?xs"]›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule_back_cond @{thm in_multiset_in_set} [with_term "mset ?xs"]›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward_prfstep @{thm Multiset.nth_mem_mset}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_mset_conv_nth</span><span> </span><span class="delimiter">[</span><span>resolve</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈# mset xs ⟹ ∃i&lt;length xs. x = xs ! i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>in_multiset_in_set</span><span> </span><span>in_set_conv_nth</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hd_in_mset</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"xs ≠ [] ⟹ hd xs ∈# mset xs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm hd_in_mset} [with_term "hd ?xs", with_term "mset ?xs"]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>last_in_mset</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"xs ≠ [] ⟹ last xs ∈# mset xs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm last_in_mset} [with_term "last ?xs", with_term "mset ?xs"]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Relationship between mset and set of lists›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mset_butlast</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"xs ≠ [] ⟹ mset (butlast xs) = mset xs - {# last xs #}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_diff_cancel_right'</span><span> </span><span>append_butlast_last_id</span><span> </span><span>mset.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>mset.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>union_code</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>insert_mset_to_set</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mset xs' = mset xs + {# x #} ⟹ set xs' = set xs ∪ {x}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>set_mset_mset</span><span> </span><span>set_mset_single</span><span> </span><span>set_mset_union</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>delete_mset_to_set</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"distinct xs ⟹ mset xs' = mset xs - {# x #} ⟹ set xs' = set xs - {x}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>mset_eq_setD</span><span> </span><span>mset_remove1</span><span> </span><span>set_remove1_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>update_mset_to_set</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"distinct xs ⟹ mset xs' = {# y #} + (mset xs - {# x #}) ⟹ set xs' = (set xs - {x}) ∪ {y}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>insert_mset_to_set</span><span> </span><span>mset_remove1</span><span> </span><span>set_remove1_eq</span><span> </span><span>union_commute</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mset_update'</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"i &lt; length ls ⟹ mset (ls[i := v]) = {#v#} + (mset ls - {# ls ! i #})"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mset_update</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹swap›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm mset_swap}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm set_swap}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹upto lists›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>upt_zero_length</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length [0..&lt;n] = n"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nth_upt_zero</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length [0..&lt;n] ⟹ [0..&lt;n] ! i = i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Lambda lists›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>list</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(nat ⇒ 'a) ⇒ nat ⇒ 'a list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"list s n = map s [0 ..&lt; n]"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_length</span><span> </span><span class="delimiter">[</span><span>rewrite_arg</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length (list s n) = n"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>list_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_nth</span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length (list s n) ⟹ (list s n) ! i = s i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>list_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Splitting of lists›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_resolve_prfstep @{thm split_list}›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_backward_prfstep @{thm not_distinct_decomp}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Finiteness›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_resolve_prfstep @{thm finite_lists_length_le}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Cardinality›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_rewrite_rule @{thm distinct_card}›</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Auto2_Main">
<div class="head"><h1>Theory Auto2_Main</h1>
<span class="command">theory</span> <span class="name">Auto2_Main</span><br/>
<span class="keyword">imports</span> <a href="Arith_Thms.html"><span class="name">Arith_Thms</span></a> <a href="Lists_Thms.html"><span class="name">Lists_Thms</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  File: Auto2_Main.thy
  Author: Bohua Zhan

  Setup of auto2 for basic theorems in Main.
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Auto2_Main</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Arith_Thms</span><span> </span><span>Lists_Thms</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Auto2_Test">
<div class="head"><h1>Theory Auto2_Test</h1>
<span class="command">theory</span> <span class="name">Auto2_Test</span><br/>
<span class="keyword">imports</span> <a href="Auto2_Main.html"><span class="name">Auto2_Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  File: Auto2_Test.thy
  Author: Bohua Zhan

  Unit tests for auto2.
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Auto2_Test</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Auto2_Main</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹util_test.ML›</span></span></span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹rewrite_test.ML›</span></span></span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹matcher_test.ML›</span></span></span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹normalize_test.ML›</span></span></span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹logic_steps_test.ML›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_file</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹acdata_test.ML›</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Pelletier">
<div class="head"><h1>Theory Pelletier</h1>
<span class="command">theory</span> <span class="name">Pelletier</span><br/>
<span class="keyword">imports</span> <a href="Logic_Thms.html"><span class="name">Logic_Thms</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  File: Pelletier.thy
  Author: Bohua Zhan

  Pelletier's problems. From the paper "Seventy-five problems for testing
  automatic theorem provers" by Francis Jeffry Pelletier.
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Pelletier's problems›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Pelletier</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Logic_Thms</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>p1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(p ⟶ q) ⟷ (¬q ⟶ ¬p)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>p2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(¬¬p) ⟷ p"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>p3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬(p ⟶ q) ⟹ q ⟶ p"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>p4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(¬p ⟶ q) ⟷ (¬q ⟶ p)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>p5</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(p ∨ q) ⟶ (p ∨ r) ⟹ p ∨ (q ⟶ r)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>p6</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p ∨ ¬p"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>p7</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p ∨ ¬¬¬p"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>p8</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"((p ⟶ q) ⟶ p) ⟹ p"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>p9</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(p ∨ q) ∧ (¬p ∨ q) ∧ (p ∨ ¬q) ⟹ ¬(¬p ∨ ¬q)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>p10</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"q ⟶ r ⟹ r ⟶ p ∧ q ⟹ p ⟶ q ∨ r ⟹ p ⟷ q"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>p11</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p ⟷ p"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>p12</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"((p ⟷ q) ⟷ r) ⟷ (p ⟷ (q ⟷ r))"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"q"</span></span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>p13</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p ∨ (q ∧ r) ⟷ (p ∨ q) ∧ (p ∨ r)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>p14</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(p ⟷ q) ⟷ ((q ∨ ¬p) ∧ (¬q ∨ p))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>p15</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(p ⟶ q) ⟷ (¬p ∨ q)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>p16</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(p ⟶ q) ∨ (q ⟶ p)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>p17</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(p ∧ (q ⟶ r) ⟶ s) ⟷ (¬p ∨ q ∨ s) ∧ (¬p ∨ ¬r ∨ s)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>p18</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃y::'a. ∀x. F(y) ⟶ F(x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. F(x)"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y::'a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y = y"</span></span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. F(y) ⟶ F(x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬F(y)"</span></span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. F(y) ⟶ F(x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>p19</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃x::'a. ∀y z. (P(y) ⟶ Q(z)) ⟶ (P(x) ⟶ Q(x))"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃x. P(x) ⟶ Q(x)"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P(x) ⟶ Q(x)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀y z. (P(y) ⟶ Q(z)) ⟶ (P(x) ⟶ Q(x))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x::'a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀y z. (P(y) ⟶ Q(z)) ⟶ (P(x) ⟶ Q(x))"</span></span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>p20</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x y. ∃z. ∀w. P(x) ∧ Q(y) ⟶ R(z) ∧ S(w) ⟹
  ∃x y. P(x) ∧ Q(y) ⟹ ∃z. R(z)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P(x)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Q(y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>z</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀w. P(x) ∧ Q(y) ⟶ R(z) ∧ S(w)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>p21</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃x. p ⟶ F(x) ⟹ ∃x. F(x) ⟶ p ⟹ ∃x. p ⟷ F(x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p"</span></span></span><span> </span><span class="delimiter">@with</span><span> </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"F(x)"</span></span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ⟷ F(x)"</span></span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬p"</span></span></span><span> </span><span class="delimiter">@with</span><span> </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬F(x)"</span></span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p ⟷ F(x)"</span></span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>p22</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x::'a. p ⟷ F(x) ⟹ p ⟷ (∀x. F(x))"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p"</span></span></span><span> </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x::'a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = x"</span></span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>p23</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀x::'a. p ∨ F(x)) ⟷ (p ∨ (∀x. F(x)))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>p29</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃x. F(x) ⟹ ∃x. G(x) ⟹
  ((∀x. F(x) ⟶ H(x)) ∧ (∀x. G(x) ⟶ J(x))) ⟷
  (∀x y. F(x) ∧ G(y) ⟶ H(x) ∧ J(y))"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"F(a)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"G(b)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x y. F(x) ∧ G(y) ⟶ H(x) ∧ J(y)"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. F(x) ⟶ H(x)"</span></span></span><span> </span><span class="delimiter">@with</span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"F(x) ∧ G(b)"</span></span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀y. G(y) ⟶ J(y)"</span></span></span><span> </span><span class="delimiter">@with</span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"F(a) ∧ G(y)"</span></span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>p30</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. F(x) ∨ G(x) ⟶ ¬H(x) ⟹
  ∀x. (G(x) ⟶ ¬I(x)) ⟶ F(x) ∧ H(x) ⟹ ∀x. I(x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. I(x)"</span></span></span><span> </span><span class="delimiter">@with</span><span> </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"F(x)"</span></span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>p31</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬(∃x. F(x) ∧ (G(x) ∨ H(x))) ⟹ ∃x. I(x) ∧ F(x) ⟹ ∀x. ¬H(x) ⟶ J(x) ⟹
  ∃x. I(x) ∧ J(x)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>p32</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. (F(x) ∧ (G(x) ∨ H(x))) ⟶ I(x) ⟹ ∀x. I(x) ∧ H(x) ⟶ J(x) ⟹
  ∀x. K(x) ⟶ H(x) ⟹ ∀x. F(x) ∧ K(x) ⟶ J(x)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>p33</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀x. p(a) ∧ (p(x) ⟶ p(b)) ⟶ p(c)) ⟷
  (∀x. (¬p(a) ∨ p(x) ∨ p(c)) ∧ (¬p(a) ∨ ¬p(b) ∨ p(c)))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>p35</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃(x::'a) (y::'b). P(x,y) ⟶ (∀x y. P(x,y))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>p39</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬(∃x. ∀y. F(y,x) ⟷ ¬F(y,y))"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@contradiction</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀y. F(y,x) ⟷ ¬F(y,y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"F(x,x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Note there is a typo in the original text. *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>p40</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃y. ∀x. F(x,y) ⟷ F(x,x) ⟹ ¬(∀x. ∃y. ∀z. F(z,y) ⟷ ¬F(z,x))"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>A</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. F(x,A) ⟷ F(x,x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬(∃y. ∀z. F(z,y) ⟷ ¬F(z,A))"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="delimiter">(</span><span class="delimiter">@rule</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀y. ¬(∀z. F(z,y) ⟷ ¬F(z,A))"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>      </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬(F(y,y) ⟷ ¬F(y,A))"</span></span></span><span> </span><span class="delimiter">@with</span><span> </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"F(y,y)"</span></span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>p42</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬(∃y. ∀x. F(x,y) ⟷ ¬(∃z. F(x,z) ∧ F(z,x)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@contradiction</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. F(x,y) ⟷ ¬(∃z. F(x,z) ∧ F(z,x))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"F(y,y)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>p43</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x y. Q(x,y) ⟷ (∀z. F(z,x) ⟷ F(z,y)) ⟹
  ∀x y. Q(x,y) ⟷ Q(y,x)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>p47</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(∀x. P1(x) ⟶ P0(x)) ∧ (∃x. P1(x)) ⟹
   (∀x. P2(x) ⟶ P0(x)) ∧ (∃x. P2(x)) ⟹
   (∀x. P3(x) ⟶ P0(x)) ∧ (∃x. P3(x)) ⟹
   (∀x. P4(x) ⟶ P0(x)) ∧ (∃x. P4(x)) ⟹
   (∀x. P5(x) ⟶ P0(x)) ∧ (∃x. P5(x)) ⟹
   (∃x. Q1(x)) ∧ (∀x. Q1(x) ⟶ Q0(x)) ⟹
   ∀x. P0(x) ⟶ ((∀y. Q0(y) ⟶ R(x,y)) ∨
                   (∀y. P0(y) ∧ S(y,x) ∧ (∃z. Q0(z) ∧ R(y,z)) ⟶ R(x,y))) ⟹
   ∀x y. P3(y) ∧ (P5(x) ∨ P4(x)) ⟶ S(x,y) ⟹
   ∀x y. P3(x) ∧ P2(y) ⟶ S(x,y) ⟹
   ∀x y. P2(x) ∧ P1(y) ⟶ S(x,y) ⟹
   ∀x y. P1(x) ∧ (P2(y) ∨ Q1(y)) ⟶ ¬R(x,y) ⟹
   ∀x y. P3(x) ∧ P4(y) ⟶ R(x,y) ⟹
   ∀x y. P3(x) ∧ P5(y) ⟶ ¬R(x,y) ⟹
   ∀x. P4(x) ∨ P5(x) ⟶ (∃y. Q0(y) ∧ R(x,y)) ⟹
   ∃x y. P0(x) ∧ P0(y) ∧ (∃z. Q1(z) ∧ R(y,z) ∧ R(x,y))"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>x1</span><span> </span><span>x2</span><span> </span><span>x3</span><span> </span><span>x4</span><span> </span><span>x5</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P1(x1)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P2(x2)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P3(x3)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P4(x4)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P5(x5)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S(x3,x2)"</span></span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S(x2,x1)"</span></span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"R(x3,x4)"</span></span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬R(x3,x5)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>p48</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a = b ∨ c = d ⟹ a = c ∨ b = d ⟹ a = d ∨ b = c"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>p49</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃x y. ∀(z::'a). z = x ∨ z = y ⟹ P(a) ∧ P(b) ⟹ (a::'a) ≠ b ⟹ ∀x. P(x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀(z::'a). z = x ∨ z = y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = a ∨ x = b"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀c. P(c)"</span></span></span><span> </span><span class="delimiter">@with</span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c = a ∨ c = b"</span></span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>p50</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. F(a,x) ∨ (∀y. F(x,y)) ⟹ ∃x. ∀y. F(x,y)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀y. F(a,y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬F(a,y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="delimiter">(</span><span class="delimiter">@rule</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀z. F(a,y) ∨ F(y,z)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>p51</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃z w. ∀x y. F(x,y) ⟷ x = z ∧ y = w ⟹
  ∃z. ∀x. (∃w. ∀y. F(x,y) ⟷ y = w) ⟷ x = z"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>z</span><span> </span><span>w</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x y. F(x,y) ⟷ x = z ∧ y = w"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. (∃w. ∀y. F(x,y) ⟷ y = w) ⟷ x = z"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = z"</span></span></span><span> </span><span class="delimiter">@with</span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀y. F(x,y) ⟷ y = w"</span></span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>p52</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃z w. ∀x y. F(x,y) ⟷ x = z ∧ y = w ⟹
  ∃w. ∀y. (∃z. ∀x. F(x,y) ⟷ x = z) ⟷ y = w"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>z</span><span> </span><span>w</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x y. F(x,y) ⟷ x = z ∧ y = w"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span class="string"><span class="delete"><span class="delete">"∀y. (∃z. ∀x. F(x,y) ⟷ x = z) ⟷ y = w"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y = w"</span></span></span><span> </span><span class="delimiter">@with</span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. F(x,y) ⟷ x = z"</span></span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>p55</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∃x. L(x) ∧ K(x,a) ⟹
   L(a) ∧ L(b) ∧ L(c) ⟹
   ∀x. L(x) ⟶ x = a ∨ x = b ∨ x = c ⟹
   ∀y x. K(x,y) ⟶ H(x,y) ⟹
   ∀x y. K(x,y) ⟶ ¬R(x,y) ⟹
   ∀x. H(a,x) ⟶ ¬H(c,x) ⟹
   ∀x. x ≠ b ⟶ H(a,x) ⟹
   ∀x. ¬R(x,a) ⟶ H(b,x) ⟹
   ∀x. H(a,x) ⟶ H(b,x) ⟹  ―‹typo in text›
   ∀x. ∃y. ¬H(x,y) ⟹
   a ≠ b ⟹
   K(a,a)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"K(b,a)"</span></span></span><span> </span><span class="delimiter">@with</span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. H(b,x)"</span></span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>p56</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀x. (∃y. F(y) ∧ x = f(y)) ⟶ F(x)) ⟷ (∀x. F(x) ⟶ F(f(x)))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>p57</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"F(f(a,b),f(b,c)) ⟹ F(f(b,c),f(a,c)) ⟹
  ∀x y z. F(x,y) ∧ F(y,z) ⟶ F(x,z) ⟹ F(f(a,b),f(a,c))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>p58</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x y. f(x) = g(y) ⟹ ∀x y. f(f(x)) = f(g(y))"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x y. f(f(x)) = f(g(y))"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f(x) = g(y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>p59</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x::'a. F(x) ⟷ ¬F(f(x)) ⟹ ∃x. F(x) ∧ ¬F(f(x))"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x::'a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = x"</span></span></span><span> </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"F(x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>p60</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. F(x,f(x)) ⟷ (∃y. (∀z. F(z,y) ⟶ F(z,f(x))) ∧ F(x,y))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>p61</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x y z. f(x,f(y,z)) = f(f(x,y),z) ⟹ ∀x y z w. f(x,f(y,f(z,w))) = f(f(f(x,y),z),w)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Primes_Ex">
<div class="head"><h1>Theory Primes_Ex</h1>
<span class="command">theory</span> <span class="name">Primes_Ex</span><br/>
<span class="keyword">imports</span> <a href="Auto2_Main.html"><span class="name">Auto2_Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  File: Primes_Ex.thy
  Author: Bohua Zhan

  Elementary number theory of primes, up to the proof of infinitude
  of primes and the unique factorization theorem.

  Follows the development in HOL/Computational_Algebra/Primes.thy.
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Primes›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Primes_Ex</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Auto2_Main</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Basic definition›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>prime</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>rewrite</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"prime p = (1 &lt; p ∧ (∀m. m dvd p ⟶ m = 1 ∨ m = p))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>primeD1</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prime p ⟹ 1 &lt; p"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>primeD2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prime p ⟹ m dvd p ⟹ m = 1 ∨ m = p"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm primeD2} [with_cond "?m ≠ 1", with_cond "?m ≠ ?p"]›</span></span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm_eqforward @{thm prime_def}›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Exists a prime p. *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>exists_prime</span><span> </span><span class="delimiter">[</span><span>resolve</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃p. prime p"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prime 2"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prime_odd_nat</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prime p ⟹ p &gt; 2 ⟹ odd p"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prime_imp_coprime_nat</span><span> </span><span class="delimiter">[</span><span>backward2</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prime p ⟹ ¬ p dvd n ⟹ coprime p n"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prime_dvd_mult_nat</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prime p ⟹ p dvd m * n ⟹ p dvd m ∨ p dvd n"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm prime_dvd_mult_nat}
  (with_conds ["?m ≠ ?p", "?n ≠ ?p", "?m ≠ ?p * ?m'", "?n ≠ ?p * ?n'"])›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>prime_dvd_intro</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prime p ⟹ p * q = m * n ⟹ p dvd m ∨ p dvd n"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p dvd m * n"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm prime_dvd_intro}
  (with_conds ["?m ≠ ?p", "?n ≠ ?p", "?m ≠ ?p * ?m'", "?n ≠ ?p * ?n'"])›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prime_dvd_mult_eq_nat</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prime p ⟹ p dvd m * n = (p dvd m ∨ p dvd n)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_prime_eq_prod_nat</span><span> </span><span class="delimiter">[</span><span>backward1</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n &gt; 1 ⟹ ¬ prime n ⟹
    ∃m k. n = m * k ∧ 1 &lt; m ∧ m &lt; n ∧ 1 &lt; k ∧ k &lt; n"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>m</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m dvd n ∧ m ≠ 1 ∧ m ≠ n"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>k</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n = m * k"</span></span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m ≤ m * k"</span></span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k ≤ m * k"</span></span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prime_dvd_power_nat</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prime p ⟹ p dvd x^n ⟹ p dvd x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm prime_dvd_power_nat} [with_cond "?p ≠ ?x"]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prime_dvd_power_nat_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prime p ⟹ n &gt; 0 ⟹ p dvd x^n ⟷ p dvd x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prime_nat_code</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prime p = (1 &lt; p ∧ (∀x. 1 &lt; x ∧ x &lt; p ⟶ ¬ x dvd p))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prime_factor_nat</span><span> </span><span class="delimiter">[</span><span>backward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n ≠ 1 ⟹ ∃p. p dvd n ∧ prime p"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@strong_induct</span></span><span> </span><span>n</span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prime n"</span></span></span><span> </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>k</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k ≠ 1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k ≠ n"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k dvd n"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@apply_induct_hyp</span></span><span> </span><span>k</span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prime_divprod_pow_nat</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"prime p ⟹ coprime a b ⟹ p^n dvd a * b ⟹ p^n dvd a ∨ p^n dvd b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prime_product</span><span> </span><span class="delimiter">[</span><span>forward</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prime (p * q) ⟹ p = 1 ∨ q = 1"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p dvd q * p"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prime_exp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prime (p ^ n) ⟷ n = 1 ∧ prime p"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto2</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prime_power_mult</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prime p ⟹ x * y = p ^ k ⟹ ∃i j. x = p ^ i ∧ y = p ^ j"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@induct</span></span><span> </span><span>k</span><span> </span><span class="keyword2"><span class="keyword">arbitrary</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span class="delimiter">@with</span><span>
</span><span>    </span><span class="keyword1"><span class="command">@subgoal</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k = Suc k'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p dvd x"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>        </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>x'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = p * x'"</span></span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x * y = p * (x' * y)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>i</span><span> </span><span>j</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x' = p ^ i"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y = p ^ j"</span></span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = p ^ Suc i"</span></span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p dvd y"</span></span></span><span> </span><span class="delimiter">@with</span><span>
</span><span>        </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>y'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y = p * y'"</span></span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x * y = p * (x * y')"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>i</span><span> </span><span>j</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = p ^ i"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y' = p ^ j"</span></span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y = p ^ Suc j"</span></span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">@endgoal</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Infinitude of primes›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>bigger_prime</span><span> </span><span class="delimiter">[</span><span>resolve</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃p. prime p ∧ n &lt; p"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>p</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prime p"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p dvd fact n + 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n ≥ p"</span></span></span><span> </span><span class="delimiter">@with</span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(p::nat) dvd fact n"</span></span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>primes_infinite</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ finite {p. prime p}"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>b</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prime b"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Max {p. prime p} &lt; b"</span></span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Existence and uniqueness of prime factorization›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>factorization_exists</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n &gt; 0 ⟹ ∃M. (∀p∈#M. prime p) ∧ n = (∏i∈#M. i)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@strong_induct</span></span><span> </span><span>n</span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n = 1"</span></span></span><span> </span><span class="delimiter">@with</span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n = (∏i∈# {#}. i)"</span></span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"prime n"</span></span></span><span> </span><span class="delimiter">@with</span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n = (∏i∈# {#n#}. i)"</span></span></span><span> </span><span class="keyword1"><span class="command">@end</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>m</span><span> </span><span>k</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n = m * k"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"1 &lt; m"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m &lt; n"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"1 &lt; k"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k &lt; n"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@apply_induct_hyp</span></span><span> </span><span>m</span><span>
</span><span>  </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>M</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀p∈#M. prime p)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m = (∏i∈#M. i)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@apply_induct_hyp</span></span><span> </span><span>k</span><span>
</span><span>  </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>K</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀p∈#K. prime p)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k = (∏i∈#K. i)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n = (∏i∈#(M+K). i)"</span></span></span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>prime_dvd_multiset</span><span> </span><span class="delimiter">[</span><span>backward1</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"prime p ⟹ p dvd (∏i∈#M. i) ⟹ ∃n. n∈#M ∧ p dvd n"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@strong_induct</span></span><span> </span><span>M</span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M = {#}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>M'</span><span> </span><span>m</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M = M' + {#m#}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@contradiction</span></span><span> </span><span class="keyword1"><span class="command">@apply_induct_hyp</span></span><span> </span><span>M'</span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>factorization_unique_aux</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∀p∈#M. prime p ⟹ ∀p∈#N. prime p ⟹ (∏i∈#M. i) dvd (∏i∈#N. i) ⟹ M ⊆# N"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@strong_induct</span></span><span> </span><span>M</span><span> </span><span class="keyword2"><span class="keyword">arbitrary</span></span><span> </span><span>N</span><span>
</span><span>  </span><span class="keyword1"><span class="command">@case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M = {#}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>M'</span><span> </span><span>m</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M = M' + {#m#}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m dvd (∏i∈#M. i)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n ∈# N"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m dvd n"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@obtain</span></span><span> </span><span>N'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"N = N' + {#n#}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m = n"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∏i∈#M'. i) dvd (∏i∈#N'. i)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">@apply_induct_hyp</span></span><span> </span><span>M'</span><span> </span><span>N'</span><span>
</span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹add_forward_prfstep_cond @{thm factorization_unique_aux} [with_cond "?M ≠ ?N"]›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>factorization_unique</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∀p∈#M. prime p ⟹ ∀p∈#N. prime p ⟹ (∏i∈#M. i) = (∏i∈#N. i) ⟹ M = N"</span></span></span><span>
</span><span class="keyword1"><span class="command">@proof</span></span><span> </span><span class="keyword1"><span class="command">@have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"M ⊆# N"</span></span></span><span> </span><span class="keyword1"><span class="command">@qed</span></span><span>
</span><span class="keyword1"><span class="command">setup</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹del_prfstep_thm @{thm factorization_unique_aux}›</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div>