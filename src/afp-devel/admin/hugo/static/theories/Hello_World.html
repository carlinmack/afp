<div id="IO">
<div class="head"><h1>Theory IO</h1>
<span class="command">theory</span> <span class="name">IO</span><br/>
<span class="keyword">imports</span> <a href="Monad_Syntax.html"><span class="name">Monad_Syntax</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>IO</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>    </span><span>Main</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Monad_Syntax"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπIO Monad‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
  Inspired by Haskell.
  Definitions from üåê‚Äπhttps://wiki.haskell.org/IO_inside‚Ä∫
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπReal World‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
  We model the real world with a fake type.

  WARNING:
    Using low-level commands such as ‚¨ö‚Äπtypedecl‚Ä∫ instead of high-level ‚¨ö‚Äπdatatype‚Ä∫ is dangerous.
    We explicitly use a ‚¨ö‚Äπtypedecl‚Ä∫ instead of a ‚¨ö‚Äπdatatype‚Ä∫ because we never want to instantiate
    the world. We don't need a constructor, we just need the type.

  The following models an arbitrary type we cannot reason about.
  Don't reason about the complete world! Only write down some assumptions about parts of the world.
‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">typedecl</span></span><span> </span><span>real_world</span><span> </span><span class="delimiter">(</span><span class="cartouche"><span class="delete"><span class="delete">‚Äπüåê‚Ä∫</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
  For examples, see üóè‚ÄπHelloWorld_Proof.thy‚Ä∫.
  In said theory, we model ‚ñ©‚ÄπSTDIN‚Ä∫ and ‚ñ©‚ÄπSTDOUT‚Ä∫ as parts of the world and describe how this part
  of the wold can be affected. We don't model the rest of the world. This allows us to reason about
  ‚ñ©‚ÄπSTDIN‚Ä∫ and ‚ñ©‚ÄπSTDOUT‚Ä∫ as part of the world, but nothing more.
‚Ä∫</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπIO Monad‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
  The set of all functions which take a \&lt;^typ&gt;‚Äπüåê‚Ä∫ and return an \&lt;^typ&gt;‚Äπ'Œ±‚Ä∫ and a \&lt;^typ&gt;‚Äπüåê‚Ä∫.

  The rough idea of all IO functions is the following: You are given the world in its current state.
  You can do whatever you like to the world. You can produce some value of type \&lt;^typ&gt;‚Äπ'Œ±‚Ä∫ and you
  have to return the modified world.

  For example, the ‚ñ©‚Äπmain‚Ä∫ function is Haskell does not produce a value, therefore, ‚ñ©‚Äπmain‚Ä∫ in
  Haskell is of type ‚ñ©‚ÄπIO ()‚Ä∫. Another example in Haskell is ‚ñ©‚ÄπgetLine‚Ä∫, which returns ‚ñ©‚ÄπString‚Ä∫.
  It's type in Haskell is ‚ñ©‚ÄπIO String‚Ä∫. All those functions may also modify the state of the world.
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">typedef</span></span><span> </span><span class="tfree">'Œ±</span><span> </span><span>io</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"UNIV :: (üåê ‚áí 'Œ± √ó üåê) set"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÉx. x ‚àà UNIV"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
  Related Work:
  ‚àó‚ÄπProgramming TLS in Isabelle/HOL‚Ä∫ by Andreas Lochbihler and Marc Z√ºst uses a partial function
  (‚Äπ‚áÄ‚Ä∫).
  ‚¨ö‚Äπ
    typedecl real_world
    typedef 'Œ± io = "UNIV :: (üåê ‚áÄ 'Œ± √ó üåê) set" by simp
  ‚Ä∫
  We use a total function. This implies the dangerous assumption that all IO functions are total
  (i.e., terminate).
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
  The ‚¨ö‚Äπtypedef‚Ä∫ above gives us some convenient definitions.
  Since the model of \&lt;^typ&gt;‚Äπ'Œ± io‚Ä∫ is just a mode, those definitions should not end up in generated
  code.
‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">term</span></span><span> </span><span>Abs_io</span><span> </span><span class="comment">‚Äï ‚ÄπTakes a \&lt;^typ&gt;‚Äπ(üåê ‚áí 'Œ± √ó üåê)‚Ä∫ and abstracts it to an \&lt;^typ&gt;‚Äπ'Œ± io‚Ä∫.‚Ä∫</span><span>
</span><span class="keyword1"><span class="command">term</span></span><span> </span><span>Rep_io</span><span> </span><span class="comment">‚Äï ‚ÄπUnpacks an \&lt;^typ&gt;‚Äπ'Œ± io‚Ä∫ to a \&lt;^typ&gt;‚Äπ(üåê ‚áí 'Œ± √ó üåê)‚Ä∫‚Ä∫</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπMonad Operations‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
  Within an \&lt;^typ&gt;‚Äπ'Œ± io‚Ä∫ context, execute \&lt;^term&gt;‚Äπaction<span class="hidden">‚á©</span><sub>1</sub>‚Ä∫ and \&lt;^term&gt;‚Äπaction<span class="hidden">‚á©</span><sub>2</sub>‚Ä∫ sequentially.
  The world is passed through and potentially modified by each action.
‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>bind</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'Œ± io ‚áí ('Œ± ‚áí 'Œ≤ io) ‚áí 'Œ≤ io"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>code</span><span> </span><span>del</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bind action<span class="hidden">‚á©</span><sub>1</sub> action<span class="hidden">‚á©</span><sub>2</sub> = Abs_io (Œªworld<span class="hidden">‚á©</span><sub>0</sub>.
                                  let (a, world<span class="hidden">‚á©</span><sub>1</sub>) = (Rep_io action<span class="hidden">‚á©</span><sub>1</sub>) world<span class="hidden">‚á©</span><sub>0</sub>;
                                      (b, world<span class="hidden">‚á©</span><sub>2</sub>) = (Rep_io (action<span class="hidden">‚á©</span><sub>2</sub> a)) world<span class="hidden">‚á©</span><sub>1</sub>
                                  in (b, world<span class="hidden">‚á©</span><sub>2</sub>))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
  In Haskell, the definition for ‚ñ©‚Äπbind‚Ä∫ (‚ñ©‚Äπ&gt;&gt;=‚Ä∫) is:
  ‚ñ©‚Äπ
    (&gt;&gt;=) :: IO a -&gt; (a -&gt; IO b) -&gt; IO b
    (action1 &gt;&gt;= action2) world0 =
       let (a, world1) = action1 world0
           (b, world2) = action2 a world1
       in (b, world2)
  ‚Ä∫
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">hide_const</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="delimiter">)</span><span> </span><span>bind</span><span>
</span><span class="keyword1"><span class="command">adhoc_overloading</span></span><span> </span><span>bind</span><span> </span><span>IO.bind</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπThanks to ‚¨ö‚Äπadhoc_overloading‚Ä∫, we can use monad syntax.‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bind (foo :: 'Œ± io) (Œªa. bar a) = foo ‚§ú (Œªa. bar a)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>return</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'Œ± ‚áí 'Œ± io"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>code</span><span> </span><span>del</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"return a ‚â° Abs_io (Œªworld. (a, world))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">hide_const</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="delimiter">)</span><span> </span><span>return</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
  In Haskell, the definition for ‚ñ©‚Äπreturn‚Ä∫ is::
  ‚ñ©‚Äπ
    return :: a -&gt; IO a
    return a world0  =  (a, world0)
  ‚Ä∫
‚Ä∫</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπMonad Laws‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>left_id</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'Œ± ‚áí 'Œ≤ io"</span></span></span><span> </span><span class="comment">‚Äï ‚ÄπMake sure we use our \&lt;^const&gt;‚ÄπIO.bind‚Ä∫.‚Ä∫</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(IO.return a ‚§ú f) = f a"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>return_def</span><span> </span><span>IO.bind_def</span><span> </span><span>Abs_io_inverse</span><span> </span><span>Rep_io_inverse</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>right_id</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>m</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'Œ± io"</span></span></span><span> </span><span class="comment">‚Äï ‚ÄπMake sure we use our \&lt;^const&gt;‚ÄπIO.bind‚Ä∫.‚Ä∫</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(m ‚§ú IO.return) = m"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>return_def</span><span> </span><span>IO.bind_def</span><span> </span><span>Abs_io_inverse</span><span> </span><span>Rep_io_inverse</span><span class="delimiter">)</span><span>
</span><span>    
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bind_assoc</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>m</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'Œ± io"</span></span></span><span> </span><span class="comment">‚Äï ‚ÄπMake sure we use our \&lt;^const&gt;‚ÄπIO.bind‚Ä∫.‚Ä∫</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"((m ‚§ú f) ‚§ú g) = (m ‚§ú (Œªx. f x ‚§ú g))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>IO.bind_def</span><span> </span><span>Abs_io_inverse</span><span> </span><span>Abs_io_inject</span><span> </span><span>fun_eq_iff</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπCode Generator Setup‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
  We don't expose our \&lt;^const&gt;‚ÄπIO.bind‚Ä∫ definition to code.
  We use the built-in definitions of the target language (e.g., Haskell, SML).
‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span>IO.bind</span><span> </span><span class="delimiter">‚áÄ</span><span> </span><span class="delimiter">(</span><span>Haskell</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"_ &gt;&gt;= _"</span></span></span><span>
</span><span>                                  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"bind"</span></span></span><span>
</span><span>            </span><span class="delimiter">|</span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span>IO.return</span><span> </span><span class="delimiter">‚áÄ</span><span> </span><span class="delimiter">(</span><span>Haskell</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"return"</span></span></span><span>
</span><span>                                    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"(() =&gt; _)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπSML does not come with a bind function. We just define it (hopefully correct).‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span> </span><span class="keyword2"><span class="keyword">code_module</span></span><span> </span><span>Bind</span><span> </span><span class="delimiter">‚áÄ</span><span> </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
fun bind x f () = f (x ()) ();
‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">code_reserved</span></span><span> </span><span>SML</span><span> </span><span>bind</span><span> </span><span>return</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
  Make sure the code generator does not try to define \&lt;^typ&gt;‚Äπ'Œ± io‚Ä∫ by itself, but always uses
  the one of the target language.
  For Haskell, this is the fully qualified Prelude.IO.
  For SML, we wrap it in a nullary function.
‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span> </span><span class="keyword2"><span class="keyword">type_constructor</span></span><span> </span><span>io</span><span> </span><span class="delimiter">‚áÄ</span><span> </span><span class="delimiter">(</span><span>Haskell</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"Prelude.IO _"</span></span></span><span>
</span><span>                                     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"unit -&gt; _"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
In Isabelle, a \&lt;^typ&gt;‚Äπstring‚Ä∫ is just a type synonym for \&lt;^typ&gt;‚Äπchar list‚Ä∫.
When translating a \&lt;^typ&gt;‚Äπstring‚Ä∫ to Haskell, Isabelle does not use Haskell's ‚ñ©‚ÄπString‚Ä∫ or 
‚ñ©‚Äπ[Prelude.Char]‚Ä∫. Instead, Isabelle serializes its own
  ‚ñ©‚Äπdata Char = Char Bool Bool Bool Bool Bool Bool Bool Bool‚Ä∫.
The resulting code will look just ugly.

To use the native strings of Haskell, we use the Isabelle type \&lt;^typ&gt;‚ÄπString.literal‚Ä∫.
This gets translated to a Haskell ‚ñ©‚ÄπString‚Ä∫.

A string literal in Isabelle is created with \&lt;^term&gt;‚ÄπSTR ''foo'' :: String.literal‚Ä∫.
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
  We define IO functions in Isabelle without implementation.
  For a proof in Isabelle, we will only describe their externally observable properties.
  For code generation, we map those functions to the corresponding function of the target language.

  Our assumption is that our description in Isabelle corresponds to the real behavior of those
  functions in the respective target language.

  We use ‚¨ö‚Äπaxiomatization‚Ä∫ instead of ‚¨ö‚Äπconsts‚Ä∫ to axiomatically define that those functions exist,
  but there is no implementation of them. This makes sure that we have to explicitly write down all
  our assumptions about their behavior. Currently, no assumptions (apart from their type) can be
  made about those functions.
‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">axiomatization</span></span><span>
</span><span>  </span><span>println</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"String.literal ‚áí unit io"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>getLine</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"String.literal io"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπA Haskell module named ‚ñ©‚ÄπStdIO‚Ä∫ which just implements ‚ñ©‚Äπprintln‚Ä∫ and ‚ñ©‚ÄπgetLine‚Ä∫.‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span> </span><span class="keyword2"><span class="keyword">code_module</span></span><span> </span><span>StdIO</span><span> </span><span class="delimiter">‚áÄ</span><span> </span><span class="delimiter">(</span><span>Haskell</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
module StdIO (println, getLine) where
import qualified Prelude (putStrLn, getLine)
println = Prelude.putStrLn
getLine = Prelude.getLine
‚Ä∫</span></span></span><span>                              </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
(* Newline behavior in SML is odd.*)
fun println s () = TextIO.print (s ^ "\n");
fun getLine () = case (TextIO.inputLine TextIO.stdIn) of
                  SOME s =&gt; String.substring (s, 0, String.size s - 1)
                | NONE =&gt; raise Fail "getLine";
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_reserved</span></span><span> </span><span>Haskell</span><span> </span><span>StdIO</span><span> </span><span>println</span><span> </span><span>getLine</span><span>
</span><span class="keyword1"><span class="command">code_reserved</span></span><span> </span><span>SML</span><span> </span><span>println</span><span> </span><span>print</span><span> </span><span>getLine</span><span> </span><span>TextIO</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
  When the code generator sees the functions \&lt;^const&gt;‚Äπprintln‚Ä∫ or \&lt;^const&gt;‚ÄπgetLine‚Ä∫, we tell it to use
  our language-specific implementation.
  ‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">code_printing</span></span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span>println</span><span> </span><span class="delimiter">‚áÄ</span><span> </span><span class="delimiter">(</span><span>Haskell</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"StdIO.println"</span></span></span><span>
</span><span>                              </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"println"</span></span></span><span>
</span><span>            </span><span class="delimiter">|</span><span> </span><span class="keyword2"><span class="keyword">constant</span></span><span> </span><span>getLine</span><span> </span><span class="delimiter">‚áÄ</span><span> </span><span class="delimiter">(</span><span>Haskell</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"StdIO.getLine"</span></span></span><span>
</span><span>                              </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="delimiter">(</span><span>SML</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"getLine"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπMonad syntax and \&lt;^const&gt;‚Äπprintln‚Ä∫ examples.‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bind (println (STR ''foo''))
            (Œª_.  println (STR ''bar'')) =
       println (STR ''foo'') ‚§ú (Œª_. println (STR ''bar''))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"do { _ ‚Üê println (STR ''foo'');
            println (STR ''bar'')} =
      println (STR ''foo'') ‚™¢ (println (STR ''bar''))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπModelling Running an \&lt;^typ&gt;‚Äπ'Œ± io‚Ä∫ Function‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
  Apply some function \&lt;^term&gt;‚Äπiofun :: 'Œ± io‚Ä∫ to a specific world and return the new world
  (discarding the result of \&lt;^term&gt;‚Äπiofun‚Ä∫).
‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>exec</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'Œ± io ‚áí üåê ‚áí üåê"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"exec iofun world = snd (Rep_io iofun world)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπSimilar, but only get the result.‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>eval</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'Œ± io ‚áí üåê ‚áí 'Œ±"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"eval iofun world = fst (Rep_io iofun world)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
  Essentially, \&lt;^const&gt;‚Äπexec‚Ä∫ and \&lt;^const&gt;‚Äπeval‚Ä∫ extract the payload \&lt;^typ&gt;‚Äπ'Œ±‚Ä∫ and \&lt;^typ&gt;‚Äπüåê‚Ä∫
  when executing an \&lt;^typ&gt;‚Äπ'Œ± io‚Ä∫.
‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Abs_io (Œªworld. (eval iofun world, exec iofun world)) = iofun"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>exec_def</span><span> </span><span>eval_def</span><span> </span><span>Rep_io_inverse</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exec_Abs_io</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"exec (Abs_io f) world = snd (f world)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>exec_def</span><span> </span><span>Abs_io_inverse</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exec_then</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"exec (io<span class="hidden">‚á©</span><sub>1</sub> ‚™¢ io<span class="hidden">‚á©</span><sub>2</sub>) world = exec io<span class="hidden">‚á©</span><sub>2</sub> (exec io<span class="hidden">‚á©</span><sub>1</sub> world)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eval_then</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"eval (io<span class="hidden">‚á©</span><sub>1</sub> ‚™¢ io<span class="hidden">‚á©</span><sub>2</sub>) world = eval io<span class="hidden">‚á©</span><sub>2</sub> (exec io<span class="hidden">‚á©</span><sub>1</sub> world)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>exec_def</span><span> </span><span>eval_def</span><span> </span><span>bind_def</span><span> </span><span>Abs_io_inverse</span><span> </span><span>split_beta</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exec_bind</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"exec (io<span class="hidden">‚á©</span><sub>1</sub> ‚§ú io<span class="hidden">‚á©</span><sub>2</sub>) world = exec (io<span class="hidden">‚á©</span><sub>2</sub> (eval io<span class="hidden">‚á©</span><sub>1</sub> world)) (exec io<span class="hidden">‚á©</span><sub>1</sub> world)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>eval_bind</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"eval (io<span class="hidden">‚á©</span><sub>1</sub> ‚§ú io<span class="hidden">‚á©</span><sub>2</sub>) world = eval (io<span class="hidden">‚á©</span><sub>2</sub> (eval io<span class="hidden">‚á©</span><sub>1</sub> world)) (exec io<span class="hidden">‚á©</span><sub>1</sub> world)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>exec_def</span><span> </span><span>eval_def</span><span> </span><span>bind_def</span><span> </span><span>Abs_io_inverse</span><span> </span><span>split_beta</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>exec_return</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"exec (IO.return a) world = world"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"eval (IO.return a) world = a"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>exec_def</span><span> </span><span>eval_def</span><span> </span><span>Abs_io_inverse</span><span> </span><span>return_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>
</div>
</div><div id="HelloWorld">
<div class="head"><h1>Theory HelloWorld</h1>
<span class="command">theory</span> <span class="name">HelloWorld</span><br/>
<span class="keyword">imports</span> <a href="IO.html"><span class="name">IO</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>HelloWorld</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>IO</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπHello, World!‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
  The idea of a \&lt;^term&gt;‚Äπmain :: unit io‚Ä∫ function is that, upon start of your program, you will be
  handed a value of type \&lt;^typ&gt;‚Äπüåê‚Ä∫. You can pass this world through your code and modify it.
  Be careful with the \&lt;^typ&gt;‚Äπüåê‚Ä∫, it's the only one we have.
‚Ä∫</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπThe main function, defined in Isabelle. It should have the right type in Haskell.‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>main</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"unit io"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"main ‚â° do {
               _ ‚Üê println (STR ''Hello World! What is your name?'');
               name ‚Üê getLine;
               println (STR ''Hello, '' + name + STR ''!'')
             }"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπGenerating Code‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπChecking that the generated code compiles.‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">export_code</span></span><span> </span><span>main</span><span> </span><span class="keyword2"><span class="keyword">checking</span></span><span> </span><span>Haskell</span><span class="delimiter">?</span><span> </span><span>SML</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπIsabelle_System.bash "echo ${ISABELLE_TMP} &gt; ${ISABELLE_TMP}/self"‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
During the build of this session, the code generated in the following subsections will be
written to
‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">text_raw</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ\verbatiminput{${ISABELLE_TMP}/self}‚Ä∫</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπHaskell‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">export_code</span></span><span> </span><span>main</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>Haskell</span><span> </span><span class="keyword2"><span class="keyword">file</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"$ISABELLE_TMP/exported_hs"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπThe generated helper module üóè‚Äπ$ISABELLE_TMP/exported_hs/StdIO.hs‚Ä∫ is shown below.‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">text_raw</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ\verbatiminput{$ISABELLE_TMP/exported_hs/StdIO.hs}‚Ä∫</span></span></span><span>
</span><span> 
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπThe generated main file üóè‚Äπ$ISABELLE_TMP/exported_hs/HelloWorld.hs‚Ä∫ is shown below.‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">text_raw</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ\verbatiminput{$ISABELLE_TMP/exported_hs/HelloWorld.hs}‚Ä∫</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπSML‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">export_code</span></span><span> </span><span>main</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>SML</span><span> </span><span class="keyword2"><span class="keyword">file</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"$ISABELLE_TMP/exported.sml"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπThe generated SML code in üóè‚Äπ$ISABELLE_TMP/exported.sml‚Ä∫ is shown below.‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">text_raw</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ\verbatiminput{$ISABELLE_TMP/exported.sml}‚Ä∫</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>
</div>
</div><div id="HelloWorld_Proof">
<div class="head"><h1>Theory HelloWorld_Proof</h1>
<span class="command">theory</span> <span class="name">HelloWorld_Proof</span><br/>
<span class="keyword">imports</span> <a href="HelloWorld.html"><span class="name">HelloWorld</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>HelloWorld_Proof</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>HelloWorld</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπCorrectness‚Ä∫</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπModeling Input and Output‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
  With the appropriate assumptions about \&lt;^const&gt;‚Äπprintln‚Ä∫ and \&lt;^const&gt;‚ÄπgetLine‚Ä∫,
  we can even prove something.
  We summarize our model about input and output in the assumptions of a ‚¨ö‚Äπlocale‚Ä∫.
‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>io_stdio</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="comment">‚Äï ‚ÄπWe model ‚ñ©‚ÄπSTDIN‚Ä∫ and ‚ñ©‚ÄπSTDOUT‚Ä∫ as part of the \&lt;^typ&gt;‚Äπüåê‚Ä∫.
     Note that we know nothing about \&lt;^typ&gt;‚Äπüåê‚Ä∫,
     we just model that we can find ‚ñ©‚ÄπSTDIN‚Ä∫ and ‚ñ©‚ÄπSTDOUT‚Ä∫ somewhere in there.‚Ä∫</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>stdout_of</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"üåê ‚áí string list"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>stdin_of</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"üåê ‚áí string list"</span></span></span><span>
</span><span>
</span><span>  </span><span class="comment">‚Äï ‚ÄπAssumptions about ‚ñ©‚ÄπSTDIN‚Ä∫:
      Calling \&lt;^const&gt;‚Äπprintln‚Ä∫ appends to the end of ‚ñ©‚ÄπSTDOUT‚Ä∫ and \&lt;^const&gt;‚ÄπgetLine‚Ä∫ does not change
      anything.‚Ä∫</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>stdout_of_println</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"stdout_of (exec (println str) world) = stdout_of world@[String.explode str]"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>stdout_of_getLine</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"stdout_of (exec getLine world) = stdout_of world"</span></span></span><span>
</span><span>
</span><span>  </span><span class="comment">‚Äï ‚ÄπAssumptions about ‚ñ©‚ÄπSTDIN‚Ä∫:
      Calling \&lt;^const&gt;‚Äπprintln‚Ä∫ does not change anything and \&lt;^const&gt;‚ÄπgetLine‚Ä∫ removes the first element
      from the ‚ñ©‚ÄπSTDIN‚Ä∫ stream.‚Ä∫</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>stdin_of_println</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"stdin_of (exec (println str) world) = stdin_of world"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>stdin_of_getLine</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"stdin_of world = inp#stdin ‚üπ
     stdin_of (exec getLine world) = stdin ‚àß eval getLine world = String.implode inp"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπCorrectness of Hello World‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπCorrectness of \&lt;^const&gt;‚Äπmain‚Ä∫:
    If ‚ñ©‚ÄπSTDOUT‚Ä∫ is initially empty and only \&lt;^term&gt;‚Äπ''corny''‚Ä∫ will be typed into ‚ñ©‚ÄπSTDIN‚Ä∫,
    then the program will output: \&lt;^term&gt;‚Äπ[''Hello World! What is your name?'', ''Hello, corny!'']‚Ä∫.
  ‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>io_stdio</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>stdout</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"stdout_of world = []"</span></span></span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>stdin</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"stdin_of world = [''corny'']"</span></span></span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"stdout_of (exec main world) =
              [''Hello World! What is your name?'',
               ''Hello, corny!'']"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?world1</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"exec (println (STR ''Hello World! What is your name?'')) world"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>stdout_world2</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"literal.explode STR ''Hello World! What is your name?'' =
     ''Hello World! What is your name?''"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>code_simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>stdin_of_getLine</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>stdin</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>stdin</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>stdin_world2</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"eval getLine ?world1 = String.implode ''corny''"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>stdin_of_getLine</span><span> </span><span>stdin</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>main_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>exec_bind</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>stdout</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>stdout_world2</span><span> </span><span>stdin_world2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>plus_literal.rep_eq</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>code_simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>
</div>
</div><div id="RunningCodeFromIsabelle">
<div class="head"><h1>Theory RunningCodeFromIsabelle</h1>
<span class="command">theory</span> <span class="name">RunningCodeFromIsabelle</span><br/>
<span class="keyword">imports</span> <a href="HelloWorld.html"><span class="name">HelloWorld</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>RunningCodeFromIsabelle</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>HelloWorld</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπRunning the Generated Code inside Isabelle‚Ä∫</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Maintainer note: We invoke the generated code ON PURPOSE from bash to demonstrate how to use
  the generated code from outside Isabelle and make sure the code runs.*)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
  Usually, one would use ‚¨ö‚Äπexport_code‚Ä∫ to generate code. Here, we want to write the code to
  a temp directory and execute it right afterwards inside Isablle, so we invoke the code generator
  directly from Isabelle/ML.
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπHaskell‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
val (files, _) =
  Code_Target.produce_code @{context} false [@{const_name main}] "Haskell" "Main" NONE []

val target = File.tmp_path (Path.basic ("export" ^ serial_string ()))

val ghc = getenv "ISABELLE_GHC";

val cmd =
  "cd " ^ Path.implode target ^ " &amp;&amp; " ^
    Bash.string ghc ^ " Main.hs &amp;&amp; " ^
    "(  echo 'Cyber Cat 42' | ./Main )";

Isabelle_System.mkdirs target;

app (fn ([file], content) =&gt;
   let
     val path = Path.append target (Path.basic file)
   in
     File.write path content
   end) files;

val exitcode =
  if ghc &lt;&gt; "" then
    Isabelle_System.bash cmd
  else
    (writeln "not running Haskell, because $ISABELLE_GHC is not set."; 0);

if exitcode &lt;&gt; 0 then
  raise (Fail ("example Haskell code did not run as expected, " ^
                 "exit code was " ^ (Int.toString exitcode)))
else ()
‚Ä∫</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπSML‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ

val ([(_, content)], _) =
  Code_Target.produce_code @{context} false [@{const_name main}] "SML" "HelloWorld" NONE []

val target = File.tmp_path (Path.basic ("export" ^ serial_string ()))
val file = Path.append target (Path.basic "main.ML")

val cmd =
  "echo 'Super Goat 2000' | " ^
    "\"${POLYML_EXE?}\" --use " ^ Path.implode file ^
    " --eval 'HelloWorld.main ()'";

Isabelle_System.mkdirs target;
File.write file content;

val exitcode = Isabelle_System.bash cmd;

if exitcode &lt;&gt; 0 then
  raise (Fail ("example SML code did not run as expected, " ^
                 "exit code was " ^ (Int.toString exitcode)))
else ()
‚Ä∫</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>
</div>
</div>