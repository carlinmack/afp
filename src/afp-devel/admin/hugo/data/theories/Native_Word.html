<div id="More_Bits_Int">
<div class="head">
<h1>Theory More_Bits_Int</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Bits_Int.thy
    Author:     Andreas Lochbihler, ETH Zurich
*)</span>

<span class="keyword1"><span class="command">chapter</span></span> <span class="quoted"><span class="plain_text">‹More bit operations on integers›</span></span>

<span class="keyword1"><span class="command">theory</span></span> More_Bits_Int
<span class="keyword2"><span class="keyword">imports</span></span>
  <span class="quoted">"<a href="../Word_Lib/Bits_Int.html">Word_Lib.Bits_Int</a>"</span>
  <span class="quoted">"<a href="../Word_Lib/Bit_Comprehension.html">Word_Lib.Bit_Comprehension</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Preliminaries›</span></span>

<span class="keyword1" id="More_Bits_Int-last_rev'"><span class="command">lemma</span></span> last_rev' <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"last <span class="main">(</span>rev <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> hd <span class="free">xs</span>"</span></span> <span class="comment1">― ‹TODO define <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>last []›</span></span> as <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>hd []›</span></span>?›</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> last_def hd_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="More_Bits_Int-nat_LEAST_True"><span class="command">lemma</span></span> nat_LEAST_True<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">LEAST</span> <span class="main"><span class="bound">_</span></span> <span class="main">::</span> nat<span class="main">.</span> True<span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> Least_equality<span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Use this function to convert numeral <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">integer</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>s quickly into <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">int</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>s.
  By default, it works only for symbolic evaluation; normally generated code raises
  an exception at run-time. If theory <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Code_Target_Bits_Int›</span></span></span></span> is imported,
  it works again, because then <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">int</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is implemented in terms of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">integer</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
  even for symbolic evaluation.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">int_of_integer_symbolic</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"integer <span class="main">⇒</span> int"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">int_of_integer_symbolic</span> <span class="main">=</span> int_of_integer"</span></span>

<span class="keyword1" id="More_Bits_Int-int_of_integer_symbolic_aux_code"><span class="command">lemma</span></span> int_of_integer_symbolic_aux_code <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">nbe</span></span></span></span></span></span></span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"int_of_integer_symbolic <span class="main">0</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="quoted"><span class="quoted">"int_of_integer_symbolic <span class="main">(</span>Code_Numeral.Pos <span class="free">n</span><span class="main">)</span> <span class="main">=</span> Int.Pos <span class="free">n</span>"</span></span>
  <span class="quoted"><span class="quoted">"int_of_integer_symbolic <span class="main">(</span>Code_Numeral.Neg <span class="free">n</span><span class="main">)</span> <span class="main">=</span> Int.Neg <span class="free">n</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> int_of_integer_symbolic_def<span class="main">)</span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Symbolic bit operations on numerals and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">int</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>s›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">bitOR_num</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"num <span class="main">⇒</span> num <span class="main">⇒</span> num"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">bitOR_num</span> num.One num.One <span class="main">=</span> num.One"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">bitOR_num</span> num.One <span class="main">(</span>num.Bit0 <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span> num.Bit1 <span class="free"><span class="bound"><span class="entity">n</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">bitOR_num</span> num.One <span class="main">(</span>num.Bit1 <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span> num.Bit1 <span class="free"><span class="bound"><span class="entity">n</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">bitOR_num</span> <span class="main">(</span>num.Bit0 <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> num.One <span class="main">=</span> num.Bit1 <span class="free"><span class="bound"><span class="entity">m</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">bitOR_num</span> <span class="main">(</span>num.Bit0 <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="main">(</span>num.Bit0 <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span> num.Bit0 <span class="main">(</span><span class="free">bitOR_num</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">bitOR_num</span> <span class="main">(</span>num.Bit0 <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="main">(</span>num.Bit1 <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span> num.Bit1 <span class="main">(</span><span class="free">bitOR_num</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">bitOR_num</span> <span class="main">(</span>num.Bit1 <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> num.One <span class="main">=</span> num.Bit1 <span class="free"><span class="bound"><span class="entity">m</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">bitOR_num</span> <span class="main">(</span>num.Bit1 <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="main">(</span>num.Bit0 <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span> num.Bit1 <span class="main">(</span><span class="free">bitOR_num</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">bitOR_num</span> <span class="main">(</span>num.Bit1 <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="main">(</span>num.Bit1 <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span> num.Bit1 <span class="main">(</span><span class="free">bitOR_num</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">bitAND_num</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"num <span class="main">⇒</span> num <span class="main">⇒</span> num option"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">bitAND_num</span> num.One num.One <span class="main">=</span> Some num.One"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">bitAND_num</span> num.One <span class="main">(</span>num.Bit0 <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span> None"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">bitAND_num</span> num.One <span class="main">(</span>num.Bit1 <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span> Some num.One"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">bitAND_num</span> <span class="main">(</span>num.Bit0 <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> num.One <span class="main">=</span> None"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">bitAND_num</span> <span class="main">(</span>num.Bit0 <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="main">(</span>num.Bit0 <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span> map_option num.Bit0 <span class="main">(</span><span class="free">bitAND_num</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">bitAND_num</span> <span class="main">(</span>num.Bit0 <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="main">(</span>num.Bit1 <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span> map_option num.Bit0 <span class="main">(</span><span class="free">bitAND_num</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">bitAND_num</span> <span class="main">(</span>num.Bit1 <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> num.One <span class="main">=</span> Some num.One"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">bitAND_num</span> <span class="main">(</span>num.Bit1 <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="main">(</span>num.Bit0 <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span> map_option num.Bit0 <span class="main">(</span><span class="free">bitAND_num</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">bitAND_num</span> <span class="main">(</span>num.Bit1 <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="main">(</span>num.Bit1 <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">bitAND_num</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">of</span> None <span class="main">⇒</span> Some num.One <span class="main">|</span> Some <span class="bound">n'</span> <span class="main">⇒</span> Some <span class="main">(</span>num.Bit1 <span class="bound">n'</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">bitXOR_num</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"num <span class="main">⇒</span> num <span class="main">⇒</span> num option"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">bitXOR_num</span> num.One num.One <span class="main">=</span> None"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">bitXOR_num</span> num.One <span class="main">(</span>num.Bit0 <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span> Some <span class="main">(</span>num.Bit1 <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">bitXOR_num</span> num.One <span class="main">(</span>num.Bit1 <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span> Some <span class="main">(</span>num.Bit0 <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">bitXOR_num</span> <span class="main">(</span>num.Bit0 <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> num.One <span class="main">=</span> Some <span class="main">(</span>num.Bit1 <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">bitXOR_num</span> <span class="main">(</span>num.Bit0 <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="main">(</span>num.Bit0 <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span> map_option num.Bit0 <span class="main">(</span><span class="free">bitXOR_num</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">bitXOR_num</span> <span class="main">(</span>num.Bit0 <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="main">(</span>num.Bit1 <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span> Some <span class="main">(</span><span class="keyword1">case</span> <span class="free">bitXOR_num</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">of</span> None <span class="main">⇒</span> num.One <span class="main">|</span> Some <span class="bound">n'</span> <span class="main">⇒</span> num.Bit1 <span class="bound">n'</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">bitXOR_num</span> <span class="main">(</span>num.Bit1 <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> num.One <span class="main">=</span> Some <span class="main">(</span>num.Bit0 <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">bitXOR_num</span> <span class="main">(</span>num.Bit1 <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="main">(</span>num.Bit0 <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span> Some <span class="main">(</span><span class="keyword1">case</span> <span class="free">bitXOR_num</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">of</span> None <span class="main">⇒</span> num.One <span class="main">|</span> Some <span class="bound">n'</span> <span class="main">⇒</span> num.Bit1 <span class="bound">n'</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">bitXOR_num</span> <span class="main">(</span>num.Bit1 <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="main">(</span>num.Bit1 <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span> map_option num.Bit0 <span class="main">(</span><span class="free">bitXOR_num</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">bitORN_num</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"num <span class="main">⇒</span> num <span class="main">⇒</span> num"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">bitORN_num</span> num.One num.One <span class="main">=</span> num.One"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">bitORN_num</span> num.One <span class="main">(</span>num.Bit0 <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="main">=</span> num.Bit1 <span class="free"><span class="bound"><span class="entity">m</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">bitORN_num</span> num.One <span class="main">(</span>num.Bit1 <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="main">=</span> num.Bit1 <span class="free"><span class="bound"><span class="entity">m</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">bitORN_num</span> <span class="main">(</span>num.Bit0 <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> num.One <span class="main">=</span> num.Bit0 num.One"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">bitORN_num</span> <span class="main">(</span>num.Bit0 <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">(</span>num.Bit0 <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="main">=</span> Num.BitM <span class="main">(</span><span class="free">bitORN_num</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">bitORN_num</span> <span class="main">(</span>num.Bit0 <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">(</span>num.Bit1 <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="main">=</span> num.Bit0 <span class="main">(</span><span class="free">bitORN_num</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">bitORN_num</span> <span class="main">(</span>num.Bit1 <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> num.One <span class="main">=</span> num.One"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">bitORN_num</span> <span class="main">(</span>num.Bit1 <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">(</span>num.Bit0 <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="main">=</span> Num.BitM <span class="main">(</span><span class="free">bitORN_num</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">bitORN_num</span> <span class="main">(</span>num.Bit1 <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">(</span>num.Bit1 <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="main">=</span> Num.BitM <span class="main">(</span><span class="free">bitORN_num</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">bitANDN_num</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"num <span class="main">⇒</span> num <span class="main">⇒</span> num option"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">bitANDN_num</span> num.One num.One <span class="main">=</span> None"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">bitANDN_num</span> num.One <span class="main">(</span>num.Bit0 <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span> Some num.One"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">bitANDN_num</span> num.One <span class="main">(</span>num.Bit1 <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span> None"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">bitANDN_num</span> <span class="main">(</span>num.Bit0 <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> num.One <span class="main">=</span> Some <span class="main">(</span>num.Bit0 <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">bitANDN_num</span> <span class="main">(</span>num.Bit0 <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="main">(</span>num.Bit0 <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span> map_option num.Bit0 <span class="main">(</span><span class="free">bitANDN_num</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">bitANDN_num</span> <span class="main">(</span>num.Bit0 <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="main">(</span>num.Bit1 <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span> map_option num.Bit0 <span class="main">(</span><span class="free">bitANDN_num</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">bitANDN_num</span> <span class="main">(</span>num.Bit1 <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> num.One <span class="main">=</span> Some <span class="main">(</span>num.Bit0 <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">bitANDN_num</span> <span class="main">(</span>num.Bit1 <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="main">(</span>num.Bit0 <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">bitANDN_num</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">of</span> None <span class="main">⇒</span> Some num.One <span class="main">|</span> Some <span class="bound">n'</span> <span class="main">⇒</span> Some <span class="main">(</span>num.Bit1 <span class="bound">n'</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">bitANDN_num</span> <span class="main">(</span>num.Bit1 <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="main">(</span>num.Bit1 <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span> map_option num.Bit0 <span class="main">(</span><span class="free">bitANDN_num</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="More_Bits_Int-int_numeral_bitOR_num"><span class="command">lemma</span></span> int_numeral_bitOR_num<span class="main">:</span> <span class="quoted"><span class="quoted">"numeral <span class="free">n</span> <span class="keyword1">OR</span> numeral <span class="free">m</span> <span class="main">=</span> <span class="main">(</span>numeral <span class="main">(</span>bitOR_num <span class="free">n</span> <span class="free">m</span><span class="main">)</span> <span class="main">::</span> int<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span> <span class="quoted"><span class="free">m</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> bitOR_num.induct<span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="More_Bits_Int-int_numeral_bitAND_num"><span class="command">lemma</span></span> int_numeral_bitAND_num<span class="main">:</span> <span class="quoted"><span class="quoted">"numeral <span class="free">n</span> <span class="keyword1">AND</span> numeral <span class="free">m</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> bitAND_num <span class="free">n</span> <span class="free">m</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="main">0</span> <span class="main">::</span> int <span class="main">|</span> Some <span class="bound">n'</span> <span class="main">⇒</span> numeral <span class="bound">n'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span> <span class="quoted"><span class="free">m</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> bitAND_num.induct<span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

<span class="keyword1" id="More_Bits_Int-int_numeral_bitXOR_num"><span class="command">lemma</span></span> int_numeral_bitXOR_num<span class="main">:</span>
  <span class="quoted"><span class="quoted">"numeral <span class="free">m</span> <span class="keyword1">XOR</span> numeral <span class="free">n</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> bitXOR_num <span class="free">m</span> <span class="free">n</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="main">0</span> <span class="main">::</span> int <span class="main">|</span> Some <span class="bound">n'</span> <span class="main">⇒</span> numeral <span class="bound">n'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">m</span></span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> bitXOR_num.induct<span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

<span class="keyword1" id="More_Bits_Int-int_or_not_bitORN_num"><span class="command">lemma</span></span> int_or_not_bitORN_num<span class="main">:</span>
  <span class="quoted"><span class="quoted">"numeral <span class="free">n</span> <span class="keyword1">OR</span> <span class="keyword1">NOT</span> <span class="main">(</span>numeral <span class="free">m</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">-</span> numeral <span class="main">(</span>bitORN_num <span class="free">n</span> <span class="free">m</span><span class="main">)</span> <span class="main">::</span> int<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">n</span></span> <span class="quoted"><span class="free">m</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> bitORN_num.induct<span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> add_One BitM_inc_eq<span class="main">)</span>

<span class="keyword1" id="More_Bits_Int-int_and_not_bitANDN_num"><span class="command">lemma</span></span> int_and_not_bitANDN_num<span class="main">:</span>
  <span class="quoted"><span class="quoted">"numeral <span class="free">n</span> <span class="keyword1">AND</span> <span class="keyword1">NOT</span> <span class="main">(</span>numeral <span class="free">m</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> bitANDN_num <span class="free">n</span> <span class="free">m</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="main">0</span> <span class="main">::</span> int <span class="main">|</span> Some <span class="bound">n'</span> <span class="main">⇒</span> numeral <span class="bound">n'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">n</span></span> <span class="quoted"><span class="free">m</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> bitANDN_num.induct<span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> add_One BitM_inc_eq <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

<span class="keyword1" id="More_Bits_Int-int_not_and_bitANDN_num"><span class="command">lemma</span></span> int_not_and_bitANDN_num<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="keyword1">NOT</span> <span class="main">(</span>numeral <span class="free">m</span><span class="main">)</span> <span class="keyword1">AND</span> numeral <span class="free">n</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> bitANDN_num <span class="free">n</span> <span class="free">m</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="main">0</span> <span class="main">::</span> int <span class="main">|</span> Some <span class="bound">n'</span> <span class="main">⇒</span> numeral <span class="bound">n'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> int_and_not_bitANDN_num<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> int_and_comm<span class="main">)</span>

<span class="keyword1"><span class="command">code_identifier</span></span>
  <span class="keyword2"><span class="keyword">code_module</span></span> More_Bits_Int <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> Bit_Operations <span class="keyword2"><span class="keyword">and</span></span> <span class="main">(</span>OCaml<span class="main">)</span> Bit_Operations <span class="keyword2"><span class="keyword">and</span></span> <span class="main">(</span>Haskell<span class="main">)</span> Bit_Operations <span class="keyword2"><span class="keyword">and</span></span> <span class="main">(</span>Scala<span class="main">)</span> Bit_Operations

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Code_Symbolic_Bits_Int">
<div class="head">
<h1>Theory Code_Symbolic_Bits_Int</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Code_Symbolic_Bits_Int.thy
    Author:     Andreas Lochbihler, ETH Zurich
*)</span>

<span class="keyword1"><span class="command">chapter</span></span> <span class="quoted"><span class="plain_text">‹Symbolic implementation of bit operations on int›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Code_Symbolic_Bits_Int
<span class="keyword2"><span class="keyword">imports</span></span>
  <span class="quoted">"<a href="../Word_Lib/Generic_set_bit.html">Word_Lib.Generic_set_bit</a>"</span>
  <span class="quoted">"<a href="../Word_Lib/Least_significant_bit.html">Word_Lib.Least_significant_bit</a>"</span>
  <a href="More_Bits_Int.html">More_Bits_Int</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Implementations of bit operations on <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹int›</span></span></span></span> operating on symbolic representation›</span></span>

<span class="keyword1" id="Code_Symbolic_Bits_Int-test_bit_int_code"><span class="command">lemma</span></span> test_bit_int_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"bit <span class="main">(</span><span class="main">0</span><span class="main">::</span>int<span class="main">)</span>          <span class="free">n</span> <span class="main">=</span> False"</span></span>
  <span class="quoted"><span class="quoted">"bit <span class="main">(</span>Int.Neg num.One<span class="main">)</span> <span class="free">n</span> <span class="main">=</span> True"</span></span>
  <span class="quoted"><span class="quoted">"bit <span class="main">(</span>Int.Pos num.One<span class="main">)</span>      <span class="main">0</span> <span class="main">=</span> True"</span></span>
  <span class="quoted"><span class="quoted">"bit <span class="main">(</span>Int.Pos <span class="main">(</span>num.Bit0 <span class="free">m</span><span class="main">)</span><span class="main">)</span> <span class="main">0</span> <span class="main">=</span> False"</span></span>
  <span class="quoted"><span class="quoted">"bit <span class="main">(</span>Int.Pos <span class="main">(</span>num.Bit1 <span class="free">m</span><span class="main">)</span><span class="main">)</span> <span class="main">0</span> <span class="main">=</span> True"</span></span>
  <span class="quoted"><span class="quoted">"bit <span class="main">(</span>Int.Neg <span class="main">(</span>num.Bit0 <span class="free">m</span><span class="main">)</span><span class="main">)</span> <span class="main">0</span> <span class="main">=</span> False"</span></span>
  <span class="quoted"><span class="quoted">"bit <span class="main">(</span>Int.Neg <span class="main">(</span>num.Bit1 <span class="free">m</span><span class="main">)</span><span class="main">)</span> <span class="main">0</span> <span class="main">=</span> True"</span></span>
  <span class="quoted"><span class="quoted">"bit <span class="main">(</span>Int.Pos num.One<span class="main">)</span>      <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="main">=</span> False"</span></span>
  <span class="quoted"><span class="quoted">"bit <span class="main">(</span>Int.Pos <span class="main">(</span>num.Bit0 <span class="free">m</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="main">=</span> bit <span class="main">(</span>Int.Pos <span class="free">m</span><span class="main">)</span> <span class="free">n</span>"</span></span>
  <span class="quoted"><span class="quoted">"bit <span class="main">(</span>Int.Pos <span class="main">(</span>num.Bit1 <span class="free">m</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="main">=</span> bit <span class="main">(</span>Int.Pos <span class="free">m</span><span class="main">)</span> <span class="free">n</span>"</span></span>
  <span class="quoted"><span class="quoted">"bit <span class="main">(</span>Int.Neg <span class="main">(</span>num.Bit0 <span class="free">m</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="main">=</span> bit <span class="main">(</span>Int.Neg <span class="free">m</span><span class="main">)</span> <span class="free">n</span>"</span></span>
  <span class="quoted"><span class="quoted">"bit <span class="main">(</span>Int.Neg <span class="main">(</span>num.Bit1 <span class="free">m</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="main">=</span> bit <span class="main">(</span>Int.Neg <span class="main">(</span>Num.inc <span class="free">m</span><span class="main">)</span><span class="main">)</span> <span class="free">n</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Num.add_One bit_Suc<span class="main">)</span>

<span class="keyword1" id="Code_Symbolic_Bits_Int-int_not_code"><span class="command">lemma</span></span> int_not_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="keyword1">NOT</span> <span class="main">(</span><span class="main">0</span> <span class="main">::</span> int<span class="main">)</span> <span class="main">=</span> <span class="main">-</span><span class="main">1</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="keyword1">NOT</span> <span class="main">(</span>Int.Pos <span class="free">n</span><span class="main">)</span> <span class="main">=</span> Int.Neg <span class="main">(</span>Num.inc <span class="free">n</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="keyword1">NOT</span> <span class="main">(</span>Int.Neg <span class="free">n</span><span class="main">)</span> <span class="main">=</span> Num.sub <span class="free">n</span> num.One"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Num.add_One int_not_def<span class="main">)</span>

<span class="keyword1" id="Code_Symbolic_Bits_Int-int_and_code"><span class="command">lemma</span></span> int_and_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">i</span> <span class="free">j</span> <span class="main">::</span> <span class="quoted">int</span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="keyword1">AND</span> <span class="free">j</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="keyword1">AND</span> <span class="main">0</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="quoted"><span class="quoted">"Int.Pos <span class="free">n</span> <span class="keyword1">AND</span> Int.Pos <span class="free">m</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> bitAND_num <span class="free">n</span> <span class="free">m</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="main">0</span> <span class="main">|</span> Some <span class="bound">n'</span> <span class="main">⇒</span> Int.Pos <span class="bound">n'</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"Int.Neg <span class="free">n</span> <span class="keyword1">AND</span> Int.Neg <span class="free">m</span> <span class="main">=</span> <span class="keyword1">NOT</span> <span class="main">(</span>Num.sub <span class="free">n</span> num.One <span class="keyword1">OR</span> Num.sub <span class="free">m</span> num.One<span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"Int.Pos <span class="free">n</span> <span class="keyword1">AND</span> Int.Neg num.One <span class="main">=</span> Int.Pos <span class="free">n</span>"</span></span>
  <span class="quoted"><span class="quoted">"Int.Pos <span class="free">n</span> <span class="keyword1">AND</span> Int.Neg <span class="main">(</span>num.Bit0 <span class="free">m</span><span class="main">)</span> <span class="main">=</span> Num.sub <span class="main">(</span>bitORN_num <span class="main">(</span>Num.BitM <span class="free">m</span><span class="main">)</span> <span class="free">n</span><span class="main">)</span> num.One"</span></span>
  <span class="quoted"><span class="quoted">"Int.Pos <span class="free">n</span> <span class="keyword1">AND</span> Int.Neg <span class="main">(</span>num.Bit1 <span class="free">m</span><span class="main">)</span> <span class="main">=</span> Num.sub <span class="main">(</span>bitORN_num <span class="main">(</span>num.Bit0 <span class="free">m</span><span class="main">)</span> <span class="free">n</span><span class="main">)</span> num.One"</span></span>
  <span class="quoted"><span class="quoted">"Int.Neg num.One <span class="keyword1">AND</span> Int.Pos <span class="free">m</span> <span class="main">=</span> Int.Pos <span class="free">m</span>"</span></span>
  <span class="quoted"><span class="quoted">"Int.Neg <span class="main">(</span>num.Bit0 <span class="free">n</span><span class="main">)</span> <span class="keyword1">AND</span> Int.Pos <span class="free">m</span> <span class="main">=</span> Num.sub <span class="main">(</span>bitORN_num <span class="main">(</span>Num.BitM <span class="free">n</span><span class="main">)</span> <span class="free">m</span><span class="main">)</span> num.One"</span></span>
  <span class="quoted"><span class="quoted">"Int.Neg <span class="main">(</span>num.Bit1 <span class="free">n</span><span class="main">)</span> <span class="keyword1">AND</span> Int.Pos <span class="free">m</span> <span class="main">=</span> Num.sub <span class="main">(</span>bitORN_num <span class="main">(</span>num.Bit0 <span class="free">n</span><span class="main">)</span> <span class="free">m</span><span class="main">)</span> num.One"</span></span>
           <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> int_numeral_bitAND_num Num.add_One
              sub_inc_One_eq inc_BitM_eq not_minus_numeral_inc_eq
              <span class="quasi_keyword">flip</span><span class="main"><span class="main">:</span></span> int_not_neg_numeral int_or_not_bitORN_num <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">ac_simps</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Code_Symbolic_Bits_Int-int_or_code"><span class="command">lemma</span></span> int_or_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">i</span> <span class="free">j</span> <span class="main">::</span> <span class="quoted">int</span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="keyword1">OR</span> <span class="free">j</span> <span class="main">=</span> <span class="free">j</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="keyword1">OR</span> <span class="main">0</span> <span class="main">=</span> <span class="free">i</span>"</span></span>
  <span class="quoted"><span class="quoted">"Int.Pos <span class="free">n</span> <span class="keyword1">OR</span> Int.Pos <span class="free">m</span> <span class="main">=</span> Int.Pos <span class="main">(</span>bitOR_num <span class="free">n</span> <span class="free">m</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"Int.Neg <span class="free">n</span> <span class="keyword1">OR</span> Int.Neg <span class="free">m</span> <span class="main">=</span> <span class="keyword1">NOT</span> <span class="main">(</span>Num.sub <span class="free">n</span> num.One <span class="keyword1">AND</span> Num.sub <span class="free">m</span> num.One<span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"Int.Pos <span class="free">n</span> <span class="keyword1">OR</span> Int.Neg num.One <span class="main">=</span> Int.Neg num.One"</span></span>
  <span class="quoted"><span class="quoted">"Int.Pos <span class="free">n</span> <span class="keyword1">OR</span> Int.Neg <span class="main">(</span>num.Bit0 <span class="free">m</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> bitANDN_num <span class="main">(</span>Num.BitM <span class="free">m</span><span class="main">)</span> <span class="free">n</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="main">-</span><span class="main">1</span> <span class="main">|</span> Some <span class="bound">n'</span> <span class="main">⇒</span> Int.Neg <span class="main">(</span>Num.inc <span class="bound">n'</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"Int.Pos <span class="free">n</span> <span class="keyword1">OR</span> Int.Neg <span class="main">(</span>num.Bit1 <span class="free">m</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> bitANDN_num <span class="main">(</span>num.Bit0 <span class="free">m</span><span class="main">)</span> <span class="free">n</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="main">-</span><span class="main">1</span> <span class="main">|</span> Some <span class="bound">n'</span> <span class="main">⇒</span> Int.Neg <span class="main">(</span>Num.inc <span class="bound">n'</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"Int.Neg num.One <span class="keyword1">OR</span> Int.Pos <span class="free">m</span> <span class="main">=</span> Int.Neg num.One"</span></span>
  <span class="quoted"><span class="quoted">"Int.Neg <span class="main">(</span>num.Bit0 <span class="free">n</span><span class="main">)</span> <span class="keyword1">OR</span> Int.Pos <span class="free">m</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> bitANDN_num <span class="main">(</span>Num.BitM <span class="free">n</span><span class="main">)</span> <span class="free">m</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="main">-</span><span class="main">1</span> <span class="main">|</span> Some <span class="bound">n'</span> <span class="main">⇒</span> Int.Neg <span class="main">(</span>Num.inc <span class="bound">n'</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"Int.Neg <span class="main">(</span>num.Bit1 <span class="free">n</span><span class="main">)</span> <span class="keyword1">OR</span> Int.Pos <span class="free">m</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> bitANDN_num <span class="main">(</span>num.Bit0 <span class="free">n</span><span class="main">)</span> <span class="free">m</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="main">-</span><span class="main">1</span> <span class="main">|</span> Some <span class="bound">n'</span> <span class="main">⇒</span> Int.Neg <span class="main">(</span>Num.inc <span class="bound">n'</span><span class="main">)</span><span class="main">)</span>"</span></span>
           <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> int_numeral_bitOR_num <span class="quasi_keyword">flip</span><span class="main"><span class="main">:</span></span> int_not_neg_numeral<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> or_int_def int_and_comm int_not_and_bitANDN_num <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> int_not_simps<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Num.add_One<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Code_Symbolic_Bits_Int-int_xor_code"><span class="command">lemma</span></span> int_xor_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">i</span> <span class="free">j</span> <span class="main">::</span> <span class="quoted">int</span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="keyword1">XOR</span> <span class="free">j</span> <span class="main">=</span> <span class="free">j</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="keyword1">XOR</span> <span class="main">0</span> <span class="main">=</span> <span class="free">i</span>"</span></span>
  <span class="quoted"><span class="quoted">"Int.Pos <span class="free">n</span> <span class="keyword1">XOR</span> Int.Pos <span class="free">m</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> bitXOR_num <span class="free">n</span> <span class="free">m</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="main">0</span> <span class="main">|</span> Some <span class="bound">n'</span> <span class="main">⇒</span> Int.Pos <span class="bound">n'</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"Int.Neg <span class="free">n</span> <span class="keyword1">XOR</span> Int.Neg <span class="free">m</span> <span class="main">=</span> Num.sub <span class="free">n</span> num.One <span class="keyword1">XOR</span> Num.sub <span class="free">m</span> num.One"</span></span>
  <span class="quoted"><span class="quoted">"Int.Neg <span class="free">n</span> <span class="keyword1">XOR</span> Int.Pos <span class="free">m</span> <span class="main">=</span> <span class="keyword1">NOT</span> <span class="main">(</span>Num.sub <span class="free">n</span> num.One <span class="keyword1">XOR</span> Int.Pos <span class="free">m</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"Int.Pos <span class="free">n</span> <span class="keyword1">XOR</span> Int.Neg <span class="free">m</span> <span class="main">=</span> <span class="keyword1">NOT</span> <span class="main">(</span>Int.Pos <span class="free">n</span> <span class="keyword1">XOR</span> Num.sub <span class="free">m</span> num.One<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fold</span> int_not_neg_numeral<span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> int_numeral_bitXOR_num int_xor_not <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> option.case_cong<span class="main">)</span>

<span class="keyword1" id="Code_Symbolic_Bits_Int-bin_rest_code"><span class="command">lemma</span></span> bin_rest_code<span class="main">:</span> <span class="quoted"><span class="quoted">"bin_rest <span class="free">i</span> <span class="main">=</span> <span class="free">i</span> <span class="main">&gt;&gt;</span> <span class="main">1</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> shiftr_int_def<span class="main">)</span>

<span class="keyword1" id="Code_Symbolic_Bits_Int-set_bits_code"><span class="command">lemma</span></span> set_bits_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"set_bits <span class="main">=</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''set_bits is unsupported on type int''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> set_bits <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> int<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">i</span> <span class="main">::</span> <span class="quoted">int</span> 
  <span class="keyword2"><span class="keyword">shows</span></span> int_set_bit_True_conv_OR <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"set_bit <span class="free">i</span> <span class="free">n</span> True <span class="main">=</span> <span class="free">i</span> <span class="keyword1">OR</span> <span class="main">(</span><span class="main">1</span> <span class="main">&lt;&lt;</span> <span class="free">n</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> int_set_bit_False_conv_NAND <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"set_bit <span class="free">i</span> <span class="free">n</span> False <span class="main">=</span> <span class="free">i</span> <span class="keyword1">AND</span> <span class="keyword1">NOT</span> <span class="main">(</span><span class="main">1</span> <span class="main">&lt;&lt;</span> <span class="free">n</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> int_set_bit_conv_ops<span class="main">:</span> <span class="quoted"><span class="quoted">"set_bit <span class="free">i</span> <span class="free">n</span> <span class="free">b</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">b</span> <span class="keyword1">then</span> <span class="free">i</span> <span class="keyword1">OR</span> <span class="main">(</span><span class="main">1</span> <span class="main">&lt;&lt;</span> <span class="free">n</span><span class="main">)</span> <span class="keyword1">else</span> <span class="free">i</span> <span class="keyword1">AND</span> <span class="keyword1">NOT</span> <span class="main">(</span><span class="main">1</span> <span class="main">&lt;&lt;</span> <span class="free">n</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_bit_int_def bin_set_conv_OR bin_clr_conv_NAND<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">‹drop_bit <span class="main">::</span> nat <span class="main">⇒</span> int <span class="main">⇒</span> int›</span></span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Code_Symbolic_Bits_Int-drop_bit_int_code"><span class="command">lemma</span></span> drop_bit_int_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">i</span> <span class="main">::</span> <span class="quoted">int</span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"drop_bit <span class="main">0</span> <span class="free">i</span> <span class="main">=</span> <span class="free">i</span>"</span></span>
  <span class="quoted"><span class="quoted">"drop_bit <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="main">0</span> <span class="main">=</span> <span class="main">(</span><span class="main">0</span> <span class="main">::</span> int<span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"drop_bit <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="main">(</span>Int.Pos num.One<span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="quoted"><span class="quoted">"drop_bit <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="main">(</span>Int.Pos <span class="main">(</span>num.Bit0 <span class="free">m</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> drop_bit <span class="free">n</span> <span class="main">(</span>Int.Pos <span class="free">m</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"drop_bit <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="main">(</span>Int.Pos <span class="main">(</span>num.Bit1 <span class="free">m</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> drop_bit <span class="free">n</span> <span class="main">(</span>Int.Pos <span class="free">m</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"drop_bit <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="main">(</span>Int.Neg num.One<span class="main">)</span> <span class="main">=</span> <span class="main">-</span> <span class="main">1</span>"</span></span>
  <span class="quoted"><span class="quoted">"drop_bit <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="main">(</span>Int.Neg <span class="main">(</span>num.Bit0 <span class="free">m</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> drop_bit <span class="free">n</span> <span class="main">(</span>Int.Neg <span class="free">m</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"drop_bit <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="main">(</span>Int.Neg <span class="main">(</span>num.Bit1 <span class="free">m</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> drop_bit <span class="free">n</span> <span class="main">(</span>Int.Neg <span class="main">(</span>Num.inc <span class="free">m</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> shiftr_eq_drop_bit drop_bit_Suc add_One<span class="main">)</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">‹push_bit <span class="main">::</span> nat <span class="main">⇒</span> int <span class="main">⇒</span> int›</span></span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Code_Symbolic_Bits_Int-push_bit_int_code"><span class="command">lemma</span></span> push_bit_int_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"push_bit <span class="main">0</span> <span class="free">i</span> <span class="main">=</span> <span class="free">i</span>"</span></span>
  <span class="quoted"><span class="quoted">"push_bit <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="free">i</span> <span class="main">=</span> push_bit <span class="free">n</span> <span class="main">(</span>Int.dup <span class="free">i</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">ac_simps</span></span><span class="main">)</span>

<span class="keyword1" id="Code_Symbolic_Bits_Int-int_lsb_code"><span class="command">lemma</span></span> int_lsb_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lsb <span class="main">(</span><span class="main">0</span> <span class="main">::</span> int<span class="main">)</span> <span class="main">=</span> False"</span></span>
  <span class="quoted"><span class="quoted">"lsb <span class="main">(</span>Int.Pos num.One<span class="main">)</span> <span class="main">=</span> True"</span></span>
  <span class="quoted"><span class="quoted">"lsb <span class="main">(</span>Int.Pos <span class="main">(</span>num.Bit0 <span class="free">w</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> False"</span></span>
  <span class="quoted"><span class="quoted">"lsb <span class="main">(</span>Int.Pos <span class="main">(</span>num.Bit1 <span class="free">w</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> True"</span></span>
  <span class="quoted"><span class="quoted">"lsb <span class="main">(</span>Int.Neg num.One<span class="main">)</span> <span class="main">=</span> True"</span></span>
  <span class="quoted"><span class="quoted">"lsb <span class="main">(</span>Int.Neg <span class="main">(</span>num.Bit0 <span class="free">w</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> False"</span></span>
  <span class="quoted"><span class="quoted">"lsb <span class="main">(</span>Int.Neg <span class="main">(</span>num.Bit1 <span class="free">w</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> True"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Bits_Integer">
<div class="head">
<h1>Theory Bits_Integer</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Bits_Integer.thy
    Author:     Andreas Lochbihler, ETH Zurich
*)</span>

<span class="keyword1"><span class="command">chapter</span></span> <span class="quoted"><span class="plain_text">‹Bit operations for target language integers›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Bits_Integer <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="More_Bits_Int.html">More_Bits_Int</a>
  <a href="Code_Symbolic_Bits_Int.html">Code_Symbolic_Bits_Int</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span> <span class="main">=</span>
  identity_quotient
  fun_quotient
  Quotient_integer<span class="main">[</span><span class="operator">folded</span> integer.pcr_cr_eq<span class="main">]</span>

<span class="keyword1" id="Bits_Integer-undefined_transfer"><span class="command">lemma</span></span> undefined_transfer<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Quotient <span class="free">R</span> <span class="free">Abs</span> <span class="free">Rep</span> <span class="free">T</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">T</span> <span class="main">(</span><span class="free">Rep</span> undefined<span class="main">)</span> undefined"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> Quotient_alt_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">bundle</span></span> undefined_transfer <span class="main">=</span> undefined_transfer<span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹More lemmas about <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">integer</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>s›</span></span>

<span class="keyword1"><span class="command">context</span></span>
<span class="keyword2"><span class="keyword">includes</span></span> integer.lifting
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Bits_Integer-bitval_integer_transfer"><span class="command">lemma</span></span> bitval_integer_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>rel_fun <span class="main">(=)</span> pcr_integer<span class="main">)</span> of_bool of_bool"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> of_bool_def integer.pcr_cr_eq cr_integer_def<span class="main">)</span>

<span class="keyword1" id="Bits_Integer-integer_of_nat_less_0_conv"><span class="command">lemma</span></span> integer_of_nat_less_0_conv <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> integer_of_nat <span class="free">n</span> <span class="main">&lt;</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">transfer</span><span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1" id="Bits_Integer-int_of_integer_pow"><span class="command">lemma</span></span> int_of_integer_pow<span class="main">:</span> <span class="quoted"><span class="quoted">"int_of_integer <span class="main">(</span><span class="free">x</span> <span class="main">^</span> <span class="free">n</span><span class="main">)</span> <span class="main">=</span> int_of_integer <span class="free">x</span> <span class="main">^</span> <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Bits_Integer-pow_integer_transfer"><span class="command">lemma</span></span> pow_integer_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>rel_fun pcr_integer <span class="main">(</span>rel_fun <span class="main">(=)</span> pcr_integer<span class="main">)</span><span class="main">)</span> <span class="main">(^)</span> <span class="main">(^)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> integer.pcr_cr_eq cr_integer_def int_of_integer_pow<span class="main">)</span>

<span class="keyword1" id="Bits_Integer-sub1_lt_0_iff"><span class="command">lemma</span></span> sub1_lt_0_iff <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Code_Numeral.sub <span class="free">n</span> num.One <span class="main">&lt;</span> <span class="main">0</span> <span class="main">⟷</span> False"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Code_Numeral.sub_code<span class="main">)</span>

<span class="keyword1" id="Bits_Integer-nat_of_integer_numeral"><span class="command">lemma</span></span> nat_of_integer_numeral <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"nat_of_integer <span class="main">(</span>numeral <span class="free">n</span><span class="main">)</span> <span class="main">=</span> numeral <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Bits_Integer-nat_of_integer_sub1_conv_pred_numeral"><span class="command">lemma</span></span> nat_of_integer_sub1_conv_pred_numeral <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"nat_of_integer <span class="main">(</span>Code_Numeral.sub <span class="free">n</span> num.One<span class="main">)</span> <span class="main">=</span> pred_numeral <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Code_Numeral.sub_code<span class="main">)</span>

<span class="keyword1" id="Bits_Integer-nat_of_integer_1"><span class="command">lemma</span></span> nat_of_integer_1 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"nat_of_integer <span class="main">1</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Bits_Integer-dup_1"><span class="command">lemma</span></span> dup_1 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Code_Numeral.dup <span class="main">1</span> <span class="main">=</span> <span class="numeral">2</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Bit operations on <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">integer</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Bit operations on <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">integer</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> are the same as on <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">int</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> bin_rest_integer <span class="main">::</span> <span class="quoted"><span class="quoted">"integer <span class="main">⇒</span> integer"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">bin_rest</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> bin_last_integer <span class="main">::</span> <span class="quoted"><span class="quoted">"integer <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">bin_last</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> Bit_integer <span class="main">::</span> <span class="quoted"><span class="quoted">"integer <span class="main">⇒</span> bool <span class="main">⇒</span> integer"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">‹<span class="main">λ</span><span class="bound">k</span> <span class="bound">b</span><span class="main">.</span> of_bool <span class="bound">b</span> <span class="main">+</span> <span class="numeral">2</span> <span class="main">*</span> <span class="bound">k</span>›</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instance</span></span> integer <span class="main">::</span> <span class="quoted">semiring_bit_syntax</span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax integer.lifting
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Bits_Integer-test_bit_integer_transfer"><span class="command">lemma</span></span> test_bit_integer_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">‹<span class="main">(</span>pcr_integer <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> bit <span class="main">(!!)</span>›</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> test_bit_eq_bit <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Bits_Integer-shiftl_integer_transfer"><span class="command">lemma</span></span> shiftl_integer_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">‹<span class="main">(</span>pcr_integer <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> pcr_integer<span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">k</span> <span class="bound">n</span><span class="main">.</span> push_bit <span class="bound">n</span> <span class="bound">k</span><span class="main">)</span> <span class="main">(&lt;&lt;)</span>›</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> shiftl_eq_push_bit <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Bits_Integer-shiftr_integer_transfer"><span class="command">lemma</span></span> shiftr_integer_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">‹<span class="main">(</span>pcr_integer <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> pcr_integer<span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">k</span> <span class="bound">n</span><span class="main">.</span> drop_bit <span class="bound">n</span> <span class="bound">k</span><span class="main">)</span> <span class="main">(&gt;&gt;)</span>›</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> shiftr_eq_drop_bit <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> integer <span class="main">::</span> <span class="quoted">lsb</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> integer.lifting <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">lsb_integer</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"integer <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">lsb</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">instance</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">transfer</span><span class="main">)</span> <span class="main">(</span><span class="operator">fact</span> lsb_odd<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> integer <span class="main">::</span> <span class="quoted">msb</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> integer.lifting <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">msb_integer</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"integer <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">msb</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> integer <span class="main">::</span> <span class="quoted">set_bit</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> integer.lifting <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">set_bit_integer</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"integer <span class="main">⇒</span> nat <span class="main">⇒</span> bool <span class="main">⇒</span> integer"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">set_bit</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">instance</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">standard</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">bit_simps</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="entity">wf_set_bits_integer</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">wf_set_bits_integer</span> <span class="main">≡</span> wf_set_bits_int"</span></span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Target language implementations›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Unfortunately, this is not straightforward,
  because these API functions have different signatures and preconditions on the parameters:

  \begin{description}
  \item[Standard ML] Shifts in IntInf are given as word, but not IntInf.
  \item[Haskell] In the Data.Bits.Bits type class, shifts and bit indices are given as Int rather than Integer.
  \end{description}

  Additional constants take only parameters of type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">integer</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> rather than <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">nat</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
  and check the preconditions as far as possible (e.g., being non-negative) in a portable way.
  Manual implementations inside code\_printing perform the remaining range checks and convert
  these <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">integer</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>s into the right type.

  For normalisation by evaluation, we derive custom code equations, because NBE
  does not know these code\_printing serialisations and would otherwise loop.
›</span></span>

<span class="keyword1"><span class="command">code_identifier</span></span> <span class="keyword2"><span class="keyword">code_module</span></span> Bits_Integer <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> Bits_Int <span class="keyword2"><span class="keyword">and</span></span> <span class="main">(</span>OCaml<span class="main">)</span> Bits_Int <span class="keyword2"><span class="keyword">and</span></span> <span class="main">(</span>Haskell<span class="main">)</span> Bits_Int <span class="keyword2"><span class="keyword">and</span></span> <span class="main">(</span>Scala<span class="main">)</span> Bits_Int

<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">code_module</span></span> Bits_Integer <span class="main">⇀</span> <span class="main">(</span>SML<span class="main">)</span>
<span class="quoted">‹structure Bits_Integer : sig
  val set_bit : IntInf.int -&gt; IntInf.int -&gt; bool -&gt; IntInf.int
  val shiftl : IntInf.int -&gt; IntInf.int -&gt; IntInf.int
  val shiftr : IntInf.int -&gt; IntInf.int -&gt; IntInf.int
  val test_bit : IntInf.int -&gt; IntInf.int -&gt; bool
end = struct

val maxWord = IntInf.pow (2, Word.wordSize);

fun set_bit x n b =
  if n &lt; maxWord then
    if b then IntInf.orb (x, IntInf.&lt;&lt; (1, Word.fromLargeInt (IntInf.toLarge n)))
    else IntInf.andb (x, IntInf.notb (IntInf.&lt;&lt; (1, Word.fromLargeInt (IntInf.toLarge n))))
  else raise (Fail ("Bit index too large: " ^ IntInf.toString n));

fun shiftl x n =
  if n &lt; maxWord then IntInf.&lt;&lt; (x, Word.fromLargeInt (IntInf.toLarge n))
  else raise (Fail ("Shift operand too large: " ^ IntInf.toString n));

fun shiftr x n =
  if n &lt; maxWord then IntInf.~&gt;&gt; (x, Word.fromLargeInt (IntInf.toLarge n))
  else raise (Fail ("Shift operand too large: " ^ IntInf.toString n));

fun test_bit x n =
  if n &lt; maxWord then IntInf.andb (x, IntInf.&lt;&lt; (1, Word.fromLargeInt (IntInf.toLarge n))) &lt;&gt; 0
  else raise (Fail ("Bit index too large: " ^ IntInf.toString n));

end; (*struct Bits_Integer*)›</span>
<span class="keyword1"><span class="command">code_reserved</span></span> SML Bits_Integer

<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">code_module</span></span> Bits_Integer <span class="main">⇀</span> <span class="main">(</span>OCaml<span class="main">)</span>
<span class="quoted">‹module Bits_Integer : sig
  val shiftl : Z.t -&gt; Z.t -&gt; Z.t
  val shiftr : Z.t -&gt; Z.t -&gt; Z.t
  val test_bit : Z.t -&gt; Z.t -&gt; bool
end = struct

(* We do not need an explicit range checks here,
   because Big_int.int_of_big_int raises Failure
   if the argument does not fit into an int. *)
let shiftl x n = Z.shift_left x (Z.to_int n);;

let shiftr x n = Z.shift_right x (Z.to_int n);;

let test_bit x n =  Z.testbit x (Z.to_int n);;

end;; (*struct Bits_Integer*)›</span>
<span class="keyword1"><span class="command">code_reserved</span></span> OCaml Bits_Integer

<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">code_module</span></span> Data_Bits <span class="main">⇀</span> <span class="main">(</span>Haskell<span class="main">)</span>
<span class="quoted">‹
module Data_Bits where {

import qualified Data.Bits;

{-
  The ...Bounded functions assume that the Integer argument for the shift
  or bit index fits into an Int, is non-negative and (for types of fixed bit width)
  less than bitSize
-}

infixl 7 .&amp;.;
infixl 6 `xor`;
infixl 5 .|.;

(.&amp;.) :: Data.Bits.Bits a =&gt; a -&gt; a -&gt; a;
(.&amp;.) = (Data.Bits..&amp;.);

xor :: Data.Bits.Bits a =&gt; a -&gt; a -&gt; a;
xor = Data.Bits.xor;

(.|.) :: Data.Bits.Bits a =&gt; a -&gt; a -&gt; a;
(.|.) = (Data.Bits..|.);

complement :: Data.Bits.Bits a =&gt; a -&gt; a;
complement = Data.Bits.complement;

testBitUnbounded :: Data.Bits.Bits a =&gt; a -&gt; Integer -&gt; Bool;
testBitUnbounded x b
  | b &lt;= toInteger (Prelude.maxBound :: Int) = Data.Bits.testBit x (fromInteger b)
  | otherwise = error ("Bit index too large: " ++ show b)
;

testBitBounded :: Data.Bits.Bits a =&gt; a -&gt; Integer -&gt; Bool;
testBitBounded x b = Data.Bits.testBit x (fromInteger b);

setBitUnbounded :: Data.Bits.Bits a =&gt; a -&gt; Integer -&gt; Bool -&gt; a;
setBitUnbounded x n b
  | n &lt;= toInteger (Prelude.maxBound :: Int) =
    if b then Data.Bits.setBit x (fromInteger n) else Data.Bits.clearBit x (fromInteger n)
  | otherwise = error ("Bit index too large: " ++ show n)
;

setBitBounded :: Data.Bits.Bits a =&gt; a -&gt; Integer -&gt; Bool -&gt; a;
setBitBounded x n True = Data.Bits.setBit x (fromInteger n);
setBitBounded x n False = Data.Bits.clearBit x (fromInteger n);

shiftlUnbounded :: Data.Bits.Bits a =&gt; a -&gt; Integer -&gt; a;
shiftlUnbounded x n
  | n &lt;= toInteger (Prelude.maxBound :: Int) = Data.Bits.shiftL x (fromInteger n)
  | otherwise = error ("Shift operand too large: " ++ show n)
;

shiftlBounded :: Data.Bits.Bits a =&gt; a -&gt; Integer -&gt; a;
shiftlBounded x n = Data.Bits.shiftL x (fromInteger n);

shiftrUnbounded :: Data.Bits.Bits a =&gt; a -&gt; Integer -&gt; a;
shiftrUnbounded x n
  | n &lt;= toInteger (Prelude.maxBound :: Int) = Data.Bits.shiftR x (fromInteger n)
  | otherwise = error ("Shift operand too large: " ++ show n)
;

shiftrBounded :: (Ord a, Data.Bits.Bits a) =&gt; a -&gt; Integer -&gt; a;
shiftrBounded x n = Data.Bits.shiftR x (fromInteger n);

}›</span>

  <span class="keyword2"><span class="keyword">and</span></span> <span class="comment1">― ‹<span class="antiquoted"><span class="antiquote">@{</span><span class="operator">theory</span> <a href="../../HOL/HOL/Quickcheck_Narrowing.html">HOL.Quickcheck_Narrowing</a><span class="antiquote">}</span></span> maps <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">integer</span><span class="antiquote">}</span></span> to
            Haskell's Prelude.Int type instead of Integer. For compatibility
            with the Haskell target, we nevertheless provide bounded and
            unbounded functions.›</span>
  <span class="main">(</span>Haskell_Quickcheck<span class="main">)</span>
<span class="quoted">‹
module Data_Bits where {

import qualified Data.Bits;

{-
  The functions assume that the Int argument for the shift or bit index is
  non-negative and (for types of fixed bit width) less than bitSize
-}

infixl 7 .&amp;.;
infixl 6 `xor`;
infixl 5 .|.;

(.&amp;.) :: Data.Bits.Bits a =&gt; a -&gt; a -&gt; a;
(.&amp;.) = (Data.Bits..&amp;.);

xor :: Data.Bits.Bits a =&gt; a -&gt; a -&gt; a;
xor = Data.Bits.xor;

(.|.) :: Data.Bits.Bits a =&gt; a -&gt; a -&gt; a;
(.|.) = (Data.Bits..|.);

complement :: Data.Bits.Bits a =&gt; a -&gt; a;
complement = Data.Bits.complement;

testBitUnbounded :: Data.Bits.Bits a =&gt; a -&gt; Prelude.Int -&gt; Bool;
testBitUnbounded = Data.Bits.testBit;

testBitBounded :: Data.Bits.Bits a =&gt; a -&gt; Prelude.Int -&gt; Bool;
testBitBounded = Data.Bits.testBit;

setBitUnbounded :: Data.Bits.Bits a =&gt; a -&gt; Prelude.Int -&gt; Bool -&gt; a;
setBitUnbounded x n True = Data.Bits.setBit x n;
setBitUnbounded x n False = Data.Bits.clearBit x n;

setBitBounded :: Data.Bits.Bits a =&gt; a -&gt; Prelude.Int -&gt; Bool -&gt; a;
setBitBounded x n True = Data.Bits.setBit x n;
setBitBounded x n False = Data.Bits.clearBit x n;

shiftlUnbounded :: Data.Bits.Bits a =&gt; a -&gt; Prelude.Int -&gt; a;
shiftlUnbounded = Data.Bits.shiftL;

shiftlBounded :: Data.Bits.Bits a =&gt; a -&gt; Prelude.Int -&gt; a;
shiftlBounded = Data.Bits.shiftL;

shiftrUnbounded :: Data.Bits.Bits a =&gt; a -&gt; Prelude.Int -&gt; a;
shiftrUnbounded = Data.Bits.shiftR;

shiftrBounded :: (Ord a, Data.Bits.Bits a) =&gt; a -&gt; Prelude.Int -&gt; a;
shiftrBounded = Data.Bits.shiftR;

}›</span>
<span class="keyword1"><span class="command">code_reserved</span></span> Haskell Data_Bits

<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">code_module</span></span> Bits_Integer <span class="main">⇀</span> <span class="main">(</span>Scala<span class="main">)</span>
<span class="quoted">‹object Bits_Integer {

def setBit(x: BigInt, n: BigInt, b: Boolean) : BigInt =
  if (n.isValidInt)
    if (b)
      x.setBit(n.toInt)
    else
      x.clearBit(n.toInt)
  else
    sys.error("Bit index too large: " + n.toString)

def shiftl(x: BigInt, n: BigInt) : BigInt =
  if (n.isValidInt)
    x &lt;&lt; n.toInt
  else
    sys.error("Shift index too large: " + n.toString)

def shiftr(x: BigInt, n: BigInt) : BigInt =
  if (n.isValidInt)
    x &lt;&lt; n.toInt
  else
    sys.error("Shift index too large: " + n.toString)

def testBit(x: BigInt, n: BigInt) : Boolean =
  if (n.isValidInt)
    x.testBit(n.toInt)
  else
    sys.error("Bit index too large: " + n.toString)

} /* object Bits_Integer */›</span>

<span class="keyword1"><span class="command">code_printing</span></span>
  <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">(AND)</span> <span class="main">::</span> integer <span class="main">⇒</span> integer <span class="main">⇒</span> integer"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"IntInf.andb ((_),/ (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Z.logand"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"((Data'_Bits..&amp;.) :: Integer -&gt; Integer -&gt; Integer)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell_Quickcheck<span class="main">)</span> <span class="quoted">"((Data'_Bits..&amp;.) :: Prelude.Int -&gt; Prelude.Int -&gt; Prelude.Int)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 3 <span class="quoted">"&amp;"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">(OR)</span> <span class="main">::</span> integer <span class="main">⇒</span> integer <span class="main">⇒</span> integer"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"IntInf.orb ((_),/ (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Z.logor"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"((Data'_Bits..|.) :: Integer -&gt; Integer -&gt; Integer)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell_Quickcheck<span class="main">)</span> <span class="quoted">"((Data'_Bits..|.) :: Prelude.Int -&gt; Prelude.Int -&gt; Prelude.Int)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 1 <span class="quoted">"|"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">(XOR)</span> <span class="main">::</span> integer <span class="main">⇒</span> integer <span class="main">⇒</span> integer"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"IntInf.xorb ((_),/ (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Z.logxor"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"(Data'_Bits.xor :: Integer -&gt; Integer -&gt; Integer)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell_Quickcheck<span class="main">)</span> <span class="quoted">"(Data'_Bits.xor :: Prelude.Int -&gt; Prelude.Int -&gt; Prelude.Int)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 2 <span class="quoted">"^"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">NOT</span> <span class="main">::</span> integer <span class="main">⇒</span> integer"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"IntInf.notb"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Z.lognot"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"(Data'_Bits.complement :: Integer -&gt; Integer)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell_Quickcheck<span class="main">)</span> <span class="quoted">"(Data'_Bits.complement :: Prelude.Int -&gt; Prelude.Int)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"_.unary'_~"</span>

<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">bin_rest_integer</span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"IntInf.div ((_), 2)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Z.shift'_right/ _/ 1"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"(Data'_Bits.shiftrUnbounded _ 1 :: Integer)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell_Quickcheck<span class="main">)</span> <span class="quoted">"(Data'_Bits.shiftrUnbounded _ 1 :: Prelude.Int)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"_ &gt;&gt; 1"</span>

<span class="keyword1"><span class="command">context</span></span>
<span class="keyword2"><span class="keyword">includes</span></span> integer.lifting
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Bits_Integer-bitNOT_integer_code"><span class="command">lemma</span></span> bitNOT_integer_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">i</span> <span class="main">::</span> <span class="quoted">integer</span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="keyword1">NOT</span> <span class="free">i</span> <span class="main">=</span> <span class="main">-</span> <span class="free">i</span> <span class="main">-</span> <span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> int_not_def<span class="main">)</span>

<span class="keyword1" id="Bits_Integer-bin_rest_integer_code"><span class="command">lemma</span></span> bin_rest_integer_code <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">nbe</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"bin_rest_integer <span class="free">i</span> <span class="main">=</span> <span class="free">i</span> <span class="keyword1">div</span> <span class="numeral">2</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">rule</span>

<span class="keyword1" id="Bits_Integer-bin_last_integer_code"><span class="command">lemma</span></span> bin_last_integer_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"bin_last_integer <span class="free">i</span> <span class="main">⟷</span> <span class="free">i</span> <span class="keyword1">AND</span> <span class="main">1</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">rule</span> bin_last_conv_AND<span class="main">)</span>

<span class="keyword1" id="Bits_Integer-bin_last_integer_nbe"><span class="command">lemma</span></span> bin_last_integer_nbe <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">nbe</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"bin_last_integer <span class="free">i</span> <span class="main">⟷</span> <span class="free">i</span> <span class="keyword1">mod</span> <span class="numeral">2</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bin_last_def<span class="main">)</span>

<span class="keyword1" id="Bits_Integer-bitval_bin_last_integer"><span class="command">lemma</span></span> bitval_bin_last_integer <span class="main">[</span><span class="operator">code_unfold</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"of_bool <span class="main">(</span>bin_last_integer <span class="free">i</span><span class="main">)</span> <span class="main">=</span> <span class="free">i</span> <span class="keyword1">AND</span> <span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">rule</span> bitval_bin_last<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">integer_test_bit</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"integer <span class="main">⇒</span> integer <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">integer_test_bit</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">&lt;</span> <span class="main">0</span> <span class="keyword1">then</span> undefined <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">else</span> bit <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span>nat_of_integer <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">‹bit <span class="main">::</span> integer <span class="main">⇒</span> nat <span class="main">⇒</span> bool›</span></span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Bits_Integer-bit_integer_code"><span class="command">lemma</span></span> bit_integer_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"bit <span class="free">x</span> <span class="free">n</span> <span class="main">⟷</span> integer_test_bit <span class="free">x</span> <span class="main">(</span>integer_of_nat <span class="free">n</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> integer_test_bit_def<span class="main">)</span>

<span class="keyword1" id="Bits_Integer-integer_test_bit_code"><span class="command">lemma</span></span> integer_test_bit_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"integer_test_bit <span class="free">x</span> <span class="main">(</span>Code_Numeral.Neg <span class="free">n</span><span class="main">)</span> <span class="main">=</span> undefined <span class="free">x</span> <span class="main">(</span>Code_Numeral.Neg <span class="free">n</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"integer_test_bit <span class="main">0</span> <span class="main">0</span> <span class="main">=</span> False"</span></span>
  <span class="quoted"><span class="quoted">"integer_test_bit <span class="main">0</span> <span class="main">(</span>Code_Numeral.Pos <span class="free">n</span><span class="main">)</span> <span class="main">=</span> False"</span></span>
  <span class="quoted"><span class="quoted">"integer_test_bit <span class="main">(</span>Code_Numeral.Pos num.One<span class="main">)</span>      <span class="main">0</span> <span class="main">=</span> True"</span></span>
  <span class="quoted"><span class="quoted">"integer_test_bit <span class="main">(</span>Code_Numeral.Pos <span class="main">(</span>num.Bit0 <span class="free">n</span><span class="main">)</span><span class="main">)</span> <span class="main">0</span> <span class="main">=</span> False"</span></span>
  <span class="quoted"><span class="quoted">"integer_test_bit <span class="main">(</span>Code_Numeral.Pos <span class="main">(</span>num.Bit1 <span class="free">n</span><span class="main">)</span><span class="main">)</span> <span class="main">0</span> <span class="main">=</span> True"</span></span>
  <span class="quoted"><span class="quoted">"integer_test_bit <span class="main">(</span>Code_Numeral.Pos num.One<span class="main">)</span>      <span class="main">(</span>Code_Numeral.Pos <span class="free">n'</span><span class="main">)</span> <span class="main">=</span> False"</span></span>
  <span class="quoted"><span class="quoted">"integer_test_bit <span class="main">(</span>Code_Numeral.Pos <span class="main">(</span>num.Bit0 <span class="free">n</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Code_Numeral.Pos <span class="free">n'</span><span class="main">)</span> <span class="main">=</span>
   integer_test_bit <span class="main">(</span>Code_Numeral.Pos <span class="free">n</span><span class="main">)</span> <span class="main">(</span>Code_Numeral.sub <span class="free">n'</span> num.One<span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"integer_test_bit <span class="main">(</span>Code_Numeral.Pos <span class="main">(</span>num.Bit1 <span class="free">n</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Code_Numeral.Pos <span class="free">n'</span><span class="main">)</span> <span class="main">=</span>
   integer_test_bit <span class="main">(</span>Code_Numeral.Pos <span class="free">n</span><span class="main">)</span> <span class="main">(</span>Code_Numeral.sub <span class="free">n'</span> num.One<span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"integer_test_bit <span class="main">(</span>Code_Numeral.Neg num.One<span class="main">)</span>      <span class="main">0</span> <span class="main">=</span> True"</span></span>
  <span class="quoted"><span class="quoted">"integer_test_bit <span class="main">(</span>Code_Numeral.Neg <span class="main">(</span>num.Bit0 <span class="free">n</span><span class="main">)</span><span class="main">)</span> <span class="main">0</span> <span class="main">=</span> False"</span></span>
  <span class="quoted"><span class="quoted">"integer_test_bit <span class="main">(</span>Code_Numeral.Neg <span class="main">(</span>num.Bit1 <span class="free">n</span><span class="main">)</span><span class="main">)</span> <span class="main">0</span> <span class="main">=</span> True"</span></span>
  <span class="quoted"><span class="quoted">"integer_test_bit <span class="main">(</span>Code_Numeral.Neg num.One<span class="main">)</span>      <span class="main">(</span>Code_Numeral.Pos <span class="free">n'</span><span class="main">)</span> <span class="main">=</span> True"</span></span>
  <span class="quoted"><span class="quoted">"integer_test_bit <span class="main">(</span>Code_Numeral.Neg <span class="main">(</span>num.Bit0 <span class="free">n</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Code_Numeral.Pos <span class="free">n'</span><span class="main">)</span> <span class="main">=</span>
   integer_test_bit <span class="main">(</span>Code_Numeral.Neg <span class="free">n</span><span class="main">)</span> <span class="main">(</span>Code_Numeral.sub <span class="free">n'</span> num.One<span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"integer_test_bit <span class="main">(</span>Code_Numeral.Neg <span class="main">(</span>num.Bit1 <span class="free">n</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Code_Numeral.Pos <span class="free">n'</span><span class="main">)</span> <span class="main">=</span>
   integer_test_bit <span class="main">(</span>Code_Numeral.Neg <span class="main">(</span><span class="free">n</span> <span class="main">+</span> num.One<span class="main">)</span><span class="main">)</span> <span class="main">(</span>Code_Numeral.sub <span class="free">n'</span> num.One<span class="main">)</span>"</span></span>
                <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> integer_test_bit_def bit_integer_def<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> bin_nth_numeral_simps bit_numeral_int_simps<span class="main">(</span>6<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">presburger</span>

<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">integer_test_bit</span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Bits'_Integer.test'_bit"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Bits'_Integer.test'_bit"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"(Data'_Bits.testBitUnbounded :: Integer -&gt; Integer -&gt; Bool)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell_Quickcheck<span class="main">)</span> <span class="quoted">"(Data'_Bits.testBitUnbounded :: Prelude.Int -&gt; Prelude.Int -&gt; Bool)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"Bits'_Integer.testBit"</span>

<span class="keyword1"><span class="command">context</span></span>
<span class="keyword2"><span class="keyword">includes</span></span> integer.lifting
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Bits_Integer-lsb_integer_code"><span class="command">lemma</span></span> lsb_integer_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span> <span class="main">::</span> <span class="quoted">integer</span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"lsb <span class="free">x</span> <span class="main">=</span> bit <span class="free">x</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lsb_int_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">integer_set_bit</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"integer <span class="main">⇒</span> integer <span class="main">⇒</span> bool <span class="main">⇒</span> integer"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">integer_set_bit</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">&lt;</span> <span class="main">0</span> <span class="keyword1">then</span> undefined <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="keyword1">else</span> set_bit <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span>nat_of_integer <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Bits_Integer-set_bit_integer_code"><span class="command">lemma</span></span> set_bit_integer_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"set_bit <span class="free">x</span> <span class="free">i</span> <span class="free">b</span> <span class="main">=</span> integer_set_bit <span class="free">x</span> <span class="main">(</span>integer_of_nat <span class="free">i</span><span class="main">)</span> <span class="free">b</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> integer_set_bit_def<span class="main">)</span>

<span class="keyword1" id="Bits_Integer-set_bit_integer_conv_masks"><span class="command">lemma</span></span> set_bit_integer_conv_masks<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span> <span class="main">::</span> <span class="quoted">integer</span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"set_bit <span class="free">x</span> <span class="free">i</span> <span class="free">b</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">b</span> <span class="keyword1">then</span> <span class="free">x</span> <span class="keyword1">OR</span> <span class="main">(</span><span class="main">1</span> <span class="main">&lt;&lt;</span> <span class="free">i</span><span class="main">)</span> <span class="keyword1">else</span> <span class="free">x</span> <span class="keyword1">AND</span> <span class="keyword1">NOT</span> <span class="main">(</span><span class="main">1</span> <span class="main">&lt;&lt;</span> <span class="free">i</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> int_set_bit_False_conv_NAND int_set_bit_True_conv_OR shiftl_eq_push_bit<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">integer_set_bit</span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Bits'_Integer.set'_bit"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"(Data'_Bits.setBitUnbounded :: Integer -&gt; Integer -&gt; Bool -&gt; Integer)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell_Quickcheck<span class="main">)</span> <span class="quoted">"(Data'_Bits.setBitUnbounded :: Prelude.Int -&gt; Prelude.Int -&gt; Bool -&gt; Prelude.Int)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"Bits'_Integer.setBit"</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  OCaml.Big\_int does not have a method for changing an individual bit, so we emulate that with masks.
  We prefer an Isabelle implementation, because this then takes care of the signs for AND and OR.
›</span></span>
<span class="keyword1" id="Bits_Integer-integer_set_bit_code"><span class="command">lemma</span></span> integer_set_bit_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"integer_set_bit <span class="free">x</span> <span class="free">n</span> <span class="free">b</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="main">0</span> <span class="keyword1">then</span> undefined <span class="free">x</span> <span class="free">n</span> <span class="free">b</span> <span class="keyword1">else</span>
   <span class="keyword1">if</span> <span class="free">b</span> <span class="keyword1">then</span> <span class="free">x</span> <span class="keyword1">OR</span> <span class="main">(</span>push_bit <span class="main">(</span>nat_of_integer <span class="free">n</span><span class="main">)</span> <span class="main">1</span><span class="main">)</span>
   <span class="keyword1">else</span> <span class="free">x</span> <span class="keyword1">AND</span> <span class="keyword1">NOT</span> <span class="main">(</span>push_bit <span class="main">(</span>nat_of_integer <span class="free">n</span><span class="main">)</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> integer_set_bit_def not_less set_bit_eq set_bit_def unset_bit_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">integer_shiftl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"integer <span class="main">⇒</span> integer <span class="main">⇒</span> integer"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">integer_shiftl</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">&lt;</span> <span class="main">0</span> <span class="keyword1">then</span> undefined <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">else</span> push_bit <span class="main">(</span>nat_of_integer <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">‹push_bit <span class="main">::</span> nat <span class="main">⇒</span> integer <span class="main">⇒</span> integer›</span></span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Bits_Integer-shiftl_integer_code"><span class="command">lemma</span></span> shiftl_integer_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span> <span class="main">::</span> <span class="quoted">integer</span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"push_bit <span class="free">n</span> <span class="free">x</span> <span class="main">=</span> integer_shiftl <span class="free">x</span> <span class="main">(</span>integer_of_nat <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> integer_shiftl_def<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span>
<span class="keyword2"><span class="keyword">includes</span></span> integer.lifting
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Bits_Integer-shiftl_integer_conv_mult_pow2"><span class="command">lemma</span></span> shiftl_integer_conv_mult_pow2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span> <span class="main">::</span> <span class="quoted">integer</span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">&lt;&lt;</span> <span class="free">n</span> <span class="main">=</span> <span class="free">x</span> <span class="main">*</span> <span class="numeral">2</span> <span class="main">^</span> <span class="free">n</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> push_bit_eq_mult shiftl_eq_push_bit<span class="main">)</span>

<span class="keyword1" id="Bits_Integer-integer_shiftl_code"><span class="command">lemma</span></span> integer_shiftl_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"integer_shiftl <span class="free">x</span> <span class="main">(</span>Code_Numeral.Neg <span class="free">n</span><span class="main">)</span> <span class="main">=</span> undefined <span class="free">x</span> <span class="main">(</span>Code_Numeral.Neg <span class="free">n</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"integer_shiftl <span class="free">x</span> <span class="main">0</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="quoted"><span class="quoted">"integer_shiftl <span class="free">x</span> <span class="main">(</span>Code_Numeral.Pos <span class="free">n</span><span class="main">)</span> <span class="main">=</span> integer_shiftl <span class="main">(</span>Code_Numeral.dup <span class="free">x</span><span class="main">)</span> <span class="main">(</span>Code_Numeral.sub <span class="free">n</span> num.One<span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"integer_shiftl <span class="main">0</span> <span class="main">(</span>Code_Numeral.Pos <span class="free">n</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> integer_shiftl_def numeral_eq_Suc<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">ac_simps</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">integer_shiftl</span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Bits'_Integer.shiftl"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Bits'_Integer.shiftl"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"(Data'_Bits.shiftlUnbounded :: Integer -&gt; Integer -&gt; Integer)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell_Quickcheck<span class="main">)</span> <span class="quoted">"(Data'_Bits.shiftlUnbounded :: Prelude.Int -&gt; Prelude.Int -&gt; Prelude.Int)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"Bits'_Integer.shiftl"</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">integer_shiftr</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"integer <span class="main">⇒</span> integer <span class="main">⇒</span> integer"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">integer_shiftr</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">&lt;</span> <span class="main">0</span> <span class="keyword1">then</span> undefined <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">else</span> drop_bit <span class="main">(</span>nat_of_integer <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">‹drop_bit <span class="main">::</span> nat <span class="main">⇒</span> integer <span class="main">⇒</span> integer›</span></span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Bits_Integer-shiftr_integer_conv_div_pow2"><span class="command">lemma</span></span> shiftr_integer_conv_div_pow2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">includes</span></span> integer.lifting <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span> <span class="main">::</span> <span class="quoted">integer</span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">&gt;&gt;</span> <span class="free">n</span> <span class="main">=</span> <span class="free">x</span> <span class="keyword1">div</span> <span class="numeral">2</span> <span class="main">^</span> <span class="free">n</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> drop_bit_eq_div shiftr_eq_drop_bit<span class="main">)</span>

<span class="keyword1" id="Bits_Integer-shiftr_integer_code"><span class="command">lemma</span></span> shiftr_integer_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span> <span class="main">::</span> <span class="quoted">integer</span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"drop_bit <span class="free">n</span> <span class="free">x</span> <span class="main">=</span> integer_shiftr <span class="free">x</span> <span class="main">(</span>integer_of_nat <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> integer_shiftr_def<span class="main">)</span>

<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">integer_shiftr</span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Bits'_Integer.shiftr"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Bits'_Integer.shiftr"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"(Data'_Bits.shiftrUnbounded :: Integer -&gt; Integer -&gt; Integer)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell_Quickcheck<span class="main">)</span> <span class="quoted">"(Data'_Bits.shiftrUnbounded :: Prelude.Int -&gt; Prelude.Int -&gt; Prelude.Int)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"Bits'_Integer.shiftr"</span>

<span class="keyword1" id="Bits_Integer-integer_shiftr_code"><span class="command">lemma</span></span> integer_shiftr_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">includes</span></span> integer.lifting
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"integer_shiftr <span class="free">x</span> <span class="main">(</span>Code_Numeral.Neg <span class="free">n</span><span class="main">)</span> <span class="main">=</span> undefined <span class="free">x</span> <span class="main">(</span>Code_Numeral.Neg <span class="free">n</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"integer_shiftr <span class="free">x</span> <span class="main">0</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="quoted"><span class="quoted">"integer_shiftr <span class="main">0</span> <span class="main">(</span>Code_Numeral.Pos <span class="free">n</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="quoted"><span class="quoted">"integer_shiftr <span class="main">(</span>Code_Numeral.Pos num.One<span class="main">)</span> <span class="main">(</span>Code_Numeral.Pos <span class="free">n</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="quoted"><span class="quoted">"integer_shiftr <span class="main">(</span>Code_Numeral.Pos <span class="main">(</span>num.Bit0 <span class="free">n'</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Code_Numeral.Pos <span class="free">n</span><span class="main">)</span> <span class="main">=</span>
   integer_shiftr <span class="main">(</span>Code_Numeral.Pos <span class="free">n'</span><span class="main">)</span> <span class="main">(</span>Code_Numeral.sub <span class="free">n</span> num.One<span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"integer_shiftr <span class="main">(</span>Code_Numeral.Pos <span class="main">(</span>num.Bit1 <span class="free">n'</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Code_Numeral.Pos <span class="free">n</span><span class="main">)</span> <span class="main">=</span>
   integer_shiftr <span class="main">(</span>Code_Numeral.Pos <span class="free">n'</span><span class="main">)</span> <span class="main">(</span>Code_Numeral.sub <span class="free">n</span> num.One<span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"integer_shiftr <span class="main">(</span>Code_Numeral.Neg num.One<span class="main">)</span> <span class="main">(</span>Code_Numeral.Pos <span class="free">n</span><span class="main">)</span> <span class="main">=</span> <span class="main">-</span><span class="main">1</span>"</span></span>
  <span class="quoted"><span class="quoted">"integer_shiftr <span class="main">(</span>Code_Numeral.Neg <span class="main">(</span>num.Bit0 <span class="free">n'</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Code_Numeral.Pos <span class="free">n</span><span class="main">)</span> <span class="main">=</span>
   integer_shiftr <span class="main">(</span>Code_Numeral.Neg <span class="free">n'</span><span class="main">)</span> <span class="main">(</span>Code_Numeral.sub <span class="free">n</span> num.One<span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"integer_shiftr <span class="main">(</span>Code_Numeral.Neg <span class="main">(</span>num.Bit1 <span class="free">n'</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Code_Numeral.Pos <span class="free">n</span><span class="main">)</span> <span class="main">=</span>
   integer_shiftr <span class="main">(</span>Code_Numeral.Neg <span class="main">(</span>Num.inc <span class="free">n'</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Code_Numeral.sub <span class="free">n</span> num.One<span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> integer_shiftr_def numeral_eq_Suc drop_bit_Suc<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> add_One<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">context</span></span>
<span class="keyword2"><span class="keyword">includes</span></span> integer.lifting
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Bits_Integer-Bit_integer_code"><span class="command">lemma</span></span> Bit_integer_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Bit_integer <span class="free">i</span> False <span class="main">=</span> push_bit <span class="main">1</span> <span class="free">i</span>"</span></span>
  <span class="quoted"><span class="quoted">"Bit_integer <span class="free">i</span> True <span class="main">=</span> <span class="main">(</span>push_bit <span class="main">1</span> <span class="free">i</span><span class="main">)</span> <span class="main">+</span> <span class="main">1</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> shiftl_int_def<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Bits_Integer-msb_integer_code"><span class="command">lemma</span></span> msb_integer_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"msb <span class="main">(</span><span class="free">x</span> <span class="main">::</span> integer<span class="main">)</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">&lt;</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> msb_int_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span>
<span class="keyword2"><span class="keyword">includes</span></span> integer.lifting natural.lifting
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Bits_Integer-bitAND_integer_unfold"><span class="command">lemma</span></span> bitAND_integer_unfold <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="keyword1">AND</span> <span class="free">y</span> <span class="main">=</span>
   <span class="main">(</span><span class="keyword1">if</span> <span class="free">x</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">0</span>
    <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="free">x</span> <span class="main">=</span> <span class="main">-</span> <span class="main">1</span> <span class="keyword1">then</span> <span class="free">y</span>
    <span class="keyword1">else</span> Bit_integer <span class="main">(</span>bin_rest_integer <span class="free">x</span> <span class="keyword1">AND</span> bin_rest_integer <span class="free">y</span><span class="main">)</span> <span class="main">(</span>bin_last_integer <span class="free">x</span> <span class="main">∧</span> bin_last_integer <span class="free">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span>
    <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">algebra_simps</span></span>
      and_int_rec <span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted">‹<span class="main">_</span> <span class="main">*</span> <span class="numeral">2</span>›</span></span><span class="main"><span class="main">]</span></span> and_int_rec <span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted">‹<span class="main">_</span> <span class="main">*</span> <span class="numeral">2</span>›</span></span><span class="main"><span class="main">]</span></span> and_int_rec <span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted">‹<span class="main">1</span> <span class="main">+</span> <span class="main">_</span> <span class="main">*</span> <span class="numeral">2</span>›</span></span><span class="main"><span class="main">]</span></span>
      <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> evenE oddE<span class="main">)</span>

<span class="keyword1" id="Bits_Integer-bitOR_integer_unfold"><span class="command">lemma</span></span> bitOR_integer_unfold <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="keyword1">OR</span> <span class="free">y</span> <span class="main">=</span>
   <span class="main">(</span><span class="keyword1">if</span> <span class="free">x</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="free">y</span>
    <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="free">x</span> <span class="main">=</span> <span class="main">-</span> <span class="main">1</span> <span class="keyword1">then</span> <span class="main">-</span> <span class="main">1</span>
    <span class="keyword1">else</span> Bit_integer <span class="main">(</span>bin_rest_integer <span class="free">x</span> <span class="keyword1">OR</span> bin_rest_integer <span class="free">y</span><span class="main">)</span> <span class="main">(</span>bin_last_integer <span class="free">x</span> <span class="main">∨</span> bin_last_integer <span class="free">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span>
    <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">algebra_simps</span></span>
      or_int_rec <span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted">‹<span class="main">_</span> <span class="main">*</span> <span class="numeral">2</span>›</span></span><span class="main"><span class="main">]</span></span> or_int_rec <span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted">‹<span class="main">1</span> <span class="main">+</span> <span class="main">_</span> <span class="main">*</span> <span class="numeral">2</span>›</span></span><span class="main"><span class="main">]</span></span> or_int_rec <span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted">‹<span class="main">1</span> <span class="main">+</span> <span class="main">_</span> <span class="main">*</span> <span class="numeral">2</span>›</span></span><span class="main"><span class="main">]</span></span>
      <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> evenE oddE<span class="main">)</span>

<span class="keyword1" id="Bits_Integer-bitXOR_integer_unfold"><span class="command">lemma</span></span> bitXOR_integer_unfold <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="keyword1">XOR</span> <span class="free">y</span> <span class="main">=</span>
   <span class="main">(</span><span class="keyword1">if</span> <span class="free">x</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="free">y</span>
    <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="free">x</span> <span class="main">=</span> <span class="main">-</span> <span class="main">1</span> <span class="keyword1">then</span> <span class="keyword1">NOT</span> <span class="free">y</span>
    <span class="keyword1">else</span> Bit_integer <span class="main">(</span>bin_rest_integer <span class="free">x</span> <span class="keyword1">XOR</span> bin_rest_integer <span class="free">y</span><span class="main">)</span>
      <span class="main">(</span><span class="main">¬</span> bin_last_integer <span class="free">x</span> <span class="main">⟷</span> bin_last_integer <span class="free">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span>
    <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">algebra_simps</span></span>
      xor_int_rec <span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted">‹<span class="main">_</span> <span class="main">*</span> <span class="numeral">2</span>›</span></span><span class="main"><span class="main">]</span></span> xor_int_rec <span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted">‹<span class="main">_</span> <span class="main">*</span> <span class="numeral">2</span>›</span></span><span class="main"><span class="main">]</span></span> xor_int_rec <span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted">‹<span class="main">1</span> <span class="main">+</span> <span class="main">_</span> <span class="main">*</span> <span class="numeral">2</span>›</span></span><span class="main"><span class="main">]</span></span>
      <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> evenE oddE<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Test code generator setup›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">bit_integer_test</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">bit_integer_test</span> <span class="main">=</span>
  <span class="main">(</span><span class="main">(</span><span class="main">[</span> <span class="main">-</span><span class="main">1</span> <span class="keyword1">AND</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">1</span> <span class="keyword1">AND</span> <span class="main">-</span><span class="numeral">3</span><span class="main">,</span> <span class="numeral">3</span> <span class="keyword1">AND</span> <span class="numeral">5</span><span class="main">,</span> <span class="main">-</span><span class="numeral">3</span> <span class="keyword1">AND</span> <span class="main">(</span><span class="main">-</span> <span class="numeral">5</span><span class="main">)</span>
    <span class="main">,</span> <span class="main">-</span><span class="numeral">3</span> <span class="keyword1">OR</span> <span class="main">1</span><span class="main">,</span> <span class="main">1</span> <span class="keyword1">OR</span> <span class="main">-</span><span class="numeral">3</span><span class="main">,</span> <span class="numeral">3</span> <span class="keyword1">OR</span> <span class="numeral">5</span><span class="main">,</span> <span class="main">-</span><span class="numeral">3</span> <span class="keyword1">OR</span> <span class="main">(</span><span class="main">-</span> <span class="numeral">5</span><span class="main">)</span>
    <span class="main">,</span> <span class="keyword1">NOT</span> <span class="main">1</span><span class="main">,</span> <span class="keyword1">NOT</span> <span class="main">(</span><span class="main">-</span> <span class="numeral">3</span><span class="main">)</span>
    <span class="main">,</span> <span class="main">-</span><span class="main">1</span> <span class="keyword1">XOR</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">1</span> <span class="keyword1">XOR</span> <span class="main">(</span><span class="main">-</span> <span class="numeral">3</span><span class="main">)</span><span class="main">,</span> <span class="numeral">3</span> <span class="keyword1">XOR</span> <span class="numeral">5</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="keyword1">XOR</span> <span class="main">(</span><span class="main">-</span> <span class="numeral">3</span><span class="main">)</span>
    <span class="main">,</span> set_bit <span class="numeral">5</span> <span class="numeral">4</span> True<span class="main">,</span> set_bit <span class="main">(</span><span class="main">-</span> <span class="numeral">5</span><span class="main">)</span> <span class="numeral">2</span> True<span class="main">,</span> set_bit <span class="numeral">5</span> <span class="main">0</span> False<span class="main">,</span> set_bit <span class="main">(</span><span class="main">-</span> <span class="numeral">5</span><span class="main">)</span> <span class="main">1</span> False
    <span class="main">,</span> <span class="main">1</span> <span class="main">&lt;&lt;</span> <span class="numeral">2</span><span class="main">,</span> <span class="main">-</span><span class="main">1</span> <span class="main">&lt;&lt;</span> <span class="numeral">3</span>
    <span class="main">,</span> <span class="numeral">100</span> <span class="main">&gt;&gt;</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">-</span><span class="numeral">100</span> <span class="main">&gt;&gt;</span> <span class="numeral">3</span><span class="main">]</span> <span class="main">::</span> integer list<span class="main">)</span>
  <span class="main">=</span> <span class="main">[</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">1</span><span class="main">,</span> <span class="main">1</span><span class="main">,</span> <span class="main">-</span><span class="numeral">7</span>
    <span class="main">,</span> <span class="main">-</span><span class="numeral">3</span><span class="main">,</span> <span class="main">-</span><span class="numeral">3</span><span class="main">,</span> <span class="numeral">7</span><span class="main">,</span> <span class="main">-</span><span class="main">1</span>
    <span class="main">,</span> <span class="main">-</span><span class="numeral">2</span><span class="main">,</span> <span class="numeral">2</span>
    <span class="main">,</span> <span class="main">-</span><span class="numeral">4</span><span class="main">,</span> <span class="main">-</span><span class="numeral">4</span><span class="main">,</span> <span class="numeral">6</span><span class="main">,</span> <span class="numeral">6</span>
    <span class="main">,</span> <span class="numeral">21</span><span class="main">,</span> <span class="main">-</span><span class="main">1</span><span class="main">,</span> <span class="numeral">4</span><span class="main">,</span> <span class="main">-</span><span class="numeral">7</span>
    <span class="main">,</span> <span class="numeral">4</span><span class="main">,</span> <span class="main">-</span><span class="numeral">8</span>
    <span class="main">,</span> <span class="numeral">12</span><span class="main">,</span> <span class="main">-</span><span class="numeral">13</span><span class="main">]</span> <span class="main">∧</span>
    <span class="main">[</span> <span class="main">(</span><span class="numeral">5</span> <span class="main">::</span> integer<span class="main">)</span> <span class="main">!!</span> <span class="numeral">4</span><span class="main">,</span> <span class="main">(</span><span class="numeral">5</span> <span class="main">::</span> integer<span class="main">)</span> <span class="main">!!</span> <span class="numeral">2</span><span class="main">,</span> <span class="main">(</span><span class="main">-</span><span class="numeral">5</span> <span class="main">::</span> integer<span class="main">)</span> <span class="main">!!</span> <span class="numeral">4</span><span class="main">,</span> <span class="main">(</span><span class="main">-</span><span class="numeral">5</span> <span class="main">::</span> integer<span class="main">)</span> <span class="main">!!</span> <span class="numeral">2</span>
    <span class="main">,</span> lsb <span class="main">(</span><span class="numeral">5</span> <span class="main">::</span> integer<span class="main">)</span><span class="main">,</span> lsb <span class="main">(</span><span class="numeral">4</span> <span class="main">::</span> integer<span class="main">)</span><span class="main">,</span> lsb <span class="main">(</span><span class="main">-</span><span class="main">1</span> <span class="main">::</span> integer<span class="main">)</span><span class="main">,</span> lsb <span class="main">(</span><span class="main">-</span><span class="numeral">2</span> <span class="main">::</span> integer<span class="main">)</span><span class="main">,</span>
      msb <span class="main">(</span><span class="numeral">5</span> <span class="main">::</span> integer<span class="main">)</span><span class="main">,</span> msb <span class="main">(</span><span class="main">0</span> <span class="main">::</span> integer<span class="main">)</span><span class="main">,</span> msb <span class="main">(</span><span class="main">-</span><span class="main">1</span> <span class="main">::</span> integer<span class="main">)</span><span class="main">,</span> msb <span class="main">(</span><span class="main">-</span><span class="numeral">2</span> <span class="main">::</span> integer<span class="main">)</span><span class="main">]</span>
  <span class="main">=</span> <span class="main">[</span> False<span class="main">,</span> True<span class="main">,</span> True<span class="main">,</span> False<span class="main">,</span>
      True<span class="main">,</span> False<span class="main">,</span> True<span class="main">,</span> False<span class="main">,</span>
      False<span class="main">,</span> False<span class="main">,</span> True<span class="main">,</span> True<span class="main">]</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">bit_integer_test</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML Haskell<span class="main">?</span> Haskell_Quickcheck<span class="main">?</span> OCaml<span class="main">?</span> Scala

<span class="keyword1"><span class="command">notepad</span></span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">have</span></span> <span class="quoted">bit_integer_test</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">have</span></span> <span class="quoted">bit_integer_test</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">normalization</span>
<span class="keyword1"><span class="command">have</span></span> <span class="quoted">bit_integer_test</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">code_simp</span>
<span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword1"><span class="command">ML_val</span></span> <span class="quoted">‹<span class="keyword1"><span class="keyword">val</span></span> true <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">bit_integer_test</span><span class="antiquote">}</span></span></span>›</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="keyword1">AND</span> <span class="free">y</span> <span class="main">=</span> <span class="free">x</span> <span class="keyword1">OR</span> <span class="main">(</span><span class="free">y</span> <span class="main">::</span> integer<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">quickcheck</span></span><span class="main">[</span>random<span class="main">,</span> expect<span class="main">=</span>counterexample<span class="main">]</span>
<span class="keyword1"><span class="command">quickcheck</span></span><span class="main">[</span>exhaustive<span class="main">,</span> expect<span class="main">=</span>counterexample<span class="main">]</span>
<span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">::</span> integer<span class="main">)</span> <span class="keyword1">AND</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span> <span class="keyword1">OR</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">quickcheck</span></span><span class="main">[</span>narrowing<span class="main">,</span> expect<span class="main">=</span>no_counterexample<span class="main">]</span>
<span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span> <span class="main">::</span> integer <span class="main">⇒</span> unit<span class="main">)</span> <span class="main">=</span> <span class="free">g</span>"</span></span>
<span class="keyword1"><span class="command">quickcheck</span></span><span class="main">[</span>narrowing<span class="main">,</span> size<span class="main">=</span>3<span class="main">,</span> expect<span class="main">=</span>no_counterexample<span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span>

<span class="keyword1"><span class="command">hide_const</span></span> bit_integer_test
<span class="keyword1"><span class="command">hide_fact</span></span> bit_integer_test_def

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Code_Target_Bits_Int">
<div class="head">
<h1>Theory Code_Target_Bits_Int</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Code_Target_Bits_Int.thy
    Author:     Andreas Lochbihler, ETH Zurich
*)</span>

<span class="keyword1"><span class="command">chapter</span></span> <span class="quoted"><span class="plain_text">‹Implementation of bit operations on int by target language operations›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Code_Target_Bits_Int
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Bits_Integer.html">Bits_Integer</a>
  <span class="quoted">"<a href="../../HOL/HOL-Library/Code_Target_Int.html">HOL-Library.Code_Target_Int</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span>
  <span class="quoted"><span class="quoted">"<span class="keyword1">(AND)</span> <span class="main">::</span> int <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">(OR)</span> <span class="main">::</span> int <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">(XOR)</span> <span class="main">::</span> int <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">NOT</span><span class="main">)</span> <span class="main">::</span> int <span class="main">⇒</span> <span class="main">_</span>"</span></span>
  <span class="quoted"><span class="quoted">"lsb <span class="main">::</span> int <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="quoted"><span class="quoted">"set_bit <span class="main">::</span> int <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="quoted"><span class="quoted">"bit <span class="main">::</span> int <span class="main">⇒</span> <span class="main">_</span>"</span></span>
  <span class="quoted"><span class="quoted">"push_bit <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> int <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="quoted"><span class="quoted">"drop_bit <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> int <span class="main">⇒</span> <span class="main">_</span>"</span></span>
  <span class="quoted">int_of_integer_symbolic</span>
  <span class="main">]</span><span class="main">]</span>

<span class="keyword1"><span class="command">declare</span></span> bitval_bin_last <span class="main">[</span><span class="operator">code_unfold</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">‹bit <span class="free">x</span> <span class="free">n</span> <span class="main">⟷</span> <span class="free">x</span> <span class="keyword1">AND</span> <span class="main">(</span>push_bit <span class="free">n</span> <span class="main">1</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span>›</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">x</span> <span class="main">::</span> <span class="quoted">int</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fact</span> bit_iff_and_push_bit_not_eq_0<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span>
<span class="keyword2"><span class="keyword">includes</span></span> integer.lifting
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Code_Target_Bits_Int-bit_int_code"><span class="command">lemma</span></span> bit_int_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"bit <span class="main">(</span>int_of_integer <span class="free">x</span><span class="main">)</span> <span class="free">n</span> <span class="main">=</span> bit <span class="free">x</span> <span class="free">n</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Code_Target_Bits_Int-and_int_code"><span class="command">lemma</span></span> and_int_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"int_of_integer <span class="free">i</span> <span class="keyword1">AND</span> int_of_integer <span class="free">j</span> <span class="main">=</span> int_of_integer <span class="main">(</span><span class="free">i</span> <span class="keyword1">AND</span> <span class="free">j</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Code_Target_Bits_Int-or_int_code"><span class="command">lemma</span></span> or_int_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"int_of_integer <span class="free">i</span> <span class="keyword1">OR</span> int_of_integer <span class="free">j</span> <span class="main">=</span> int_of_integer <span class="main">(</span><span class="free">i</span> <span class="keyword1">OR</span> <span class="free">j</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Code_Target_Bits_Int-xor_int_code"><span class="command">lemma</span></span> xor_int_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"int_of_integer <span class="free">i</span> <span class="keyword1">XOR</span> int_of_integer <span class="free">j</span> <span class="main">=</span> int_of_integer <span class="main">(</span><span class="free">i</span> <span class="keyword1">XOR</span> <span class="free">j</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Code_Target_Bits_Int-not_int_code"><span class="command">lemma</span></span> not_int_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="keyword1">NOT</span> <span class="main">(</span>int_of_integer <span class="free">i</span><span class="main">)</span> <span class="main">=</span> int_of_integer <span class="main">(</span><span class="keyword1">NOT</span> <span class="free">i</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Code_Target_Bits_Int-push_bit_int_code"><span class="command">lemma</span></span> push_bit_int_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">‹push_bit <span class="free">n</span> <span class="main">(</span>int_of_integer <span class="free">x</span><span class="main">)</span> <span class="main">=</span> int_of_integer <span class="main">(</span>push_bit <span class="free">n</span> <span class="free">x</span><span class="main">)</span>›</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Code_Target_Bits_Int-drop_bit_int_code"><span class="command">lemma</span></span> drop_bit_int_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">‹drop_bit <span class="free">n</span> <span class="main">(</span>int_of_integer <span class="free">x</span><span class="main">)</span> <span class="main">=</span> int_of_integer <span class="main">(</span>drop_bit <span class="free">n</span> <span class="free">x</span><span class="main">)</span>›</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Code_Target_Bits_Int-take_bit_int_code"><span class="command">lemma</span></span> take_bit_int_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">‹take_bit <span class="free">n</span> <span class="main">(</span>int_of_integer <span class="free">x</span><span class="main">)</span> <span class="main">=</span> int_of_integer <span class="main">(</span>take_bit <span class="free">n</span> <span class="free">x</span><span class="main">)</span>›</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Code_Target_Bits_Int-lsb_int_code"><span class="command">lemma</span></span> lsb_int_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lsb <span class="main">(</span>int_of_integer <span class="free">x</span><span class="main">)</span> <span class="main">=</span> lsb <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Code_Target_Bits_Int-set_bit_int_code"><span class="command">lemma</span></span> set_bit_int_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"set_bit <span class="main">(</span>int_of_integer <span class="free">x</span><span class="main">)</span> <span class="free">n</span> <span class="free">b</span> <span class="main">=</span> int_of_integer <span class="main">(</span>set_bit <span class="free">x</span> <span class="free">n</span> <span class="free">b</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Code_Target_Bits_Int-int_of_integer_symbolic_code"><span class="command">lemma</span></span> int_of_integer_symbolic_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"int_of_integer_symbolic <span class="main">=</span> int_of_integer"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> int_of_integer_symbolic_def<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword2"><span class="keyword">qualified</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="entity">even</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹int <span class="main">⇒</span> bool›</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_abbrev</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">‹<span class="free">even</span> <span class="main">=</span> Parity.even›</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">‹Code_Target_Bits_Int.even <span class="free">i</span> <span class="main">⟷</span> <span class="free">i</span> <span class="keyword1">AND</span> <span class="main">1</span> <span class="main">=</span> <span class="main">0</span>›</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Code_Target_Bits_Int.even_def even_iff_mod_2_eq_zero and_one_eq<span class="main">)</span>

<span class="keyword1" id="Code_Target_Bits_Int-bin_rest_code"><span class="command">lemma</span></span> bin_rest_code<span class="main">:</span>
  <span class="quoted"><span class="quoted">"bin_rest <span class="main">(</span>int_of_integer <span class="free">i</span><span class="main">)</span> <span class="main">=</span> int_of_integer <span class="main">(</span>bin_rest_integer <span class="free">i</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Code_Target_Word_Base">
<div class="head">
<h1>Theory Code_Target_Word_Base</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Code_Target_Word_Base.thy
    Author:     Andreas Lochbihler, ETH Zurich
*)</span>

<span class="keyword1"><span class="command">chapter</span></span> <span class="quoted"><span class="plain_text">‹Common base for target language implementations of word types›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Code_Target_Word_Base <span class="keyword2"><span class="keyword">imports</span></span>
  <span class="quoted">"<a href="../../HOL/HOL-Library/Word.html">HOL-Library.Word</a>"</span>
  <span class="quoted">"<a href="../Word_Lib/Signed_Division_Word.html">Word_Lib.Signed_Division_Word</a>"</span>
  <a href="Bits_Integer.html">Bits_Integer</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹More lemmas›</span></span>

<span class="keyword1" id="Code_Target_Word_Base-div_half_nat"><span class="command">lemma</span></span> div_half_nat<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span> <span class="free">y</span> <span class="main">::</span> <span class="quoted">nat</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="keyword1">div</span> <span class="free">y</span><span class="main">,</span> <span class="free">x</span> <span class="keyword1">mod</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">q</span> <span class="main">=</span> <span class="numeral">2</span> <span class="main">*</span> <span class="main">(</span><span class="free">x</span> <span class="keyword1">div</span> <span class="numeral">2</span> <span class="keyword1">div</span> <span class="free">y</span><span class="main">)</span><span class="main">;</span> <span class="bound">r</span> <span class="main">=</span> <span class="free">x</span> <span class="main">-</span> <span class="bound">q</span> <span class="main">*</span> <span class="free">y</span> <span class="keyword1">in</span> <span class="keyword1">if</span> <span class="free">y</span> <span class="main">≤</span> <span class="bound">r</span> <span class="keyword1">then</span> <span class="main">(</span><span class="bound">q</span> <span class="main">+</span> <span class="main">1</span><span class="main">,</span> <span class="bound">r</span> <span class="main">-</span> <span class="free">y</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">(</span><span class="bound">q</span><span class="main">,</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?q</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="numeral">2</span> <span class="main">*</span> <span class="main">(</span><span class="free">x</span> <span class="keyword1">div</span> <span class="numeral">2</span> <span class="keyword1">div</span> <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> q<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?q</span> <span class="main">=</span> <span class="free">x</span> <span class="keyword1">div</span> <span class="free">y</span> <span class="main">-</span> <span class="free">x</span> <span class="keyword1">div</span> <span class="free">y</span> <span class="keyword1">mod</span> <span class="numeral">2</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">metis</span> div_mult2_eq mult.commute minus_mod_eq_mult_div <span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?r</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">-</span> <span class="var">?q</span> <span class="main">*</span> <span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> r<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?r</span> <span class="main">=</span> <span class="free">x</span> <span class="keyword1">mod</span> <span class="free">y</span> <span class="main">+</span> <span class="free">x</span> <span class="keyword1">div</span> <span class="free">y</span> <span class="keyword1">mod</span> <span class="numeral">2</span> <span class="main">*</span> <span class="free">y</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> q diff_mult_distrib minus_mod_eq_div_mult <span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">metis</span> diff_diff_cancel mod_less_eq_dividend mod_mult2_eq add.commute mult.commute<span class="main">)</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">≤</span> <span class="free">x</span> <span class="main">-</span> <span class="var">?q</span> <span class="main">*</span> <span class="free">y</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword1"><span class="command">with</span></span> assms q <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="keyword1">div</span> <span class="free">y</span> <span class="keyword1">mod</span> <span class="numeral">2</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> r
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Nat.add_0_right diff_0_eq_0 diff_Suc_1 le_div_geq mod2_gr_0 mod_div_trivial mult_0 neq0_conv numeral_1_eq_Suc_0 numerals<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span> 
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="keyword1">div</span> <span class="free">y</span> <span class="main">=</span> <span class="var">?q</span> <span class="main">+</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> q
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command"><span class="improper">hence</span></span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="keyword1">mod</span> <span class="free">y</span> <span class="main">=</span> <span class="var">?r</span> <span class="main">-</span> <span class="free">y</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span><span class="main">(</span><span class="operator">metis</span> minus_div_mult_eq_mod <span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> diff_commute diff_diff_left mult_Suc<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> True <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="keyword1">div</span> <span class="free">y</span> <span class="keyword1">mod</span> <span class="numeral">2</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> r
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_le<span class="main">)</span><span class="main">(</span><span class="operator">metis</span> Nat.add_0_right assms div_less div_mult_self2 mod_div_trivial mult.commute<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="keyword1">div</span> <span class="free">y</span> <span class="main">=</span> <span class="var">?q</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> q <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command"><span class="improper">hence</span></span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="keyword1">mod</span> <span class="free">y</span> <span class="main">=</span> <span class="var">?r</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> minus_div_mult_eq_mod <span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> False <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Code_Target_Word_Base-div_half_word"><span class="command">lemma</span></span> div_half_word<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span> <span class="free">y</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> len word"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="keyword1">div</span> <span class="free">y</span><span class="main">,</span> <span class="free">x</span> <span class="keyword1">mod</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">q</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span> <span class="main">&gt;&gt;</span> <span class="main">1</span><span class="main">)</span> <span class="keyword1">div</span> <span class="free">y</span> <span class="main">&lt;&lt;</span> <span class="main">1</span><span class="main">;</span> <span class="bound">r</span> <span class="main">=</span> <span class="free">x</span> <span class="main">-</span> <span class="bound">q</span> <span class="main">*</span> <span class="free">y</span> <span class="keyword1">in</span> <span class="keyword1">if</span> <span class="free">y</span> <span class="main">≤</span> <span class="bound">r</span> <span class="keyword1">then</span> <span class="main">(</span><span class="bound">q</span> <span class="main">+</span> <span class="main">1</span><span class="main">,</span> <span class="bound">r</span> <span class="main">-</span> <span class="free">y</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">(</span><span class="bound">q</span><span class="main">,</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">n</span></span> <span class="keyword2"><span class="keyword">where</span></span> n<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> of_nat <span class="skolem">n</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">&lt;</span> <span class="numeral">2</span> <span class="main">^</span> <span class="keyword1">LENGTH</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> that <span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">‹unat <span class="free"><span class="free"><span class="free">x</span></span></span>›</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">m</span></span> <span class="keyword2"><span class="keyword">where</span></span> m<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">=</span> of_nat <span class="skolem">m</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="main">&lt;</span> <span class="numeral">2</span> <span class="main">^</span> <span class="keyword1">LENGTH</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> that <span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">‹unat <span class="free"><span class="free"><span class="free">y</span></span></span>›</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">‹unat <span class="main">(</span>of_nat <span class="skolem">n</span> <span class="main">::</span> <span class="tfree">'a</span> word<span class="main">)</span> <span class="main">=</span> <span class="skolem">n</span>›</span></span> <span class="quoted"><span class="quoted">‹unat <span class="main">(</span>of_nat <span class="skolem">m</span> <span class="main">::</span> <span class="tfree">'a</span> word<span class="main">)</span> <span class="main">=</span> <span class="skolem">m</span>›</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> take_bit_of_nat take_bit_nat_eq_self_iff<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?q</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">&gt;&gt;</span> <span class="main">1</span><span class="main">)</span> <span class="keyword1">div</span> <span class="free">y</span> <span class="main">&lt;&lt;</span> <span class="main">1</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?q'</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="numeral">2</span> <span class="main">*</span> <span class="main">(</span><span class="skolem">n</span> <span class="keyword1">div</span> <span class="numeral">2</span> <span class="keyword1">div</span> <span class="skolem">m</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="keyword1">div</span> <span class="numeral">2</span> <span class="keyword1">div</span> <span class="skolem">m</span> <span class="main">&lt;</span> <span class="numeral">2</span> <span class="main">^</span> <span class="keyword1">LENGTH</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> n <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> of_nat_inverse unat_lt2p uno_simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> q<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?q</span> <span class="main">=</span> of_nat <span class="var">?q'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> n m
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> shiftr_word_eq drop_bit_eq_div shiftl_t2n word_arith_nat_div uno_simps take_bit_nat_eq_self<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> m <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span><span class="main">(</span><span class="operator">rule</span> notI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

  <span class="keyword1"><span class="command">from</span></span> n <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="numeral">2</span> <span class="main">*</span> <span class="main">(</span><span class="skolem">n</span> <span class="keyword1">div</span> <span class="numeral">2</span> <span class="keyword1">div</span> <span class="skolem">m</span><span class="main">)</span> <span class="main">&lt;</span> <span class="numeral">2</span> <span class="main">^</span> <span class="keyword1">LENGTH</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">metis</span> mult.commute div_mult2_eq minus_mod_eq_mult_div <span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> less_imp_diff_less of_nat_inverse unat_lt2p uno_simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="numeral">2</span> <span class="main">*</span> <span class="main">(</span><span class="skolem">n</span> <span class="keyword1">div</span> <span class="numeral">2</span> <span class="keyword1">div</span> <span class="skolem">m</span><span class="main">)</span> <span class="main">*</span> <span class="skolem">m</span> <span class="main">&lt;</span> <span class="numeral">2</span> <span class="main">^</span> <span class="keyword1">LENGTH</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> n <span class="keyword1"><span class="command">unfolding</span></span> div_mult2_eq<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> mult.commute<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> minus_mod_eq_div_mult <span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> diff_mult_distrib minus_mod_eq_mult_div <span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> div_mult2_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="numeral">2</span> <span class="main">*</span> <span class="main">(</span><span class="skolem">n</span> <span class="keyword1">div</span> <span class="numeral">2</span> <span class="keyword1">div</span> <span class="skolem">m</span><span class="main">)</span> <span class="main">*</span> <span class="skolem">m</span> <span class="main">≤</span> <span class="skolem">n</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">flip</span><span class="main"><span class="main">:</span></span> div_mult2_eq <span class="dynamic"><span class="dynamic">ac_simps</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span>
  <span class="keyword1"><span class="command">have</span></span> r<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">-</span> <span class="var">?q</span> <span class="main">*</span> <span class="free">y</span> <span class="main">=</span> of_nat <span class="main">(</span><span class="skolem">n</span> <span class="main">-</span> <span class="var">?q'</span> <span class="main">*</span> <span class="skolem">m</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">≤</span> <span class="free">x</span> <span class="main">-</span> <span class="var">?q</span> <span class="main">*</span> <span class="free">y</span> <span class="main">⟹</span> of_nat <span class="main">(</span><span class="skolem">n</span> <span class="main">-</span> <span class="var">?q'</span> <span class="main">*</span> <span class="skolem">m</span><span class="main">)</span> <span class="main">-</span> <span class="free">y</span> <span class="main">=</span> of_nat <span class="main">(</span><span class="skolem">n</span> <span class="main">-</span> <span class="var">?q'</span> <span class="main">*</span> <span class="skolem">m</span> <span class="main">-</span> <span class="skolem">m</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> n m <span class="keyword1"><span class="command">unfolding</span></span> q
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> of_nat_diff<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> of_nat_diff<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> word_le_nat_alt take_bit_nat_eq_self unat_sub_if' unat_word_ariths<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">‹<span class="numeral">2</span> <span class="main">≤</span> <span class="keyword1">LENGTH</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span>›</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> unat_word_ariths take_bit_nat_eq_self<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> n m div_half_nat <span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="skolem">m</span> <span class="main">≠</span> <span class="main">0</span>›</span></span><span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="skolem">n</span></span><span class="main">]</span> <span class="keyword1"><span class="command">unfolding</span></span> q
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> word_le_nat_alt word_div_def word_mod_def Let_def take_bit_nat_eq_self
      <span class="quasi_keyword">flip</span><span class="main"><span class="main">:</span></span> zdiv_int zmod_int
      <span class="quasi_keyword">split</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> if_split <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Code_Target_Word_Base-word_test_bit_set_bits"><span class="command">lemma</span></span> word_test_bit_set_bits<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">BITS</span> <span class="bound">n</span><span class="main">.</span> <span class="free">f</span> <span class="bound">n</span> <span class="main">::</span> <span class="tfree">'a</span> <span class="main">::</span> len word<span class="main">)</span> <span class="main">!!</span> <span class="free">n</span> <span class="main">⟷</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="keyword1">LENGTH</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">∧</span> <span class="free">f</span> <span class="free">n</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> test_bit_eq_bit bit_set_bits_word_iff<span class="main">)</span>

<span class="keyword1" id="Code_Target_Word_Base-word_of_int_conv_set_bits"><span class="command">lemma</span></span> word_of_int_conv_set_bits<span class="main">:</span> <span class="quoted"><span class="quoted">"word_of_int <span class="free">i</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">BITS</span> <span class="bound">n</span><span class="main">.</span> <span class="free">i</span> <span class="main">!!</span> <span class="bound">n</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> word_eqI<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> word_test_bit_set_bits<span class="main">)</span>

<span class="keyword1" id="Code_Target_Word_Base-word_and_mask_or_conv_and_mask"><span class="command">lemma</span></span> word_and_mask_or_conv_and_mask<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">!!</span> <span class="free">index</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">n</span> <span class="keyword1">AND</span> mask <span class="free">index</span><span class="main">)</span> <span class="keyword1">OR</span> <span class="main">(</span><span class="main">1</span> <span class="main">&lt;&lt;</span> <span class="free">index</span><span class="main">)</span> <span class="main">=</span> <span class="free">n</span> <span class="keyword1">AND</span> mask <span class="main">(</span><span class="free">index</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">n</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹<span class="tfree">'a</span><span class="main">::</span>len word›</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> word_eqI<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> word_ao_nth word_size nth_shiftl <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> shiftl_1<span class="main">)</span>

<span class="keyword1" id="Code_Target_Word_Base-uint_and_mask_or_full"><span class="command">lemma</span></span> uint_and_mask_or_full<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">n</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> len word"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">!!</span> <span class="main">(</span><span class="keyword1">LENGTH</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">mask1</span> <span class="main">=</span> mask <span class="main">(</span><span class="keyword1">LENGTH</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">mask2</span> <span class="main">=</span> <span class="main">1</span> <span class="main">&lt;&lt;</span> <span class="keyword1">LENGTH</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">-</span> <span class="main">1</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"uint <span class="main">(</span><span class="free">n</span> <span class="keyword1">AND</span> <span class="free">mask1</span><span class="main">)</span> <span class="keyword1">OR</span> <span class="free">mask2</span> <span class="main">=</span> uint <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">mask2</span> <span class="main">=</span> uint <span class="main">(</span><span class="main">1</span> <span class="main">&lt;&lt;</span> <span class="keyword1">LENGTH</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">-</span> <span class="main">1</span> <span class="main">::</span> <span class="tfree">'a</span> word<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> uint_shiftl word_size bintrunc_shiftl <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> shiftl_1<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"uint <span class="main">(</span><span class="free">n</span> <span class="keyword1">AND</span> <span class="free">mask1</span><span class="main">)</span> <span class="keyword1">OR</span> <span class="free">mask2</span> <span class="main">=</span> uint <span class="main">(</span><span class="free">n</span> <span class="keyword1">AND</span> <span class="free">mask1</span> <span class="keyword1">OR</span> <span class="main">(</span><span class="main">1</span> <span class="main">&lt;&lt;</span> <span class="keyword1">LENGTH</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">-</span> <span class="main">1</span> <span class="main">::</span> <span class="tfree">'a</span> word<span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> uint_or<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> uint <span class="main">(</span><span class="free">n</span> <span class="keyword1">AND</span> mask <span class="main">(</span><span class="keyword1">LENGTH</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">-</span> <span class="main">1</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> word_and_mask_or_conv_and_mask<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> uint <span class="free">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Division on <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> word"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is unsigned, but Scala and OCaml only have signed division and modulus.›</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> word_sdiv_def <span class="main">=</span> sdiv_word_def
<span class="keyword1"><span class="command">lemmas</span></span> word_smod_def <span class="main">=</span> smod_word_def

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="keyword1">sdiv</span> <span class="free">y</span> <span class="main">=</span>
   <span class="main">(</span><span class="keyword1">let</span> <span class="bound">x'</span> <span class="main">=</span> sint <span class="free">x</span><span class="main">;</span> <span class="bound">y'</span> <span class="main">=</span> sint <span class="free">y</span><span class="main">;</span>
        <span class="bound">negative</span> <span class="main">=</span> <span class="main">(</span><span class="bound">x'</span> <span class="main">&lt;</span> <span class="main">0</span><span class="main">)</span> <span class="main">≠</span> <span class="main">(</span><span class="bound">y'</span> <span class="main">&lt;</span> <span class="main">0</span><span class="main">)</span><span class="main">;</span>
        <span class="bound">result</span> <span class="main">=</span> abs <span class="bound">x'</span> <span class="keyword1">div</span> abs <span class="bound">y'</span>
    <span class="keyword1">in</span> word_of_int <span class="main">(</span><span class="keyword1">if</span> <span class="bound">negative</span> <span class="keyword1">then</span> <span class="main">-</span><span class="bound">result</span> <span class="keyword1">else</span> <span class="bound">result</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">x</span> <span class="free">y</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹<span class="tfree">'a</span><span class="main">::</span>len word›</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sdiv_word_def signed_divide_int_def sgn_if Let_def not_less not_le<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="keyword1">smod</span> <span class="free">y</span> <span class="main">=</span>
   <span class="main">(</span><span class="keyword1">let</span> <span class="bound">x'</span> <span class="main">=</span> sint <span class="free">x</span><span class="main">;</span> <span class="bound">y'</span> <span class="main">=</span> sint <span class="free">y</span><span class="main">;</span>
        <span class="bound">negative</span> <span class="main">=</span> <span class="main">(</span><span class="bound">x'</span> <span class="main">&lt;</span> <span class="main">0</span><span class="main">)</span><span class="main">;</span>
        <span class="bound">result</span> <span class="main">=</span> abs <span class="bound">x'</span> <span class="keyword1">mod</span> abs <span class="bound">y'</span>
    <span class="keyword1">in</span> word_of_int <span class="main">(</span><span class="keyword1">if</span> <span class="bound">negative</span> <span class="keyword1">then</span> <span class="main">-</span><span class="bound">result</span> <span class="keyword1">else</span> <span class="bound">result</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">x</span> <span class="free">y</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹<span class="tfree">'a</span><span class="main">::</span>len word›</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">‹<span class="skolem">k</span> <span class="keyword1">mod</span> <span class="skolem">l</span> <span class="main">=</span> <span class="skolem">k</span> <span class="main">-</span> <span class="skolem">k</span> <span class="keyword1">div</span> <span class="skolem">l</span> <span class="main">*</span> <span class="skolem">l</span>›</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">k</span> <span class="skolem">l</span> <span class="main">::</span> <span class="quoted">int</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> minus_div_mult_eq_mod<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> smod_word_def signed_modulo_int_def signed_divide_int_def * sgn_if Let_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  This algorithm implements unsigned division in terms of signed division.
  Taken from Hacker's Delight.
›</span></span>

<span class="keyword1" id="Code_Target_Word_Base-divmod_via_sdivmod"><span class="command">lemma</span></span> divmod_via_sdivmod<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span> <span class="free">y</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> len word"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="keyword1">div</span> <span class="free">y</span><span class="main">,</span> <span class="free">x</span> <span class="keyword1">mod</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="main">1</span> <span class="main">&lt;&lt;</span> <span class="main">(</span><span class="keyword1">LENGTH</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="main">≤</span> <span class="free">y</span> <span class="keyword1">then</span> <span class="keyword1">if</span> <span class="free">x</span> <span class="main">&lt;</span> <span class="free">y</span> <span class="keyword1">then</span> <span class="main">(</span><span class="main">0</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">(</span><span class="main">1</span><span class="main">,</span> <span class="free">x</span> <span class="main">-</span> <span class="free">y</span><span class="main">)</span>
   <span class="keyword1">else</span> <span class="keyword1">let</span> <span class="bound">q</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="free">x</span> <span class="main">&gt;&gt;</span> <span class="main">1</span><span class="main">)</span> <span class="keyword1">sdiv</span> <span class="free">y</span><span class="main">)</span> <span class="main">&lt;&lt;</span> <span class="main">1</span><span class="main">;</span>
            <span class="bound">r</span> <span class="main">=</span> <span class="free">x</span> <span class="main">-</span> <span class="bound">q</span> <span class="main">*</span> <span class="free">y</span>
        <span class="keyword1">in</span> <span class="keyword1">if</span> <span class="bound">r</span> <span class="main">≥</span> <span class="free">y</span> <span class="keyword1">then</span> <span class="main">(</span><span class="bound">q</span> <span class="main">+</span> <span class="main">1</span><span class="main">,</span> <span class="bound">r</span> <span class="main">-</span> <span class="free">y</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">(</span><span class="bound">q</span><span class="main">,</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">&lt;&lt;</span> <span class="main">(</span><span class="keyword1">LENGTH</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="main">≤</span> <span class="free">y</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword1"><span class="command">note</span></span> y <span class="main">=</span> this
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">&lt;</span> <span class="free">y</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="keyword1">mod</span> <span class="free">y</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> True y <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> word_div_lt_eq_0<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">n</span></span> <span class="keyword2"><span class="keyword">where</span></span> n<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">=</span> of_nat <span class="skolem">n</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">&lt;</span> <span class="numeral">2</span> <span class="main">^</span> <span class="keyword1">LENGTH</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> that <span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">‹unat <span class="free"><span class="free"><span class="free">y</span></span></span>›</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"unat <span class="free">x</span> <span class="main">&lt;</span> <span class="numeral">2</span> <span class="main">^</span> <span class="keyword1">LENGTH</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> unat_lt2p<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="numeral">2</span> <span class="main">*</span> <span class="numeral">2</span> <span class="main">^</span> <span class="main">(</span><span class="keyword1">LENGTH</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">metis</span> Suc_pred len_gt_0 power_Suc One_nat_def<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> <span class="numeral">2</span> <span class="main">*</span> <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> y n
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> push_bit_of_1 take_bit_eq_mod<span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> div<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="keyword1">div</span> of_nat <span class="skolem">n</span> <span class="main">=</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> False n
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> word_div_eq_1_iff take_bit_nat_eq_self<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="keyword1">mod</span> <span class="free">y</span> <span class="main">=</span> <span class="free">x</span> <span class="main">-</span> <span class="free">x</span> <span class="keyword1">div</span> <span class="free">y</span> <span class="main">*</span> <span class="free">y</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> minus_div_mult_eq_mod<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> div n <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="keyword1">mod</span> <span class="free">y</span> <span class="main">=</span> <span class="free">x</span> <span class="main">-</span> <span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> False y n <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword1"><span class="command">note</span></span> y <span class="main">=</span> this
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">n</span></span> <span class="keyword2"><span class="keyword">where</span></span> n<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> of_nat <span class="skolem">n</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">&lt;</span> <span class="numeral">2</span> <span class="main">^</span> <span class="keyword1">LENGTH</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> that <span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">‹unat <span class="free"><span class="free"><span class="free">x</span></span></span>›</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"int <span class="skolem">n</span> <span class="keyword1">div</span> <span class="numeral">2</span> <span class="main">+</span> <span class="numeral">2</span> <span class="main">^</span> <span class="main">(</span><span class="keyword1">LENGTH</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">-</span> Suc <span class="main">0</span><span class="main">)</span> <span class="main">&lt;</span> <span class="numeral">2</span> <span class="main">^</span> <span class="keyword1">LENGTH</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">‹<span class="keyword1">LENGTH</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span>›</span></span><span class="main">)</span>
      <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> less_imp_of_nat_less <span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tvar">?'a</span> <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted">int</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> y n <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"sint <span class="main">(</span><span class="free">x</span> <span class="main">&gt;&gt;</span> <span class="main">1</span><span class="main">)</span> <span class="main">=</span> uint <span class="main">(</span><span class="free">x</span> <span class="main">&gt;&gt;</span> <span class="main">1</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sint_uint sbintrunc_mod2p shiftr_div_2n take_bit_nat_eq_self<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"uint <span class="free">y</span> <span class="main">+</span> <span class="numeral">2</span> <span class="main">^</span> <span class="main">(</span><span class="keyword1">LENGTH</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">-</span> Suc <span class="main">0</span><span class="main">)</span> <span class="main">&lt;</span> <span class="numeral">2</span> <span class="main">^</span> <span class="keyword1">LENGTH</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> y <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="keyword1">LENGTH</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span>"</span></span><span class="main">)</span>
      <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_le word_2p_lem word_size<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"sint <span class="free">y</span> <span class="main">=</span> uint <span class="free">y</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sint_uint sbintrunc_mod2p<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> y
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> div_half_word <span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sdiv_word_def signed_divide_int_def <span class="quasi_keyword">flip</span><span class="main"><span class="main">:</span></span> uint_div<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹More implementations tailored towards target-language implementations›</span></span>

<span class="keyword1"><span class="command">context</span></span>
<span class="keyword2"><span class="keyword">includes</span></span> integer.lifting
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> word_of_integer <span class="main">::</span> <span class="quoted"><span class="quoted">"integer <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">::</span> len word"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">word_of_int</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1" id="Code_Target_Word_Base-word_of_integer_code"><span class="command">lemma</span></span> word_of_integer_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"word_of_integer <span class="free">n</span> <span class="main">=</span> word_of_int <span class="main">(</span>int_of_integer <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> word_of_integer.rep_eq<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Code_Target_Word_Base-word_of_int_code"><span class="command">lemma</span></span> word_of_int_code<span class="main">:</span>
  <span class="quoted"><span class="quoted">"uint <span class="main">(</span>word_of_int <span class="free">x</span> <span class="main">::</span> <span class="tfree">'a</span> word<span class="main">)</span> <span class="main">=</span> <span class="free">x</span> <span class="keyword1">AND</span> mask <span class="main">(</span><span class="keyword1">LENGTH</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">::</span> len<span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> take_bit_eq_mask<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">set_bits_aux</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹<span class="tfree">'a</span> word <span class="main">⇒</span> nat <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">::</span> len word›</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">‹<span class="free">set_bits_aux</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> push_bit <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="keyword1">OR</span> take_bit <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">(</span>set_bits <span class="free">f</span><span class="main">)</span>›</span></span>

<span class="keyword1" id="Code_Target_Word_Base-set_bits_aux_conv"><span class="command">lemma</span></span> set_bits_aux_conv<span class="main">:</span>
  <span class="quoted"><span class="quoted">‹set_bits_aux <span class="free">w</span> <span class="free">n</span> <span class="main">=</span> <span class="main">(</span><span class="free">w</span> <span class="main">&lt;&lt;</span> <span class="free">n</span><span class="main">)</span> <span class="keyword1">OR</span> <span class="main">(</span>set_bits <span class="free">f</span> <span class="keyword1">AND</span> mask <span class="free">n</span><span class="main">)</span>›</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">w</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹<span class="tfree">'a</span><span class="main">::</span>len word›</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> bit_word_eqI<span class="main">)</span>
    <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_bits_aux_def shiftl_word_eq bit_and_iff bit_or_iff bit_push_bit_iff bit_take_bit_iff bit_mask_iff bit_set_bits_word_iff<span class="main">)</span>

<span class="keyword1"><span class="command">corollary</span></span> set_bits_conv_set_bits_aux<span class="main">:</span>
  <span class="quoted"><span class="quoted">‹set_bits <span class="free">f</span> <span class="main">=</span> <span class="main">(</span>set_bits_aux <span class="main">0</span> <span class="main">(</span><span class="keyword1">LENGTH</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span><span class="main">)</span> <span class="main">::</span> <span class="tfree">'a</span> <span class="main">::</span> len word<span class="main">)</span>›</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_bits_aux_conv<span class="main">)</span>

<span class="keyword1" id="Code_Target_Word_Base-set_bits_aux_0"><span class="command">lemma</span></span> set_bits_aux_0 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">‹set_bits_aux <span class="free">w</span> <span class="main">0</span> <span class="main">=</span> <span class="free">w</span>›</span></span>
  <span class="keyword1"><span class="command">by</span></span>  <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_bits_aux_conv<span class="main">)</span>

<span class="keyword1" id="Code_Target_Word_Base-set_bits_aux_Suc"><span class="command">lemma</span></span> set_bits_aux_Suc <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">‹set_bits_aux <span class="free">w</span> <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="main">=</span> set_bits_aux <span class="main">(</span><span class="main">(</span><span class="free">w</span> <span class="main">&lt;&lt;</span> <span class="main">1</span><span class="main">)</span> <span class="keyword1">OR</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">f</span> <span class="free">n</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span> <span class="free">n</span>›</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_bits_aux_def shiftl_word_eq bit_eq_iff bit_or_iff bit_push_bit_iff bit_take_bit_iff bit_set_bits_word_iff<span class="main">)</span>
    <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bit_exp_iff not_less bit_1_iff less_Suc_eq_le<span class="main">)</span>

<span class="keyword1" id="Code_Target_Word_Base-set_bits_aux_simps"><span class="command">lemma</span></span> set_bits_aux_simps <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">‹set_bits_aux <span class="free">w</span> <span class="main">0</span> <span class="main">=</span> <span class="free">w</span>›</span></span>
  <span class="quoted"><span class="quoted">‹set_bits_aux <span class="free">w</span> <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="main">=</span> set_bits_aux <span class="main">(</span><span class="main">(</span><span class="free">w</span> <span class="main">&lt;&lt;</span> <span class="main">1</span><span class="main">)</span> <span class="keyword1">OR</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">f</span> <span class="free">n</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span> <span class="free">n</span>›</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Code_Target_Word_Base-word_of_int_via_signed"><span class="command">lemma</span></span> word_of_int_via_signed<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">mask</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> mask_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">mask</span> <span class="main">=</span> Bit_Operations.mask <span class="main">(</span><span class="keyword1">LENGTH</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> shift_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">shift</span> <span class="main">=</span> <span class="main">1</span> <span class="main">&lt;&lt;</span> <span class="keyword1">LENGTH</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> index_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">index</span> <span class="main">=</span> <span class="keyword1">LENGTH</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">-</span> <span class="main">1</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> overflow_def<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="free">overflow</span> <span class="main">=</span> <span class="main">1</span> <span class="main">&lt;&lt;</span> <span class="main">(</span><span class="keyword1">LENGTH</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> least_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">least</span> <span class="main">=</span> <span class="main">-</span> <span class="free">overflow</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>word_of_int <span class="free">i</span> <span class="main">::</span> <span class="tfree">'a</span> <span class="main">::</span> len word<span class="main">)</span> <span class="main">=</span>
   <span class="main">(</span><span class="keyword1">let</span> <span class="bound">i'</span> <span class="main">=</span> <span class="free">i</span> <span class="keyword1">AND</span> <span class="free">mask</span>
    <span class="keyword1">in</span> <span class="keyword1">if</span> <span class="bound">i'</span> <span class="main">!!</span> <span class="free">index</span> <span class="keyword1">then</span>
         <span class="keyword1">if</span> <span class="bound">i'</span> <span class="main">-</span> <span class="free">shift</span> <span class="main">&lt;</span> <span class="free">least</span> <span class="main">∨</span> <span class="free">overflow</span> <span class="main">≤</span> <span class="bound">i'</span> <span class="main">-</span> <span class="free">shift</span> <span class="keyword1">then</span> <span class="free">arbitrary1</span> <span class="bound">i'</span> <span class="keyword1">else</span> word_of_int <span class="main">(</span><span class="bound">i'</span> <span class="main">-</span> <span class="free">shift</span><span class="main">)</span>
       <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="bound">i'</span> <span class="main">&lt;</span> <span class="free">least</span> <span class="main">∨</span> <span class="free">overflow</span> <span class="main">≤</span> <span class="bound">i'</span> <span class="keyword1">then</span> <span class="free">arbitrary2</span> <span class="bound">i'</span> <span class="keyword1">else</span> word_of_int <span class="bound">i'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">i'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i'</span> <span class="main">=</span> <span class="free">i</span> <span class="keyword1">AND</span> <span class="free">mask</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">shift</span> <span class="main">=</span> <span class="free">mask</span> <span class="main">+</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bin_mask_p1_conv_shift<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i'</span> <span class="main">&lt;</span> <span class="free">shift</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mask_def i'_def int_and_le<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">i'</span> <span class="main">!!</span> <span class="free">index</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> unf<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i'</span> <span class="main">=</span> <span class="free">overflow</span> <span class="keyword1">OR</span> <span class="skolem">i'</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms i'_def shiftl_eq_push_bit push_bit_of_1 <span class="quasi_keyword">flip</span><span class="main"><span class="main">:</span></span> take_bit_eq_mask<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> bit_eqI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bit_take_bit_iff bit_or_iff bit_exp_iff<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">overflow</span> <span class="main">≤</span> <span class="skolem">i'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> unf<span class="main">)</span><span class="main">(</span><span class="operator">rule</span> le_int_or<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bin_sign_and assms i'_def<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i'</span> <span class="main">-</span> <span class="free">shift</span> <span class="main">&lt;</span> <span class="free">least</span> <span class="main">⟷</span> False"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> assms
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="keyword1">LENGTH</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span>"</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_less<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">overflow</span> <span class="main">≤</span> <span class="skolem">i'</span> <span class="main">-</span> <span class="free">shift</span> <span class="main">⟷</span> False"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">i'</span> <span class="main">&lt;</span> <span class="free">shift</span>›</span></span> <span class="keyword1"><span class="command">unfolding</span></span> assms
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="keyword1">LENGTH</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span>"</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_le <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> less_le_trans<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"word_of_int <span class="main">(</span><span class="skolem">i'</span> <span class="main">-</span> <span class="free">shift</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>word_of_int <span class="free">i</span> <span class="main">::</span> <span class="tfree">'a</span> word<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">i'</span> <span class="main">&lt;</span> <span class="free">shift</span>›</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> i'_def shift_def mask_def shiftl_eq_push_bit push_bit_of_1 word_of_int_eq_iff <span class="quasi_keyword">flip</span><span class="main"><span class="main">:</span></span> take_bit_eq_mask<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> True <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def i'_def<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i'</span> <span class="main">=</span> <span class="free">i</span> <span class="keyword1">AND</span> Bit_Operations.mask <span class="main">(</span><span class="keyword1">LENGTH</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> assms i'_def
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> i'_def bin_nth_ops <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> bin_eqI<span class="main">)</span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="keyword1">LENGTH</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_Suc_eq<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> Bit_Operations.mask <span class="main">(</span><span class="keyword1">LENGTH</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> int_and_le<span class="main">)</span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">&lt;</span> <span class="free">overflow</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> overflow_def
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bin_mask_p1_conv_shift<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">least</span> <span class="main">≤</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> least_def overflow_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">≤</span> <span class="skolem">i'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> i'_def mask_def<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">least</span> <span class="main">≤</span> <span class="skolem">i'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="free">least</span> <span class="main">≤</span> <span class="main">0</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"word_of_int <span class="skolem">i'</span> <span class="main">=</span> <span class="main">(</span>word_of_int <span class="free">i</span> <span class="main">::</span> <span class="tfree">'a</span> word<span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> word_eqI<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> i'_def bin_nth_ops mask_def<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> False <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def i'_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>



<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Quickcheck conversion functions›</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">includes</span></span> state_combinator_syntax
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">qc_random_cnv</span> <span class="main">::</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>natural <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">::</span>term_of<span class="main">)</span> <span class="main">⇒</span> natural <span class="main">⇒</span> Random.seed
    <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="main">(</span>unit <span class="main">⇒</span> Code_Evaluation.term<span class="main">)</span><span class="main">)</span> <span class="main">×</span> Random.seed"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">qc_random_cnv</span> <span class="free"><span class="bound"><span class="entity">a_of_natural</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">=</span> Random.range <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">∘→</span> <span class="main">(</span><span class="main">λ</span><span class="bound">k</span><span class="main">.</span> Pair <span class="main">(</span>
       <span class="keyword1">let</span> <span class="bound">n</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">a_of_natural</span></span></span> <span class="bound">k</span>
       <span class="keyword1">in</span> <span class="main">(</span><span class="bound">n</span><span class="main">,</span> <span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Code_Evaluation.term_of <span class="bound">n</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">qc_exhaustive_cnv</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>natural <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span>bool <span class="main">×</span> term list<span class="main">)</span> option<span class="main">)</span>
  <span class="main">⇒</span> natural <span class="main">⇒</span> <span class="main">(</span>bool <span class="main">×</span> term list<span class="main">)</span> option"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">qc_exhaustive_cnv</span> <span class="free"><span class="bound"><span class="entity">a_of_natural</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">d</span></span></span> <span class="main">=</span>
   Quickcheck_Exhaustive.exhaustive <span class="main">(</span><span class="main">%</span><span class="bound">x</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a_of_natural</span></span></span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">d</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">qc_full_exhaustive_cnv</span> <span class="main">::</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>natural <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>term_of<span class="main">)</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="main">(</span>unit <span class="main">⇒</span> term<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span>bool <span class="main">×</span> term list<span class="main">)</span> option<span class="main">)</span>
  <span class="main">⇒</span> natural <span class="main">⇒</span> <span class="main">(</span>bool <span class="main">×</span> term list<span class="main">)</span> option"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">qc_full_exhaustive_cnv</span> <span class="free"><span class="bound"><span class="entity">a_of_natural</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">d</span></span></span> <span class="main">=</span> Quickcheck_Exhaustive.full_exhaustive
  <span class="main">(</span><span class="main">%</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">xt</span><span class="main">)</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a_of_natural</span></span></span> <span class="bound">x</span><span class="main">,</span> <span class="main">%</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Code_Evaluation.term_of <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a_of_natural</span></span></span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">d</span></span></span>"</span></span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">quickcheck_narrowing_ghc_options</span> <span class="main"><span class="main">=</span></span> <span class="quoted">"-XTypeSynonymInstances"</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">qc_narrowing_drawn_from</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> integer <span class="main">⇒</span> <span class="main">_</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">qc_narrowing_drawn_from</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span>
   foldr Quickcheck_Narrowing.sum <span class="main">(</span>map Quickcheck_Narrowing.cons <span class="main">(</span>butlast <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Quickcheck_Narrowing.cons <span class="main">(</span>last <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> quickcheck_narrowing_samples <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">a_of_integer</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"integer <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'a</span> <span class="main">::</span> <span class="main">{</span>partial_term_of<span class="main">,</span> term_of<span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">zero</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">tr</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"typerep"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">function</span></span> <span class="entity">narrowing_samples</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"integer <span class="main">⇒</span> <span class="tfree">'a</span> list"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">narrowing_samples</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">=</span>
   <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">&gt;</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="keyword1">let</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">a'</span><span class="main">)</span> <span class="main">=</span> <span class="free">a_of_integer</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="keyword1">in</span> <span class="free">narrowing_samples</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="main">@</span> <span class="main">[</span><span class="bound">a</span><span class="main">,</span> <span class="bound">a'</span><span class="main">]</span> <span class="keyword1">else</span> <span class="main">[</span><span class="free">zero</span><span class="main">]</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">pat_completeness</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">termination</span></span> <span class="keyword1"><span class="command">including</span></span> integer.lifting
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">relation</span> <span class="quoted"><span class="quoted">"measure nat_of_integer"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span> <span class="main">::</span> <span class="quoted">integer</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">&lt;</span> <span class="skolem">i</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">i</span> <span class="main">-</span> <span class="main">1</span><span class="main">,</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">∈</span> measure nat_of_integer"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span><span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">partial_term_of_sample</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"integer <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">partial_term_of_sample</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">&lt;</span> <span class="main">0</span> <span class="keyword1">then</span> undefined
   <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="free">zero</span>
   <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="keyword1">mod</span> <span class="numeral">2</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> snd <span class="main">(</span><span class="free">a_of_integer</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="keyword1">div</span> <span class="numeral">2</span><span class="main">)</span><span class="main">)</span>
   <span class="keyword1">else</span> fst <span class="main">(</span><span class="free">a_of_integer</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="keyword1">div</span> <span class="numeral">2</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Code_Target_Word_Base-partial_term_of_code"><span class="command">lemma</span></span> partial_term_of_code<span class="main">:</span>
  <span class="quoted"><span class="quoted">"partial_term_of <span class="main">(</span><span class="free">ty</span> <span class="main">::</span> <span class="tfree">'a</span> itself<span class="main">)</span> <span class="main">(</span>Quickcheck_Narrowing.Narrowing_variable <span class="free">p</span> <span class="free">t</span><span class="main">)</span> <span class="main">≡</span>
    Code_Evaluation.Free <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''_''</span><span class="main">)</span> <span class="free">tr</span>"</span></span>
  <span class="quoted"><span class="quoted">"partial_term_of <span class="main">(</span><span class="free">ty</span> <span class="main">::</span> <span class="tfree">'a</span> itself<span class="main">)</span> <span class="main">(</span>Quickcheck_Narrowing.Narrowing_constructor <span class="free">i</span> <span class="main">[]</span><span class="main">)</span> <span class="main">≡</span>
   Code_Evaluation.term_of <span class="main">(</span>partial_term_of_sample <span class="free">i</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> partial_term_of_anything<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span>
  quickcheck_narrowing_samples.narrowing_samples.simps
  quickcheck_narrowing_samples.partial_term_of_sample_def


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The separate code target <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>SML_word›</span></span></span></span> collects setups for the
  code generator that PolyML does not provide.
›</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">Code_Target.add_derived_target</span> <span class="main">(</span><span class="inner_quoted">"SML_word"</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="entity">Code_ML.target_SML</span><span class="main">,</span> I<span class="main">)</span><span class="main">]</span><span class="main">)</span>›</span>

<span class="keyword1"><span class="command">code_identifier</span></span> <span class="keyword2"><span class="keyword">code_module</span></span> Code_Target_Word_Base <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> Word <span class="keyword2"><span class="keyword">and</span></span> <span class="main">(</span>Haskell<span class="main">)</span> Word <span class="keyword2"><span class="keyword">and</span></span> <span class="main">(</span>OCaml<span class="main">)</span> Word <span class="keyword2"><span class="keyword">and</span></span> <span class="main">(</span>Scala<span class="main">)</span> Word

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Uint64">
<div class="head">
<h1>Theory Uint64</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Uint64.thy
    Author:     Andreas Lochbihler, ETH Zurich
*)</span>

<span class="keyword1"><span class="command">chapter</span></span> <span class="quoted"><span class="plain_text">‹Unsigned words of 64 bits›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Uint64 <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Code_Target_Word_Base.html">Code_Target_Word_Base</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  PolyML (in version 5.7) provides a Word64 structure only when run in 64-bit mode.
  Therefore, we by default provide an implementation of 64-bit words using \verb$IntInf.int$ and
  masking. The code target \texttt{SML\_word} replaces this implementation and maps the operations
  directly to the \verb$Word64$ structure provided by the Standard ML implementations.

  The \verb$Eval$ target used by <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> value<span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">method</span></span> eval<span class="antiquote"><span class="antiquote">}</span></span></span></span> dynamically tests at
  runtime for the version of PolyML and uses PolyML's Word64 structure if it detects a 64-bit 
  version which does not suffer from a division bug found in PolyML 5.6.
›</span></span>

<span class="keyword1"><span class="command">declare</span></span> prod.Quotient<span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Type definition and primitive operations›</span></span>

<span class="keyword1"><span class="command">typedef</span></span> uint64 <span class="main">=</span> <span class="quoted"><span class="quoted">"UNIV <span class="main">::</span> <span class="numeral">64</span> word set"</span></span> <span class="keyword1"><span class="command">..</span></span> 

<span class="keyword1"><span class="command">setup_lifting</span></span> type_definition_uint64

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Use an abstract type for code generation to disable pattern matching on <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Abs_uint64</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>
<span class="keyword1"><span class="command">declare</span></span> Rep_uint64_inverse<span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">abstype</span><span class="main">]</span>

<span class="keyword1"><span class="command">declare</span></span> Quotient_uint64<span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span>

<span class="keyword1"><span class="command">instantiation</span></span> uint64 <span class="main">::</span> <span class="quoted">comm_ring_1</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">zero_uint64</span> <span class="main">::</span> <span class="quoted">uint64</span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">::</span> <span class="numeral">64</span> word"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">one_uint64</span> <span class="main">::</span> <span class="quoted">uint64</span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">plus_uint64</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint64 <span class="main">⇒</span> uint64 <span class="main">⇒</span> uint64"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(+)</span> <span class="main">::</span> <span class="numeral">64</span> word <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">minus_uint64</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint64 <span class="main">⇒</span> uint64 <span class="main">⇒</span> uint64"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(-)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">uminus_uint64</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint64 <span class="main">⇒</span> uint64"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">uminus</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">times_uint64</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint64 <span class="main">⇒</span> uint64 <span class="main">⇒</span> uint64"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(*)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">transfer</span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">algebra_simps</span></span><span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint64 <span class="main">::</span> <span class="quoted">semiring_modulo</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">divide_uint64</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint64 <span class="main">⇒</span> uint64 <span class="main">⇒</span> uint64"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">(div)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">modulo_uint64</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint64 <span class="main">⇒</span> uint64 <span class="main">⇒</span> uint64"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">(mod)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">transfer</span><span class="main">)</span> <span class="main">(</span><span class="operator">fact</span> word_mod_div_equality<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint64 <span class="main">::</span> <span class="quoted">linorder</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">less_uint64</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint64 <span class="main">⇒</span> uint64 <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(&lt;)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">less_eq_uint64</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint64 <span class="main">⇒</span> uint64 <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(≤)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">transfer</span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_le_not_le linear<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> less_uint64.rep_eq less_eq_uint64.rep_eq

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax
  <span class="keyword2"><span class="keyword">notes</span></span>
    transfer_rule_of_bool <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span>
    transfer_rule_numeral <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> cr_uint64<span class="main">)</span> of_bool of_bool"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Uint64-transfer_rule_numeral_uint"><span class="command">lemma</span></span> transfer_rule_numeral_uint <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> cr_uint64<span class="main">)</span> numeral numeral"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">‹<span class="main">(</span>cr_uint64 <span class="main">===&gt;</span> <span class="main">(⟷)</span><span class="main">)</span> even <span class="main">(</span><span class="keyword1">(dvd)</span> <span class="numeral">2</span> <span class="main">::</span> uint64 <span class="main">⇒</span> bool<span class="main">)</span>›</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> dvd_def<span class="main">)</span> <span class="operator">transfer_prover</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint64 <span class="main">::</span> <span class="quoted">semiring_bits</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">bit_uint64</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹uint64 <span class="main">⇒</span> nat <span class="main">⇒</span> bool›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">bit</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">instance</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">transfer</span><span class="main">)</span>
    <span class="main">(</span><span class="operator">fact</span> bit_iff_odd even_iff_mod_2_eq_zero odd_iff_mod_2_eq_one odd_one bits_induct
       bits_div_0 bits_div_by_1 bits_mod_div_trivial even_succ_div_2
       even_mask_div_iff exp_div_exp_eq div_exp_eq mod_exp_eq mult_exp_mod_exp_eq
       div_exp_mod_exp_eq even_mult_exp_div_exp_iff<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint64 <span class="main">::</span> <span class="quoted">semiring_bit_shifts</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">push_bit_uint64</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹nat <span class="main">⇒</span> uint64 <span class="main">⇒</span> uint64›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">push_bit</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">drop_bit_uint64</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹nat <span class="main">⇒</span> uint64 <span class="main">⇒</span> uint64›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">drop_bit</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">take_bit_uint64</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹nat <span class="main">⇒</span> uint64 <span class="main">⇒</span> uint64›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">take_bit</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">transfer</span><span class="main">)</span>
  <span class="main">(</span><span class="operator">fact</span> push_bit_eq_mult drop_bit_eq_div take_bit_eq_mod<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint64 <span class="main">::</span> <span class="quoted">ring_bit_operations</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">not_uint64</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹uint64 <span class="main">⇒</span> uint64›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="keyword1">NOT</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">and_uint64</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹uint64 <span class="main">⇒</span> uint64 <span class="main">⇒</span> uint64›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">‹<span class="keyword1">(AND)</span>›</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">or_uint64</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹uint64 <span class="main">⇒</span> uint64 <span class="main">⇒</span> uint64›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">‹<span class="keyword1">(OR)</span>›</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">xor_uint64</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹uint64 <span class="main">⇒</span> uint64 <span class="main">⇒</span> uint64›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">‹<span class="keyword1">(XOR)</span>›</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">mask_uint64</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹nat <span class="main">⇒</span> uint64›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">mask</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">transfer</span><span class="main">)</span>
  <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bit_and_iff bit_or_iff bit_xor_iff bit_not_iff minus_eq_not_minus_1 mask_eq_decr_exp<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">‹take_bit <span class="free">n</span> <span class="free">a</span> <span class="main">=</span> <span class="free">a</span> <span class="keyword1">AND</span> mask <span class="free">n</span>›</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">a</span> <span class="main">::</span> <span class="quoted">uint64</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fact</span> take_bit_eq_mask<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">‹mask <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="main">=</span> push_bit <span class="free">n</span> <span class="main">(</span><span class="main">1</span> <span class="main">::</span> uint64<span class="main">)</span> <span class="keyword1">OR</span> mask <span class="free">n</span>›</span></span>
  <span class="quoted"><span class="quoted">‹mask <span class="main">0</span> <span class="main">=</span> <span class="main">(</span><span class="main">0</span> <span class="main">::</span> uint64<span class="main">)</span>›</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mask_Suc_exp push_bit_of_1<span class="main">)</span>

<span class="keyword1"><span class="command">instance</span></span> uint64 <span class="main">::</span> <span class="quoted">semiring_bit_syntax</span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Uint64-test_bit_uint64_transfer"><span class="command">lemma</span></span> test_bit_uint64_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">‹<span class="main">(</span>cr_uint64 <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> bit <span class="main">(!!)</span>›</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> test_bit_eq_bit <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Uint64-shiftl_uint64_transfer"><span class="command">lemma</span></span> shiftl_uint64_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">‹<span class="main">(</span>cr_uint64 <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> cr_uint64<span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">k</span> <span class="bound">n</span><span class="main">.</span> push_bit <span class="bound">n</span> <span class="bound">k</span><span class="main">)</span> <span class="main">(&lt;&lt;)</span>›</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> shiftl_eq_push_bit <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Uint64-shiftr_uint64_transfer"><span class="command">lemma</span></span> shiftr_uint64_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">‹<span class="main">(</span>cr_uint64 <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> cr_uint64<span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">k</span> <span class="bound">n</span><span class="main">.</span> drop_bit <span class="bound">n</span> <span class="bound">k</span><span class="main">)</span> <span class="main">(&gt;&gt;)</span>›</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> shiftr_eq_drop_bit <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint64 <span class="main">::</span> <span class="quoted">lsb</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">lsb_uint64</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹uint64 <span class="main">⇒</span> bool›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">lsb</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">transfer</span><span class="main">)</span>
  <span class="main">(</span><span class="operator">fact</span> lsb_odd<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint64 <span class="main">::</span> <span class="quoted">msb</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">msb_uint64</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹uint64 <span class="main">⇒</span> bool›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">msb</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint64 <span class="main">::</span> <span class="quoted">set_bit</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">set_bit_uint64</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹uint64 <span class="main">⇒</span> nat <span class="main">⇒</span> bool <span class="main">⇒</span> uint64›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">set_bit</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">standard</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">bit_simps</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint64 <span class="main">::</span> <span class="quoted">bit_comprehension</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">set_bits_uint64</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nat <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> uint64"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"set_bits"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">transfer</span><span class="main">)</span> <span class="main">(</span><span class="operator">fact</span> set_bits_bit_eq<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> bit_uint64.rep_eq lsb_uint64.rep_eq msb_uint64.rep_eq

<span class="keyword1"><span class="command">instantiation</span></span> uint64 <span class="main">::</span> <span class="quoted">equal</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">equal_uint64</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint64 <span class="main">⇒</span> uint64 <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"equal_class.equal"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> equal_eq<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> equal_uint64.rep_eq

<span class="keyword1"><span class="command">instantiation</span></span> uint64 <span class="main">::</span> <span class="quoted">size</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">size_uint64</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint64 <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"size"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> size_uint64.rep_eq

<span class="keyword1"><span class="command">lift_definition</span></span> sshiftr_uint64 <span class="main">::</span> <span class="quoted"><span class="quoted">"uint64 <span class="main">⇒</span> nat <span class="main">⇒</span> uint64"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">&gt;&gt;&gt;</span>"</span> 55<span class="main">)</span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">‹<span class="main">λ</span><span class="bound">w</span> <span class="bound">n</span><span class="main">.</span> signed_drop_bit <span class="bound">n</span> <span class="bound">w</span>›</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> uint64_of_int <span class="main">::</span> <span class="quoted"><span class="quoted">"int <span class="main">⇒</span> uint64"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"word_of_int"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint64_of_nat</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> uint64"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">uint64_of_nat</span> <span class="main">=</span> uint64_of_int <span class="main">∘</span> int"</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> int_of_uint64 <span class="main">::</span> <span class="quoted"><span class="quoted">"uint64 <span class="main">⇒</span> int"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"uint"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> nat_of_uint64 <span class="main">::</span> <span class="quoted"><span class="quoted">"uint64 <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"unat"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">integer_of_uint64</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint64 <span class="main">⇒</span> integer"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">integer_of_uint64</span> <span class="main">=</span> integer_of_int <span class="keyword1">o</span> int_of_uint64"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Use pretty numerals from integer for pretty printing›</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> integer.lifting <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> Uint64 <span class="main">::</span> <span class="quoted"><span class="quoted">"integer <span class="main">⇒</span> uint64"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"word_of_int"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1" id="Uint64-Rep_uint64_numeral"><span class="command">lemma</span></span> Rep_uint64_numeral <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Rep_uint64 <span class="main">(</span>numeral <span class="free">n</span><span class="main">)</span> <span class="main">=</span> numeral <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> one_uint64_def Abs_uint64_inverse numeral.simps plus_uint64_def<span class="main">)</span>

<span class="keyword1" id="Uint64-numeral_uint64_transfer"><span class="command">lemma</span></span> numeral_uint64_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>rel_fun <span class="main">(=)</span> cr_uint64<span class="main">)</span> numeral numeral"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cr_uint64_def<span class="main">)</span>

<span class="keyword1" id="Uint64-numeral_uint64"><span class="command">lemma</span></span> numeral_uint64 <span class="main">[</span><span class="operator">code_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"numeral <span class="free">n</span> <span class="main">=</span> Uint64 <span class="main">(</span>numeral <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Uint64-Rep_uint64_neg_numeral"><span class="command">lemma</span></span> Rep_uint64_neg_numeral <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Rep_uint64 <span class="main">(</span><span class="main">-</span> numeral <span class="free">n</span><span class="main">)</span> <span class="main">=</span> <span class="main">-</span> numeral <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> uminus_uint64_def<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_uint64_inverse<span class="main">)</span>

<span class="keyword1" id="Uint64-neg_numeral_uint64"><span class="command">lemma</span></span> neg_numeral_uint64 <span class="main">[</span><span class="operator">code_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">-</span> numeral <span class="free">n</span> <span class="main">=</span> Uint64 <span class="main">(</span><span class="main">-</span> numeral <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cr_uint64_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Uint64-Abs_uint64_numeral"><span class="command">lemma</span></span> Abs_uint64_numeral <span class="main">[</span><span class="operator">code_post</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Abs_uint64 <span class="main">(</span>numeral <span class="free">n</span><span class="main">)</span> <span class="main">=</span> numeral <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> one_uint64_def numeral.simps plus_uint64_def Abs_uint64_inverse<span class="main">)</span>

<span class="keyword1" id="Uint64-Abs_uint64_0"><span class="command">lemma</span></span> Abs_uint64_0 <span class="main">[</span><span class="operator">code_post</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Abs_uint64 <span class="main">0</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_uint64_def<span class="main">)</span>

<span class="keyword1" id="Uint64-Abs_uint64_1"><span class="command">lemma</span></span> Abs_uint64_1 <span class="main">[</span><span class="operator">code_post</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Abs_uint64 <span class="main">1</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> one_uint64_def<span class="main">)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Code setup›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹ For SML, we generate an implementation of unsigned 64-bit words using \verb$IntInf.int$.
  If <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">ML</span></span> "LargeWord.wordSize &gt; <span class="inner_numeral"><span class="inner_numeral">63</span></span>"<span class="antiquote"><span class="antiquote">}</span></span></span></span> of the Isabelle/ML runtime environment holds, then we assume
  that there is also a <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Word64›</span></span></span></span> structure available and accordingly replace the implementation
  for the target \verb$Eval$.
›</span></span>
<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">code_module</span></span> <span class="quoted">"Uint64"</span> <span class="main">⇀</span> <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">‹(* Test that words can handle numbers between 0 and 63 *)
val _ = if 6 &lt;= Word.wordSize then () else raise (Fail ("wordSize less than 6"));

structure Uint64 : sig
  eqtype uint64;
  val zero : uint64;
  val one : uint64;
  val fromInt : IntInf.int -&gt; uint64;
  val toInt : uint64 -&gt; IntInf.int;
  val toLarge : uint64 -&gt; LargeWord.word;
  val fromLarge : LargeWord.word -&gt; uint64
  val plus : uint64 -&gt; uint64 -&gt; uint64;
  val minus : uint64 -&gt; uint64 -&gt; uint64;
  val times : uint64 -&gt; uint64 -&gt; uint64;
  val divide : uint64 -&gt; uint64 -&gt; uint64;
  val modulus : uint64 -&gt; uint64 -&gt; uint64;
  val negate : uint64 -&gt; uint64;
  val less_eq : uint64 -&gt; uint64 -&gt; bool;
  val less : uint64 -&gt; uint64 -&gt; bool;
  val notb : uint64 -&gt; uint64;
  val andb : uint64 -&gt; uint64 -&gt; uint64;
  val orb : uint64 -&gt; uint64 -&gt; uint64;
  val xorb : uint64 -&gt; uint64 -&gt; uint64;
  val shiftl : uint64 -&gt; IntInf.int -&gt; uint64;
  val shiftr : uint64 -&gt; IntInf.int -&gt; uint64;
  val shiftr_signed : uint64 -&gt; IntInf.int -&gt; uint64;
  val set_bit : uint64 -&gt; IntInf.int -&gt; bool -&gt; uint64;
  val test_bit : uint64 -&gt; IntInf.int -&gt; bool;
end = struct

type uint64 = IntInf.int;

val mask = 0xFFFFFFFFFFFFFFFF : IntInf.int;

val zero = 0 : IntInf.int;

val one = 1 : IntInf.int;

fun fromInt x = IntInf.andb(x, mask);

fun toInt x = x

fun toLarge x = LargeWord.fromLargeInt (IntInf.toLarge x);

fun fromLarge x = IntInf.fromLarge (LargeWord.toLargeInt x);

fun plus x y = IntInf.andb(IntInf.+(x, y), mask);

fun minus x y = IntInf.andb(IntInf.-(x, y), mask);

fun negate x = IntInf.andb(IntInf.~(x), mask);

fun times x y = IntInf.andb(IntInf.*(x, y), mask);

fun divide x y = IntInf.div(x, y);

fun modulus x y = IntInf.mod(x, y);

fun less_eq x y = IntInf.&lt;=(x, y);

fun less x y = IntInf.&lt;(x, y);

fun notb x = IntInf.andb(IntInf.notb(x), mask);

fun orb x y = IntInf.orb(x, y);

fun andb x y = IntInf.andb(x, y);

fun xorb x y = IntInf.xorb(x, y);

val maxWord = IntInf.pow (2, Word.wordSize);

fun shiftl x n = 
  if n &lt; maxWord then IntInf.andb(IntInf.&lt;&lt; (x, Word.fromLargeInt (IntInf.toLarge n)), mask)
  else 0;

fun shiftr x n =
  if n &lt; maxWord then IntInf.~&gt;&gt; (x, Word.fromLargeInt (IntInf.toLarge n))
  else 0;

val msb_mask = 0x8000000000000000 : IntInf.int;

fun shiftr_signed x i =
  if IntInf.andb(x, msb_mask) = 0 then shiftr x i
  else if i &gt;= 64 then 0xFFFFFFFFFFFFFFFF
  else let
    val x' = shiftr x i
    val m' = IntInf.andb(IntInf.&lt;&lt;(mask, Word.max(0w64 - Word.fromLargeInt (IntInf.toLarge i), 0w0)), mask)
  in IntInf.orb(x', m') end;

fun test_bit x n =
  if n &lt; maxWord then IntInf.andb (x, IntInf.&lt;&lt; (1, Word.fromLargeInt (IntInf.toLarge n))) &lt;&gt; 0
  else false;

fun set_bit x n b =
  if n &lt; 64 then
    if b then IntInf.orb (x, IntInf.&lt;&lt; (1, Word.fromLargeInt (IntInf.toLarge n)))
    else IntInf.andb (x, IntInf.notb (IntInf.&lt;&lt; (1, Word.fromLargeInt (IntInf.toLarge n))))
  else x;

end
›</span>
<span class="keyword1"><span class="command">code_reserved</span></span> SML Uint64

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹
<span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">polyml64</span> <span class="main">=</span> LargeWord.wordSize &gt; <span class="inner_numeral">63</span><span class="main">;</span>
  <span class="comment1">(* PolyML 5.6 has bugs in its Word64 implementation. We test for one such bug and refrain
     from using Word64 in that case. Testing is done with dynamic code evaluation such that
     the compiler does not choke on the Word64 structure, which need not be present in a 32bit
     environment. *)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">error_msg</span> <span class="main">=</span> <span class="inner_quoted">"Buggy Word64 structure"</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test_code</span> <span class="main">=</span> 
   <span class="inner_quoted">"val _ = if Word64.div (0w18446744073709551611 : Word64.word, 0w3) = 0w6148914691236517203 then ()\n"</span> ^
   <span class="inner_quoted">"else raise (Fail \""</span> ^ <span class="entity">error_msg</span> ^ <span class="inner_quoted">"\");"</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">f</span> <span class="main">=</span> Exn.interruptible_capture <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">)</span> <span class="main">=&gt;</span> ML_Compiler.eval ML_Compiler.flags Position.none <span class="main">(</span>ML_Lex.tokenize <span class="entity">test_code</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">use_Word64</span> <span class="main">=</span> <span class="entity">polyml64</span> <span class="keyword1"><span class="keyword">andalso</span></span>
    <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">f</span> <span class="main">(</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span> 
       Exn.Res <span class="main">_</span> <span class="main">=&gt;</span> true
     <span class="main">|</span> Exn.Exn <span class="main">(</span><span class="entity">e</span> <span class="keyword1"><span class="keyword">as</span></span> ERROR <span class="entity">m</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="keyword2"><span class="keyword">if</span></span> String.isSuffix <span class="entity">error_msg</span> <span class="entity">m</span> <span class="keyword2"><span class="keyword">then</span></span> false <span class="keyword2"><span class="keyword">else</span></span> Exn.reraise <span class="entity">e</span>
     <span class="main">|</span> Exn.Exn <span class="entity">e</span> <span class="main">=&gt;</span> Exn.reraise <span class="entity">e</span><span class="main">)</span>
    <span class="main">;</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">newline</span> <span class="main">=</span> <span class="inner_quoted">"\n"</span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">content</span> <span class="main">=</span> 
    <span class="inner_quoted">"structure Uint64 : sig"</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"  eqtype uint64;"</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"  val zero : uint64;"</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"  val one : uint64;"</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"  val fromInt : IntInf.int -&gt; uint64;"</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"  val toInt : uint64 -&gt; IntInf.int;"</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"  val toLarge : uint64 -&gt; LargeWord.word;"</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"  val fromLarge : LargeWord.word -&gt; uint64"</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"  val plus : uint64 -&gt; uint64 -&gt; uint64;"</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"  val minus : uint64 -&gt; uint64 -&gt; uint64;"</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"  val times : uint64 -&gt; uint64 -&gt; uint64;"</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"  val divide : uint64 -&gt; uint64 -&gt; uint64;"</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"  val modulus : uint64 -&gt; uint64 -&gt; uint64;"</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"  val negate : uint64 -&gt; uint64;"</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"  val less_eq : uint64 -&gt; uint64 -&gt; bool;"</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"  val less : uint64 -&gt; uint64 -&gt; bool;"</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"  val notb : uint64 -&gt; uint64;"</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"  val andb : uint64 -&gt; uint64 -&gt; uint64;"</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"  val orb : uint64 -&gt; uint64 -&gt; uint64;"</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"  val xorb : uint64 -&gt; uint64 -&gt; uint64;"</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"  val shiftl : uint64 -&gt; IntInf.int -&gt; uint64;"</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"  val shiftr : uint64 -&gt; IntInf.int -&gt; uint64;"</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"  val shiftr_signed : uint64 -&gt; IntInf.int -&gt; uint64;"</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"  val set_bit : uint64 -&gt; IntInf.int -&gt; bool -&gt; uint64;"</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"  val test_bit : uint64 -&gt; IntInf.int -&gt; bool;"</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"end = struct"</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">""</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"type uint64 = Word64.word;"</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">""</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"val zero = (0wx0 : uint64);"</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">""</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"val one = (0wx1 : uint64);"</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">""</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"fun fromInt x = Word64.fromLargeInt (IntInf.toLarge x);"</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">""</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"fun toInt x = IntInf.fromLarge (Word64.toLargeInt x);"</span>  ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">""</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"fun fromLarge x = Word64.fromLarge x;"</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">""</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"fun toLarge x = Word64.toLarge x;"</span>  ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">""</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"fun plus x y = Word64.+(x, y);"</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">""</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"fun minus x y = Word64.-(x, y);"</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">""</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"fun negate x = Word64.~(x);"</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">""</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"fun times x y = Word64.*(x, y);"</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">""</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"fun divide x y = Word64.div(x, y);"</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">""</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"fun modulus x y = Word64.mod(x, y);"</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">""</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"fun less_eq x y = Word64.&lt;=(x, y);"</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">""</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"fun less x y = Word64.&lt;(x, y);"</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">""</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"fun set_bit x n b ="</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"  let val mask = Word64.&lt;&lt; (0wx1, Word.fromLargeInt (IntInf.toLarge n))"</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"  in if b then Word64.orb (x, mask)"</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"     else Word64.andb (x, Word64.notb mask)"</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"  end"</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">""</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"fun shiftl x n ="</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"  Word64.&lt;&lt; (x, Word.fromLargeInt (IntInf.toLarge n))"</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">""</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"fun shiftr x n ="</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"  Word64.&gt;&gt; (x, Word.fromLargeInt (IntInf.toLarge n))"</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">""</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"fun shiftr_signed x n ="</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"  Word64.~&gt;&gt; (x, Word.fromLargeInt (IntInf.toLarge n))"</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">""</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"fun test_bit x n ="</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"  Word64.andb (x, Word64.&lt;&lt; (0wx1, Word.fromLargeInt (IntInf.toLarge n))) &lt;&gt; Word64.fromInt 0"</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">""</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"val notb = Word64.notb"</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">""</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"fun andb x y = Word64.andb(x, y);"</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">""</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"fun orb x y = Word64.orb(x, y);"</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">""</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"fun xorb x y = Word64.xorb(x, y);"</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">""</span> ^ <span class="entity">newline</span> ^
    <span class="inner_quoted">"end (*struct Uint64*)"</span>
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">target_SML64</span> <span class="main">=</span> <span class="inner_quoted">"SML_word"</span><span class="main">;</span>
<span class="keyword2"><span class="keyword">in</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">if</span></span> <span class="entity">use_Word64</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">Code_Target.set_printings</span> <span class="main">(</span><span class="entity">Code_Symbol.Module</span> <span class="main">(</span><span class="inner_quoted">"Uint64"</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="entity">Code_Runtime.target</span><span class="main">,</span> SOME <span class="main">(</span><span class="entity">content</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> I<span class="main">)</span>
  #&gt; <span class="entity">Code_Target.set_printings</span> <span class="main">(</span><span class="entity">Code_Symbol.Module</span> <span class="main">(</span><span class="inner_quoted">"Uint64"</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="entity">target_SML64</span><span class="main">,</span> SOME <span class="main">(</span><span class="entity">content</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>
›</span>

<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">code_module</span></span> Uint64 <span class="main">⇀</span> <span class="main">(</span>Haskell<span class="main">)</span>
 <span class="quoted">‹module Uint64(Int64, Word64) where

  import Data.Int(Int64)
  import Data.Word(Word64)›</span>
<span class="keyword1"><span class="command">code_reserved</span></span> Haskell Uint64

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  OCaml and Scala provide only signed 64bit numbers, so we use these and 
  implement sign-sensitive operations like comparisons manually.
›</span></span>
<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">code_module</span></span> <span class="quoted">"Uint64"</span> <span class="main">⇀</span> <span class="main">(</span>OCaml<span class="main">)</span>
<span class="quoted">‹module Uint64 : sig
  val less : int64 -&gt; int64 -&gt; bool
  val less_eq : int64 -&gt; int64 -&gt; bool
  val set_bit : int64 -&gt; Z.t -&gt; bool -&gt; int64
  val shiftl : int64 -&gt; Z.t -&gt; int64
  val shiftr : int64 -&gt; Z.t -&gt; int64
  val shiftr_signed : int64 -&gt; Z.t -&gt; int64
  val test_bit : int64 -&gt; Z.t -&gt; bool
end = struct

(* negative numbers have their highest bit set, 
   so they are greater than positive ones *)
let less x y =
  if Int64.compare x Int64.zero &lt; 0 then
    Int64.compare y Int64.zero &lt; 0 &amp;&amp; Int64.compare x y &lt; 0
  else Int64.compare y Int64.zero &lt; 0 || Int64.compare x y &lt; 0;;

let less_eq x y =
  if Int64.compare x Int64.zero &lt; 0 then
    Int64.compare y Int64.zero &lt; 0 &amp;&amp; Int64.compare x y &lt;= 0
  else Int64.compare y Int64.zero &lt; 0 || Int64.compare x y &lt;= 0;;

let set_bit x n b =
  let mask = Int64.shift_left Int64.one (Z.to_int n)
  in if b then Int64.logor x mask
     else Int64.logand x (Int64.lognot mask);;

let shiftl x n = Int64.shift_left x (Z.to_int n);;

let shiftr x n = Int64.shift_right_logical x (Z.to_int n);;

let shiftr_signed x n = Int64.shift_right x (Z.to_int n);;

let test_bit x n =
  Int64.compare 
    (Int64.logand x (Int64.shift_left Int64.one (Z.to_int n)))
    Int64.zero
  &lt;&gt; 0;;

end;; (*struct Uint64*)›</span>
<span class="keyword1"><span class="command">code_reserved</span></span> OCaml Uint64

<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">code_module</span></span> Uint64 <span class="main">⇀</span> <span class="main">(</span>Scala<span class="main">)</span>
<span class="quoted">‹object Uint64 {

def less(x: Long, y: Long) : Boolean =
  if (x &lt; 0) y &lt; 0 &amp;&amp; x &lt; y
  else y &lt; 0 || x &lt; y

def less_eq(x: Long, y: Long) : Boolean =
  if (x &lt; 0) y &lt; 0 &amp;&amp; x &lt;= y
  else y &lt; 0 || x &lt;= y

def set_bit(x: Long, n: BigInt, b: Boolean) : Long =
  if (b)
    x | (1L &lt;&lt; n.intValue)
  else
    x &amp; (1L &lt;&lt; n.intValue).unary_~

def shiftl(x: Long, n: BigInt) : Long = x &lt;&lt; n.intValue

def shiftr(x: Long, n: BigInt) : Long = x &gt;&gt;&gt; n.intValue

def shiftr_signed(x: Long, n: BigInt) : Long = x &gt;&gt; n.intValue

def test_bit(x: Long, n: BigInt) : Boolean =
  (x &amp; (1L &lt;&lt; n.intValue)) != 0

} /* object Uint64 */›</span>
<span class="keyword1"><span class="command">code_reserved</span></span> Scala Uint64

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  OCaml's conversion from Big\_int to int64 demands that the value fits int a signed 64-bit integer.
  The following justifies the implementation.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">Uint64_signed</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"integer <span class="main">⇒</span> uint64"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">Uint64_signed</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">&lt;</span> <span class="main">-</span><span class="main">(</span><span class="numeral">0x8000000000000000</span><span class="main">)</span> <span class="main">∨</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">≥</span> <span class="numeral">0x8000000000000000</span> <span class="keyword1">then</span> undefined Uint64 <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="keyword1">else</span> Uint64 <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Uint64-Uint64_code"><span class="command">lemma</span></span> Uint64_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Uint64 <span class="free">i</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">let</span> <span class="bound">i'</span> <span class="main">=</span> <span class="free">i</span> <span class="keyword1">AND</span> <span class="numeral">0xFFFFFFFFFFFFFFFF</span>
   <span class="keyword1">in</span> <span class="keyword1">if</span> bit <span class="bound">i'</span> <span class="numeral">63</span> <span class="keyword1">then</span> Uint64_signed <span class="main">(</span><span class="bound">i'</span> <span class="main">-</span> <span class="numeral">0x10000000000000000</span><span class="main">)</span> <span class="keyword1">else</span> Uint64_signed <span class="bound">i'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> undefined_transfer integer.lifting <span class="keyword1"><span class="command">unfolding</span></span> Uint64_signed_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> word_of_int_via_signed<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> shiftl_eq_push_bit push_bit_of_1 mask_eq_exp_minus_1 word_of_int_via_signed <span class="quasi_keyword">cong</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> if_cong<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Uint64-Uint64_signed_code"><span class="command">lemma</span></span> Uint64_signed_code <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">abstract</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Rep_uint64 <span class="main">(</span>Uint64_signed <span class="free">i</span><span class="main">)</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">i</span> <span class="main">&lt;</span> <span class="main">-</span><span class="main">(</span><span class="numeral">0x8000000000000000</span><span class="main">)</span> <span class="main">∨</span> <span class="free">i</span> <span class="main">≥</span> <span class="numeral">0x8000000000000000</span> <span class="keyword1">then</span> Rep_uint64 <span class="main">(</span>undefined Uint64 <span class="free">i</span><span class="main">)</span> <span class="keyword1">else</span> word_of_int <span class="main">(</span>int_of_integer_symbolic <span class="free">i</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> Uint64_signed_def Uint64_def int_of_integer_symbolic_def word_of_integer_def
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_uint64_inverse<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Avoid <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Abs_uint64</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> in generated code, use <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">Rep_uint64'</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> instead. 
  The symbolic implementations for code\_simp use <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Rep_uint64</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.

  The new destructor <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">Rep_uint64'</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is executable.
  As the simplifier is given the [code abstract] equations literally, 
  we cannot implement <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Rep_uint64</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> directly, because that makes code\_simp loop.

  If code generation raises Match, some equation probably contains <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Rep_uint64</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> 
  ([code abstract] equations for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">uint64</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> may use <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Rep_uint64</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> because
  these instances will be folded away.)

  To convert <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="numeral"><span class="numeral">64</span></span> word"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> values into <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">uint64</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, use <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">Abs_uint64'</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">Rep_uint64'</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Rep_uint64'</span> <span class="main">=</span> Rep_uint64"</span></span>

<span class="keyword1" id="Uint64-Rep_uint64'_transfer"><span class="command">lemma</span></span> Rep_uint64'_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"rel_fun cr_uint64 <span class="main">(=)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">)</span> Rep_uint64'"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> Rep_uint64'_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> uint64.rep_transfer<span class="main">)</span>

<span class="keyword1" id="Uint64-Rep_uint64'_code"><span class="command">lemma</span></span> Rep_uint64'_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Rep_uint64' <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">BITS</span> <span class="bound">n</span><span class="main">.</span> bit <span class="free">x</span> <span class="bound">n</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_bits_bit_eq<span class="main">)</span>

<span class="keyword1"><span class="command">lift_definition</span></span> Abs_uint64' <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="numeral">64</span> word <span class="main">⇒</span> uint64"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span> <span class="main">::</span> <span class="numeral">64</span> word<span class="main">.</span> <span class="bound">x</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1" id="Uint64-Abs_uint64'_code"><span class="command">lemma</span></span> Abs_uint64'_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Abs_uint64' <span class="free">x</span> <span class="main">=</span> Uint64 <span class="main">(</span>integer_of_int <span class="main">(</span>uint <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">including</span></span> integer.lifting <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">"term_of_class.term_of <span class="main">::</span> uint64 <span class="main">⇒</span> <span class="main">_</span>"</span></span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Uint64-term_of_uint64_code"><span class="command">lemma</span></span> term_of_uint64_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">TR</span> <span class="main">≡</span> typerep.Typerep"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">bit0</span> <span class="main">≡</span> <span class="keyword1">STR</span> <span class="inner_quoted">''Numeral_Type.bit0''</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"term_of_class.term_of <span class="free">x</span> <span class="main">=</span> 
   Code_Evaluation.App <span class="main">(</span>Code_Evaluation.Const <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Uint64.uint64.Abs_uint64''</span><span class="main">)</span> <span class="main">(</span><span class="free">TR</span> <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''fun''</span><span class="main">)</span> <span class="main">[</span><span class="free">TR</span> <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Word.word''</span><span class="main">)</span> <span class="main">[</span><span class="free">TR</span> <span class="free">bit0</span> <span class="main">[</span><span class="free">TR</span> <span class="free">bit0</span> <span class="main">[</span><span class="free">TR</span> <span class="free">bit0</span> <span class="main">[</span><span class="free">TR</span> <span class="free">bit0</span> <span class="main">[</span><span class="free">TR</span> <span class="free">bit0</span> <span class="main">[</span><span class="free">TR</span> <span class="free">bit0</span> <span class="main">[</span><span class="free">TR</span> <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Numeral_Type.num1''</span><span class="main">)</span> <span class="main">[]</span><span class="main">]</span><span class="main">]</span><span class="main">]</span><span class="main">]</span><span class="main">]</span><span class="main">]</span><span class="main">]</span><span class="main">,</span> <span class="free">TR</span> <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Uint64.uint64''</span><span class="main">)</span> <span class="main">[]</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
       <span class="main">(</span>term_of_class.term_of <span class="main">(</span>Rep_uint64' <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> term_of_anything<span class="main">)</span>

<span class="keyword1"><span class="command">code_printing</span></span>
  <span class="keyword2"><span class="keyword">type_constructor</span></span> uint64 <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Uint64.uint64"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"Uint64.Word64"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"int64"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"Long"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">Uint64</span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Uint64.fromInt"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"(Prelude.fromInteger _ :: Uint64.Word64)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell_Quickcheck<span class="main">)</span> <span class="quoted">"(Prelude.fromInteger (Prelude.toInteger _) :: Uint64.Word64)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"_.longValue"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">Uint64_signed</span> <span class="main">⇀</span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Z.to'_int64"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">::</span> uint64"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Uint64.zero"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"(0 :: Uint64.Word64)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Int64.zero"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"0"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">::</span> uint64"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Uint64.one"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"(1 :: Uint64.Word64)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Int64.one"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"1"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"plus <span class="main">::</span> uint64 <span class="main">⇒</span> <span class="main">_</span> "</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Uint64.plus"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 6 <span class="quoted">"+"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Int64.add"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 7 <span class="quoted">"+"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"uminus <span class="main">::</span> uint64 <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Uint64.negate"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"negate"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Int64.neg"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"!(- _)"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"minus <span class="main">::</span> uint64 <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Uint64.minus"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 6 <span class="quoted">"-"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Int64.sub"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 7 <span class="quoted">"-"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"times <span class="main">::</span> uint64 <span class="main">⇒</span> <span class="main">_</span> <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Uint64.times"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 7 <span class="quoted">"*"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Int64.mul"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 8 <span class="quoted">"*"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"HOL.equal <span class="main">::</span> uint64 <span class="main">⇒</span> <span class="main">_</span> <span class="main">⇒</span> bool"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"!((_ : Uint64.uint64) = _)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="keyword2"><span class="keyword">infix</span></span> 4 <span class="quoted">"=="</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"(Int64.compare _ _ = 0)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 5 <span class="quoted">"=="</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">class_instance</span></span> uint64 <span class="main">::</span> equal <span class="main">⇀</span>
  <span class="main">(</span>Haskell<span class="main">)</span> -
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"less_eq <span class="main">::</span> uint64 <span class="main">⇒</span> <span class="main">_</span> <span class="main">⇒</span> bool"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Uint64.less'_eq"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="keyword2"><span class="keyword">infix</span></span> 4 <span class="quoted">"&lt;="</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Uint64.less'_eq"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"Uint64.less'_eq"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"less <span class="main">::</span> uint64 <span class="main">⇒</span> <span class="main">_</span> <span class="main">⇒</span> bool"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Uint64.less"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="keyword2"><span class="keyword">infix</span></span> 4 <span class="quoted">"&lt;"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Uint64.less"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"Uint64.less"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">NOT</span> <span class="main">::</span> uint64 <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Uint64.notb"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"Data'_Bits.complement"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Int64.lognot"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"_.unary'_~"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">(AND)</span> <span class="main">::</span> uint64 <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Uint64.andb"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 7 <span class="quoted">"Data_Bits..&amp;."</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Int64.logand"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 3 <span class="quoted">"&amp;"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">(OR)</span> <span class="main">::</span> uint64 <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Uint64.orb"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 5 <span class="quoted">"Data_Bits..|."</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Int64.logor"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 1 <span class="quoted">"|"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">(XOR)</span> <span class="main">::</span> uint64 <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Uint64.xorb"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"Data'_Bits.xor"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Int64.logxor"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 2 <span class="quoted">"^"</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint64_divmod</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint64 <span class="main">⇒</span> uint64 <span class="main">⇒</span> uint64 <span class="main">×</span> uint64"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">uint64_divmod</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">(</span>undefined <span class="main">(</span><span class="keyword1">(div)</span> <span class="main">::</span> uint64 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="main">0</span> <span class="main">::</span> uint64<span class="main">)</span><span class="main">,</span> undefined <span class="main">(</span><span class="keyword1">(mod)</span> <span class="main">::</span> uint64 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="main">0</span> <span class="main">::</span> uint64<span class="main">)</span><span class="main">)</span> 
  <span class="keyword1">else</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">div</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">mod</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint64_div</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint64 <span class="main">⇒</span> uint64 <span class="main">⇒</span> uint64"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">uint64_div</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> fst <span class="main">(</span>uint64_divmod <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint64_mod</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint64 <span class="main">⇒</span> uint64 <span class="main">⇒</span> uint64"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">uint64_mod</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> snd <span class="main">(</span>uint64_divmod <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Uint64-div_uint64_code"><span class="command">lemma</span></span> div_uint64_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="keyword1">div</span> <span class="free">y</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">y</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> uint64_div <span class="free">x</span> <span class="free">y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">including</span></span> undefined_transfer <span class="keyword1"><span class="command">unfolding</span></span> uint64_divmod_def uint64_div_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> word_div_def<span class="main">)</span>

<span class="keyword1" id="Uint64-mod_uint64_code"><span class="command">lemma</span></span> mod_uint64_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="keyword1">mod</span> <span class="free">y</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">y</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="free">x</span> <span class="keyword1">else</span> uint64_mod <span class="free">x</span> <span class="free">y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">including</span></span> undefined_transfer <span class="keyword1"><span class="command">unfolding</span></span> uint64_mod_def uint64_divmod_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> word_mod_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint64_sdiv</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint64 <span class="main">⇒</span> uint64 <span class="main">⇒</span> uint64"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">uint64_sdiv</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span>
   <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> undefined <span class="main">(</span><span class="keyword1">(div)</span> <span class="main">::</span> uint64 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="main">0</span> <span class="main">::</span> uint64<span class="main">)</span>
    <span class="keyword1">else</span> Abs_uint64 <span class="main">(</span>Rep_uint64 <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">sdiv</span> Rep_uint64 <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">div0_uint64</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint64 <span class="main">⇒</span> uint64"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">div0_uint64</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> undefined <span class="main">(</span><span class="keyword1">(div)</span> <span class="main">::</span> uint64 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="main">0</span> <span class="main">::</span> uint64<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">abort</span><span class="main"><span class="main">:</span></span> <span class="quoted">div0_uint64</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">mod0_uint64</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint64 <span class="main">⇒</span> uint64"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">mod0_uint64</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> undefined <span class="main">(</span><span class="keyword1">(mod)</span> <span class="main">::</span> uint64 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="main">0</span> <span class="main">::</span> uint64<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">abort</span><span class="main"><span class="main">:</span></span> <span class="quoted">mod0_uint64</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Uint64-uint64_divmod_code"><span class="command">lemma</span></span> uint64_divmod_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"uint64_divmod <span class="free">x</span> <span class="free">y</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="numeral">0x8000000000000000</span> <span class="main">≤</span> <span class="free">y</span> <span class="keyword1">then</span> <span class="keyword1">if</span> <span class="free">x</span> <span class="main">&lt;</span> <span class="free">y</span> <span class="keyword1">then</span> <span class="main">(</span><span class="main">0</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">(</span><span class="main">1</span><span class="main">,</span> <span class="free">x</span> <span class="main">-</span> <span class="free">y</span><span class="main">)</span>
   <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="free">y</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">(</span>div0_uint64 <span class="free">x</span><span class="main">,</span> mod0_uint64 <span class="free">x</span><span class="main">)</span>
   <span class="keyword1">else</span> <span class="keyword1">let</span> <span class="bound">q</span> <span class="main">=</span> push_bit <span class="main">1</span> <span class="main">(</span>uint64_sdiv <span class="main">(</span>drop_bit <span class="main">1</span> <span class="free">x</span><span class="main">)</span> <span class="free">y</span><span class="main">)</span><span class="main">;</span>
            <span class="bound">r</span> <span class="main">=</span> <span class="free">x</span> <span class="main">-</span> <span class="bound">q</span> <span class="main">*</span> <span class="free">y</span>
        <span class="keyword1">in</span> <span class="keyword1">if</span> <span class="bound">r</span> <span class="main">≥</span> <span class="free">y</span> <span class="keyword1">then</span> <span class="main">(</span><span class="bound">q</span> <span class="main">+</span> <span class="main">1</span><span class="main">,</span> <span class="bound">r</span> <span class="main">-</span> <span class="free">y</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">(</span><span class="bound">q</span><span class="main">,</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> undefined_transfer <span class="keyword1"><span class="command">unfolding</span></span> uint64_divmod_def uint64_sdiv_def div0_uint64_def mod0_uint64_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> divmod_via_sdivmod shiftr_eq_drop_bit shiftl_eq_push_bit <span class="dynamic"><span class="dynamic">ac_simps</span></span><span class="main">)</span>

<span class="keyword1" id="Uint64-uint64_sdiv_code"><span class="command">lemma</span></span> uint64_sdiv_code <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">abstract</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Rep_uint64 <span class="main">(</span>uint64_sdiv <span class="free">x</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span>
   <span class="main">(</span><span class="keyword1">if</span> <span class="free">y</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> Rep_uint64 <span class="main">(</span>undefined <span class="main">(</span><span class="keyword1">(div)</span> <span class="main">::</span> uint64 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free">x</span> <span class="main">(</span><span class="main">0</span> <span class="main">::</span> uint64<span class="main">)</span><span class="main">)</span>
    <span class="keyword1">else</span> Rep_uint64 <span class="free">x</span> <span class="keyword1">sdiv</span> Rep_uint64 <span class="free">y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> uint64_sdiv_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_uint64_inverse<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Note that we only need a translation for signed division, but not for the remainder
  because <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> uint64_divmod_code<span class="antiquote"><span class="antiquote">}</span></span></span></span> computes both with division only.
›</span></span>

<span class="keyword1"><span class="command">code_printing</span></span>
  <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint64_div</span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Uint64.divide"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"Prelude.div"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint64_mod</span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Uint64.modulus"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"Prelude.mod"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint64_divmod</span> <span class="main">⇀</span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"divmod"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint64_sdiv</span> <span class="main">⇀</span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Int64.div"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"_ '/ _"</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint64_test_bit</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint64 <span class="main">⇒</span> integer <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">uint64_test_bit</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">∨</span> <span class="numeral">63</span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">then</span> undefined <span class="main">(</span>bit <span class="main">::</span> uint64 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span>
   <span class="keyword1">else</span> bit <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span>nat_of_integer <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Uint64-bit_uint64_code"><span class="command">lemma</span></span> bit_uint64_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"bit <span class="free">x</span> <span class="free">n</span> <span class="main">⟷</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="numeral">64</span> <span class="main">∧</span> uint64_test_bit <span class="free">x</span> <span class="main">(</span>integer_of_nat <span class="free">n</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> undefined_transfer integer.lifting <span class="keyword1"><span class="command">unfolding</span></span> uint64_test_bit_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="Uint64-uint64_test_bit_code"><span class="command">lemma</span></span> uint64_test_bit_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"uint64_test_bit <span class="free">w</span> <span class="free">n</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">∨</span> <span class="numeral">63</span> <span class="main">&lt;</span> <span class="free">n</span> <span class="keyword1">then</span> undefined <span class="main">(</span>bit <span class="main">::</span> uint64 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free">w</span> <span class="free">n</span> <span class="keyword1">else</span> bit <span class="main">(</span>Rep_uint64 <span class="free">w</span><span class="main">)</span> <span class="main">(</span>nat_of_integer <span class="free">n</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> uint64_test_bit_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bit_uint64.rep_eq<span class="main">)</span>

<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint64_test_bit</span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Uint64.test'_bit"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"Data'_Bits.testBitBounded"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Uint64.test'_bit"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"Uint64.test'_bit"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Eval<span class="main">)</span> <span class="quoted">"(fn x =&gt; fn i =&gt; if i &lt; 0 orelse i &gt;= 64 then raise (Fail \"argument to uint64'_test'_bit out of bounds\") else Uint64.test'_bit x i)"</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint64_set_bit</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint64 <span class="main">⇒</span> integer <span class="main">⇒</span> bool <span class="main">⇒</span> uint64"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">uint64_set_bit</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">∨</span> <span class="numeral">63</span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">then</span> undefined <span class="main">(</span>set_bit <span class="main">::</span> uint64 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span>
   <span class="keyword1">else</span> set_bit <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span>nat_of_integer <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Uint64-set_bit_uint64_code"><span class="command">lemma</span></span> set_bit_uint64_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"set_bit <span class="free">x</span> <span class="free">n</span> <span class="free">b</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="numeral">64</span> <span class="keyword1">then</span> uint64_set_bit <span class="free">x</span> <span class="main">(</span>integer_of_nat <span class="free">n</span><span class="main">)</span> <span class="free">b</span> <span class="keyword1">else</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">including</span></span> undefined_transfer integer.lifting <span class="keyword1"><span class="command">unfolding</span></span> uint64_set_bit_def
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">transfer</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> conj_cong <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_less set_bit_beyond word_size<span class="main">)</span>

<span class="keyword1" id="Uint64-uint64_set_bit_code"><span class="command">lemma</span></span> uint64_set_bit_code <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">abstract</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Rep_uint64 <span class="main">(</span>uint64_set_bit <span class="free">w</span> <span class="free">n</span> <span class="free">b</span><span class="main">)</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">∨</span> <span class="numeral">63</span> <span class="main">&lt;</span> <span class="free">n</span> <span class="keyword1">then</span> Rep_uint64 <span class="main">(</span>undefined <span class="main">(</span>set_bit <span class="main">::</span> uint64 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free">w</span> <span class="free">n</span> <span class="free">b</span><span class="main">)</span>
   <span class="keyword1">else</span> set_bit <span class="main">(</span>Rep_uint64 <span class="free">w</span><span class="main">)</span> <span class="main">(</span>nat_of_integer <span class="free">n</span><span class="main">)</span> <span class="free">b</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">including</span></span> undefined_transfer <span class="keyword1"><span class="command">unfolding</span></span> uint64_set_bit_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint64_set_bit</span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Uint64.set'_bit"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"Data'_Bits.setBitBounded"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Uint64.set'_bit"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"Uint64.set'_bit"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Eval<span class="main">)</span> <span class="quoted">"(fn x =&gt; fn i =&gt; fn b =&gt; if i &lt; 0 orelse i &gt;= 64 then raise (Fail \"argument to uint64'_set'_bit out of bounds\") else Uint64.set'_bit x i b)"</span>

<span class="keyword1"><span class="command">lift_definition</span></span> uint64_set_bits <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nat <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> uint64 <span class="main">⇒</span> nat <span class="main">⇒</span> uint64"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">set_bits_aux</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1" id="Uint64-uint64_set_bits_code"><span class="command">lemma</span></span> uint64_set_bits_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"uint64_set_bits <span class="free">f</span> <span class="free">w</span> <span class="free">n</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="free">w</span> 
   <span class="keyword1">else</span> <span class="keyword1">let</span> <span class="bound">n'</span> <span class="main">=</span> <span class="free">n</span> <span class="main">-</span> <span class="main">1</span> <span class="keyword1">in</span> uint64_set_bits <span class="free">f</span> <span class="main">(</span>push_bit <span class="main">1</span> <span class="free">w</span> <span class="keyword1">OR</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">f</span> <span class="bound">n'</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span> <span class="bound">n'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">transfer</span> <span class="quasi_keyword">fixing</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> shiftl_eq_push_bit<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Uint64-set_bits_uint64"><span class="command">lemma</span></span> set_bits_uint64 <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">BITS</span> <span class="bound">n</span><span class="main">.</span> <span class="free">f</span> <span class="bound">n</span><span class="main">)</span> <span class="main">=</span> uint64_set_bits <span class="free">f</span> <span class="main">0</span> <span class="numeral">64</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_bits_conv_set_bits_aux<span class="main">)</span>


<span class="keyword1" id="Uint64-lsb_code"><span class="command">lemma</span></span> lsb_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span> <span class="main">::</span> <span class="quoted">uint64</span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lsb <span class="free">x</span> <span class="main">=</span> bit <span class="free">x</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lsb_word_eq<span class="main">)</span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint64_shiftl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint64 <span class="main">⇒</span> integer <span class="main">⇒</span> uint64"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">uint64_shiftl</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">∨</span> <span class="numeral">64</span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">then</span> undefined <span class="main">(</span>push_bit <span class="main">::</span> nat <span class="main">⇒</span> uint64 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">else</span> push_bit <span class="main">(</span>nat_of_integer <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Uint64-shiftl_uint64_code"><span class="command">lemma</span></span> shiftl_uint64_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"push_bit <span class="free">n</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="numeral">64</span> <span class="keyword1">then</span> uint64_shiftl <span class="free">x</span> <span class="main">(</span>integer_of_nat <span class="free">n</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> undefined_transfer integer.lifting <span class="keyword1"><span class="command">unfolding</span></span> uint64_shiftl_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Uint64-uint64_shiftl_code"><span class="command">lemma</span></span> uint64_shiftl_code <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">abstract</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Rep_uint64 <span class="main">(</span>uint64_shiftl <span class="free">w</span> <span class="free">n</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">∨</span> <span class="numeral">64</span> <span class="main">≤</span> <span class="free">n</span> <span class="keyword1">then</span> Rep_uint64 <span class="main">(</span>undefined <span class="main">(</span>push_bit <span class="main">::</span> nat <span class="main">⇒</span> uint64 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free">w</span> <span class="free">n</span><span class="main">)</span> <span class="keyword1">else</span> push_bit <span class="main">(</span>nat_of_integer <span class="free">n</span><span class="main">)</span> <span class="main">(</span>Rep_uint64 <span class="free">w</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">including</span></span> undefined_transfer <span class="keyword1"><span class="command">unfolding</span></span> uint64_shiftl_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint64_shiftl</span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Uint64.shiftl"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"Data'_Bits.shiftlBounded"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Uint64.shiftl"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"Uint64.shiftl"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Eval<span class="main">)</span> <span class="quoted">"(fn x =&gt; fn i =&gt; if i &lt; 0 orelse i &gt;= 64 then raise (Fail \"argument to uint64'_shiftl out of bounds\") else Uint64.shiftl x i)"</span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint64_shiftr</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint64 <span class="main">⇒</span> integer <span class="main">⇒</span> uint64"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">uint64_shiftr</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">∨</span> <span class="numeral">64</span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">then</span> undefined <span class="main">(</span>drop_bit <span class="main">::</span> nat <span class="main">⇒</span> uint64 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">else</span> drop_bit <span class="main">(</span>nat_of_integer <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Uint64-shiftr_uint64_code"><span class="command">lemma</span></span> shiftr_uint64_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"drop_bit <span class="free">n</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="numeral">64</span> <span class="keyword1">then</span> uint64_shiftr <span class="free">x</span> <span class="main">(</span>integer_of_nat <span class="free">n</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> undefined_transfer integer.lifting <span class="keyword1"><span class="command">unfolding</span></span> uint64_shiftr_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Uint64-uint64_shiftr_code"><span class="command">lemma</span></span> uint64_shiftr_code <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">abstract</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Rep_uint64 <span class="main">(</span>uint64_shiftr <span class="free">w</span> <span class="free">n</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">∨</span> <span class="numeral">64</span> <span class="main">≤</span> <span class="free">n</span> <span class="keyword1">then</span> Rep_uint64 <span class="main">(</span>undefined <span class="main">(</span>drop_bit <span class="main">::</span> nat <span class="main">⇒</span> uint64 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free">w</span> <span class="free">n</span><span class="main">)</span> <span class="keyword1">else</span> drop_bit <span class="main">(</span>nat_of_integer <span class="free">n</span><span class="main">)</span> <span class="main">(</span>Rep_uint64 <span class="free">w</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> undefined_transfer <span class="keyword1"><span class="command">unfolding</span></span> uint64_shiftr_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint64_shiftr</span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Uint64.shiftr"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"Data'_Bits.shiftrBounded"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Uint64.shiftr"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"Uint64.shiftr"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Eval<span class="main">)</span> <span class="quoted">"(fn x =&gt; fn i =&gt; if i &lt; 0 orelse i &gt;= 64 then raise (Fail \"argument to uint64'_shiftr out of bounds\") else Uint64.shiftr x i)"</span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint64_sshiftr</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint64 <span class="main">⇒</span> integer <span class="main">⇒</span> uint64"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">uint64_sshiftr</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">∨</span> <span class="numeral">64</span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">then</span> undefined sshiftr_uint64 <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">else</span> sshiftr_uint64 <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span>nat_of_integer <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Uint64-sshiftr_uint64_code"><span class="command">lemma</span></span> sshiftr_uint64_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">&gt;&gt;&gt;</span> <span class="free">n</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="numeral">64</span> <span class="keyword1">then</span> uint64_sshiftr <span class="free">x</span> <span class="main">(</span>integer_of_nat <span class="free">n</span><span class="main">)</span> <span class="keyword1">else</span> <span class="keyword1">if</span> bit <span class="free">x</span> <span class="numeral">63</span> <span class="keyword1">then</span> <span class="main">-</span> <span class="main">1</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> undefined_transfer integer.lifting <span class="keyword1"><span class="command">unfolding</span></span> uint64_sshiftr_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_less signed_drop_bit_beyond<span class="main">)</span>

<span class="keyword1" id="Uint64-uint64_sshiftr_code"><span class="command">lemma</span></span> uint64_sshiftr_code <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">abstract</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Rep_uint64 <span class="main">(</span>uint64_sshiftr <span class="free">w</span> <span class="free">n</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">∨</span> <span class="numeral">64</span> <span class="main">≤</span> <span class="free">n</span> <span class="keyword1">then</span> Rep_uint64 <span class="main">(</span>undefined sshiftr_uint64 <span class="free">w</span> <span class="free">n</span><span class="main">)</span> <span class="keyword1">else</span> signed_drop_bit <span class="main">(</span>nat_of_integer <span class="free">n</span><span class="main">)</span> <span class="main">(</span>Rep_uint64 <span class="free">w</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">including</span></span> undefined_transfer <span class="keyword1"><span class="command">unfolding</span></span> uint64_sshiftr_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint64_sshiftr</span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Uint64.shiftr'_signed"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> 
    <span class="quoted">"(Prelude.fromInteger (Prelude.toInteger (Data'_Bits.shiftrBounded (Prelude.fromInteger (Prelude.toInteger _) :: Uint64.Int64) _)) :: Uint64.Word64)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Uint64.shiftr'_signed"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"Uint64.shiftr'_signed"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Eval<span class="main">)</span> <span class="quoted">"(fn x =&gt; fn i =&gt; if i &lt; 0 orelse i &gt;= 64 then raise (Fail \"argument to uint64'_shiftr'_signed out of bounds\") else Uint64.shiftr'_signed x i)"</span>

<span class="keyword1" id="Uint64-uint64_msb_test_bit"><span class="command">lemma</span></span> uint64_msb_test_bit<span class="main">:</span> <span class="quoted"><span class="quoted">"msb <span class="free">x</span> <span class="main">⟷</span> bit <span class="main">(</span><span class="free">x</span> <span class="main">::</span> uint64<span class="main">)</span> <span class="numeral">63</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> msb_word_iff_bit<span class="main">)</span>

<span class="keyword1" id="Uint64-msb_uint64_code"><span class="command">lemma</span></span> msb_uint64_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"msb <span class="free">x</span> <span class="main">⟷</span> uint64_test_bit <span class="free">x</span> <span class="numeral">63</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> uint64_test_bit_def uint64_msb_test_bit<span class="main">)</span>

<span class="keyword1" id="Uint64-uint64_of_int_code"><span class="command">lemma</span></span> uint64_of_int_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"uint64_of_int <span class="free">i</span> <span class="main">=</span> Uint64 <span class="main">(</span>integer_of_int <span class="free">i</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">including</span></span> integer.lifting <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Uint64-int_of_uint64_code"><span class="command">lemma</span></span> int_of_uint64_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"int_of_uint64 <span class="free">x</span> <span class="main">=</span> int_of_integer <span class="main">(</span>integer_of_uint64 <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> integer_of_uint64_def<span class="main">)</span>

<span class="keyword1" id="Uint64-nat_of_uint64_code"><span class="command">lemma</span></span> nat_of_uint64_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"nat_of_uint64 <span class="free">x</span> <span class="main">=</span> nat_of_integer <span class="main">(</span>integer_of_uint64 <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> integer_of_uint64_def <span class="keyword1"><span class="command">including</span></span> integer.lifting <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">integer_of_uint64_signed</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint64 <span class="main">⇒</span> integer"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">integer_of_uint64_signed</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> bit <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="numeral">63</span> <span class="keyword1">then</span> undefined integer_of_uint64 <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">else</span> integer_of_uint64 <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Uint64-integer_of_uint64_signed_code"><span class="command">lemma</span></span> integer_of_uint64_signed_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"integer_of_uint64_signed <span class="free">n</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> bit <span class="free">n</span> <span class="numeral">63</span> <span class="keyword1">then</span> undefined integer_of_uint64 <span class="free">n</span> <span class="keyword1">else</span> integer_of_int <span class="main">(</span>uint <span class="main">(</span>Rep_uint64' <span class="free">n</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> integer_of_uint64_signed_def integer_of_uint64_def
<span class="keyword1"><span class="command">including</span></span> undefined_transfer <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Uint64-integer_of_uint64_code"><span class="command">lemma</span></span> integer_of_uint64_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"integer_of_uint64 <span class="free">n</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> bit <span class="free">n</span> <span class="numeral">63</span> <span class="keyword1">then</span> integer_of_uint64_signed <span class="main">(</span><span class="free">n</span> <span class="keyword1">AND</span> <span class="numeral">0x7FFFFFFFFFFFFFFF</span><span class="main">)</span> <span class="keyword1">OR</span> <span class="numeral">0x8000000000000000</span> <span class="keyword1">else</span> integer_of_uint64_signed <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="numeral">0x7FFFFFFFFFFFFFFF</span> <span class="main">::</span> uint64<span class="main">)</span> <span class="main">=</span> mask <span class="numeral">63</span>›</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mask_eq_exp_minus_1<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">‹<span class="free">n</span> <span class="keyword1">AND</span> <span class="numeral">0x7FFFFFFFFFFFFFFF</span> <span class="main">=</span> take_bit <span class="numeral">63</span> <span class="free">n</span>›</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> take_bit_eq_mask<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> **<span class="main">:</span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="numeral">0x8000000000000000</span> <span class="main">::</span> int<span class="main">)</span> <span class="main">=</span> <span class="numeral">2</span> <span class="main">^</span> <span class="numeral">63</span>›</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> integer_of_uint64_def integer_of_uint64_signed_def o_def *
    <span class="keyword1"><span class="command">including</span></span> undefined_transfer integer.lifting
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> bit_eqI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> test_bit_eq_bit bit_or_iff bit_take_bit_iff bit_uint_iff<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> bit_exp_iff bit_or_iff **<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">code_printing</span></span>
  <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"integer_of_uint64"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Uint64.toInt"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"Prelude.toInteger"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"integer_of_uint64_signed"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Z.of'_int64"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"BigInt"</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Quickcheck setup›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint64_of_natural</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"natural <span class="main">⇒</span> uint64"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">uint64_of_natural</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≡</span> Uint64 <span class="main">(</span>integer_of_natural <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint64 <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">{</span>random<span class="main">,</span> exhaustive<span class="main">,</span> full_exhaustive<span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">random_uint64</span></span> <span class="main">≡</span> qc_random_cnv uint64_of_natural"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">exhaustive_uint64</span></span> <span class="main">≡</span> qc_exhaustive_cnv uint64_of_natural"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">full_exhaustive_uint64</span></span> <span class="main">≡</span> qc_full_exhaustive_cnv uint64_of_natural"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint64 <span class="main">::</span> <span class="quoted">narrowing</span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> quickcheck_narrowing_samples
  <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">i</span><span class="main">.</span> <span class="keyword1">let</span> <span class="bound">x</span> <span class="main">=</span> Uint64 <span class="bound">i</span> <span class="keyword1">in</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="numeral">0xFFFFFFFFFFFFFFFF</span> <span class="main">-</span> <span class="bound">x</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span>"</span></span>
  <span class="quoted"><span class="quoted">"Typerep.Typerep <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Uint64.uint64''</span><span class="main">)</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">narrowing_uint64</span></span> <span class="free"><span class="bound"><span class="entity">d</span></span></span> <span class="main">=</span> qc_narrowing_drawn_from <span class="main">(</span>narrowing_samples <span class="free"><span class="bound"><span class="entity">d</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">d</span></span></span>"</span></span>
<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">"partial_term_of <span class="main">::</span> uint64 itself <span class="main">⇒</span> <span class="main">_</span>"</span></span><span class="main">]</span><span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> partial_term_of_uint64 <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> partial_term_of_code

<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">no_notation</span></span> sshiftr_uint64 <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">&gt;&gt;&gt;</span>"</span> 55<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Uint32">
<div class="head">
<h1>Theory Uint32</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Uint32.thy
    Author:     Andreas Lochbihler, ETH Zurich
*)</span>

<span class="keyword1"><span class="command">chapter</span></span> <span class="quoted"><span class="plain_text">‹Unsigned words of 32 bits›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Uint32 <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Code_Target_Word_Base.html">Code_Target_Word_Base</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">declare</span></span> prod.Quotient<span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Type definition and primitive operations›</span></span>

<span class="keyword1"><span class="command">typedef</span></span> uint32 <span class="main">=</span> <span class="quoted"><span class="quoted">"UNIV <span class="main">::</span> <span class="numeral">32</span> word set"</span></span> <span class="keyword1"><span class="command">..</span></span> 

<span class="keyword1"><span class="command">setup_lifting</span></span> type_definition_uint32

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Use an abstract type for code generation to disable pattern matching on <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Abs_uint32</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>
<span class="keyword1"><span class="command">declare</span></span> Rep_uint32_inverse<span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">abstype</span><span class="main">]</span>

<span class="keyword1"><span class="command">declare</span></span> Quotient_uint32<span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span>

<span class="keyword1"><span class="command">instantiation</span></span> uint32 <span class="main">::</span> <span class="quoted">comm_ring_1</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">zero_uint32</span> <span class="main">::</span> <span class="quoted">uint32</span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">::</span> <span class="numeral">32</span> word"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">one_uint32</span> <span class="main">::</span> <span class="quoted">uint32</span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">plus_uint32</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint32 <span class="main">⇒</span> uint32 <span class="main">⇒</span> uint32"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(+)</span> <span class="main">::</span> <span class="numeral">32</span> word <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">minus_uint32</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint32 <span class="main">⇒</span> uint32 <span class="main">⇒</span> uint32"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(-)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">uminus_uint32</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint32 <span class="main">⇒</span> uint32"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">uminus</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">times_uint32</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint32 <span class="main">⇒</span> uint32 <span class="main">⇒</span> uint32"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(*)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">transfer</span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">algebra_simps</span></span><span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint32 <span class="main">::</span> <span class="quoted">semiring_modulo</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">divide_uint32</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint32 <span class="main">⇒</span> uint32 <span class="main">⇒</span> uint32"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">(div)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">modulo_uint32</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint32 <span class="main">⇒</span> uint32 <span class="main">⇒</span> uint32"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">(mod)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">transfer</span><span class="main">)</span> <span class="main">(</span><span class="operator">fact</span> word_mod_div_equality<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint32 <span class="main">::</span> <span class="quoted">linorder</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">less_uint32</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint32 <span class="main">⇒</span> uint32 <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(&lt;)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">less_eq_uint32</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint32 <span class="main">⇒</span> uint32 <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(≤)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">transfer</span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_le_not_le linear<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> less_uint32.rep_eq less_eq_uint32.rep_eq

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax
  <span class="keyword2"><span class="keyword">notes</span></span>
    transfer_rule_of_bool <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span>
    transfer_rule_numeral <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> cr_uint32<span class="main">)</span> of_bool of_bool"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Uint32-transfer_rule_numeral_uint"><span class="command">lemma</span></span> transfer_rule_numeral_uint <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> cr_uint32<span class="main">)</span> numeral numeral"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">‹<span class="main">(</span>cr_uint32 <span class="main">===&gt;</span> <span class="main">(⟷)</span><span class="main">)</span> even <span class="main">(</span><span class="keyword1">(dvd)</span> <span class="numeral">2</span> <span class="main">::</span> uint32 <span class="main">⇒</span> bool<span class="main">)</span>›</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> dvd_def<span class="main">)</span> <span class="operator">transfer_prover</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint32<span class="main">::</span> <span class="quoted">semiring_bits</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">bit_uint32</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹uint32 <span class="main">⇒</span> nat <span class="main">⇒</span> bool›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">bit</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">instance</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">transfer</span><span class="main">)</span>
    <span class="main">(</span><span class="operator">fact</span> bit_iff_odd even_iff_mod_2_eq_zero odd_iff_mod_2_eq_one odd_one bits_induct
       bits_div_0 bits_div_by_1 bits_mod_div_trivial even_succ_div_2
       even_mask_div_iff exp_div_exp_eq div_exp_eq mod_exp_eq mult_exp_mod_exp_eq
       div_exp_mod_exp_eq even_mult_exp_div_exp_iff<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint32 <span class="main">::</span> <span class="quoted">semiring_bit_shifts</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">push_bit_uint32</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹nat <span class="main">⇒</span> uint32 <span class="main">⇒</span> uint32›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">push_bit</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">drop_bit_uint32</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹nat <span class="main">⇒</span> uint32 <span class="main">⇒</span> uint32›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">drop_bit</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">take_bit_uint32</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹nat <span class="main">⇒</span> uint32 <span class="main">⇒</span> uint32›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">take_bit</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">transfer</span><span class="main">)</span>
  <span class="main">(</span><span class="operator">fact</span> push_bit_eq_mult drop_bit_eq_div take_bit_eq_mod<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint32 <span class="main">::</span> <span class="quoted">ring_bit_operations</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">not_uint32</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹uint32 <span class="main">⇒</span> uint32›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="keyword1">NOT</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">and_uint32</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹uint32 <span class="main">⇒</span> uint32 <span class="main">⇒</span> uint32›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">‹<span class="keyword1">(AND)</span>›</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">or_uint32</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹uint32 <span class="main">⇒</span> uint32 <span class="main">⇒</span> uint32›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">‹<span class="keyword1">(OR)</span>›</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">xor_uint32</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹uint32 <span class="main">⇒</span> uint32 <span class="main">⇒</span> uint32›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">‹<span class="keyword1">(XOR)</span>›</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">mask_uint32</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹nat <span class="main">⇒</span> uint32›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">mask</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">transfer</span><span class="main">)</span>
  <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bit_and_iff bit_or_iff bit_xor_iff bit_not_iff minus_eq_not_minus_1 mask_eq_decr_exp<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">‹take_bit <span class="free">n</span> <span class="free">a</span> <span class="main">=</span> <span class="free">a</span> <span class="keyword1">AND</span> mask <span class="free">n</span>›</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">a</span> <span class="main">::</span> <span class="quoted">uint32</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fact</span> take_bit_eq_mask<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">‹mask <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="main">=</span> push_bit <span class="free">n</span> <span class="main">(</span><span class="main">1</span> <span class="main">::</span> uint32<span class="main">)</span> <span class="keyword1">OR</span> mask <span class="free">n</span>›</span></span>
  <span class="quoted"><span class="quoted">‹mask <span class="main">0</span> <span class="main">=</span> <span class="main">(</span><span class="main">0</span> <span class="main">::</span> uint32<span class="main">)</span>›</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mask_Suc_exp push_bit_of_1<span class="main">)</span>

<span class="keyword1"><span class="command">instance</span></span> uint32 <span class="main">::</span> <span class="quoted">semiring_bit_syntax</span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Uint32-test_bit_uint32_transfer"><span class="command">lemma</span></span> test_bit_uint32_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">‹<span class="main">(</span>cr_uint32 <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> bit <span class="main">(!!)</span>›</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> test_bit_eq_bit <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Uint32-shiftl_uint32_transfer"><span class="command">lemma</span></span> shiftl_uint32_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">‹<span class="main">(</span>cr_uint32 <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> cr_uint32<span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">k</span> <span class="bound">n</span><span class="main">.</span> push_bit <span class="bound">n</span> <span class="bound">k</span><span class="main">)</span> <span class="main">(&lt;&lt;)</span>›</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> shiftl_eq_push_bit <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Uint32-shiftr_uint32_transfer"><span class="command">lemma</span></span> shiftr_uint32_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">‹<span class="main">(</span>cr_uint32 <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> cr_uint32<span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">k</span> <span class="bound">n</span><span class="main">.</span> drop_bit <span class="bound">n</span> <span class="bound">k</span><span class="main">)</span> <span class="main">(&gt;&gt;)</span>›</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> shiftr_eq_drop_bit <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint32 <span class="main">::</span> <span class="quoted">lsb</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">lsb_uint32</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹uint32 <span class="main">⇒</span> bool›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">lsb</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">transfer</span><span class="main">)</span>
  <span class="main">(</span><span class="operator">fact</span> lsb_odd<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint32 <span class="main">::</span> <span class="quoted">msb</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">msb_uint32</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹uint32 <span class="main">⇒</span> bool›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">msb</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint32 <span class="main">::</span> <span class="quoted">set_bit</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">set_bit_uint32</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹uint32 <span class="main">⇒</span> nat <span class="main">⇒</span> bool <span class="main">⇒</span> uint32›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">set_bit</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">standard</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">bit_simps</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint32 <span class="main">::</span> <span class="quoted">bit_comprehension</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">set_bits_uint32</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nat <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> uint32"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"set_bits"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">transfer</span><span class="main">)</span> <span class="main">(</span><span class="operator">fact</span> set_bits_bit_eq<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> bit_uint32.rep_eq lsb_uint32.rep_eq msb_uint32.rep_eq

<span class="keyword1"><span class="command">instantiation</span></span> uint32 <span class="main">::</span> <span class="quoted">equal</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">equal_uint32</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint32 <span class="main">⇒</span> uint32 <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"equal_class.equal"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> equal_eq<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> equal_uint32.rep_eq

<span class="keyword1"><span class="command">instantiation</span></span> uint32 <span class="main">::</span> <span class="quoted">size</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">size_uint32</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint32 <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"size"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> size_uint32.rep_eq                                                    

<span class="keyword1"><span class="command">lift_definition</span></span> sshiftr_uint32 <span class="main">::</span> <span class="quoted"><span class="quoted">"uint32 <span class="main">⇒</span> nat <span class="main">⇒</span> uint32"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">&gt;&gt;&gt;</span>"</span> 55<span class="main">)</span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">‹<span class="main">λ</span><span class="bound">w</span> <span class="bound">n</span><span class="main">.</span> signed_drop_bit <span class="bound">n</span> <span class="bound">w</span>›</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> uint32_of_int <span class="main">::</span> <span class="quoted"><span class="quoted">"int <span class="main">⇒</span> uint32"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"word_of_int"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint32_of_nat</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> uint32"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">uint32_of_nat</span> <span class="main">=</span> uint32_of_int <span class="main">∘</span> int"</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> int_of_uint32 <span class="main">::</span> <span class="quoted"><span class="quoted">"uint32 <span class="main">⇒</span> int"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"uint"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> nat_of_uint32 <span class="main">::</span> <span class="quoted"><span class="quoted">"uint32 <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"unat"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">integer_of_uint32</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint32 <span class="main">⇒</span> integer"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">integer_of_uint32</span> <span class="main">=</span> integer_of_int <span class="keyword1">o</span> int_of_uint32"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Use pretty numerals from integer for pretty printing›</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> integer.lifting <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> Uint32 <span class="main">::</span> <span class="quoted"><span class="quoted">"integer <span class="main">⇒</span> uint32"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"word_of_int"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1" id="Uint32-Rep_uint32_numeral"><span class="command">lemma</span></span> Rep_uint32_numeral <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Rep_uint32 <span class="main">(</span>numeral <span class="free">n</span><span class="main">)</span> <span class="main">=</span> numeral <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> one_uint32_def Abs_uint32_inverse numeral.simps plus_uint32_def<span class="main">)</span>

<span class="keyword1" id="Uint32-numeral_uint32_transfer"><span class="command">lemma</span></span> numeral_uint32_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>rel_fun <span class="main">(=)</span> cr_uint32<span class="main">)</span> numeral numeral"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cr_uint32_def<span class="main">)</span>

<span class="keyword1" id="Uint32-numeral_uint32"><span class="command">lemma</span></span> numeral_uint32 <span class="main">[</span><span class="operator">code_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"numeral <span class="free">n</span> <span class="main">=</span> Uint32 <span class="main">(</span>numeral <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Uint32-Rep_uint32_neg_numeral"><span class="command">lemma</span></span> Rep_uint32_neg_numeral <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Rep_uint32 <span class="main">(</span><span class="main">-</span> numeral <span class="free">n</span><span class="main">)</span> <span class="main">=</span> <span class="main">-</span> numeral <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> uminus_uint32_def<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_uint32_inverse<span class="main">)</span>

<span class="keyword1" id="Uint32-neg_numeral_uint32"><span class="command">lemma</span></span> neg_numeral_uint32 <span class="main">[</span><span class="operator">code_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">-</span> numeral <span class="free">n</span> <span class="main">=</span> Uint32 <span class="main">(</span><span class="main">-</span> numeral <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cr_uint32_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Uint32-Abs_uint32_numeral"><span class="command">lemma</span></span> Abs_uint32_numeral <span class="main">[</span><span class="operator">code_post</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Abs_uint32 <span class="main">(</span>numeral <span class="free">n</span><span class="main">)</span> <span class="main">=</span> numeral <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> one_uint32_def numeral.simps plus_uint32_def Abs_uint32_inverse<span class="main">)</span>

<span class="keyword1" id="Uint32-Abs_uint32_0"><span class="command">lemma</span></span> Abs_uint32_0 <span class="main">[</span><span class="operator">code_post</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Abs_uint32 <span class="main">0</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_uint32_def<span class="main">)</span>

<span class="keyword1" id="Uint32-Abs_uint32_1"><span class="command">lemma</span></span> Abs_uint32_1 <span class="main">[</span><span class="operator">code_post</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Abs_uint32 <span class="main">1</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> one_uint32_def<span class="main">)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Code setup›</span></span>

<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">code_module</span></span> Uint32 <span class="main">⇀</span> <span class="main">(</span>SML<span class="main">)</span>
<span class="quoted">‹(* Test that words can handle numbers between 0 and 31 *)
val _ = if 5 &lt;= Word.wordSize then () else raise (Fail ("wordSize less than 5"));

structure Uint32 : sig
  val set_bit : Word32.word -&gt; IntInf.int -&gt; bool -&gt; Word32.word
  val shiftl : Word32.word -&gt; IntInf.int -&gt; Word32.word
  val shiftr : Word32.word -&gt; IntInf.int -&gt; Word32.word
  val shiftr_signed : Word32.word -&gt; IntInf.int -&gt; Word32.word
  val test_bit : Word32.word -&gt; IntInf.int -&gt; bool
end = struct

fun set_bit x n b =
  let val mask = Word32.&lt;&lt; (0wx1, Word.fromLargeInt (IntInf.toLarge n))
  in if b then Word32.orb (x, mask)
     else Word32.andb (x, Word32.notb mask)
  end

fun shiftl x n =
  Word32.&lt;&lt; (x, Word.fromLargeInt (IntInf.toLarge n))

fun shiftr x n =
  Word32.&gt;&gt; (x, Word.fromLargeInt (IntInf.toLarge n))

fun shiftr_signed x n =
  Word32.~&gt;&gt; (x, Word.fromLargeInt (IntInf.toLarge n))

fun test_bit x n =
  Word32.andb (x, Word32.&lt;&lt; (0wx1, Word.fromLargeInt (IntInf.toLarge n))) &lt;&gt; Word32.fromInt 0

end; (* struct Uint32 *)›</span>
<span class="keyword1"><span class="command">code_reserved</span></span> SML Uint32

<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">code_module</span></span> Uint32 <span class="main">⇀</span> <span class="main">(</span>Haskell<span class="main">)</span>
 <span class="quoted">‹module Uint32(Int32, Word32) where

  import Data.Int(Int32)
  import Data.Word(Word32)›</span>
<span class="keyword1"><span class="command">code_reserved</span></span> Haskell Uint32

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  OCaml and Scala provide only signed 32bit numbers, so we use these and 
  implement sign-sensitive operations like comparisons manually.
›</span></span>
<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">code_module</span></span> <span class="quoted">"Uint32"</span> <span class="main">⇀</span> <span class="main">(</span>OCaml<span class="main">)</span>
<span class="quoted">‹module Uint32 : sig
  val less : int32 -&gt; int32 -&gt; bool
  val less_eq : int32 -&gt; int32 -&gt; bool
  val set_bit : int32 -&gt; Z.t -&gt; bool -&gt; int32
  val shiftl : int32 -&gt; Z.t -&gt; int32
  val shiftr : int32 -&gt; Z.t -&gt; int32
  val shiftr_signed : int32 -&gt; Z.t -&gt; int32
  val test_bit : int32 -&gt; Z.t -&gt; bool
end = struct

(* negative numbers have their highest bit set, 
   so they are greater than positive ones *)
let less x y =
  if Int32.compare x Int32.zero &lt; 0 then
    Int32.compare y Int32.zero &lt; 0 &amp;&amp; Int32.compare x y &lt; 0
  else Int32.compare y Int32.zero &lt; 0 || Int32.compare x y &lt; 0;;

let less_eq x y =
  if Int32.compare x Int32.zero &lt; 0 then
    Int32.compare y Int32.zero &lt; 0 &amp;&amp; Int32.compare x y &lt;= 0
  else Int32.compare y Int32.zero &lt; 0 || Int32.compare x y &lt;= 0;;

let set_bit x n b =
  let mask = Int32.shift_left Int32.one (Z.to_int n)
  in if b then Int32.logor x mask
     else Int32.logand x (Int32.lognot mask);;

let shiftl x n = Int32.shift_left x (Z.to_int n);;

let shiftr x n = Int32.shift_right_logical x (Z.to_int n);;

let shiftr_signed x n = Int32.shift_right x (Z.to_int n);;

let test_bit x n =
  Int32.compare 
    (Int32.logand x (Int32.shift_left Int32.one (Z.to_int n)))
    Int32.zero
  &lt;&gt; 0;;

end;; (*struct Uint32*)›</span>
<span class="keyword1"><span class="command">code_reserved</span></span> OCaml Uint32

<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">code_module</span></span> Uint32 <span class="main">⇀</span> <span class="main">(</span>Scala<span class="main">)</span>
<span class="quoted">‹object Uint32 {

def less(x: Int, y: Int) : Boolean =
  if (x &lt; 0) y &lt; 0 &amp;&amp; x &lt; y
  else y &lt; 0 || x &lt; y

def less_eq(x: Int, y: Int) : Boolean =
  if (x &lt; 0) y &lt; 0 &amp;&amp; x &lt;= y
  else y &lt; 0 || x &lt;= y

def set_bit(x: Int, n: BigInt, b: Boolean) : Int =
  if (b)
    x | (1 &lt;&lt; n.intValue)
  else
    x &amp; (1 &lt;&lt; n.intValue).unary_~

def shiftl(x: Int, n: BigInt) : Int = x &lt;&lt; n.intValue

def shiftr(x: Int, n: BigInt) : Int = x &gt;&gt;&gt; n.intValue

def shiftr_signed(x: Int, n: BigInt) : Int = x &gt;&gt; n.intValue

def test_bit(x: Int, n: BigInt) : Boolean =
  (x &amp; (1 &lt;&lt; n.intValue)) != 0

} /* object Uint32 */›</span>
<span class="keyword1"><span class="command">code_reserved</span></span> Scala Uint32

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  OCaml's conversion from Big\_int to int32 demands that the value fits int a signed 32-bit integer.
  The following justifies the implementation.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">Uint32_signed</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"integer <span class="main">⇒</span> uint32"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">Uint32_signed</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">&lt;</span> <span class="main">-</span><span class="main">(</span><span class="numeral">0x80000000</span><span class="main">)</span> <span class="main">∨</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">≥</span> <span class="numeral">0x80000000</span> <span class="keyword1">then</span> undefined Uint32 <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="keyword1">else</span> Uint32 <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Uint32-Uint32_code"><span class="command">lemma</span></span> Uint32_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Uint32 <span class="free">i</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">let</span> <span class="bound">i'</span> <span class="main">=</span> <span class="free">i</span> <span class="keyword1">AND</span> <span class="numeral">0xFFFFFFFF</span>
   <span class="keyword1">in</span> <span class="keyword1">if</span> bit <span class="bound">i'</span> <span class="numeral">31</span> <span class="keyword1">then</span> Uint32_signed <span class="main">(</span><span class="bound">i'</span> <span class="main">-</span> <span class="numeral">0x100000000</span><span class="main">)</span> <span class="keyword1">else</span> Uint32_signed <span class="bound">i'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> undefined_transfer integer.lifting <span class="keyword1"><span class="command">unfolding</span></span> Uint32_signed_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> word_of_int_via_signed<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> shiftl_eq_push_bit push_bit_of_1 mask_eq_exp_minus_1 word_of_int_via_signed <span class="quasi_keyword">cong</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> if_cong<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Uint32-Uint32_signed_code"><span class="command">lemma</span></span> Uint32_signed_code <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">abstract</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Rep_uint32 <span class="main">(</span>Uint32_signed <span class="free">i</span><span class="main">)</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">i</span> <span class="main">&lt;</span> <span class="main">-</span><span class="main">(</span><span class="numeral">0x80000000</span><span class="main">)</span> <span class="main">∨</span> <span class="free">i</span> <span class="main">≥</span> <span class="numeral">0x80000000</span> <span class="keyword1">then</span> Rep_uint32 <span class="main">(</span>undefined Uint32 <span class="free">i</span><span class="main">)</span> <span class="keyword1">else</span> word_of_int <span class="main">(</span>int_of_integer_symbolic <span class="free">i</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> Uint32_signed_def Uint32_def int_of_integer_symbolic_def word_of_integer_def
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_uint32_inverse<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Avoid <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Abs_uint32</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> in generated code, use <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">Rep_uint32'</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> instead. 
  The symbolic implementations for code\_simp use <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Rep_uint32</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.

  The new destructor <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">Rep_uint32'</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is executable.
  As the simplifier is given the [code abstract] equations literally, 
  we cannot implement <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Rep_uint32</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> directly, because that makes code\_simp loop.

  If code generation raises Match, some equation probably contains <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Rep_uint32</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> 
  ([code abstract] equations for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">uint32</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> may use <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Rep_uint32</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> because
  these instances will be folded away.)

  To convert <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="numeral"><span class="numeral">32</span></span> word"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> values into <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">uint32</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, use <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">Abs_uint32'</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">Rep_uint32'</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Rep_uint32'</span> <span class="main">=</span> Rep_uint32"</span></span>

<span class="keyword1" id="Uint32-Rep_uint32'_transfer"><span class="command">lemma</span></span> Rep_uint32'_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"rel_fun cr_uint32 <span class="main">(=)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">)</span> Rep_uint32'"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> Rep_uint32'_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> uint32.rep_transfer<span class="main">)</span>

<span class="keyword1" id="Uint32-Rep_uint32'_code"><span class="command">lemma</span></span> Rep_uint32'_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Rep_uint32' <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">BITS</span> <span class="bound">n</span><span class="main">.</span> bit <span class="free">x</span> <span class="bound">n</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_bits_bit_eq<span class="main">)</span> 

<span class="keyword1"><span class="command">lift_definition</span></span> Abs_uint32' <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="numeral">32</span> word <span class="main">⇒</span> uint32"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span> <span class="main">::</span> <span class="numeral">32</span> word<span class="main">.</span> <span class="bound">x</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1" id="Uint32-Abs_uint32'_code"><span class="command">lemma</span></span> Abs_uint32'_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Abs_uint32' <span class="free">x</span> <span class="main">=</span> Uint32 <span class="main">(</span>integer_of_int <span class="main">(</span>uint <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">including</span></span> integer.lifting <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">"term_of_class.term_of <span class="main">::</span> uint32 <span class="main">⇒</span> <span class="main">_</span>"</span></span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Uint32-term_of_uint32_code"><span class="command">lemma</span></span> term_of_uint32_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">TR</span> <span class="main">≡</span> typerep.Typerep"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">bit0</span> <span class="main">≡</span> <span class="keyword1">STR</span> <span class="inner_quoted">''Numeral_Type.bit0''</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"term_of_class.term_of <span class="free">x</span> <span class="main">=</span> 
   Code_Evaluation.App <span class="main">(</span>Code_Evaluation.Const <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Uint32.uint32.Abs_uint32''</span><span class="main">)</span> <span class="main">(</span><span class="free">TR</span> <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''fun''</span><span class="main">)</span> <span class="main">[</span><span class="free">TR</span> <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Word.word''</span><span class="main">)</span> <span class="main">[</span><span class="free">TR</span> <span class="free">bit0</span> <span class="main">[</span><span class="free">TR</span> <span class="free">bit0</span> <span class="main">[</span><span class="free">TR</span> <span class="free">bit0</span> <span class="main">[</span><span class="free">TR</span> <span class="free">bit0</span> <span class="main">[</span><span class="free">TR</span> <span class="free">bit0</span> <span class="main">[</span><span class="free">TR</span> <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Numeral_Type.num1''</span><span class="main">)</span> <span class="main">[]</span><span class="main">]</span><span class="main">]</span><span class="main">]</span><span class="main">]</span><span class="main">]</span><span class="main">]</span><span class="main">,</span> <span class="free">TR</span> <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Uint32.uint32''</span><span class="main">)</span> <span class="main">[]</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
       <span class="main">(</span>term_of_class.term_of <span class="main">(</span>Rep_uint32' <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> term_of_anything<span class="main">)</span>

<span class="keyword1"><span class="command">code_printing</span></span>
  <span class="keyword2"><span class="keyword">type_constructor</span></span> uint32 <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Word32.word"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"Uint32.Word32"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"int32"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"Int"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Eval<span class="main">)</span> <span class="quoted">"Word32.word"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">Uint32</span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Word32.fromLargeInt (IntInf.toLarge _)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"(Prelude.fromInteger _ :: Uint32.Word32)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell_Quickcheck<span class="main">)</span> <span class="quoted">"(Prelude.fromInteger (Prelude.toInteger _) :: Uint32.Word32)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"_.intValue"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">Uint32_signed</span> <span class="main">⇀</span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Z.to'_int32"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">::</span> uint32"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"(Word32.fromInt 0)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"(0 :: Uint32.Word32)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Int32.zero"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"0"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">::</span> uint32"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"(Word32.fromInt 1)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"(1 :: Uint32.Word32)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Int32.one"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"1"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"plus <span class="main">::</span> uint32 <span class="main">⇒</span> <span class="main">_</span> "</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Word32.+ ((_), (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 6 <span class="quoted">"+"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Int32.add"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 7 <span class="quoted">"+"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"uminus <span class="main">::</span> uint32 <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Word32.~"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"negate"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Int32.neg"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"!(- _)"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"minus <span class="main">::</span> uint32 <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Word32.- ((_), (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 6 <span class="quoted">"-"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Int32.sub"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 7 <span class="quoted">"-"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"times <span class="main">::</span> uint32 <span class="main">⇒</span> <span class="main">_</span> <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Word32.* ((_), (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 7 <span class="quoted">"*"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Int32.mul"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 8 <span class="quoted">"*"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"HOL.equal <span class="main">::</span> uint32 <span class="main">⇒</span> <span class="main">_</span> <span class="main">⇒</span> bool"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"!((_ : Word32.word) = _)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="keyword2"><span class="keyword">infix</span></span> 4 <span class="quoted">"=="</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"(Int32.compare _ _ = 0)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 5 <span class="quoted">"=="</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">class_instance</span></span> uint32 <span class="main">::</span> equal <span class="main">⇀</span>
  <span class="main">(</span>Haskell<span class="main">)</span> -
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"less_eq <span class="main">::</span> uint32 <span class="main">⇒</span> <span class="main">_</span> <span class="main">⇒</span> bool"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Word32.&lt;= ((_), (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="keyword2"><span class="keyword">infix</span></span> 4 <span class="quoted">"&lt;="</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Uint32.less'_eq"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"Uint32.less'_eq"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"less <span class="main">::</span> uint32 <span class="main">⇒</span> <span class="main">_</span> <span class="main">⇒</span> bool"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Word32.&lt; ((_), (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="keyword2"><span class="keyword">infix</span></span> 4 <span class="quoted">"&lt;"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Uint32.less"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"Uint32.less"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">NOT</span> <span class="main">::</span> uint32 <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Word32.notb"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"Data'_Bits.complement"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Int32.lognot"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"_.unary'_~"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">(AND)</span> <span class="main">::</span> uint32 <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Word32.andb ((_),/ (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 7 <span class="quoted">"Data_Bits..&amp;."</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Int32.logand"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 3 <span class="quoted">"&amp;"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">(OR)</span> <span class="main">::</span> uint32 <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Word32.orb ((_),/ (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 5 <span class="quoted">"Data_Bits..|."</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Int32.logor"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 1 <span class="quoted">"|"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">(XOR)</span> <span class="main">::</span> uint32 <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Word32.xorb ((_),/ (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"Data'_Bits.xor"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Int32.logxor"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 2 <span class="quoted">"^"</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint32_divmod</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint32 <span class="main">⇒</span> uint32 <span class="main">⇒</span> uint32 <span class="main">×</span> uint32"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">uint32_divmod</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">(</span>undefined <span class="main">(</span><span class="keyword1">(div)</span> <span class="main">::</span> uint32 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="main">0</span> <span class="main">::</span> uint32<span class="main">)</span><span class="main">,</span> undefined <span class="main">(</span><span class="keyword1">(mod)</span> <span class="main">::</span> uint32 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="main">0</span> <span class="main">::</span> uint32<span class="main">)</span><span class="main">)</span> 
  <span class="keyword1">else</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">div</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">mod</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint32_div</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint32 <span class="main">⇒</span> uint32 <span class="main">⇒</span> uint32"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">uint32_div</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> fst <span class="main">(</span>uint32_divmod <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint32_mod</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint32 <span class="main">⇒</span> uint32 <span class="main">⇒</span> uint32"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">uint32_mod</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> snd <span class="main">(</span>uint32_divmod <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Uint32-div_uint32_code"><span class="command">lemma</span></span> div_uint32_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="keyword1">div</span> <span class="free">y</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">y</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> uint32_div <span class="free">x</span> <span class="free">y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">including</span></span> undefined_transfer <span class="keyword1"><span class="command">unfolding</span></span> uint32_divmod_def uint32_div_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> word_div_def<span class="main">)</span>

<span class="keyword1" id="Uint32-mod_uint32_code"><span class="command">lemma</span></span> mod_uint32_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="keyword1">mod</span> <span class="free">y</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">y</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="free">x</span> <span class="keyword1">else</span> uint32_mod <span class="free">x</span> <span class="free">y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">including</span></span> undefined_transfer <span class="keyword1"><span class="command">unfolding</span></span> uint32_mod_def uint32_divmod_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> word_mod_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint32_sdiv</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint32 <span class="main">⇒</span> uint32 <span class="main">⇒</span> uint32"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">uint32_sdiv</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span>
   <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> undefined <span class="main">(</span><span class="keyword1">(div)</span> <span class="main">::</span> uint32 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="main">0</span> <span class="main">::</span> uint32<span class="main">)</span>
    <span class="keyword1">else</span> Abs_uint32 <span class="main">(</span>Rep_uint32 <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">sdiv</span> Rep_uint32 <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">div0_uint32</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint32 <span class="main">⇒</span> uint32"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">div0_uint32</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> undefined <span class="main">(</span><span class="keyword1">(div)</span> <span class="main">::</span> uint32 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="main">0</span> <span class="main">::</span> uint32<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">abort</span><span class="main"><span class="main">:</span></span> <span class="quoted">div0_uint32</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">mod0_uint32</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint32 <span class="main">⇒</span> uint32"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">mod0_uint32</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> undefined <span class="main">(</span><span class="keyword1">(mod)</span> <span class="main">::</span> uint32 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="main">0</span> <span class="main">::</span> uint32<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">abort</span><span class="main"><span class="main">:</span></span> <span class="quoted">mod0_uint32</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Uint32-uint32_divmod_code"><span class="command">lemma</span></span> uint32_divmod_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"uint32_divmod <span class="free">x</span> <span class="free">y</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="numeral">0x80000000</span> <span class="main">≤</span> <span class="free">y</span> <span class="keyword1">then</span> <span class="keyword1">if</span> <span class="free">x</span> <span class="main">&lt;</span> <span class="free">y</span> <span class="keyword1">then</span> <span class="main">(</span><span class="main">0</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">(</span><span class="main">1</span><span class="main">,</span> <span class="free">x</span> <span class="main">-</span> <span class="free">y</span><span class="main">)</span>
   <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="free">y</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">(</span>div0_uint32 <span class="free">x</span><span class="main">,</span> mod0_uint32 <span class="free">x</span><span class="main">)</span>
   <span class="keyword1">else</span> <span class="keyword1">let</span> <span class="bound">q</span> <span class="main">=</span> <span class="main">(</span>uint32_sdiv <span class="main">(</span>drop_bit <span class="main">1</span> <span class="free">x</span><span class="main">)</span> <span class="free">y</span><span class="main">)</span> <span class="main">&lt;&lt;</span> <span class="main">1</span><span class="main">;</span>
            <span class="bound">r</span> <span class="main">=</span> <span class="free">x</span> <span class="main">-</span> <span class="bound">q</span> <span class="main">*</span> <span class="free">y</span>
        <span class="keyword1">in</span> <span class="keyword1">if</span> <span class="bound">r</span> <span class="main">≥</span> <span class="free">y</span> <span class="keyword1">then</span> <span class="main">(</span><span class="bound">q</span> <span class="main">+</span> <span class="main">1</span><span class="main">,</span> <span class="bound">r</span> <span class="main">-</span> <span class="free">y</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">(</span><span class="bound">q</span><span class="main">,</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> undefined_transfer <span class="keyword1"><span class="command">unfolding</span></span> uint32_divmod_def uint32_sdiv_def div0_uint32_def mod0_uint32_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> divmod_via_sdivmod shiftr_eq_drop_bit shiftl_eq_push_bit <span class="dynamic"><span class="dynamic">ac_simps</span></span><span class="main">)</span>

<span class="keyword1" id="Uint32-uint32_sdiv_code"><span class="command">lemma</span></span> uint32_sdiv_code <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">abstract</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Rep_uint32 <span class="main">(</span>uint32_sdiv <span class="free">x</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span>
   <span class="main">(</span><span class="keyword1">if</span> <span class="free">y</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> Rep_uint32 <span class="main">(</span>undefined <span class="main">(</span><span class="keyword1">(div)</span> <span class="main">::</span> uint32 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free">x</span> <span class="main">(</span><span class="main">0</span> <span class="main">::</span> uint32<span class="main">)</span><span class="main">)</span>
    <span class="keyword1">else</span> Rep_uint32 <span class="free">x</span> <span class="keyword1">sdiv</span> Rep_uint32 <span class="free">y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> uint32_sdiv_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_uint32_inverse<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Note that we only need a translation for signed division, but not for the remainder
  because <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> uint32_divmod_code<span class="antiquote"><span class="antiquote">}</span></span></span></span> computes both with division only.
›</span></span>

<span class="keyword1"><span class="command">code_printing</span></span>
  <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint32_div</span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Word32.div ((_), (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"Prelude.div"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint32_mod</span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Word32.mod ((_), (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"Prelude.mod"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint32_divmod</span> <span class="main">⇀</span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"divmod"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint32_sdiv</span> <span class="main">⇀</span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Int32.div"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"_ '/ _"</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint32_test_bit</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint32 <span class="main">⇒</span> integer <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">uint32_test_bit</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">∨</span> <span class="numeral">31</span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">then</span> undefined <span class="main">(</span>bit <span class="main">::</span> uint32 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span>
   <span class="keyword1">else</span> bit <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span>nat_of_integer <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Uint32-test_bit_uint32_code"><span class="command">lemma</span></span> test_bit_uint32_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"bit <span class="free">x</span> <span class="free">n</span> <span class="main">⟷</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="numeral">32</span> <span class="main">∧</span> uint32_test_bit <span class="free">x</span> <span class="main">(</span>integer_of_nat <span class="free">n</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> undefined_transfer integer.lifting <span class="keyword1"><span class="command">unfolding</span></span> uint32_test_bit_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="Uint32-uint32_test_bit_code"><span class="command">lemma</span></span> uint32_test_bit_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"uint32_test_bit <span class="free">w</span> <span class="free">n</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">∨</span> <span class="numeral">31</span> <span class="main">&lt;</span> <span class="free">n</span> <span class="keyword1">then</span> undefined <span class="main">(</span>bit <span class="main">::</span> uint32 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free">w</span> <span class="free">n</span> <span class="keyword1">else</span> bit <span class="main">(</span>Rep_uint32 <span class="free">w</span><span class="main">)</span> <span class="main">(</span>nat_of_integer <span class="free">n</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> uint32_test_bit_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bit_uint32.rep_eq<span class="main">)</span>

<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint32_test_bit</span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Uint32.test'_bit"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"Data'_Bits.testBitBounded"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Uint32.test'_bit"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"Uint32.test'_bit"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Eval<span class="main">)</span> <span class="quoted">"(fn w =&gt; fn n =&gt; if n &lt; 0 orelse 32 &lt;= n then raise (Fail \"argument to uint32'_test'_bit out of bounds\") else Uint32.test'_bit w n)"</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint32_set_bit</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint32 <span class="main">⇒</span> integer <span class="main">⇒</span> bool <span class="main">⇒</span> uint32"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">uint32_set_bit</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">∨</span> <span class="numeral">31</span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">then</span> undefined <span class="main">(</span>set_bit <span class="main">::</span> uint32 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span>
   <span class="keyword1">else</span> set_bit <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span>nat_of_integer <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Uint32-set_bit_uint32_code"><span class="command">lemma</span></span> set_bit_uint32_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"set_bit <span class="free">x</span> <span class="free">n</span> <span class="free">b</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="numeral">32</span> <span class="keyword1">then</span> uint32_set_bit <span class="free">x</span> <span class="main">(</span>integer_of_nat <span class="free">n</span><span class="main">)</span> <span class="free">b</span> <span class="keyword1">else</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">including</span></span> undefined_transfer integer.lifting <span class="keyword1"><span class="command">unfolding</span></span> uint32_set_bit_def
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">transfer</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> conj_cong <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_less set_bit_beyond word_size<span class="main">)</span>

<span class="keyword1" id="Uint32-uint32_set_bit_code"><span class="command">lemma</span></span> uint32_set_bit_code <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">abstract</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Rep_uint32 <span class="main">(</span>uint32_set_bit <span class="free">w</span> <span class="free">n</span> <span class="free">b</span><span class="main">)</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">∨</span> <span class="numeral">31</span> <span class="main">&lt;</span> <span class="free">n</span> <span class="keyword1">then</span> Rep_uint32 <span class="main">(</span>undefined <span class="main">(</span>set_bit <span class="main">::</span> uint32 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free">w</span> <span class="free">n</span> <span class="free">b</span><span class="main">)</span>
   <span class="keyword1">else</span> set_bit <span class="main">(</span>Rep_uint32 <span class="free">w</span><span class="main">)</span> <span class="main">(</span>nat_of_integer <span class="free">n</span><span class="main">)</span> <span class="free">b</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">including</span></span> undefined_transfer <span class="keyword1"><span class="command">unfolding</span></span> uint32_set_bit_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint32_set_bit</span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Uint32.set'_bit"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"Data'_Bits.setBitBounded"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Uint32.set'_bit"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"Uint32.set'_bit"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Eval<span class="main">)</span> <span class="quoted">"(fn w =&gt; fn n =&gt; fn b =&gt; if n &lt; 0 orelse 32 &lt;= n then raise (Fail \"argument to uint32'_set'_bit out of bounds\") else Uint32.set'_bit x n b)"</span>

<span class="keyword1"><span class="command">lift_definition</span></span> uint32_set_bits <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nat <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> uint32 <span class="main">⇒</span> nat <span class="main">⇒</span> uint32"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">set_bits_aux</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1" id="Uint32-uint32_set_bits_code"><span class="command">lemma</span></span> uint32_set_bits_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"uint32_set_bits <span class="free">f</span> <span class="free">w</span> <span class="free">n</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="free">w</span> 
   <span class="keyword1">else</span> <span class="keyword1">let</span> <span class="bound">n'</span> <span class="main">=</span> <span class="free">n</span> <span class="main">-</span> <span class="main">1</span> <span class="keyword1">in</span> uint32_set_bits <span class="free">f</span> <span class="main">(</span>push_bit <span class="main">1</span> <span class="free">w</span> <span class="keyword1">OR</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">f</span> <span class="bound">n'</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span> <span class="bound">n'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">transfer</span> <span class="quasi_keyword">fixing</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> shiftl_eq_push_bit<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Uint32-set_bits_uint32"><span class="command">lemma</span></span> set_bits_uint32 <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">BITS</span> <span class="bound">n</span><span class="main">.</span> <span class="free">f</span> <span class="bound">n</span><span class="main">)</span> <span class="main">=</span> uint32_set_bits <span class="free">f</span> <span class="main">0</span> <span class="numeral">32</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_bits_conv_set_bits_aux<span class="main">)</span>


<span class="keyword1" id="Uint32-lsb_code"><span class="command">lemma</span></span> lsb_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span> <span class="main">::</span> <span class="quoted">uint32</span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lsb <span class="free">x</span> <span class="main">⟷</span> bit <span class="free">x</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lsb_word_eq<span class="main">)</span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint32_shiftl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint32 <span class="main">⇒</span> integer <span class="main">⇒</span> uint32"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">uint32_shiftl</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">∨</span> <span class="numeral">32</span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">then</span> undefined <span class="main">(</span>push_bit <span class="main">::</span> nat <span class="main">⇒</span> uint32 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">else</span> push_bit <span class="main">(</span>nat_of_integer <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Uint32-shiftl_uint32_code"><span class="command">lemma</span></span> shiftl_uint32_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"push_bit <span class="free">n</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="numeral">32</span> <span class="keyword1">then</span> uint32_shiftl <span class="free">x</span> <span class="main">(</span>integer_of_nat <span class="free">n</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> undefined_transfer integer.lifting <span class="keyword1"><span class="command">unfolding</span></span> uint32_shiftl_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Uint32-uint32_shiftl_code"><span class="command">lemma</span></span> uint32_shiftl_code <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">abstract</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Rep_uint32 <span class="main">(</span>uint32_shiftl <span class="free">w</span> <span class="free">n</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">∨</span> <span class="numeral">32</span> <span class="main">≤</span> <span class="free">n</span> <span class="keyword1">then</span> Rep_uint32 <span class="main">(</span>undefined <span class="main">(</span>push_bit <span class="main">::</span> nat <span class="main">⇒</span> uint32 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free">w</span> <span class="free">n</span><span class="main">)</span> <span class="keyword1">else</span> push_bit <span class="main">(</span>nat_of_integer <span class="free">n</span><span class="main">)</span> <span class="main">(</span>Rep_uint32 <span class="free">w</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> undefined_transfer <span class="keyword1"><span class="command">unfolding</span></span> uint32_shiftl_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> shiftl_eq_push_bit<span class="main">)</span>

<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint32_shiftl</span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Uint32.shiftl"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"Data'_Bits.shiftlBounded"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Uint32.shiftl"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"Uint32.shiftl"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Eval<span class="main">)</span> <span class="quoted">"(fn x =&gt; fn i =&gt; if i &lt; 0 orelse i &gt;= 32 then raise Fail \"argument to uint32'_shiftl out of bounds\" else Uint32.shiftl x i)"</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint32_shiftr</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint32 <span class="main">⇒</span> integer <span class="main">⇒</span> uint32"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">uint32_shiftr</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">∨</span> <span class="numeral">32</span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">then</span> undefined <span class="main">(</span>drop_bit <span class="main">::</span> nat <span class="main">⇒</span> uint32 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">else</span> drop_bit <span class="main">(</span>nat_of_integer <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Uint32-shiftr_uint32_code"><span class="command">lemma</span></span> shiftr_uint32_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"drop_bit <span class="free">n</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="numeral">32</span> <span class="keyword1">then</span> uint32_shiftr <span class="free">x</span> <span class="main">(</span>integer_of_nat <span class="free">n</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> undefined_transfer integer.lifting <span class="keyword1"><span class="command">unfolding</span></span> uint32_shiftr_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Uint32-uint32_shiftr_code"><span class="command">lemma</span></span> uint32_shiftr_code <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">abstract</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Rep_uint32 <span class="main">(</span>uint32_shiftr <span class="free">w</span> <span class="free">n</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">∨</span> <span class="numeral">32</span> <span class="main">≤</span> <span class="free">n</span> <span class="keyword1">then</span> Rep_uint32 <span class="main">(</span>undefined <span class="main">(</span>drop_bit <span class="main">::</span> nat <span class="main">⇒</span> uint32 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free">w</span> <span class="free">n</span><span class="main">)</span> <span class="keyword1">else</span> drop_bit <span class="main">(</span>nat_of_integer <span class="free">n</span><span class="main">)</span> <span class="main">(</span>Rep_uint32 <span class="free">w</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> undefined_transfer <span class="keyword1"><span class="command">unfolding</span></span> uint32_shiftr_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint32_shiftr</span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Uint32.shiftr"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"Data'_Bits.shiftrBounded"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Uint32.shiftr"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"Uint32.shiftr"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Eval<span class="main">)</span> <span class="quoted">"(fn x =&gt; fn i =&gt; if i &lt; 0 orelse i &gt;= 32 then raise Fail \"argument to uint32'_shiftr out of bounds\" else Uint32.shiftr x i)"</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint32_sshiftr</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint32 <span class="main">⇒</span> integer <span class="main">⇒</span> uint32"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">uint32_sshiftr</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">∨</span> <span class="numeral">32</span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">then</span> undefined sshiftr_uint32 <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">else</span> sshiftr_uint32 <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span>nat_of_integer <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Uint32-sshiftr_uint32_code"><span class="command">lemma</span></span> sshiftr_uint32_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">&gt;&gt;&gt;</span> <span class="free">n</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="numeral">32</span> <span class="keyword1">then</span> uint32_sshiftr <span class="free">x</span> <span class="main">(</span>integer_of_nat <span class="free">n</span><span class="main">)</span> <span class="keyword1">else</span> <span class="keyword1">if</span> bit <span class="free">x</span> <span class="numeral">31</span> <span class="keyword1">then</span> <span class="main">-</span> <span class="main">1</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> undefined_transfer integer.lifting <span class="keyword1"><span class="command">unfolding</span></span> uint32_sshiftr_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_less signed_drop_bit_beyond<span class="main">)</span>

<span class="keyword1" id="Uint32-uint32_sshiftr_code"><span class="command">lemma</span></span> uint32_sshiftr_code <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">abstract</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Rep_uint32 <span class="main">(</span>uint32_sshiftr <span class="free">w</span> <span class="free">n</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">∨</span> <span class="numeral">32</span> <span class="main">≤</span> <span class="free">n</span> <span class="keyword1">then</span> Rep_uint32 <span class="main">(</span>undefined sshiftr_uint32 <span class="free">w</span> <span class="free">n</span><span class="main">)</span> <span class="keyword1">else</span> signed_drop_bit <span class="main">(</span>nat_of_integer <span class="free">n</span><span class="main">)</span> <span class="main">(</span>Rep_uint32 <span class="free">w</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">including</span></span> undefined_transfer <span class="keyword1"><span class="command">unfolding</span></span> uint32_sshiftr_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint32_sshiftr</span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Uint32.shiftr'_signed"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> 
    <span class="quoted">"(Prelude.fromInteger (Prelude.toInteger (Data'_Bits.shiftrBounded (Prelude.fromInteger (Prelude.toInteger _) :: Uint32.Int32) _)) :: Uint32.Word32)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Uint32.shiftr'_signed"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"Uint32.shiftr'_signed"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Eval<span class="main">)</span> <span class="quoted">"(fn x =&gt; fn i =&gt; if i &lt; 0 orelse i &gt;= 32 then raise Fail \"argument to uint32'_shiftr'_signed out of bounds\" else Uint32.shiftr'_signed x i)"</span>

<span class="keyword1" id="Uint32-uint32_msb_test_bit"><span class="command">lemma</span></span> uint32_msb_test_bit<span class="main">:</span> <span class="quoted"><span class="quoted">"msb <span class="free">x</span> <span class="main">⟷</span> bit <span class="main">(</span><span class="free">x</span> <span class="main">::</span> uint32<span class="main">)</span> <span class="numeral">31</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> msb_word_iff_bit<span class="main">)</span>

<span class="keyword1" id="Uint32-msb_uint32_code"><span class="command">lemma</span></span> msb_uint32_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"msb <span class="free">x</span> <span class="main">⟷</span> uint32_test_bit <span class="free">x</span> <span class="numeral">31</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> uint32_test_bit_def uint32_msb_test_bit<span class="main">)</span>

<span class="keyword1" id="Uint32-uint32_of_int_code"><span class="command">lemma</span></span> uint32_of_int_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"uint32_of_int <span class="free">i</span> <span class="main">=</span> Uint32 <span class="main">(</span>integer_of_int <span class="free">i</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">including</span></span> integer.lifting <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Uint32-int_of_uint32_code"><span class="command">lemma</span></span> int_of_uint32_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"int_of_uint32 <span class="free">x</span> <span class="main">=</span> int_of_integer <span class="main">(</span>integer_of_uint32 <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> integer_of_uint32_def<span class="main">)</span>

<span class="keyword1" id="Uint32-nat_of_uint32_code"><span class="command">lemma</span></span> nat_of_uint32_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"nat_of_uint32 <span class="free">x</span> <span class="main">=</span> nat_of_integer <span class="main">(</span>integer_of_uint32 <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> integer_of_uint32_def <span class="keyword1"><span class="command">including</span></span> integer.lifting <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">integer_of_uint32_signed</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint32 <span class="main">⇒</span> integer"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">integer_of_uint32_signed</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> bit <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="numeral">31</span> <span class="keyword1">then</span> undefined integer_of_uint32 <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">else</span> integer_of_uint32 <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Uint32-integer_of_uint32_signed_code"><span class="command">lemma</span></span> integer_of_uint32_signed_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"integer_of_uint32_signed <span class="free">n</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> bit <span class="free">n</span> <span class="numeral">31</span> <span class="keyword1">then</span> undefined integer_of_uint32 <span class="free">n</span> <span class="keyword1">else</span> integer_of_int <span class="main">(</span>uint <span class="main">(</span>Rep_uint32' <span class="free">n</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> integer_of_uint32_signed_def integer_of_uint32_def
<span class="keyword1"><span class="command">including</span></span> undefined_transfer <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Uint32-integer_of_uint32_code"><span class="command">lemma</span></span> integer_of_uint32_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"integer_of_uint32 <span class="free">n</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> bit <span class="free">n</span> <span class="numeral">31</span> <span class="keyword1">then</span> integer_of_uint32_signed <span class="main">(</span><span class="free">n</span> <span class="keyword1">AND</span> <span class="numeral">0x7FFFFFFF</span><span class="main">)</span> <span class="keyword1">OR</span> <span class="numeral">0x80000000</span> <span class="keyword1">else</span> integer_of_uint32_signed <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="numeral">0x7FFFFFFF</span> <span class="main">::</span> uint32<span class="main">)</span> <span class="main">=</span> mask <span class="numeral">31</span>›</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mask_eq_exp_minus_1<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">‹<span class="free">n</span> <span class="keyword1">AND</span> <span class="numeral">0x7FFFFFFF</span> <span class="main">=</span> take_bit <span class="numeral">31</span> <span class="free">n</span>›</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> take_bit_eq_mask<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> **<span class="main">:</span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="numeral">0x80000000</span> <span class="main">::</span> int<span class="main">)</span> <span class="main">=</span> <span class="numeral">2</span> <span class="main">^</span> <span class="numeral">31</span>›</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> integer_of_uint32_def integer_of_uint32_signed_def o_def *
    <span class="keyword1"><span class="command">including</span></span> undefined_transfer integer.lifting
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> bit_eqI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> test_bit_eq_bit bit_or_iff bit_take_bit_iff bit_uint_iff<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> bit_exp_iff bit_or_iff **<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">code_printing</span></span>
  <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"integer_of_uint32"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"IntInf.fromLarge (Word32.toLargeInt _) : IntInf.int"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"Prelude.toInteger"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"integer_of_uint32_signed"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Z.of'_int32"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"BigInt"</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Quickcheck setup›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint32_of_natural</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"natural <span class="main">⇒</span> uint32"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">uint32_of_natural</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≡</span> Uint32 <span class="main">(</span>integer_of_natural <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint32 <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">{</span>random<span class="main">,</span> exhaustive<span class="main">,</span> full_exhaustive<span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">random_uint32</span></span> <span class="main">≡</span> qc_random_cnv uint32_of_natural"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">exhaustive_uint32</span></span> <span class="main">≡</span> qc_exhaustive_cnv uint32_of_natural"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">full_exhaustive_uint32</span></span> <span class="main">≡</span> qc_full_exhaustive_cnv uint32_of_natural"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint32 <span class="main">::</span> <span class="quoted">narrowing</span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> quickcheck_narrowing_samples
  <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">i</span><span class="main">.</span> <span class="keyword1">let</span> <span class="bound">x</span> <span class="main">=</span> Uint32 <span class="bound">i</span> <span class="keyword1">in</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="numeral">0xFFFFFFFF</span> <span class="main">-</span> <span class="bound">x</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span>"</span></span>
  <span class="quoted"><span class="quoted">"Typerep.Typerep <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Uint32.uint32''</span><span class="main">)</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">narrowing_uint32</span></span> <span class="free"><span class="bound"><span class="entity">d</span></span></span> <span class="main">=</span> qc_narrowing_drawn_from <span class="main">(</span>narrowing_samples <span class="free"><span class="bound"><span class="entity">d</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">d</span></span></span>"</span></span>
<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">"partial_term_of <span class="main">::</span> uint32 itself <span class="main">⇒</span> <span class="main">_</span>"</span></span><span class="main">]</span><span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> partial_term_of_uint32 <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> partial_term_of_code

<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">no_notation</span></span> sshiftr_uint32 <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">&gt;&gt;&gt;</span>"</span> 55<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Uint16">
<div class="head">
<h1>Theory Uint16</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Uint16.thy
    Author:     Andreas Lochbihler, ETH Zurich
*)</span>

<span class="keyword1"><span class="command">chapter</span></span> <span class="quoted"><span class="plain_text">‹Unsigned words of 16 bits›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Uint16 <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Code_Target_Word_Base.html">Code_Target_Word_Base</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Restriction for ML code generation:
  This theory assumes that the ML system provides a Word16
  implementation (mlton does, but PolyML 5.5 does not).
  Therefore, the code setup lives in the target <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>SML_word›</span></span></span></span>
  rather than <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>SML›</span></span></span></span>.  This ensures that code generation still
  works as long as <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>uint16›</span></span></span></span> is not involved.
  For the target <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>SML›</span></span></span></span> itself, no special code generation 
  for this type is set up. Nevertheless, it should work by emulation via <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="numeral"><span class="numeral">16</span></span> word"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> 
  if the theory <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Code_Target_Bits_Int›</span></span></span></span> is imported.

  Restriction for OCaml code generation:
  OCaml does not provide an int16 type, so no special code generation 
  for this type is set up.
›</span></span>

<span class="keyword1"><span class="command">declare</span></span> prod.Quotient<span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Type definition and primitive operations›</span></span>

<span class="keyword1"><span class="command">typedef</span></span> uint16 <span class="main">=</span> <span class="quoted"><span class="quoted">"UNIV <span class="main">::</span> <span class="numeral">16</span> word set"</span></span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">setup_lifting</span></span> type_definition_uint16

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Use an abstract type for code generation to disable pattern matching on <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Abs_uint16</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>
<span class="keyword1"><span class="command">declare</span></span> Rep_uint16_inverse<span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">abstype</span><span class="main">]</span>

<span class="keyword1"><span class="command">declare</span></span> Quotient_uint16<span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span>

<span class="keyword1"><span class="command">instantiation</span></span> uint16 <span class="main">::</span> <span class="quoted">comm_ring_1</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">zero_uint16</span> <span class="main">::</span> <span class="quoted">uint16</span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">::</span> <span class="numeral">16</span> word"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">one_uint16</span> <span class="main">::</span> <span class="quoted">uint16</span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">plus_uint16</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint16 <span class="main">⇒</span> uint16 <span class="main">⇒</span> uint16"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(+)</span> <span class="main">::</span> <span class="numeral">16</span> word <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">minus_uint16</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint16 <span class="main">⇒</span> uint16 <span class="main">⇒</span> uint16"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(-)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">uminus_uint16</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint16 <span class="main">⇒</span> uint16"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">uminus</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">times_uint16</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint16 <span class="main">⇒</span> uint16 <span class="main">⇒</span> uint16"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(*)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">transfer</span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">algebra_simps</span></span><span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint16 <span class="main">::</span> <span class="quoted">semiring_modulo</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">divide_uint16</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint16 <span class="main">⇒</span> uint16 <span class="main">⇒</span> uint16"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">(div)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">modulo_uint16</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint16 <span class="main">⇒</span> uint16 <span class="main">⇒</span> uint16"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">(mod)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">transfer</span><span class="main">)</span> <span class="main">(</span><span class="operator">fact</span> word_mod_div_equality<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint16 <span class="main">::</span> <span class="quoted">linorder</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">less_uint16</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint16 <span class="main">⇒</span> uint16 <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(&lt;)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">less_eq_uint16</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint16 <span class="main">⇒</span> uint16 <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(≤)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">transfer</span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_le_not_le linear<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> less_uint16.rep_eq less_eq_uint16.rep_eq

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax
  <span class="keyword2"><span class="keyword">notes</span></span>
    transfer_rule_of_bool <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span>
    transfer_rule_numeral <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> cr_uint16<span class="main">)</span> of_bool of_bool"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Uint16-transfer_rule_numeral_uint"><span class="command">lemma</span></span> transfer_rule_numeral_uint <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> cr_uint16<span class="main">)</span> numeral numeral"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">‹<span class="main">(</span>cr_uint16 <span class="main">===&gt;</span> <span class="main">(⟷)</span><span class="main">)</span> even <span class="main">(</span><span class="keyword1">(dvd)</span> <span class="numeral">2</span> <span class="main">::</span> uint16 <span class="main">⇒</span> bool<span class="main">)</span>›</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> dvd_def<span class="main">)</span> <span class="operator">transfer_prover</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint16 <span class="main">::</span> <span class="quoted">semiring_bits</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">bit_uint16</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹uint16 <span class="main">⇒</span> nat <span class="main">⇒</span> bool›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">bit</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">instance</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">transfer</span><span class="main">)</span>
    <span class="main">(</span><span class="operator">fact</span> bit_iff_odd even_iff_mod_2_eq_zero odd_iff_mod_2_eq_one odd_one bits_induct
       bits_div_0 bits_div_by_1 bits_mod_div_trivial even_succ_div_2
       even_mask_div_iff exp_div_exp_eq div_exp_eq mod_exp_eq mult_exp_mod_exp_eq
       div_exp_mod_exp_eq even_mult_exp_div_exp_iff<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint16 <span class="main">::</span> <span class="quoted">semiring_bit_shifts</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">push_bit_uint16</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹nat <span class="main">⇒</span> uint16 <span class="main">⇒</span> uint16›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">push_bit</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">drop_bit_uint16</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹nat <span class="main">⇒</span> uint16 <span class="main">⇒</span> uint16›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">drop_bit</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">take_bit_uint16</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹nat <span class="main">⇒</span> uint16 <span class="main">⇒</span> uint16›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">take_bit</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">transfer</span><span class="main">)</span>
  <span class="main">(</span><span class="operator">fact</span> push_bit_eq_mult drop_bit_eq_div take_bit_eq_mod<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint16 <span class="main">::</span> <span class="quoted">ring_bit_operations</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">not_uint16</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹uint16 <span class="main">⇒</span> uint16›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="keyword1">NOT</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">and_uint16</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹uint16 <span class="main">⇒</span> uint16 <span class="main">⇒</span> uint16›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">‹<span class="keyword1">(AND)</span>›</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">or_uint16</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹uint16 <span class="main">⇒</span> uint16 <span class="main">⇒</span> uint16›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">‹<span class="keyword1">(OR)</span>›</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">xor_uint16</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹uint16 <span class="main">⇒</span> uint16 <span class="main">⇒</span> uint16›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">‹<span class="keyword1">(XOR)</span>›</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">mask_uint16</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹nat <span class="main">⇒</span> uint16›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">mask</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">transfer</span><span class="main">)</span>
  <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bit_and_iff bit_or_iff bit_xor_iff bit_not_iff minus_eq_not_minus_1 mask_eq_decr_exp<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">‹take_bit <span class="free">n</span> <span class="free">a</span> <span class="main">=</span> <span class="free">a</span> <span class="keyword1">AND</span> mask <span class="free">n</span>›</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">a</span> <span class="main">::</span> <span class="quoted">uint16</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fact</span> take_bit_eq_mask<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">‹mask <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="main">=</span> push_bit <span class="free">n</span> <span class="main">(</span><span class="main">1</span> <span class="main">::</span> uint16<span class="main">)</span> <span class="keyword1">OR</span> mask <span class="free">n</span>›</span></span>
  <span class="quoted"><span class="quoted">‹mask <span class="main">0</span> <span class="main">=</span> <span class="main">(</span><span class="main">0</span> <span class="main">::</span> uint16<span class="main">)</span>›</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mask_Suc_exp push_bit_of_1<span class="main">)</span>

<span class="keyword1"><span class="command">instance</span></span> uint16 <span class="main">::</span> <span class="quoted">semiring_bit_syntax</span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Uint16-test_bit_uint16_transfer"><span class="command">lemma</span></span> test_bit_uint16_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">‹<span class="main">(</span>cr_uint16 <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> bit <span class="main">(!!)</span>›</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> test_bit_eq_bit <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Uint16-shiftl_uint16_transfer"><span class="command">lemma</span></span> shiftl_uint16_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">‹<span class="main">(</span>cr_uint16 <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> cr_uint16<span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">k</span> <span class="bound">n</span><span class="main">.</span> push_bit <span class="bound">n</span> <span class="bound">k</span><span class="main">)</span> <span class="main">(&lt;&lt;)</span>›</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> shiftl_eq_push_bit <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Uint16-shiftr_uint16_transfer"><span class="command">lemma</span></span> shiftr_uint16_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">‹<span class="main">(</span>cr_uint16 <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> cr_uint16<span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">k</span> <span class="bound">n</span><span class="main">.</span> drop_bit <span class="bound">n</span> <span class="bound">k</span><span class="main">)</span> <span class="main">(&gt;&gt;)</span>›</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> shiftr_eq_drop_bit <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint16 <span class="main">::</span> <span class="quoted">lsb</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">lsb_uint16</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹uint16 <span class="main">⇒</span> bool›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">lsb</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">transfer</span><span class="main">)</span>
  <span class="main">(</span><span class="operator">fact</span> lsb_odd<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint16 <span class="main">::</span> <span class="quoted">msb</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">msb_uint16</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹uint16 <span class="main">⇒</span> bool›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">msb</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint16 <span class="main">::</span> <span class="quoted">set_bit</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">set_bit_uint16</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹uint16 <span class="main">⇒</span> nat <span class="main">⇒</span> bool <span class="main">⇒</span> uint16›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">set_bit</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">standard</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">bit_simps</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint16 <span class="main">::</span> <span class="quoted">bit_comprehension</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">set_bits_uint16</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nat <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> uint16"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"set_bits"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">transfer</span><span class="main">)</span> <span class="main">(</span><span class="operator">fact</span> set_bits_bit_eq<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> bit_uint16.rep_eq lsb_uint16.rep_eq msb_uint16.rep_eq

<span class="keyword1"><span class="command">instantiation</span></span> uint16 <span class="main">::</span> <span class="quoted">equal</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">equal_uint16</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint16 <span class="main">⇒</span> uint16 <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"equal_class.equal"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> equal_eq<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> equal_uint16.rep_eq

<span class="keyword1"><span class="command">instantiation</span></span> uint16 <span class="main">::</span> <span class="quoted">size</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">size_uint16</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint16 <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"size"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> size_uint16.rep_eq

<span class="keyword1"><span class="command">lift_definition</span></span> sshiftr_uint16 <span class="main">::</span> <span class="quoted"><span class="quoted">"uint16 <span class="main">⇒</span> nat <span class="main">⇒</span> uint16"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">&gt;&gt;&gt;</span>"</span> 55<span class="main">)</span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">‹<span class="main">λ</span><span class="bound">w</span> <span class="bound">n</span><span class="main">.</span> signed_drop_bit <span class="bound">n</span> <span class="bound">w</span>›</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> uint16_of_int <span class="main">::</span> <span class="quoted"><span class="quoted">"int <span class="main">⇒</span> uint16"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"word_of_int"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint16_of_nat</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> uint16"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">uint16_of_nat</span> <span class="main">=</span> uint16_of_int <span class="main">∘</span> int"</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> int_of_uint16 <span class="main">::</span> <span class="quoted"><span class="quoted">"uint16 <span class="main">⇒</span> int"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"uint"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> nat_of_uint16 <span class="main">::</span> <span class="quoted"><span class="quoted">"uint16 <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"unat"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">integer_of_uint16</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint16 <span class="main">⇒</span> integer"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">integer_of_uint16</span> <span class="main">=</span> integer_of_int <span class="keyword1">o</span> int_of_uint16"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Use pretty numerals from integer for pretty printing›</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> integer.lifting <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> Uint16 <span class="main">::</span> <span class="quoted"><span class="quoted">"integer <span class="main">⇒</span> uint16"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"word_of_int"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1" id="Uint16-Rep_uint16_numeral"><span class="command">lemma</span></span> Rep_uint16_numeral <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Rep_uint16 <span class="main">(</span>numeral <span class="free">n</span><span class="main">)</span> <span class="main">=</span> numeral <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> one_uint16_def Abs_uint16_inverse numeral.simps plus_uint16_def<span class="main">)</span>

<span class="keyword1" id="Uint16-Rep_uint16_neg_numeral"><span class="command">lemma</span></span> Rep_uint16_neg_numeral <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Rep_uint16 <span class="main">(</span><span class="main">-</span> numeral <span class="free">n</span><span class="main">)</span> <span class="main">=</span> <span class="main">-</span> numeral <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> uminus_uint16_def<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_uint16_inverse<span class="main">)</span>

<span class="keyword1" id="Uint16-numeral_uint16_transfer"><span class="command">lemma</span></span> numeral_uint16_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>rel_fun <span class="main">(=)</span> cr_uint16<span class="main">)</span> numeral numeral"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cr_uint16_def<span class="main">)</span>

<span class="keyword1" id="Uint16-numeral_uint16"><span class="command">lemma</span></span> numeral_uint16 <span class="main">[</span><span class="operator">code_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"numeral <span class="free">n</span> <span class="main">=</span> Uint16 <span class="main">(</span>numeral <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Uint16-neg_numeral_uint16"><span class="command">lemma</span></span> neg_numeral_uint16 <span class="main">[</span><span class="operator">code_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">-</span> numeral <span class="free">n</span> <span class="main">=</span> Uint16 <span class="main">(</span><span class="main">-</span> numeral <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cr_uint16_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Uint16-Abs_uint16_numeral"><span class="command">lemma</span></span> Abs_uint16_numeral <span class="main">[</span><span class="operator">code_post</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Abs_uint16 <span class="main">(</span>numeral <span class="free">n</span><span class="main">)</span> <span class="main">=</span> numeral <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> one_uint16_def numeral.simps plus_uint16_def Abs_uint16_inverse<span class="main">)</span>

<span class="keyword1" id="Uint16-Abs_uint16_0"><span class="command">lemma</span></span> Abs_uint16_0 <span class="main">[</span><span class="operator">code_post</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Abs_uint16 <span class="main">0</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_uint16_def<span class="main">)</span>

<span class="keyword1" id="Uint16-Abs_uint16_1"><span class="command">lemma</span></span> Abs_uint16_1 <span class="main">[</span><span class="operator">code_post</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Abs_uint16 <span class="main">1</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> one_uint16_def<span class="main">)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Code setup›</span></span>

<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">code_module</span></span> Uint16 <span class="main">⇀</span> <span class="main">(</span>SML_word<span class="main">)</span>
<span class="quoted">‹(* Test that words can handle numbers between 0 and 15 *)
val _ = if 4 &lt;= Word.wordSize then () else raise (Fail ("wordSize less than 4"));

structure Uint16 : sig
  val set_bit : Word16.word -&gt; IntInf.int -&gt; bool -&gt; Word16.word
  val shiftl : Word16.word -&gt; IntInf.int -&gt; Word16.word
  val shiftr : Word16.word -&gt; IntInf.int -&gt; Word16.word
  val shiftr_signed : Word16.word -&gt; IntInf.int -&gt; Word16.word
  val test_bit : Word16.word -&gt; IntInf.int -&gt; bool
end = struct

fun set_bit x n b =
  let val mask = Word16.&lt;&lt; (0wx1, Word.fromLargeInt (IntInf.toLarge n))
  in if b then Word16.orb (x, mask)
     else Word16.andb (x, Word16.notb mask)
  end

fun shiftl x n =
  Word16.&lt;&lt; (x, Word.fromLargeInt (IntInf.toLarge n))

fun shiftr x n =
  Word16.&gt;&gt; (x, Word.fromLargeInt (IntInf.toLarge n))

fun shiftr_signed x n =
  Word16.~&gt;&gt; (x, Word.fromLargeInt (IntInf.toLarge n))

fun test_bit x n =
  Word16.andb (x, Word16.&lt;&lt; (0wx1, Word.fromLargeInt (IntInf.toLarge n))) &lt;&gt; Word16.fromInt 0

end; (* struct Uint16 *)›</span>
<span class="keyword1"><span class="command">code_reserved</span></span> SML_word Uint16

<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">code_module</span></span> Uint16 <span class="main">⇀</span> <span class="main">(</span>Haskell<span class="main">)</span>
 <span class="quoted">‹module Uint16(Int16, Word16) where

  import Data.Int(Int16)
  import Data.Word(Word16)›</span>
<span class="keyword1"><span class="command">code_reserved</span></span> Haskell Uint16

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Scala provides unsigned 16-bit numbers as Char.›</span></span>

<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">code_module</span></span> Uint16 <span class="main">⇀</span> <span class="main">(</span>Scala<span class="main">)</span>
<span class="quoted">‹object Uint16 {

def set_bit(x: scala.Char, n: BigInt, b: Boolean) : scala.Char =
  if (b)
    (x | (1.toChar &lt;&lt; n.intValue)).toChar
  else
    (x &amp; (1.toChar &lt;&lt; n.intValue).unary_~).toChar

def shiftl(x: scala.Char, n: BigInt) : scala.Char = (x &lt;&lt; n.intValue).toChar

def shiftr(x: scala.Char, n: BigInt) : scala.Char = (x &gt;&gt;&gt; n.intValue).toChar

def shiftr_signed(x: scala.Char, n: BigInt) : scala.Char = (x.toShort &gt;&gt; n.intValue).toChar

def test_bit(x: scala.Char, n: BigInt) : Boolean = (x &amp; (1.toChar &lt;&lt; n.intValue)) != 0

} /* object Uint16 */›</span>
<span class="keyword1"><span class="command">code_reserved</span></span> Scala Uint16

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Avoid <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Abs_uint16</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> in generated code, use <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">Rep_uint16'</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> instead. 
  The symbolic implementations for code\_simp use <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Rep_uint16</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.

  The new destructor <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">Rep_uint16'</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is executable.
  As the simplifier is given the [code abstract] equations literally, 
  we cannot implement <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Rep_uint16</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> directly, because that makes code\_simp loop.

  If code generation raises Match, some equation probably contains <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Rep_uint16</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> 
  ([code abstract] equations for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">uint16</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> may use <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Rep_uint16</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> because
  these instances will be folded away.)

  To convert <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="numeral"><span class="numeral">16</span></span> word"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> values into <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">uint16</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, use <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">Abs_uint16'</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">Rep_uint16'</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Rep_uint16'</span> <span class="main">=</span> Rep_uint16"</span></span>

<span class="keyword1" id="Uint16-Rep_uint16'_transfer"><span class="command">lemma</span></span> Rep_uint16'_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"rel_fun cr_uint16 <span class="main">(=)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">)</span> Rep_uint16'"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> Rep_uint16'_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> uint16.rep_transfer<span class="main">)</span>

<span class="keyword1" id="Uint16-Rep_uint16'_code"><span class="command">lemma</span></span> Rep_uint16'_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Rep_uint16' <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">BITS</span> <span class="bound">n</span><span class="main">.</span> bit <span class="free">x</span> <span class="bound">n</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_bits_bit_eq<span class="main">)</span>

<span class="keyword1"><span class="command">lift_definition</span></span> Abs_uint16' <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="numeral">16</span> word <span class="main">⇒</span> uint16"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span> <span class="main">::</span> <span class="numeral">16</span> word<span class="main">.</span> <span class="bound">x</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1" id="Uint16-Abs_uint16'_code"><span class="command">lemma</span></span> Abs_uint16'_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Abs_uint16' <span class="free">x</span> <span class="main">=</span> Uint16 <span class="main">(</span>integer_of_int <span class="main">(</span>uint <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">including</span></span> integer.lifting <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">"term_of_class.term_of <span class="main">::</span> uint16 <span class="main">⇒</span> <span class="main">_</span>"</span></span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Uint16-term_of_uint16_code"><span class="command">lemma</span></span> term_of_uint16_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">TR</span> <span class="main">≡</span> typerep.Typerep"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">bit0</span> <span class="main">≡</span> <span class="keyword1">STR</span> <span class="inner_quoted">''Numeral_Type.bit0''</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"term_of_class.term_of <span class="free">x</span> <span class="main">=</span> 
   Code_Evaluation.App <span class="main">(</span>Code_Evaluation.Const <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Uint16.uint16.Abs_uint16''</span><span class="main">)</span> <span class="main">(</span><span class="free">TR</span> <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''fun''</span><span class="main">)</span> <span class="main">[</span><span class="free">TR</span> <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Word.word''</span><span class="main">)</span> <span class="main">[</span><span class="free">TR</span> <span class="free">bit0</span> <span class="main">[</span><span class="free">TR</span> <span class="free">bit0</span> <span class="main">[</span><span class="free">TR</span> <span class="free">bit0</span> <span class="main">[</span><span class="free">TR</span> <span class="free">bit0</span> <span class="main">[</span><span class="free">TR</span> <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Numeral_Type.num1''</span><span class="main">)</span> <span class="main">[]</span><span class="main">]</span><span class="main">]</span><span class="main">]</span><span class="main">]</span><span class="main">]</span><span class="main">,</span> <span class="free">TR</span> <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Uint16.uint16''</span><span class="main">)</span> <span class="main">[]</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
       <span class="main">(</span>term_of_class.term_of <span class="main">(</span>Rep_uint16' <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> term_of_anything<span class="main">)</span>

<span class="keyword1" id="Uint16-Uin16_code"><span class="command">lemma</span></span> Uin16_code <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">abstract</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Rep_uint16 <span class="main">(</span>Uint16 <span class="free">i</span><span class="main">)</span> <span class="main">=</span> word_of_int <span class="main">(</span>int_of_integer_symbolic <span class="free">i</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> Uint16_def int_of_integer_symbolic_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_uint16_inverse<span class="main">)</span>

<span class="keyword1"><span class="command">code_printing</span></span>
  <span class="keyword2"><span class="keyword">type_constructor</span></span> uint16 <span class="main">⇀</span>
  <span class="main">(</span>SML_word<span class="main">)</span> <span class="quoted">"Word16.word"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"Uint16.Word16"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"scala.Char"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">Uint16</span> <span class="main">⇀</span>
  <span class="main">(</span>SML_word<span class="main">)</span> <span class="quoted">"Word16.fromLargeInt (IntInf.toLarge _)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"(Prelude.fromInteger _ :: Uint16.Word16)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell_Quickcheck<span class="main">)</span> <span class="quoted">"(Prelude.fromInteger (Prelude.toInteger _) :: Uint16.Word16)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"_.charValue"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">::</span> uint16"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML_word<span class="main">)</span> <span class="quoted">"(Word16.fromInt 0)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"(0 :: Uint16.Word16)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"0"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">::</span> uint16"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML_word<span class="main">)</span> <span class="quoted">"(Word16.fromInt 1)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"(1 :: Uint16.Word16)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"1"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"plus <span class="main">::</span> uint16 <span class="main">⇒</span> <span class="main">_</span> <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML_word<span class="main">)</span> <span class="quoted">"Word16.+ ((_), (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 6 <span class="quoted">"+"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"(_ +/ _).toChar"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"uminus <span class="main">::</span> uint16 <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML_word<span class="main">)</span> <span class="quoted">"Word16.~"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"negate"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"(- _).toChar"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"minus <span class="main">::</span> uint16 <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML_word<span class="main">)</span> <span class="quoted">"Word16.- ((_), (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 6 <span class="quoted">"-"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"(_ -/ _).toChar"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"times <span class="main">::</span> uint16 <span class="main">⇒</span> <span class="main">_</span> <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML_word<span class="main">)</span> <span class="quoted">"Word16.* ((_), (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 7 <span class="quoted">"*"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"(_ */ _).toChar"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"HOL.equal <span class="main">::</span> uint16 <span class="main">⇒</span> <span class="main">_</span> <span class="main">⇒</span> bool"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML_word<span class="main">)</span> <span class="quoted">"!((_ : Word16.word) = _)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="keyword2"><span class="keyword">infix</span></span> 4 <span class="quoted">"=="</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 5 <span class="quoted">"=="</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">class_instance</span></span> uint16 <span class="main">::</span> equal <span class="main">⇀</span> <span class="main">(</span>Haskell<span class="main">)</span> -
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"less_eq <span class="main">::</span> uint16 <span class="main">⇒</span> <span class="main">_</span> <span class="main">⇒</span> bool"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML_word<span class="main">)</span> <span class="quoted">"Word16.&lt;= ((_), (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="keyword2"><span class="keyword">infix</span></span> 4 <span class="quoted">"&lt;="</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 4 <span class="quoted">"&lt;="</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"less <span class="main">::</span> uint16 <span class="main">⇒</span> <span class="main">_</span> <span class="main">⇒</span> bool"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML_word<span class="main">)</span> <span class="quoted">"Word16.&lt; ((_), (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="keyword2"><span class="keyword">infix</span></span> 4 <span class="quoted">"&lt;"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 4 <span class="quoted">"&lt;"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">NOT</span> <span class="main">::</span> uint16 <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML_word<span class="main">)</span> <span class="quoted">"Word16.notb"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"Data'_Bits.complement"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"_.unary'_~.toChar"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">(AND)</span> <span class="main">::</span> uint16 <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML_word<span class="main">)</span> <span class="quoted">"Word16.andb ((_),/ (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 7 <span class="quoted">"Data_Bits..&amp;."</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"(_ &amp; _).toChar"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">(OR)</span> <span class="main">::</span> uint16 <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML_word<span class="main">)</span> <span class="quoted">"Word16.orb ((_),/ (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 5 <span class="quoted">"Data_Bits..|."</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"(_ | _).toChar"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">(XOR)</span> <span class="main">::</span> uint16 <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML_word<span class="main">)</span> <span class="quoted">"Word16.xorb ((_),/ (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"Data'_Bits.xor"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"(_ ^ _).toChar"</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint16_div</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint16 <span class="main">⇒</span> uint16 <span class="main">⇒</span> uint16"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">uint16_div</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> undefined <span class="main">(</span><span class="keyword1">(div)</span> <span class="main">::</span> uint16 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="main">0</span> <span class="main">::</span> uint16<span class="main">)</span> <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">div</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint16_mod</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint16 <span class="main">⇒</span> uint16 <span class="main">⇒</span> uint16"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">uint16_mod</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> undefined <span class="main">(</span><span class="keyword1">(mod)</span> <span class="main">::</span> uint16 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="main">0</span> <span class="main">::</span> uint16<span class="main">)</span> <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">mod</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> undefined_transfer <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Uint16-div_uint16_code"><span class="command">lemma</span></span> div_uint16_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="keyword1">div</span> <span class="free">y</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">y</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> uint16_div <span class="free">x</span> <span class="free">y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> uint16_div_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> word_div_def<span class="main">)</span>

<span class="keyword1" id="Uint16-mod_uint16_code"><span class="command">lemma</span></span> mod_uint16_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="keyword1">mod</span> <span class="free">y</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">y</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="free">x</span> <span class="keyword1">else</span> uint16_mod <span class="free">x</span> <span class="free">y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> uint16_mod_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> word_mod_def<span class="main">)</span>

<span class="keyword1" id="Uint16-uint16_div_code"><span class="command">lemma</span></span> uint16_div_code <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">abstract</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Rep_uint16 <span class="main">(</span>uint16_div <span class="free">x</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">y</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> Rep_uint16 <span class="main">(</span>undefined <span class="main">(</span><span class="keyword1">(div)</span> <span class="main">::</span> uint16 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free">x</span> <span class="main">(</span><span class="main">0</span> <span class="main">::</span> uint16<span class="main">)</span><span class="main">)</span> <span class="keyword1">else</span> Rep_uint16 <span class="free">x</span> <span class="keyword1">div</span> Rep_uint16 <span class="free">y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> uint16_div_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Uint16-uint16_mod_code"><span class="command">lemma</span></span> uint16_mod_code <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">abstract</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Rep_uint16 <span class="main">(</span>uint16_mod <span class="free">x</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">y</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> Rep_uint16 <span class="main">(</span>undefined <span class="main">(</span><span class="keyword1">(mod)</span> <span class="main">::</span> uint16 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free">x</span> <span class="main">(</span><span class="main">0</span> <span class="main">::</span> uint16<span class="main">)</span><span class="main">)</span> <span class="keyword1">else</span> Rep_uint16 <span class="free">x</span> <span class="keyword1">mod</span> Rep_uint16 <span class="free">y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> uint16_mod_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint16_div</span> <span class="main">⇀</span>
  <span class="main">(</span>SML_word<span class="main">)</span> <span class="quoted">"Word16.div ((_), (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"Prelude.div"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"(_ '/ _).toChar"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint16_mod</span> <span class="main">⇀</span>
  <span class="main">(</span>SML_word<span class="main">)</span> <span class="quoted">"Word16.mod ((_), (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"Prelude.mod"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"(_ % _).toChar"</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint16_test_bit</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint16 <span class="main">⇒</span> integer <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">uint16_test_bit</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">∨</span> <span class="numeral">15</span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">then</span> undefined <span class="main">(</span>bit <span class="main">::</span> uint16 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span>
   <span class="keyword1">else</span> bit <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span>nat_of_integer <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Uint16-test_bit_uint16_code"><span class="command">lemma</span></span> test_bit_uint16_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"bit <span class="free">x</span> <span class="free">n</span> <span class="main">⟷</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="numeral">16</span> <span class="main">∧</span> uint16_test_bit <span class="free">x</span> <span class="main">(</span>integer_of_nat <span class="free">n</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> undefined_transfer integer.lifting <span class="keyword1"><span class="command">unfolding</span></span> uint16_test_bit_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="Uint16-uint16_test_bit_code"><span class="command">lemma</span></span> uint16_test_bit_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"uint16_test_bit <span class="free">w</span> <span class="free">n</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">∨</span> <span class="numeral">15</span> <span class="main">&lt;</span> <span class="free">n</span> <span class="keyword1">then</span> undefined <span class="main">(</span>bit <span class="main">::</span> uint16 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free">w</span> <span class="free">n</span> <span class="keyword1">else</span> bit <span class="main">(</span>Rep_uint16 <span class="free">w</span><span class="main">)</span> <span class="main">(</span>nat_of_integer <span class="free">n</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> uint16_test_bit_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bit_uint16.rep_eq<span class="main">)</span>

<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint16_test_bit</span> <span class="main">⇀</span>
  <span class="main">(</span>SML_word<span class="main">)</span> <span class="quoted">"Uint16.test'_bit"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"Data'_Bits.testBitBounded"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"Uint16.test'_bit"</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint16_set_bit</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint16 <span class="main">⇒</span> integer <span class="main">⇒</span> bool <span class="main">⇒</span> uint16"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">uint16_set_bit</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">∨</span> <span class="numeral">15</span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">then</span> undefined <span class="main">(</span>set_bit <span class="main">::</span> uint16 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span>
   <span class="keyword1">else</span> set_bit <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span>nat_of_integer <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Uint16-set_bit_uint16_code"><span class="command">lemma</span></span> set_bit_uint16_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"set_bit <span class="free">x</span> <span class="free">n</span> <span class="free">b</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="numeral">16</span> <span class="keyword1">then</span> uint16_set_bit <span class="free">x</span> <span class="main">(</span>integer_of_nat <span class="free">n</span><span class="main">)</span> <span class="free">b</span> <span class="keyword1">else</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">including</span></span> undefined_transfer integer.lifting <span class="keyword1"><span class="command">unfolding</span></span> uint16_set_bit_def
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">transfer</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> conj_cong <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_less set_bit_beyond word_size<span class="main">)</span>

<span class="keyword1" id="Uint16-uint16_set_bit_code"><span class="command">lemma</span></span> uint16_set_bit_code <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">abstract</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Rep_uint16 <span class="main">(</span>uint16_set_bit <span class="free">w</span> <span class="free">n</span> <span class="free">b</span><span class="main">)</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">∨</span> <span class="numeral">15</span> <span class="main">&lt;</span> <span class="free">n</span> <span class="keyword1">then</span> Rep_uint16 <span class="main">(</span>undefined <span class="main">(</span>set_bit <span class="main">::</span> uint16 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free">w</span> <span class="free">n</span> <span class="free">b</span><span class="main">)</span>
   <span class="keyword1">else</span> set_bit <span class="main">(</span>Rep_uint16 <span class="free">w</span><span class="main">)</span> <span class="main">(</span>nat_of_integer <span class="free">n</span><span class="main">)</span> <span class="free">b</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">including</span></span> undefined_transfer <span class="keyword1"><span class="command">unfolding</span></span> uint16_set_bit_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint16_set_bit</span> <span class="main">⇀</span>
  <span class="main">(</span>SML_word<span class="main">)</span> <span class="quoted">"Uint16.set'_bit"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"Data'_Bits.setBitBounded"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"Uint16.set'_bit"</span>

<span class="keyword1"><span class="command">lift_definition</span></span> uint16_set_bits <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nat <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> uint16 <span class="main">⇒</span> nat <span class="main">⇒</span> uint16"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">set_bits_aux</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1" id="Uint16-uint16_set_bits_code"><span class="command">lemma</span></span> uint16_set_bits_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"uint16_set_bits <span class="free">f</span> <span class="free">w</span> <span class="free">n</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="free">w</span> 
   <span class="keyword1">else</span> <span class="keyword1">let</span> <span class="bound">n'</span> <span class="main">=</span> <span class="free">n</span> <span class="main">-</span> <span class="main">1</span> <span class="keyword1">in</span> uint16_set_bits <span class="free">f</span> <span class="main">(</span><span class="main">(</span>push_bit <span class="main">1</span> <span class="free">w</span><span class="main">)</span> <span class="keyword1">OR</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">f</span> <span class="bound">n'</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span> <span class="bound">n'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">transfer</span> <span class="quasi_keyword">fixing</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> shiftl_eq_push_bit<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Uint16-set_bits_uint16"><span class="command">lemma</span></span> set_bits_uint16 <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">BITS</span> <span class="bound">n</span><span class="main">.</span> <span class="free">f</span> <span class="bound">n</span><span class="main">)</span> <span class="main">=</span> uint16_set_bits <span class="free">f</span> <span class="main">0</span> <span class="numeral">16</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_bits_conv_set_bits_aux<span class="main">)</span>


<span class="keyword1" id="Uint16-lsb_code"><span class="command">lemma</span></span> lsb_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span> <span class="main">::</span> <span class="quoted">uint16</span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lsb <span class="free">x</span> <span class="main">⟷</span> bit <span class="free">x</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lsb_odd<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint16_shiftl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint16 <span class="main">⇒</span> integer <span class="main">⇒</span> uint16"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">uint16_shiftl</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">∨</span> <span class="numeral">16</span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">then</span> undefined <span class="main">(</span>push_bit <span class="main">::</span> nat <span class="main">⇒</span> uint16 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">else</span> push_bit <span class="main">(</span>nat_of_integer <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Uint16-shiftl_uint16_code"><span class="command">lemma</span></span> shiftl_uint16_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"push_bit <span class="free">n</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="numeral">16</span> <span class="keyword1">then</span> uint16_shiftl <span class="free">x</span> <span class="main">(</span>integer_of_nat <span class="free">n</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> undefined_transfer integer.lifting <span class="keyword1"><span class="command">unfolding</span></span> uint16_shiftl_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Uint16-uint16_shiftl_code"><span class="command">lemma</span></span> uint16_shiftl_code <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">abstract</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Rep_uint16 <span class="main">(</span>uint16_shiftl <span class="free">w</span> <span class="free">n</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">∨</span> <span class="numeral">16</span> <span class="main">≤</span> <span class="free">n</span> <span class="keyword1">then</span> Rep_uint16 <span class="main">(</span>undefined <span class="main">(</span>push_bit <span class="main">::</span> nat <span class="main">⇒</span> uint16 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free">w</span> <span class="free">n</span><span class="main">)</span>
   <span class="keyword1">else</span> push_bit <span class="main">(</span>nat_of_integer <span class="free">n</span><span class="main">)</span> <span class="main">(</span>Rep_uint16 <span class="free">w</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> undefined_transfer <span class="keyword1"><span class="command">unfolding</span></span> uint16_shiftl_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint16_shiftl</span> <span class="main">⇀</span>
  <span class="main">(</span>SML_word<span class="main">)</span> <span class="quoted">"Uint16.shiftl"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"Data'_Bits.shiftlBounded"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"Uint16.shiftl"</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint16_shiftr</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint16 <span class="main">⇒</span> integer <span class="main">⇒</span> uint16"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">uint16_shiftr</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">∨</span> <span class="numeral">16</span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">then</span> undefined <span class="main">(</span>drop_bit <span class="main">::</span> nat <span class="main">⇒</span> uint16 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">else</span> drop_bit <span class="main">(</span>nat_of_integer <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Uint16-shiftr_uint16_code"><span class="command">lemma</span></span> shiftr_uint16_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"drop_bit <span class="free">n</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="numeral">16</span> <span class="keyword1">then</span> uint16_shiftr <span class="free">x</span> <span class="main">(</span>integer_of_nat <span class="free">n</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> undefined_transfer integer.lifting <span class="keyword1"><span class="command">unfolding</span></span> uint16_shiftr_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Uint16-uint16_shiftr_code"><span class="command">lemma</span></span> uint16_shiftr_code <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">abstract</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Rep_uint16 <span class="main">(</span>uint16_shiftr <span class="free">w</span> <span class="free">n</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">∨</span> <span class="numeral">16</span> <span class="main">≤</span> <span class="free">n</span> <span class="keyword1">then</span> Rep_uint16 <span class="main">(</span>undefined <span class="main">(</span>drop_bit <span class="main">::</span> nat <span class="main">⇒</span> uint16 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free">w</span> <span class="free">n</span><span class="main">)</span>
   <span class="keyword1">else</span> drop_bit <span class="main">(</span>nat_of_integer <span class="free">n</span><span class="main">)</span> <span class="main">(</span>Rep_uint16 <span class="free">w</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">including</span></span> undefined_transfer <span class="keyword1"><span class="command">unfolding</span></span> uint16_shiftr_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint16_shiftr</span> <span class="main">⇀</span>
  <span class="main">(</span>SML_word<span class="main">)</span> <span class="quoted">"Uint16.shiftr"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"Data'_Bits.shiftrBounded"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"Uint16.shiftr"</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint16_sshiftr</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint16 <span class="main">⇒</span> integer <span class="main">⇒</span> uint16"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">uint16_sshiftr</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">∨</span> <span class="numeral">16</span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">then</span> undefined sshiftr_uint16 <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">else</span> sshiftr_uint16 <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span>nat_of_integer <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Uint16-sshiftr_uint16_code"><span class="command">lemma</span></span> sshiftr_uint16_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">&gt;&gt;&gt;</span> <span class="free">n</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="numeral">16</span> <span class="keyword1">then</span> uint16_sshiftr <span class="free">x</span> <span class="main">(</span>integer_of_nat <span class="free">n</span><span class="main">)</span> <span class="keyword1">else</span> <span class="keyword1">if</span> bit <span class="free">x</span> <span class="numeral">15</span> <span class="keyword1">then</span> <span class="main">-</span><span class="main">1</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">including</span></span> undefined_transfer integer.lifting <span class="keyword1"><span class="command">unfolding</span></span> uint16_sshiftr_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_less signed_drop_bit_beyond word_size<span class="main">)</span>

<span class="keyword1" id="Uint16-uint16_sshiftr_code"><span class="command">lemma</span></span> uint16_sshiftr_code <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">abstract</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Rep_uint16 <span class="main">(</span>uint16_sshiftr <span class="free">w</span> <span class="free">n</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">∨</span> <span class="numeral">16</span> <span class="main">≤</span> <span class="free">n</span> <span class="keyword1">then</span> Rep_uint16 <span class="main">(</span>undefined sshiftr_uint16 <span class="free">w</span> <span class="free">n</span><span class="main">)</span>
   <span class="keyword1">else</span> signed_drop_bit <span class="main">(</span>nat_of_integer <span class="free">n</span><span class="main">)</span> <span class="main">(</span>Rep_uint16 <span class="free">w</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">including</span></span> undefined_transfer <span class="keyword1"><span class="command">unfolding</span></span> uint16_sshiftr_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint16_sshiftr</span> <span class="main">⇀</span>
  <span class="main">(</span>SML_word<span class="main">)</span> <span class="quoted">"Uint16.shiftr'_signed"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> 
    <span class="quoted">"(Prelude.fromInteger (Prelude.toInteger (Data'_Bits.shiftrBounded (Prelude.fromInteger (Prelude.toInteger _) :: Uint16.Int16) _)) :: Uint16.Word16)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"Uint16.shiftr'_signed"</span>

<span class="keyword1" id="Uint16-uint16_msb_test_bit"><span class="command">lemma</span></span> uint16_msb_test_bit<span class="main">:</span> <span class="quoted"><span class="quoted">"msb <span class="free">x</span> <span class="main">⟷</span> bit <span class="main">(</span><span class="free">x</span> <span class="main">::</span> uint16<span class="main">)</span> <span class="numeral">15</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> msb_word_iff_bit<span class="main">)</span>

<span class="keyword1" id="Uint16-msb_uint16_code"><span class="command">lemma</span></span> msb_uint16_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"msb <span class="free">x</span> <span class="main">⟷</span> uint16_test_bit <span class="free">x</span> <span class="numeral">15</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> uint16_test_bit_def uint16_msb_test_bit<span class="main">)</span>

<span class="keyword1" id="Uint16-uint16_of_int_code"><span class="command">lemma</span></span> uint16_of_int_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"uint16_of_int <span class="free">i</span> <span class="main">=</span> Uint16 <span class="main">(</span>integer_of_int <span class="free">i</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">including</span></span> integer.lifting <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Uint16-int_of_uint16_code"><span class="command">lemma</span></span> int_of_uint16_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"int_of_uint16 <span class="free">x</span> <span class="main">=</span> int_of_integer <span class="main">(</span>integer_of_uint16 <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> integer_of_uint16_def<span class="main">)</span>

<span class="keyword1" id="Uint16-nat_of_uint16_code"><span class="command">lemma</span></span> nat_of_uint16_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"nat_of_uint16 <span class="free">x</span> <span class="main">=</span> nat_of_integer <span class="main">(</span>integer_of_uint16 <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> integer_of_uint16_def <span class="keyword1"><span class="command">including</span></span> integer.lifting <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Uint16-integer_of_uint16_code"><span class="command">lemma</span></span> integer_of_uint16_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"integer_of_uint16 <span class="free">n</span> <span class="main">=</span> integer_of_int <span class="main">(</span>uint <span class="main">(</span>Rep_uint16' <span class="free">n</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> integer_of_uint16_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">code_printing</span></span>
  <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"integer_of_uint16"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML_word<span class="main">)</span> <span class="quoted">"Word16.toInt _ : IntInf.int"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"Prelude.toInteger"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"BigInt"</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Quickcheck setup›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint16_of_natural</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"natural <span class="main">⇒</span> uint16"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">uint16_of_natural</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≡</span> Uint16 <span class="main">(</span>integer_of_natural <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint16 <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">{</span>random<span class="main">,</span> exhaustive<span class="main">,</span> full_exhaustive<span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">random_uint16</span></span> <span class="main">≡</span> qc_random_cnv uint16_of_natural"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">exhaustive_uint16</span></span> <span class="main">≡</span> qc_exhaustive_cnv uint16_of_natural"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">full_exhaustive_uint16</span></span> <span class="main">≡</span> qc_full_exhaustive_cnv uint16_of_natural"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint16 <span class="main">::</span> <span class="quoted">narrowing</span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> quickcheck_narrowing_samples
  <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">i</span><span class="main">.</span> <span class="keyword1">let</span> <span class="bound">x</span> <span class="main">=</span> Uint16 <span class="bound">i</span> <span class="keyword1">in</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="numeral">0xFFFF</span> <span class="main">-</span> <span class="bound">x</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span>"</span></span>
  <span class="quoted"><span class="quoted">"Typerep.Typerep <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Uint16.uint16''</span><span class="main">)</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">narrowing_uint16</span></span> <span class="free"><span class="bound"><span class="entity">d</span></span></span> <span class="main">=</span> qc_narrowing_drawn_from <span class="main">(</span>narrowing_samples <span class="free"><span class="bound"><span class="entity">d</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">d</span></span></span>"</span></span>
<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">"partial_term_of <span class="main">::</span> uint16 itself <span class="main">⇒</span> <span class="main">_</span>"</span></span><span class="main">]</span><span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> partial_term_of_uint16 <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> partial_term_of_code

<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">no_notation</span></span> sshiftr_uint16 <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">&gt;&gt;&gt;</span>"</span> 55<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Uint8">
<div class="head">
<h1>Theory Uint8</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Uint8.thy
    Author:     Andreas Lochbihler, ETH Zurich
*)</span>

<span class="keyword1"><span class="command">chapter</span></span> <span class="quoted"><span class="plain_text">‹Unsigned words of 8 bits›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Uint8 <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Code_Target_Word_Base.html">Code_Target_Word_Base</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Restriction for OCaml code generation:
  OCaml does not provide an int8 type, so no special code generation 
  for this type is set up. If the theory <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Code_Target_Bits_Int›</span></span></span></span>
  is imported, the type <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>uint8›</span></span></span></span> is emulated via <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="numeral"><span class="numeral">8</span></span> word"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>

<span class="keyword1"><span class="command">declare</span></span> prod.Quotient<span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Type definition and primitive operations›</span></span>

<span class="keyword1"><span class="command">typedef</span></span> uint8 <span class="main">=</span> <span class="quoted"><span class="quoted">"UNIV <span class="main">::</span> <span class="numeral">8</span> word set"</span></span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">setup_lifting</span></span> type_definition_uint8

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Use an abstract type for code generation to disable pattern matching on <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Abs_uint8</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>
<span class="keyword1"><span class="command">declare</span></span> Rep_uint8_inverse<span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">abstype</span><span class="main">]</span>

<span class="keyword1"><span class="command">declare</span></span> Quotient_uint8<span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span>

<span class="keyword1"><span class="command">instantiation</span></span> uint8 <span class="main">::</span> <span class="quoted">comm_ring_1</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">zero_uint8</span> <span class="main">::</span> <span class="quoted">uint8</span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">::</span> <span class="numeral">8</span> word"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">one_uint8</span> <span class="main">::</span> <span class="quoted">uint8</span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">plus_uint8</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint8 <span class="main">⇒</span> uint8 <span class="main">⇒</span> uint8"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(+)</span> <span class="main">::</span> <span class="numeral">8</span> word <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">minus_uint8</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint8 <span class="main">⇒</span> uint8 <span class="main">⇒</span> uint8"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(-)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">uminus_uint8</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint8 <span class="main">⇒</span> uint8"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">uminus</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">times_uint8</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint8 <span class="main">⇒</span> uint8 <span class="main">⇒</span> uint8"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(*)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">transfer</span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">algebra_simps</span></span><span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint8 <span class="main">::</span> <span class="quoted">semiring_modulo</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">divide_uint8</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint8 <span class="main">⇒</span> uint8 <span class="main">⇒</span> uint8"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">(div)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">modulo_uint8</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint8 <span class="main">⇒</span> uint8 <span class="main">⇒</span> uint8"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">(mod)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">transfer</span><span class="main">)</span> <span class="main">(</span><span class="operator">fact</span> word_mod_div_equality<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint8 <span class="main">::</span> <span class="quoted">linorder</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">less_uint8</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint8 <span class="main">⇒</span> uint8 <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(&lt;)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">less_eq_uint8</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint8 <span class="main">⇒</span> uint8 <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(≤)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">transfer</span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_le_not_le linear<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> less_uint8.rep_eq less_eq_uint8.rep_eq

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax
  <span class="keyword2"><span class="keyword">notes</span></span>
    transfer_rule_of_bool <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span>
    transfer_rule_numeral <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> cr_uint8<span class="main">)</span> of_bool of_bool"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Uint8-transfer_rule_numeral_uint"><span class="command">lemma</span></span> transfer_rule_numeral_uint <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> cr_uint8<span class="main">)</span> numeral numeral"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">‹<span class="main">(</span>cr_uint8 <span class="main">===&gt;</span> <span class="main">(⟷)</span><span class="main">)</span> even <span class="main">(</span><span class="keyword1">(dvd)</span> <span class="numeral">2</span> <span class="main">::</span> uint8 <span class="main">⇒</span> bool<span class="main">)</span>›</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> dvd_def<span class="main">)</span> <span class="operator">transfer_prover</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint8 <span class="main">::</span> <span class="quoted">semiring_bits</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">bit_uint8</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹uint8 <span class="main">⇒</span> nat <span class="main">⇒</span> bool›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">bit</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">instance</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">transfer</span><span class="main">)</span>
    <span class="main">(</span><span class="operator">fact</span> bit_iff_odd even_iff_mod_2_eq_zero odd_iff_mod_2_eq_one odd_one bits_induct
       bits_div_0 bits_div_by_1 bits_mod_div_trivial even_succ_div_2
       even_mask_div_iff exp_div_exp_eq div_exp_eq mod_exp_eq mult_exp_mod_exp_eq
       div_exp_mod_exp_eq even_mult_exp_div_exp_iff<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint8 <span class="main">::</span> <span class="quoted">semiring_bit_shifts</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">push_bit_uint8</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹nat <span class="main">⇒</span> uint8 <span class="main">⇒</span> uint8›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">push_bit</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">drop_bit_uint8</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹nat <span class="main">⇒</span> uint8 <span class="main">⇒</span> uint8›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">drop_bit</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">take_bit_uint8</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹nat <span class="main">⇒</span> uint8 <span class="main">⇒</span> uint8›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">take_bit</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">transfer</span><span class="main">)</span>
  <span class="main">(</span><span class="operator">fact</span> push_bit_eq_mult drop_bit_eq_div take_bit_eq_mod<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint8 <span class="main">::</span> <span class="quoted">ring_bit_operations</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">not_uint8</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹uint8 <span class="main">⇒</span> uint8›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="keyword1">NOT</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">and_uint8</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹uint8 <span class="main">⇒</span> uint8 <span class="main">⇒</span> uint8›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">‹<span class="keyword1">(AND)</span>›</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">or_uint8</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹uint8 <span class="main">⇒</span> uint8 <span class="main">⇒</span> uint8›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">‹<span class="keyword1">(OR)</span>›</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">xor_uint8</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹uint8 <span class="main">⇒</span> uint8 <span class="main">⇒</span> uint8›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">‹<span class="keyword1">(XOR)</span>›</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">mask_uint8</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹nat <span class="main">⇒</span> uint8›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">mask</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">transfer</span><span class="main">)</span>
  <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bit_and_iff bit_or_iff bit_xor_iff bit_not_iff minus_eq_not_minus_1 mask_eq_decr_exp<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">‹take_bit <span class="free">n</span> <span class="free">a</span> <span class="main">=</span> <span class="free">a</span> <span class="keyword1">AND</span> mask <span class="free">n</span>›</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">a</span> <span class="main">::</span> <span class="quoted">uint8</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fact</span> take_bit_eq_mask<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">‹mask <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="main">=</span> push_bit <span class="free">n</span> <span class="main">(</span><span class="main">1</span> <span class="main">::</span> uint8<span class="main">)</span> <span class="keyword1">OR</span> mask <span class="free">n</span>›</span></span>
  <span class="quoted"><span class="quoted">‹mask <span class="main">0</span> <span class="main">=</span> <span class="main">(</span><span class="main">0</span> <span class="main">::</span> uint8<span class="main">)</span>›</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mask_Suc_exp push_bit_of_1<span class="main">)</span>

<span class="keyword1"><span class="command">instance</span></span> uint8 <span class="main">::</span> <span class="quoted">semiring_bit_syntax</span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Uint8-test_bit_uint8_transfer"><span class="command">lemma</span></span> test_bit_uint8_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">‹<span class="main">(</span>cr_uint8 <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> bit <span class="main">(!!)</span>›</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> test_bit_eq_bit <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Uint8-shiftl_uint8_transfer"><span class="command">lemma</span></span> shiftl_uint8_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">‹<span class="main">(</span>cr_uint8 <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> cr_uint8<span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">k</span> <span class="bound">n</span><span class="main">.</span> push_bit <span class="bound">n</span> <span class="bound">k</span><span class="main">)</span> <span class="main">(&lt;&lt;)</span>›</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> shiftl_eq_push_bit <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Uint8-shiftr_uint8_transfer"><span class="command">lemma</span></span> shiftr_uint8_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">‹<span class="main">(</span>cr_uint8 <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> cr_uint8<span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">k</span> <span class="bound">n</span><span class="main">.</span> drop_bit <span class="bound">n</span> <span class="bound">k</span><span class="main">)</span> <span class="main">(&gt;&gt;)</span>›</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> shiftr_eq_drop_bit <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint8 <span class="main">::</span> <span class="quoted">lsb</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">lsb_uint8</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹uint8 <span class="main">⇒</span> bool›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">lsb</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">transfer</span><span class="main">)</span>
  <span class="main">(</span><span class="operator">fact</span> lsb_odd<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint8 <span class="main">::</span> <span class="quoted">msb</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">msb_uint8</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹uint8 <span class="main">⇒</span> bool›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">msb</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint8 <span class="main">::</span> <span class="quoted">set_bit</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">set_bit_uint8</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹uint8 <span class="main">⇒</span> nat <span class="main">⇒</span> bool <span class="main">⇒</span> uint8›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">set_bit</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">standard</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">bit_simps</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint8 <span class="main">::</span> <span class="quoted">bit_comprehension</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">set_bits_uint8</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nat <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> uint8"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"set_bits"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">transfer</span><span class="main">)</span> <span class="main">(</span><span class="operator">fact</span> set_bits_bit_eq<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> bit_uint8.rep_eq lsb_uint8.rep_eq msb_uint8.rep_eq

<span class="keyword1"><span class="command">instantiation</span></span> uint8 <span class="main">::</span> <span class="quoted">equal</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">equal_uint8</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint8 <span class="main">⇒</span> uint8 <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"equal_class.equal"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> equal_eq<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> equal_uint8.rep_eq

<span class="keyword1"><span class="command">instantiation</span></span> uint8 <span class="main">::</span> <span class="quoted">size</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">size_uint8</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint8 <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"size"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> size_uint8.rep_eq

<span class="keyword1"><span class="command">lift_definition</span></span> sshiftr_uint8 <span class="main">::</span> <span class="quoted"><span class="quoted">"uint8 <span class="main">⇒</span> nat <span class="main">⇒</span> uint8"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">&gt;&gt;&gt;</span>"</span> 55<span class="main">)</span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">‹<span class="main">λ</span><span class="bound">w</span> <span class="bound">n</span><span class="main">.</span> signed_drop_bit <span class="bound">n</span> <span class="bound">w</span>›</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> uint8_of_int <span class="main">::</span> <span class="quoted"><span class="quoted">"int <span class="main">⇒</span> uint8"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"word_of_int"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint8_of_nat</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> uint8"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">uint8_of_nat</span> <span class="main">=</span> uint8_of_int <span class="main">∘</span> int"</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> int_of_uint8 <span class="main">::</span> <span class="quoted"><span class="quoted">"uint8 <span class="main">⇒</span> int"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"uint"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> nat_of_uint8 <span class="main">::</span> <span class="quoted"><span class="quoted">"uint8 <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"unat"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">integer_of_uint8</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint8 <span class="main">⇒</span> integer"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">integer_of_uint8</span> <span class="main">=</span> integer_of_int <span class="keyword1">o</span> int_of_uint8"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Use pretty numerals from integer for pretty printing›</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> integer.lifting <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> Uint8 <span class="main">::</span> <span class="quoted"><span class="quoted">"integer <span class="main">⇒</span> uint8"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"word_of_int"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1" id="Uint8-Rep_uint8_numeral"><span class="command">lemma</span></span> Rep_uint8_numeral <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Rep_uint8 <span class="main">(</span>numeral <span class="free">n</span><span class="main">)</span> <span class="main">=</span> numeral <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> one_uint8_def Abs_uint8_inverse numeral.simps plus_uint8_def<span class="main">)</span>

<span class="keyword1" id="Uint8-numeral_uint8_transfer"><span class="command">lemma</span></span> numeral_uint8_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>rel_fun <span class="main">(=)</span> cr_uint8<span class="main">)</span> numeral numeral"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cr_uint8_def<span class="main">)</span>

<span class="keyword1" id="Uint8-numeral_uint8"><span class="command">lemma</span></span> numeral_uint8 <span class="main">[</span><span class="operator">code_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"numeral <span class="free">n</span> <span class="main">=</span> Uint8 <span class="main">(</span>numeral <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Uint8-Rep_uint8_neg_numeral"><span class="command">lemma</span></span> Rep_uint8_neg_numeral <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Rep_uint8 <span class="main">(</span><span class="main">-</span> numeral <span class="free">n</span><span class="main">)</span> <span class="main">=</span> <span class="main">-</span> numeral <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> uminus_uint8_def<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_uint8_inverse<span class="main">)</span>

<span class="keyword1" id="Uint8-neg_numeral_uint8"><span class="command">lemma</span></span> neg_numeral_uint8 <span class="main">[</span><span class="operator">code_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">-</span> numeral <span class="free">n</span> <span class="main">=</span> Uint8 <span class="main">(</span><span class="main">-</span> numeral <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cr_uint8_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Uint8-Abs_uint8_numeral"><span class="command">lemma</span></span> Abs_uint8_numeral <span class="main">[</span><span class="operator">code_post</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Abs_uint8 <span class="main">(</span>numeral <span class="free">n</span><span class="main">)</span> <span class="main">=</span> numeral <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> one_uint8_def numeral.simps plus_uint8_def Abs_uint8_inverse<span class="main">)</span>

<span class="keyword1" id="Uint8-Abs_uint8_0"><span class="command">lemma</span></span> Abs_uint8_0 <span class="main">[</span><span class="operator">code_post</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Abs_uint8 <span class="main">0</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_uint8_def<span class="main">)</span>

<span class="keyword1" id="Uint8-Abs_uint8_1"><span class="command">lemma</span></span> Abs_uint8_1 <span class="main">[</span><span class="operator">code_post</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Abs_uint8 <span class="main">1</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> one_uint8_def<span class="main">)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Code setup›</span></span>

<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">code_module</span></span> Uint8 <span class="main">⇀</span> <span class="main">(</span>SML<span class="main">)</span>
<span class="quoted">‹(* Test that words can handle numbers between 0 and 3 *)
val _ = if 3 &lt;= Word.wordSize then () else raise (Fail ("wordSize less than 3"));

structure Uint8 : sig
  val set_bit : Word8.word -&gt; IntInf.int -&gt; bool -&gt; Word8.word
  val shiftl : Word8.word -&gt; IntInf.int -&gt; Word8.word
  val shiftr : Word8.word -&gt; IntInf.int -&gt; Word8.word
  val shiftr_signed : Word8.word -&gt; IntInf.int -&gt; Word8.word
  val test_bit : Word8.word -&gt; IntInf.int -&gt; bool
end = struct

fun set_bit x n b =
  let val mask = Word8.&lt;&lt; (0wx1, Word.fromLargeInt (IntInf.toLarge n))
  in if b then Word8.orb (x, mask)
     else Word8.andb (x, Word8.notb mask)
  end

fun shiftl x n =
  Word8.&lt;&lt; (x, Word.fromLargeInt (IntInf.toLarge n))

fun shiftr x n =
  Word8.&gt;&gt; (x, Word.fromLargeInt (IntInf.toLarge n))

fun shiftr_signed x n =
  Word8.~&gt;&gt; (x, Word.fromLargeInt (IntInf.toLarge n))

fun test_bit x n =
  Word8.andb (x, Word8.&lt;&lt; (0wx1, Word.fromLargeInt (IntInf.toLarge n))) &lt;&gt; Word8.fromInt 0

end; (* struct Uint8 *)›</span>
<span class="keyword1"><span class="command">code_reserved</span></span> SML Uint8

<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">code_module</span></span> Uint8 <span class="main">⇀</span> <span class="main">(</span>Haskell<span class="main">)</span>
 <span class="quoted">‹module Uint8(Int8, Word8) where

  import Data.Int(Int8)
  import Data.Word(Word8)›</span>
<span class="keyword1"><span class="command">code_reserved</span></span> Haskell Uint8

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Scala provides only signed 8bit numbers, so we use these and 
  implement sign-sensitive operations like comparisons manually.
›</span></span>

<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">code_module</span></span> Uint8 <span class="main">⇀</span> <span class="main">(</span>Scala<span class="main">)</span>
<span class="quoted">‹object Uint8 {

def less(x: Byte, y: Byte) : Boolean =
  if (x &lt; 0) y &lt; 0 &amp;&amp; x &lt; y
  else y &lt; 0 || x &lt; y

def less_eq(x: Byte, y: Byte) : Boolean =
  if (x &lt; 0) y &lt; 0 &amp;&amp; x &lt;= y
  else y &lt; 0 || x &lt;= y

def set_bit(x: Byte, n: BigInt, b: Boolean) : Byte =
  if (b)
    (x | (1 &lt;&lt; n.intValue)).toByte
  else
    (x &amp; (1 &lt;&lt; n.intValue).unary_~).toByte

def shiftl(x: Byte, n: BigInt) : Byte = (x &lt;&lt; n.intValue).toByte

def shiftr(x: Byte, n: BigInt) : Byte = ((x &amp; 255) &gt;&gt;&gt; n.intValue).toByte

def shiftr_signed(x: Byte, n: BigInt) : Byte = (x &gt;&gt; n.intValue).toByte

def test_bit(x: Byte, n: BigInt) : Boolean =
  (x &amp; (1 &lt;&lt; n.intValue)) != 0

} /* object Uint8 */›</span>
<span class="keyword1"><span class="command">code_reserved</span></span> Scala Uint8

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Avoid <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Abs_uint8</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> in generated code, use <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">Rep_uint8'</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> instead. 
  The symbolic implementations for code\_simp use <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Rep_uint8</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.

  The new destructor <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">Rep_uint8'</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is executable.
  As the simplifier is given the [code abstract] equations literally, 
  we cannot implement <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Rep_uint8</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> directly, because that makes code\_simp loop.

  If code generation raises Match, some equation probably contains <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Rep_uint8</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> 
  ([code abstract] equations for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">uint8</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> may use <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Rep_uint8</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> because
  these instances will be folded away.)

  To convert <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="numeral"><span class="numeral">8</span></span> word"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> values into <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">uint8</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, use <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">Abs_uint8'</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">Rep_uint8'</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Rep_uint8'</span> <span class="main">=</span> Rep_uint8"</span></span>

<span class="keyword1" id="Uint8-Rep_uint8'_transfer"><span class="command">lemma</span></span> Rep_uint8'_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"rel_fun cr_uint8 <span class="main">(=)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">)</span> Rep_uint8'"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> Rep_uint8'_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> uint8.rep_transfer<span class="main">)</span>

<span class="keyword1" id="Uint8-Rep_uint8'_code"><span class="command">lemma</span></span> Rep_uint8'_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Rep_uint8' <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">BITS</span> <span class="bound">n</span><span class="main">.</span> bit <span class="free">x</span> <span class="bound">n</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_bits_bit_eq<span class="main">)</span>

<span class="keyword1"><span class="command">lift_definition</span></span> Abs_uint8' <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="numeral">8</span> word <span class="main">⇒</span> uint8"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span> <span class="main">::</span> <span class="numeral">8</span> word<span class="main">.</span> <span class="bound">x</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1" id="Uint8-Abs_uint8'_code"><span class="command">lemma</span></span> Abs_uint8'_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Abs_uint8' <span class="free">x</span> <span class="main">=</span> Uint8 <span class="main">(</span>integer_of_int <span class="main">(</span>uint <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">including</span></span> integer.lifting <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">"term_of_class.term_of <span class="main">::</span> uint8 <span class="main">⇒</span> <span class="main">_</span>"</span></span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Uint8-term_of_uint8_code"><span class="command">lemma</span></span> term_of_uint8_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">TR</span> <span class="main">≡</span> typerep.Typerep"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">bit0</span> <span class="main">≡</span> <span class="keyword1">STR</span> <span class="inner_quoted">''Numeral_Type.bit0''</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"term_of_class.term_of <span class="free">x</span> <span class="main">=</span> 
   Code_Evaluation.App <span class="main">(</span>Code_Evaluation.Const <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Uint8.uint8.Abs_uint8''</span><span class="main">)</span> <span class="main">(</span><span class="free">TR</span> <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''fun''</span><span class="main">)</span> <span class="main">[</span><span class="free">TR</span> <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Word.word''</span><span class="main">)</span> <span class="main">[</span><span class="free">TR</span> <span class="free">bit0</span> <span class="main">[</span><span class="free">TR</span> <span class="free">bit0</span> <span class="main">[</span><span class="free">TR</span> <span class="free">bit0</span> <span class="main">[</span><span class="free">TR</span> <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Numeral_Type.num1''</span><span class="main">)</span> <span class="main">[]</span><span class="main">]</span><span class="main">]</span><span class="main">]</span><span class="main">]</span><span class="main">,</span> <span class="free">TR</span> <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Uint8.uint8''</span><span class="main">)</span> <span class="main">[]</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
       <span class="main">(</span>term_of_class.term_of <span class="main">(</span>Rep_uint8' <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> term_of_anything<span class="main">)</span>

<span class="keyword1" id="Uint8-Uin8_code"><span class="command">lemma</span></span> Uin8_code <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">abstract</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Rep_uint8 <span class="main">(</span>Uint8 <span class="free">i</span><span class="main">)</span> <span class="main">=</span> word_of_int <span class="main">(</span>int_of_integer_symbolic <span class="free">i</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> Uint8_def int_of_integer_symbolic_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_uint8_inverse<span class="main">)</span>

<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">type_constructor</span></span> uint8 <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Word8.word"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"Uint8.Word8"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"Byte"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">Uint8</span> <span class="main">⇀</span> 
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Word8.fromLargeInt (IntInf.toLarge _)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"(Prelude.fromInteger _ :: Uint8.Word8)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell_Quickcheck<span class="main">)</span> <span class="quoted">"(Prelude.fromInteger (Prelude.toInteger _) :: Uint8.Word8)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"_.byteValue"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">::</span> uint8"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"(Word8.fromInt 0)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"(0 :: Uint8.Word8)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"0.toByte"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">::</span> uint8"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"(Word8.fromInt 1)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"(1 :: Uint8.Word8)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"1.toByte"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"plus <span class="main">::</span> uint8 <span class="main">⇒</span> <span class="main">_</span> <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Word8.+ ((_), (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 6 <span class="quoted">"+"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"(_ +/ _).toByte"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"uminus <span class="main">::</span> uint8 <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Word8.~"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"negate"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"(- _).toByte"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"minus <span class="main">::</span> uint8 <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Word8.- ((_), (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 6 <span class="quoted">"-"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"(_ -/ _).toByte"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"times <span class="main">::</span> uint8 <span class="main">⇒</span> <span class="main">_</span> <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Word8.* ((_), (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 7 <span class="quoted">"*"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"(_ */ _).toByte"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"HOL.equal <span class="main">::</span> uint8 <span class="main">⇒</span> <span class="main">_</span> <span class="main">⇒</span> bool"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"!((_ : Word8.word) = _)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="keyword2"><span class="keyword">infix</span></span> 4 <span class="quoted">"=="</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 5 <span class="quoted">"=="</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">class_instance</span></span> uint8 <span class="main">::</span> equal <span class="main">⇀</span> <span class="main">(</span>Haskell<span class="main">)</span> -
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"less_eq <span class="main">::</span> uint8 <span class="main">⇒</span> <span class="main">_</span> <span class="main">⇒</span> bool"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Word8.&lt;= ((_), (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="keyword2"><span class="keyword">infix</span></span> 4 <span class="quoted">"&lt;="</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"Uint8.less'_eq"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"less <span class="main">::</span> uint8 <span class="main">⇒</span> <span class="main">_</span> <span class="main">⇒</span> bool"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Word8.&lt; ((_), (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="keyword2"><span class="keyword">infix</span></span> 4 <span class="quoted">"&lt;"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"Uint8.less"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">NOT</span> <span class="main">::</span> uint8 <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Word8.notb"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"Data'_Bits.complement"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"_.unary'_~.toByte"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">(AND)</span> <span class="main">::</span> uint8 <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Word8.andb ((_),/ (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 7 <span class="quoted">"Data_Bits..&amp;."</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"(_ &amp; _).toByte"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">(OR)</span> <span class="main">::</span> uint8 <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Word8.orb ((_),/ (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 5 <span class="quoted">"Data_Bits..|."</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"(_ | _).toByte"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">(XOR)</span> <span class="main">::</span> uint8 <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Word8.xorb ((_),/ (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"Data'_Bits.xor"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"(_ ^ _).toByte"</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint8_divmod</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint8 <span class="main">⇒</span> uint8 <span class="main">⇒</span> uint8 <span class="main">×</span> uint8"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">uint8_divmod</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">(</span>undefined <span class="main">(</span><span class="keyword1">(div)</span> <span class="main">::</span> uint8 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="main">0</span> <span class="main">::</span> uint8<span class="main">)</span><span class="main">,</span> undefined <span class="main">(</span><span class="keyword1">(mod)</span> <span class="main">::</span> uint8 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="main">0</span> <span class="main">::</span> uint8<span class="main">)</span><span class="main">)</span> 
  <span class="keyword1">else</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">div</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">mod</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint8_div</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint8 <span class="main">⇒</span> uint8 <span class="main">⇒</span> uint8"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">uint8_div</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> fst <span class="main">(</span>uint8_divmod <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint8_mod</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint8 <span class="main">⇒</span> uint8 <span class="main">⇒</span> uint8"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">uint8_mod</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> snd <span class="main">(</span>uint8_divmod <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Uint8-div_uint8_code"><span class="command">lemma</span></span> div_uint8_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="keyword1">div</span> <span class="free">y</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">y</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> uint8_div <span class="free">x</span> <span class="free">y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">including</span></span> undefined_transfer <span class="keyword1"><span class="command">unfolding</span></span> uint8_divmod_def uint8_div_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> word_div_def<span class="main">)</span>

<span class="keyword1" id="Uint8-mod_uint8_code"><span class="command">lemma</span></span> mod_uint8_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="keyword1">mod</span> <span class="free">y</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">y</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="free">x</span> <span class="keyword1">else</span> uint8_mod <span class="free">x</span> <span class="free">y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">including</span></span> undefined_transfer <span class="keyword1"><span class="command">unfolding</span></span> uint8_mod_def uint8_divmod_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> word_mod_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint8_sdiv</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint8 <span class="main">⇒</span> uint8 <span class="main">⇒</span> uint8"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">uint8_sdiv</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span>
   <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> undefined <span class="main">(</span><span class="keyword1">(div)</span> <span class="main">::</span> uint8 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="main">0</span> <span class="main">::</span> uint8<span class="main">)</span>
    <span class="keyword1">else</span> Abs_uint8 <span class="main">(</span>Rep_uint8 <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">sdiv</span> Rep_uint8 <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">div0_uint8</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint8 <span class="main">⇒</span> uint8"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">div0_uint8</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> undefined <span class="main">(</span><span class="keyword1">(div)</span> <span class="main">::</span> uint8 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="main">0</span> <span class="main">::</span> uint8<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">abort</span><span class="main"><span class="main">:</span></span> <span class="quoted">div0_uint8</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">mod0_uint8</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint8 <span class="main">⇒</span> uint8"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">mod0_uint8</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> undefined <span class="main">(</span><span class="keyword1">(mod)</span> <span class="main">::</span> uint8 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="main">0</span> <span class="main">::</span> uint8<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">abort</span><span class="main"><span class="main">:</span></span> <span class="quoted">mod0_uint8</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Uint8-uint8_divmod_code"><span class="command">lemma</span></span> uint8_divmod_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"uint8_divmod <span class="free">x</span> <span class="free">y</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="numeral">0x80</span> <span class="main">≤</span> <span class="free">y</span> <span class="keyword1">then</span> <span class="keyword1">if</span> <span class="free">x</span> <span class="main">&lt;</span> <span class="free">y</span> <span class="keyword1">then</span> <span class="main">(</span><span class="main">0</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">(</span><span class="main">1</span><span class="main">,</span> <span class="free">x</span> <span class="main">-</span> <span class="free">y</span><span class="main">)</span>
   <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="free">y</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">(</span>div0_uint8 <span class="free">x</span><span class="main">,</span> mod0_uint8 <span class="free">x</span><span class="main">)</span>
   <span class="keyword1">else</span> <span class="keyword1">let</span> <span class="bound">q</span> <span class="main">=</span> <span class="main">(</span>uint8_sdiv <span class="main">(</span><span class="free">x</span> <span class="main">&gt;&gt;</span> <span class="main">1</span><span class="main">)</span> <span class="free">y</span><span class="main">)</span> <span class="main">&lt;&lt;</span> <span class="main">1</span><span class="main">;</span>
            <span class="bound">r</span> <span class="main">=</span> <span class="free">x</span> <span class="main">-</span> <span class="bound">q</span> <span class="main">*</span> <span class="free">y</span>
        <span class="keyword1">in</span> <span class="keyword1">if</span> <span class="bound">r</span> <span class="main">≥</span> <span class="free">y</span> <span class="keyword1">then</span> <span class="main">(</span><span class="bound">q</span> <span class="main">+</span> <span class="main">1</span><span class="main">,</span> <span class="bound">r</span> <span class="main">-</span> <span class="free">y</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">(</span><span class="bound">q</span><span class="main">,</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">including</span></span> undefined_transfer <span class="keyword1"><span class="command">unfolding</span></span> uint8_divmod_def uint8_sdiv_def div0_uint8_def mod0_uint8_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> divmod_via_sdivmod<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> shiftl_eq_push_bit shiftr_eq_drop_bit<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Uint8-uint8_sdiv_code"><span class="command">lemma</span></span> uint8_sdiv_code <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">abstract</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Rep_uint8 <span class="main">(</span>uint8_sdiv <span class="free">x</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span>
   <span class="main">(</span><span class="keyword1">if</span> <span class="free">y</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> Rep_uint8 <span class="main">(</span>undefined <span class="main">(</span><span class="keyword1">(div)</span> <span class="main">::</span> uint8 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free">x</span> <span class="main">(</span><span class="main">0</span> <span class="main">::</span> uint8<span class="main">)</span><span class="main">)</span>
    <span class="keyword1">else</span> Rep_uint8 <span class="free">x</span> <span class="keyword1">sdiv</span> Rep_uint8 <span class="free">y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> uint8_sdiv_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_uint8_inverse<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Note that we only need a translation for signed division, but not for the remainder
  because <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> uint8_divmod_code<span class="antiquote"><span class="antiquote">}</span></span></span></span> computes both with division only.
›</span></span>

<span class="keyword1"><span class="command">code_printing</span></span>
  <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint8_div</span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Word8.div ((_), (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"Prelude.div"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint8_mod</span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Word8.mod ((_), (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"Prelude.mod"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint8_divmod</span> <span class="main">⇀</span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"divmod"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint8_sdiv</span> <span class="main">⇀</span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"(_ '/ _).toByte"</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint8_test_bit</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint8 <span class="main">⇒</span> integer <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">uint8_test_bit</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">∨</span> <span class="numeral">7</span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">then</span> undefined <span class="main">(</span>test_bit <span class="main">::</span> uint8 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span>
   <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">!!</span> <span class="main">(</span>nat_of_integer <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Uint8-bit_uint8_code"><span class="command">lemma</span></span> bit_uint8_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"bit <span class="free">x</span> <span class="free">n</span> <span class="main">⟷</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="numeral">8</span> <span class="main">∧</span> uint8_test_bit <span class="free">x</span> <span class="main">(</span>integer_of_nat <span class="free">n</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> undefined_transfer integer.lifting <span class="keyword1"><span class="command">unfolding</span></span> uint8_test_bit_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="Uint8-uint8_test_bit_code"><span class="command">lemma</span></span> uint8_test_bit_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"uint8_test_bit <span class="free">w</span> <span class="free">n</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">∨</span> <span class="numeral">7</span> <span class="main">&lt;</span> <span class="free">n</span> <span class="keyword1">then</span> undefined <span class="main">(</span>test_bit <span class="main">::</span> uint8 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free">w</span> <span class="free">n</span> <span class="keyword1">else</span> Rep_uint8 <span class="free">w</span> <span class="main">!!</span> nat_of_integer <span class="free">n</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> uint8_test_bit_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bit_uint8.rep_eq test_bit_eq_bit<span class="main">)</span>

<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint8_test_bit</span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Uint8.test'_bit"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"Data'_Bits.testBitBounded"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"Uint8.test'_bit"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Eval<span class="main">)</span> <span class="quoted">"(fn x =&gt; fn i =&gt; if i &lt; 0 orelse i &gt;= 8 then raise (Fail \"argument to uint8'_test'_bit out of bounds\") else Uint8.test'_bit x i)"</span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint8_set_bit</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint8 <span class="main">⇒</span> integer <span class="main">⇒</span> bool <span class="main">⇒</span> uint8"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">uint8_set_bit</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">∨</span> <span class="numeral">7</span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">then</span> undefined <span class="main">(</span>set_bit <span class="main">::</span> uint8 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span>
   <span class="keyword1">else</span> set_bit <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span>nat_of_integer <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Uint8-set_bit_uint8_code"><span class="command">lemma</span></span> set_bit_uint8_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"set_bit <span class="free">x</span> <span class="free">n</span> <span class="free">b</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="numeral">8</span> <span class="keyword1">then</span> uint8_set_bit <span class="free">x</span> <span class="main">(</span>integer_of_nat <span class="free">n</span><span class="main">)</span> <span class="free">b</span> <span class="keyword1">else</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">including</span></span> undefined_transfer integer.lifting <span class="keyword1"><span class="command">unfolding</span></span> uint8_set_bit_def
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">transfer</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> conj_cong <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_less set_bit_beyond word_size<span class="main">)</span>

<span class="keyword1" id="Uint8-uint8_set_bit_code"><span class="command">lemma</span></span> uint8_set_bit_code <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">abstract</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Rep_uint8 <span class="main">(</span>uint8_set_bit <span class="free">w</span> <span class="free">n</span> <span class="free">b</span><span class="main">)</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">∨</span> <span class="numeral">7</span> <span class="main">&lt;</span> <span class="free">n</span> <span class="keyword1">then</span> Rep_uint8 <span class="main">(</span>undefined <span class="main">(</span>set_bit <span class="main">::</span> uint8 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free">w</span> <span class="free">n</span> <span class="free">b</span><span class="main">)</span>
   <span class="keyword1">else</span> set_bit <span class="main">(</span>Rep_uint8 <span class="free">w</span><span class="main">)</span> <span class="main">(</span>nat_of_integer <span class="free">n</span><span class="main">)</span> <span class="free">b</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">including</span></span> undefined_transfer <span class="keyword1"><span class="command">unfolding</span></span> uint8_set_bit_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint8_set_bit</span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Uint8.set'_bit"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"Data'_Bits.setBitBounded"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"Uint8.set'_bit"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Eval<span class="main">)</span> <span class="quoted">"(fn x =&gt; fn i =&gt; fn b =&gt; if i &lt; 0 orelse i &gt;= 8 then raise (Fail \"argument to uint8'_set'_bit out of bounds\") else Uint8.set'_bit x i b)"</span>


<span class="keyword1"><span class="command">lift_definition</span></span> uint8_set_bits <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nat <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> uint8 <span class="main">⇒</span> nat <span class="main">⇒</span> uint8"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">set_bits_aux</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1" id="Uint8-uint8_set_bits_code"><span class="command">lemma</span></span> uint8_set_bits_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"uint8_set_bits <span class="free">f</span> <span class="free">w</span> <span class="free">n</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="free">w</span> 
   <span class="keyword1">else</span> <span class="keyword1">let</span> <span class="bound">n'</span> <span class="main">=</span> <span class="free">n</span> <span class="main">-</span> <span class="main">1</span> <span class="keyword1">in</span> uint8_set_bits <span class="free">f</span> <span class="main">(</span>push_bit <span class="main">1</span> <span class="free">w</span> <span class="keyword1">OR</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">f</span> <span class="bound">n'</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span> <span class="bound">n'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">transfer</span> <span class="quasi_keyword">fixing</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> shiftl_eq_push_bit<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Uint8-set_bits_uint8"><span class="command">lemma</span></span> set_bits_uint8 <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">BITS</span> <span class="bound">n</span><span class="main">.</span> <span class="free">f</span> <span class="bound">n</span><span class="main">)</span> <span class="main">=</span> uint8_set_bits <span class="free">f</span> <span class="main">0</span> <span class="numeral">8</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_bits_conv_set_bits_aux<span class="main">)</span>


<span class="keyword1" id="Uint8-lsb_code"><span class="command">lemma</span></span> lsb_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span> <span class="main">::</span> <span class="quoted">uint8</span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lsb <span class="free">x</span> <span class="main">=</span> <span class="free">x</span> <span class="main">!!</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lsb_odd<span class="main">)</span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint8_shiftl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint8 <span class="main">⇒</span> integer <span class="main">⇒</span> uint8"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">uint8_shiftl</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">∨</span> <span class="numeral">8</span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">then</span> undefined <span class="main">(</span>push_bit <span class="main">::</span> nat <span class="main">⇒</span> uint8 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">else</span> push_bit <span class="main">(</span>nat_of_integer <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Uint8-shiftl_uint8_code"><span class="command">lemma</span></span> shiftl_uint8_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"push_bit <span class="free">n</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="numeral">8</span> <span class="keyword1">then</span> uint8_shiftl <span class="free">x</span> <span class="main">(</span>integer_of_nat <span class="free">n</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> undefined_transfer integer.lifting <span class="keyword1"><span class="command">unfolding</span></span> uint8_shiftl_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Uint8-uint8_shiftl_code"><span class="command">lemma</span></span> uint8_shiftl_code <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">abstract</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Rep_uint8 <span class="main">(</span>uint8_shiftl <span class="free">w</span> <span class="free">n</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">∨</span> <span class="numeral">8</span> <span class="main">≤</span> <span class="free">n</span> <span class="keyword1">then</span> Rep_uint8 <span class="main">(</span>undefined <span class="main">(</span>push_bit <span class="main">::</span> nat <span class="main">⇒</span> uint8 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free">w</span> <span class="free">n</span><span class="main">)</span>
   <span class="keyword1">else</span> push_bit <span class="main">(</span>nat_of_integer <span class="free">n</span><span class="main">)</span> <span class="main">(</span>Rep_uint8 <span class="free">w</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> undefined_transfer <span class="keyword1"><span class="command">unfolding</span></span> uint8_shiftl_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint8_shiftl</span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Uint8.shiftl"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"Data'_Bits.shiftlBounded"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"Uint8.shiftl"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Eval<span class="main">)</span> <span class="quoted">"(fn x =&gt; fn i =&gt; if i &lt; 0 orelse i &gt;= 8 then raise (Fail \"argument to uint8'_shiftl out of bounds\") else Uint8.shiftl x i)"</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint8_shiftr</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint8 <span class="main">⇒</span> integer <span class="main">⇒</span> uint8"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">uint8_shiftr</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">∨</span> <span class="numeral">8</span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">then</span> undefined <span class="main">(</span>shiftr <span class="main">::</span> uint8 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">&gt;&gt;</span> <span class="main">(</span>nat_of_integer <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Uint8-shiftr_uint8_code"><span class="command">lemma</span></span> shiftr_uint8_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"drop_bit <span class="free">n</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="numeral">8</span> <span class="keyword1">then</span> uint8_shiftr <span class="free">x</span> <span class="main">(</span>integer_of_nat <span class="free">n</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> undefined_transfer integer.lifting <span class="keyword1"><span class="command">unfolding</span></span> uint8_shiftr_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Uint8-uint8_shiftr_code"><span class="command">lemma</span></span> uint8_shiftr_code <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">abstract</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Rep_uint8 <span class="main">(</span>uint8_shiftr <span class="free">w</span> <span class="free">n</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">∨</span> <span class="numeral">8</span> <span class="main">≤</span> <span class="free">n</span> <span class="keyword1">then</span> Rep_uint8 <span class="main">(</span>undefined <span class="main">(</span>shiftr <span class="main">::</span> uint8 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free">w</span> <span class="free">n</span><span class="main">)</span> 
   <span class="keyword1">else</span> drop_bit <span class="main">(</span>nat_of_integer <span class="free">n</span><span class="main">)</span> <span class="main">(</span>Rep_uint8 <span class="free">w</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">including</span></span> undefined_transfer <span class="keyword1"><span class="command">unfolding</span></span> uint8_shiftr_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint8_shiftr</span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Uint8.shiftr"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"Data'_Bits.shiftrBounded"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"Uint8.shiftr"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Eval<span class="main">)</span> <span class="quoted">"(fn x =&gt; fn i =&gt; if i &lt; 0 orelse i &gt;= 8 then raise (Fail \"argument to uint8'_shiftr out of bounds\") else Uint8.shiftr x i)"</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint8_sshiftr</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint8 <span class="main">⇒</span> integer <span class="main">⇒</span> uint8"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">uint8_sshiftr</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">∨</span> <span class="numeral">8</span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">then</span> undefined sshiftr_uint8 <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">else</span> sshiftr_uint8 <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span>nat_of_integer <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Uint8-sshiftr_uint8_code"><span class="command">lemma</span></span> sshiftr_uint8_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">&gt;&gt;&gt;</span> <span class="free">n</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="numeral">8</span> <span class="keyword1">then</span> uint8_sshiftr <span class="free">x</span> <span class="main">(</span>integer_of_nat <span class="free">n</span><span class="main">)</span> <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="free">x</span> <span class="main">!!</span> <span class="numeral">7</span> <span class="keyword1">then</span> <span class="main">-</span><span class="main">1</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> undefined_transfer integer.lifting <span class="keyword1"><span class="command">unfolding</span></span> uint8_sshiftr_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_less signed_drop_bit_beyond word_size<span class="main">)</span>

<span class="keyword1" id="Uint8-uint8_sshiftr_code"><span class="command">lemma</span></span> uint8_sshiftr_code <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">abstract</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Rep_uint8 <span class="main">(</span>uint8_sshiftr <span class="free">w</span> <span class="free">n</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">∨</span> <span class="numeral">8</span> <span class="main">≤</span> <span class="free">n</span> <span class="keyword1">then</span> Rep_uint8 <span class="main">(</span>undefined sshiftr_uint8 <span class="free">w</span> <span class="free">n</span><span class="main">)</span>
   <span class="keyword1">else</span> signed_drop_bit <span class="main">(</span>nat_of_integer <span class="free">n</span><span class="main">)</span> <span class="main">(</span>Rep_uint8 <span class="free">w</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> undefined_transfer <span class="keyword1"><span class="command">unfolding</span></span> uint8_sshiftr_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint8_sshiftr</span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Uint8.shiftr'_signed"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> 
    <span class="quoted">"(Prelude.fromInteger (Prelude.toInteger (Data'_Bits.shiftrBounded (Prelude.fromInteger (Prelude.toInteger _) :: Uint8.Int8) _)) :: Uint8.Word8)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"Uint8.shiftr'_signed"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Eval<span class="main">)</span> <span class="quoted">"(fn x =&gt; fn i =&gt; if i &lt; 0 orelse i &gt;= 8 then raise (Fail \"argument to uint8'_sshiftr out of bounds\") else Uint8.shiftr'_signed x i)"</span>

<span class="keyword1" id="Uint8-uint8_msb_test_bit"><span class="command">lemma</span></span> uint8_msb_test_bit<span class="main">:</span> <span class="quoted"><span class="quoted">"msb <span class="free">x</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">x</span> <span class="main">::</span> uint8<span class="main">)</span> <span class="main">!!</span> <span class="numeral">7</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> msb_word_iff_bit<span class="main">)</span>

<span class="keyword1" id="Uint8-msb_uint16_code"><span class="command">lemma</span></span> msb_uint16_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"msb <span class="free">x</span> <span class="main">⟷</span> uint8_test_bit <span class="free">x</span> <span class="numeral">7</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> uint8_test_bit_def uint8_msb_test_bit<span class="main">)</span>

<span class="keyword1" id="Uint8-uint8_of_int_code"><span class="command">lemma</span></span> uint8_of_int_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"uint8_of_int <span class="free">i</span> <span class="main">=</span> Uint8 <span class="main">(</span>integer_of_int <span class="free">i</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">including</span></span> integer.lifting <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Uint8-int_of_uint8_code"><span class="command">lemma</span></span> int_of_uint8_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"int_of_uint8 <span class="free">x</span> <span class="main">=</span> int_of_integer <span class="main">(</span>integer_of_uint8 <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> integer_of_uint8_def<span class="main">)</span>

<span class="keyword1" id="Uint8-nat_of_uint8_code"><span class="command">lemma</span></span> nat_of_uint8_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"nat_of_uint8 <span class="free">x</span> <span class="main">=</span> nat_of_integer <span class="main">(</span>integer_of_uint8 <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> integer_of_uint8_def <span class="keyword1"><span class="command">including</span></span> integer.lifting <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">integer_of_uint8_signed</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint8 <span class="main">⇒</span> integer"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">integer_of_uint8_signed</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">!!</span> <span class="numeral">7</span> <span class="keyword1">then</span> undefined integer_of_uint8 <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">else</span> integer_of_uint8 <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Uint8-integer_of_uint8_signed_code"><span class="command">lemma</span></span> integer_of_uint8_signed_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"integer_of_uint8_signed <span class="free">n</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> bit <span class="free">n</span> <span class="numeral">7</span> <span class="keyword1">then</span> undefined integer_of_uint8 <span class="free">n</span> <span class="keyword1">else</span> integer_of_int <span class="main">(</span>uint <span class="main">(</span>Rep_uint8' <span class="free">n</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> integer_of_uint8_signed_def integer_of_uint8_def
<span class="keyword1"><span class="command">including</span></span> undefined_transfer <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Uint8-integer_of_uint8_code"><span class="command">lemma</span></span> integer_of_uint8_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"integer_of_uint8 <span class="free">n</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> bit <span class="free">n</span> <span class="numeral">7</span> <span class="keyword1">then</span> integer_of_uint8_signed <span class="main">(</span><span class="free">n</span> <span class="keyword1">AND</span> <span class="numeral">0x7F</span><span class="main">)</span> <span class="keyword1">OR</span> <span class="numeral">0x80</span> <span class="keyword1">else</span> integer_of_uint8_signed <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="numeral">0x7F</span> <span class="main">::</span> uint8<span class="main">)</span> <span class="main">=</span> mask <span class="numeral">7</span>›</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mask_eq_exp_minus_1<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">‹<span class="free">n</span> <span class="keyword1">AND</span> <span class="numeral">0x7F</span> <span class="main">=</span> take_bit <span class="numeral">7</span> <span class="free">n</span>›</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> take_bit_eq_mask<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> **<span class="main">:</span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="numeral">0x80</span> <span class="main">::</span> int<span class="main">)</span> <span class="main">=</span> <span class="numeral">2</span> <span class="main">^</span> <span class="numeral">7</span>›</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> integer_of_uint8_def integer_of_uint8_signed_def o_def *
  <span class="keyword1"><span class="command">including</span></span> undefined_transfer integer.lifting
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bit_take_bit_iff uint_take_bit_eq<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> bit_eqI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bit_uint_iff bit_or_iff bit_take_bit_iff<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> ** bit_exp_iff<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">code_printing</span></span>
  <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"integer_of_uint8"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"IntInf.fromLarge (Word8.toLargeInt _)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"Prelude.toInteger"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"integer_of_uint8_signed"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"BigInt"</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Quickcheck setup›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint8_of_natural</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"natural <span class="main">⇒</span> uint8"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">uint8_of_natural</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≡</span> Uint8 <span class="main">(</span>integer_of_natural <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint8 <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">{</span>random<span class="main">,</span> exhaustive<span class="main">,</span> full_exhaustive<span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">random_uint8</span></span> <span class="main">≡</span> qc_random_cnv uint8_of_natural"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">exhaustive_uint8</span></span> <span class="main">≡</span> qc_exhaustive_cnv uint8_of_natural"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">full_exhaustive_uint8</span></span> <span class="main">≡</span> qc_full_exhaustive_cnv uint8_of_natural"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint8 <span class="main">::</span> <span class="quoted">narrowing</span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> quickcheck_narrowing_samples
  <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">i</span><span class="main">.</span> <span class="keyword1">let</span> <span class="bound">x</span> <span class="main">=</span> Uint8 <span class="bound">i</span> <span class="keyword1">in</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="numeral">0xFF</span> <span class="main">-</span> <span class="bound">x</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span>"</span></span>
  <span class="quoted"><span class="quoted">"Typerep.Typerep <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Uint8.uint8''</span><span class="main">)</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">narrowing_uint8</span></span> <span class="free"><span class="bound"><span class="entity">d</span></span></span> <span class="main">=</span> qc_narrowing_drawn_from <span class="main">(</span>narrowing_samples <span class="free"><span class="bound"><span class="entity">d</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">d</span></span></span>"</span></span>
<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">"partial_term_of <span class="main">::</span> uint8 itself <span class="main">⇒</span> <span class="main">_</span>"</span></span><span class="main">]</span><span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> partial_term_of_uint8 <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> partial_term_of_code

<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">no_notation</span></span> sshiftr_uint8 <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">&gt;&gt;&gt;</span>"</span> 55<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Uint">
<div class="head">
<h1>Theory Uint</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Uint.thy
    Author:     Peter Lammich, TU Munich
    Author:     Andreas Lochbihler, ETH Zurich
*)</span>

<span class="keyword1"><span class="command">chapter</span></span> <span class="quoted"><span class="plain_text">‹Unsigned words of default size›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Uint <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Code_Target_Word_Base.html">Code_Target_Word_Base</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  This theory provides access to words in the target languages of the code generator
  whose bit width is the default of the target language. To that end, the type <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>uint›</span></span></span></span>
  models words of width <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>dflt_size›</span></span></span></span>, but <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>dflt_size›</span></span></span></span> is known only to be positive.

  Usage restrictions:
  Default-size words (type <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>uint›</span></span></span></span>) cannot be used for evaluation, because 
  the results depend on the particular choice of word size in the target language
  and implementation. Symbolic evaluation has not yet been set up for <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>uint›</span></span></span></span>.
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The default size type›</span></span>
<span class="keyword1"><span class="command">typedecl</span></span> dflt_size

<span class="keyword1"><span class="command">instantiation</span></span> dflt_size <span class="main">::</span> <span class="quoted">typerep</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"typerep_class.typerep <span class="main">≡</span>  <span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main">::</span> dflt_size itself<span class="main">.</span> Typerep.Typerep <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Uint.dflt_size''</span><span class="main">)</span> <span class="main">[]</span>"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">consts</span></span> dflt_size_aux <span class="main">::</span> <span class="quoted"><span class="quoted">"nat"</span></span>
<span class="keyword1"><span class="command">specification</span></span> <span class="main">(</span><span class="quoted">dflt_size_aux</span><span class="main">)</span> dflt_size_aux_g0<span class="main">:</span> <span class="quoted"><span class="quoted">"dflt_size_aux <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">hide_fact</span></span> dflt_size_aux_def

<span class="keyword1"><span class="command">instantiation</span></span> dflt_size <span class="main">::</span> <span class="quoted">len</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">len_of_dflt_size</span></span> <span class="main">(</span><span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">::</span> dflt_size itself<span class="main">)</span> <span class="main">≡</span> dflt_size_aux"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro_classes</span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> len_of_dflt_size_def dflt_size_aux_g0<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">dflt_size</span> <span class="main">≡</span> len_of <span class="main">(</span><span class="keyword1">TYPE</span> <span class="main">(</span>dflt_size<span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> integer.lifting <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> dflt_size_integer <span class="main">::</span> <span class="quoted">integer</span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"int dflt_size"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">declare</span></span> dflt_size_integer_def<span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">del</span><span class="main">]</span>
  <span class="comment1">― ‹The code generator will substitute a machine-dependent value for this constant›</span>

<span class="keyword1" id="Uint-dflt_size_by_int"><span class="command">lemma</span></span> dflt_size_by_int<span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"dflt_size <span class="main">=</span> nat_of_integer dflt_size_integer"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Uint-dflt_size"><span class="command">lemma</span></span> dflt_size<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"dflt_size <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
  <span class="quoted"><span class="quoted">"dflt_size <span class="main">≥</span> Suc <span class="main">0</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">¬</span> dflt_size <span class="main">&lt;</span> Suc <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> len_gt_0<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'a</span><span class="main"><span class="main">=</span></span><span class="quoted">dflt_size</span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> len_gt_0<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">declare</span></span> prod.Quotient<span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Type definition and primitive operations›</span></span>

<span class="keyword1"><span class="command">typedef</span></span> uint <span class="main">=</span> <span class="quoted"><span class="quoted">"UNIV <span class="main">::</span> dflt_size word set"</span></span> <span class="keyword1"><span class="command">..</span></span> 

<span class="keyword1"><span class="command">setup_lifting</span></span> type_definition_uint

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Use an abstract type for code generation to disable pattern matching on <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Abs_uint</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>
<span class="keyword1"><span class="command">declare</span></span> Rep_uint_inverse<span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">abstype</span><span class="main">]</span>

<span class="keyword1"><span class="command">declare</span></span> Quotient_uint<span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span>

<span class="keyword1"><span class="command">instantiation</span></span> uint <span class="main">::</span> <span class="quoted">comm_ring_1</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">zero_uint</span> <span class="main">::</span> <span class="quoted">uint</span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">::</span> dflt_size word"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">one_uint</span> <span class="main">::</span> <span class="quoted">uint</span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">plus_uint</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint <span class="main">⇒</span> uint <span class="main">⇒</span> uint"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(+)</span> <span class="main">::</span> dflt_size word <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">minus_uint</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint <span class="main">⇒</span> uint <span class="main">⇒</span> uint"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(-)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">uminus_uint</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint <span class="main">⇒</span> uint"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">uminus</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">times_uint</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint <span class="main">⇒</span> uint <span class="main">⇒</span> uint"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(*)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">transfer</span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">algebra_simps</span></span><span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint <span class="main">::</span> <span class="quoted">semiring_modulo</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">divide_uint</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint <span class="main">⇒</span> uint <span class="main">⇒</span> uint"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">(div)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">modulo_uint</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint <span class="main">⇒</span> uint <span class="main">⇒</span> uint"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">(mod)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">transfer</span><span class="main">)</span> <span class="main">(</span><span class="operator">fact</span> word_mod_div_equality<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint <span class="main">::</span> <span class="quoted">linorder</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">less_uint</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint <span class="main">⇒</span> uint <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(&lt;)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">less_eq_uint</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint <span class="main">⇒</span> uint <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(≤)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">transfer</span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_le_not_le linear<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> less_uint.rep_eq less_eq_uint.rep_eq

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax
  <span class="keyword2"><span class="keyword">notes</span></span>
    transfer_rule_of_bool <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span>
    transfer_rule_numeral <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> cr_uint<span class="main">)</span> of_bool of_bool"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Uint-transfer_rule_numeral_uint"><span class="command">lemma</span></span> transfer_rule_numeral_uint <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> cr_uint<span class="main">)</span> numeral numeral"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">‹<span class="main">(</span>cr_uint <span class="main">===&gt;</span> <span class="main">(⟷)</span><span class="main">)</span> even <span class="main">(</span><span class="keyword1">(dvd)</span> <span class="numeral">2</span> <span class="main">::</span> uint <span class="main">⇒</span> bool<span class="main">)</span>›</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> dvd_def<span class="main">)</span> <span class="operator">transfer_prover</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint <span class="main">::</span> <span class="quoted">semiring_bits</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">bit_uint</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹uint <span class="main">⇒</span> nat <span class="main">⇒</span> bool›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">bit</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">instance</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">transfer</span><span class="main">)</span>
    <span class="main">(</span><span class="operator">fact</span> bit_iff_odd even_iff_mod_2_eq_zero odd_iff_mod_2_eq_one odd_one bits_induct
       bits_div_0 bits_div_by_1 bits_mod_div_trivial even_succ_div_2
       even_mask_div_iff exp_div_exp_eq div_exp_eq mod_exp_eq mult_exp_mod_exp_eq
       div_exp_mod_exp_eq even_mult_exp_div_exp_iff<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint <span class="main">::</span> <span class="quoted">semiring_bit_shifts</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">push_bit_uint</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹nat <span class="main">⇒</span> uint <span class="main">⇒</span> uint›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">push_bit</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">drop_bit_uint</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹nat <span class="main">⇒</span> uint <span class="main">⇒</span> uint›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">drop_bit</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">take_bit_uint</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹nat <span class="main">⇒</span> uint <span class="main">⇒</span> uint›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">take_bit</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">transfer</span><span class="main">)</span>
  <span class="main">(</span><span class="operator">fact</span> push_bit_eq_mult drop_bit_eq_div take_bit_eq_mod<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint <span class="main">::</span> <span class="quoted">ring_bit_operations</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">not_uint</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹uint <span class="main">⇒</span> uint›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="keyword1">NOT</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">and_uint</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹uint <span class="main">⇒</span> uint <span class="main">⇒</span> uint›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">‹<span class="keyword1">(AND)</span>›</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">or_uint</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹uint <span class="main">⇒</span> uint <span class="main">⇒</span> uint›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">‹<span class="keyword1">(OR)</span>›</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">xor_uint</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹uint <span class="main">⇒</span> uint <span class="main">⇒</span> uint›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">‹<span class="keyword1">(XOR)</span>›</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">mask_uint</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹nat <span class="main">⇒</span> uint›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">mask</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">transfer</span><span class="main">)</span>
  <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bit_and_iff bit_or_iff bit_xor_iff bit_not_iff minus_eq_not_minus_1 mask_eq_decr_exp<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">‹take_bit <span class="free">n</span> <span class="free">a</span> <span class="main">=</span> <span class="free">a</span> <span class="keyword1">AND</span> mask <span class="free">n</span>›</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">a</span> <span class="main">::</span> <span class="quoted">uint</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fact</span> take_bit_eq_mask<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">‹mask <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="main">=</span> push_bit <span class="free">n</span> <span class="main">(</span><span class="main">1</span> <span class="main">::</span> uint<span class="main">)</span> <span class="keyword1">OR</span> mask <span class="free">n</span>›</span></span>
  <span class="quoted"><span class="quoted">‹mask <span class="main">0</span> <span class="main">=</span> <span class="main">(</span><span class="main">0</span> <span class="main">::</span> uint<span class="main">)</span>›</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mask_Suc_exp push_bit_of_1<span class="main">)</span>

<span class="keyword1"><span class="command">instance</span></span> uint <span class="main">::</span> <span class="quoted">semiring_bit_syntax</span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Uint-test_bit_uint_transfer"><span class="command">lemma</span></span> test_bit_uint_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">‹<span class="main">(</span>cr_uint <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> bit <span class="main">(!!)</span>›</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> test_bit_eq_bit <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Uint-shiftl_uint_transfer"><span class="command">lemma</span></span> shiftl_uint_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">‹<span class="main">(</span>cr_uint <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> cr_uint<span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">k</span> <span class="bound">n</span><span class="main">.</span> push_bit <span class="bound">n</span> <span class="bound">k</span><span class="main">)</span> <span class="main">(&lt;&lt;)</span>›</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> shiftl_eq_push_bit <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Uint-shiftr_uint_transfer"><span class="command">lemma</span></span> shiftr_uint_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">‹<span class="main">(</span>cr_uint <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> cr_uint<span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">k</span> <span class="bound">n</span><span class="main">.</span> drop_bit <span class="bound">n</span> <span class="bound">k</span><span class="main">)</span> <span class="main">(&gt;&gt;)</span>›</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> shiftr_eq_drop_bit <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint <span class="main">::</span> <span class="quoted">lsb</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">lsb_uint</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹uint <span class="main">⇒</span> bool›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">lsb</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">transfer</span><span class="main">)</span>
  <span class="main">(</span><span class="operator">fact</span> lsb_odd<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint <span class="main">::</span> <span class="quoted">msb</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">msb_uint</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹uint <span class="main">⇒</span> bool›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">msb</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint <span class="main">::</span> <span class="quoted">set_bit</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">set_bit_uint</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹uint <span class="main">⇒</span> nat <span class="main">⇒</span> bool <span class="main">⇒</span> uint›</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">set_bit</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">standard</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">bit_simps</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint <span class="main">::</span> <span class="quoted">bit_comprehension</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">set_bits_uint</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nat <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> uint"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"set_bits"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">transfer</span><span class="main">)</span> <span class="main">(</span><span class="operator">fact</span> set_bits_bit_eq<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> bit_uint.rep_eq lsb_uint.rep_eq msb_uint.rep_eq

<span class="keyword1"><span class="command">instantiation</span></span> uint <span class="main">::</span> <span class="quoted">equal</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">equal_uint</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint <span class="main">⇒</span> uint <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"equal_class.equal"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> equal_eq<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> equal_uint.rep_eq

<span class="keyword1"><span class="command">instantiation</span></span> uint <span class="main">::</span> <span class="quoted">size</span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="class_parameter">size_uint</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"size"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> size_uint.rep_eq

<span class="keyword1"><span class="command">lift_definition</span></span> sshiftr_uint <span class="main">::</span> <span class="quoted"><span class="quoted">"uint <span class="main">⇒</span> nat <span class="main">⇒</span> uint"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">&gt;&gt;&gt;</span>"</span> 55<span class="main">)</span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">‹<span class="main">λ</span><span class="bound">w</span> <span class="bound">n</span><span class="main">.</span> signed_drop_bit <span class="bound">n</span> <span class="bound">w</span>›</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> uint_of_int <span class="main">::</span> <span class="quoted"><span class="quoted">"int <span class="main">⇒</span> uint"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"word_of_int"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Use pretty numerals from integer for pretty printing›</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> integer.lifting <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> Uint <span class="main">::</span> <span class="quoted"><span class="quoted">"integer <span class="main">⇒</span> uint"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"word_of_int"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1" id="Uint-Rep_uint_numeral"><span class="command">lemma</span></span> Rep_uint_numeral <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Rep_uint <span class="main">(</span>numeral <span class="free">n</span><span class="main">)</span> <span class="main">=</span> numeral <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> one_uint_def Abs_uint_inverse numeral.simps plus_uint_def<span class="main">)</span>

<span class="keyword1" id="Uint-numeral_uint_transfer"><span class="command">lemma</span></span> numeral_uint_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>rel_fun <span class="main">(=)</span> cr_uint<span class="main">)</span> numeral numeral"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cr_uint_def<span class="main">)</span>

<span class="keyword1" id="Uint-numeral_uint"><span class="command">lemma</span></span> numeral_uint <span class="main">[</span><span class="operator">code_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"numeral <span class="free">n</span> <span class="main">=</span> Uint <span class="main">(</span>numeral <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Uint-Rep_uint_neg_numeral"><span class="command">lemma</span></span> Rep_uint_neg_numeral <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Rep_uint <span class="main">(</span><span class="main">-</span> numeral <span class="free">n</span><span class="main">)</span> <span class="main">=</span> <span class="main">-</span> numeral <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> uminus_uint_def<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_uint_inverse<span class="main">)</span>

<span class="keyword1" id="Uint-neg_numeral_uint"><span class="command">lemma</span></span> neg_numeral_uint <span class="main">[</span><span class="operator">code_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">-</span> numeral <span class="free">n</span> <span class="main">=</span> Uint <span class="main">(</span><span class="main">-</span> numeral <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cr_uint_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Uint-Abs_uint_numeral"><span class="command">lemma</span></span> Abs_uint_numeral <span class="main">[</span><span class="operator">code_post</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Abs_uint <span class="main">(</span>numeral <span class="free">n</span><span class="main">)</span> <span class="main">=</span> numeral <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> one_uint_def numeral.simps plus_uint_def Abs_uint_inverse<span class="main">)</span>

<span class="keyword1" id="Uint-Abs_uint_0"><span class="command">lemma</span></span> Abs_uint_0 <span class="main">[</span><span class="operator">code_post</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Abs_uint <span class="main">0</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_uint_def<span class="main">)</span>

<span class="keyword1" id="Uint-Abs_uint_1"><span class="command">lemma</span></span> Abs_uint_1 <span class="main">[</span><span class="operator">code_post</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Abs_uint <span class="main">1</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> one_uint_def<span class="main">)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Code setup›</span></span>

<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">code_module</span></span> Uint <span class="main">⇀</span> <span class="main">(</span>SML<span class="main">)</span>
<span class="quoted">‹
structure Uint : sig
  val set_bit : Word.word -&gt; IntInf.int -&gt; bool -&gt; Word.word
  val shiftl : Word.word -&gt; IntInf.int -&gt; Word.word
  val shiftr : Word.word -&gt; IntInf.int -&gt; Word.word
  val shiftr_signed : Word.word -&gt; IntInf.int -&gt; Word.word
  val test_bit : Word.word -&gt; IntInf.int -&gt; bool
end = struct

fun set_bit x n b =
  let val mask = Word.&lt;&lt; (0wx1, Word.fromLargeInt (IntInf.toLarge n))
  in if b then Word.orb (x, mask)
     else Word.andb (x, Word.notb mask)
  end

fun shiftl x n =
  Word.&lt;&lt; (x, Word.fromLargeInt (IntInf.toLarge n))

fun shiftr x n =
  Word.&gt;&gt; (x, Word.fromLargeInt (IntInf.toLarge n))

fun shiftr_signed x n =
  Word.~&gt;&gt; (x, Word.fromLargeInt (IntInf.toLarge n))

fun test_bit x n =
  Word.andb (x, Word.&lt;&lt; (0wx1, Word.fromLargeInt (IntInf.toLarge n))) &lt;&gt; Word.fromInt 0

end; (* struct Uint *)›</span>
<span class="keyword1"><span class="command">code_reserved</span></span> SML Uint

<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">code_module</span></span> Uint <span class="main">⇀</span> <span class="main">(</span>Haskell<span class="main">)</span>
 <span class="quoted">‹module Uint(Int, Word, dflt_size) where

  import qualified Prelude
  import Data.Int(Int)
  import Data.Word(Word)
  import qualified Data.Bits

  dflt_size :: Prelude.Integer
  dflt_size = Prelude.toInteger (bitSize_aux (0::Word)) where
    bitSize_aux :: (Data.Bits.Bits a, Prelude.Bounded a) =&gt; a -&gt; Int
    bitSize_aux = Data.Bits.bitSize›</span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="main">(</span>Haskell_Quickcheck<span class="main">)</span>
 <span class="quoted">‹module Uint(Int, Word, dflt_size) where

  import qualified Prelude
  import Data.Int(Int)
  import Data.Word(Word)
  import qualified Data.Bits

  dflt_size :: Prelude.Int
  dflt_size = bitSize_aux (0::Word) where
    bitSize_aux :: (Data.Bits.Bits a, Prelude.Bounded a) =&gt; a -&gt; Int
    bitSize_aux = Data.Bits.bitSize
›</span>
<span class="keyword1"><span class="command">code_reserved</span></span> Haskell Uint dflt_size

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  OCaml and Scala provide only signed bit numbers, so we use these and 
  implement sign-sensitive operations like comparisons manually.
›</span></span>

<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">code_module</span></span> <span class="quoted">"Uint"</span> <span class="main">⇀</span> <span class="main">(</span>OCaml<span class="main">)</span>
<span class="quoted">‹module Uint : sig
  type t = int
  val dflt_size : Z.t
  val less : t -&gt; t -&gt; bool
  val less_eq : t -&gt; t -&gt; bool
  val set_bit : t -&gt; Z.t -&gt; bool -&gt; t
  val shiftl : t -&gt; Z.t -&gt; t
  val shiftr : t -&gt; Z.t -&gt; t
  val shiftr_signed : t -&gt; Z.t -&gt; t
  val test_bit : t -&gt; Z.t -&gt; bool
  val int_mask : int
  val int32_mask : int32
  val int64_mask : int64
end = struct

type t = int

let dflt_size = Z.of_int Sys.int_size;;

(* negative numbers have their highest bit set, 
   so they are greater than positive ones *)
let less x y =
  if x&lt;0 then
    y&lt;0 &amp;&amp; x&lt;y
  else y &lt; 0 || x &lt; y;;

let less_eq x y =
  if x &lt; 0 then
    y &lt; 0 &amp;&amp;  x &lt;= y
  else y &lt; 0 || x &lt;= y;;

let set_bit x n b =
  let mask = 1 lsl (Z.to_int n)
  in if b then x lor mask
     else x land (lnot mask);;

let shiftl x n = x lsl (Z.to_int n);;

let shiftr x n = x lsr (Z.to_int n);;

let shiftr_signed x n = x asr (Z.to_int n);;

let test_bit x n = x land (1 lsl (Z.to_int n)) &lt;&gt; 0;;

let int_mask =
  if Sys.int_size &lt; 32 then lnot 0 else 0xFFFFFFFF;;

let int32_mask = 
  if Sys.int_size &lt; 32 then Int32.pred (Int32.shift_left Int32.one Sys.int_size)
  else Int32.of_string "0xFFFFFFFF";;

let int64_mask = 
  if Sys.int_size &lt; 64 then Int64.pred (Int64.shift_left Int64.one Sys.int_size)
  else Int64.of_string "0xFFFFFFFFFFFFFFFF";;

end;; (*struct Uint*)›</span>
<span class="keyword1"><span class="command">code_reserved</span></span> OCaml Uint

<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">code_module</span></span> Uint <span class="main">⇀</span> <span class="main">(</span>Scala<span class="main">)</span>
<span class="quoted">‹object Uint {
def dflt_size : BigInt = BigInt(32)

def less(x: Int, y: Int) : Boolean =
  if (x &lt; 0) y &lt; 0 &amp;&amp; x &lt; y
  else y &lt; 0 || x &lt; y

def less_eq(x: Int, y: Int) : Boolean =
  if (x &lt; 0) y &lt; 0 &amp;&amp; x &lt;= y
  else y &lt; 0 || x &lt;= y

def set_bit(x: Int, n: BigInt, b: Boolean) : Int =
  if (b)
    x | (1 &lt;&lt; n.intValue)
  else
    x &amp; (1 &lt;&lt; n.intValue).unary_~

def shiftl(x: Int, n: BigInt) : Int = x &lt;&lt; n.intValue

def shiftr(x: Int, n: BigInt) : Int = x &gt;&gt;&gt; n.intValue

def shiftr_signed(x: Int, n: BigInt) : Int = x &gt;&gt; n.intValue

def test_bit(x: Int, n: BigInt) : Boolean =
  (x &amp; (1 &lt;&lt; n.intValue)) != 0

} /* object Uint */›</span>
<span class="keyword1"><span class="command">code_reserved</span></span> Scala Uint


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  OCaml's conversion from Big\_int to int demands that the value fits into a signed integer.
  The following justifies the implementation.
›</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> integer.lifting <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">wivs_mask</span> <span class="main">::</span> <span class="quoted">int</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">wivs_mask</span> <span class="main">=</span> <span class="numeral">2</span><span class="main">^</span> dflt_size <span class="main">-</span> <span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> wivs_mask_integer <span class="main">::</span> <span class="quoted">integer</span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">wivs_mask</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"wivs_mask_integer <span class="main">=</span> <span class="numeral">2</span> <span class="main">^</span> dflt_size <span class="main">-</span> <span class="main">1</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> wivs_mask_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">wivs_shift</span> <span class="main">::</span> <span class="quoted">int</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">wivs_shift</span> <span class="main">=</span> <span class="numeral">2</span> <span class="main">^</span> dflt_size"</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> wivs_shift_integer <span class="main">::</span> <span class="quoted">integer</span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">wivs_shift</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"wivs_shift_integer <span class="main">=</span> <span class="numeral">2</span> <span class="main">^</span> dflt_size"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> wivs_shift_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">wivs_index</span> <span class="main">::</span> <span class="quoted">nat</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">wivs_index</span> <span class="main">==</span> dflt_size <span class="main">-</span> <span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> wivs_index_integer <span class="main">::</span> <span class="quoted">integer</span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"int wivs_index"</span></span><span class="keyword1"><span class="command">.</span></span>
<span class="keyword1" id="Uint-wivs_index_integer_code"><span class="command">lemma</span></span> wivs_index_integer_code<span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"wivs_index_integer <span class="main">=</span> dflt_size_integer <span class="main">-</span> <span class="main">1</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> wivs_index_def of_nat_diff<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">wivs_overflow</span> <span class="main">::</span> <span class="quoted">int</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">wivs_overflow</span> <span class="main">==</span> <span class="numeral">2</span><span class="main">^</span> <span class="main">(</span>dflt_size <span class="main">-</span> <span class="main">1</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> wivs_overflow_integer <span class="main">::</span> <span class="quoted">integer</span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">wivs_overflow</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"wivs_overflow_integer <span class="main">=</span> <span class="numeral">2</span> <span class="main">^</span> <span class="main">(</span>dflt_size <span class="main">-</span> <span class="main">1</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> wivs_overflow_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">wivs_least</span> <span class="main">::</span> <span class="quoted">int</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">wivs_least</span> <span class="main">==</span> <span class="main">-</span> wivs_overflow"</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> wivs_least_integer <span class="main">::</span> <span class="quoted">integer</span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">wivs_least</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"wivs_least_integer <span class="main">=</span> <span class="main">-</span> <span class="main">(</span><span class="numeral">2</span> <span class="main">^</span> <span class="main">(</span>dflt_size <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> wivs_overflow_def wivs_least_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">Uint_signed</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"integer <span class="main">⇒</span> uint"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">Uint_signed</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">&lt;</span> wivs_least_integer <span class="main">∨</span> wivs_overflow_integer <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="keyword1">then</span> undefined Uint <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="keyword1">else</span> Uint <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Uint-Uint_code"><span class="command">lemma</span></span> Uint_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Uint <span class="free">i</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">let</span> <span class="bound">i'</span> <span class="main">=</span> <span class="free">i</span> <span class="keyword1">AND</span> wivs_mask_integer <span class="keyword1">in</span> 
   <span class="keyword1">if</span> bit <span class="bound">i'</span> wivs_index <span class="keyword1">then</span> Uint_signed <span class="main">(</span><span class="bound">i'</span> <span class="main">-</span> wivs_shift_integer<span class="main">)</span> <span class="keyword1">else</span> Uint_signed <span class="bound">i'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> undefined_transfer 
  <span class="keyword1"><span class="command">unfolding</span></span> Uint_signed_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> word_of_int_via_signed<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> shiftl_eq_push_bit push_bit_of_1 mask_eq_exp_minus_1 word_of_int_via_signed
         wivs_mask_def wivs_index_def wivs_overflow_def wivs_least_def wivs_shift_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Uint-Uint_signed_code"><span class="command">lemma</span></span> Uint_signed_code <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">abstract</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Rep_uint <span class="main">(</span>Uint_signed <span class="free">i</span><span class="main">)</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">i</span> <span class="main">&lt;</span> wivs_least_integer <span class="main">∨</span> <span class="free">i</span> <span class="main">≥</span> wivs_overflow_integer <span class="keyword1">then</span> Rep_uint <span class="main">(</span>undefined Uint <span class="free">i</span><span class="main">)</span> <span class="keyword1">else</span> word_of_int <span class="main">(</span>int_of_integer_symbolic <span class="free">i</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Uint_signed_def Uint_def int_of_integer_symbolic_def word_of_integer_def
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_uint_inverse<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Avoid <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Abs_uint</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> in generated code, use <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">Rep_uint'</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> instead. 
  The symbolic implementations for code\_simp use <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Rep_uint</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.

  The new destructor <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">Rep_uint'</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is executable.
  As the simplifier is given the [code abstract] equations literally, 
  we cannot implement <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Rep_uint</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> directly, because that makes code\_simp loop.

  If code generation raises Match, some equation probably contains <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Rep_uint</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> 
  ([code abstract] equations for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">uint</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> may use <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Rep_uint</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> because
  these instances will be folded away.)
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">Rep_uint'</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Rep_uint'</span> <span class="main">=</span> Rep_uint"</span></span>

<span class="keyword1" id="Uint-Rep_uint'_code"><span class="command">lemma</span></span> Rep_uint'_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Rep_uint' <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">BITS</span> <span class="bound">n</span><span class="main">.</span> bit <span class="free">x</span> <span class="bound">n</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Rep_uint'_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_bits_bit_eq<span class="main">)</span>

<span class="keyword1"><span class="command">lift_definition</span></span> Abs_uint' <span class="main">::</span> <span class="quoted"><span class="quoted">"dflt_size word <span class="main">⇒</span> uint"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span> <span class="main">::</span> dflt_size word<span class="main">.</span> <span class="bound">x</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1" id="Uint-Abs_uint'_code"><span class="command">lemma</span></span> Abs_uint'_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Abs_uint' <span class="free">x</span> <span class="main">=</span> Uint <span class="main">(</span>integer_of_int <span class="main">(</span>uint <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">including</span></span> integer.lifting <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">"term_of_class.term_of <span class="main">::</span> uint <span class="main">⇒</span> <span class="main">_</span>"</span></span><span class="main">]</span><span class="main">]</span>

<span class="keyword1" id="Uint-term_of_uint_code"><span class="command">lemma</span></span> term_of_uint_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">TR</span> <span class="main">≡</span> typerep.Typerep"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">bit0</span> <span class="main">≡</span> <span class="keyword1">STR</span> <span class="inner_quoted">''Numeral_Type.bit0''</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"term_of_class.term_of <span class="free">x</span> <span class="main">=</span> 
   Code_Evaluation.App <span class="main">(</span>Code_Evaluation.Const <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Uint.uint.Abs_uint''</span><span class="main">)</span> <span class="main">(</span><span class="free">TR</span> <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''fun''</span><span class="main">)</span> <span class="main">[</span><span class="free">TR</span> <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Word.word''</span><span class="main">)</span>  <span class="main">[</span><span class="free">TR</span> <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Uint.dflt_size''</span><span class="main">)</span> <span class="main">[]</span><span class="main">]</span><span class="main">,</span> <span class="free">TR</span> <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Uint.uint''</span><span class="main">)</span> <span class="main">[]</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
       <span class="main">(</span>term_of_class.term_of <span class="main">(</span>Rep_uint' <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> term_of_anything<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Important:
  We must prevent the reflection oracle (eval-tac) to 
  use our machine-dependent type.
›</span></span>

<span class="keyword1"><span class="command">code_printing</span></span>
  <span class="keyword2"><span class="keyword">type_constructor</span></span> uint <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Word.word"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"Uint.Word"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Uint.t"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"Int"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Eval<span class="main">)</span> <span class="quoted">"*** \"Error: Machine dependent type\" ***"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Quickcheck<span class="main">)</span> <span class="quoted">"Word.word"</span> 
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">dflt_size_integer</span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"(IntInf.fromLarge (Int.toLarge Word.wordSize))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Eval<span class="main">)</span> <span class="quoted">"(raise (Fail \"Machine dependent code\"))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Quickcheck<span class="main">)</span> <span class="quoted">"Word.wordSize"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"Uint.dflt'_size"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Uint.dflt'_size"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"Uint.dflt'_size"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">Uint</span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Word.fromLargeInt (IntInf.toLarge _)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Eval<span class="main">)</span> <span class="quoted">"(raise (Fail \"Machine dependent code\"))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Quickcheck<span class="main">)</span> <span class="quoted">"Word.fromInt"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"(Prelude.fromInteger _ :: Uint.Word)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell_Quickcheck<span class="main">)</span> <span class="quoted">"(Prelude.fromInteger (Prelude.toInteger _) :: Uint.Word)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"_.intValue"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">Uint_signed</span> <span class="main">⇀</span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Z.to'_int"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">::</span> uint"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"(Word.fromInt 0)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Eval<span class="main">)</span> <span class="quoted">"(raise (Fail \"Machine dependent code\"))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Quickcheck<span class="main">)</span> <span class="quoted">"(Word.fromInt 0)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"(0 :: Uint.Word)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"0"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"0"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">::</span> uint"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"(Word.fromInt 1)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Eval<span class="main">)</span> <span class="quoted">"(raise (Fail \"Machine dependent code\"))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Quickcheck<span class="main">)</span> <span class="quoted">"(Word.fromInt 1)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"(1 :: Uint.Word)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"1"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"1"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"plus <span class="main">::</span> uint <span class="main">⇒</span> <span class="main">_</span> "</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Word.+ ((_), (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Eval<span class="main">)</span> <span class="quoted">"(raise (Fail \"Machine dependent code\"))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Quickcheck<span class="main">)</span> <span class="quoted">"Word.+ ((_), (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 6 <span class="quoted">"+"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Pervasives.(+)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 7 <span class="quoted">"+"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"uminus <span class="main">::</span> uint <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Word.~"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Eval<span class="main">)</span> <span class="quoted">"(raise (Fail \"Machine dependent code\"))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Quickcheck<span class="main">)</span> <span class="quoted">"Word.~"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"negate"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Pervasives.(~-)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"!(- _)"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"minus <span class="main">::</span> uint <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Word.- ((_), (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Eval<span class="main">)</span> <span class="quoted">"(raise (Fail \"Machine dependent code\"))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Quickcheck<span class="main">)</span> <span class="quoted">"Word.- ((_), (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 6 <span class="quoted">"-"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Pervasives.(-)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 7 <span class="quoted">"-"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"times <span class="main">::</span> uint <span class="main">⇒</span> <span class="main">_</span> <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Word.* ((_), (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Eval<span class="main">)</span> <span class="quoted">"(raise (Fail \"Machine dependent code\"))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Quickcheck<span class="main">)</span> <span class="quoted">"Word.* ((_), (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 7 <span class="quoted">"*"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Pervasives.( * )"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 8 <span class="quoted">"*"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"HOL.equal <span class="main">::</span> uint <span class="main">⇒</span> <span class="main">_</span> <span class="main">⇒</span> bool"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"!((_ : Word.word) = _)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Eval<span class="main">)</span> <span class="quoted">"(raise (Fail \"Machine dependent code\"))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Quickcheck<span class="main">)</span> <span class="quoted">"!((_ : Word.word) = _)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="keyword2"><span class="keyword">infix</span></span> 4 <span class="quoted">"=="</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"(Pervasives.(=):Uint.t -&gt; Uint.t -&gt; bool)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 5 <span class="quoted">"=="</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">class_instance</span></span> uint <span class="main">::</span> equal <span class="main">⇀</span>
  <span class="main">(</span>Haskell<span class="main">)</span> -
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"less_eq <span class="main">::</span> uint <span class="main">⇒</span> <span class="main">_</span> <span class="main">⇒</span> bool"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Word.&lt;= ((_), (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Eval<span class="main">)</span> <span class="quoted">"(raise (Fail \"Machine dependent code\"))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Quickcheck<span class="main">)</span> <span class="quoted">"Word.&lt;= ((_), (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="keyword2"><span class="keyword">infix</span></span> 4 <span class="quoted">"&lt;="</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Uint.less'_eq"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"Uint.less'_eq"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"less <span class="main">::</span> uint <span class="main">⇒</span> <span class="main">_</span> <span class="main">⇒</span> bool"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Word.&lt; ((_), (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Eval<span class="main">)</span> <span class="quoted">"(raise (Fail \"Machine dependent code\"))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Quickcheck<span class="main">)</span> <span class="quoted">"Word.&lt; ((_), (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="keyword2"><span class="keyword">infix</span></span> 4 <span class="quoted">"&lt;"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Uint.less"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"Uint.less"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">NOT</span> <span class="main">::</span> uint <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Word.notb"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Eval<span class="main">)</span> <span class="quoted">"(raise (Fail \"Machine dependent code\"))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Quickcheck<span class="main">)</span> <span class="quoted">"Word.notb"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"Data'_Bits.complement"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Pervasives.lnot"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"_.unary'_~"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">(AND)</span> <span class="main">::</span> uint <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Word.andb ((_),/ (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Eval<span class="main">)</span> <span class="quoted">"(raise (Fail \"Machine dependent code\"))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Quickcheck<span class="main">)</span> <span class="quoted">"Word.andb ((_),/ (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 7 <span class="quoted">"Data_Bits..&amp;."</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Pervasives.(land)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 3 <span class="quoted">"&amp;"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">(OR)</span> <span class="main">::</span> uint <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Word.orb ((_),/ (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Eval<span class="main">)</span> <span class="quoted">"(raise (Fail \"Machine dependent code\"))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Quickcheck<span class="main">)</span> <span class="quoted">"Word.orb ((_),/ (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 5 <span class="quoted">"Data_Bits..|."</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Pervasives.(lor)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 1 <span class="quoted">"|"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">(XOR)</span> <span class="main">::</span> uint <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Word.xorb ((_),/ (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Eval<span class="main">)</span> <span class="quoted">"(raise (Fail \"Machine dependent code\"))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Quickcheck<span class="main">)</span> <span class="quoted">"Word.xorb ((_),/ (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"Data'_Bits.xor"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Pervasives.(lxor)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="keyword2"><span class="keyword">infixl</span></span> 2 <span class="quoted">"^"</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint_divmod</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint <span class="main">⇒</span> uint <span class="main">⇒</span> uint <span class="main">×</span> uint"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">uint_divmod</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">(</span>undefined <span class="main">(</span><span class="keyword1">(div)</span> <span class="main">::</span> uint <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="main">0</span> <span class="main">::</span> uint<span class="main">)</span><span class="main">,</span> undefined <span class="main">(</span><span class="keyword1">(mod)</span> <span class="main">::</span> uint <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="main">0</span> <span class="main">::</span> uint<span class="main">)</span><span class="main">)</span> 
  <span class="keyword1">else</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">div</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">mod</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint_div</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint <span class="main">⇒</span> uint <span class="main">⇒</span> uint"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">uint_div</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> fst <span class="main">(</span>uint_divmod <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint_mod</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint <span class="main">⇒</span> uint <span class="main">⇒</span> uint"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">uint_mod</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> snd <span class="main">(</span>uint_divmod <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Uint-div_uint_code"><span class="command">lemma</span></span> div_uint_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="keyword1">div</span> <span class="free">y</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">y</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> uint_div <span class="free">x</span> <span class="free">y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">including</span></span> undefined_transfer <span class="keyword1"><span class="command">unfolding</span></span> uint_divmod_def uint_div_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> word_div_def<span class="main">)</span>

<span class="keyword1" id="Uint-mod_uint_code"><span class="command">lemma</span></span> mod_uint_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="keyword1">mod</span> <span class="free">y</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">y</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="free">x</span> <span class="keyword1">else</span> uint_mod <span class="free">x</span> <span class="free">y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">including</span></span> undefined_transfer <span class="keyword1"><span class="command">unfolding</span></span> uint_mod_def uint_divmod_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> word_mod_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint_sdiv</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint <span class="main">⇒</span> uint <span class="main">⇒</span> uint"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">uint_sdiv</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span>
   <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> undefined <span class="main">(</span><span class="keyword1">(div)</span> <span class="main">::</span> uint <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="main">0</span> <span class="main">::</span> uint<span class="main">)</span>
    <span class="keyword1">else</span> Abs_uint <span class="main">(</span>Rep_uint <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">sdiv</span> Rep_uint <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">div0_uint</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint <span class="main">⇒</span> uint"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">div0_uint</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> undefined <span class="main">(</span><span class="keyword1">(div)</span> <span class="main">::</span> uint <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="main">0</span> <span class="main">::</span> uint<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">abort</span><span class="main"><span class="main">:</span></span> <span class="quoted">div0_uint</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">mod0_uint</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint <span class="main">⇒</span> uint"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">mod0_uint</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> undefined <span class="main">(</span><span class="keyword1">(mod)</span> <span class="main">::</span> uint <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="main">0</span> <span class="main">::</span> uint<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">abort</span><span class="main"><span class="main">:</span></span> <span class="quoted">mod0_uint</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">wivs_overflow_uint</span> <span class="main">::</span> <span class="quoted">uint</span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">wivs_overflow_uint</span> <span class="main">≡</span> push_bit <span class="main">(</span>dflt_size <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="main">1</span>"</span></span>

<span class="keyword1" id="Uint-uint_divmod_code"><span class="command">lemma</span></span> uint_divmod_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"uint_divmod <span class="free">x</span> <span class="free">y</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> wivs_overflow_uint <span class="main">≤</span> <span class="free">y</span> <span class="keyword1">then</span> <span class="keyword1">if</span> <span class="free">x</span> <span class="main">&lt;</span> <span class="free">y</span> <span class="keyword1">then</span> <span class="main">(</span><span class="main">0</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">(</span><span class="main">1</span><span class="main">,</span> <span class="free">x</span> <span class="main">-</span> <span class="free">y</span><span class="main">)</span>
   <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="free">y</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">(</span>div0_uint <span class="free">x</span><span class="main">,</span> mod0_uint <span class="free">x</span><span class="main">)</span>
   <span class="keyword1">else</span> <span class="keyword1">let</span> <span class="bound">q</span> <span class="main">=</span> push_bit <span class="main">1</span> <span class="main">(</span>uint_sdiv <span class="main">(</span>drop_bit <span class="main">1</span> <span class="free">x</span><span class="main">)</span> <span class="free">y</span><span class="main">)</span><span class="main">;</span>
            <span class="bound">r</span> <span class="main">=</span> <span class="free">x</span> <span class="main">-</span> <span class="bound">q</span> <span class="main">*</span> <span class="free">y</span>
        <span class="keyword1">in</span> <span class="keyword1">if</span> <span class="bound">r</span> <span class="main">≥</span> <span class="free">y</span> <span class="keyword1">then</span> <span class="main">(</span><span class="bound">q</span> <span class="main">+</span> <span class="main">1</span><span class="main">,</span> <span class="bound">r</span> <span class="main">-</span> <span class="free">y</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">(</span><span class="bound">q</span><span class="main">,</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">‹<span class="free">y</span> <span class="main">=</span> <span class="main">0</span>›</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">‹<span class="free">x</span> <span class="main">≥</span> <span class="main">0</span>›</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">‹wivs_overflow_uint <span class="main">&gt;</span> <span class="main">0</span>›</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> wivs_overflow_uint_def push_bit_of_1<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> uint_divmod_def div0_uint_def mod0_uint_def not_less<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">including</span></span> undefined_transfer 
    <span class="keyword1"><span class="command">unfolding</span></span> uint_divmod_def uint_sdiv_def div0_uint_def mod0_uint_def
      wivs_overflow_uint_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> divmod_via_sdivmod push_bit_of_1 shiftl_eq_push_bit shiftr_eq_drop_bit<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Uint-uint_sdiv_code"><span class="command">lemma</span></span> uint_sdiv_code <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">abstract</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Rep_uint <span class="main">(</span>uint_sdiv <span class="free">x</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span>
   <span class="main">(</span><span class="keyword1">if</span> <span class="free">y</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> Rep_uint <span class="main">(</span>undefined <span class="main">(</span><span class="keyword1">(div)</span> <span class="main">::</span> uint <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free">x</span> <span class="main">(</span><span class="main">0</span> <span class="main">::</span> uint<span class="main">)</span><span class="main">)</span>
    <span class="keyword1">else</span> Rep_uint <span class="free">x</span> <span class="keyword1">sdiv</span> Rep_uint <span class="free">y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> uint_sdiv_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Abs_uint_inverse<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Note that we only need a translation for signed division, but not for the remainder
  because <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> uint_divmod_code<span class="antiquote"><span class="antiquote">}</span></span></span></span> computes both with division only.
›</span></span>

<span class="keyword1"><span class="command">code_printing</span></span>
  <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint_div</span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Word.div ((_), (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Eval<span class="main">)</span> <span class="quoted">"(raise (Fail \"Machine dependent code\"))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Quickcheck<span class="main">)</span> <span class="quoted">"Word.div ((_), (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"Prelude.div"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint_mod</span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Word.mod ((_), (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Eval<span class="main">)</span> <span class="quoted">"(raise (Fail \"Machine dependent code\"))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Quickcheck<span class="main">)</span> <span class="quoted">"Word.mod ((_), (_))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"Prelude.mod"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint_divmod</span> <span class="main">⇀</span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"divmod"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint_sdiv</span> <span class="main">⇀</span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Pervasives.('/)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"_ '/ _"</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint_test_bit</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint <span class="main">⇒</span> integer <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">uint_test_bit</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">∨</span> dflt_size_integer <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">then</span> undefined <span class="main">(</span>bit <span class="main">::</span> uint <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span>
   <span class="keyword1">else</span> bit <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span>nat_of_integer <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Uint-test_bit_uint_code"><span class="command">lemma</span></span> test_bit_uint_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"bit <span class="free">x</span> <span class="free">n</span> <span class="main">⟷</span> <span class="free">n</span> <span class="main">&lt;</span> dflt_size <span class="main">∧</span> uint_test_bit <span class="free">x</span> <span class="main">(</span>integer_of_nat <span class="free">n</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> undefined_transfer integer.lifting <span class="keyword1"><span class="command">unfolding</span></span> uint_test_bit_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="Uint-uint_test_bit_code"><span class="command">lemma</span></span> uint_test_bit_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"uint_test_bit <span class="free">w</span> <span class="free">n</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">∨</span> dflt_size_integer <span class="main">≤</span> <span class="free">n</span> <span class="keyword1">then</span> undefined <span class="main">(</span>bit <span class="main">::</span> uint <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free">w</span> <span class="free">n</span> <span class="keyword1">else</span> bit <span class="main">(</span>Rep_uint <span class="free">w</span><span class="main">)</span> <span class="main">(</span>nat_of_integer <span class="free">n</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> uint_test_bit_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bit_uint.rep_eq<span class="main">)</span>

<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint_test_bit</span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Uint.test'_bit"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Eval<span class="main">)</span> <span class="quoted">"(raise (Fail \"Machine dependent code\"))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Quickcheck<span class="main">)</span> <span class="quoted">"Uint.test'_bit"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"Data'_Bits.testBitBounded"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Uint.test'_bit"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"Uint.test'_bit"</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint_set_bit</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint <span class="main">⇒</span> integer <span class="main">⇒</span> bool <span class="main">⇒</span> uint"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">uint_set_bit</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">∨</span> dflt_size_integer <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">then</span> undefined <span class="main">(</span>set_bit <span class="main">::</span> uint <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span>
   <span class="keyword1">else</span> set_bit <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span>nat_of_integer <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Uint-set_bit_uint_code"><span class="command">lemma</span></span> set_bit_uint_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"set_bit <span class="free">x</span> <span class="free">n</span> <span class="free">b</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">&lt;</span> dflt_size <span class="keyword1">then</span> uint_set_bit <span class="free">x</span> <span class="main">(</span>integer_of_nat <span class="free">n</span><span class="main">)</span> <span class="free">b</span> <span class="keyword1">else</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> undefined_transfer integer.lifting <span class="keyword1"><span class="command">unfolding</span></span> uint_set_bit_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> conj_cong <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_less set_bit_beyond word_size<span class="main">)</span>

<span class="keyword1" id="Uint-uint_set_bit_code"><span class="command">lemma</span></span> uint_set_bit_code <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">abstract</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Rep_uint <span class="main">(</span>uint_set_bit <span class="free">w</span> <span class="free">n</span> <span class="free">b</span><span class="main">)</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">∨</span> dflt_size_integer <span class="main">≤</span> <span class="free">n</span> <span class="keyword1">then</span> Rep_uint <span class="main">(</span>undefined <span class="main">(</span>set_bit <span class="main">::</span> uint <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free">w</span> <span class="free">n</span> <span class="free">b</span><span class="main">)</span>
   <span class="keyword1">else</span> set_bit <span class="main">(</span>Rep_uint <span class="free">w</span><span class="main">)</span> <span class="main">(</span>nat_of_integer <span class="free">n</span><span class="main">)</span> <span class="free">b</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">including</span></span> undefined_transfer integer.lifting <span class="keyword1"><span class="command">unfolding</span></span> uint_set_bit_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint_set_bit</span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Uint.set'_bit"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Eval<span class="main">)</span> <span class="quoted">"(raise (Fail \"Machine dependent code\"))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Quickcheck<span class="main">)</span> <span class="quoted">"Uint.set'_bit"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"Data'_Bits.setBitBounded"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Uint.set'_bit"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"Uint.set'_bit"</span>

<span class="keyword1"><span class="command">lift_definition</span></span> uint_set_bits <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nat <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> uint <span class="main">⇒</span> nat <span class="main">⇒</span> uint"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">set_bits_aux</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1" id="Uint-uint_set_bits_code"><span class="command">lemma</span></span> uint_set_bits_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"uint_set_bits <span class="free">f</span> <span class="free">w</span> <span class="free">n</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="free">w</span> 
   <span class="keyword1">else</span> <span class="keyword1">let</span> <span class="bound">n'</span> <span class="main">=</span> <span class="free">n</span> <span class="main">-</span> <span class="main">1</span> <span class="keyword1">in</span> uint_set_bits <span class="free">f</span> <span class="main">(</span>push_bit <span class="main">1</span> <span class="free">w</span> <span class="keyword1">OR</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">f</span> <span class="bound">n'</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span> <span class="bound">n'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">transfer</span> <span class="quasi_keyword">fixing</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> shiftl_eq_push_bit<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Uint-set_bits_uint"><span class="command">lemma</span></span> set_bits_uint <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">BITS</span> <span class="bound">n</span><span class="main">.</span> <span class="free">f</span> <span class="bound">n</span><span class="main">)</span> <span class="main">=</span> uint_set_bits <span class="free">f</span> <span class="main">0</span> dflt_size"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_bits_conv_set_bits_aux<span class="main">)</span>

<span class="keyword1" id="Uint-lsb_code"><span class="command">lemma</span></span> lsb_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span> <span class="main">::</span> <span class="quoted">uint</span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lsb <span class="free">x</span> <span class="main">=</span> bit <span class="free">x</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lsb_word_eq<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint_shiftl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint <span class="main">⇒</span> integer <span class="main">⇒</span> uint"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">uint_shiftl</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">∨</span> dflt_size_integer <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">then</span> undefined <span class="main">(</span>push_bit <span class="main">::</span> nat <span class="main">⇒</span> uint <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">else</span> push_bit <span class="main">(</span>nat_of_integer <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Uint-shiftl_uint_code"><span class="command">lemma</span></span> shiftl_uint_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"push_bit <span class="free">n</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">&lt;</span> dflt_size <span class="keyword1">then</span> uint_shiftl <span class="free">x</span> <span class="main">(</span>integer_of_nat <span class="free">n</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> undefined_transfer integer.lifting <span class="keyword1"><span class="command">unfolding</span></span> uint_shiftl_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">transfer</span> <span class="quasi_keyword">fixing</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1" id="Uint-uint_shiftl_code"><span class="command">lemma</span></span> uint_shiftl_code <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">abstract</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Rep_uint <span class="main">(</span>uint_shiftl <span class="free">w</span> <span class="free">n</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">∨</span> dflt_size_integer <span class="main">≤</span> <span class="free">n</span> <span class="keyword1">then</span> Rep_uint <span class="main">(</span>undefined <span class="main">(</span>push_bit <span class="main">::</span> nat <span class="main">⇒</span> uint <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free">w</span> <span class="free">n</span><span class="main">)</span> <span class="keyword1">else</span> push_bit <span class="main">(</span>nat_of_integer <span class="free">n</span><span class="main">)</span> <span class="main">(</span>Rep_uint <span class="free">w</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> undefined_transfer integer.lifting <span class="keyword1"><span class="command">unfolding</span></span> uint_shiftl_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint_shiftl</span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Uint.shiftl"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Eval<span class="main">)</span> <span class="quoted">"(raise (Fail \"Machine dependent code\"))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Quickcheck<span class="main">)</span> <span class="quoted">"Uint.shiftl"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"Data'_Bits.shiftlBounded"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Uint.shiftl"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"Uint.shiftl"</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint_shiftr</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint <span class="main">⇒</span> integer <span class="main">⇒</span> uint"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">uint_shiftr</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">∨</span> dflt_size_integer <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">then</span> undefined <span class="main">(</span>drop_bit <span class="main">::</span> nat <span class="main">⇒</span> uint <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">else</span> drop_bit <span class="main">(</span>nat_of_integer <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Uint-shiftr_uint_code"><span class="command">lemma</span></span> shiftr_uint_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"drop_bit <span class="free">n</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">&lt;</span> dflt_size <span class="keyword1">then</span> uint_shiftr <span class="free">x</span> <span class="main">(</span>integer_of_nat <span class="free">n</span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> undefined_transfer integer.lifting <span class="keyword1"><span class="command">unfolding</span></span> uint_shiftr_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">transfer</span> <span class="quasi_keyword">fixing</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span> <span class="operator">simp</span>
  
<span class="keyword1" id="Uint-uint_shiftr_code"><span class="command">lemma</span></span> uint_shiftr_code <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">abstract</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Rep_uint <span class="main">(</span>uint_shiftr <span class="free">w</span> <span class="free">n</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">∨</span> dflt_size_integer <span class="main">≤</span> <span class="free">n</span> <span class="keyword1">then</span> Rep_uint <span class="main">(</span>undefined <span class="main">(</span>drop_bit <span class="main">::</span> nat <span class="main">⇒</span> uint <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free">w</span> <span class="free">n</span><span class="main">)</span> <span class="keyword1">else</span> drop_bit <span class="main">(</span>nat_of_integer <span class="free">n</span><span class="main">)</span> <span class="main">(</span>Rep_uint <span class="free">w</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">including</span></span> undefined_transfer <span class="keyword1"><span class="command">unfolding</span></span> uint_shiftr_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint_shiftr</span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Uint.shiftr"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Eval<span class="main">)</span> <span class="quoted">"(raise (Fail \"Machine dependent code\"))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Quickcheck<span class="main">)</span> <span class="quoted">"Uint.shiftr"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"Data'_Bits.shiftrBounded"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Uint.shiftr"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"Uint.shiftr"</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint_sshiftr</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"uint <span class="main">⇒</span> integer <span class="main">⇒</span> uint"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">uint_sshiftr</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">∨</span> dflt_size_integer <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">then</span> undefined sshiftr_uint <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">else</span> sshiftr_uint <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span>nat_of_integer <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Uint-sshiftr_uint_code"><span class="command">lemma</span></span> sshiftr_uint_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">&gt;&gt;&gt;</span> <span class="free">n</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">&lt;</span> dflt_size <span class="keyword1">then</span> uint_sshiftr <span class="free">x</span> <span class="main">(</span>integer_of_nat <span class="free">n</span><span class="main">)</span> <span class="keyword1">else</span> 
    <span class="keyword1">if</span> bit <span class="free">x</span> wivs_index <span class="keyword1">then</span> <span class="main">-</span><span class="main">1</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">including</span></span> undefined_transfer integer.lifting <span class="keyword1"><span class="command">unfolding</span></span> uint_sshiftr_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> not_less signed_drop_bit_beyond word_size wivs_index_def<span class="main">)</span>

<span class="keyword1" id="Uint-uint_sshiftr_code"><span class="command">lemma</span></span> uint_sshiftr_code <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">abstract</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Rep_uint <span class="main">(</span>uint_sshiftr <span class="free">w</span> <span class="free">n</span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">&lt;</span> <span class="main">0</span> <span class="main">∨</span> dflt_size_integer <span class="main">≤</span> <span class="free">n</span> <span class="keyword1">then</span> Rep_uint <span class="main">(</span>undefined sshiftr_uint <span class="free">w</span> <span class="free">n</span><span class="main">)</span> <span class="keyword1">else</span> signed_drop_bit <span class="main">(</span>nat_of_integer <span class="free">n</span><span class="main">)</span> <span class="main">(</span>Rep_uint <span class="free">w</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">including</span></span> undefined_transfer <span class="keyword1"><span class="command">unfolding</span></span> uint_sshiftr_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint_sshiftr</span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Uint.shiftr'_signed"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Eval<span class="main">)</span> <span class="quoted">"(raise (Fail \"Machine dependent code\"))"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Quickcheck<span class="main">)</span> <span class="quoted">"Uint.shiftr'_signed"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> 
    <span class="quoted">"(Prelude.fromInteger (Prelude.toInteger (Data'_Bits.shiftrBounded (Prelude.fromInteger (Prelude.toInteger _) :: Uint.Int) _)) :: Uint.Word)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Uint.shiftr'_signed"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"Uint.shiftr'_signed"</span>

<span class="keyword1" id="Uint-uint_msb_test_bit"><span class="command">lemma</span></span> uint_msb_test_bit<span class="main">:</span> <span class="quoted"><span class="quoted">"msb <span class="free">x</span> <span class="main">⟷</span> bit <span class="main">(</span><span class="free">x</span> <span class="main">::</span> uint<span class="main">)</span> wivs_index"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> msb_word_iff_bit wivs_index_def<span class="main">)</span>

<span class="keyword1" id="Uint-msb_uint_code"><span class="command">lemma</span></span> msb_uint_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"msb <span class="free">x</span> <span class="main">⟷</span> uint_test_bit <span class="free">x</span> wivs_index_integer"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> uint_test_bit_def uint_msb_test_bit 
  wivs_index_integer_code dflt_size_integer_def wivs_index_def<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>full_types<span class="main"><span class="main">)</span></span> One_nat_def dflt_size<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> less_iff_diff_less_0 
    nat_of_integer_of_nat of_nat_1 of_nat_diff of_nat_less_0_iff wivs_index_def<span class="main">)</span>

<span class="keyword1" id="Uint-uint_of_int_code"><span class="command">lemma</span></span> uint_of_int_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"uint_of_int <span class="free">i</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">BITS</span> <span class="bound">n</span><span class="main">.</span> bit <span class="free">i</span> <span class="bound">n</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> word_of_int_conv_set_bits<span class="main">)</span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Quickcheck setup›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">uint_of_natural</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"natural <span class="main">⇒</span> uint"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">uint_of_natural</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≡</span> Uint <span class="main">(</span>integer_of_natural <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">{</span>random<span class="main">,</span> exhaustive<span class="main">,</span> full_exhaustive<span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">random_uint</span></span> <span class="main">≡</span> qc_random_cnv uint_of_natural"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">exhaustive_uint</span></span> <span class="main">≡</span> qc_exhaustive_cnv uint_of_natural"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">full_exhaustive_uint</span></span> <span class="main">≡</span> qc_full_exhaustive_cnv uint_of_natural"</span></span>
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> uint <span class="main">::</span> <span class="quoted">narrowing</span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> quickcheck_narrowing_samples
  <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">i</span><span class="main">.</span> <span class="main">(</span>Uint <span class="bound">i</span><span class="main">,</span> Uint <span class="main">(</span><span class="main">-</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span>"</span></span>
  <span class="quoted"><span class="quoted">"Typerep.Typerep <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Uint.uint''</span><span class="main">)</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="class_parameter">narrowing_uint</span></span> <span class="free"><span class="bound"><span class="entity">d</span></span></span> <span class="main">=</span> qc_narrowing_drawn_from <span class="main">(</span>narrowing_samples <span class="free"><span class="bound"><span class="entity">d</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">d</span></span></span>"</span></span>
<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">"partial_term_of <span class="main">::</span> uint itself <span class="main">⇒</span> <span class="main">_</span>"</span></span><span class="main">]</span><span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> partial_term_of_uint <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> partial_term_of_code

<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">no_notation</span></span> sshiftr_uint <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">&gt;&gt;&gt;</span>"</span> 55<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Native_Cast">
<div class="head">
<h1>Theory Native_Cast</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Native_Cast.thy
    Author:     Andreas Lochbihler, ETH Zurich
*)</span>

<span class="keyword1"><span class="command">chapter</span></span> <span class="quoted"><span class="plain_text">‹Conversions between unsigned words and between char›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Native_Cast
  <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Uint8.html">Uint8</a>
  <a href="Uint16.html">Uint16</a>
  <a href="Uint32.html">Uint32</a>
  <a href="Uint64.html">Uint64</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Auxiliary stuff›</span></span>

<span class="keyword1" id="Native_Cast-integer_of_char_char_of_integer"><span class="command">lemma</span></span> integer_of_char_char_of_integer <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"integer_of_char <span class="main">(</span>char_of_integer <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">x</span> <span class="keyword1">mod</span> <span class="numeral">256</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> integer_of_char_def char_of_integer_def<span class="main">)</span>

<span class="keyword1" id="Native_Cast-char_of_integer_integer_of_char"><span class="command">lemma</span></span> char_of_integer_integer_of_char <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"char_of_integer <span class="main">(</span>integer_of_char <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> integer_of_char_def char_of_integer_def<span class="main">)</span>

<span class="keyword1" id="Native_Cast-int_lt_numeral"><span class="command">lemma</span></span> int_lt_numeral <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"int <span class="free">x</span> <span class="main">&lt;</span> numeral <span class="free">n</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">&lt;</span> numeral <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> nat_numeral zless_nat_eq_int_zless<span class="main">)</span>

<span class="keyword1" id="Native_Cast-int_of_integer_ge_0"><span class="command">lemma</span></span> int_of_integer_ge_0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">≤</span> int_of_integer <span class="free">x</span> <span class="main">⟷</span> <span class="main">0</span> <span class="main">≤</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">including</span></span> integer.lifting <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Native_Cast-integer_of_char_ge_0"><span class="command">lemma</span></span> integer_of_char_ge_0 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">≤</span> integer_of_char <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> integer.lifting <span class="keyword1"><span class="command">unfolding</span></span> integer_of_char_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> of_char_def<span class="main">)</span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Conversion between native words›</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> uint8_of_uint16 <span class="main">::</span> <span class="quoted"><span class="quoted">"uint16 <span class="main">⇒</span> uint8"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">ucast</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> uint8_of_uint32 <span class="main">::</span> <span class="quoted"><span class="quoted">"uint32 <span class="main">⇒</span> uint8"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">ucast</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> uint8_of_uint64 <span class="main">::</span> <span class="quoted"><span class="quoted">"uint64 <span class="main">⇒</span> uint8"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">ucast</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> uint16_of_uint8 <span class="main">::</span> <span class="quoted"><span class="quoted">"uint8 <span class="main">⇒</span> uint16"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">ucast</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> uint16_of_uint32 <span class="main">::</span> <span class="quoted"><span class="quoted">"uint32 <span class="main">⇒</span> uint16"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">ucast</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> uint16_of_uint64 <span class="main">::</span> <span class="quoted"><span class="quoted">"uint64 <span class="main">⇒</span> uint16"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">ucast</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> uint32_of_uint8 <span class="main">::</span> <span class="quoted"><span class="quoted">"uint8 <span class="main">⇒</span> uint32"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">ucast</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> uint32_of_uint16 <span class="main">::</span> <span class="quoted"><span class="quoted">"uint16 <span class="main">⇒</span> uint32"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">ucast</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> uint32_of_uint64 <span class="main">::</span> <span class="quoted"><span class="quoted">"uint64 <span class="main">⇒</span> uint32"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">ucast</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> uint64_of_uint8 <span class="main">::</span> <span class="quoted"><span class="quoted">"uint8 <span class="main">⇒</span> uint64"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">ucast</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> uint64_of_uint16 <span class="main">::</span> <span class="quoted"><span class="quoted">"uint16 <span class="main">⇒</span> uint64"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">ucast</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> uint64_of_uint32 <span class="main">::</span> <span class="quoted"><span class="quoted">"uint32 <span class="main">⇒</span> uint64"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">ucast</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">context</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword2"><span class="keyword">qualified</span></span> <span class="keyword1"><span class="command">definition</span></span> <span class="entity">mask</span> <span class="main">::</span> <span class="quoted">integer</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">‹<span class="free">mask</span> <span class="main">=</span> <span class="main">(</span><span class="numeral">0xFFFFFFFF</span> <span class="main">::</span> integer<span class="main">)</span>›</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">code_printing</span></span>
  <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint8_of_uint16</span> <span class="main">⇀</span>
  <span class="main">(</span>SML_word<span class="main">)</span> <span class="quoted">"Word8.fromLarge (Word16.toLarge _)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"(Prelude.fromIntegral _ :: Uint8.Word8)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"_.toByte"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint8_of_uint32</span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Word8.fromLarge (Word32.toLarge _)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"(Prelude.fromIntegral _ :: Uint8.Word8)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"_.toByte"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint8_of_uint64</span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Word8.fromLarge (Uint64.toLarge _)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"(Prelude.fromIntegral _ :: Uint8.Word8)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"_.toByte"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint16_of_uint8</span> <span class="main">⇀</span>
  <span class="main">(</span>SML_word<span class="main">)</span> <span class="quoted">"Word16.fromLarge (Word8.toLarge _)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"(Prelude.fromIntegral _ :: Uint16.Word16)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"((_).toInt &amp; 0xFF).toChar"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint16_of_uint32</span> <span class="main">⇀</span>
  <span class="main">(</span>SML_word<span class="main">)</span> <span class="quoted">"Word16.fromLarge (Word32.toLarge _)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"(Prelude.fromIntegral _ :: Uint16.Word16)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"_.toChar"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint16_of_uint64</span> <span class="main">⇀</span>
  <span class="main">(</span>SML_word<span class="main">)</span> <span class="quoted">"Word16.fromLarge (Uint64.toLarge _)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"(Prelude.fromIntegral _ :: Uint16.Word16)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"_.toChar"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint32_of_uint8</span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Word32.fromLarge (Word8.toLarge _)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"(Prelude.fromIntegral _ :: Uint32.Word32)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"((_).toInt &amp; 0xFF)"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint32_of_uint16</span> <span class="main">⇀</span>
  <span class="main">(</span>SML_word<span class="main">)</span> <span class="quoted">"Word32.fromLarge (Word16.toLarge _)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"(Prelude.fromIntegral _ :: Uint32.Word32)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"(_).toInt"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint32_of_uint64</span> <span class="main">⇀</span>
  <span class="main">(</span>SML_word<span class="main">)</span> <span class="quoted">"Word32.fromLarge (Uint64.toLarge _)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"(Prelude.fromIntegral _ :: Uint32.Word32)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"(_).toInt"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Int64.to'_int32"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint64_of_uint8</span> <span class="main">⇀</span>
  <span class="main">(</span>SML_word<span class="main">)</span> <span class="quoted">"Word64.fromLarge (Word8.toLarge _)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"(Prelude.fromIntegral _ :: Uint64.Word64)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"((_).toLong &amp; 0xFF)"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint64_of_uint16</span> <span class="main">⇀</span>
  <span class="main">(</span>SML_word<span class="main">)</span> <span class="quoted">"Word64.fromLarge (Word16.toLarge _)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"(Prelude.fromIntegral _ :: Uint64.Word64)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"_.toLong"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint64_of_uint32</span> <span class="main">⇀</span>
  <span class="main">(</span>SML_word<span class="main">)</span> <span class="quoted">"Word64.fromLarge (Word32.toLarge _)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"(Prelude.fromIntegral _ :: Uint64.Word64)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"((_).toLong &amp; 0xFFFFFFFFL)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Int64.logand (Int64.of'_int32 _) (Int64.of'_string \"4294967295\")"</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Use <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> Abs_uint8'<span class="antiquote"><span class="antiquote">}</span></span></span></span> etc. instead of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> Rep_uint8<span class="antiquote"><span class="antiquote">}</span></span></span></span> in code equations
  for conversion functions to avoid exceptions during code generation when the
  target language provides only some of the uint types.
›</span></span>

<span class="keyword1" id="Native_Cast-uint8_of_uint16_code"><span class="command">lemma</span></span> uint8_of_uint16_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"uint8_of_uint16 <span class="free">x</span> <span class="main">=</span> Abs_uint8' <span class="main">(</span>ucast <span class="main">(</span>Rep_uint16' <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Native_Cast-uint8_of_uint32_code"><span class="command">lemma</span></span> uint8_of_uint32_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"uint8_of_uint32 <span class="free">x</span> <span class="main">=</span> Abs_uint8' <span class="main">(</span>ucast <span class="main">(</span>Rep_uint32' <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Native_Cast-uint8_of_uint64_code"><span class="command">lemma</span></span> uint8_of_uint64_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"uint8_of_uint64 <span class="free">x</span> <span class="main">=</span> Abs_uint8' <span class="main">(</span>ucast <span class="main">(</span>Rep_uint64' <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Native_Cast-uint16_of_uint8_code"><span class="command">lemma</span></span> uint16_of_uint8_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"uint16_of_uint8 <span class="free">x</span> <span class="main">=</span> Abs_uint16' <span class="main">(</span>ucast <span class="main">(</span>Rep_uint8' <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Native_Cast-uint16_of_uint32_code"><span class="command">lemma</span></span> uint16_of_uint32_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"uint16_of_uint32 <span class="free">x</span> <span class="main">=</span> Abs_uint16' <span class="main">(</span>ucast <span class="main">(</span>Rep_uint32' <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Native_Cast-uint16_of_uint64_code"><span class="command">lemma</span></span> uint16_of_uint64_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"uint16_of_uint64 <span class="free">x</span> <span class="main">=</span> Abs_uint16' <span class="main">(</span>ucast <span class="main">(</span>Rep_uint64' <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Native_Cast-uint32_of_uint8_code"><span class="command">lemma</span></span> uint32_of_uint8_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"uint32_of_uint8 <span class="free">x</span> <span class="main">=</span> Abs_uint32' <span class="main">(</span>ucast <span class="main">(</span>Rep_uint8' <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Native_Cast-uint32_of_uint16_code"><span class="command">lemma</span></span> uint32_of_uint16_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"uint32_of_uint16 <span class="free">x</span> <span class="main">=</span> Abs_uint32' <span class="main">(</span>ucast <span class="main">(</span>Rep_uint16' <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Native_Cast-uint32_of_uint64_code"><span class="command">lemma</span></span> uint32_of_uint64_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"uint32_of_uint64 <span class="free">x</span> <span class="main">=</span> Abs_uint32' <span class="main">(</span>ucast <span class="main">(</span>Rep_uint64' <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Native_Cast-uint64_of_uint8_code"><span class="command">lemma</span></span> uint64_of_uint8_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"uint64_of_uint8 <span class="free">x</span> <span class="main">=</span> Abs_uint64' <span class="main">(</span>ucast <span class="main">(</span>Rep_uint8' <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Native_Cast-uint64_of_uint16_code"><span class="command">lemma</span></span> uint64_of_uint16_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"uint64_of_uint16 <span class="free">x</span> <span class="main">=</span> Abs_uint64' <span class="main">(</span>ucast <span class="main">(</span>Rep_uint16' <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Native_Cast-uint64_of_uint32_code"><span class="command">lemma</span></span> uint64_of_uint32_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"uint64_of_uint32 <span class="free">x</span> <span class="main">=</span> Abs_uint64' <span class="main">(</span>ucast <span class="main">(</span>Rep_uint32' <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Native_Cast_Uint">
<div class="head">
<h1>Theory Native_Cast_Uint</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Native_Cast_Uint.thy
    Author:     Andreas Lochbihler, Digital Asset
*)</span>

<span class="keyword1"><span class="command">theory</span></span> Native_Cast_Uint <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Native_Cast.html">Native_Cast</a>
  <a href="Uint.html">Uint</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> uint_of_uint8 <span class="main">::</span> <span class="quoted"><span class="quoted">"uint8 <span class="main">⇒</span> uint"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">ucast</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> uint_of_uint16 <span class="main">::</span> <span class="quoted"><span class="quoted">"uint16 <span class="main">⇒</span> uint"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">ucast</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> uint_of_uint32 <span class="main">::</span> <span class="quoted"><span class="quoted">"uint32 <span class="main">⇒</span> uint"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">ucast</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> uint_of_uint64 <span class="main">::</span> <span class="quoted"><span class="quoted">"uint64 <span class="main">⇒</span> uint"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">ucast</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> uint8_of_uint <span class="main">::</span> <span class="quoted"><span class="quoted">"uint <span class="main">⇒</span> uint8"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">ucast</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> uint16_of_uint <span class="main">::</span> <span class="quoted"><span class="quoted">"uint <span class="main">⇒</span> uint16"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">ucast</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> uint32_of_uint <span class="main">::</span> <span class="quoted"><span class="quoted">"uint <span class="main">⇒</span> uint32"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">ucast</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> uint64_of_uint <span class="main">::</span> <span class="quoted"><span class="quoted">"uint <span class="main">⇒</span> uint64"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">ucast</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">code_printing</span></span>
  <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint_of_uint8</span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Word.fromLarge (Word8.toLarge _)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"(Prelude.fromIntegral _ :: Uint.Word)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"((_).toInt &amp; 0xFF)"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint_of_uint16</span> <span class="main">⇀</span>
  <span class="main">(</span>SML_word<span class="main">)</span> <span class="quoted">"Word.fromLarge (Word16.toLarge _)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"(Prelude.fromIntegral _ :: Uint.Word)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"(_).toInt"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint_of_uint32</span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Word.fromLarge (Word32.toLarge _)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"(Prelude.fromIntegral _ :: Uint.Word)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"_"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"(Int32.to'_int _) land Uint.int'_mask"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint_of_uint64</span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Word.fromLarge (Uint64.toLarge _)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"(Prelude.fromIntegral _ :: Uint.Word)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"(_).toInt"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Int64.to'_int"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint8_of_uint</span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Word8.fromLarge (Word.toLarge _)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"(Prelude.fromIntegral _ :: Uint8.Word8)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"(_).toByte"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint16_of_uint</span> <span class="main">⇀</span>
  <span class="main">(</span>SML_word<span class="main">)</span> <span class="quoted">"Word16.fromLarge (Word.toLarge _)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"(Prelude.fromIntegral _ :: Uint16.Word16)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"(_).toChar"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint32_of_uint</span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Word32.fromLarge (Word.toLarge _)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"(Prelude.fromIntegral _ :: Uint32.Word32)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"_"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Int32.logand (Int32.of'_int _) Uint.int32'_mask"</span>
<span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">uint64_of_uint</span> <span class="main">⇀</span>
  <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"Uint64.fromLarge (Word.toLarge _)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"(Prelude.fromIntegral _ :: Uint64.Word64)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>Scala<span class="main">)</span> <span class="quoted">"((_).toLong &amp; 0xFFFFFFFFL)"</span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="main">(</span>OCaml<span class="main">)</span> <span class="quoted">"Int64.logand (Int64.of'_int _) Uint.int64'_mask"</span>

<span class="keyword1" id="Native_Cast_Uint-uint8_of_uint_code"><span class="command">lemma</span></span> uint8_of_uint_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"uint8_of_uint <span class="free">x</span> <span class="main">=</span> Abs_uint8' <span class="main">(</span>ucast <span class="main">(</span>Rep_uint' <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Rep_uint'_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Native_Cast_Uint-uint16_of_uint_code"><span class="command">lemma</span></span> uint16_of_uint_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"uint16_of_uint <span class="free">x</span> <span class="main">=</span> Abs_uint16' <span class="main">(</span>ucast <span class="main">(</span>Rep_uint' <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Rep_uint'_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Native_Cast_Uint-uint32_of_uint_code"><span class="command">lemma</span></span> uint32_of_uint_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"uint32_of_uint <span class="free">x</span> <span class="main">=</span> Abs_uint32' <span class="main">(</span>ucast <span class="main">(</span>Rep_uint' <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Rep_uint'_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Native_Cast_Uint-uint64_of_uint_code"><span class="command">lemma</span></span> uint64_of_uint_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"uint64_of_uint <span class="free">x</span> <span class="main">=</span> Abs_uint64' <span class="main">(</span>ucast <span class="main">(</span>Rep_uint' <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Rep_uint'_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Native_Cast_Uint-uint_of_uint8_code"><span class="command">lemma</span></span> uint_of_uint8_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"uint_of_uint8 <span class="free">x</span> <span class="main">=</span> Abs_uint' <span class="main">(</span>ucast <span class="main">(</span>Rep_uint8' <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Native_Cast_Uint-uint_of_uint16_code"><span class="command">lemma</span></span> uint_of_uint16_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"uint_of_uint16 <span class="free">x</span> <span class="main">=</span> Abs_uint' <span class="main">(</span>ucast <span class="main">(</span>Rep_uint16' <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Native_Cast_Uint-uint_of_uint32_code"><span class="command">lemma</span></span> uint_of_uint32_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"uint_of_uint32 <span class="free">x</span> <span class="main">=</span> Abs_uint' <span class="main">(</span>ucast <span class="main">(</span>Rep_uint32' <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Native_Cast_Uint-uint_of_uint64_code"><span class="command">lemma</span></span> uint_of_uint64_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"uint_of_uint64 <span class="free">x</span> <span class="main">=</span> Abs_uint' <span class="main">(</span>ucast <span class="main">(</span>Rep_uint64' <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="Native_Word_Imperative_HOL">
<div class="head">
<h1>Theory Native_Word_Imperative_HOL</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Native_Word_Imperative_HOL.thy
    Author:     Andreas Lochbihler, ETH Zurich
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Compatibility with Imperative/HOL›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Native_Word_Imperative_HOL <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Code_Target_Word_Base.html">Code_Target_Word_Base</a>
  <span class="quoted">"<a href="../../HOL/HOL-Imperative_HOL/Heap_Monad.html">HOL-Imperative_HOL.Heap_Monad</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We add a code target that combines the translations for native words that are by default not
  supported by all PolyML versions with the adaptations for Imperative\_HOL.
›</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">Code_Target.add_derived_target</span> <span class="main">(</span><span class="inner_quoted">"SML_word_imp"</span><span class="main">,</span> <span class="main">[</span><span class="main">(</span><span class="inner_quoted">"SML_word"</span><span class="main">,</span> I<span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="inner_quoted">"SML_imp"</span><span class="main">,</span> I<span class="main">)</span><span class="main">]</span><span class="main">)</span>›</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Native_Word_Test">
<div class="head">
<h1>Theory Native_Word_Test</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Native_Word_Test.thy
    Author:     Andreas Lochbihler, ETH Zurich
*)</span>

<span class="keyword1"><span class="command">chapter</span></span> <span class="quoted"><span class="plain_text">‹Test cases›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Native_Word_Test <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Uint64.html">Uint64</a> <a href="Uint32.html">Uint32</a> <a href="Uint16.html">Uint16</a> <a href="Uint8.html">Uint8</a> <a href="Uint.html">Uint</a> <a href="Native_Cast_Uint.html">Native_Cast_Uint</a>
  <span class="quoted">"<a href="../../HOL/HOL-Library/Code_Test.html">HOL-Library.Code_Test</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Tests for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">uint32</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">notation</span></span> sshiftr_uint32 <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">&gt;&gt;&gt;</span>"</span> 55<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">test_uint32</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">test_uint32</span> <span class="main">⟷</span>
  <span class="main">(</span><span class="main">(</span><span class="main">[</span> <span class="numeral">0x100000001</span><span class="main">,</span> <span class="main">-</span><span class="main">1</span><span class="main">,</span> <span class="main">-</span><span class="numeral">4294967291</span><span class="main">,</span> <span class="numeral">0xFFFFFFFF</span><span class="main">,</span> <span class="numeral">0x12345678</span>
    <span class="main">,</span> <span class="numeral">0x5A</span> <span class="keyword1">AND</span> <span class="numeral">0x36</span>
    <span class="main">,</span> <span class="numeral">0x5A</span> <span class="keyword1">OR</span> <span class="numeral">0x36</span>
    <span class="main">,</span> <span class="numeral">0x5A</span> <span class="keyword1">XOR</span> <span class="numeral">0x36</span>
    <span class="main">,</span> <span class="keyword1">NOT</span> <span class="numeral">0x5A</span>
    <span class="main">,</span> <span class="numeral">5</span> <span class="main">+</span> <span class="numeral">6</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="main">+</span> <span class="numeral">6</span><span class="main">,</span> <span class="main">-</span><span class="numeral">6</span> <span class="main">+</span> <span class="numeral">5</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="main">+</span> <span class="main">(</span><span class="main">-</span> <span class="numeral">6</span><span class="main">)</span><span class="main">,</span> <span class="numeral">0xFFFFFFFFF</span> <span class="main">+</span> <span class="main">1</span>
    <span class="main">,</span> <span class="numeral">5</span> <span class="main">-</span> <span class="numeral">3</span><span class="main">,</span> <span class="numeral">3</span> <span class="main">-</span> <span class="numeral">5</span>
    <span class="main">,</span> <span class="numeral">5</span> <span class="main">*</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="main">*</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="main">*</span> <span class="main">-</span><span class="numeral">4</span><span class="main">,</span> <span class="numeral">0x12345678</span> <span class="main">*</span> <span class="numeral">0x87654321</span>
    <span class="main">,</span> <span class="numeral">5</span> <span class="keyword1">div</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="keyword1">div</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="keyword1">div</span> <span class="main">-</span><span class="numeral">3</span><span class="main">,</span> <span class="numeral">5</span> <span class="keyword1">div</span> <span class="main">-</span><span class="numeral">3</span>
    <span class="main">,</span> <span class="numeral">5</span> <span class="keyword1">mod</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="keyword1">mod</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="keyword1">mod</span> <span class="main">-</span><span class="numeral">3</span><span class="main">,</span> <span class="numeral">5</span> <span class="keyword1">mod</span> <span class="main">-</span><span class="numeral">3</span>
    <span class="main">,</span> set_bit <span class="numeral">5</span> <span class="numeral">4</span> True<span class="main">,</span> set_bit <span class="main">(</span><span class="main">-</span> <span class="numeral">5</span><span class="main">)</span> <span class="numeral">2</span> True<span class="main">,</span> set_bit <span class="numeral">5</span> <span class="main">0</span> False<span class="main">,</span> set_bit <span class="main">(</span><span class="main">-</span> <span class="numeral">5</span><span class="main">)</span> <span class="main">1</span> False
    <span class="main">,</span> set_bit <span class="numeral">5</span> <span class="numeral">32</span> True<span class="main">,</span> set_bit <span class="numeral">5</span> <span class="numeral">32</span> False<span class="main">,</span> set_bit <span class="main">(</span><span class="main">-</span> <span class="numeral">5</span><span class="main">)</span> <span class="numeral">32</span> True<span class="main">,</span> set_bit <span class="main">(</span><span class="main">-</span> <span class="numeral">5</span><span class="main">)</span> <span class="numeral">32</span> False
    <span class="main">,</span> <span class="main">1</span> <span class="main">&lt;&lt;</span> <span class="numeral">2</span><span class="main">,</span> <span class="main">-</span><span class="main">1</span> <span class="main">&lt;&lt;</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">1</span> <span class="main">&lt;&lt;</span> <span class="numeral">32</span><span class="main">,</span> <span class="main">1</span> <span class="main">&lt;&lt;</span> <span class="main">0</span>
    <span class="main">,</span> <span class="numeral">100</span> <span class="main">&gt;&gt;</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">-</span><span class="numeral">100</span> <span class="main">&gt;&gt;</span> <span class="numeral">3</span><span class="main">,</span> <span class="numeral">100</span> <span class="main">&gt;&gt;</span> <span class="numeral">32</span><span class="main">,</span> <span class="main">-</span><span class="numeral">100</span> <span class="main">&gt;&gt;</span> <span class="numeral">32</span>
    <span class="main">,</span> <span class="numeral">100</span> <span class="main">&gt;&gt;&gt;</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">-</span><span class="numeral">100</span> <span class="main">&gt;&gt;&gt;</span> <span class="numeral">3</span><span class="main">,</span> <span class="numeral">100</span> <span class="main">&gt;&gt;&gt;</span> <span class="numeral">32</span><span class="main">,</span> <span class="main">-</span><span class="numeral">100</span> <span class="main">&gt;&gt;&gt;</span> <span class="numeral">32</span><span class="main">]</span> <span class="main">::</span> uint32 list<span class="main">)</span>
   <span class="main">=</span>
    <span class="main">[</span> <span class="main">1</span><span class="main">,</span> <span class="numeral">4294967295</span><span class="main">,</span> <span class="numeral">5</span><span class="main">,</span> <span class="numeral">4294967295</span><span class="main">,</span> <span class="numeral">305419896</span>
    <span class="main">,</span> <span class="numeral">18</span>
    <span class="main">,</span> <span class="numeral">126</span>
    <span class="main">,</span> <span class="numeral">108</span>
    <span class="main">,</span> <span class="numeral">4294967205</span>
    <span class="main">,</span> <span class="numeral">11</span><span class="main">,</span> <span class="main">1</span><span class="main">,</span> <span class="numeral">4294967295</span><span class="main">,</span> <span class="numeral">4294967285</span><span class="main">,</span> <span class="main">0</span>
    <span class="main">,</span> <span class="numeral">2</span><span class="main">,</span> <span class="numeral">4294967294</span>
    <span class="main">,</span> <span class="numeral">15</span><span class="main">,</span> <span class="numeral">4294967281</span><span class="main">,</span> <span class="numeral">20</span><span class="main">,</span> <span class="numeral">1891143032</span>
    <span class="main">,</span> <span class="main">1</span><span class="main">,</span> <span class="numeral">1431655763</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="main">0</span>
    <span class="main">,</span> <span class="numeral">2</span><span class="main">,</span> <span class="numeral">2</span><span class="main">,</span> <span class="numeral">4294967291</span><span class="main">,</span> <span class="numeral">5</span> 
    <span class="main">,</span> <span class="numeral">21</span><span class="main">,</span> <span class="numeral">4294967295</span><span class="main">,</span> <span class="numeral">4</span><span class="main">,</span> <span class="numeral">4294967289</span>
    <span class="main">,</span> <span class="numeral">5</span><span class="main">,</span> <span class="numeral">5</span><span class="main">,</span> <span class="numeral">4294967291</span><span class="main">,</span> <span class="numeral">4294967291</span>
    <span class="main">,</span> <span class="numeral">4</span><span class="main">,</span> <span class="numeral">4294967288</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="main">1</span>
    <span class="main">,</span> <span class="numeral">12</span><span class="main">,</span> <span class="numeral">536870899</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="main">0</span>
    <span class="main">,</span> <span class="numeral">12</span><span class="main">,</span> <span class="numeral">4294967283</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="numeral">4294967295</span><span class="main">]</span><span class="main">)</span> <span class="main">∧</span>
  <span class="main">(</span><span class="main">[</span> <span class="main">(</span><span class="numeral">0x5</span> <span class="main">::</span> uint32<span class="main">)</span> <span class="main">=</span> <span class="numeral">0x5</span><span class="main">,</span> <span class="main">(</span><span class="numeral">0x5</span> <span class="main">::</span> uint32<span class="main">)</span> <span class="main">=</span> <span class="numeral">0x6</span>
   <span class="main">,</span> <span class="main">(</span><span class="numeral">0x5</span> <span class="main">::</span> uint32<span class="main">)</span> <span class="main">&lt;</span> <span class="numeral">0x5</span><span class="main">,</span> <span class="main">(</span><span class="numeral">0x5</span> <span class="main">::</span> uint32<span class="main">)</span> <span class="main">&lt;</span> <span class="numeral">0x6</span><span class="main">,</span> <span class="main">(</span><span class="main">-</span><span class="numeral">5</span> <span class="main">::</span> uint32<span class="main">)</span> <span class="main">&lt;</span> <span class="numeral">6</span><span class="main">,</span> <span class="main">(</span><span class="numeral">6</span> <span class="main">::</span> uint32<span class="main">)</span> <span class="main">&lt;</span> <span class="main">-</span><span class="numeral">5</span>
   <span class="main">,</span> <span class="main">(</span><span class="numeral">0x5</span> <span class="main">::</span> uint32<span class="main">)</span> <span class="main">≤</span> <span class="numeral">0x5</span><span class="main">,</span> <span class="main">(</span><span class="numeral">0x5</span> <span class="main">::</span> uint32<span class="main">)</span> <span class="main">≤</span> <span class="numeral">0x4</span><span class="main">,</span> <span class="main">(</span><span class="main">-</span><span class="numeral">5</span> <span class="main">::</span> uint32<span class="main">)</span> <span class="main">≤</span> <span class="numeral">6</span><span class="main">,</span> <span class="main">(</span><span class="numeral">6</span> <span class="main">::</span> uint32<span class="main">)</span> <span class="main">≤</span> <span class="main">-</span><span class="numeral">5</span> 
   <span class="main">,</span> <span class="main">(</span><span class="numeral">0x7FFFFFFF</span> <span class="main">::</span> uint32<span class="main">)</span> <span class="main">&lt;</span> <span class="numeral">0x80000000</span><span class="main">,</span> <span class="main">(</span><span class="numeral">0xFFFFFFFF</span> <span class="main">::</span> uint32<span class="main">)</span> <span class="main">&lt;</span> <span class="main">0</span><span class="main">,</span> <span class="main">(</span><span class="numeral">0x80000000</span> <span class="main">::</span> uint32<span class="main">)</span> <span class="main">&lt;</span> <span class="numeral">0x7FFFFFFF</span>
   <span class="main">,</span> <span class="main">(</span><span class="numeral">0x7FFFFFFF</span> <span class="main">::</span> uint32<span class="main">)</span> <span class="main">!!</span> <span class="main">0</span><span class="main">,</span> <span class="main">(</span><span class="numeral">0x7FFFFFFF</span> <span class="main">::</span> uint32<span class="main">)</span> <span class="main">!!</span> <span class="numeral">31</span><span class="main">,</span> <span class="main">(</span><span class="numeral">0x80000000</span> <span class="main">::</span> uint32<span class="main">)</span> <span class="main">!!</span> <span class="numeral">31</span><span class="main">,</span> <span class="main">(</span><span class="numeral">0x80000000</span> <span class="main">::</span> uint32<span class="main">)</span> <span class="main">!!</span> <span class="numeral">32</span>
   <span class="main">]</span>
  <span class="main">=</span>
   <span class="main">[</span> True<span class="main">,</span> False
   <span class="main">,</span> False<span class="main">,</span> True<span class="main">,</span> False<span class="main">,</span> True
   <span class="main">,</span> True<span class="main">,</span> False<span class="main">,</span> False<span class="main">,</span> True
   <span class="main">,</span> True<span class="main">,</span> False<span class="main">,</span> False
   <span class="main">,</span> True<span class="main">,</span> False<span class="main">,</span> True<span class="main">,</span> False
   <span class="main">]</span><span class="main">)</span> <span class="main">∧</span>
  <span class="main">(</span><span class="main">[</span>integer_of_uint32 <span class="main">0</span><span class="main">,</span> integer_of_uint32 <span class="numeral">0x7FFFFFFF</span><span class="main">,</span> integer_of_uint32 <span class="numeral">0x80000000</span><span class="main">,</span> integer_of_uint32 <span class="numeral">0xAAAAAAAA</span><span class="main">]</span>
  <span class="main">=</span>
   <span class="main">[</span><span class="main">0</span><span class="main">,</span> <span class="numeral">0x7FFFFFFF</span><span class="main">,</span> <span class="numeral">0x80000000</span><span class="main">,</span> <span class="numeral">0xAAAAAAAA</span><span class="main">]</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">no_notation</span></span> sshiftr_uint32 <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">&gt;&gt;&gt;</span>"</span> 55<span class="main">)</span>

<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">test_uint32</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML Haskell<span class="main">?</span> OCaml<span class="main">?</span> Scala

<span class="keyword1"><span class="command">notepad</span></span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">have</span></span> <span class="quoted">test_uint32</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">have</span></span> <span class="quoted">test_uint32</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">code_simp</span>
<span class="keyword1"><span class="command">have</span></span> <span class="quoted">test_uint32</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">normalization</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">test_uint32'</span> <span class="main">::</span> <span class="quoted">uint32</span> 
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">test_uint32'</span> <span class="main">=</span> <span class="main">0</span> <span class="main">+</span> <span class="numeral">10</span> <span class="main">-</span> <span class="numeral">14</span> <span class="main">*</span> <span class="numeral">3</span> <span class="keyword1">div</span> <span class="numeral">6</span> <span class="keyword1">mod</span> <span class="numeral">3</span> <span class="main">&lt;&lt;</span> <span class="numeral">3</span> <span class="main">&gt;&gt;</span> <span class="numeral">2</span>"</span></span>
<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹<span class="keyword1"><span class="keyword">val</span></span> <span class="inner_numeral">0wx12</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">test_uint32'</span><span class="antiquote">}</span></span></span>›</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="keyword1">AND</span> <span class="free">y</span> <span class="main">=</span> <span class="free">x</span> <span class="keyword1">OR</span> <span class="main">(</span><span class="free">y</span> <span class="main">::</span> uint32<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">quickcheck</span></span><span class="main">[</span>random<span class="main">,</span> expect<span class="main">=</span>counterexample<span class="main">]</span>
<span class="keyword1"><span class="command">quickcheck</span></span><span class="main">[</span>exhaustive<span class="main">,</span> expect<span class="main">=</span>counterexample<span class="main">]</span>
<span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">::</span> uint32<span class="main">)</span> <span class="keyword1">AND</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span> <span class="keyword1">OR</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">quickcheck</span></span><span class="main">[</span>narrowing<span class="main">,</span> expect<span class="main">=</span>no_counterexample<span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span> <span class="main">::</span> uint32 <span class="main">⇒</span> unit<span class="main">)</span> <span class="main">=</span> <span class="free">g</span>"</span></span>
<span class="keyword1"><span class="command">quickcheck</span></span><span class="main">[</span>narrowing<span class="main">,</span> size<span class="main">=</span>3<span class="main">,</span> expect<span class="main">=</span>no_counterexample<span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Tests for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">uint16</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">notation</span></span> sshiftr_uint16 <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">&gt;&gt;&gt;</span>"</span> 55<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">test_uint16</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">test_uint16</span> <span class="main">⟷</span>
  <span class="main">(</span><span class="main">(</span><span class="main">[</span> <span class="numeral">0x10001</span><span class="main">,</span> <span class="main">-</span><span class="main">1</span><span class="main">,</span> <span class="main">-</span><span class="numeral">65535</span><span class="main">,</span> <span class="numeral">0xFFFF</span><span class="main">,</span> <span class="numeral">0x1234</span>
    <span class="main">,</span> <span class="numeral">0x5A</span> <span class="keyword1">AND</span> <span class="numeral">0x36</span>
    <span class="main">,</span> <span class="numeral">0x5A</span> <span class="keyword1">OR</span> <span class="numeral">0x36</span>
    <span class="main">,</span> <span class="numeral">0x5A</span> <span class="keyword1">XOR</span> <span class="numeral">0x36</span>
    <span class="main">,</span> <span class="keyword1">NOT</span> <span class="numeral">0x5A</span>
    <span class="main">,</span> <span class="numeral">5</span> <span class="main">+</span> <span class="numeral">6</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="main">+</span> <span class="numeral">6</span><span class="main">,</span> <span class="main">-</span><span class="numeral">6</span> <span class="main">+</span> <span class="numeral">5</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="main">+</span> <span class="main">-</span><span class="numeral">6</span><span class="main">,</span> <span class="numeral">0xFFFF</span> <span class="main">+</span> <span class="main">1</span>
    <span class="main">,</span> <span class="numeral">5</span> <span class="main">-</span> <span class="numeral">3</span><span class="main">,</span> <span class="numeral">3</span> <span class="main">-</span> <span class="numeral">5</span>
    <span class="main">,</span> <span class="numeral">5</span> <span class="main">*</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="main">*</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="main">*</span> <span class="main">-</span><span class="numeral">4</span><span class="main">,</span> <span class="numeral">0x1234</span> <span class="main">*</span> <span class="numeral">0x8765</span>
    <span class="main">,</span> <span class="numeral">5</span> <span class="keyword1">div</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="keyword1">div</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="keyword1">div</span> <span class="main">-</span><span class="numeral">3</span><span class="main">,</span> <span class="numeral">5</span> <span class="keyword1">div</span> <span class="main">-</span><span class="numeral">3</span>
    <span class="main">,</span> <span class="numeral">5</span> <span class="keyword1">mod</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="keyword1">mod</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="keyword1">mod</span> <span class="main">-</span><span class="numeral">3</span><span class="main">,</span> <span class="numeral">5</span> <span class="keyword1">mod</span> <span class="main">-</span><span class="numeral">3</span>
    <span class="main">,</span> set_bit <span class="numeral">5</span> <span class="numeral">4</span> True<span class="main">,</span> set_bit <span class="main">(</span><span class="main">-</span> <span class="numeral">5</span><span class="main">)</span> <span class="numeral">2</span> True<span class="main">,</span> set_bit <span class="numeral">5</span> <span class="main">0</span> False<span class="main">,</span> set_bit <span class="main">(</span><span class="main">-</span> <span class="numeral">5</span><span class="main">)</span> <span class="main">1</span> False
    <span class="main">,</span> set_bit <span class="numeral">5</span> <span class="numeral">32</span> True<span class="main">,</span> set_bit <span class="numeral">5</span> <span class="numeral">32</span> False<span class="main">,</span> set_bit <span class="main">(</span><span class="main">-</span> <span class="numeral">5</span><span class="main">)</span> <span class="numeral">32</span> True<span class="main">,</span> set_bit <span class="main">(</span><span class="main">-</span> <span class="numeral">5</span><span class="main">)</span> <span class="numeral">32</span> False
    <span class="main">,</span> <span class="main">1</span> <span class="main">&lt;&lt;</span> <span class="numeral">2</span><span class="main">,</span> <span class="main">-</span><span class="main">1</span> <span class="main">&lt;&lt;</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">1</span> <span class="main">&lt;&lt;</span> <span class="numeral">16</span><span class="main">,</span> <span class="main">1</span> <span class="main">&lt;&lt;</span> <span class="main">0</span>
    <span class="main">,</span> <span class="numeral">100</span> <span class="main">&gt;&gt;</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">-</span><span class="numeral">100</span> <span class="main">&gt;&gt;</span> <span class="numeral">3</span><span class="main">,</span> <span class="numeral">100</span> <span class="main">&gt;&gt;</span> <span class="numeral">16</span><span class="main">,</span> <span class="main">-</span><span class="numeral">100</span> <span class="main">&gt;&gt;</span> <span class="numeral">16</span>
    <span class="main">,</span> <span class="numeral">100</span> <span class="main">&gt;&gt;&gt;</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">-</span><span class="numeral">100</span> <span class="main">&gt;&gt;&gt;</span> <span class="numeral">3</span><span class="main">,</span> <span class="numeral">100</span> <span class="main">&gt;&gt;&gt;</span> <span class="numeral">16</span><span class="main">,</span> <span class="main">-</span><span class="numeral">100</span> <span class="main">&gt;&gt;&gt;</span> <span class="numeral">16</span><span class="main">]</span> <span class="main">::</span> uint16 list<span class="main">)</span>
   <span class="main">=</span>
    <span class="main">[</span> <span class="main">1</span><span class="main">,</span> <span class="numeral">65535</span><span class="main">,</span> <span class="main">1</span><span class="main">,</span> <span class="numeral">65535</span><span class="main">,</span> <span class="numeral">4660</span>
    <span class="main">,</span> <span class="numeral">18</span>
    <span class="main">,</span> <span class="numeral">126</span>
    <span class="main">,</span> <span class="numeral">108</span>
    <span class="main">,</span> <span class="numeral">65445</span>
    <span class="main">,</span> <span class="numeral">11</span><span class="main">,</span> <span class="main">1</span><span class="main">,</span> <span class="numeral">65535</span><span class="main">,</span> <span class="numeral">65525</span><span class="main">,</span> <span class="main">0</span>
    <span class="main">,</span> <span class="numeral">2</span><span class="main">,</span> <span class="numeral">65534</span>
    <span class="main">,</span> <span class="numeral">15</span><span class="main">,</span> <span class="numeral">65521</span><span class="main">,</span> <span class="numeral">20</span><span class="main">,</span> <span class="numeral">39556</span>
    <span class="main">,</span> <span class="main">1</span><span class="main">,</span> <span class="numeral">21843</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="main">0</span>
    <span class="main">,</span> <span class="numeral">2</span><span class="main">,</span> <span class="numeral">2</span><span class="main">,</span> <span class="numeral">65531</span><span class="main">,</span> <span class="numeral">5</span>
    <span class="main">,</span> <span class="numeral">21</span><span class="main">,</span> <span class="numeral">65535</span><span class="main">,</span> <span class="numeral">4</span><span class="main">,</span> <span class="numeral">65529</span>
    <span class="main">,</span> <span class="numeral">5</span><span class="main">,</span> <span class="numeral">5</span><span class="main">,</span> <span class="numeral">65531</span><span class="main">,</span> <span class="numeral">65531</span>
    <span class="main">,</span> <span class="numeral">4</span><span class="main">,</span> <span class="numeral">65528</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="main">1</span>
    <span class="main">,</span> <span class="numeral">12</span><span class="main">,</span> <span class="numeral">8179</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="main">0</span>
    <span class="main">,</span> <span class="numeral">12</span><span class="main">,</span> <span class="numeral">65523</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="numeral">65535</span><span class="main">]</span><span class="main">)</span> <span class="main">∧</span>
  <span class="main">(</span><span class="main">[</span> <span class="main">(</span><span class="numeral">0x5</span> <span class="main">::</span> uint16<span class="main">)</span> <span class="main">=</span> <span class="numeral">0x5</span><span class="main">,</span> <span class="main">(</span><span class="numeral">0x5</span> <span class="main">::</span> uint16<span class="main">)</span> <span class="main">=</span> <span class="numeral">0x6</span>
   <span class="main">,</span> <span class="main">(</span><span class="numeral">0x5</span> <span class="main">::</span> uint16<span class="main">)</span> <span class="main">&lt;</span> <span class="numeral">0x5</span><span class="main">,</span> <span class="main">(</span><span class="numeral">0x5</span> <span class="main">::</span> uint16<span class="main">)</span> <span class="main">&lt;</span> <span class="numeral">0x6</span><span class="main">,</span> <span class="main">(</span><span class="main">-</span><span class="numeral">5</span> <span class="main">::</span> uint16<span class="main">)</span> <span class="main">&lt;</span> <span class="numeral">6</span><span class="main">,</span> <span class="main">(</span><span class="numeral">6</span> <span class="main">::</span> uint16<span class="main">)</span> <span class="main">&lt;</span> <span class="main">-</span><span class="numeral">5</span>
   <span class="main">,</span> <span class="main">(</span><span class="numeral">0x5</span> <span class="main">::</span> uint16<span class="main">)</span> <span class="main">≤</span> <span class="numeral">0x5</span><span class="main">,</span> <span class="main">(</span><span class="numeral">0x5</span> <span class="main">::</span> uint16<span class="main">)</span> <span class="main">≤</span> <span class="numeral">0x4</span><span class="main">,</span> <span class="main">(</span><span class="main">-</span><span class="numeral">5</span> <span class="main">::</span> uint16<span class="main">)</span> <span class="main">≤</span> <span class="numeral">6</span><span class="main">,</span> <span class="main">(</span><span class="numeral">6</span> <span class="main">::</span> uint16<span class="main">)</span> <span class="main">≤</span> <span class="main">-</span><span class="numeral">5</span> 
   <span class="main">,</span> <span class="main">(</span><span class="numeral">0x7FFF</span> <span class="main">::</span> uint16<span class="main">)</span> <span class="main">&lt;</span> <span class="numeral">0x8000</span><span class="main">,</span> <span class="main">(</span><span class="numeral">0xFFFF</span> <span class="main">::</span> uint16<span class="main">)</span> <span class="main">&lt;</span> <span class="main">0</span><span class="main">,</span> <span class="main">(</span><span class="numeral">0x8000</span> <span class="main">::</span> uint16<span class="main">)</span> <span class="main">&lt;</span> <span class="numeral">0x7FFF</span>
   <span class="main">,</span> <span class="main">(</span><span class="numeral">0x7FFF</span> <span class="main">::</span> uint16<span class="main">)</span> <span class="main">!!</span> <span class="main">0</span><span class="main">,</span> <span class="main">(</span><span class="numeral">0x7FFF</span> <span class="main">::</span> uint16<span class="main">)</span> <span class="main">!!</span> <span class="numeral">15</span><span class="main">,</span> <span class="main">(</span><span class="numeral">0x8000</span> <span class="main">::</span> uint16<span class="main">)</span> <span class="main">!!</span> <span class="numeral">15</span><span class="main">,</span> <span class="main">(</span><span class="numeral">0x8000</span> <span class="main">::</span> uint16<span class="main">)</span> <span class="main">!!</span> <span class="numeral">16</span>
   <span class="main">]</span>
  <span class="main">=</span>
   <span class="main">[</span> True<span class="main">,</span> False
   <span class="main">,</span> False<span class="main">,</span> True<span class="main">,</span> False<span class="main">,</span> True
   <span class="main">,</span> True<span class="main">,</span> False<span class="main">,</span> False<span class="main">,</span> True
   <span class="main">,</span> True<span class="main">,</span> False<span class="main">,</span> False
   <span class="main">,</span> True<span class="main">,</span> False<span class="main">,</span> True<span class="main">,</span> False
   <span class="main">]</span><span class="main">)</span> <span class="main">∧</span>
  <span class="main">(</span><span class="main">[</span>integer_of_uint16 <span class="main">0</span><span class="main">,</span> integer_of_uint16 <span class="numeral">0x7FFF</span><span class="main">,</span> integer_of_uint16 <span class="numeral">0x8000</span><span class="main">,</span> integer_of_uint16 <span class="numeral">0xAAAA</span><span class="main">]</span>
  <span class="main">=</span>
   <span class="main">[</span><span class="main">0</span><span class="main">,</span> <span class="numeral">0x7FFF</span><span class="main">,</span> <span class="numeral">0x8000</span><span class="main">,</span> <span class="numeral">0xAAAA</span><span class="main">]</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">no_notation</span></span> sshiftr_uint16 <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">&gt;&gt;&gt;</span>"</span> 55<span class="main">)</span>

<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">test_uint16</span></span> <span class="keyword2"><span class="keyword">checking</span></span> Haskell<span class="main">?</span> Scala
<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">test_uint16</span></span> <span class="keyword2"><span class="keyword">in</span></span> SML_word

<span class="keyword1"><span class="command">notepad</span></span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">have</span></span> <span class="quoted">test_uint16</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">code_simp</span>
<span class="keyword1"><span class="command">have</span></span> <span class="quoted">test_uint16</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">normalization</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">::</span> uint16<span class="main">)</span> <span class="keyword1">AND</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span> <span class="keyword1">OR</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">quickcheck</span></span><span class="main">[</span>narrowing<span class="main">,</span> expect<span class="main">=</span>no_counterexample<span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span> <span class="main">::</span> uint16 <span class="main">⇒</span> unit<span class="main">)</span> <span class="main">=</span> <span class="free">g</span>"</span></span>
<span class="keyword1"><span class="command">quickcheck</span></span><span class="main">[</span>narrowing<span class="main">,</span> size<span class="main">=</span>3<span class="main">,</span> expect<span class="main">=</span>no_counterexample<span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Tests for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">uint8</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">notation</span></span> sshiftr_uint8 <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">&gt;&gt;&gt;</span>"</span> 55<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">test_uint8</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">test_uint8</span> <span class="main">⟷</span> 
  <span class="main">(</span><span class="main">(</span><span class="main">[</span> <span class="numeral">0x101</span><span class="main">,</span> <span class="main">-</span><span class="main">1</span><span class="main">,</span> <span class="main">-</span><span class="numeral">255</span><span class="main">,</span> <span class="numeral">0xFF</span><span class="main">,</span> <span class="numeral">0x12</span>
    <span class="main">,</span> <span class="numeral">0x5A</span> <span class="keyword1">AND</span> <span class="numeral">0x36</span>
    <span class="main">,</span> <span class="numeral">0x5A</span> <span class="keyword1">OR</span> <span class="numeral">0x36</span>
    <span class="main">,</span> <span class="numeral">0x5A</span> <span class="keyword1">XOR</span> <span class="numeral">0x36</span>
    <span class="main">,</span> <span class="keyword1">NOT</span> <span class="numeral">0x5A</span>
    <span class="main">,</span> <span class="numeral">5</span> <span class="main">+</span> <span class="numeral">6</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="main">+</span> <span class="numeral">6</span><span class="main">,</span> <span class="main">-</span><span class="numeral">6</span> <span class="main">+</span> <span class="numeral">5</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="main">+</span> <span class="main">-</span><span class="numeral">6</span><span class="main">,</span> <span class="numeral">0xFF</span> <span class="main">+</span> <span class="main">1</span>
    <span class="main">,</span> <span class="numeral">5</span> <span class="main">-</span> <span class="numeral">3</span><span class="main">,</span> <span class="numeral">3</span> <span class="main">-</span> <span class="numeral">5</span>
    <span class="main">,</span> <span class="numeral">5</span> <span class="main">*</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="main">*</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="main">*</span> <span class="main">-</span><span class="numeral">4</span><span class="main">,</span> <span class="numeral">0x12</span> <span class="main">*</span> <span class="numeral">0x87</span>
    <span class="main">,</span> <span class="numeral">5</span> <span class="keyword1">div</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="keyword1">div</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="keyword1">div</span> <span class="main">-</span><span class="numeral">3</span><span class="main">,</span> <span class="numeral">5</span> <span class="keyword1">div</span> <span class="main">-</span><span class="numeral">3</span>
    <span class="main">,</span> <span class="numeral">5</span> <span class="keyword1">mod</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="keyword1">mod</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="keyword1">mod</span> <span class="main">-</span><span class="numeral">3</span><span class="main">,</span> <span class="numeral">5</span> <span class="keyword1">mod</span> <span class="main">-</span><span class="numeral">3</span>
    <span class="main">,</span> set_bit <span class="numeral">5</span> <span class="numeral">4</span> True<span class="main">,</span> set_bit <span class="main">(</span><span class="main">-</span> <span class="numeral">5</span><span class="main">)</span> <span class="numeral">2</span> True<span class="main">,</span> set_bit <span class="numeral">5</span> <span class="main">0</span> False<span class="main">,</span> set_bit <span class="main">(</span><span class="main">-</span> <span class="numeral">5</span><span class="main">)</span> <span class="main">1</span> False
    <span class="main">,</span> set_bit <span class="numeral">5</span> <span class="numeral">32</span> True<span class="main">,</span> set_bit <span class="numeral">5</span> <span class="numeral">32</span> False<span class="main">,</span> set_bit <span class="main">(</span><span class="main">-</span> <span class="numeral">5</span><span class="main">)</span> <span class="numeral">32</span> True<span class="main">,</span> set_bit <span class="main">(</span><span class="main">-</span> <span class="numeral">5</span><span class="main">)</span> <span class="numeral">32</span> False
    <span class="main">,</span> <span class="main">1</span> <span class="main">&lt;&lt;</span> <span class="numeral">2</span><span class="main">,</span> <span class="main">-</span><span class="main">1</span> <span class="main">&lt;&lt;</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">1</span> <span class="main">&lt;&lt;</span> <span class="numeral">8</span><span class="main">,</span> <span class="main">1</span> <span class="main">&lt;&lt;</span> <span class="main">0</span>
    <span class="main">,</span> <span class="numeral">100</span> <span class="main">&gt;&gt;</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">-</span><span class="numeral">100</span> <span class="main">&gt;&gt;</span> <span class="numeral">3</span><span class="main">,</span> <span class="numeral">100</span> <span class="main">&gt;&gt;</span> <span class="numeral">8</span><span class="main">,</span> <span class="main">-</span><span class="numeral">100</span> <span class="main">&gt;&gt;</span> <span class="numeral">8</span>
    <span class="main">,</span> <span class="numeral">100</span> <span class="main">&gt;&gt;&gt;</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">-</span><span class="numeral">100</span> <span class="main">&gt;&gt;&gt;</span> <span class="numeral">3</span><span class="main">,</span> <span class="numeral">100</span> <span class="main">&gt;&gt;&gt;</span> <span class="numeral">8</span><span class="main">,</span> <span class="main">-</span><span class="numeral">100</span> <span class="main">&gt;&gt;&gt;</span> <span class="numeral">8</span><span class="main">]</span> <span class="main">::</span> uint8 list<span class="main">)</span>
   <span class="main">=</span>
    <span class="main">[</span> <span class="main">1</span><span class="main">,</span> <span class="numeral">255</span><span class="main">,</span> <span class="main">1</span><span class="main">,</span> <span class="numeral">255</span><span class="main">,</span> <span class="numeral">18</span>
    <span class="main">,</span> <span class="numeral">18</span>
    <span class="main">,</span> <span class="numeral">126</span>
    <span class="main">,</span> <span class="numeral">108</span>
    <span class="main">,</span> <span class="numeral">165</span>
    <span class="main">,</span> <span class="numeral">11</span><span class="main">,</span> <span class="main">1</span><span class="main">,</span> <span class="numeral">255</span><span class="main">,</span> <span class="numeral">245</span><span class="main">,</span> <span class="main">0</span>
    <span class="main">,</span> <span class="numeral">2</span><span class="main">,</span> <span class="numeral">254</span>
    <span class="main">,</span> <span class="numeral">15</span><span class="main">,</span> <span class="numeral">241</span><span class="main">,</span> <span class="numeral">20</span><span class="main">,</span> <span class="numeral">126</span>
    <span class="main">,</span> <span class="main">1</span><span class="main">,</span> <span class="numeral">83</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="main">0</span>
    <span class="main">,</span> <span class="numeral">2</span><span class="main">,</span> <span class="numeral">2</span><span class="main">,</span> <span class="numeral">251</span><span class="main">,</span> <span class="numeral">5</span>
    <span class="main">,</span> <span class="numeral">21</span><span class="main">,</span> <span class="numeral">255</span><span class="main">,</span> <span class="numeral">4</span><span class="main">,</span> <span class="numeral">249</span>
    <span class="main">,</span> <span class="numeral">5</span><span class="main">,</span> <span class="numeral">5</span><span class="main">,</span> <span class="numeral">251</span><span class="main">,</span> <span class="numeral">251</span>
    <span class="main">,</span> <span class="numeral">4</span><span class="main">,</span> <span class="numeral">248</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="main">1</span>
    <span class="main">,</span> <span class="numeral">12</span><span class="main">,</span> <span class="numeral">19</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="main">0</span>
    <span class="main">,</span> <span class="numeral">12</span><span class="main">,</span> <span class="numeral">243</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="numeral">255</span><span class="main">]</span><span class="main">)</span> <span class="main">∧</span>
  <span class="main">(</span><span class="main">[</span> <span class="main">(</span><span class="numeral">0x5</span> <span class="main">::</span> uint8<span class="main">)</span> <span class="main">=</span> <span class="numeral">0x5</span><span class="main">,</span> <span class="main">(</span><span class="numeral">0x5</span> <span class="main">::</span> uint8<span class="main">)</span> <span class="main">=</span> <span class="numeral">0x6</span>
   <span class="main">,</span> <span class="main">(</span><span class="numeral">0x5</span> <span class="main">::</span> uint8<span class="main">)</span> <span class="main">&lt;</span> <span class="numeral">0x5</span><span class="main">,</span> <span class="main">(</span><span class="numeral">0x5</span> <span class="main">::</span> uint8<span class="main">)</span> <span class="main">&lt;</span> <span class="numeral">0x6</span><span class="main">,</span> <span class="main">(</span><span class="main">-</span><span class="numeral">5</span> <span class="main">::</span> uint8<span class="main">)</span> <span class="main">&lt;</span> <span class="numeral">6</span><span class="main">,</span> <span class="main">(</span><span class="numeral">6</span> <span class="main">::</span> uint8<span class="main">)</span> <span class="main">&lt;</span> <span class="main">-</span><span class="numeral">5</span>
   <span class="main">,</span> <span class="main">(</span><span class="numeral">0x5</span> <span class="main">::</span> uint8<span class="main">)</span> <span class="main">≤</span> <span class="numeral">0x5</span><span class="main">,</span> <span class="main">(</span><span class="numeral">0x5</span> <span class="main">::</span> uint8<span class="main">)</span> <span class="main">≤</span> <span class="numeral">0x4</span><span class="main">,</span> <span class="main">(</span><span class="main">-</span><span class="numeral">5</span> <span class="main">::</span> uint8<span class="main">)</span> <span class="main">≤</span> <span class="numeral">6</span><span class="main">,</span> <span class="main">(</span><span class="numeral">6</span> <span class="main">::</span> uint8<span class="main">)</span> <span class="main">≤</span> <span class="main">-</span><span class="numeral">5</span> 
   <span class="main">,</span> <span class="main">(</span><span class="numeral">0x7F</span> <span class="main">::</span> uint8<span class="main">)</span> <span class="main">&lt;</span> <span class="numeral">0x80</span><span class="main">,</span> <span class="main">(</span><span class="numeral">0xFF</span> <span class="main">::</span> uint8<span class="main">)</span> <span class="main">&lt;</span> <span class="main">0</span><span class="main">,</span> <span class="main">(</span><span class="numeral">0x80</span> <span class="main">::</span> uint8<span class="main">)</span> <span class="main">&lt;</span> <span class="numeral">0x7F</span>
   <span class="main">,</span> <span class="main">(</span><span class="numeral">0x7F</span> <span class="main">::</span> uint8<span class="main">)</span> <span class="main">!!</span> <span class="main">0</span><span class="main">,</span> <span class="main">(</span><span class="numeral">0x7F</span> <span class="main">::</span> uint8<span class="main">)</span> <span class="main">!!</span> <span class="numeral">7</span><span class="main">,</span> <span class="main">(</span><span class="numeral">0x80</span> <span class="main">::</span> uint8<span class="main">)</span> <span class="main">!!</span> <span class="numeral">7</span><span class="main">,</span> <span class="main">(</span><span class="numeral">0x80</span> <span class="main">::</span> uint8<span class="main">)</span> <span class="main">!!</span> <span class="numeral">8</span>
   <span class="main">]</span>
  <span class="main">=</span>
   <span class="main">[</span> True<span class="main">,</span> False
   <span class="main">,</span> False<span class="main">,</span> True<span class="main">,</span> False<span class="main">,</span> True
   <span class="main">,</span> True<span class="main">,</span> False<span class="main">,</span> False<span class="main">,</span> True
   <span class="main">,</span> True<span class="main">,</span> False<span class="main">,</span> False
   <span class="main">,</span> True<span class="main">,</span> False<span class="main">,</span> True<span class="main">,</span> False
   <span class="main">]</span><span class="main">)</span> <span class="main">∧</span>
  <span class="main">(</span><span class="main">[</span>integer_of_uint8 <span class="main">0</span><span class="main">,</span> integer_of_uint8 <span class="numeral">0x7F</span><span class="main">,</span> integer_of_uint8 <span class="numeral">0x80</span><span class="main">,</span> integer_of_uint8 <span class="numeral">0xAA</span><span class="main">]</span>
  <span class="main">=</span>
   <span class="main">[</span><span class="main">0</span><span class="main">,</span> <span class="numeral">0x7F</span><span class="main">,</span> <span class="numeral">0x80</span><span class="main">,</span> <span class="numeral">0xAA</span><span class="main">]</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">no_notation</span></span> sshiftr_uint8 <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">&gt;&gt;&gt;</span>"</span> 55<span class="main">)</span>

<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">test_uint8</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML Haskell<span class="main">?</span> Scala

<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">test_uint8</span></span> <span class="keyword2"><span class="keyword">in</span></span> SML

<span class="keyword1"><span class="command">notepad</span></span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">have</span></span> <span class="quoted">test_uint8</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">have</span></span> <span class="quoted">test_uint8</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">code_simp</span>
<span class="keyword1"><span class="command">have</span></span> <span class="quoted">test_uint8</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">normalization</span>
<span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword1"><span class="command">ML_val</span></span> <span class="quoted">‹<span class="keyword1"><span class="keyword">val</span></span> true <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">test_uint8</span><span class="antiquote">}</span></span></span>›</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">test_uint8'</span> <span class="main">::</span> <span class="quoted">uint8</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">test_uint8'</span> <span class="main">=</span> <span class="main">0</span> <span class="main">+</span> <span class="numeral">10</span> <span class="main">-</span> <span class="numeral">14</span> <span class="main">*</span> <span class="numeral">3</span> <span class="keyword1">div</span> <span class="numeral">6</span> <span class="keyword1">mod</span> <span class="numeral">3</span> <span class="main">&lt;&lt;</span> <span class="numeral">3</span> <span class="main">&gt;&gt;</span> <span class="numeral">2</span>"</span></span>
<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹<span class="keyword1"><span class="keyword">val</span></span> <span class="inner_numeral">0wx12</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">test_uint8'</span><span class="antiquote">}</span></span></span>›</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="keyword1">AND</span> <span class="free">y</span> <span class="main">=</span> <span class="free">x</span> <span class="keyword1">OR</span> <span class="main">(</span><span class="free">y</span> <span class="main">::</span> uint8<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">quickcheck</span></span><span class="main">[</span>random<span class="main">,</span> expect<span class="main">=</span>counterexample<span class="main">]</span>
<span class="keyword1"><span class="command">quickcheck</span></span><span class="main">[</span>exhaustive<span class="main">,</span> expect<span class="main">=</span>counterexample<span class="main">]</span>
<span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">::</span> uint8<span class="main">)</span> <span class="keyword1">AND</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span> <span class="keyword1">OR</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">quickcheck</span></span><span class="main">[</span>narrowing<span class="main">,</span> expect<span class="main">=</span>no_counterexample<span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span> <span class="main">::</span> uint8 <span class="main">⇒</span> unit<span class="main">)</span> <span class="main">=</span> <span class="free">g</span>"</span></span>
<span class="keyword1"><span class="command">quickcheck</span></span><span class="main">[</span>narrowing<span class="main">,</span> size<span class="main">=</span>3<span class="main">,</span> expect<span class="main">=</span>no_counterexample<span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Tests for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"uint"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">notation</span></span> sshiftr_uint <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">&gt;&gt;&gt;</span>"</span> 55<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">test_uint</span> <span class="main">≡</span> <span class="keyword1">let</span> 
  <span class="bound">test_list1</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span>
      <span class="bound">HS</span> <span class="main">=</span> uint_of_int <span class="main">(</span><span class="numeral">2</span> <span class="main">^</span> <span class="main">(</span>dflt_size <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1">in</span>
      <span class="main">(</span><span class="main">[</span> <span class="bound">HS</span> <span class="main">+</span> <span class="bound">HS</span> <span class="main">+</span> <span class="main">1</span><span class="main">,</span> <span class="main">-</span><span class="main">1</span><span class="main">,</span> <span class="main">-</span><span class="bound">HS</span> <span class="main">-</span> <span class="bound">HS</span> <span class="main">+</span> <span class="numeral">5</span><span class="main">,</span> <span class="bound">HS</span> <span class="main">+</span> <span class="main">(</span><span class="bound">HS</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">,</span> <span class="numeral">0x12</span>
      <span class="main">,</span> <span class="numeral">0x5A</span> <span class="keyword1">AND</span> <span class="numeral">0x36</span>
      <span class="main">,</span> <span class="numeral">0x5A</span> <span class="keyword1">OR</span> <span class="numeral">0x36</span>
      <span class="main">,</span> <span class="numeral">0x5A</span> <span class="keyword1">XOR</span> <span class="numeral">0x36</span>
      <span class="main">,</span> <span class="keyword1">NOT</span> <span class="numeral">0x5A</span>
      <span class="main">,</span> <span class="numeral">5</span> <span class="main">+</span> <span class="numeral">6</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="main">+</span> <span class="numeral">6</span><span class="main">,</span> <span class="main">-</span><span class="numeral">6</span> <span class="main">+</span> <span class="numeral">5</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="main">+</span> <span class="main">-</span><span class="numeral">6</span><span class="main">,</span> <span class="bound">HS</span> <span class="main">+</span> <span class="main">(</span><span class="bound">HS</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="main">+</span> <span class="main">1</span>
      <span class="main">,</span> <span class="numeral">5</span> <span class="main">-</span> <span class="numeral">3</span><span class="main">,</span> <span class="numeral">3</span> <span class="main">-</span> <span class="numeral">5</span>
      <span class="main">,</span> <span class="numeral">5</span> <span class="main">*</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="main">*</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="main">*</span> <span class="main">-</span><span class="numeral">4</span><span class="main">,</span> <span class="numeral">0x12345678</span> <span class="main">*</span> <span class="numeral">0x87654321</span><span class="main">]</span>
    <span class="main">@</span> <span class="main">(</span><span class="keyword1">if</span> dflt_size <span class="main">&gt;</span> <span class="numeral">4</span> <span class="keyword1">then</span>
      <span class="main">[</span> <span class="numeral">5</span> <span class="keyword1">div</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="keyword1">div</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="keyword1">div</span> <span class="main">-</span><span class="numeral">3</span><span class="main">,</span> <span class="numeral">5</span> <span class="keyword1">div</span> <span class="main">-</span><span class="numeral">3</span>
      <span class="main">,</span> <span class="numeral">5</span> <span class="keyword1">mod</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="keyword1">mod</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="keyword1">mod</span> <span class="main">-</span><span class="numeral">3</span><span class="main">,</span> <span class="numeral">5</span> <span class="keyword1">mod</span> <span class="main">-</span><span class="numeral">3</span>
      <span class="main">,</span> set_bit <span class="numeral">5</span> <span class="numeral">4</span> True<span class="main">,</span> set_bit <span class="main">(</span><span class="main">-</span> <span class="numeral">5</span><span class="main">)</span> <span class="numeral">2</span> True<span class="main">,</span> set_bit <span class="numeral">5</span> <span class="main">0</span> False<span class="main">,</span> set_bit <span class="main">(</span><span class="main">-</span> <span class="numeral">5</span><span class="main">)</span> <span class="main">1</span> False
      <span class="main">,</span> set_bit <span class="numeral">5</span> dflt_size True<span class="main">,</span> set_bit <span class="numeral">5</span> dflt_size False<span class="main">,</span> set_bit <span class="main">(</span><span class="main">-</span> <span class="numeral">5</span><span class="main">)</span> dflt_size True<span class="main">,</span> set_bit <span class="main">(</span><span class="main">-</span> <span class="numeral">5</span><span class="main">)</span> dflt_size False
      <span class="main">,</span> <span class="main">1</span> <span class="main">&lt;&lt;</span> <span class="numeral">2</span><span class="main">,</span> <span class="main">-</span><span class="main">1</span> <span class="main">&lt;&lt;</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">1</span> <span class="main">&lt;&lt;</span> dflt_size<span class="main">,</span> <span class="main">1</span> <span class="main">&lt;&lt;</span> <span class="main">0</span>
      <span class="main">,</span> <span class="numeral">31</span> <span class="main">&gt;&gt;</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">-</span><span class="main">1</span> <span class="main">&gt;&gt;</span> <span class="numeral">3</span><span class="main">,</span> <span class="numeral">31</span> <span class="main">&gt;&gt;</span> dflt_size<span class="main">,</span> <span class="main">-</span><span class="main">1</span> <span class="main">&gt;&gt;</span> dflt_size
      <span class="main">,</span> <span class="numeral">15</span> <span class="main">&gt;&gt;&gt;</span> <span class="numeral">2</span><span class="main">,</span> <span class="main">-</span><span class="main">1</span> <span class="main">&gt;&gt;&gt;</span> <span class="numeral">3</span><span class="main">,</span> <span class="numeral">15</span> <span class="main">&gt;&gt;&gt;</span> dflt_size<span class="main">,</span> <span class="main">-</span><span class="main">1</span> <span class="main">&gt;&gt;&gt;</span> dflt_size<span class="main">]</span>
    <span class="keyword1">else</span> <span class="main">[]</span><span class="main">)</span> <span class="main">::</span> uint list<span class="main">)</span><span class="main">)</span><span class="main">;</span>
  
  <span class="bound">test_list2</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> 
      <span class="bound">S</span> <span class="main">=</span> wivs_shift 
    <span class="keyword1">in</span> 
      <span class="main">(</span><span class="main">[</span> <span class="main">1</span><span class="main">,</span> <span class="main">-</span><span class="main">1</span><span class="main">,</span> <span class="main">-</span><span class="bound">S</span> <span class="main">+</span> <span class="numeral">5</span><span class="main">,</span> <span class="bound">S</span> <span class="main">-</span> <span class="main">1</span><span class="main">,</span> <span class="numeral">0x12</span>
      <span class="main">,</span> <span class="numeral">0x5A</span> <span class="keyword1">AND</span> <span class="numeral">0x36</span>
      <span class="main">,</span> <span class="numeral">0x5A</span> <span class="keyword1">OR</span> <span class="numeral">0x36</span>
      <span class="main">,</span> <span class="numeral">0x5A</span> <span class="keyword1">XOR</span> <span class="numeral">0x36</span>
      <span class="main">,</span> <span class="keyword1">NOT</span> <span class="numeral">0x5A</span>
      <span class="main">,</span> <span class="numeral">5</span> <span class="main">+</span> <span class="numeral">6</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="main">+</span> <span class="numeral">6</span><span class="main">,</span> <span class="main">-</span><span class="numeral">6</span> <span class="main">+</span> <span class="numeral">5</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="main">+</span> <span class="main">-</span><span class="numeral">6</span><span class="main">,</span> <span class="main">0</span>
      <span class="main">,</span> <span class="numeral">5</span> <span class="main">-</span> <span class="numeral">3</span><span class="main">,</span> <span class="numeral">3</span> <span class="main">-</span> <span class="numeral">5</span>
      <span class="main">,</span> <span class="numeral">5</span> <span class="main">*</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="main">*</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="main">*</span> <span class="main">-</span><span class="numeral">4</span><span class="main">,</span> <span class="numeral">0x12345678</span> <span class="main">*</span> <span class="numeral">0x87654321</span><span class="main">]</span>
    <span class="main">@</span> <span class="main">(</span><span class="keyword1">if</span> dflt_size <span class="main">&gt;</span> <span class="numeral">4</span> <span class="keyword1">then</span>
      <span class="main">[</span> <span class="numeral">5</span> <span class="keyword1">div</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">(</span><span class="bound">S</span> <span class="main">-</span> <span class="numeral">5</span><span class="main">)</span> <span class="keyword1">div</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">(</span><span class="bound">S</span> <span class="main">-</span> <span class="numeral">5</span><span class="main">)</span> <span class="keyword1">div</span> <span class="main">(</span><span class="bound">S</span> <span class="main">-</span> <span class="numeral">3</span><span class="main">)</span><span class="main">,</span> <span class="numeral">5</span> <span class="keyword1">div</span> <span class="main">(</span><span class="bound">S</span> <span class="main">-</span> <span class="numeral">3</span><span class="main">)</span>
      <span class="main">,</span> <span class="numeral">5</span> <span class="keyword1">mod</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">(</span><span class="bound">S</span> <span class="main">-</span> <span class="numeral">5</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">(</span><span class="bound">S</span> <span class="main">-</span> <span class="numeral">5</span><span class="main">)</span> <span class="keyword1">mod</span> <span class="main">(</span><span class="bound">S</span> <span class="main">-</span> <span class="numeral">3</span><span class="main">)</span><span class="main">,</span> <span class="numeral">5</span> <span class="keyword1">mod</span> <span class="main">(</span><span class="bound">S</span> <span class="main">-</span> <span class="numeral">3</span><span class="main">)</span>
      <span class="main">,</span> set_bit <span class="numeral">5</span> <span class="numeral">4</span> True<span class="main">,</span> <span class="main">-</span><span class="main">1</span><span class="main">,</span> set_bit <span class="numeral">5</span> <span class="main">0</span> False<span class="main">,</span> <span class="main">-</span><span class="numeral">7</span>
      <span class="main">,</span> <span class="numeral">5</span><span class="main">,</span> <span class="numeral">5</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span>
      <span class="main">,</span> <span class="numeral">4</span><span class="main">,</span> <span class="main">-</span><span class="numeral">8</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="main">1</span>
      <span class="main">,</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">(</span><span class="bound">S</span> <span class="main">&gt;&gt;</span> <span class="numeral">3</span><span class="main">)</span> <span class="main">-</span> <span class="main">1</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="main">0</span>
      <span class="main">,</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">(</span><span class="bound">S</span> <span class="main">&gt;&gt;</span> <span class="main">1</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="bound">S</span> <span class="main">&gt;&gt;</span> <span class="main">1</span><span class="main">)</span> <span class="main">-</span> <span class="main">1</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="main">-</span><span class="main">1</span><span class="main">]</span> 
    <span class="keyword1">else</span> <span class="main">[]</span><span class="main">)</span> <span class="main">::</span> int list<span class="main">)</span><span class="main">)</span><span class="main">;</span>

  <span class="bound">test_list_c1</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span>
      <span class="bound">HS</span> <span class="main">=</span> uint_of_int <span class="main">(</span><span class="main">(</span><span class="numeral">2</span><span class="main">^</span><span class="main">(</span>dflt_size <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1">in</span>
  <span class="main">[</span>  <span class="main">(</span><span class="numeral">0x5</span> <span class="main">::</span> uint<span class="main">)</span> <span class="main">=</span> <span class="numeral">0x5</span><span class="main">,</span> <span class="main">(</span><span class="numeral">0x5</span> <span class="main">::</span> uint<span class="main">)</span> <span class="main">=</span> <span class="numeral">0x6</span>
   <span class="main">,</span> <span class="main">(</span><span class="numeral">0x5</span> <span class="main">::</span> uint<span class="main">)</span> <span class="main">&lt;</span> <span class="numeral">0x5</span><span class="main">,</span> <span class="main">(</span><span class="numeral">0x5</span> <span class="main">::</span> uint<span class="main">)</span> <span class="main">&lt;</span> <span class="numeral">0x6</span><span class="main">,</span> <span class="main">(</span><span class="main">-</span><span class="numeral">5</span> <span class="main">::</span> uint<span class="main">)</span> <span class="main">&lt;</span> <span class="numeral">6</span><span class="main">,</span> <span class="main">(</span><span class="numeral">6</span> <span class="main">::</span> uint<span class="main">)</span> <span class="main">&lt;</span> <span class="main">-</span><span class="numeral">5</span>
   <span class="main">,</span> <span class="main">(</span><span class="numeral">0x5</span> <span class="main">::</span> uint<span class="main">)</span> <span class="main">≤</span> <span class="numeral">0x5</span><span class="main">,</span> <span class="main">(</span><span class="numeral">0x5</span> <span class="main">::</span> uint<span class="main">)</span> <span class="main">≤</span> <span class="numeral">0x4</span><span class="main">,</span> <span class="main">(</span><span class="main">-</span><span class="numeral">5</span> <span class="main">::</span> uint<span class="main">)</span> <span class="main">≤</span> <span class="numeral">6</span><span class="main">,</span> <span class="main">(</span><span class="numeral">6</span> <span class="main">::</span> uint<span class="main">)</span> <span class="main">≤</span> <span class="main">-</span><span class="numeral">5</span> 
   <span class="main">,</span> <span class="main">(</span><span class="bound">HS</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="main">&lt;</span> <span class="bound">HS</span><span class="main">,</span> <span class="main">(</span><span class="bound">HS</span> <span class="main">+</span> <span class="bound">HS</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="main">&lt;</span> <span class="main">0</span><span class="main">,</span> <span class="bound">HS</span> <span class="main">&lt;</span> <span class="bound">HS</span> <span class="main">-</span> <span class="main">1</span>
   <span class="main">,</span> <span class="main">(</span><span class="bound">HS</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="main">!!</span> <span class="main">0</span><span class="main">,</span> <span class="main">(</span><span class="bound">HS</span> <span class="main">-</span> <span class="main">1</span> <span class="main">::</span> uint<span class="main">)</span> <span class="main">!!</span> <span class="main">(</span>dflt_size <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="bound">HS</span> <span class="main">::</span> uint<span class="main">)</span> <span class="main">!!</span> <span class="main">(</span>dflt_size <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="bound">HS</span> <span class="main">::</span> uint<span class="main">)</span> <span class="main">!!</span> dflt_size
   <span class="main">]</span><span class="main">)</span><span class="main">;</span>

  <span class="bound">test_list_c2</span> <span class="main">=</span>
   <span class="main">[</span> True<span class="main">,</span> False
   <span class="main">,</span> False<span class="main">,</span> dflt_size<span class="main">≥</span><span class="numeral">2</span><span class="main">,</span> dflt_size<span class="main">=</span><span class="numeral">3</span><span class="main">,</span> dflt_size<span class="main">≠</span><span class="numeral">3</span>
   <span class="main">,</span> True<span class="main">,</span> False<span class="main">,</span> dflt_size<span class="main">=</span><span class="numeral">3</span><span class="main">,</span> dflt_size<span class="main">≠</span><span class="numeral">3</span>
   <span class="main">,</span> True<span class="main">,</span> False<span class="main">,</span> False
   <span class="main">,</span> dflt_size<span class="main">≠</span><span class="main">1</span><span class="main">,</span> False<span class="main">,</span> True<span class="main">,</span> False
   <span class="main">]</span>
<span class="keyword1">in</span>
  <span class="bound">test_list1</span> <span class="main">=</span> map uint_of_int <span class="bound">test_list2</span>
<span class="main">∧</span> <span class="bound">test_list_c1</span> <span class="main">=</span> <span class="bound">test_list_c2</span>"</span></span>

<span class="keyword1"><span class="command">no_notation</span></span> sshiftr_uint <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">&gt;&gt;&gt;</span>"</span> 55<span class="main">)</span>

<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">test_uint</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML Haskell<span class="main">?</span> OCaml<span class="main">?</span> Scala

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"test_uint"</span></span>
<span class="keyword1"><span class="command">quickcheck</span></span><span class="main">[</span>exhaustive<span class="main">,</span> expect<span class="main">=</span>no_counterexample<span class="main">]</span>
<span class="keyword1"><span class="command">oops</span></span> <span class="comment1">― ‹FIXME: prove correctness of test by reflective means (not yet supported)›</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="keyword1">AND</span> <span class="free">y</span> <span class="main">=</span> <span class="free">x</span> <span class="keyword1">OR</span> <span class="main">(</span><span class="free">y</span> <span class="main">::</span> uint<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">quickcheck</span></span><span class="main">[</span>random<span class="main">,</span> expect<span class="main">=</span>counterexample<span class="main">]</span>
<span class="keyword1"><span class="command">quickcheck</span></span><span class="main">[</span>exhaustive<span class="main">,</span> expect<span class="main">=</span>counterexample<span class="main">]</span>
<span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">::</span> uint<span class="main">)</span> <span class="keyword1">AND</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span> <span class="keyword1">OR</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">quickcheck</span></span><span class="main">[</span>narrowing<span class="main">,</span> expect<span class="main">=</span>no_counterexample<span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span> <span class="main">::</span> uint <span class="main">⇒</span> unit<span class="main">)</span> <span class="main">=</span> <span class="free">g</span>"</span></span>
<span class="keyword1"><span class="command">quickcheck</span></span><span class="main">[</span>narrowing<span class="main">,</span> size<span class="main">=</span>3<span class="main">,</span> expect<span class="main">=</span>no_counterexample<span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹ Tests for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">uint64</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> ›</span></span>

<span class="keyword1"><span class="command">notation</span></span> sshiftr_uint64 <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">&gt;&gt;&gt;</span>"</span> 55<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">test_uint64</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">test_uint64</span> <span class="main">⟷</span>
  <span class="main">(</span><span class="main">(</span><span class="main">[</span> <span class="numeral">0x10000000000000001</span><span class="main">,</span> <span class="main">-</span><span class="main">1</span><span class="main">,</span> <span class="main">-</span><span class="numeral">9223372036854775808</span><span class="main">,</span> <span class="numeral">0xFFFFFFFFFFFFFFFF</span><span class="main">,</span> <span class="numeral">0x1234567890ABCDEF</span>
    <span class="main">,</span> <span class="numeral">0x5A</span> <span class="keyword1">AND</span> <span class="numeral">0x36</span>
    <span class="main">,</span> <span class="numeral">0x5A</span> <span class="keyword1">OR</span> <span class="numeral">0x36</span>
    <span class="main">,</span> <span class="numeral">0x5A</span> <span class="keyword1">XOR</span> <span class="numeral">0x36</span>
    <span class="main">,</span> <span class="keyword1">NOT</span> <span class="numeral">0x5A</span>
    <span class="main">,</span> <span class="numeral">5</span> <span class="main">+</span> <span class="numeral">6</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="main">+</span> <span class="numeral">6</span><span class="main">,</span> <span class="main">-</span><span class="numeral">6</span> <span class="main">+</span> <span class="numeral">5</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="main">+</span> <span class="main">(</span><span class="main">-</span> <span class="numeral">6</span><span class="main">)</span><span class="main">,</span> <span class="numeral">0xFFFFFFFFFFFFFFFFFF</span> <span class="main">+</span> <span class="main">1</span>
    <span class="main">,</span> <span class="numeral">5</span> <span class="main">-</span> <span class="numeral">3</span><span class="main">,</span> <span class="numeral">3</span> <span class="main">-</span> <span class="numeral">5</span>
    <span class="main">,</span> <span class="numeral">5</span> <span class="main">*</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="main">*</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="main">*</span> <span class="main">-</span><span class="numeral">4</span><span class="main">,</span> <span class="numeral">0x1234567890ABCDEF</span> <span class="main">*</span> <span class="numeral">0xFEDCBA0987654321</span>
    <span class="main">,</span> <span class="numeral">5</span> <span class="keyword1">div</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="keyword1">div</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="keyword1">div</span> <span class="main">-</span><span class="numeral">3</span><span class="main">,</span> <span class="numeral">5</span> <span class="keyword1">div</span> <span class="main">-</span><span class="numeral">3</span>
    <span class="main">,</span> <span class="numeral">5</span> <span class="keyword1">mod</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="keyword1">mod</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="keyword1">mod</span> <span class="main">-</span><span class="numeral">3</span><span class="main">,</span> <span class="numeral">5</span> <span class="keyword1">mod</span> <span class="main">-</span><span class="numeral">3</span>
    <span class="main">,</span> set_bit <span class="numeral">5</span> <span class="numeral">4</span> True<span class="main">,</span> set_bit <span class="main">(</span><span class="main">-</span> <span class="numeral">5</span><span class="main">)</span> <span class="numeral">2</span> True<span class="main">,</span> set_bit <span class="numeral">5</span> <span class="main">0</span> False<span class="main">,</span> set_bit <span class="main">(</span><span class="main">-</span> <span class="numeral">5</span><span class="main">)</span> <span class="main">1</span> False
    <span class="main">,</span> set_bit <span class="numeral">5</span> <span class="numeral">64</span> True<span class="main">,</span> set_bit <span class="numeral">5</span> <span class="numeral">64</span> False<span class="main">,</span> set_bit <span class="main">(</span><span class="main">-</span> <span class="numeral">5</span><span class="main">)</span> <span class="numeral">64</span> True<span class="main">,</span> set_bit <span class="main">(</span><span class="main">-</span> <span class="numeral">5</span><span class="main">)</span> <span class="numeral">64</span> False
    <span class="main">,</span> <span class="main">1</span> <span class="main">&lt;&lt;</span> <span class="numeral">2</span><span class="main">,</span> <span class="main">-</span><span class="main">1</span> <span class="main">&lt;&lt;</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">1</span> <span class="main">&lt;&lt;</span> <span class="numeral">64</span><span class="main">,</span> <span class="main">1</span> <span class="main">&lt;&lt;</span> <span class="main">0</span>
    <span class="main">,</span> <span class="numeral">100</span> <span class="main">&gt;&gt;</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">-</span><span class="numeral">100</span> <span class="main">&gt;&gt;</span> <span class="numeral">3</span><span class="main">,</span> <span class="numeral">100</span> <span class="main">&gt;&gt;</span> <span class="numeral">64</span><span class="main">,</span> <span class="main">-</span><span class="numeral">100</span> <span class="main">&gt;&gt;</span> <span class="numeral">64</span>
    <span class="main">,</span> <span class="numeral">100</span> <span class="main">&gt;&gt;&gt;</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">-</span><span class="numeral">100</span> <span class="main">&gt;&gt;&gt;</span> <span class="numeral">3</span><span class="main">,</span> <span class="numeral">100</span> <span class="main">&gt;&gt;&gt;</span> <span class="numeral">64</span><span class="main">,</span> <span class="main">-</span><span class="numeral">100</span> <span class="main">&gt;&gt;&gt;</span> <span class="numeral">64</span><span class="main">]</span> <span class="main">::</span> uint64 list<span class="main">)</span>
   <span class="main">=</span>
    <span class="main">[</span> <span class="main">1</span><span class="main">,</span> <span class="numeral">18446744073709551615</span><span class="main">,</span> <span class="numeral">9223372036854775808</span><span class="main">,</span> <span class="numeral">18446744073709551615</span><span class="main">,</span> <span class="numeral">1311768467294899695</span>
    <span class="main">,</span> <span class="numeral">18</span>
    <span class="main">,</span> <span class="numeral">126</span>
    <span class="main">,</span> <span class="numeral">108</span>
    <span class="main">,</span> <span class="numeral">18446744073709551525</span>
    <span class="main">,</span> <span class="numeral">11</span><span class="main">,</span> <span class="main">1</span><span class="main">,</span> <span class="numeral">18446744073709551615</span><span class="main">,</span> <span class="numeral">18446744073709551605</span><span class="main">,</span> <span class="main">0</span>
    <span class="main">,</span> <span class="numeral">2</span><span class="main">,</span> <span class="numeral">18446744073709551614</span>
    <span class="main">,</span> <span class="numeral">15</span><span class="main">,</span> <span class="numeral">18446744073709551601</span><span class="main">,</span> <span class="numeral">20</span><span class="main">,</span> <span class="numeral">14000077364136384719</span>
    <span class="main">,</span> <span class="main">1</span><span class="main">,</span> <span class="numeral">6148914691236517203</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="main">0</span>
    <span class="main">,</span> <span class="numeral">2</span><span class="main">,</span> <span class="numeral">2</span><span class="main">,</span> <span class="numeral">18446744073709551611</span><span class="main">,</span> <span class="numeral">5</span> 
    <span class="main">,</span> <span class="numeral">21</span><span class="main">,</span> <span class="numeral">18446744073709551615</span><span class="main">,</span> <span class="numeral">4</span><span class="main">,</span> <span class="numeral">18446744073709551609</span>
    <span class="main">,</span> <span class="numeral">5</span><span class="main">,</span> <span class="numeral">5</span><span class="main">,</span> <span class="numeral">18446744073709551611</span><span class="main">,</span> <span class="numeral">18446744073709551611</span>
    <span class="main">,</span> <span class="numeral">4</span><span class="main">,</span> <span class="numeral">18446744073709551608</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="main">1</span>
    <span class="main">,</span> <span class="numeral">12</span><span class="main">,</span> <span class="numeral">2305843009213693939</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="main">0</span>
    <span class="main">,</span> <span class="numeral">12</span><span class="main">,</span> <span class="numeral">18446744073709551603</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="numeral">18446744073709551615</span><span class="main">]</span><span class="main">)</span> <span class="main">∧</span>
  <span class="main">(</span><span class="main">[</span> <span class="main">(</span><span class="numeral">0x5</span> <span class="main">::</span> uint64<span class="main">)</span> <span class="main">=</span> <span class="numeral">0x5</span><span class="main">,</span> <span class="main">(</span><span class="numeral">0x5</span> <span class="main">::</span> uint64<span class="main">)</span> <span class="main">=</span> <span class="numeral">0x6</span>
   <span class="main">,</span> <span class="main">(</span><span class="numeral">0x5</span> <span class="main">::</span> uint64<span class="main">)</span> <span class="main">&lt;</span> <span class="numeral">0x5</span><span class="main">,</span> <span class="main">(</span><span class="numeral">0x5</span> <span class="main">::</span> uint64<span class="main">)</span> <span class="main">&lt;</span> <span class="numeral">0x6</span><span class="main">,</span> <span class="main">(</span><span class="main">-</span><span class="numeral">5</span> <span class="main">::</span> uint64<span class="main">)</span> <span class="main">&lt;</span> <span class="numeral">6</span><span class="main">,</span> <span class="main">(</span><span class="numeral">6</span> <span class="main">::</span> uint64<span class="main">)</span> <span class="main">&lt;</span> <span class="main">-</span><span class="numeral">5</span>
   <span class="main">,</span> <span class="main">(</span><span class="numeral">0x5</span> <span class="main">::</span> uint64<span class="main">)</span> <span class="main">≤</span> <span class="numeral">0x5</span><span class="main">,</span> <span class="main">(</span><span class="numeral">0x5</span> <span class="main">::</span> uint64<span class="main">)</span> <span class="main">≤</span> <span class="numeral">0x4</span><span class="main">,</span> <span class="main">(</span><span class="main">-</span><span class="numeral">5</span> <span class="main">::</span> uint64<span class="main">)</span> <span class="main">≤</span> <span class="numeral">6</span><span class="main">,</span> <span class="main">(</span><span class="numeral">6</span> <span class="main">::</span> uint64<span class="main">)</span> <span class="main">≤</span> <span class="main">-</span><span class="numeral">5</span> 
   <span class="main">,</span> <span class="main">(</span><span class="numeral">0x7FFFFFFFFFFFFFFF</span> <span class="main">::</span> uint64<span class="main">)</span> <span class="main">&lt;</span> <span class="numeral">0x8000000000000000</span><span class="main">,</span> <span class="main">(</span><span class="numeral">0xFFFFFFFFFFFFFFFF</span> <span class="main">::</span> uint64<span class="main">)</span> <span class="main">&lt;</span> <span class="main">0</span><span class="main">,</span> <span class="main">(</span><span class="numeral">0x8000000000000000</span> <span class="main">::</span> uint64<span class="main">)</span> <span class="main">&lt;</span> <span class="numeral">0x7FFFFFFFFFFFFFFF</span>
   <span class="main">,</span> <span class="main">(</span><span class="numeral">0x7FFFFFFFFFFFFFFF</span> <span class="main">::</span> uint64<span class="main">)</span> <span class="main">!!</span> <span class="main">0</span><span class="main">,</span> <span class="main">(</span><span class="numeral">0x7FFFFFFFFFFFFFFF</span> <span class="main">::</span> uint64<span class="main">)</span> <span class="main">!!</span> <span class="numeral">63</span><span class="main">,</span> <span class="main">(</span><span class="numeral">0x8000000000000000</span> <span class="main">::</span> uint64<span class="main">)</span> <span class="main">!!</span> <span class="numeral">63</span><span class="main">,</span> <span class="main">(</span><span class="numeral">0x8000000000000000</span> <span class="main">::</span> uint64<span class="main">)</span> <span class="main">!!</span> <span class="numeral">64</span>
   <span class="main">]</span>
  <span class="main">=</span>
   <span class="main">[</span> True<span class="main">,</span> False
   <span class="main">,</span> False<span class="main">,</span> True<span class="main">,</span> False<span class="main">,</span> True
   <span class="main">,</span> True<span class="main">,</span> False<span class="main">,</span> False<span class="main">,</span> True
   <span class="main">,</span> True<span class="main">,</span> False<span class="main">,</span> False
   <span class="main">,</span> True<span class="main">,</span> False<span class="main">,</span> True<span class="main">,</span> False
   <span class="main">]</span><span class="main">)</span> <span class="main">∧</span>
  <span class="main">(</span><span class="main">[</span>integer_of_uint64 <span class="main">0</span><span class="main">,</span> integer_of_uint64 <span class="numeral">0x7FFFFFFFFFFFFFFF</span><span class="main">,</span> integer_of_uint64 <span class="numeral">0x8000000000000000</span><span class="main">,</span> integer_of_uint64 <span class="numeral">0xAAAAAAAAAAAAAAAA</span><span class="main">]</span>
  <span class="main">=</span>
   <span class="main">[</span><span class="main">0</span><span class="main">,</span> <span class="numeral">0x7FFFFFFFFFFFFFFF</span><span class="main">,</span> <span class="numeral">0x8000000000000000</span><span class="main">,</span> <span class="numeral">0xAAAAAAAAAAAAAAAA</span><span class="main">]</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">value</span></span> <span class="main">[</span>nbe<span class="main">]</span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="numeral">0x10000000000000001</span><span class="main">,</span> <span class="main">-</span><span class="main">1</span><span class="main">,</span> <span class="main">-</span><span class="numeral">9223372036854775808</span><span class="main">,</span> <span class="numeral">0xFFFFFFFFFFFFFFFF</span><span class="main">,</span> <span class="numeral">0x1234567890ABCDEF</span>
    <span class="main">,</span> <span class="numeral">0x5A</span> <span class="keyword1">AND</span> <span class="numeral">0x36</span>
    <span class="main">,</span> <span class="numeral">0x5A</span> <span class="keyword1">OR</span> <span class="numeral">0x36</span>
    <span class="main">,</span> <span class="numeral">0x5A</span> <span class="keyword1">XOR</span> <span class="numeral">0x36</span>
    <span class="main">,</span> <span class="keyword1">NOT</span> <span class="numeral">0x5A</span>
    <span class="main">,</span> <span class="numeral">5</span> <span class="main">+</span> <span class="numeral">6</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="main">+</span> <span class="numeral">6</span><span class="main">,</span> <span class="main">-</span><span class="numeral">6</span> <span class="main">+</span> <span class="numeral">5</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="main">+</span> <span class="main">(</span><span class="main">-</span> <span class="numeral">6</span><span class="main">)</span><span class="main">,</span> <span class="numeral">0xFFFFFFFFFFFFFFFFFF</span> <span class="main">+</span> <span class="main">1</span>
    <span class="main">,</span> <span class="numeral">5</span> <span class="main">-</span> <span class="numeral">3</span><span class="main">,</span> <span class="numeral">3</span> <span class="main">-</span> <span class="numeral">5</span>
    <span class="main">,</span> <span class="numeral">5</span> <span class="main">*</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="main">*</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="main">*</span> <span class="main">-</span><span class="numeral">4</span><span class="main">,</span> <span class="numeral">0x1234567890ABCDEF</span> <span class="main">*</span> <span class="numeral">0xFEDCBA0987654321</span>
    <span class="main">,</span> <span class="numeral">5</span> <span class="keyword1">div</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="keyword1">div</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="keyword1">div</span> <span class="main">-</span><span class="numeral">3</span><span class="main">,</span> <span class="numeral">5</span> <span class="keyword1">div</span> <span class="main">-</span><span class="numeral">3</span>
    <span class="main">,</span> <span class="numeral">5</span> <span class="keyword1">mod</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="keyword1">mod</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">-</span><span class="numeral">5</span> <span class="keyword1">mod</span> <span class="main">-</span><span class="numeral">3</span><span class="main">,</span> <span class="numeral">5</span> <span class="keyword1">mod</span> <span class="main">-</span><span class="numeral">3</span>
    <span class="main">,</span> set_bit <span class="numeral">5</span> <span class="numeral">4</span> True<span class="main">,</span> set_bit <span class="main">(</span><span class="main">-</span> <span class="numeral">5</span><span class="main">)</span> <span class="numeral">2</span> True<span class="main">,</span> set_bit <span class="numeral">5</span> <span class="main">0</span> False<span class="main">,</span> set_bit <span class="main">(</span><span class="main">-</span> <span class="numeral">5</span><span class="main">)</span> <span class="main">1</span> False
    <span class="main">,</span> set_bit <span class="numeral">5</span> <span class="numeral">64</span> True<span class="main">,</span> set_bit <span class="numeral">5</span> <span class="numeral">64</span> False<span class="main">,</span> set_bit <span class="main">(</span><span class="main">-</span> <span class="numeral">5</span><span class="main">)</span> <span class="numeral">64</span> True<span class="main">,</span> set_bit <span class="main">(</span><span class="main">-</span> <span class="numeral">5</span><span class="main">)</span> <span class="numeral">64</span> False
    <span class="main">,</span> <span class="main">1</span> <span class="main">&lt;&lt;</span> <span class="numeral">2</span><span class="main">,</span> <span class="main">-</span><span class="main">1</span> <span class="main">&lt;&lt;</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">1</span> <span class="main">&lt;&lt;</span> <span class="numeral">64</span><span class="main">,</span> <span class="main">1</span> <span class="main">&lt;&lt;</span> <span class="main">0</span>
    <span class="main">,</span> <span class="numeral">100</span> <span class="main">&gt;&gt;</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">-</span><span class="numeral">100</span> <span class="main">&gt;&gt;</span> <span class="numeral">3</span><span class="main">,</span> <span class="numeral">100</span> <span class="main">&gt;&gt;</span> <span class="numeral">64</span><span class="main">,</span> <span class="main">-</span><span class="numeral">100</span> <span class="main">&gt;&gt;</span> <span class="numeral">64</span>
    <span class="main">,</span> <span class="numeral">100</span> <span class="main">&gt;&gt;&gt;</span> <span class="numeral">3</span><span class="main">,</span> <span class="main">-</span><span class="numeral">100</span> <span class="main">&gt;&gt;&gt;</span> <span class="numeral">3</span><span class="main">,</span> <span class="numeral">100</span> <span class="main">&gt;&gt;&gt;</span> <span class="numeral">64</span><span class="main">,</span> <span class="main">-</span><span class="numeral">100</span> <span class="main">&gt;&gt;&gt;</span> <span class="numeral">64</span><span class="main">]</span> <span class="main">::</span> uint64 list"</span></span>

<span class="keyword1"><span class="command">no_notation</span></span> sshiftr_uint64 <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">&gt;&gt;&gt;</span>"</span> 55<span class="main">)</span>

<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">test_uint64</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML Haskell<span class="main">?</span> OCaml<span class="main">?</span> Scala

<span class="keyword1"><span class="command">notepad</span></span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">have</span></span> <span class="quoted">test_uint64</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">have</span></span> <span class="quoted">test_uint64</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">code_simp</span>
<span class="keyword1"><span class="command">have</span></span> <span class="quoted">test_uint64</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">normalization</span>
<span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword1"><span class="command">ML_val</span></span> <span class="quoted">‹<span class="keyword1"><span class="keyword">val</span></span> true <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">test_uint64</span><span class="antiquote">}</span></span></span>›</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">test_uint64'</span> <span class="main">::</span> <span class="quoted">uint64</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">test_uint64'</span> <span class="main">=</span> <span class="main">0</span> <span class="main">+</span> <span class="numeral">10</span> <span class="main">-</span> <span class="numeral">14</span> <span class="main">*</span> <span class="numeral">3</span> <span class="keyword1">div</span> <span class="numeral">6</span> <span class="keyword1">mod</span> <span class="numeral">3</span> <span class="main">&lt;&lt;</span> <span class="numeral">3</span> <span class="main">&gt;&gt;</span> <span class="numeral">2</span>"</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Tests for casts›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">test_casts</span> <span class="main">::</span> <span class="quoted">bool</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">test_casts</span> <span class="main">⟷</span>
  map uint8_of_uint32 <span class="main">[</span><span class="numeral">10</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="numeral">0xFE</span><span class="main">,</span> <span class="numeral">0xFFFFFFFF</span><span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="numeral">10</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="numeral">0xFE</span><span class="main">,</span> <span class="numeral">0xFF</span><span class="main">]</span> <span class="main">∧</span>
  map uint8_of_uint64 <span class="main">[</span><span class="numeral">10</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="numeral">0xFE</span><span class="main">,</span> <span class="numeral">0xFFFFFFFFFFFFFFFF</span><span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="numeral">10</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="numeral">0xFE</span><span class="main">,</span> <span class="numeral">0xFF</span><span class="main">]</span> <span class="main">∧</span>
  map uint32_of_uint8 <span class="main">[</span><span class="numeral">10</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="numeral">0xFF</span><span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="numeral">10</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="numeral">0xFF</span><span class="main">]</span> <span class="main">∧</span>
  map uint64_of_uint8 <span class="main">[</span><span class="numeral">10</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="numeral">0xFF</span><span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="numeral">10</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="numeral">0xFF</span><span class="main">]</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">test_casts'</span> <span class="main">::</span> <span class="quoted">bool</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">test_casts'</span> <span class="main">⟷</span>
  map uint8_of_uint16 <span class="main">[</span><span class="numeral">10</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="numeral">0xFE</span><span class="main">,</span> <span class="numeral">0xFFFF</span><span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="numeral">10</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="numeral">0xFE</span><span class="main">,</span> <span class="numeral">0xFF</span><span class="main">]</span> <span class="main">∧</span>
  map uint16_of_uint8 <span class="main">[</span><span class="numeral">10</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="numeral">0xFF</span><span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="numeral">10</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="numeral">0xFF</span><span class="main">]</span> <span class="main">∧</span>
  map uint16_of_uint32 <span class="main">[</span><span class="numeral">10</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="numeral">0xFFFE</span><span class="main">,</span> <span class="numeral">0xFFFFFFFF</span><span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="numeral">10</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="numeral">0xFFFE</span><span class="main">,</span> <span class="numeral">0xFFFF</span><span class="main">]</span> <span class="main">∧</span>
  map uint16_of_uint64 <span class="main">[</span><span class="numeral">10</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="numeral">0xFFFE</span><span class="main">,</span> <span class="numeral">0xFFFFFFFFFFFFFFFF</span><span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="numeral">10</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="numeral">0xFFFE</span><span class="main">,</span> <span class="numeral">0xFFFF</span><span class="main">]</span> <span class="main">∧</span>
  map uint32_of_uint16 <span class="main">[</span><span class="numeral">10</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="numeral">0xFFFF</span><span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="numeral">10</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="numeral">0xFFFF</span><span class="main">]</span> <span class="main">∧</span>
  map uint64_of_uint16 <span class="main">[</span><span class="numeral">10</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="numeral">0xFFFF</span><span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="numeral">10</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="numeral">0xFFFF</span><span class="main">]</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">test_casts''</span> <span class="main">::</span> <span class="quoted">bool</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">test_casts''</span> <span class="main">⟷</span>
  map uint32_of_uint64 <span class="main">[</span><span class="numeral">10</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="numeral">0xFFFFFFFE</span><span class="main">,</span> <span class="numeral">0xFFFFFFFFFFFFFFFF</span><span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="numeral">10</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="numeral">0xFFFFFFFE</span><span class="main">,</span> <span class="numeral">0xFFFFFFFF</span><span class="main">]</span> <span class="main">∧</span>
  map uint64_of_uint32 <span class="main">[</span><span class="numeral">10</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="numeral">0xFFFFFFFF</span><span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="numeral">10</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="numeral">0xFFFFFFFF</span><span class="main">]</span>"</span></span>

<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">test_casts</span></span> <span class="quoted"><span class="quoted">test_casts''</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML Haskell<span class="main">?</span> Scala
<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">test_casts''</span></span> <span class="keyword2"><span class="keyword">checking</span></span> OCaml<span class="main">?</span>
<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">test_casts'</span></span> <span class="keyword2"><span class="keyword">checking</span></span> Haskell<span class="main">?</span> Scala

<span class="keyword1"><span class="command">notepad</span></span> <span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted">test_casts</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted">test_casts</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">normalization</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted">test_casts</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">code_simp</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted">test_casts'</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">normalization</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted">test_casts'</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">code_simp</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted">test_casts''</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted">test_casts''</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">normalization</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted">test_casts''</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">code_simp</span>
<span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹
  <span class="keyword1"><span class="keyword">val</span></span> true <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">test_casts</span><span class="antiquote">}</span></span></span>
  <span class="keyword1"><span class="keyword">val</span></span> true <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">test_casts''</span><span class="antiquote">}</span></span></span>
›</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">test_casts_uint</span> <span class="main">::</span> <span class="quoted">bool</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">test_casts_uint</span> <span class="main">⟷</span>
  map uint_of_uint32 <span class="main">(</span><span class="main">[</span><span class="main">0</span><span class="main">,</span> <span class="numeral">10</span><span class="main">]</span> <span class="main">@</span> <span class="main">(</span><span class="keyword1">if</span> dflt_size <span class="main">&lt;</span> <span class="numeral">32</span> <span class="keyword1">then</span> <span class="main">[</span><span class="main">1</span> <span class="main">&lt;&lt;</span> <span class="main">(</span>dflt_size <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">,</span> <span class="numeral">0xFFFFFFFF</span><span class="main">]</span> <span class="keyword1">else</span> <span class="main">[</span><span class="numeral">0xFFFFFFFF</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> 
  <span class="main">[</span><span class="main">0</span><span class="main">,</span> <span class="numeral">10</span><span class="main">]</span> <span class="main">@</span> <span class="main">(</span><span class="keyword1">if</span> dflt_size <span class="main">&lt;</span> <span class="numeral">32</span> <span class="keyword1">then</span> <span class="main">[</span><span class="main">1</span> <span class="main">&lt;&lt;</span> <span class="main">(</span>dflt_size <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">1</span> <span class="main">&lt;&lt;</span> dflt_size<span class="main">)</span> <span class="main">-</span> <span class="main">1</span><span class="main">]</span> <span class="keyword1">else</span> <span class="main">[</span><span class="numeral">0xFFFFFFFF</span><span class="main">]</span><span class="main">)</span> <span class="main">∧</span>
  map uint32_of_uint <span class="main">[</span><span class="main">0</span><span class="main">,</span> <span class="numeral">10</span><span class="main">,</span> <span class="keyword1">if</span> dflt_size <span class="main">&lt;</span> <span class="numeral">32</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="main">&lt;&lt;</span> <span class="main">(</span>dflt_size <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="keyword1">else</span> <span class="numeral">0xFFFFFFFF</span><span class="main">]</span> <span class="main">=</span>
  <span class="main">[</span><span class="main">0</span><span class="main">,</span> <span class="numeral">10</span><span class="main">,</span> <span class="keyword1">if</span> dflt_size <span class="main">&lt;</span> <span class="numeral">32</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="main">&lt;&lt;</span> <span class="main">(</span>dflt_size <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="keyword1">else</span> <span class="numeral">0xFFFFFFFF</span><span class="main">]</span> <span class="main">∧</span>
  map uint_of_uint64 <span class="main">[</span><span class="main">0</span><span class="main">,</span> <span class="numeral">10</span><span class="main">,</span> <span class="main">1</span> <span class="main">&lt;&lt;</span> <span class="main">(</span>dflt_size <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">,</span> <span class="numeral">0xFFFFFFFFFFFFFFFF</span><span class="main">]</span> <span class="main">=</span>
  <span class="main">[</span><span class="main">0</span><span class="main">,</span> <span class="numeral">10</span><span class="main">,</span> <span class="main">1</span> <span class="main">&lt;&lt;</span> <span class="main">(</span>dflt_size <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">1</span> <span class="main">&lt;&lt;</span> dflt_size<span class="main">)</span> <span class="main">-</span> <span class="main">1</span><span class="main">]</span> <span class="main">∧</span>
  map uint64_of_uint <span class="main">[</span><span class="main">0</span><span class="main">,</span> <span class="numeral">10</span><span class="main">,</span> <span class="main">1</span> <span class="main">&lt;&lt;</span> <span class="main">(</span>dflt_size <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">]</span> <span class="main">=</span>
  <span class="main">[</span><span class="main">0</span><span class="main">,</span> <span class="numeral">10</span><span class="main">,</span> <span class="main">1</span> <span class="main">&lt;&lt;</span> <span class="main">(</span>dflt_size <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">]</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">test_casts_uint'</span> <span class="main">::</span> <span class="quoted">bool</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">test_casts_uint'</span> <span class="main">⟷</span>
  map uint_of_uint16 <span class="main">[</span><span class="main">0</span><span class="main">,</span> <span class="numeral">10</span><span class="main">,</span> <span class="numeral">0xFFFF</span><span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="main">0</span><span class="main">,</span> <span class="numeral">10</span><span class="main">,</span> <span class="numeral">0xFFFF</span><span class="main">]</span> <span class="main">∧</span>
  map uint16_of_uint <span class="main">[</span><span class="main">0</span><span class="main">,</span> <span class="numeral">10</span><span class="main">,</span> <span class="numeral">0xFFFF</span><span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="main">0</span><span class="main">,</span> <span class="numeral">10</span><span class="main">,</span> <span class="numeral">0xFFFF</span><span class="main">]</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">test_casts_uint''</span> <span class="main">::</span> <span class="quoted">bool</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">test_casts_uint''</span> <span class="main">⟷</span>
  map uint_of_uint8 <span class="main">[</span><span class="main">0</span><span class="main">,</span> <span class="numeral">10</span><span class="main">,</span> <span class="numeral">0xFF</span><span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="main">0</span><span class="main">,</span> <span class="numeral">10</span><span class="main">,</span> <span class="numeral">0xFF</span><span class="main">]</span> <span class="main">∧</span>
  map uint8_of_uint <span class="main">[</span><span class="main">0</span><span class="main">,</span> <span class="numeral">10</span><span class="main">,</span> <span class="numeral">0xFF</span><span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="main">0</span><span class="main">,</span> <span class="numeral">10</span><span class="main">,</span> <span class="numeral">0xFF</span><span class="main">]</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Native_Word_Test_Emu">
<div class="head">
<h1>Theory Native_Word_Test_Emu</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Native_Word_Test_Emu.thy
    Author:     Andreas Lochbihler, ETH Zurich
*)</span>

<span class="keyword1"><span class="command">theory</span></span> Native_Word_Test_Emu <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Native_Word_Test.html">Native_Word_Test</a>
  <a href="Code_Target_Bits_Int.html">Code_Target_Bits_Int</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Test cases for emulation of native words›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Tests for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">uint16</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Test that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">uint16</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is emulated for PolyML and OCaml via <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="numeral"><span class="numeral">16</span></span> word"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> 
  if <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory</span></span> <a href="Code_Target_Bits_Int.html"></a><a href="Code_Target_Bits_Int.html">Native_Word.Code_Target_Bits_Int</a><span class="antiquote"><span class="antiquote">}</span></span></span></span> is imported.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">test_uint16_emulation</span> <span class="main">::</span> <span class="quoted">bool</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">test_uint16_emulation</span> <span class="main">⟷</span> <span class="main">(</span><span class="numeral">0xFFFFF</span> <span class="main">-</span> <span class="numeral">0x1000</span> <span class="main">=</span> <span class="main">(</span><span class="numeral">0xEFFF</span> <span class="main">::</span> uint16<span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">test_uint16_emulation</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML OCaml<span class="main">?</span>
  <span class="comment1">― ‹test the other target languages as well›</span> Haskell<span class="main">?</span> Scala

<span class="keyword1"><span class="command">notepad</span></span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">have</span></span> <span class="quoted">test_uint16</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">have</span></span> <span class="quoted">test_uint16_emulation</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">eval</span>
<span class="keyword1"><span class="command">have</span></span> <span class="quoted">test_uint16_emulation</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">normalization</span>
<span class="keyword1"><span class="command">have</span></span> <span class="quoted">test_uint16_emulation</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">code_simp</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">ML_val</span></span> <span class="quoted">‹
  <span class="keyword1"><span class="keyword">val</span></span> true <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">test_uint16</span><span class="antiquote">}</span></span></span><span class="main">;</span>
  <span class="keyword1"><span class="keyword">val</span></span> true <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">test_uint16_emulation</span><span class="antiquote">}</span></span></span><span class="main">;</span>
›</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="keyword1">AND</span> <span class="free">y</span> <span class="main">=</span> <span class="free">x</span> <span class="keyword1">OR</span> <span class="main">(</span><span class="free">y</span> <span class="main">::</span> uint16<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">quickcheck</span></span><span class="main">[</span>random<span class="main">,</span> expect<span class="main">=</span>counterexample<span class="main">]</span>
<span class="keyword1"><span class="command">quickcheck</span></span><span class="main">[</span>exhaustive<span class="main">,</span> expect<span class="main">=</span>counterexample<span class="main">]</span>
<span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Tests for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">uint8</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Test that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">uint8</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is emulated for OCaml via <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="numeral"><span class="numeral">8</span></span> word"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> 
  if <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory</span></span> <a href="Code_Target_Bits_Int.html"></a><a href="Code_Target_Bits_Int.html">Native_Word.Code_Target_Bits_Int</a><span class="antiquote"><span class="antiquote">}</span></span></span></span> is imported.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">test_uint8_emulation</span> <span class="main">::</span> <span class="quoted">bool</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">test_uint8_emulation</span> <span class="main">⟷</span> <span class="main">(</span><span class="numeral">0xFFF</span> <span class="main">-</span> <span class="numeral">0x10</span> <span class="main">=</span> <span class="main">(</span><span class="numeral">0xEF</span> <span class="main">::</span> uint8<span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">test_uint8_emulation</span></span> <span class="keyword2"><span class="keyword">checking</span></span> OCaml<span class="main">?</span>
  <span class="comment1">― ‹test the other target languages as well›</span> SML Haskell<span class="main">?</span> Scala

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Native_Word_Test_PolyML">
<div class="head">
<h1>Theory Native_Word_Test_PolyML</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Native_Word_Test_PolyML.thy
    Author:     Andreas Lochbihler, ETH Zurich
*)</span>

<span class="keyword1"><span class="command">theory</span></span> Native_Word_Test_PolyML <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Native_Word_Test.html">Native_Word_Test</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Test with PolyML›</span></span>

<span class="keyword1"><span class="command">test_code</span></span>
  <span class="quoted">test_uint64</span> <span class="quoted"><span class="quoted">"test_uint64' <span class="main">=</span> <span class="numeral">0x12</span>"</span></span>
  <span class="quoted">test_uint32</span> <span class="quoted"><span class="quoted">"test_uint32' <span class="main">=</span> <span class="numeral">0x12</span>"</span></span>
  <span class="quoted">test_uint8</span> <span class="quoted"><span class="quoted">"test_uint8' <span class="main">=</span> <span class="numeral">0x12</span>"</span></span>
  <span class="quoted">test_uint</span>
  <span class="quoted">test_casts</span> <span class="quoted">test_casts''</span>
  <span class="quoted">test_casts_uint</span> <span class="quoted">test_casts_uint''</span>
<span class="keyword2"><span class="keyword">in</span></span> PolyML

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Native_Word_Test_PolyML2">
<div class="head">
<h1>Theory Native_Word_Test_PolyML2</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Native_Word_Test_PolYML2.thy
    Author:     Andreas Lochbihler, ETH Zurich
*)</span>

<span class="keyword1"><span class="command">theory</span></span> Native_Word_Test_PolyML2 <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Native_Word_Test_Emu.html">Native_Word_Test_Emu</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">test_code</span></span>
  <span class="quoted">test_uint16</span> <span class="quoted">test_uint16_emulation</span>
  <span class="quoted">test_casts'</span>
  <span class="quoted">test_casts_uint'</span>
<span class="keyword2"><span class="keyword">in</span></span> PolyML

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Native_Word_Test_PolyML64">
<div class="head">
<h1>Theory Native_Word_Test_PolyML64</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Native_Word_Test_PolYML64.thy
    Author:     Andreas Lochbihler, ETH Zurich
*)</span>

<span class="keyword1"><span class="command">theory</span></span> Native_Word_Test_PolyML64 <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Native_Word_Test.html">Native_Word_Test</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">test_code</span></span> <span class="quoted"><span class="quoted">"test_uint64' <span class="main">=</span> <span class="numeral">0x12</span>"</span></span>
<span class="keyword2"><span class="keyword">in</span></span> PolyML

<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹
  <span class="keyword2"><span class="keyword">if</span></span> ML_System.platform_is_64 <span class="keyword2"><span class="keyword">then</span></span>
    ML <span class="antiquoted"><span class="entity"><span class="operator">‹</span><span class="hidden">\&lt;^</span><span class="control">assert</span><span class="hidden">&gt;</span> (<span class="hidden">\&lt;^</span><span class="control">code</span><span class="hidden">&gt;</span>‹test_uint64'› = 0wx12)›</span></span>
  <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="main">)</span>
›</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Native_Word_Test_Scala">
<div class="head">
<h1>Theory Native_Word_Test_Scala</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Native_Word_Test_Scala.thy
    Author:     Andreas Lochbihler, ETH Zurich
*)</span>

<span class="keyword1"><span class="command">theory</span></span> Native_Word_Test_Scala <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Native_Word_Test.html">Native_Word_Test</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Test with Scala›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  In Scala, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">uint</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">uint32</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> are both implemented as type \texttt{Int}.
  When they are used in the same generated program, we have to suppress the type class
  instances for one of them.
›</span></span>
<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">class_instance</span></span> uint32 <span class="main">::</span> equal <span class="main">⇀</span> <span class="main">(</span>Scala<span class="main">)</span> -
<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">class_instance</span></span> uint32 <span class="main">::</span> semiring_bit_syntax <span class="main">⇀</span> <span class="main">(</span>Scala<span class="main">)</span> -

<span class="keyword1"><span class="command">test_code</span></span>
  <span class="quoted">test_uint64</span> <span class="quoted"><span class="quoted">"test_uint64' <span class="main">=</span> <span class="numeral">0x12</span>"</span></span>
  <span class="quoted">test_uint32</span> <span class="quoted"><span class="quoted">"test_uint32' <span class="main">=</span> <span class="numeral">0x12</span>"</span></span>
  <span class="quoted">test_uint16</span>
  <span class="quoted">test_uint8</span> <span class="quoted"><span class="quoted">"test_uint8' <span class="main">=</span> <span class="numeral">0x12</span>"</span></span> 
  <span class="quoted">test_uint</span>
  <span class="quoted">test_casts</span> <span class="quoted">test_casts'</span> <span class="quoted">test_casts''</span>
  <span class="quoted">test_casts_uint</span> <span class="quoted">test_casts_uint'</span> <span class="quoted">test_casts_uint''</span>
<span class="keyword2"><span class="keyword">in</span></span> Scala

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Native_Word_Test_GHC">
<div class="head">
<h1>Theory Native_Word_Test_GHC</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Native_Word_Test_GHC.thy
    Author:     Andreas Lochbihler, ETH Zurich
*)</span>

<span class="keyword1"><span class="command">theory</span></span> Native_Word_Test_GHC <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Native_Word_Test.html">Native_Word_Test</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Test with GHC›</span></span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code_test_ghc</span> <span class="main"><span class="main">=</span></span> <span class="quoted">"-XTypeSynonymInstances"</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1"><span class="command">test_code</span></span>
  <span class="quoted">test_uint64</span> <span class="quoted"><span class="quoted">"test_uint64' <span class="main">=</span> <span class="numeral">0x12</span>"</span></span>
  <span class="quoted">test_uint32</span> <span class="quoted"><span class="quoted">"test_uint32' <span class="main">=</span> <span class="numeral">0x12</span>"</span></span>
  <span class="quoted">test_uint16</span>
  <span class="quoted">test_uint8</span> <span class="quoted"><span class="quoted">"test_uint8' <span class="main">=</span> <span class="numeral">0x12</span>"</span></span>
  <span class="quoted">test_uint</span>
  <span class="quoted">test_casts</span> <span class="quoted">test_casts'</span> <span class="quoted">test_casts''</span>
  <span class="quoted">test_casts_uint</span> <span class="quoted">test_casts_uint'</span> <span class="quoted">test_casts_uint''</span>
<span class="keyword2"><span class="keyword">in</span></span> GHC

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Test quickcheck narrowing›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">::</span> uint64<span class="main">)</span> <span class="keyword1">AND</span> <span class="free">y</span> <span class="main">=</span> <span class="free">x</span> <span class="keyword1">OR</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">quickcheck</span></span><span class="main">[</span>narrowing<span class="main">,</span> expect<span class="main">=</span>counterexample<span class="main">]</span>
<span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span> <span class="main">::</span> uint64 <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">=</span> <span class="free">g</span>"</span></span>
<span class="keyword1"><span class="command">quickcheck</span></span><span class="main">[</span>narrowing<span class="main">,</span> size<span class="main">=</span>3<span class="main">,</span> expect<span class="main">=</span>counterexample<span class="main">]</span>
<span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">::</span> uint32<span class="main">)</span> <span class="keyword1">AND</span> <span class="free">y</span> <span class="main">=</span> <span class="free">x</span> <span class="keyword1">OR</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">quickcheck</span></span><span class="main">[</span>narrowing<span class="main">,</span> expect<span class="main">=</span>counterexample<span class="main">]</span>
<span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span> <span class="main">::</span> uint32 <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">=</span> <span class="free">g</span>"</span></span>
<span class="keyword1"><span class="command">quickcheck</span></span><span class="main">[</span>narrowing<span class="main">,</span> size<span class="main">=</span>3<span class="main">,</span> expect<span class="main">=</span>counterexample<span class="main">]</span>
<span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">::</span> uint16<span class="main">)</span> <span class="keyword1">AND</span> <span class="free">y</span> <span class="main">=</span> <span class="free">x</span> <span class="keyword1">OR</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">quickcheck</span></span><span class="main">[</span>narrowing<span class="main">,</span> expect<span class="main">=</span>counterexample<span class="main">]</span>
<span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span> <span class="main">::</span> uint16 <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">=</span> <span class="free">g</span>"</span></span>
<span class="keyword1"><span class="command">quickcheck</span></span><span class="main">[</span>narrowing<span class="main">,</span> size<span class="main">=</span>3<span class="main">,</span> expect<span class="main">=</span>counterexample<span class="main">]</span>
<span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">::</span> uint8<span class="main">)</span> <span class="keyword1">AND</span> <span class="free">y</span> <span class="main">=</span> <span class="free">x</span> <span class="keyword1">OR</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">quickcheck</span></span><span class="main">[</span>narrowing<span class="main">,</span> expect<span class="main">=</span>counterexample<span class="main">]</span>
<span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span> <span class="main">::</span> uint8 <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">=</span> <span class="free">g</span>"</span></span>
<span class="keyword1"><span class="command">quickcheck</span></span><span class="main">[</span>narrowing<span class="main">,</span> size<span class="main">=</span>3<span class="main">,</span> expect<span class="main">=</span>counterexample<span class="main">]</span>
<span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">::</span> uint<span class="main">)</span> <span class="keyword1">AND</span> <span class="free">y</span> <span class="main">=</span> <span class="free">x</span> <span class="keyword1">OR</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">quickcheck</span></span><span class="main">[</span>narrowing<span class="main">,</span> expect<span class="main">=</span>counterexample<span class="main">]</span>
<span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span> <span class="main">::</span> uint <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">=</span> <span class="free">g</span>"</span></span>
<span class="keyword1"><span class="command">quickcheck</span></span><span class="main">[</span>narrowing<span class="main">,</span> size<span class="main">=</span>3<span class="main">,</span> expect<span class="main">=</span>counterexample<span class="main">]</span>
<span class="keyword1"><span class="command">oops</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Native_Word_Test_MLton">
<div class="head">
<h1>Theory Native_Word_Test_MLton</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Native_Word_Test_MLton.thy
    Author:     Andreas Lochbihler, ETH Zurich
*)</span>

<span class="keyword1"><span class="command">theory</span></span> Native_Word_Test_MLton <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Native_Word_Test.html">Native_Word_Test</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Test with MLton›</span></span>

<span class="keyword1"><span class="command">test_code</span></span>
  <span class="quoted">test_uint64</span> <span class="quoted"><span class="quoted">"test_uint64' <span class="main">=</span> <span class="numeral">0x12</span>"</span></span>
  <span class="quoted">test_uint32</span> <span class="quoted"><span class="quoted">"test_uint32' <span class="main">=</span> <span class="numeral">0x12</span>"</span></span>
  <span class="quoted">test_uint8</span> <span class="quoted"><span class="quoted">"test_uint8' <span class="main">=</span> <span class="numeral">0x12</span>"</span></span>
  <span class="quoted">test_uint</span>
  <span class="quoted">test_casts</span>
  <span class="quoted">test_casts''</span>
  <span class="quoted">test_casts_uint</span>
  <span class="quoted">test_casts_uint''</span>
<span class="keyword2"><span class="keyword">in</span></span> MLton

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹MLton provides \texttt{Word16} and \texttt{Word64} structures. To test them in the
  SML\_word target, we have to associate a driver with the combination.›</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">Code_Test.add_driver</span> <span class="main">(</span><span class="inner_quoted">"MLton_word"</span><span class="main">,</span> <span class="main">(</span><span class="entity">Code_Test.evaluate_in_mlton</span><span class="main">,</span> <span class="inner_quoted">"SML_word"</span><span class="main">)</span><span class="main">)</span>›</span>

<span class="keyword1"><span class="command">test_code</span></span>
  <span class="quoted">test_uint64</span> <span class="quoted"><span class="quoted">"test_uint64' <span class="main">=</span> <span class="numeral">0x12</span>"</span></span>
  <span class="quoted">test_uint32</span> <span class="quoted"><span class="quoted">"test_uint32' <span class="main">=</span> <span class="numeral">0x12</span>"</span></span>
  <span class="quoted">test_uint16</span>
  <span class="quoted">test_uint8</span> <span class="quoted"><span class="quoted">"test_uint8' <span class="main">=</span> <span class="numeral">0x12</span>"</span></span>
  <span class="quoted">test_uint</span>
  <span class="quoted">test_casts</span>
  <span class="quoted">test_casts'</span>
  <span class="quoted">test_casts''</span>
  <span class="quoted">test_casts_uint</span>
  <span class="quoted">test_casts_uint'</span>
  <span class="quoted">test_casts_uint''</span>
<span class="keyword2"><span class="keyword">in</span></span> MLton_word

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Native_Word_Test_MLton2">
<div class="head">
<h1>Theory Native_Word_Test_MLton2</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Native_Word_Test_MLton2.thy
    Author:     Andreas Lochbihler, ETH Zurich
*)</span>

<span class="keyword1"><span class="command">theory</span></span> Native_Word_Test_MLton2 <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Native_Word_Test_Emu.html">Native_Word_Test_Emu</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">test_casts'</span></span> <span class="keyword2"><span class="keyword">in</span></span> SML <span class="keyword2"><span class="keyword">module_name</span></span> Generated_Code

<span class="keyword1"><span class="command">test_code</span></span>
  <span class="quoted">test_uint16</span> <span class="quoted">test_uint16_emulation</span>
  <span class="quoted">test_casts'</span>
  <span class="quoted">test_casts_uint'</span>
<span class="keyword2"><span class="keyword">in</span></span> MLton

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Native_Word_Test_OCaml">
<div class="head">
<h1>Theory Native_Word_Test_OCaml</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Native_Word_Test_MLton2.thy
    Author:     Andreas Lochbihler, ETH Zurich
*)</span>

<span class="keyword1"><span class="command">theory</span></span> Native_Word_Test_OCaml <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Native_Word_Test.html">Native_Word_Test</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Test with OCaml›</span></span>

<span class="keyword1"><span class="command">test_code</span></span>
  <span class="quoted">test_uint64</span> <span class="quoted"><span class="quoted">"test_uint64' <span class="main">=</span> <span class="numeral">0x12</span>"</span></span>
  <span class="quoted">test_uint32</span> <span class="quoted"><span class="quoted">"test_uint32' <span class="main">=</span> <span class="numeral">0x12</span>"</span></span>
  <span class="quoted">test_uint</span>
  <span class="quoted">test_casts''</span>
  <span class="quoted">test_casts_uint</span>
<span class="keyword2"><span class="keyword">in</span></span> OCaml

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Native_Word_Test_OCaml2">
<div class="head">
<h1>Theory Native_Word_Test_OCaml2</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Native_Word_Test_OCaml2.thy
    Author:     Andreas Lochbihler, ETH Zurich
*)</span>

<span class="keyword1"><span class="command">theory</span></span> Native_Word_Test_OCaml2 <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Native_Word_Test_Emu.html">Native_Word_Test_Emu</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">test_code</span></span>
  <span class="quoted">test_uint16</span> <span class="quoted">test_uint16_emulation</span>
  <span class="quoted">test_uint8</span> <span class="quoted"><span class="quoted">"test_uint8' <span class="main">=</span> <span class="numeral">0x12</span>"</span></span> <span class="quoted">test_uint8_emulation</span>
  <span class="quoted">test_casts</span> <span class="quoted">test_casts'</span>
  <span class="quoted">test_casts_uint'</span> <span class="quoted">test_casts_uint''</span>
<span class="keyword2"><span class="keyword">in</span></span> OCaml

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Native_Word_Test_SMLNJ">
<div class="head">
<h1>Theory Native_Word_Test_SMLNJ</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Native_Word_Test_SMLNJ.thy
    Author:     Andreas Lochbihler, ETH Zurich
*)</span>

<span class="keyword1"><span class="command">theory</span></span> Native_Word_Test_SMLNJ <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Native_Word_Test.html">Native_Word_Test</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Test with SML/NJ›</span></span>

<span class="keyword1"><span class="command">test_code</span></span>
  <span class="quoted">test_uint64</span> <span class="quoted"><span class="quoted">"test_uint64' <span class="main">=</span> <span class="numeral">0x12</span>"</span></span>
  <span class="quoted">test_uint32</span> <span class="quoted"><span class="quoted">"test_uint32' <span class="main">=</span> <span class="numeral">0x12</span>"</span></span>
  <span class="quoted">test_uint8</span> <span class="quoted"><span class="quoted">"test_uint8' <span class="main">=</span> <span class="numeral">0x12</span>"</span></span>
  <span class="quoted">test_uint</span>
  <span class="quoted">test_casts</span>
  <span class="quoted">test_casts''</span>
  <span class="quoted">test_casts_uint</span>
  <span class="quoted">test_casts_uint''</span>
<span class="keyword2"><span class="keyword">in</span></span> SMLNJ

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹SMLNJ provides a \texttt{Word64} structure. To test it in the
  SML\_word target, we have to associate a driver with the combination.
  As SMLNj does not implement a Word16 structure, we remove the code module
  that refers to it. After this, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">uint16</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> no longer works in the target
  \texttt{SML\_word} as intended!
›</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">Code_Test.add_driver</span> <span class="main">(</span><span class="inner_quoted">"SMLNJ_word"</span><span class="main">,</span> <span class="main">(</span><span class="entity">Code_Test.evaluate_in_smlnj</span><span class="main">,</span> <span class="inner_quoted">"SML_word"</span><span class="main">)</span><span class="main">)</span>›</span>
<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">code_module</span></span> Uint16 <span class="main">⇀</span> <span class="main">(</span>SML_word<span class="main">)</span> <span class="quoted">‹›</span>

<span class="keyword1"><span class="command">test_code</span></span>
  <span class="quoted">test_uint64</span> <span class="quoted"><span class="quoted">"test_uint64' <span class="main">=</span> <span class="numeral">0x12</span>"</span></span>
  <span class="quoted">test_uint32</span> <span class="quoted"><span class="quoted">"test_uint32' <span class="main">=</span> <span class="numeral">0x12</span>"</span></span>
  <span class="quoted">test_uint8</span> <span class="quoted"><span class="quoted">"test_uint8' <span class="main">=</span> <span class="numeral">0x12</span>"</span></span>
  <span class="quoted">test_uint</span>
  <span class="comment1">― ‹The cast operations for <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">uint64</span><span class="antiquote">}</span></span> use \texttt{Word64.fromLarge} and
      \texttt{Word64.toLarge}, which are unimplemented in SMLNJ's \texttt{Word64} structure.›</span>
  <span class="comment1">(* test_casts test_casts'' 
  test_casts_uint *)</span>
  <span class="quoted">test_casts_uint''</span>
<span class="keyword2"><span class="keyword">in</span></span> SMLNJ_word

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Native_Word_Test_SMLNJ2">
<div class="head">
<h1>Theory Native_Word_Test_SMLNJ2</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Native_Word_Test_SMLNJ2.thy
    Author:     Andreas Lochbihler, ETH Zurich
*)</span>

<span class="keyword1"><span class="command">theory</span></span> Native_Word_Test_SMLNJ2 <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Native_Word_Test_Emu.html">Native_Word_Test_Emu</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">test_code</span></span>
  <span class="quoted">test_uint16</span> <span class="quoted">test_uint16_emulation</span>
  <span class="quoted">test_casts'</span>
  <span class="quoted">test_casts_uint'</span>
<span class="keyword2"><span class="keyword">in</span></span> SMLNJ

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Uint_Userguide">
<div class="head">
<h1>Theory Uint_Userguide</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Uint_Userguide.thy
    Author:     Andreas Lochbihler, ETH Zurich
*)</span>

<span class="keyword1"><span class="command">chapter</span></span> <span class="quoted"><span class="plain_text">‹User guide for native words›</span></span>

<span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">theory</span></span> Uint_Userguide <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Uint32.html">Uint32</a>
  <a href="Uint16.html">Uint16</a>
  <a href="Code_Target_Bits_Int.html">Code_Target_Bits_Int</a>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  This tutorial explains how to best use the types for native
  words like <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"uint32"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> in your formalisation.
  You can base your formalisation
  \begin{enumerate}
  \item either directly on these types,
  \item or on the generic <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> word"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and only introduce native
    words a posteriori via code generator refinement.
  \end{enumerate}

  The first option causes the least overhead if you have to prove only
  little about the words you use and start a fresh formalisation.
  Just use the native type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">uint32</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> instead of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="numeral"><span class="numeral">32</span></span> word"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
  and similarly for <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>uint64›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>uint16›</span></span></span></span>, and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>uint8›</span></span></span></span>.
  As native word types are meant only for code generation, the lemmas
  about <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> word"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>  have not been duplicated, but you can transfer
  theorems between native word types and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> word"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> using the
  transfer package.

  Note, however, that this option restricts your work a bit:
  your own functions cannot be ``polymorphic'' in the word length,
  but you have to define a separate function for every word length you need.

  The second option is recommended if you already have a formalisation
  based on <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> word"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> or if your proofs involve words and their
  properties. It separates code generation from modelling and proving,
  i.e., you can work with words as usual. Consequently, you have to
  manually setup the code generator to use the native types wherever
  you want. The following describes how to achieve this with moderate
  effort.

  Note, however, that some target languages of the code generator
  (especially OCaml) do not support all the native word types provided.
  Therefore, you should only import those types that you need -- the
  theory file for each type mentions at the top the restrictions for
  code generation. For example, PolyML does not provide the Word16
  structure, and OCaml provides neither Word8 nor Word16.
  You can still use these theories provided that you also import
  the theory <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory</span></span> <a href="Code_Target_Bits_Int.html"></a><a href="Code_Target_Bits_Int.html">Native_Word.Code_Target_Bits_Int</a><span class="antiquote"><span class="antiquote">}</span></span></span></span> (which implements
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">int</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> by target-language integers), but these words will
  be implemented via Isabelle's <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Word›</span></span></span></span> library, i.e.,
  you do not gain anything in terms of efficiency.

  \textbf{There is a separate code target <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>SML_word›</span></span></span></span> for SML.}
  If you use one of the native words that PolyML does not support
  (such as <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>uint16›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>uint64›</span></span></span></span> in 32-bit mode), but would
  like to map its operations to the Standard Basis Library functions,
  make sure to use the target <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>SML_word›</span></span></span></span> instead of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>SML›</span></span></span></span>;
  if you only use native word sizes that PolyML supports, you can stick
  with <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>SML›</span></span></span></span>.  This ensures that code generation within Isabelle
  as used by <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Quickcheck›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>value›</span></span></span></span> and @\{code\} in ML blocks
  continues to work.
›</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Lifting functions from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> word"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to native words›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  This section shows how to convert functions from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> word"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to native 
  words. For example, the following function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>sum_squares›</span></span></span></span> computes 
  the sum of the first <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">n</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> square numbers in 16 bit arithmetic using
  a tail-recursive function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>gen_sum_squares›</span></span></span></span> with accumulator;
  for convenience, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>sum_squares_int›</span></span></span></span> takes an integer instead of a word.
›</span></span>

<span class="keyword1"><span class="command">function</span></span> <span class="entity">gen_sum_squares</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="numeral">16</span> word <span class="main">⇒</span> <span class="numeral">16</span> word <span class="main">⇒</span> <span class="numeral">16</span> word"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="comment1">(*&lt;*)</span><span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span></span></span></span><span class="main">]</span><span class="main">:</span><span class="comment1">(*&gt;*)</span>

  <span class="quoted"><span class="quoted">"<span class="free">gen_sum_squares</span> <span class="free"><span class="bound"><span class="entity">accum</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span>
   <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">accum</span></span></span> <span class="keyword1">else</span> <span class="free">gen_sum_squares</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">accum</span></span></span> <span class="main">+</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">*</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="comment1">(*&lt;*)</span><span class="keyword1"><span class="command">by</span></span> <span class="operator">pat_completeness</span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">termination</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">relation</span> <span class="quoted"><span class="quoted">‹measure <span class="main">(</span>nat <span class="main">∘</span> uint <span class="main">∘</span> snd<span class="main">)</span>›</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> measure_unat<span class="main">)</span><span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">sum_squares</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="numeral">16</span> word <span class="main">⇒</span> <span class="numeral">16</span> word"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
   <span class="quoted"><span class="quoted">"<span class="free">sum_squares</span> <span class="main">=</span> gen_sum_squares <span class="main">0</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">sum_squares_int</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"int <span class="main">⇒</span> <span class="numeral">16</span> word"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">sum_squares_int</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> sum_squares <span class="main">(</span>word_of_int <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The generated code for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">sum_squares</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">sum_squares_int</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> 
  emulates words with unbounded integers and explicit modulus as specified 
  in the theory <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory</span></span> "<a href="../../HOL/HOL-Library/Word.html"></a><a href="../../HOL/HOL-Library/Word.html">HOL-Library.Word</a>"<span class="antiquote"><span class="antiquote">}</span></span></span></span>. But for efficiency, we want that the
  generated code uses machine words and machine arithmetic. Unfortunately,
  as <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> word"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is polymorphic in the word length, the code generator
  can only do this if we use another type for machine words. The theory
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory</span></span> <a href="Uint16.html"></a><a href="Uint16.html">Native_Word.Uint16</a><span class="antiquote"><span class="antiquote">}</span></span></span></span> defines the type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">uint16</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> for machine words of
  16~bits. We just have to follow two steps to use it:
  
  First, we lift all our functions from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="numeral"><span class="numeral">16</span></span> word"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">uint16</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>,
  i.e., <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">sum_squares</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">gen_sum_squares</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, and 
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">sum_squares_int</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> in our case. The theory <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory</span></span> <a href="Uint16.html"></a><a href="Uint16.html">Native_Word.Uint16</a><span class="antiquote"><span class="antiquote">}</span></span></span></span> sets
  up the lifting package for this and has already taken care of the
  arithmetic and bit-wise operations.
›</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> gen_sum_squares_uint <span class="main">::</span> <span class="quoted"><span class="quoted">"uint16 <span class="main">⇒</span> uint16 <span class="main">⇒</span> uint16"</span></span> 
  <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">gen_sum_squares</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> sum_squares_uint <span class="main">::</span> <span class="quoted"><span class="quoted">"uint16 <span class="main">⇒</span> uint16"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">sum_squares</span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> sum_squares_int_uint <span class="main">::</span> <span class="quoted"><span class="quoted">"int <span class="main">⇒</span> uint16"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">sum_squares_int</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Second, we also have to transfer the code equations for our functions.
  The attribute <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Transfer.transferred›</span></span></span></span> takes care of that, but it is
  better to check that the transfer succeeded: inspect the theorem to check
  that the new constants are used throughout.
›</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">Transfer.transferred</span><span class="main">,</span> <span class="operator">code</span><span class="main">]</span> <span class="main">=</span>
  gen_sum_squares.simps
  sum_squares_def
  sum_squares_int_def

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Finally, we export the code to standard ML.  We use the target
  <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>SML_word›</span></span></span></span> instead of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>SML›</span></span></span></span> to have the operations
  on <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">uint16</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> mapped to the Standard Basis Library. As PolyML
  does not provide a Word16 type, the mapping for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">uint16</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is only
  active in the refined target <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>SML_word›</span></span></span></span>.
›</span></span>
<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">sum_squares_int_uint</span></span> <span class="keyword2"><span class="keyword">in</span></span> SML_word

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Nevertheless, we can still evaluate terms with <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">uint16</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> within 
  Isabelle, i.e., PolyML, but this will be translated to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="numeral"><span class="numeral">16</span></span> word"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
  and therefore less efficient.
›</span></span>

<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"sum_squares_int_uint <span class="numeral">40</span>"</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Storing native words in datatypes›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The above lifting is necessary for all functions whose type mentions
  the word type. Fortunately, we do not have to duplicate functions that
  merely operate on datatypes that contain words. Nevertheless, we have
  to tell the code generator that these functions should call the new ones,
  which operate on machine words. This section shows how to achieve this
  with data refinement.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Example: expressions and two semantics›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  As the running example, we consider a language of expressions (literal values, less-than comparisions and conditional) where values are either booleans or 32-bit words.
  The original specification uses the type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="numeral"><span class="numeral">32</span></span> word"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> val <span class="main">=</span> Bool <span class="quoted">bool</span> <span class="main">|</span> Word <span class="quoted"><span class="quoted">"<span class="numeral">32</span> word"</span></span>
<span class="keyword1"><span class="command">datatype</span></span> expr <span class="main">=</span> Lit <span class="quoted">val</span> <span class="main">|</span> LT <span class="quoted">expr</span> <span class="quoted">expr</span> <span class="main">|</span> IF <span class="quoted">expr</span> <span class="quoted">expr</span> <span class="quoted">expr</span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="entity">word</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="numeral">32</span> word <span class="main">⇒</span> expr"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">word</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">≡</span> Lit <span class="main">(</span>Word <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="entity">bool</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"bool <span class="main">⇒</span> expr"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">bool</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">≡</span> Lit <span class="main">(</span>Bool <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span>"</span></span>

<span class="comment1">― ‹Denotational semantics of expressions, <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">None</span><span class="antiquote">}</span></span> denotes a type error›</span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity">eval</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"expr <span class="main">⇒</span> val option"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">eval</span> <span class="main">(</span>Lit <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">=</span> Some <span class="free"><span class="bound"><span class="entity">v</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">eval</span> <span class="main">(</span>LT <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>2</sub></span></span></span><span class="main">)</span> <span class="main">=</span> 
  <span class="main">(</span><span class="keyword1">case</span> <span class="main">(</span><span class="free">eval</span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>1</sub></span></span></span><span class="main">,</span> <span class="free">eval</span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>2</sub></span></span></span><span class="main">)</span> 
   <span class="keyword1">of</span> <span class="main">(</span>Some <span class="main">(</span>Word <span class="bound">i<span class="hidden">⇩</span><sub>1</sub></span><span class="main">)</span><span class="main">,</span> Some <span class="main">(</span>Word <span class="bound">i<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">)</span> <span class="main">⇒</span> Some <span class="main">(</span>Bool <span class="main">(</span><span class="bound">i<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">&lt;</span> <span class="bound">i<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span><span class="main">)</span>
   <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> None<span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">eval</span> <span class="main">(</span>IF <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>3</sub></span></span></span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> <span class="free">eval</span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="keyword1">of</span> Some <span class="main">(</span>Bool <span class="bound">b</span><span class="main">)</span> <span class="main">⇒</span> <span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="free">eval</span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="keyword1">else</span> <span class="free">eval</span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>3</sub></span></span></span>
   <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> None<span class="main">)</span>"</span></span>

<span class="comment1">― ‹Small-step semantics of expressions, it gets stuck upon type errors.›</span>
<span class="keyword1"><span class="command">inductive</span></span> <span class="entity">step</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"expr <span class="main">⇒</span> expr <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="quoted">"_ <span class="keyword1">→</span> _"</span> <span class="main">[</span>50<span class="main">,</span> 50<span class="main">]</span> 60<span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main"><span class="free">→</span></span> <span class="free"><span class="bound"><span class="entity">e'</span></span></span> <span class="main">⟹</span> LT <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="main"><span class="free">→</span></span> LT <span class="free"><span class="bound"><span class="entity">e'</span></span></span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>2</sub></span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main"><span class="free">→</span></span> <span class="free"><span class="bound"><span class="entity">e'</span></span></span> <span class="main">⟹</span> LT <span class="main">(</span>word <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main"><span class="free">→</span></span> LT <span class="main">(</span>word <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">e'</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"LT <span class="main">(</span>word <span class="free"><span class="bound"><span class="entity">i<span class="hidden">⇩</span><sub>1</sub></span></span></span><span class="main">)</span> <span class="main">(</span>word <span class="free"><span class="bound"><span class="entity">i<span class="hidden">⇩</span><sub>2</sub></span></span></span><span class="main">)</span> <span class="main"><span class="free">→</span></span> bool <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">i<span class="hidden">⇩</span><sub>2</sub></span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main"><span class="free">→</span></span> <span class="free"><span class="bound"><span class="entity">e'</span></span></span> <span class="main">⟹</span> IF <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="main"><span class="free">→</span></span> IF <span class="free"><span class="bound"><span class="entity">e'</span></span></span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>2</sub></span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"IF <span class="main">(</span>bool True<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="main"><span class="free">→</span></span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>1</sub></span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"IF <span class="main">(</span>bool False<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="main"><span class="free">→</span></span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>2</sub></span></span></span>"</span></span>

<span class="comment1">― ‹Compile the inductive definition with the predicate compiler›</span>
<span class="keyword1"><span class="command">code_pred</span></span> <span class="main">(</span>modes<span class="main">:</span> i ⇒ o ⇒ bool as reduce<span class="main">,</span> i ⇒ i ⇒ bool as step'<span class="main">)</span> <span class="quoted"><span class="quoted">step</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Change the datatype to use machine words›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Now, we want to use <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">uint32</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> instead of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="numeral"><span class="numeral">32</span></span> word"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  The goal is to make the code generator use the new type without
  duplicating any of the types (<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">val</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">expr</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>) or the
  functions (<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">eval</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">reduce</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>) on such types.

  The constructor <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Word</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> has <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="numeral"><span class="numeral">32</span></span> word"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> in its type, so
  we have to lift it to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Word'›</span></span></span></span>, and the same holds for the
  case combinator <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">case_val</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, which <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">case_val'</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> replaces.%
  \footnote{%
    Note that we should not declare a case translation for the new
    case combinator because this will break parsing case expressions
    with old case combinator.
  }
  Next, we set up the code generator accordingly:
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Bool</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">Word'</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> are the new constructors for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">val</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>,
  and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">case_val'</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is the new case combinator with an appropriate 
  case certificate.%
  \footnote{%
    Case certificates tell the code generator to replace the HOL
    case combinator for a datatype with the case combinator of the
    target language.  Without a case certificate, the code generator
    generates a function that re-implements the case combinator; 
    in a strict languages like ML or Scala, this means that the code
    evaluates all possible cases before it decides which one is taken.

    Case certificates are described in Haftmann's PhD thesis
    \cite[Def.\ 27]{Haftmann2009PhD}. For a datatype <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>dt›</span></span></span></span>
    with constructors <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>C<span class="hidden">⇩</span><sub>1</sub>›</span></span></span></span> to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>C<span class="hidden">⇩</span><sub>n</sub>›</span></span></span></span>
    where each constructor <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>C<span class="hidden">⇩</span><sub>i</sub>›</span></span></span></span> takes <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>k<span class="hidden">⇩</span><sub>i</sub>›</span></span></span></span> parameters,
    the certificate for the case combinator <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>case_dt›</span></span></span></span>
    looks as follows:

    {
      \isamarkuptrue\isacommand{lemma}\isamarkupfalse\isanewline%
      \ \ \isakeyword{assumes}\ {\isachardoublequoteopen}CASE\ {\isasymequiv}\ dt{\isacharunderscore}case\ c\isactrlsub {\isadigit{1}}\ c\isactrlsub {\isadigit{2}}\ \ldots\ c\isactrlsub{n}{\isachardoublequoteclose}\isanewline
      \ \ \isakeyword{shows}\ {\isachardoublequoteopen}{\isacharparenleft}CASE\ {\isacharparenleft}C\isactrlsub {\isadigit{1}}\ a\isactrlsub {\isadigit{1}}\isactrlsub {\isadigit{1}}\ a\isactrlsub {\isadigit{1}}\isactrlsub {\isadigit{2}}\ \ldots\ a\isactrlsub {\isadigit{1}}\isactrlsub {k\ensuremath{{}_1}}{\isacharparenright}\ {\isasymequiv}\ c\isactrlsub {\isadigit{1}}\ a\isactrlsub {\isadigit{1}}\isactrlsub {\isadigit{1}}\ a\isactrlsub {\isadigit{1}}\isactrlsub {\isadigit{2}}\ \ldots\ a\isactrlsub {\isadigit{1}}\isactrlsub {k\ensuremath{{}_1}}{\isacharparenright}\isanewline
      \ \ \ \ {\isacharampersand}{\isacharampersand}{\isacharampersand}\ {\isacharparenleft}CASE\ {\isacharparenleft}C\isactrlsub {\isadigit{2}}\ a\isactrlsub {\isadigit{2}}\isactrlsub {\isadigit{1}}\ a\isactrlsub {\isadigit{2}}\isactrlsub {\isadigit{2}}\ \ldots\ a\isactrlsub {\isadigit{2}}\isactrlsub {k\ensuremath{{}_2}}{\isacharparenright}\ {\isasymequiv}\ c\isactrlsub {\isadigit{2}}\ a\isactrlsub {\isadigit{2}}\isactrlsub {\isadigit{1}}\ a\isactrlsub {\isadigit{2}}\isactrlsub {\isadigit{2}}\ \ldots\ a\isactrlsub {\isadigit{2}}\isactrlsub {k\ensuremath{{}_2}}{\isacharparenright}\isanewline
      \ \ \ \ {\isacharampersand}{\isacharampersand}{\isacharampersand}\ \ldots\isanewline
      \ \ \ \ {\isacharampersand}{\isacharampersand}{\isacharampersand}\ {\isacharparenleft}CASE\ {\isacharparenleft}C\isactrlsub {n}\ a\isactrlsub {n}\isactrlsub {\isadigit{1}}\ a\isactrlsub {n}\isactrlsub {\isadigit{2}}\ \ldots\ a\isactrlsub {n}\isactrlsub {k\ensuremath{{}_n}}{\isacharparenright}\ {\isasymequiv}\ c\isactrlsub {n}\ a\isactrlsub {n}\isactrlsub {\isadigit{1}}\ a\isactrlsub {n}\isactrlsub {\isadigit{2}}\ \ldots\ a\isactrlsub {n}\isactrlsub {k\ensuremath{{}_n}}{\isacharparenright}{\isachardoublequoteclose}\isanewline
    }
  }
  We delete the code equations for the old constructor <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Word</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
  and case combinator <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">case_val</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> such that the code generator
  reports missing adaptations.
›</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> Word' <span class="main">::</span> <span class="quoted"><span class="quoted">"uint32 <span class="main">⇒</span> val"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">Word</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">code_datatype</span></span> <span class="quoted">Bool</span> <span class="quoted">Word'</span>

<span class="keyword1"><span class="command">lift_definition</span></span> case_val' <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>bool <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span>uint32 <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⇒</span> val <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">case_val</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> val.case <span class="main">[</span><span class="operator">Transfer.transferred</span><span class="main">]</span>

<span class="keyword1" id="Uint_Userguide-case_val'_cert"><span class="command">lemma</span></span> case_val'_cert<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">bool</span> <span class="free">word'</span> <span class="free">b</span> <span class="free">w</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">CASE</span> <span class="main">≡</span> case_val' <span class="free">bool</span> <span class="free">word'</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">CASE</span> <span class="main">(</span>Bool <span class="free">b</span><span class="main">)</span> <span class="main">≡</span> <span class="free">bool</span> <span class="free">b</span><span class="main">)</span> <span class="main">&amp;&amp;&amp;</span> <span class="main">(</span><span class="free">CASE</span> <span class="main">(</span>Word' <span class="free">w</span><span class="main">)</span> <span class="main">≡</span> <span class="free">word'</span> <span class="free">w</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main">)</span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">Code.declare_case_global</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> case_val'_cert<span class="antiquote">}</span></span></span>›</span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">drop</span><span class="main"><span class="main">:</span></span> <span class="quoted">case_val</span> <span class="quoted">Word</span><span class="main">]</span><span class="main">]</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Make functions use functions on machine words›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Finally, we merely have to change the code equations to use the 
  new functions that operate on <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">uint32</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>. As before, the
  attribute <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Transfer.transferred›</span></span></span></span> does the job. In our example,
  we adapt the equality test on <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">val</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> (code equations
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] val.eq.simps<span class="antiquote"><span class="antiquote">}</span></span></span></span>) and the denotational and small-step 
  semantics (code equations <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] eval.simps<span class="antiquote"><span class="antiquote">}</span></span></span></span> and
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] step.equation<span class="antiquote"><span class="antiquote">}</span></span></span></span>, respectively).

  We check that the adaptation has suceeded by exporting the functions.
  As we only use native word sizes that PolyML supports, we can use 
  the usual target <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>SML›</span></span></span></span> instead of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>SML_word›</span></span></span></span>.
›</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> 
  val.eq.simps<span class="main">[</span><span class="operator">THEN</span> meta_eq_to_obj_eq<span class="main">,</span> <span class="operator">Transfer.transferred</span><span class="main">,</span> <span class="operator">THEN</span> eq_reflection<span class="main">]</span>
  eval.simps<span class="main">[</span><span class="operator">Transfer.transferred</span><span class="main">]</span>
  step.equation<span class="main">[</span><span class="operator">Transfer.transferred</span><span class="main">]</span>

<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">reduce</span></span> <span class="quoted"><span class="quoted">step'</span></span> <span class="quoted"><span class="quoted">eval</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Troubleshooting›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  This section explains some possible problems when using native words.
  If you experience other difficulties, please contact the author.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>export_code›</span></span></span></span> raises an exception \label{section:export_code:exception}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Probably, you have defined and are using a function on a native word type,
  but the code equation refers to emulated words. For example, the following
  defines a function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>double›</span></span></span></span> that doubles a word. When we try to export
  code for <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>double›</span></span></span></span> without any further setup, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>export_code›</span></span></span></span> will
  raise an exception or generate code that does not compile.
›</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> double <span class="main">::</span> <span class="quoted"><span class="quoted">"uint32 <span class="main">⇒</span> uint32"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">+</span> <span class="bound">x</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We have to prove a code equation that only uses the existing operations on
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">uint32</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>. Then, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>export_code›</span></span></span></span> works again.
›</span></span>

<span class="keyword1" id="Uint_Userguide-double_code"><span class="command">lemma</span></span> double_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"double <span class="free">n</span> <span class="main">=</span> <span class="free">n</span> <span class="main">+</span> <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹The generated code does not compile›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Probably, you have been exporting to a target language for which there
  is no setup, or your compiler does not provide the required API. Every
  theory for native words mentions at the start the limitations on code
  generation. Check that your concrete application meets all the
  requirements.

  Alternatively, this might be an instance of the problem described 
  in \S\ref{section:export_code:exception}.

  For Haskell, you have to enable the extension TypeSynonymInstances with \texttt{-XTypeSynonymInstances}
  if you are using polymorphic bit operations on the native word types.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹The generated code is too slow›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The generated code will most likely not be as fast as a direct implementation in the target language with manual tuning.
  This is because we want the configuration of the code generation to be sound (as it can be used to prove theorems in Isabelle).
  Therefore, the bit operations sometimes perform range checks before they call the target language API.
  Here are some examples:
  \begin{itemize}
  \item Shift distances and bit indices in target languages are often expected to fit into a bounded integer or word.
    However, the size of these types varies across target languages and platforms.
    Hence, no Isabelle/HOL type can model uniformly all of them.
    Instead, the bit operations use arbitrary-precision integers for such quantities and check at run-time that the values fit into a bounded integer or word, respectively -- if not, they raise an exception.
  
  \item Division and modulo operations explicitly test whether the divisor is $0$ and return the HOL value of division by $0$ in that case.
    This is necessary because some languages leave the behaviour of division by 0 unspecified.
  \end{itemize}
  
  If you have better ideas how to eliminate such checks and speed up the generated code without sacrificing soundness, please contact the author!
›</span></span>

<span class="comment1">(*&lt;*)</span><span class="keyword2"><span class="keyword">end</span></span><span class="comment1">(*&gt;*)</span>
</pre>
</div>