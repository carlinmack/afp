<div id="TypeApp">
<div class="head">
<h1>Theory TypeApp</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Type Application›</span></span>

<span class="keyword1"><span class="command">theory</span></span> TypeApp
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOLCF/HOLCF.html">HOLCF</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Class of type constructors›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In HOLCF, the type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"udom defl"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> consists of deflations
over the universal domain---each value of type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"udom defl"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
represents a bifinite domain. In turn, values of the continuous
function type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"udom defl <span class="main"><span class="main">→</span></span> udom defl"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> represent functions from
domains to domains, i.e.~type constructors.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Class <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>tycon›</span></span></span></span>, defined below, will be populated with
dummy types: For example, if the type <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>foo›</span></span></span></span> is an instance of
class <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>tycon›</span></span></span></span>, then users will never deal with any values <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>x::foo›</span></span></span></span> in practice. Such types are only used with the overloaded
constant <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>tc›</span></span></span></span>, which associates each type <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>'a::tycon›</span></span></span></span>
with a value of type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"udom defl <span class="main"><span class="main">→</span></span> udom defl"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>. \medskip›</span></span>

<span class="keyword1"><span class="command">class</span></span> tycon <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free"><span class="free"><span class="free">tc</span></span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>type<span class="main">)</span> itself <span class="main">⇒</span> udom defl <span class="main">→</span> udom defl"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> itself"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is defined in Isabelle's meta-logic;
it is inhabited by a single value, written <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1">TYPE</span></span><span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>. We
define the syntax <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>TC('a)›</span></span></span></span> to abbreviate <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>tc
TYPE('a)›</span></span></span></span>. \medskip›</span></span>

<span class="keyword1"><span class="command">syntax</span></span>  <span class="quoted">"_TC"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"type <span class="main">⇒</span> logic"</span></span>  <span class="main">(</span><span class="quoted">"<span class="keyword3">(1</span><span class="keyword1">TC</span><span class="keyword3">/</span><span class="keyword3">(1</span><span class="keyword1">'(</span>_<span class="keyword1">')</span><span class="keyword3">)</span><span class="keyword3">)</span>"</span><span class="main">)</span>

<span class="keyword1"><span class="command">translations</span></span> <span class="quoted">"<span class="keyword1">TC</span><span class="main">(</span><span class="tfree"><span class="free">'a</span></span><span class="main">)</span>"</span> <span class="main">⇌</span> <span class="quoted">"<span class="keyword1">CONST</span> tc <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree"><span class="free">'a</span></span><span class="main">)</span>"</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Type constructor for type application›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We now define a binary type constructor that models type
application: Type <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>('a, 't) app›</span></span></span></span> is the result of applying the
type constructor <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>'t›</span></span></span></span> (from class <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>tycon›</span></span></span></span>) to the type
argument <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>'a›</span></span></span></span> (from class <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>domain›</span></span></span></span>).›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We define type <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>('a, 't) app›</span></span></span></span> using <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>domaindef›</span></span></span></span>,
a low-level type-definition command provided by HOLCF (similar to
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>typedef›</span></span></span></span> in Isabelle/HOL) that defines a new domain type
represented by the given deflation. Note that in HOLCF, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>DEFL('a)›</span></span></span></span> is an abbreviation for <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>defl TYPE('a)›</span></span></span></span>, where
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>defl :: ('a::domain) itself ⇒ udom defl›</span></span></span></span> is an overloaded
function from the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>domain›</span></span></span></span> type class that yields the deflation
representing the given type. \medskip›</span></span>

<span class="keyword1"><span class="command">domaindef</span></span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'t</span><span class="main">)</span> app <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="keyword1">TC</span><span class="main">(</span><span class="tfree">'t</span><span class="main">::</span>tycon<span class="main">)</span><span class="main">⋅</span><span class="keyword1">DEFL</span><span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>domain<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We define the infix syntax <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>'a⋅'t›</span></span></span></span> for the type <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>('a,'t) app›</span></span></span></span>. Note that for consistency with Isabelle's existing
type syntax, we have used postfix order for type application: type
argument on the left, type constructor on the right. \medskip›</span></span>

<span class="keyword1"><span class="command">type_notation</span></span> app <span class="main">(</span><span class="quoted">"<span class="keyword3">(</span>_<span class="keyword1">⋅</span>_<span class="keyword3">)</span>"</span> <span class="main">[</span>999<span class="main">,</span>1000<span class="main">]</span> 999<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>domaindef›</span></span></span></span> command generates the theorem <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>DEFL_app›</span></span></span></span>: <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> DEFL_app <span class="main"><span class="main">[</span></span><span class="operator"><span class="operator">where</span></span> 'a<span class="main"><span class="main"><span class="main"><span class="main">=</span></span></span></span><span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">::</span></span>domain"</span></span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> 't<span class="main"><span class="main"><span class="main"><span class="main">=</span></span></span></span><span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'t</span></span><span class="main"><span class="main">::</span></span>tycon"</span></span><span class="main"><span class="main">]</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>,
which we can use to derive other useful lemmas. \medskip›</span></span>

<span class="keyword1" id="TypeApp-TC_DEFL"><span class="command">lemma</span></span> TC_DEFL<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">TC</span><span class="main">(</span><span class="tfree">'t</span><span class="main">::</span>tycon<span class="main">)</span><span class="main">⋅</span><span class="keyword1">DEFL</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">DEFL</span><span class="main">(</span><span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'t</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> DEFL_app <span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="TypeApp-DEFL_app_mono"><span class="command">lemma</span></span> DEFL_app_mono <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="keyword1">DEFL</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">⊑</span> <span class="keyword1">DEFL</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span> <span class="main">⟹</span> <span class="keyword1">DEFL</span><span class="main">(</span><span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'t</span><span class="main">::</span>tycon<span class="main">)</span> <span class="main">⊑</span> <span class="keyword1">DEFL</span><span class="main">(</span><span class="tfree">'b</span><span class="main">⋅</span><span class="tfree">'t</span><span class="main">)</span>"</span></span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> DEFL_app<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> monofun_cfun_arg<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Coerce">
<div class="head">
<h1>Theory Coerce</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Coercion Operator›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Coerce
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOLCF/HOLCF.html">HOLCF</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Coerce›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>domain›</span></span></span></span> type class, which is the default type class
in HOLCF, fixes two overloaded functions: <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>emb::'a → udom›</span></span></span></span> and
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>prj::udom → 'a›</span></span></span></span>. By composing the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>prj›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>emb›</span></span></span></span>
functions together, we can coerce values between any two types in
class <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>domain›</span></span></span></span>. \medskip›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">coerce</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'b</span>"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">coerce</span> <span class="main">≡</span> prj <span class="keyword1">oo</span> emb"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹When working with proofs involving <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>emb›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>prj›</span></span></span></span>,
and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>coerce›</span></span></span></span>, it is often difficult to tell at which types those
constants are being used. To alleviate this problem, we define special
input and output syntax to indicate the types. \medskip›</span></span>

<span class="keyword1"><span class="command">syntax</span></span>
  <span class="quoted">"_emb"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"type <span class="main">⇒</span> logic"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword3">(1</span><span class="keyword1">EMB</span><span class="keyword3">/</span><span class="keyword3">(1</span><span class="keyword1">'(</span>_<span class="keyword1">')</span><span class="keyword3">)</span><span class="keyword3">)</span>"</span><span class="main">)</span>
  <span class="quoted">"_prj"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"type <span class="main">⇒</span> logic"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword3">(1</span><span class="keyword1">PRJ</span><span class="keyword3">/</span><span class="keyword3">(1</span><span class="keyword1">'(</span>_<span class="keyword1">')</span><span class="keyword3">)</span><span class="keyword3">)</span>"</span><span class="main">)</span>
  <span class="quoted">"_coerce"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"type <span class="main">⇒</span> type <span class="main">⇒</span> logic"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword3">(1</span><span class="keyword1">COERCE</span><span class="keyword3">/</span><span class="keyword3">(1</span><span class="keyword1">'(</span>_<span class="keyword1">,</span><span class="keyword3">/ </span>_<span class="keyword1">')</span><span class="keyword3">)</span><span class="keyword3">)</span>"</span><span class="main">)</span>

<span class="keyword1"><span class="command">translations</span></span>
  <span class="quoted">"<span class="keyword1">EMB</span><span class="main">(</span><span class="tfree"><span class="free">'a</span></span><span class="main">)</span>"</span> <span class="main">⇀</span> <span class="quoted">"<span class="keyword1">CONST</span> emb <span class="main">::</span> <span class="tfree"><span class="free">'a</span></span> <span class="main">→</span> udom"</span>
  <span class="quoted">"<span class="keyword1">PRJ</span><span class="main">(</span><span class="tfree"><span class="free">'a</span></span><span class="main">)</span>"</span> <span class="main">⇀</span> <span class="quoted">"<span class="keyword1">CONST</span> prj <span class="main">::</span> udom <span class="main">→</span> <span class="tfree"><span class="free">'a</span></span>"</span>
  <span class="quoted">"<span class="keyword1">COERCE</span><span class="main">(</span><span class="tfree"><span class="free">'a</span></span><span class="main">,</span><span class="tfree"><span class="free">'b</span></span><span class="main">)</span>"</span> <span class="main">⇀</span> <span class="quoted">"<span class="keyword1">CONST</span> coerce <span class="main">::</span> <span class="tfree"><span class="free">'a</span></span> <span class="main">→</span> <span class="tfree"><span class="free">'b</span></span>"</span>

<span class="keyword1"><span class="command">typed_print_translation</span></span> <span class="quoted">‹
<span class="keyword2"><span class="keyword">let</span></span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">emb_tr'</span> <span class="main">(</span><span class="entity">ctxt</span> <span class="main">:</span> <span class="entity">Proof.context</span><span class="main">)</span> <span class="main">(</span>Type<span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">[</span><span class="entity">T</span><span class="main">,</span> <span class="main">_</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span>
    Syntax.const <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">syntax_const</span> "_emb"<span class="antiquote">}</span></span> $ Syntax_Phases.term_of_typ <span class="entity">ctxt</span> <span class="entity">T</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prj_tr'</span> <span class="entity">ctxt</span> <span class="main">(</span>Type<span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">[</span><span class="main">_</span><span class="main">,</span> <span class="entity">T</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span>
    Syntax.const <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">syntax_const</span> "_prj"<span class="antiquote">}</span></span> $ Syntax_Phases.term_of_typ <span class="entity">ctxt</span> <span class="entity">T</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">coerce_tr'</span> <span class="entity">ctxt</span> <span class="main">(</span>Type<span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">[</span><span class="entity">T</span><span class="main">,</span> <span class="entity">U</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span>
    Syntax.const <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">syntax_const</span> "_coerce"<span class="antiquote">}</span></span> $
      Syntax_Phases.term_of_typ <span class="entity">ctxt</span> <span class="entity">T</span> $ Syntax_Phases.term_of_typ <span class="entity">ctxt</span> <span class="entity">U</span>
<span class="keyword2"><span class="keyword">in</span></span>
  <span class="main">[</span><span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_syntax</span> emb<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">emb_tr'</span><span class="main">)</span><span class="main">,</span>
   <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_syntax</span> prj<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">prj_tr'</span><span class="main">)</span><span class="main">,</span>
   <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_syntax</span> coerce<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">coerce_tr'</span><span class="main">)</span><span class="main">]</span>
<span class="keyword2"><span class="keyword">end</span></span>
›</span>

<span class="keyword1" id="Coerce-beta_coerce"><span class="command">lemma</span></span> beta_coerce<span class="main">:</span> <span class="quoted"><span class="quoted">"coerce<span class="main">⋅</span><span class="free">x</span> <span class="main">=</span> prj<span class="main">⋅</span><span class="main">(</span>emb<span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> coerce_def<span class="main">)</span>

<span class="keyword1" id="Coerce-prj_emb"><span class="command">lemma</span></span> prj_emb<span class="main">:</span> <span class="quoted"><span class="quoted">"prj<span class="main">⋅</span><span class="main">(</span>emb<span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> coerce<span class="main">⋅</span><span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> coerce_def<span class="main">)</span>

<span class="keyword1" id="Coerce-coerce_strict"><span class="command">lemma</span></span> coerce_strict <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"coerce<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> coerce_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Certain type instances of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>coerce›</span></span></span></span> may reduce to the
identity function, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>emb›</span></span></span></span>, or <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>prj›</span></span></span></span>. \medskip›</span></span>

<span class="keyword1" id="Coerce-coerce_eq_ID"><span class="command">lemma</span></span> coerce_eq_ID <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">COERCE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">=</span> ID"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> beta_coerce<span class="main">)</span>

<span class="keyword1" id="Coerce-coerce_eq_emb"><span class="command">lemma</span></span> coerce_eq_emb <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">COERCE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> udom<span class="main">)</span> <span class="main">=</span> <span class="keyword1">EMB</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> beta_coerce<span class="main">)</span>

<span class="keyword1" id="Coerce-coerce_eq_prj"><span class="command">lemma</span></span> coerce_eq_prj <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">COERCE</span><span class="main">(</span>udom<span class="main">,</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">PRJ</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> beta_coerce<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">"Cancellation rules"</span></span>

<span class="keyword1" id="Coerce-emb_coerce"><span class="command">lemma</span></span> emb_coerce<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="keyword1">DEFL</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">⊑</span> <span class="keyword1">DEFL</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span>
   <span class="main">⟹</span> <span class="keyword1">EMB</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">COERCE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span><span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">EMB</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span><span class="main">⋅</span><span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> beta_coerce emb_prj_emb<span class="main">)</span>

<span class="keyword1" id="Coerce-coerce_prj"><span class="command">lemma</span></span> coerce_prj<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="keyword1">DEFL</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">⊑</span> <span class="keyword1">DEFL</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span>
   <span class="main">⟹</span> <span class="keyword1">COERCE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">,</span><span class="tfree">'a</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">PRJ</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span><span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">PRJ</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span><span class="main">⋅</span><span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> beta_coerce prj_emb_prj<span class="main">)</span>

<span class="keyword1" id="Coerce-coerce_idem"><span class="command">lemma</span></span> coerce_idem <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="keyword1">DEFL</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">⊑</span> <span class="keyword1">DEFL</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span>
   <span class="main">⟹</span> <span class="keyword1">COERCE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">,</span><span class="tfree">'c</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">COERCE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span><span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">COERCE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'c</span><span class="main">)</span><span class="main">⋅</span><span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> beta_coerce emb_prj_emb<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹More lemmas about emb and prj›</span></span>

<span class="keyword1" id="Coerce-prj_cast_DEFL"><span class="command">lemma</span></span> prj_cast_DEFL <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">PRJ</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>cast<span class="main">⋅</span><span class="keyword1">DEFL</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span><span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">PRJ</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span><span class="main">⋅</span><span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cast_DEFL<span class="main">)</span>

<span class="keyword1" id="Coerce-cast_DEFL_emb"><span class="command">lemma</span></span> cast_DEFL_emb <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"cast<span class="main">⋅</span><span class="keyword1">DEFL</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">EMB</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span><span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">EMB</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span><span class="main">⋅</span><span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cast_DEFL<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1">DEFL</span></span><span class="main"><span class="main">(</span></span>udom<span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1" id="Coerce-below_DEFL_udom"><span class="command">lemma</span></span> below_DEFL_udom <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊑</span> <span class="keyword1">DEFL</span><span class="main">(</span>udom<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cast_below_imp_below<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cast.belowI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cast_DEFL<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Coercing various datatypes›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Coercing from the strict product type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> <span class="main"><span class="main">⊗</span></span> <span class="tfree"><span class="tfree">'b</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to
another strict product type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'c</span></span> <span class="main"><span class="main">⊗</span></span> <span class="tfree"><span class="tfree">'d</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is equivalent to mapping
the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>coerce›</span></span></span></span> function separately over each component using
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>sprod_map :: ('a → 'c) → ('b → 'd) → 'a ⊗ 'b → 'c ⊗ 'd›</span></span></span></span>. Each
of the several type constructors defined in HOLCF satisfies a similar
property, with respect to its own map combinator. \medskip›</span></span>

<span class="keyword1" id="Coerce-coerce_u"><span class="command">lemma</span></span> coerce_u<span class="main">:</span> <span class="quoted"><span class="quoted">"coerce <span class="main">=</span> u_map<span class="main">⋅</span>coerce"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> coerce_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> emb_u_def prj_u_def liftemb_eq liftprj_eq<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> ep_pair.e_inverse <span class="main"><span class="main">[</span></span><span class="operator">OF</span> ep_pair_u<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> u_map_map cfcomp1<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Coerce-coerce_sfun"><span class="command">lemma</span></span> coerce_sfun<span class="main">:</span> <span class="quoted"><span class="quoted">"coerce <span class="main">=</span> sfun_map<span class="main">⋅</span>coerce<span class="main">⋅</span>coerce"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> coerce_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> emb_sfun_def prj_sfun_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> ep_pair.e_inverse <span class="main"><span class="main">[</span></span><span class="operator">OF</span> ep_pair_sfun<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sfun_map_map cfcomp1<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Coerce-coerce_cfun'"><span class="command">lemma</span></span> coerce_cfun'<span class="main">:</span> <span class="quoted"><span class="quoted">"coerce <span class="main">=</span> cfun_map<span class="main">⋅</span>coerce<span class="main">⋅</span>coerce"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> prj_emb <span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> emb_cfun_def prj_cfun_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> prj_emb coerce_sfun coerce_u<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> encode_cfun_map <span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Coerce-coerce_ssum"><span class="command">lemma</span></span> coerce_ssum<span class="main">:</span> <span class="quoted"><span class="quoted">"coerce <span class="main">=</span> ssum_map<span class="main">⋅</span>coerce<span class="main">⋅</span>coerce"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> coerce_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> emb_ssum_def prj_ssum_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> ep_pair.e_inverse <span class="main"><span class="main">[</span></span><span class="operator">OF</span> ep_pair_ssum<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ssum_map_map cfcomp1<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Coerce-coerce_sprod"><span class="command">lemma</span></span> coerce_sprod<span class="main">:</span> <span class="quoted"><span class="quoted">"coerce <span class="main">=</span> sprod_map<span class="main">⋅</span>coerce<span class="main">⋅</span>coerce"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> coerce_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> emb_sprod_def prj_sprod_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> ep_pair.e_inverse <span class="main"><span class="main">[</span></span><span class="operator">OF</span> ep_pair_sprod<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sprod_map_map cfcomp1<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Coerce-coerce_prod"><span class="command">lemma</span></span> coerce_prod<span class="main">:</span> <span class="quoted"><span class="quoted">"coerce <span class="main">=</span> prod_map<span class="main">⋅</span>coerce<span class="main">⋅</span>coerce"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> coerce_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> emb_prod_def prj_prod_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> ep_pair.e_inverse <span class="main"><span class="main">[</span></span><span class="operator">OF</span> ep_pair_prod<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> prod_map_map cfcomp1<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Simplifying coercions›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹When simplifying applications of the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>coerce›</span></span></span></span> function,
rewrite rules are always oriented to replace <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>coerce›</span></span></span></span> at complex
types with other applications of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>coerce›</span></span></span></span> at simpler types.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The safest rewrite rules for <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>coerce›</span></span></span></span> are given the
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>[simp]›</span></span></span></span> attribute. For other rules that do not belong in the
global simpset, we use dynamic theorem list called <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>coerce_simp›</span></span></span></span>,
which will collect additional rules for simplifying coercions. \medskip›</span></span>

<span class="keyword1"><span class="command">named_theorems</span></span> coerce_simp <span class="quoted">"rule for simplifying coercions"</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>coerce›</span></span></span></span> function commutes with data constructors
for various HOLCF datatypes. \medskip›</span></span>

<span class="keyword1" id="Coerce-coerce_up"><span class="command">lemma</span></span> coerce_up <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"coerce<span class="main">⋅</span><span class="main">(</span>up<span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> up<span class="main">⋅</span><span class="main">(</span>coerce<span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> coerce_u<span class="main">)</span>

<span class="keyword1" id="Coerce-coerce_sinl"><span class="command">lemma</span></span> coerce_sinl <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"coerce<span class="main">⋅</span><span class="main">(</span>sinl<span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> sinl<span class="main">⋅</span><span class="main">(</span>coerce<span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> coerce_ssum ssum_map_sinl'<span class="main">)</span>

<span class="keyword1" id="Coerce-coerce_sinr"><span class="command">lemma</span></span> coerce_sinr <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"coerce<span class="main">⋅</span><span class="main">(</span>sinr<span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> sinr<span class="main">⋅</span><span class="main">(</span>coerce<span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> coerce_ssum ssum_map_sinr'<span class="main">)</span>

<span class="keyword1" id="Coerce-coerce_spair"><span class="command">lemma</span></span> coerce_spair <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"coerce<span class="main">⋅</span><span class="main">(:</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">:)</span> <span class="main">=</span> <span class="main">(:</span>coerce<span class="main">⋅</span><span class="free">x</span><span class="main">,</span> coerce<span class="main">⋅</span><span class="free">y</span><span class="main">:)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> coerce_sprod sprod_map_spair'<span class="main">)</span>

<span class="keyword1" id="Coerce-coerce_Pair"><span class="command">lemma</span></span> coerce_Pair <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"coerce<span class="main">⋅</span><span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>coerce<span class="main">⋅</span><span class="free">x</span><span class="main">,</span> coerce<span class="main">⋅</span><span class="free">y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> coerce_prod<span class="main">)</span>

<span class="keyword1" id="Coerce-beta_coerce_cfun"><span class="command">lemma</span></span> beta_coerce_cfun <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"coerce<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">x</span> <span class="main">=</span> coerce<span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span>coerce<span class="main">⋅</span><span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> coerce_cfun'<span class="main">)</span>

<span class="keyword1" id="Coerce-coerce_cfun"><span class="command">lemma</span></span> coerce_cfun<span class="main">:</span> <span class="quoted"><span class="quoted">"coerce<span class="main">⋅</span><span class="free">f</span> <span class="main">=</span> coerce <span class="keyword1">oo</span> <span class="free">f</span> <span class="keyword1">oo</span> coerce"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cfun_eqI<span class="main">)</span>

<span class="keyword1" id="Coerce-coerce_cfun_app"><span class="command">lemma</span></span> coerce_cfun_app <span class="main">[</span><span class="operator">coerce_simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"coerce<span class="main">⋅</span><span class="free">f</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> coerce<span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span>coerce<span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cfun_eqI<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Functor">
<div class="head">
<h1>Theory Functor</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Functor Class›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Functor
<span class="keyword2"><span class="keyword">imports</span></span> <a href="TypeApp.html">TypeApp</a> <a href="Coerce.html">Coerce</a>
<span class="keyword2"><span class="keyword">keywords</span></span> <span class="quoted">"tycondef"</span> <span class="main">::</span> thy_defn <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted">"⋅"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Class definition›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Here we define the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>functor›</span></span></span></span> class, which models the
Haskell class \texttt{Functor}. For technical reasons, we split the
definition of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>functor›</span></span></span></span> into two separate classes: First, we
introduce <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>prefunctor›</span></span></span></span>, which only requires <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>fmap›</span></span></span></span> to
preserve the identity function, and not function composition.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The Haskell class \texttt{Functor f} fixes a polymorphic
function \texttt{fmap :: (a -&gt; b) -&gt; f a -&gt; f b}. Since functions in
Isabelle type classes can only mention one type variable, we have the
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>prefunctor›</span></span></span></span> class fix a function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>fmapU›</span></span></span></span> that fixes both
of the polymorphic types to be the universal domain. We will use the
coercion operator to recover a polymorphic <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>fmap›</span></span></span></span>.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The single axiom of the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>prefunctor›</span></span></span></span> class is stated in
terms of the HOLCF constant <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>isodefl›</span></span></span></span>, which relates a function
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f :: 'a → 'a›</span></span></span></span> with a deflation <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>t :: udom defl›</span></span></span></span>:
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> isodefl_def <span class="main"><span class="main">[</span></span><span class="operator"><span class="operator">of</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">f</span></span></span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">t</span></span></span></span><span class="main"><span class="main">,</span></span> <span class="operator"><span class="operator">no_vars</span></span><span class="main"><span class="main">]</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>

<span class="keyword1"><span class="command">class</span></span> prefunctor <span class="main">=</span> <span class="quoted">"tycon"</span> <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free"><span class="free"><span class="free">fmapU</span></span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>udom <span class="main">→</span> udom<span class="main">)</span> <span class="main">→</span> udom<span class="main">⋅</span><span class="tfree">'a</span> <span class="main">→</span> udom<span class="main">⋅</span><span class="tfree">'a</span><span class="main">::</span>tycon"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> isodefl_fmapU<span class="main">:</span>
    <span class="quoted"><span class="quoted">"isodefl <span class="main">(</span><span class="free">fmapU</span><span class="main">⋅</span><span class="main">(</span>cast<span class="main">⋅</span><span class="free">t</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="keyword1">TC</span><span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>tycon<span class="main">)</span><span class="main">⋅</span><span class="free">t</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>functor›</span></span></span></span> class extends <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>prefunctor›</span></span></span></span> with an
axiom stating that <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>fmapU›</span></span></span></span> preserves composition.›</span></span>

<span class="keyword1"><span class="command">class</span></span> <span class="quoted">"functor"</span> <span class="main">=</span> prefunctor <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> fmapU_fmapU <span class="main">[</span><span class="operator">coerce_simp</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">f</span> <span class="bound">g</span> <span class="main">(</span><span class="bound">xs</span><span class="main">::</span>udom<span class="main">⋅</span><span class="tfree">'a</span><span class="main">::</span>tycon<span class="main">)</span><span class="main">.</span>
      fmapU<span class="main">⋅</span><span class="bound">f</span><span class="main">⋅</span><span class="main">(</span>fmapU<span class="main">⋅</span><span class="bound">g</span><span class="main">⋅</span><span class="bound">xs</span><span class="main">)</span> <span class="main">=</span> fmapU<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="bound">f</span><span class="main">⋅</span><span class="main">(</span><span class="bound">g</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="bound">xs</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We define the polymorphic <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>fmap›</span></span></span></span> by coercion from <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>fmapU›</span></span></span></span>, then we proceed to derive the polymorphic versions of the
functor laws.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">fmap</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">→</span> <span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'f</span> <span class="main">→</span> <span class="tfree">'b</span><span class="main">⋅</span><span class="tfree">'f</span><span class="main">::</span>functor"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">fmap</span> <span class="main">=</span> coerce<span class="main">⋅</span><span class="main">(</span>fmapU <span class="main">::</span> <span class="main">_</span> <span class="main">→</span> udom<span class="main">⋅</span><span class="tfree">'f</span> <span class="main">→</span> udom<span class="main">⋅</span><span class="tfree">'f</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Polymorphic functor laws›</span></span>

<span class="keyword1" id="Functor-fmapU_eq_fmap"><span class="command">lemma</span></span> fmapU_eq_fmap<span class="main">:</span> <span class="quoted"><span class="quoted">"fmapU <span class="main">=</span> fmap"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmap_def eta_cfun<span class="main">)</span>

<span class="keyword1" id="Functor-fmap_eq_fmapU"><span class="command">lemma</span></span> fmap_eq_fmapU<span class="main">:</span> <span class="quoted"><span class="quoted">"fmap <span class="main">=</span> fmapU"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> fmapU_eq_fmap<span class="main">)</span>

<span class="keyword1" id="Functor-cast_TC"><span class="command">lemma</span></span> cast_TC<span class="main">:</span>
  <span class="quoted"><span class="quoted">"cast<span class="main">⋅</span><span class="main">(</span><span class="keyword1">TC</span><span class="main">(</span><span class="tfree">'f</span><span class="main">)</span><span class="main">⋅</span><span class="free">t</span><span class="main">)</span> <span class="main">=</span> emb <span class="keyword1">oo</span> fmapU<span class="main">⋅</span><span class="main">(</span>cast<span class="main">⋅</span><span class="free">t</span><span class="main">)</span> <span class="keyword1">oo</span> <span class="keyword1">PRJ</span><span class="main">(</span>udom<span class="main">⋅</span><span class="tfree">'f</span><span class="main">::</span>prefunctor<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> isodefl_fmapU <span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> isodefl_def<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Functor-isodefl_cast"><span class="command">lemma</span></span> isodefl_cast<span class="main">:</span> <span class="quoted"><span class="quoted">"isodefl <span class="main">(</span>cast<span class="main">⋅</span><span class="free">t</span><span class="main">)</span> <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> isodefl_def<span class="main">)</span>

<span class="keyword1" id="Functor-cast_cast_below1"><span class="command">lemma</span></span> cast_cast_below1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊑</span> <span class="free">B</span> <span class="main">⟹</span> cast<span class="main">⋅</span><span class="free">A</span><span class="main">⋅</span><span class="main">(</span>cast<span class="main">⋅</span><span class="free">B</span><span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> cast<span class="main">⋅</span><span class="free">A</span><span class="main">⋅</span><span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> deflation_below_comp1 deflation_cast monofun_cfun_arg<span class="main">)</span>

<span class="keyword1" id="Functor-cast_cast_below2"><span class="command">lemma</span></span> cast_cast_below2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">⊑</span> <span class="free">B</span> <span class="main">⟹</span> cast<span class="main">⋅</span><span class="free">B</span><span class="main">⋅</span><span class="main">(</span>cast<span class="main">⋅</span><span class="free">A</span><span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> cast<span class="main">⋅</span><span class="free">A</span><span class="main">⋅</span><span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> deflation_below_comp2 deflation_cast monofun_cfun_arg<span class="main">)</span>

<span class="keyword1" id="Functor-isodefl_fmap"><span class="command">lemma</span></span> isodefl_fmap<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"isodefl <span class="free">d</span> <span class="free">t</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"isodefl <span class="main">(</span>fmap<span class="main">⋅</span><span class="free">d</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'f</span> <span class="main">→</span> <span class="main">_</span><span class="main">)</span> <span class="main">(</span><span class="keyword1">TC</span><span class="main">(</span><span class="tfree">'f</span><span class="main">::</span>functor<span class="main">)</span><span class="main">⋅</span><span class="free">t</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> deflation_d<span class="main">:</span> <span class="quoted"><span class="quoted">"deflation <span class="free">d</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> isodefl_imp_deflation<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> cast_t<span class="main">:</span> <span class="quoted"><span class="quoted">"cast<span class="main">⋅</span><span class="free">t</span> <span class="main">=</span> emb <span class="keyword1">oo</span> <span class="free">d</span> <span class="keyword1">oo</span> prj"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> isodefl_def <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">have</span></span> t_below<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">⊑</span> <span class="keyword1">DEFL</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cast_below_imp_below<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> cast_t cast_DEFL<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cfun_below_iff deflation.below <span class="main"><span class="main">[</span></span><span class="operator">OF</span> deflation_d<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">have</span></span> fmap_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"fmap<span class="main">⋅</span><span class="free">d</span> <span class="main">=</span> <span class="keyword1">PRJ</span><span class="main">(</span><span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'f</span><span class="main">)</span> <span class="keyword1">oo</span> cast<span class="main">⋅</span><span class="main">(</span><span class="keyword1">TC</span><span class="main">(</span><span class="tfree">'f</span><span class="main">)</span><span class="main">⋅</span><span class="free">t</span><span class="main">)</span> <span class="keyword1">oo</span> emb"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmap_def coerce_cfun cast_TC cast_t prj_emb cfcomp1<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmap_eq isodefl_def cfun_eq_iff emb_prj<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> DEFL_app<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cast_cast_below1 monofun_cfun t_below<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cast_cast_below2 monofun_cfun t_below<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Functor-fmap_ID"><span class="command">lemma</span></span> fmap_ID <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"fmap<span class="main">⋅</span>ID <span class="main">=</span> ID"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> isodefl_DEFL_imp_ID<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> DEFL_app<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> isodefl_fmap<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> isodefl_ID_DEFL<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Functor-fmap_ident"><span class="command">lemma</span></span> fmap_ident <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"fmap<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> ID"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ID_def <span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Functor-coerce_coerce_eq_fmapU_cast"><span class="command">lemma</span></span> coerce_coerce_eq_fmapU_cast <span class="main">[</span><span class="operator">coerce_simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom<span class="main">⋅</span><span class="tfree">'f</span><span class="main">::</span>functor"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">COERCE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'f</span><span class="main">,</span> udom<span class="main">⋅</span><span class="tfree">'f</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">COERCE</span><span class="main">(</span>udom<span class="main">⋅</span><span class="tfree">'f</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'f</span><span class="main">)</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span> <span class="main">=</span>
    fmapU<span class="main">⋅</span><span class="main">(</span>cast<span class="main">⋅</span><span class="keyword1">DEFL</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> coerce_def emb_prj DEFL_app cast_TC<span class="main">)</span>

<span class="keyword1" id="Functor-fmap_fmap"><span class="command">lemma</span></span> fmap_fmap<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'f</span><span class="main">::</span>functor"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'b</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">→</span> <span class="tfree">'c</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span>fmap<span class="main">⋅</span><span class="free">g</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span> <span class="main">=</span> fmap<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="free">g</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> fmap_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">coerce_simp</span></span><span class="main">)</span>

<span class="keyword1" id="Functor-fmap_cfcomp"><span class="command">lemma</span></span> fmap_cfcomp<span class="main">:</span> <span class="quoted"><span class="quoted">"fmap<span class="main">⋅</span><span class="main">(</span><span class="free">f</span> <span class="keyword1">oo</span> <span class="free">g</span><span class="main">)</span> <span class="main">=</span> fmap<span class="main">⋅</span><span class="free">f</span> <span class="keyword1">oo</span> fmap<span class="main">⋅</span><span class="free">g</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cfcomp1 fmap_fmap eta_cfun<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Derived properties of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>fmap›</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Other theorems about <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>fmap›</span></span></span></span> can be derived using only
the abstract functor laws.›</span></span>

<span class="keyword1" id="Functor-deflation_fmap"><span class="command">lemma</span></span> deflation_fmap<span class="main">:</span>
  <span class="quoted"><span class="quoted">"deflation <span class="free">d</span> <span class="main">⟹</span> deflation <span class="main">(</span>fmap<span class="main">⋅</span><span class="free">d</span><span class="main">)</span>"</span></span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> deflation.intro<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmap_fmap deflation.idem eta_cfun<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"fmap<span class="main">⋅</span><span class="free">d</span><span class="main">⋅</span><span class="improper">x</span> <span class="main">⊑</span> fmap<span class="main">⋅</span>ID<span class="main">⋅</span><span class="improper">x</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> monofun_cfun_fun<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> monofun_cfun_arg<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> deflation.below_ID<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Functor-ep_pair_fmap"><span class="command">lemma</span></span> ep_pair_fmap<span class="main">:</span>
  <span class="quoted"><span class="quoted">"ep_pair <span class="free">e</span> <span class="free">p</span> <span class="main">⟹</span> ep_pair <span class="main">(</span>fmap<span class="main">⋅</span><span class="free">e</span><span class="main">)</span> <span class="main">(</span>fmap<span class="main">⋅</span><span class="free">p</span><span class="main">)</span>"</span></span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ep_pair.intro<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmap_fmap ep_pair.e_inverse<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmap_fmap<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> y<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"fmap<span class="main">⋅</span>ID<span class="main">⋅</span><span class="improper">y</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> below_trans<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> monofun_cfun_fun<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> monofun_cfun_arg<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_belowI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> ep_pair.e_p_below<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Functor-fmap_strict"><span class="command">lemma</span></span> fmap_strict<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'b</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">(</span><span class="main">⊥</span><span class="main">::</span><span class="tfree">'b</span><span class="main">⋅</span><span class="tfree">'f</span><span class="main">::</span>functor<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> bottomI<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"fmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="main">⊥</span><span class="main">::</span><span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'f</span><span class="main">)</span> <span class="main">⊑</span> fmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span>fmap<span class="main">⋅</span><span class="main">⊥</span><span class="main">⋅</span><span class="main">(</span><span class="main">⊥</span><span class="main">::</span><span class="tfree">'b</span><span class="main">⋅</span><span class="tfree">'f</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> monofun_cfun<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> fmap<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="main">⊥</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="main">⊥</span><span class="main">::</span><span class="tfree">'b</span><span class="main">⋅</span><span class="tfree">'f</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmap_fmap<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">⊑</span> fmap<span class="main">⋅</span>ID<span class="main">⋅</span><span class="main">⊥</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> monofun_cfun assms <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> fmap_ID<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"fmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">⊑</span> <span class="main">(</span><span class="main">⊥</span><span class="main">::</span><span class="tfree">'b</span><span class="main">⋅</span><span class="tfree">'f</span><span class="main">::</span>functor<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Proving that <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>fmap⋅coerce = coerce›</span></span></span></span>›</span></span>

<span class="keyword1" id="Functor-fmapU_cast_eq"><span class="command">lemma</span></span> fmapU_cast_eq<span class="main">:</span>
  <span class="quoted"><span class="quoted">"fmapU<span class="main">⋅</span><span class="main">(</span>cast<span class="main">⋅</span><span class="free">A</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword1">PRJ</span><span class="main">(</span>udom<span class="main">⋅</span><span class="tfree">'f</span><span class="main">)</span> <span class="keyword1">oo</span> cast<span class="main">⋅</span><span class="main">(</span><span class="keyword1">TC</span><span class="main">(</span><span class="tfree">'f</span><span class="main">::</span>functor<span class="main">)</span><span class="main">⋅</span><span class="free">A</span><span class="main">)</span> <span class="keyword1">oo</span> emb"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> cast_TC<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="Functor-fmapU_cast_DEFL"><span class="command">lemma</span></span> fmapU_cast_DEFL<span class="main">:</span>
  <span class="quoted"><span class="quoted">"fmapU<span class="main">⋅</span><span class="main">(</span>cast<span class="main">⋅</span><span class="keyword1">DEFL</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword1">PRJ</span><span class="main">(</span>udom<span class="main">⋅</span><span class="tfree">'f</span><span class="main">)</span> <span class="keyword1">oo</span> cast<span class="main">⋅</span><span class="keyword1">DEFL</span><span class="main">(</span><span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'f</span><span class="main">::</span>functor<span class="main">)</span> <span class="keyword1">oo</span> emb"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmapU_cast_eq DEFL_app<span class="main">)</span>

<span class="keyword1" id="Functor-coerce_functor"><span class="command">lemma</span></span> coerce_functor<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">COERCE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'f</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">⋅</span><span class="tfree">'f</span><span class="main">::</span>functor<span class="main">)</span> <span class="main">=</span> fmap<span class="main">⋅</span>coerce"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">rename_tac</span> xs<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmap_def coerce_cfun<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> coerce_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cfcomp1<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> emb_prj<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> fmapU_fmapU <span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmapU_cast_DEFL<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> emb_prj<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cast_cast_below1 cast_cast_below2<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Lemmas for reasoning about coercion›</span></span>

<span class="keyword1" id="Functor-fmapU_cast_coerce"><span class="command">lemma</span></span> fmapU_cast_coerce <span class="main">[</span><span class="operator">coerce_simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">m</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'f</span><span class="main">::</span>functor"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fmapU<span class="main">⋅</span><span class="main">(</span>cast<span class="main">⋅</span><span class="keyword1">DEFL</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">COERCE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'f</span><span class="main">,</span> udom<span class="main">⋅</span><span class="tfree">'f</span><span class="main">)</span><span class="main">⋅</span><span class="free">m</span><span class="main">)</span> <span class="main">=</span>
    <span class="keyword1">COERCE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'f</span><span class="main">,</span> udom<span class="main">⋅</span><span class="tfree">'f</span><span class="main">)</span><span class="main">⋅</span><span class="free">m</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> coerce_functor cast_DEFL fmapU_eq_fmap fmap_fmap eta_cfun<span class="main">)</span>

<span class="keyword1" id="Functor-coerce_fmap"><span class="command">lemma</span></span> coerce_fmap <span class="main">[</span><span class="operator">coerce_simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'f</span><span class="main">::</span>functor"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'b</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">COERCE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">⋅</span><span class="tfree">'f</span><span class="main">,</span> <span class="tfree">'c</span><span class="main">⋅</span><span class="tfree">'f</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>fmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span> <span class="main">=</span> fmap<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="keyword1">COERCE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">,</span><span class="tfree">'c</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> coerce_functor fmap_fmap<span class="main">)</span>

<span class="keyword1" id="Functor-fmap_coerce"><span class="command">lemma</span></span> fmap_coerce <span class="main">[</span><span class="operator">coerce_simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'f</span><span class="main">::</span>functor"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">→</span> <span class="tfree">'c</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">COERCE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'f</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">⋅</span><span class="tfree">'f</span><span class="main">)</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span> <span class="main">=</span> fmap<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">COERCE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> coerce_functor fmap_fmap<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Configuration of Domain package›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We make various theorem declarations to enable Domain
  package definitions that involve <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>tycon›</span></span></span></span> application.›</span></span>

<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">Domain_Take_Proofs.add_rec_type</span> <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_name</span> app<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">[</span>true<span class="main">,</span> false<span class="main">]</span><span class="main">)</span>›</span>

<span class="keyword1"><span class="command">declare</span></span> DEFL_app <span class="main">[</span><span class="operator">domain_defl_simps</span><span class="main">]</span>
<span class="keyword1"><span class="command">declare</span></span> fmap_ID <span class="main">[</span><span class="operator">domain_map_ID</span><span class="main">]</span>
<span class="keyword1"><span class="command">declare</span></span> deflation_fmap <span class="main">[</span><span class="operator">domain_deflation</span><span class="main">]</span>
<span class="keyword1"><span class="command">declare</span></span> isodefl_fmap <span class="main">[</span><span class="operator">domain_isodefl</span><span class="main">]</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Configuration of the Tycon package›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We now set up a new type definition command, which is used for
  defining new <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>tycon›</span></span></span></span> instances. The <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>tycondef›</span></span></span></span> command
  is implemented using much of the same code as the Domain package,
  and supports a similar input syntax. It automatically generates a
  <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>prefunctor›</span></span></span></span> instance for each new type. (The user must
  provide a proof of the composition law to obtain a <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>functor›</span></span></span></span>
  class instance.)›</span></span>

<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹tycondef.ML›</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="files/tycondef.ML">
<div class="head">
<h1>File ‹tycondef.ML›</h1>
</div>
<pre class="source"><span class="comment1">(* Version: Isabelle2012 *)</span>

<span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">TYCON</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> add_tycon_cmd<span class="main">:</span>
      <span class="main">(</span>string * <span class="main">(</span>string * string option<span class="main">)</span> list * binding * mixfix *
       <span class="main">(</span>binding * <span class="main">(</span>bool * binding option * string<span class="main">)</span> list * mixfix<span class="main">)</span> list<span class="main">)</span> list
      <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory

  <span class="keyword1"><span class="keyword">val</span></span> add_tycon<span class="main">:</span>
      <span class="main">(</span>string * <span class="main">(</span>string * sort<span class="main">)</span> list * binding * mixfix *
       <span class="main">(</span>binding * <span class="main">(</span>bool * binding option * typ<span class="main">)</span> list * mixfix<span class="main">)</span> list<span class="main">)</span> list
      <span class="main">-&gt;</span> theory <span class="main">-&gt;</span> theory
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Tycon</span> <span class="main">:</span> <span class="entity">TYCON</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">TC_simp</span> <span class="main">=</span>
  <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">lemma</span> <span class="quoted">"<span class="free">f</span> <span class="main">≡</span> <span class="free">g</span> <span class="main">⟹</span> <span class="free">f</span> <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">::</span><span class="main">{}</span><span class="main">)</span> <span class="main">=</span> <span class="free">g</span> <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span>"</span> <span class="keyword1"><span class="keyword">by</span></span> <span class="operator">simp</span><span class="antiquote">}</span></span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_appT</span> <span class="entity">T</span> <span class="entity">U</span> <span class="main">=</span> Type <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_name</span> app<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">[</span><span class="entity">T</span><span class="main">,</span> <span class="entity">U</span><span class="main">]</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_appT</span> <span class="main">(</span>Type <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_name</span> app<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">[</span><span class="entity">T</span><span class="main">,</span> <span class="entity">U</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">T</span><span class="main">,</span> <span class="entity">U</span><span class="main">)</span>
  <span class="main">|</span> <span class="entity">dest_appT</span> <span class="entity">T</span> <span class="main">=</span> <span class="keyword3"><span class="keyword">raise</span></span> TYPE <span class="main">(</span><span class="inner_quoted">"dest_appT"</span><span class="main">,</span> <span class="main">[</span><span class="entity">T</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>

<span class="keyword3"><span class="keyword">open</span></span> HOLCF_Library

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">first</span>  <span class="main">(</span><span class="entity">x</span><span class="main">,</span><span class="main">_</span><span class="main">,</span><span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">x</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">second</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span><span class="entity">x</span><span class="main">,</span><span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">x</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">beta_ss</span> <span class="main">=</span>
  simpset_of <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span>
    addsimps <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> simp_thms<span class="antiquote">}</span></span></span> addsimprocs <span class="main">[</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">simproc</span> beta_cfun_proc<span class="antiquote">}</span></span></span><span class="main">]</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_cpo</span> <span class="entity">thy</span> <span class="entity">T</span> <span class="main">=</span> Sign.of_sort <span class="entity">thy</span> <span class="main">(</span><span class="entity">T</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">cpo</span><span class="antiquote">}</span></span><span class="main">)</span>

<span class="comment1">(******************************************************************************)</span>
<span class="comment1">(****************************** defining tycons *******************************)</span>
<span class="comment1">(******************************************************************************)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">define_singleton_type</span>
    <span class="main">(</span><span class="entity">typ</span> <span class="main">:</span> binding * <span class="main">(</span>string * sort<span class="main">)</span> list * mixfix<span class="main">)</span>
    <span class="main">(</span><span class="entity">thy</span> <span class="main">:</span> theory<span class="main">)</span> <span class="main">:</span> <span class="main">(</span>string * <span class="entity">Typedef.info</span><span class="main">)</span> * theory <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">set</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"UNIV <span class="main">::</span> unit set"</span><span class="antiquote">}</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">opt_morphs</span> <span class="main">=</span> NONE
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">tac</span> <span class="entity">ctxt</span> <span class="main">=</span> resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">UNIV_witness</span><span class="main">]</span> <span class="inner_numeral">1</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> writeln <span class="main">(</span><span class="inner_quoted">"Defining type "</span> ^ Binding.print <span class="main">(</span><span class="entity">first</span> <span class="entity">typ</span><span class="main">)</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">thy</span>
    |&gt; <span class="entity">Named_Target.theory_map_result</span> <span class="main">(</span>apsnd o <span class="entity">Typedef.transform_info</span><span class="main">)</span>
      <span class="main">(</span><span class="entity">Typedef.add_typedef</span> <span class="main">{</span>overloaded <span class="main">=</span> false<span class="main">}</span> <span class="entity">typ</span> <span class="entity">set</span> <span class="entity">opt_morphs</span> <span class="entity">tac</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>    

<span class="comment1">(******************************************************************************)</span>
<span class="comment1">(************************** building types and terms **************************)</span>
<span class="comment1">(******************************************************************************)</span>

<span class="keyword1"><span class="keyword">infixr</span></span> <span class="inner_numeral">6</span> -&gt;&gt;
<span class="keyword1"><span class="keyword">infixr</span></span> --&gt;&gt;

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">udomT</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">udom</span><span class="antiquote">}</span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">deflT</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"udom defl"</span><span class="antiquote">}</span></span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">udeflT</span> <span class="main">=</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"udom u defl"</span><span class="antiquote">}</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_DEFL</span> <span class="entity">T</span> <span class="main">=</span>
  Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> defl<span class="antiquote">}</span></span><span class="main">,</span> Term.itselfT <span class="entity">T</span> --&gt; <span class="entity">deflT</span><span class="main">)</span> $ Logic.mk_type <span class="entity">T</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_DEFL</span> <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> defl<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="entity">t</span><span class="main">)</span> <span class="main">=</span> Logic.dest_type <span class="entity">t</span>
  <span class="main">|</span> <span class="entity">dest_DEFL</span> <span class="entity">t</span> <span class="main">=</span> <span class="keyword3"><span class="keyword">raise</span></span> TERM <span class="main">(</span><span class="inner_quoted">"dest_DEFL"</span><span class="main">,</span> <span class="main">[</span><span class="entity">t</span><span class="main">]</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_LIFTDEFL</span> <span class="entity">T</span> <span class="main">=</span>
  Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> liftdefl<span class="antiquote">}</span></span><span class="main">,</span> Term.itselfT <span class="entity">T</span> --&gt; <span class="entity">udeflT</span><span class="main">)</span> $ Logic.mk_type <span class="entity">T</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_LIFTDEFL</span> <span class="main">(</span>Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> liftdefl<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="entity">t</span><span class="main">)</span> <span class="main">=</span> Logic.dest_type <span class="entity">t</span>
  <span class="main">|</span> <span class="entity">dest_LIFTDEFL</span> <span class="entity">t</span> <span class="main">=</span> <span class="keyword3"><span class="keyword">raise</span></span> TERM <span class="main">(</span><span class="inner_quoted">"dest_LIFTDEFL"</span><span class="main">,</span> <span class="main">[</span><span class="entity">t</span><span class="main">]</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">tc_const</span> <span class="entity">T</span> <span class="main">=</span>
  Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> tc<span class="antiquote">}</span></span><span class="main">,</span> Term.itselfT <span class="entity">T</span> --&gt; <span class="entity">deflT</span> <span class="entity">-&gt;&gt;</span> <span class="entity">deflT</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_TC</span> <span class="entity">T</span> <span class="main">=</span> <span class="entity">tc_const</span> <span class="entity">T</span> $ Logic.mk_type <span class="entity">T</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">argumentTs</span> <span class="main">(</span>Type <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">type_name</span> app<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">[</span><span class="entity">T</span><span class="main">,</span> Type <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">Ts</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Ts</span> @ <span class="main">[</span><span class="entity">T</span><span class="main">]</span>
  <span class="main">|</span> <span class="entity">argumentTs</span> <span class="main">(</span>Type <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">Ts</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="entity">Ts</span>
  <span class="main">|</span> <span class="entity">argumentTs</span> <span class="entity">T</span> <span class="main">=</span> <span class="main">[</span><span class="main">]</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_u_defl</span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">mk_capply</span> <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> "u_defl"<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">emb_const</span> <span class="entity">T</span> <span class="main">=</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> emb<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">T</span> <span class="entity">-&gt;&gt;</span> <span class="entity">udomT</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prj_const</span> <span class="entity">T</span> <span class="main">=</span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> prj<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">udomT</span> <span class="entity">-&gt;&gt;</span> <span class="entity">T</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">coerce_const</span> <span class="main">(</span><span class="entity">T</span><span class="main">,</span> <span class="entity">U</span><span class="main">)</span> <span class="main">=</span> <span class="entity">mk_cfcomp</span> <span class="main">(</span><span class="entity">prj_const</span> <span class="entity">U</span><span class="main">,</span> <span class="entity">emb_const</span> <span class="entity">T</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">isodefl_const</span> <span class="entity">T</span> <span class="main">=</span>
  Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> isodefl<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">(</span><span class="entity">T</span> <span class="entity">-&gt;&gt;</span> <span class="entity">T</span><span class="main">)</span> --&gt; <span class="entity">deflT</span> --&gt; <span class="entity">HOLogic.boolT</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">isodefl'_const</span> <span class="entity">T</span> <span class="main">=</span>
  Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> isodefl'<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">(</span><span class="entity">T</span> <span class="entity">-&gt;&gt;</span> <span class="entity">T</span><span class="main">)</span> --&gt; <span class="entity">udeflT</span> --&gt; <span class="entity">HOLogic.boolT</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_deflation</span> <span class="entity">t</span> <span class="main">=</span>
  Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> deflation<span class="antiquote">}</span></span><span class="main">,</span> Term.fastype_of <span class="entity">t</span> --&gt; <span class="entity">boolT</span><span class="main">)</span> $ <span class="entity">t</span>

<span class="comment1">(* splits a cterm into the right and lefthand sides of equality *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">dest_eqs</span> <span class="entity">t</span> <span class="main">=</span> <span class="entity">HOLogic.dest_eq</span> <span class="main">(</span><span class="entity">HOLogic.dest_Trueprop</span> <span class="entity">t</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_eqs</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">u</span><span class="main">)</span> <span class="main">=</span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">u</span><span class="main">)</span><span class="main">)</span>

<span class="comment1">(******************************************************************************)</span>
<span class="comment1">(****************************** isomorphism info ******************************)</span>
<span class="comment1">(******************************************************************************)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">deflation_abs_rep</span> <span class="main">(</span><span class="entity">info</span> <span class="main">:</span> <span class="entity">Domain_Take_Proofs.iso_info</span><span class="main">)</span> <span class="main">:</span> thm <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">abs_iso</span> <span class="main">=</span> <span class="main">#</span>abs_inverse <span class="entity">info</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rep_iso</span> <span class="main">=</span> <span class="main">#</span>rep_inverse <span class="entity">info</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> deflation_abs_rep<span class="antiquote">}</span></span></span> OF <span class="main">[</span><span class="entity">abs_iso</span><span class="main">,</span> <span class="entity">rep_iso</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    Drule.zero_var_indexes <span class="entity">thm</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(******************************************************************************)</span>
<span class="comment1">(*************** fixed-point definitions and unfolding theorems ***************)</span>
<span class="comment1">(******************************************************************************)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_projs</span> <span class="main">[</span><span class="main">]</span>      <span class="main">_</span> <span class="main">=</span> <span class="main">[</span><span class="main">]</span>
  <span class="main">|</span> <span class="entity">mk_projs</span> <span class="main">(</span><span class="entity">x</span>::<span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="entity">t</span> <span class="main">=</span> <span class="main">[</span><span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">]</span>
  <span class="main">|</span> <span class="entity">mk_projs</span> <span class="main">(</span><span class="entity">x</span>::<span class="entity">xs</span><span class="main">)</span> <span class="entity">t</span> <span class="main">=</span> <span class="main">(</span><span class="entity">x</span><span class="main">,</span> <span class="entity">mk_fst</span> <span class="entity">t</span><span class="main">)</span> :: <span class="entity">mk_projs</span> <span class="entity">xs</span> <span class="main">(</span><span class="entity">mk_snd</span> <span class="entity">t</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_fixdefs</span>
    <span class="main">(</span><span class="entity">spec</span> <span class="main">:</span> <span class="main">(</span>binding * term<span class="main">)</span> list<span class="main">)</span>
    <span class="main">(</span><span class="entity">thy</span> <span class="main">:</span> theory<span class="main">)</span> <span class="main">:</span> <span class="main">(</span>thm list * thm list * thm<span class="main">)</span> * theory <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">binds</span> <span class="main">=</span> map fst <span class="entity">spec</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lhss</span><span class="main">,</span> <span class="entity">rhss</span><span class="main">)</span> <span class="main">=</span> ListPair.unzip <span class="main">(</span>map <span class="main">(</span><span class="entity">dest_eqs</span> o snd<span class="main">)</span> <span class="entity">spec</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">functional</span> <span class="main">=</span> <span class="entity">lambda_tuple</span> <span class="entity">lhss</span> <span class="main">(</span><span class="entity">mk_tuple</span> <span class="entity">rhss</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fixpoint</span> <span class="main">=</span> <span class="entity">mk_fix</span> <span class="main">(</span><span class="entity">mk_cabs</span> <span class="entity">functional</span><span class="main">)</span>

    <span class="comment1">(* project components of fixpoint *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">projs</span> <span class="main">=</span> <span class="entity">mk_projs</span> <span class="entity">lhss</span> <span class="entity">fixpoint</span>

    <span class="comment1">(* convert parameters to lambda abstractions *)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_eqn</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="main">=</span>
        <span class="keyword2"><span class="keyword">case</span></span> <span class="entity">lhs</span> <span class="keyword2"><span class="keyword">of</span></span>
          Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Rep_cfun<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> $ <span class="entity">f</span> $ <span class="main">(</span><span class="entity">x</span> <span class="keyword1"><span class="keyword">as</span></span> Free <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span>
            <span class="entity">mk_eqn</span> <span class="main">(</span><span class="entity">f</span><span class="main">,</span> <span class="entity">big_lambda</span> <span class="entity">x</span> <span class="entity">rhs</span><span class="main">)</span>
        <span class="main">|</span> <span class="entity">f</span> $ Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> Pure.type<span class="antiquote">}</span></span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="main">=&gt;</span>
            <span class="entity">mk_eqn</span> <span class="main">(</span><span class="entity">f</span><span class="main">,</span> Abs <span class="main">(</span><span class="inner_quoted">"t"</span><span class="main">,</span> <span class="entity">T</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span><span class="main">)</span>
        <span class="main">|</span> Const <span class="main">_</span> <span class="main">=&gt;</span> Logic.mk_equals <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span>
        <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> <span class="keyword3"><span class="keyword">raise</span></span> TERM <span class="main">(</span><span class="inner_quoted">"lhs not of correct form"</span><span class="main">,</span> <span class="main">[</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">]</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eqns</span> <span class="main">=</span> map <span class="entity">mk_eqn</span> <span class="entity">projs</span>

    <span class="comment1">(* register constant definitions *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">fixdef_thms</span><span class="main">,</span> <span class="entity">thy</span><span class="main">)</span> <span class="main">=</span>
      <span class="main">(</span>Global_Theory.add_defs false o map Thm.no_attributes<span class="main">)</span>
        <span class="main">(</span>map <span class="main">(</span>Binding.suffix_name <span class="inner_quoted">"_def"</span><span class="main">)</span> <span class="entity">binds</span> ~~ <span class="entity">eqns</span><span class="main">)</span> <span class="entity">thy</span>

    <span class="comment1">(* prove applied version of definitions *)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prove_proj</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">tac</span> <span class="entity">ctxt</span> <span class="main">=</span> rewrite_goals_tac <span class="entity">ctxt</span> <span class="entity">fixdef_thms</span> THEN
          <span class="entity">simp_tac</span> <span class="main">(</span>put_simpset <span class="entity">beta_ss</span> <span class="entity">ctxt</span><span class="main">)</span> <span class="inner_numeral">1</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goal</span> <span class="main">=</span> Logic.mk_equals <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span> Goal.prove_global <span class="entity">thy</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">goal</span> <span class="main">(</span><span class="entity">tac</span> o <span class="main">#</span>context<span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">proj_thms</span> <span class="main">=</span> map <span class="entity">prove_proj</span> <span class="entity">projs</span>

    <span class="comment1">(* mk_tuple lhss == fixpoint *)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">pair_equalI</span> <span class="main">(</span><span class="entity">thm1</span><span class="main">,</span> <span class="entity">thm2</span><span class="main">)</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Pair_equalI<span class="antiquote">}</span></span></span> OF <span class="main">[</span><span class="entity">thm1</span><span class="main">,</span> <span class="entity">thm2</span><span class="main">]</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tuple_fixdef_thm</span> <span class="main">=</span> foldr1 <span class="entity">pair_equalI</span> <span class="entity">proj_thms</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cont_thm</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt</span> <span class="main">=</span> Proof_Context.init_global <span class="entity">thy</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prop</span> <span class="main">=</span> <span class="entity">mk_trp</span> <span class="main">(</span><span class="entity">mk_cont</span> <span class="entity">functional</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rules</span> <span class="main">=</span> <span class="entity">Named_Theorems.get</span> <span class="entity">ctxt</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">named_theorems</span> cont2cont<span class="antiquote">}</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tac</span> <span class="main">=</span> REPEAT_ALL_NEW <span class="main">(</span>match_tac <span class="entity">ctxt</span> <span class="main">(</span>rev <span class="entity">rules</span><span class="main">)</span><span class="main">)</span> <span class="inner_numeral">1</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        Goal.prove_global <span class="entity">thy</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">prop</span> <span class="main">(</span>K <span class="entity">tac</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tuple_unfold_thm</span> <span class="main">=</span>
      <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> def_cont_fix_eq<span class="antiquote">}</span></span></span> OF <span class="main">[</span><span class="entity">tuple_fixdef_thm</span><span class="main">,</span> <span class="entity">cont_thm</span><span class="main">]</span><span class="main">)</span>
      |&gt; Local_Defs.unfold <span class="main">(</span>Proof_Context.init_global <span class="entity">thy</span><span class="main">)</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> split_conv<span class="antiquote">}</span></span></span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_unfold_thms</span> <span class="main">[</span><span class="main">]</span> <span class="main">_</span> <span class="main">=</span> <span class="main">[</span><span class="main">]</span>
      <span class="main">|</span> <span class="entity">mk_unfold_thms</span> <span class="main">(</span><span class="entity">n</span>::<span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="entity">thm</span> <span class="main">=</span> <span class="main">[</span><span class="main">(</span><span class="entity">n</span><span class="main">,</span> <span class="entity">thm</span><span class="main">)</span><span class="main">]</span>
      <span class="main">|</span> <span class="entity">mk_unfold_thms</span> <span class="main">(</span><span class="entity">n</span>::<span class="entity">ns</span><span class="main">)</span> <span class="entity">thm</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thmL</span> <span class="main">=</span> <span class="entity">thm</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Pair_eqD1<span class="antiquote">}</span></span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thmR</span> <span class="main">=</span> <span class="entity">thm</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Pair_eqD2<span class="antiquote">}</span></span></span>
        <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">n</span><span class="main">,</span> <span class="entity">thmL</span><span class="main">)</span> :: <span class="entity">mk_unfold_thms</span> <span class="entity">ns</span> <span class="entity">thmR</span> <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">unfold_binds</span> <span class="main">=</span> map <span class="main">(</span>Binding.suffix_name <span class="inner_quoted">"_unfold"</span><span class="main">)</span> <span class="entity">binds</span>

    <span class="comment1">(* register unfold theorems *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">unfold_thms</span><span class="main">,</span> <span class="entity">thy</span><span class="main">)</span> <span class="main">=</span>
      <span class="main">(</span>Global_Theory.add_thms o map <span class="main">(</span>Thm.no_attributes o apsnd Drule.zero_var_indexes<span class="main">)</span><span class="main">)</span>
        <span class="main">(</span><span class="entity">mk_unfold_thms</span> <span class="entity">unfold_binds</span> <span class="entity">tuple_unfold_thm</span><span class="main">)</span> <span class="entity">thy</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span><span class="main">(</span><span class="entity">proj_thms</span><span class="main">,</span> <span class="entity">unfold_thms</span><span class="main">,</span> <span class="entity">cont_thm</span><span class="main">)</span><span class="main">,</span> <span class="entity">thy</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(******************************************************************************)</span>
<span class="comment1">(****************** deflation combinators and map functions *******************)</span>
<span class="comment1">(******************************************************************************)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">defl_of_typ</span>
    <span class="main">(</span><span class="entity">thy</span> <span class="main">:</span> theory<span class="main">)</span>
    <span class="main">(</span><span class="entity">rules'</span> <span class="main">:</span> <span class="main">(</span>term * term<span class="main">)</span> list<span class="main">)</span>
    <span class="main">(</span><span class="entity">T</span> <span class="main">:</span> typ<span class="main">)</span> <span class="main">:</span> term <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">defl_simps</span> <span class="main">=</span> Global_Theory.get_thms <span class="entity">thy</span> <span class="inner_quoted">"domain_defl_simps"</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rules</span> <span class="main">=</span> map <span class="main">(</span>Thm.concl_of #&gt; <span class="entity">HOLogic.dest_Trueprop</span> #&gt; <span class="entity">HOLogic.dest_eq</span><span class="main">)</span> <span class="entity">defl_simps</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">proc1</span> <span class="entity">t</span> <span class="main">=</span>
      <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">dest_DEFL</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
        TFree <span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> SOME <span class="main">(</span>Free <span class="main">(</span><span class="inner_quoted">"d"</span> ^ Library.unprefix <span class="inner_quoted">"'"</span> <span class="entity">a</span><span class="main">,</span> <span class="entity">deflT</span><span class="main">)</span><span class="main">)</span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> NONE<span class="main">)</span> <span class="keyword3"><span class="keyword">handle</span></span> TERM <span class="main">_</span> <span class="main">=&gt;</span> NONE
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">proc2</span> <span class="entity">t</span> <span class="main">=</span>
      <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">dest_LIFTDEFL</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
        TFree <span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> SOME <span class="main">(</span>Free <span class="main">(</span><span class="inner_quoted">"p"</span> ^ Library.unprefix <span class="inner_quoted">"'"</span> <span class="entity">a</span><span class="main">,</span> <span class="entity">udeflT</span><span class="main">)</span><span class="main">)</span>
      <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> NONE<span class="main">)</span> <span class="keyword3"><span class="keyword">handle</span></span> TERM <span class="main">_</span> <span class="main">=&gt;</span> NONE
  <span class="keyword2"><span class="keyword">in</span></span>
    Pattern.rewrite_term <span class="entity">thy</span> <span class="main">(</span><span class="entity">rules</span> @ <span class="entity">rules'</span><span class="main">)</span> <span class="main">[</span><span class="entity">proc1</span><span class="main">,</span> <span class="entity">proc2</span><span class="main">]</span> <span class="main">(</span><span class="entity">mk_DEFL</span> <span class="entity">T</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(******************************************************************************)</span>
<span class="comment1">(********************* declaring definitions and theorems *********************)</span>
<span class="comment1">(******************************************************************************)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">define_const</span>
    <span class="main">(</span><span class="entity">bind</span> <span class="main">:</span> binding<span class="main">,</span> <span class="entity">rhs</span> <span class="main">:</span> term<span class="main">)</span>
    <span class="main">(</span><span class="entity">thy</span> <span class="main">:</span> theory<span class="main">)</span>
    <span class="main">:</span> <span class="main">(</span>term * thm<span class="main">)</span> * theory <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">typ</span> <span class="main">=</span> Term.fastype_of <span class="entity">rhs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">const</span><span class="main">,</span> <span class="entity">thy</span><span class="main">)</span> <span class="main">=</span> Sign.declare_const_global <span class="main">(</span><span class="main">(</span><span class="entity">bind</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span><span class="main">,</span> NoSyn<span class="main">)</span> <span class="entity">thy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">eqn</span> <span class="main">=</span> Logic.mk_equals <span class="main">(</span><span class="entity">const</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">def</span> <span class="main">=</span> Thm.no_attributes <span class="main">(</span>Binding.suffix_name <span class="inner_quoted">"_def"</span> <span class="entity">bind</span><span class="main">,</span> <span class="entity">eqn</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">def_thm</span><span class="main">,</span> <span class="entity">thy</span><span class="main">)</span> <span class="main">=</span> yield_singleton <span class="main">(</span>Global_Theory.add_defs false<span class="main">)</span> <span class="entity">def</span> <span class="entity">thy</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span><span class="main">(</span><span class="entity">const</span><span class="main">,</span> <span class="entity">def_thm</span><span class="main">)</span><span class="main">,</span> <span class="entity">thy</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_qualified_thm</span> <span class="entity">name</span> <span class="main">(</span><span class="entity">dbind</span><span class="main">,</span> <span class="entity">thm</span><span class="main">)</span> <span class="main">=</span>
    yield_singleton Global_Theory.add_thms
      <span class="main">(</span><span class="main">(</span>Binding.qualify_name true <span class="entity">dbind</span> <span class="entity">name</span><span class="main">,</span> <span class="entity">thm</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>

<span class="comment1">(******************************************************************************)</span>
<span class="comment1">(*************************** defining map functions ***************************)</span>
<span class="comment1">(******************************************************************************)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">define_map_functions</span>
    <span class="main">(</span><span class="entity">spec</span> <span class="main">:</span> <span class="main">(</span>binding * <span class="entity">Domain_Take_Proofs.iso_info</span><span class="main">)</span> list<span class="main">)</span>
    <span class="main">(</span><span class="entity">thy</span> <span class="main">:</span> theory<span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>

    <span class="comment1">(* retrieve components of spec *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dbinds</span> <span class="main">=</span> map fst <span class="entity">spec</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">iso_infos</span> <span class="main">=</span> map snd <span class="entity">spec</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dom_eqns</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">#</span>absT <span class="entity">x</span><span class="main">,</span> <span class="main">#</span>repT <span class="entity">x</span><span class="main">)</span><span class="main">)</span> <span class="entity">iso_infos</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rep_abs_consts</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">x</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">#</span>rep_const <span class="entity">x</span><span class="main">,</span> <span class="main">#</span>abs_const <span class="entity">x</span><span class="main">)</span><span class="main">)</span> <span class="entity">iso_infos</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mapT</span> <span class="entity">T</span> <span class="main">=</span>
      map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">T</span> <span class="main">=&gt;</span> <span class="entity">T</span> <span class="entity">-&gt;&gt;</span> <span class="entity">T</span><span class="main">)</span> <span class="main">(</span>filter <span class="main">(</span><span class="entity">is_cpo</span> <span class="entity">thy</span><span class="main">)</span> <span class="main">(</span><span class="entity">argumentTs</span> <span class="entity">T</span><span class="main">)</span><span class="main">)</span> <span class="entity">--&gt;&gt;</span> <span class="main">(</span><span class="entity">T</span> <span class="entity">-&gt;&gt;</span> <span class="entity">T</span><span class="main">)</span>

    <span class="comment1">(* declare map functions *)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">declare_map_const</span> <span class="main">(</span><span class="entity">tbind</span><span class="main">,</span> <span class="main">(</span><span class="entity">lhsT</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="entity">thy</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">map_type</span> <span class="main">=</span> <span class="entity">mapT</span> <span class="entity">lhsT</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">map_bind</span> <span class="main">=</span> Binding.suffix_name <span class="inner_quoted">"_map"</span> <span class="entity">tbind</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        Sign.declare_const_global <span class="main">(</span><span class="main">(</span><span class="entity">map_bind</span><span class="main">,</span> <span class="entity">map_type</span><span class="main">)</span><span class="main">,</span> NoSyn<span class="main">)</span> <span class="entity">thy</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">map_consts</span><span class="main">,</span> <span class="entity">thy</span><span class="main">)</span> <span class="main">=</span> <span class="entity">thy</span> |&gt;
      fold_map <span class="entity">declare_map_const</span> <span class="main">(</span><span class="entity">dbinds</span> ~~ <span class="entity">dom_eqns</span><span class="main">)</span>

    <span class="comment1">(* defining equations for map functions *)</span>
    <span class="keyword2"><span class="keyword">local</span></span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">unprime</span> <span class="entity">a</span> <span class="main">=</span> Library.unprefix <span class="inner_quoted">"'"</span> <span class="entity">a</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mapvar</span> <span class="entity">T</span> <span class="main">=</span> Free <span class="main">(</span><span class="entity">unprime</span> <span class="main">(</span>fst <span class="main">(</span>dest_TFree <span class="entity">T</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="entity">T</span> <span class="entity">-&gt;&gt;</span> <span class="entity">T</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">map_lhs</span> <span class="main">(</span><span class="entity">map_const</span><span class="main">,</span> <span class="entity">lhsT</span><span class="main">)</span> <span class="main">=</span>
        <span class="main">(</span><span class="entity">lhsT</span><span class="main">,</span> <span class="entity">list_ccomb</span> <span class="main">(</span><span class="entity">map_const</span><span class="main">,</span> map <span class="entity">mapvar</span> <span class="main">(</span>filter <span class="main">(</span><span class="entity">is_cpo</span> <span class="entity">thy</span><span class="main">)</span> <span class="main">(</span><span class="entity">argumentTs</span> <span class="entity">lhsT</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tab1</span> <span class="main">=</span> map <span class="entity">map_lhs</span> <span class="main">(</span><span class="entity">map_consts</span> ~~ map fst <span class="entity">dom_eqns</span><span class="main">)</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Ts</span> <span class="main">=</span> <span class="main">(</span><span class="entity">argumentTs</span> o fst o hd<span class="main">)</span> <span class="entity">dom_eqns</span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tab</span> <span class="main">=</span> <span class="main">(</span><span class="entity">Ts</span> ~~ map <span class="entity">mapvar</span> <span class="entity">Ts</span><span class="main">)</span> @ <span class="entity">tab1</span>
      <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_map_spec</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">rep_const</span><span class="main">,</span> <span class="entity">abs_const</span><span class="main">)</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">lhsT</span><span class="main">,</span> <span class="entity">rhsT</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
        <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs</span> <span class="main">=</span> <span class="entity">Domain_Take_Proofs.map_of_typ</span> <span class="entity">thy</span> <span class="entity">tab</span> <span class="entity">lhsT</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">body</span> <span class="main">=</span> <span class="entity">Domain_Take_Proofs.map_of_typ</span> <span class="entity">thy</span> <span class="entity">tab</span> <span class="entity">rhsT</span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs</span> <span class="main">=</span> <span class="entity">mk_cfcomp</span> <span class="main">(</span><span class="entity">abs_const</span><span class="main">,</span> <span class="entity">mk_cfcomp</span> <span class="main">(</span><span class="entity">body</span><span class="main">,</span> <span class="entity">rep_const</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">mk_eqs</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword2"><span class="keyword">in</span></span>
      <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">map_specs</span> <span class="main">=</span>
          map <span class="entity">mk_map_spec</span> <span class="main">(</span><span class="entity">rep_abs_consts</span> ~~ <span class="entity">map_consts</span> ~~ <span class="entity">dom_eqns</span><span class="main">)</span>
    <span class="keyword2"><span class="keyword">end</span></span>

    <span class="comment1">(* register recursive definition of map functions *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">map_binds</span> <span class="main">=</span> map <span class="main">(</span>Binding.suffix_name <span class="inner_quoted">"_map"</span><span class="main">)</span> <span class="entity">dbinds</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">map_apply_thms</span><span class="main">,</span> <span class="entity">map_unfold_thms</span><span class="main">,</span> <span class="entity">map_cont_thm</span><span class="main">)</span><span class="main">,</span> <span class="entity">thy</span><span class="main">)</span> <span class="main">=</span>
      <span class="entity">add_fixdefs</span> <span class="main">(</span><span class="entity">map_binds</span> ~~ <span class="entity">map_specs</span><span class="main">)</span> <span class="entity">thy</span>

    <span class="comment1">(* prove deflation theorems for map functions *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">deflation_abs_rep_thms</span> <span class="main">=</span> map <span class="entity">deflation_abs_rep</span> <span class="entity">iso_infos</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">deflation_map_thm</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">unprime</span> <span class="entity">a</span> <span class="main">=</span> Library.unprefix <span class="inner_quoted">"'"</span> <span class="entity">a</span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_f</span> <span class="entity">T</span> <span class="main">=</span> Free <span class="main">(</span><span class="entity">unprime</span> <span class="main">(</span>fst <span class="main">(</span>dest_TFree <span class="entity">T</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="entity">T</span> <span class="entity">-&gt;&gt;</span> <span class="entity">T</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_assm</span> <span class="entity">T</span> <span class="main">=</span> <span class="entity">mk_trp</span> <span class="main">(</span><span class="entity">mk_deflation</span> <span class="main">(</span><span class="entity">mk_f</span> <span class="entity">T</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_goal</span> <span class="main">(</span><span class="entity">map_const</span><span class="main">,</span> <span class="main">(</span><span class="entity">lhsT</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Ts</span> <span class="main">=</span> <span class="entity">argumentTs</span> <span class="entity">lhsT</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">map_term</span> <span class="main">=</span> <span class="entity">list_ccomb</span> <span class="main">(</span><span class="entity">map_const</span><span class="main">,</span> map <span class="entity">mk_f</span> <span class="main">(</span>filter <span class="main">(</span><span class="entity">is_cpo</span> <span class="entity">thy</span><span class="main">)</span> <span class="entity">Ts</span><span class="main">)</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">mk_deflation</span> <span class="entity">map_term</span> <span class="keyword2"><span class="keyword">end</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">assms</span> <span class="main">=</span> <span class="main">(</span>map <span class="entity">mk_assm</span> o filter <span class="main">(</span><span class="entity">is_cpo</span> <span class="entity">thy</span><span class="main">)</span> o <span class="entity">argumentTs</span> o fst o hd<span class="main">)</span> <span class="entity">dom_eqns</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goals</span> <span class="main">=</span> map <span class="entity">mk_goal</span> <span class="main">(</span><span class="entity">map_consts</span> ~~ <span class="entity">dom_eqns</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goal</span> <span class="main">=</span> <span class="entity">mk_trp</span> <span class="main">(</span>foldr1 <span class="entity">HOLogic.mk_conj</span> <span class="entity">goals</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">adm_rules</span> <span class="main">=</span>
          <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> adm_conj adm_subst <span class="main">[</span><span class="operator">OF</span> _ adm_deflation<span class="main">]</span>
                 cont2cont_fst cont2cont_snd cont_id<span class="antiquote">}</span></span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">bottom_rules</span> <span class="main">=</span>
          <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> fst_strict snd_strict deflation_bottom simp_thms<span class="antiquote">}</span></span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tuple_rules</span> <span class="main">=</span>
          <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> split_def fst_conv snd_conv<span class="antiquote">}</span></span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">deflation_rules</span> <span class="main">=</span>
          <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> conjI deflation_ID<span class="antiquote">}</span></span></span>
          @ <span class="entity">deflation_abs_rep_thms</span>
          @ <span class="entity">Domain_Take_Proofs.get_deflation_thms</span> <span class="entity">thy</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        Goal.prove_global <span class="entity">thy</span> <span class="main">[</span><span class="main">]</span> <span class="entity">assms</span> <span class="entity">goal</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span><span class="entity">prems</span><span class="main">,</span> context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
         EVERY
          <span class="main">[</span>rewrite_goals_tac <span class="entity">ctxt</span> <span class="entity">map_apply_thms</span><span class="main">,</span>
           resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">map_cont_thm</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> cont_fix_ind<span class="antiquote">}</span></span></span><span class="main">]</span> <span class="inner_numeral">1</span><span class="main">,</span>
           REPEAT <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="entity">adm_rules</span> <span class="inner_numeral">1</span><span class="main">)</span><span class="main">,</span>
           <span class="entity">simp_tac</span> <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt</span> addsimps <span class="entity">bottom_rules</span><span class="main">)</span> <span class="inner_numeral">1</span><span class="main">,</span>
           <span class="entity">simp_tac</span> <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt</span> addsimps <span class="entity">tuple_rules</span><span class="main">)</span> <span class="inner_numeral">1</span><span class="main">,</span>
           REPEAT <span class="main">(</span>eresolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> conjE<span class="antiquote">}</span></span></span> <span class="inner_numeral">1</span><span class="main">)</span><span class="main">,</span>
           REPEAT <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">deflation_rules</span> @ <span class="entity">prems</span><span class="main">)</span> <span class="inner_numeral">1</span> ORELSE assume_tac <span class="entity">ctxt</span> <span class="inner_numeral">1</span><span class="main">)</span><span class="main">]</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">conjuncts</span> <span class="main">[</span><span class="main">]</span> <span class="main">_</span> <span class="main">=</span> <span class="main">[</span><span class="main">]</span>
      <span class="main">|</span> <span class="entity">conjuncts</span> <span class="main">(</span><span class="entity">n</span>::<span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="entity">thm</span> <span class="main">=</span> <span class="main">[</span><span class="main">(</span><span class="entity">n</span><span class="main">,</span> <span class="entity">thm</span><span class="main">)</span><span class="main">]</span>
      <span class="main">|</span> <span class="entity">conjuncts</span> <span class="main">(</span><span class="entity">n</span>::<span class="entity">ns</span><span class="main">)</span> <span class="entity">thm</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thmL</span> <span class="main">=</span> <span class="entity">thm</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> conjunct1<span class="antiquote">}</span></span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thmR</span> <span class="main">=</span> <span class="entity">thm</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> conjunct2<span class="antiquote">}</span></span></span>
        <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">n</span><span class="main">,</span> <span class="entity">thmL</span><span class="main">)</span>:: <span class="entity">conjuncts</span> <span class="entity">ns</span> <span class="entity">thmR</span> <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">deflation_map_binds</span> <span class="main">=</span> <span class="entity">dbinds</span> |&gt;
        map <span class="main">(</span>Binding.prefix_name <span class="inner_quoted">"deflation_"</span> o Binding.suffix_name <span class="inner_quoted">"_map"</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">deflation_map_thms</span><span class="main">,</span> <span class="entity">thy</span><span class="main">)</span> <span class="main">=</span> <span class="entity">thy</span> |&gt;
      <span class="main">(</span>Global_Theory.add_thms o map <span class="main">(</span>Thm.no_attributes o apsnd Drule.zero_var_indexes<span class="main">)</span><span class="main">)</span>
        <span class="main">(</span><span class="entity">conjuncts</span> <span class="entity">deflation_map_binds</span> <span class="entity">deflation_map_thm</span><span class="main">)</span>

<span class="comment1">(*
    (* register indirect recursion in theory data *)
    local
      fun register_map (dname, args) =
        Domain_Take_Proofs.add_rec_type (dname, args)
      val dnames = map (fst o dest_Type o fst) dom_eqns
      fun args (T, _) = case T of Type (_, Ts) =&gt; map (is_cpo thy) Ts | _ =&gt; []
      val argss = map args dom_eqns
    in
      val thy =
          fold register_map (dnames ~~ argss) thy
    end
*)</span>

    <span class="comment1">(* register deflation theorems *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> fold <span class="entity">Domain_Take_Proofs.add_deflation_thm</span> <span class="entity">deflation_map_thms</span> <span class="entity">thy</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">result</span> <span class="main">=</span>
      <span class="main">{</span>
        map_consts <span class="main">=</span> <span class="entity">map_consts</span><span class="main">,</span>
        map_apply_thms <span class="main">=</span> <span class="entity">map_apply_thms</span><span class="main">,</span>
        map_unfold_thms <span class="main">=</span> <span class="entity">map_unfold_thms</span><span class="main">,</span>
        map_cont_thm <span class="main">=</span> <span class="entity">map_cont_thm</span><span class="main">,</span>
        deflation_map_thms <span class="main">=</span> <span class="entity">deflation_map_thms</span>
      <span class="main">}</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span><span class="entity">result</span><span class="main">,</span> <span class="entity">thy</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(******************************************************************************)</span>
<span class="comment1">(******************************* main function ********************************)</span>
<span class="comment1">(******************************************************************************)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">domain_isomorphism</span>
    <span class="main">(</span><span class="entity">param</span> <span class="main">:</span> string<span class="main">)</span>
    <span class="main">(</span><span class="entity">doms</span> <span class="main">:</span> <span class="main">(</span><span class="main">(</span>string * sort<span class="main">)</span> list * binding * mixfix * typ *
             <span class="main">(</span>binding * binding<span class="main">)</span> option<span class="main">)</span> list<span class="main">)</span>
    <span class="main">(</span><span class="entity">thy</span><span class="main">:</span> theory<span class="main">)</span>
    <span class="main">:</span> <span class="main">(</span><span class="entity">Domain_Take_Proofs.iso_info</span> list
       * <span class="entity">Domain_Take_Proofs.take_induct_info</span><span class="main">)</span> * theory <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="comment1">(* this theory is used just for parsing *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tmp_thy</span> <span class="main">=</span> <span class="entity">thy</span> |&gt;
      Sign.add_types_global <span class="main">(</span>map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">tvs</span><span class="main">,</span> <span class="entity">tbind</span><span class="main">,</span> <span class="entity">mx</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span>
        <span class="main">(</span><span class="entity">tbind</span><span class="main">,</span> length <span class="entity">tvs</span><span class="main">,</span> <span class="entity">mx</span><span class="main">)</span><span class="main">)</span> <span class="entity">doms</span><span class="main">)</span>

    <span class="comment1">(* declare arities in temporary theory *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tmp_thy</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">arity</span> <span class="main">(</span><span class="entity">vs</span><span class="main">,</span> <span class="entity">tbind</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span>
          <span class="main">(</span>Sign.full_name <span class="entity">thy</span> <span class="entity">tbind</span><span class="main">,</span> map snd <span class="entity">vs</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">"tycon"</span><span class="antiquote">}</span></span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        fold <span class="entity">Axclass.arity_axiomatization</span> <span class="main">(</span>map <span class="entity">arity</span> <span class="entity">doms</span><span class="main">)</span> <span class="entity">tmp_thy</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="comment1">(* check bifiniteness of right-hand sides *)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">check_rhs</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">if</span></span> Sign.of_sort <span class="entity">tmp_thy</span> <span class="main">(</span><span class="entity">rhs</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">"domain"</span><span class="antiquote">}</span></span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">else</span></span> error <span class="main">(</span><span class="inner_quoted">"Type not of sort domain: "</span> ^
        quote <span class="main">(</span>Syntax.string_of_typ_global <span class="entity">tmp_thy</span> <span class="entity">rhs</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> map <span class="entity">check_rhs</span> <span class="entity">doms</span>

    <span class="comment1">(* domain equations *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">paramT</span> <span class="main">=</span> TFree <span class="main">(</span><span class="entity">param</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">domain</span><span class="antiquote">}</span></span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_tc_eqn</span> <span class="main">(</span><span class="entity">vs</span><span class="main">,</span> <span class="entity">tbind</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span>
      <span class="main">(</span>Type <span class="main">(</span>Sign.full_name <span class="entity">tmp_thy</span> <span class="entity">tbind</span><span class="main">,</span> map TFree <span class="entity">vs</span><span class="main">)</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tc_eqns</span> <span class="main">=</span> map <span class="entity">mk_tc_eqn</span> <span class="entity">doms</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_dom_eqn</span> <span class="main">(</span><span class="entity">vs</span><span class="main">,</span> <span class="entity">tbind</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span>
      <span class="main">(</span><span class="entity">mk_appT</span> <span class="entity">paramT</span> <span class="main">(</span>Type <span class="main">(</span>Sign.full_name <span class="entity">tmp_thy</span> <span class="entity">tbind</span><span class="main">,</span> map TFree <span class="entity">vs</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dom_eqns</span> <span class="main">=</span> map <span class="entity">mk_dom_eqn</span> <span class="entity">doms</span>

    <span class="comment1">(* check for valid type parameters *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">tyvars</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> hd <span class="entity">doms</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">tvs</span><span class="main">,</span> <span class="entity">tname</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span>
      <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">full_tname</span> <span class="main">=</span> Sign.full_name <span class="entity">tmp_thy</span> <span class="entity">tname</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> duplicates <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="main">(</span>map fst <span class="entity">tvs</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
          <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span>
            <span class="keyword2"><span class="keyword">if</span></span> eq_set <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="main">(</span><span class="entity">tyvars</span><span class="main">,</span> <span class="entity">tvs</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="entity">full_tname</span><span class="main">,</span> <span class="entity">tvs</span><span class="main">)</span>
            <span class="keyword2"><span class="keyword">else</span></span> error <span class="main">(</span><span class="inner_quoted">"Mutually recursive domains must have same type parameters"</span><span class="main">)</span>
        <span class="main">|</span> <span class="entity">dups</span> <span class="main">=&gt;</span> error <span class="main">(</span><span class="inner_quoted">"Duplicate parameter(s) for domain "</span> ^ Binding.print <span class="entity">tname</span> ^
            <span class="inner_quoted">" : "</span> ^ commas <span class="entity">dups</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span><span class="main">)</span> <span class="entity">doms</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dbinds</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">dbind</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">dbind</span><span class="main">)</span> <span class="entity">doms</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">morphs</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">morphs</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">morphs</span><span class="main">)</span> <span class="entity">doms</span>

    <span class="comment1">(* determine deflation combinator arguments *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tcs</span> <span class="main">:</span> typ list <span class="main">=</span> map fst <span class="entity">tc_eqns</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">param_defl</span> <span class="main">=</span> Free <span class="main">(</span><span class="inner_quoted">"d"</span> ^ Library.unprefix <span class="inner_quoted">"'"</span> <span class="entity">param</span><span class="main">,</span> <span class="entity">deflT</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhsTs</span> <span class="main">:</span> typ list <span class="main">=</span> map fst <span class="entity">dom_eqns</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">defl_rec</span> <span class="main">=</span> Free <span class="main">(</span><span class="inner_quoted">"t"</span><span class="main">,</span> <span class="entity">mk_tupleT</span> <span class="main">(</span>map <span class="main">(</span>K <span class="entity">deflT</span><span class="main">)</span> <span class="entity">lhsTs</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">defl_rews</span> <span class="main">=</span> <span class="entity">mk_projs</span> <span class="main">(</span>map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">T</span> <span class="main">=&gt;</span> <span class="entity">mk_capply</span> <span class="main">(</span><span class="entity">mk_TC</span> <span class="entity">T</span><span class="main">,</span> <span class="entity">param_defl</span><span class="main">)</span><span class="main">)</span> <span class="entity">tcs</span><span class="main">)</span> <span class="entity">defl_rec</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">defl_body</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">rhsT</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> <span class="entity">defl_of_typ</span> <span class="entity">tmp_thy</span> <span class="entity">defl_rews</span> <span class="entity">rhsT</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">functional</span> <span class="main">=</span> Term.lambda <span class="entity">defl_rec</span> <span class="main">(</span><span class="entity">mk_tuple</span> <span class="main">(</span>map <span class="entity">defl_body</span> <span class="entity">doms</span><span class="main">)</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tfrees</span> <span class="main">=</span> Term.add_tfrees <span class="entity">functional</span> <span class="main">[</span><span class="main">]</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">frees</span> <span class="main">=</span> map fst <span class="main">(</span>Term.add_frees <span class="entity">functional</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_defl_flags</span> <span class="main">(</span><span class="entity">vs</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">argT</span> <span class="entity">v</span> <span class="main">=</span> TFree <span class="entity">v</span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_d</span> <span class="entity">v</span> <span class="main">=</span> <span class="inner_quoted">"d"</span> ^ Library.unprefix <span class="inner_quoted">"'"</span> <span class="main">(</span>fst <span class="entity">v</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_p</span> <span class="entity">v</span> <span class="main">=</span> <span class="inner_quoted">"p"</span> ^ Library.unprefix <span class="inner_quoted">"'"</span> <span class="main">(</span>fst <span class="entity">v</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">=</span> maps <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">v</span> <span class="main">=&gt;</span> <span class="main">[</span><span class="main">(</span><span class="entity">mk_d</span> <span class="entity">v</span><span class="main">,</span> <span class="entity">mk_DEFL</span> <span class="main">(</span><span class="entity">argT</span> <span class="entity">v</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">mk_p</span> <span class="entity">v</span><span class="main">,</span> <span class="entity">mk_LIFTDEFL</span> <span class="main">(</span><span class="entity">argT</span> <span class="entity">v</span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="entity">vs</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">typeTs</span> <span class="main">=</span> map <span class="entity">argT</span> <span class="main">(</span>filter <span class="main">(</span>member <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">tfrees</span><span class="main">)</span> <span class="entity">vs</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">defl_args</span> <span class="main">=</span> map snd <span class="main">(</span>filter <span class="main">(</span>member <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">frees</span> o fst<span class="main">)</span> <span class="entity">args</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span><span class="entity">typeTs</span><span class="main">,</span> <span class="entity">defl_args</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">defl_flagss</span> <span class="main">=</span> map <span class="entity">get_defl_flags</span> <span class="entity">doms</span>

    <span class="comment1">(* declare deflation combinator constants *)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">declare_defl_const</span> <span class="main">(</span><span class="main">(</span><span class="entity">typeTs</span><span class="main">,</span> <span class="entity">defl_args</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">tbind</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="entity">thy</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">defl_bind</span> <span class="main">=</span> Binding.suffix_name <span class="inner_quoted">"_defl"</span> <span class="entity">tbind</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">defl_type</span> <span class="main">=</span>
          map Term.itselfT <span class="entity">typeTs</span> ---&gt; map fastype_of <span class="entity">defl_args</span> <span class="entity">--&gt;&gt;</span> <span class="entity">deflT</span> <span class="entity">-&gt;&gt;</span> <span class="entity">deflT</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        Sign.declare_const_global <span class="main">(</span><span class="main">(</span><span class="entity">defl_bind</span><span class="main">,</span> <span class="entity">defl_type</span><span class="main">)</span><span class="main">,</span> NoSyn<span class="main">)</span> <span class="entity">thy</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">defl_consts</span><span class="main">,</span> <span class="entity">thy</span><span class="main">)</span> <span class="main">=</span>
      fold_map <span class="entity">declare_defl_const</span> <span class="main">(</span><span class="entity">defl_flagss</span> ~~ <span class="entity">doms</span><span class="main">)</span> <span class="entity">thy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">tmp_thy</span><span class="main">)</span> <span class="main">=</span>
      fold_map <span class="entity">declare_defl_const</span> <span class="main">(</span><span class="entity">defl_flagss</span> ~~ <span class="entity">doms</span><span class="main">)</span> <span class="entity">tmp_thy</span>

    <span class="comment1">(* defining equations for type combinators *)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_defl_term</span> <span class="main">(</span><span class="entity">defl_const</span><span class="main">,</span> <span class="main">(</span><span class="entity">typeTs</span><span class="main">,</span> <span class="entity">defl_args</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">type_args</span> <span class="main">=</span> map Logic.mk_type <span class="entity">typeTs</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="entity">list_ccomb</span> <span class="main">(</span>list_comb <span class="main">(</span><span class="entity">defl_const</span><span class="main">,</span> <span class="entity">type_args</span><span class="main">)</span><span class="main">,</span> <span class="entity">defl_args</span> @ <span class="main">[</span><span class="entity">param_defl</span><span class="main">]</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">defl_terms</span> <span class="main">=</span> map <span class="entity">mk_defl_term</span> <span class="main">(</span><span class="entity">defl_consts</span> ~~ <span class="entity">defl_flagss</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">defl_rews</span> <span class="main">=</span> map fst <span class="entity">defl_rews</span> ~~ <span class="entity">defl_terms</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_defl_spec</span> <span class="main">(</span><span class="entity">lhsT</span><span class="main">,</span> <span class="entity">rhsT</span><span class="main">)</span> <span class="main">=</span>
      <span class="entity">mk_eqs</span> <span class="main">(</span><span class="entity">defl_of_typ</span> <span class="entity">tmp_thy</span> <span class="entity">defl_rews</span> <span class="entity">lhsT</span><span class="main">,</span>
              <span class="entity">defl_of_typ</span> <span class="entity">tmp_thy</span> <span class="entity">defl_rews</span> <span class="entity">rhsT</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">defl_specs</span> <span class="main">=</span> map <span class="entity">mk_defl_spec</span> <span class="entity">dom_eqns</span>

    <span class="comment1">(* register recursive definition of deflation combinators *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">defl_binds</span> <span class="main">=</span> map <span class="main">(</span>Binding.suffix_name <span class="inner_quoted">"_defl"</span><span class="main">)</span> <span class="entity">dbinds</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">defl_apply_thms</span><span class="main">,</span> <span class="entity">defl_unfold_thms</span><span class="main">,</span> <span class="entity">defl_cont_thm</span><span class="main">)</span><span class="main">,</span> <span class="entity">thy</span><span class="main">)</span> <span class="main">=</span>
      <span class="entity">add_fixdefs</span> <span class="main">(</span><span class="entity">defl_binds</span> ~~ <span class="entity">defl_specs</span><span class="main">)</span> <span class="entity">thy</span>

    <span class="comment1">(* define tycons using deflation combinators *)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">make_tycondef</span> <span class="main">(</span><span class="main">(</span><span class="entity">vs</span><span class="main">,</span> <span class="entity">tbind</span><span class="main">,</span> <span class="entity">mx</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="entity">tc</span><span class="main">)</span> <span class="entity">thy</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">spec</span> <span class="main">=</span> <span class="main">(</span><span class="entity">tbind</span><span class="main">,</span> <span class="entity">vs</span><span class="main">,</span> <span class="entity">mx</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">full_tname</span><span class="main">,</span> <span class="entity">info</span><span class="main">)</span><span class="main">,</span> <span class="entity">thy</span><span class="main">)</span> <span class="main">=</span> <span class="entity">define_singleton_type</span> <span class="entity">spec</span> <span class="entity">thy</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">newT</span> <span class="main">=</span> <span class="main">#</span>abs_type <span class="main">(</span><span class="main">#</span><span class="inner_numeral">1</span> <span class="entity">info</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs_tfrees</span> <span class="main">=</span> map dest_TFree <span class="main">(</span>snd <span class="main">(</span>dest_Type <span class="entity">newT</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tc_eqn</span> <span class="main">=</span> Logic.mk_equals <span class="main">(</span><span class="entity">tc_const</span> <span class="entity">newT</span><span class="main">,</span> Abs <span class="main">(</span><span class="inner_quoted">""</span><span class="main">,</span> Term.itselfT <span class="entity">newT</span><span class="main">,</span> <span class="entity">tc</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">tc_ldef</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span> <span class="entity">thy</span>
          |&gt; <span class="entity">Class.instantiation</span> <span class="main">(</span><span class="main">[</span><span class="entity">full_tname</span><span class="main">]</span><span class="main">,</span> <span class="entity">lhs_tfrees</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">tycon</span><span class="antiquote">}</span></span><span class="main">)</span>
          |&gt; <span class="entity">Specification.definition</span> NONE <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span>
              <span class="main">(</span><span class="main">(</span>Binding.prefix_name <span class="inner_quoted">"tc_"</span> <span class="main">(</span>Binding.suffix_name <span class="inner_quoted">"_def"</span> <span class="entity">tbind</span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">tc_eqn</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt_thy</span> <span class="main">=</span> Proof_Context.init_global <span class="main">(</span>Proof_Context.theory_of <span class="entity">lthy</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tc_def</span> <span class="main">=</span> singleton <span class="main">(</span>Proof_Context.export <span class="entity">lthy</span> <span class="entity">ctxt_thy</span><span class="main">)</span> <span class="entity">tc_ldef</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> <span class="entity">lthy</span>
          |&gt; <span class="entity">Class.prove_instantiation_exit</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> <span class="entity">Class.intro_classes_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span>
        <span class="comment1">(* declare domain_defl_simps *)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">attr</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">attributes</span> <span class="main">[</span><span class="operator">domain_defl_simps</span><span class="main">]</span><span class="antiquote">}</span></span></span>
          |&gt; map <span class="main">(</span><span class="entity">Attrib.attribute_global</span> <span class="entity">thy</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tc_thm</span> <span class="main">=</span> Drule.zero_var_indexes <span class="main">(</span><span class="entity">tc_def</span> RS <span class="entity">TC_simp</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tc_thm_bind</span> <span class="main">=</span> Binding.prefix_name <span class="inner_quoted">"TC_"</span> <span class="entity">tbind</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">thy</span><span class="main">)</span> <span class="main">=</span> <span class="entity">thy</span> |&gt; Global_Theory.add_thm <span class="main">(</span><span class="main">(</span><span class="entity">tc_thm_bind</span><span class="main">,</span> <span class="entity">tc_thm</span><span class="main">)</span><span class="main">,</span> <span class="entity">attr</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span><span class="entity">tc_def</span><span class="main">,</span> <span class="entity">thy</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_defl_term</span> <span class="main">(</span><span class="entity">defl_const</span><span class="main">,</span> <span class="main">(</span><span class="entity">typeTs</span><span class="main">,</span> <span class="entity">defl_args</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">type_args</span> <span class="main">=</span> map Logic.mk_type <span class="entity">typeTs</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="entity">list_ccomb</span> <span class="main">(</span>list_comb <span class="main">(</span><span class="entity">defl_const</span><span class="main">,</span> <span class="entity">type_args</span><span class="main">)</span><span class="main">,</span> <span class="entity">defl_args</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">defl_terms</span> <span class="main">=</span> map <span class="entity">mk_defl_term</span> <span class="main">(</span><span class="entity">defl_consts</span> ~~ <span class="entity">defl_flagss</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">tc_defs</span><span class="main">,</span> <span class="entity">thy</span><span class="main">)</span> <span class="main">=</span> fold_map <span class="entity">make_tycondef</span> <span class="main">(</span><span class="entity">doms</span> ~~ <span class="entity">defl_terms</span><span class="main">)</span> <span class="entity">thy</span>

    <span class="comment1">(* prove DEFL equations *)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_DEFL_eq_thm</span> <span class="main">(</span><span class="entity">lhsT</span><span class="main">,</span> <span class="entity">rhsT</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goal</span> <span class="main">=</span> <span class="entity">mk_eqs</span> <span class="main">(</span><span class="entity">mk_DEFL</span> <span class="entity">lhsT</span><span class="main">,</span> <span class="entity">mk_DEFL</span> <span class="entity">rhsT</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">DEFL_simps</span> <span class="main">=</span> Global_Theory.get_thms <span class="entity">thy</span> <span class="inner_quoted">"domain_defl_simps"</span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">tac</span> <span class="entity">ctxt</span> <span class="main">=</span>
          rewrite_goals_tac <span class="entity">ctxt</span> <span class="main">(</span>map <span class="entity">mk_meta_eq</span> <span class="entity">DEFL_simps</span> @ <span class="entity">tc_defs</span><span class="main">)</span>
          THEN TRY <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="entity">defl_unfold_thms</span> <span class="inner_numeral">1</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        Goal.prove_global <span class="entity">thy</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">goal</span> <span class="main">(</span><span class="entity">tac</span> o <span class="main">#</span>context<span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">DEFL_eq_thms</span> <span class="main">=</span> map <span class="entity">mk_DEFL_eq_thm</span> <span class="entity">dom_eqns</span>

    <span class="comment1">(* register DEFL equations *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">DEFL_eq_binds</span> <span class="main">=</span> map <span class="main">(</span>Binding.prefix_name <span class="inner_quoted">"DEFL_eq_"</span><span class="main">)</span> <span class="entity">dbinds</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">thy</span><span class="main">)</span> <span class="main">=</span> <span class="entity">thy</span> |&gt;
      <span class="main">(</span>Global_Theory.add_thms o map Thm.no_attributes<span class="main">)</span>
        <span class="main">(</span><span class="entity">DEFL_eq_binds</span> ~~ <span class="entity">DEFL_eq_thms</span><span class="main">)</span>

    <span class="comment1">(* define rep/abs functions *)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_rep_abs</span> <span class="main">(</span><span class="main">(</span><span class="entity">tbind</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">lhsT</span><span class="main">,</span> <span class="entity">rhsT</span><span class="main">)</span><span class="main">)</span> <span class="entity">thy</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rep_bind</span> <span class="main">=</span> Binding.suffix_name <span class="inner_quoted">"_rep"</span> <span class="entity">tbind</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">abs_bind</span> <span class="main">=</span> Binding.suffix_name <span class="inner_quoted">"_abs"</span> <span class="entity">tbind</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">rep_const</span><span class="main">,</span> <span class="entity">rep_def</span><span class="main">)</span><span class="main">,</span> <span class="entity">thy</span><span class="main">)</span> <span class="main">=</span>
            <span class="entity">define_const</span> <span class="main">(</span><span class="entity">rep_bind</span><span class="main">,</span> <span class="entity">coerce_const</span> <span class="main">(</span><span class="entity">lhsT</span><span class="main">,</span> <span class="entity">rhsT</span><span class="main">)</span><span class="main">)</span> <span class="entity">thy</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">abs_const</span><span class="main">,</span> <span class="entity">abs_def</span><span class="main">)</span><span class="main">,</span> <span class="entity">thy</span><span class="main">)</span> <span class="main">=</span>
            <span class="entity">define_const</span> <span class="main">(</span><span class="entity">abs_bind</span><span class="main">,</span> <span class="entity">coerce_const</span> <span class="main">(</span><span class="entity">rhsT</span><span class="main">,</span> <span class="entity">lhsT</span><span class="main">)</span><span class="main">)</span> <span class="entity">thy</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">rep_const</span><span class="main">,</span> <span class="entity">abs_const</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">rep_def</span><span class="main">,</span> <span class="entity">abs_def</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="entity">thy</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">rep_abs_consts</span><span class="main">,</span> <span class="entity">rep_abs_defs</span><span class="main">)</span><span class="main">,</span> <span class="entity">thy</span><span class="main">)</span> <span class="main">=</span> <span class="entity">thy</span>
      |&gt; fold_map <span class="entity">mk_rep_abs</span> <span class="main">(</span><span class="entity">dbinds</span> ~~ <span class="entity">morphs</span> ~~ <span class="entity">dom_eqns</span><span class="main">)</span>
      |&gt;&gt; ListPair.unzip

    <span class="comment1">(* prove isomorphism and isodefl rules *)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_iso_thms</span> <span class="main">(</span><span class="main">(</span><span class="entity">tbind</span><span class="main">,</span> <span class="entity">DEFL_eq</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">rep_def</span><span class="main">,</span> <span class="entity">abs_def</span><span class="main">)</span><span class="main">)</span> <span class="entity">thy</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">make</span> <span class="entity">thm</span> <span class="main">=</span>
            Drule.zero_var_indexes <span class="main">(</span><span class="entity">thm</span> OF <span class="main">[</span><span class="entity">DEFL_eq</span><span class="main">,</span> <span class="entity">abs_def</span><span class="main">,</span> <span class="entity">rep_def</span><span class="main">]</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rep_iso_thm</span> <span class="main">=</span> <span class="entity">make</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> domain_rep_iso<span class="antiquote">}</span></span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">abs_iso_thm</span> <span class="main">=</span> <span class="entity">make</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> domain_abs_iso<span class="antiquote">}</span></span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">isodefl_thm</span> <span class="main">=</span> <span class="entity">make</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> isodefl_abs_rep<span class="antiquote">}</span></span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> <span class="entity">thy</span>
          |&gt; snd o <span class="entity">add_qualified_thm</span> <span class="inner_quoted">"rep_iso"</span> <span class="main">(</span><span class="entity">tbind</span><span class="main">,</span> <span class="entity">rep_iso_thm</span><span class="main">)</span>
          |&gt; snd o <span class="entity">add_qualified_thm</span> <span class="inner_quoted">"abs_iso"</span> <span class="main">(</span><span class="entity">tbind</span><span class="main">,</span> <span class="entity">abs_iso_thm</span><span class="main">)</span>
          |&gt; snd o <span class="entity">add_qualified_thm</span> <span class="inner_quoted">"isodefl_abs_rep"</span> <span class="main">(</span><span class="entity">tbind</span><span class="main">,</span> <span class="entity">isodefl_thm</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">rep_iso_thm</span><span class="main">,</span> <span class="entity">abs_iso_thm</span><span class="main">)</span><span class="main">,</span> <span class="entity">isodefl_thm</span><span class="main">)</span><span class="main">,</span> <span class="entity">thy</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">iso_thms</span><span class="main">,</span> <span class="entity">isodefl_abs_rep_thms</span><span class="main">)</span><span class="main">,</span> <span class="entity">thy</span><span class="main">)</span> <span class="main">=</span>
      <span class="entity">thy</span>
      |&gt; fold_map <span class="entity">mk_iso_thms</span> <span class="main">(</span><span class="entity">dbinds</span> ~~ <span class="entity">DEFL_eq_thms</span> ~~ <span class="entity">rep_abs_defs</span><span class="main">)</span>
      |&gt;&gt; ListPair.unzip

    <span class="comment1">(* collect info about rep/abs *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">iso_infos</span> <span class="main">:</span> <span class="entity">Domain_Take_Proofs.iso_info</span> list <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_info</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">lhsT</span><span class="main">,</span> <span class="entity">rhsT</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">repC</span><span class="main">,</span> <span class="entity">absC</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">rep_iso</span><span class="main">,</span> <span class="entity">abs_iso</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
          <span class="main">{</span>
            repT <span class="main">=</span> <span class="entity">rhsT</span><span class="main">,</span>
            absT <span class="main">=</span> <span class="entity">lhsT</span><span class="main">,</span>
            rep_const <span class="main">=</span> <span class="entity">repC</span><span class="main">,</span>
            abs_const <span class="main">=</span> <span class="entity">absC</span><span class="main">,</span>
            rep_inverse <span class="main">=</span> <span class="entity">rep_iso</span><span class="main">,</span>
            abs_inverse <span class="main">=</span> <span class="entity">abs_iso</span>
          <span class="main">}</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        map <span class="entity">mk_info</span> <span class="main">(</span><span class="entity">dom_eqns</span> ~~ <span class="entity">rep_abs_consts</span> ~~ <span class="entity">iso_thms</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="comment1">(* definitions and proofs related to map functions *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">map_info</span><span class="main">,</span> <span class="entity">thy</span><span class="main">)</span> <span class="main">=</span>
        <span class="entity">define_map_functions</span> <span class="main">(</span><span class="entity">dbinds</span> ~~ <span class="entity">iso_infos</span><span class="main">)</span> <span class="entity">thy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span> <span class="entity">map_consts</span><span class="main">,</span> <span class="entity">map_apply_thms</span><span class="main">,</span> <span class="entity">map_cont_thm</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span> <span class="entity">map_info</span>

    <span class="comment1">(* prove isodefl rules for map functions *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">isodefl_thm</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">unprime</span> <span class="entity">a</span> <span class="main">=</span> Library.unprefix <span class="inner_quoted">"'"</span> <span class="entity">a</span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_d</span> <span class="entity">T</span> <span class="main">=</span> Free <span class="main">(</span><span class="inner_quoted">"d"</span> ^ <span class="entity">unprime</span> <span class="main">(</span>fst <span class="main">(</span>dest_TFree <span class="entity">T</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="entity">deflT</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_p</span> <span class="entity">T</span> <span class="main">=</span> Free <span class="main">(</span><span class="inner_quoted">"p"</span> ^ <span class="entity">unprime</span> <span class="main">(</span>fst <span class="main">(</span>dest_TFree <span class="entity">T</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="entity">udeflT</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_f</span> <span class="entity">T</span> <span class="main">=</span> Free <span class="main">(</span><span class="inner_quoted">"f"</span> ^ <span class="entity">unprime</span> <span class="main">(</span>fst <span class="main">(</span>dest_TFree <span class="entity">T</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="entity">T</span> <span class="entity">-&gt;&gt;</span> <span class="entity">T</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_assm</span> <span class="entity">t</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">case</span></span> try <span class="entity">dest_LIFTDEFL</span> <span class="entity">t</span> <span class="keyword2"><span class="keyword">of</span></span>
            SOME <span class="entity">T</span> <span class="main">=&gt;</span> <span class="entity">mk_trp</span> <span class="main">(</span><span class="entity">isodefl'_const</span> <span class="entity">T</span> $ <span class="entity">mk_f</span> <span class="entity">T</span> $ <span class="entity">mk_p</span> <span class="entity">T</span><span class="main">)</span>
          <span class="main">|</span> NONE <span class="main">=&gt;</span>
            <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">T</span> <span class="main">=</span> <span class="entity">dest_DEFL</span> <span class="entity">t</span>
            <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">mk_trp</span> <span class="main">(</span><span class="entity">isodefl_const</span> <span class="entity">T</span> $ <span class="entity">mk_f</span> <span class="entity">T</span> $ <span class="entity">mk_d</span> <span class="entity">T</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_goal</span> <span class="main">(</span><span class="entity">map_const</span><span class="main">,</span> <span class="main">(</span><span class="main">(</span><span class="entity">T</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="entity">defl_term</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Ts</span> <span class="main">=</span> <span class="entity">argumentTs</span> <span class="entity">T</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">map_term</span> <span class="main">=</span> <span class="entity">list_ccomb</span> <span class="main">(</span><span class="entity">map_const</span><span class="main">,</span> map <span class="entity">mk_f</span> <span class="main">(</span>filter <span class="main">(</span><span class="entity">is_cpo</span> <span class="entity">thy</span><span class="main">)</span> <span class="entity">Ts</span><span class="main">)</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rews1</span> <span class="main">=</span> map <span class="entity">mk_DEFL</span> <span class="entity">Ts</span> ~~ map <span class="entity">mk_d</span> <span class="entity">Ts</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rews2</span> <span class="main">=</span> map <span class="entity">mk_LIFTDEFL</span> <span class="entity">Ts</span> ~~ map <span class="entity">mk_p</span> <span class="entity">Ts</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rews3</span> <span class="main">=</span> <span class="main">[</span><span class="main">(</span><span class="main">(</span><span class="entity">mk_TC</span> o snd o <span class="entity">dest_appT</span><span class="main">)</span> <span class="entity">T</span><span class="main">,</span> <span class="entity">defl_term</span><span class="main">)</span><span class="main">]</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rews</span> <span class="main">=</span> <span class="entity">rews1</span> @ <span class="entity">rews2</span> @ <span class="entity">rews3</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">defl_term</span> <span class="main">=</span> <span class="entity">defl_of_typ</span> <span class="entity">thy</span> <span class="entity">rews</span> <span class="entity">T</span>
          <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">isodefl_const</span> <span class="entity">T</span> $ <span class="entity">map_term</span> $ <span class="entity">defl_term</span> <span class="keyword2"><span class="keyword">end</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">assms</span> <span class="main">=</span> <span class="main">(</span>map <span class="entity">mk_assm</span> o snd o hd<span class="main">)</span> <span class="entity">defl_flagss</span>
          @ <span class="main">[</span><span class="entity">mk_trp</span> <span class="main">(</span><span class="entity">isodefl_const</span> <span class="entity">paramT</span> $ <span class="entity">mk_f</span> <span class="entity">paramT</span> $ <span class="entity">mk_d</span> <span class="entity">paramT</span><span class="main">)</span><span class="main">]</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goals</span> <span class="main">=</span> map <span class="entity">mk_goal</span> <span class="main">(</span><span class="entity">map_consts</span> ~~ <span class="main">(</span><span class="entity">dom_eqns</span> ~~ <span class="entity">defl_terms</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goal</span> <span class="main">=</span> <span class="entity">mk_trp</span> <span class="main">(</span>foldr1 <span class="entity">HOLogic.mk_conj</span> <span class="entity">goals</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">adm_rules</span> <span class="main">=</span>
          <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> adm_conj adm_isodefl cont2cont_fst cont2cont_snd cont_id<span class="antiquote">}</span></span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">bottom_rules</span> <span class="main">=</span>
          <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> fst_strict snd_strict isodefl_bottom simp_thms<span class="antiquote">}</span></span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tuple_rules</span> <span class="main">=</span>
          <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> split_def fst_conv snd_conv<span class="antiquote">}</span></span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">map_ID_thms</span> <span class="main">=</span> <span class="entity">Domain_Take_Proofs.get_map_ID_thms</span> <span class="entity">thy</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">map_ID_simps</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">th</span> <span class="main">=&gt;</span> <span class="entity">th</span> RS <span class="entity">sym</span><span class="main">)</span> <span class="entity">map_ID_thms</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">isodefl_rules</span> <span class="main">=</span>
          <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> conjI isodefl_ID_DEFL isodefl_LIFTDEFL<span class="antiquote">}</span></span></span>
          @ <span class="entity">isodefl_abs_rep_thms</span>
          @ Global_Theory.get_thms <span class="entity">thy</span> <span class="inner_quoted">"domain_isodefl"</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        Goal.prove_global <span class="entity">thy</span> <span class="main">[</span><span class="main">]</span> <span class="entity">assms</span> <span class="entity">goal</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span><span class="entity">prems</span><span class="main">,</span> context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
         EVERY
          <span class="main">[</span>rewrite_goals_tac <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">defl_apply_thms</span> @ <span class="entity">map_apply_thms</span><span class="main">)</span><span class="main">,</span>
           resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> cont_parallel_fix_ind<span class="antiquote">}</span></span></span> OF <span class="main">[</span><span class="entity">defl_cont_thm</span><span class="main">,</span> <span class="entity">map_cont_thm</span><span class="main">]</span><span class="main">]</span> <span class="inner_numeral">1</span><span class="main">,</span>
           REPEAT <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="entity">adm_rules</span> <span class="inner_numeral">1</span><span class="main">)</span><span class="main">,</span>
           <span class="entity">simp_tac</span> <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt</span> addsimps <span class="entity">bottom_rules</span><span class="main">)</span> <span class="inner_numeral">1</span><span class="main">,</span>
           <span class="entity">simp_tac</span> <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt</span> addsimps <span class="entity">tuple_rules</span><span class="main">)</span> <span class="inner_numeral">1</span><span class="main">,</span>
           <span class="entity">simp_tac</span> <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt</span> addsimps <span class="entity">map_ID_simps</span><span class="main">)</span> <span class="inner_numeral">1</span><span class="main">,</span>
           REPEAT <span class="main">(</span>eresolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> conjE<span class="antiquote">}</span></span></span> <span class="inner_numeral">1</span><span class="main">)</span><span class="main">,</span>
           REPEAT <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">isodefl_rules</span> @ <span class="entity">prems</span><span class="main">)</span> <span class="inner_numeral">1</span> ORELSE assume_tac <span class="entity">ctxt</span> <span class="inner_numeral">1</span><span class="main">)</span><span class="main">]</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">isodefl_binds</span> <span class="main">=</span> map <span class="main">(</span>Binding.prefix_name <span class="inner_quoted">"isodefl_"</span><span class="main">)</span> <span class="entity">dbinds</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">isodefl_attr</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">attributes</span> <span class="main">[</span><span class="operator">domain_isodefl</span><span class="main">]</span><span class="antiquote">}</span></span></span>
      |&gt; map <span class="main">(</span><span class="entity">Attrib.attribute_global</span> <span class="entity">thy</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">conjuncts</span> <span class="main">[</span><span class="main">]</span> <span class="main">_</span> <span class="main">=</span> <span class="main">[</span><span class="main">]</span>
      <span class="main">|</span> <span class="entity">conjuncts</span> <span class="main">(</span><span class="entity">n</span>::<span class="main">[</span><span class="main">]</span><span class="main">)</span> <span class="entity">thm</span> <span class="main">=</span> <span class="main">[</span><span class="main">(</span><span class="entity">n</span><span class="main">,</span> <span class="entity">thm</span><span class="main">)</span><span class="main">]</span>
      <span class="main">|</span> <span class="entity">conjuncts</span> <span class="main">(</span><span class="entity">n</span>::<span class="entity">ns</span><span class="main">)</span> <span class="entity">thm</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">let</span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thmL</span> <span class="main">=</span> <span class="entity">thm</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> conjunct1<span class="antiquote">}</span></span></span>
          <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thmR</span> <span class="main">=</span> <span class="entity">thm</span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> conjunct2<span class="antiquote">}</span></span></span>
        <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">n</span><span class="main">,</span> <span class="entity">thmL</span><span class="main">)</span>:: <span class="entity">conjuncts</span> <span class="entity">ns</span> <span class="entity">thmR</span> <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">isodefl_thms</span><span class="main">,</span> <span class="entity">thy</span><span class="main">)</span> <span class="main">=</span> <span class="entity">thy</span> |&gt;
      <span class="main">(</span>Global_Theory.add_thms o map <span class="main">(</span>rpair <span class="entity">isodefl_attr</span> o apsnd Drule.zero_var_indexes<span class="main">)</span><span class="main">)</span>
        <span class="main">(</span><span class="entity">conjuncts</span> <span class="entity">isodefl_binds</span> <span class="entity">isodefl_thm</span><span class="main">)</span>

    <span class="comment1">(* prove map_ID theorems *)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prove_map_ID_thm</span>
        <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">map_const</span><span class="main">,</span> <span class="main">(</span><span class="entity">lhsT</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="entity">DEFL_thm</span><span class="main">)</span><span class="main">,</span> <span class="entity">isodefl_thm</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">Ts</span> <span class="main">=</span> <span class="entity">argumentTs</span> <span class="entity">lhsT</span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_cpo</span> <span class="entity">T</span> <span class="main">=</span> Sign.of_sort <span class="entity">thy</span> <span class="main">(</span><span class="entity">T</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">cpo</span><span class="antiquote">}</span></span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs</span> <span class="main">=</span> <span class="entity">list_ccomb</span> <span class="main">(</span><span class="entity">map_const</span><span class="main">,</span> map <span class="entity">mk_ID</span> <span class="main">(</span>filter <span class="entity">is_cpo</span> <span class="entity">Ts</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goal</span> <span class="main">=</span> <span class="entity">mk_eqs</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">mk_ID</span> <span class="entity">lhsT</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">tac</span> <span class="entity">ctxt</span> <span class="main">=</span> EVERY
          <span class="main">[</span>resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> isodefl_DEFL_imp_ID<span class="antiquote">}</span></span></span> <span class="inner_numeral">1</span><span class="main">,</span>
           <span class="entity">stac</span> <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> DEFL_app<span class="antiquote">}</span></span></span> <span class="inner_numeral">1</span><span class="main">,</span>
           <span class="entity">stac</span> <span class="entity">ctxt</span> <span class="entity">DEFL_thm</span> <span class="inner_numeral">1</span><span class="main">,</span>
           resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">isodefl_thm</span><span class="main">]</span> <span class="inner_numeral">1</span><span class="main">,</span>
           REPEAT <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> isodefl_ID_DEFL isodefl_LIFTDEFL<span class="antiquote">}</span></span></span> <span class="inner_numeral">1</span><span class="main">)</span><span class="main">]</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        Goal.prove_global <span class="entity">thy</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">goal</span> <span class="main">(</span><span class="entity">tac</span> o <span class="main">#</span>context<span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">map_ID_binds</span> <span class="main">=</span> map <span class="main">(</span>Binding.suffix_name <span class="inner_quoted">"_map_ID"</span><span class="main">)</span> <span class="entity">dbinds</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">map_ID_thms</span> <span class="main">=</span>
      map <span class="entity">prove_map_ID_thm</span>
        <span class="main">(</span><span class="entity">map_consts</span> ~~ <span class="entity">dom_eqns</span> ~~ <span class="entity">tc_defs</span> ~~ <span class="entity">isodefl_thms</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">thy</span><span class="main">)</span> <span class="main">=</span> <span class="entity">thy</span> |&gt;
      <span class="main">(</span>Global_Theory.add_thms o map <span class="main">(</span>rpair <span class="main">[</span><span class="entity">Domain_Take_Proofs.map_ID_add</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
        <span class="main">(</span><span class="entity">map_ID_binds</span> ~~ <span class="entity">map_ID_thms</span><span class="main">)</span>

    <span class="comment1">(* definitions and proofs related to take functions *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">take_info</span><span class="main">,</span> <span class="entity">thy</span><span class="main">)</span> <span class="main">=</span>
        <span class="entity">Domain_Take_Proofs.define_take_functions</span>
          <span class="main">(</span><span class="entity">dbinds</span> ~~ <span class="entity">iso_infos</span><span class="main">)</span> <span class="entity">thy</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">{</span> <span class="entity">take_consts</span><span class="main">,</span> <span class="entity">chain_take_thms</span><span class="main">,</span> <span class="entity">take_0_thms</span><span class="main">,</span> <span class="entity">take_Suc_thms</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=</span>
        <span class="entity">take_info</span>

    <span class="comment1">(* least-upper-bound lemma for take functions *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lub_take_lemma</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs</span> <span class="main">=</span> <span class="entity">mk_tuple</span> <span class="main">(</span>map <span class="entity">mk_lub</span> <span class="entity">take_consts</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">is_cpo</span> <span class="entity">T</span> <span class="main">=</span> Sign.of_sort <span class="entity">thy</span> <span class="main">(</span><span class="entity">T</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">cpo</span><span class="antiquote">}</span></span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_map_ID</span> <span class="main">(</span><span class="entity">map_const</span><span class="main">,</span> <span class="main">(</span><span class="entity">lhsT</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
          <span class="entity">list_ccomb</span> <span class="main">(</span><span class="entity">map_const</span><span class="main">,</span> map <span class="entity">mk_ID</span> <span class="main">(</span>filter <span class="entity">is_cpo</span> <span class="main">(</span><span class="entity">argumentTs</span> <span class="entity">lhsT</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs</span> <span class="main">=</span> <span class="entity">mk_tuple</span> <span class="main">(</span>map <span class="entity">mk_map_ID</span> <span class="main">(</span><span class="entity">map_consts</span> ~~ <span class="entity">dom_eqns</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goal</span> <span class="main">=</span> <span class="entity">mk_trp</span> <span class="main">(</span><span class="entity">mk_eq</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">map_ID_thms</span> <span class="main">=</span> <span class="entity">Domain_Take_Proofs.get_map_ID_thms</span> <span class="entity">thy</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">start_rules</span> <span class="main">=</span>
            <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> lub_Pair <span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> ch2ch_Pair<span class="antiquote">}</span></span></span> @ <span class="entity">chain_take_thms</span>
            @ <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> prod.collapse split_def<span class="antiquote">}</span></span></span>
            @ <span class="entity">map_apply_thms</span> @ <span class="entity">map_ID_thms</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rules0</span> <span class="main">=</span>
            <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> iterate_0 Pair_strict<span class="antiquote">}</span></span></span> @ <span class="entity">take_0_thms</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rules1</span> <span class="main">=</span>
            <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> iterate_Suc prod_eq_iff fst_conv snd_conv<span class="antiquote">}</span></span></span>
            @ <span class="entity">take_Suc_thms</span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">tac</span> <span class="entity">ctxt</span> <span class="main">=</span>
            EVERY
            <span class="main">[</span><span class="entity">simp_tac</span> <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt</span> addsimps <span class="entity">start_rules</span><span class="main">)</span> <span class="inner_numeral">1</span><span class="main">,</span>
             <span class="entity">simp_tac</span> <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt</span> addsimps <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> fix_def2<span class="antiquote">}</span></span></span><span class="main">)</span> <span class="inner_numeral">1</span><span class="main">,</span>
             resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> lub_eq<span class="antiquote">}</span></span></span> <span class="inner_numeral">1</span><span class="main">,</span>
             resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> nat.induct<span class="antiquote">}</span></span></span> <span class="inner_numeral">1</span><span class="main">,</span>
             <span class="entity">simp_tac</span> <span class="main">(</span>put_simpset <span class="entity">HOL_basic_ss</span> <span class="entity">ctxt</span> addsimps <span class="entity">rules0</span><span class="main">)</span> <span class="inner_numeral">1</span><span class="main">,</span>
             <span class="entity">asm_full_simp_tac</span> <span class="main">(</span>put_simpset <span class="entity">beta_ss</span> <span class="entity">ctxt</span> addsimps <span class="entity">rules1</span><span class="main">)</span> <span class="inner_numeral">1</span><span class="main">]</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        Goal.prove_global <span class="entity">thy</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">goal</span> <span class="main">(</span><span class="entity">tac</span> o <span class="main">#</span>context<span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="comment1">(* prove lub of take equals ID *)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prove_lub_take</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">dbind</span><span class="main">,</span> <span class="entity">take_const</span><span class="main">)</span><span class="main">,</span> <span class="entity">map_ID_thm</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">lhsT</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">)</span> <span class="entity">thy</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">n</span> <span class="main">=</span> Free <span class="main">(</span><span class="inner_quoted">"n"</span><span class="main">,</span> <span class="entity">natT</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">goal</span> <span class="main">=</span> <span class="entity">mk_eqs</span> <span class="main">(</span><span class="entity">mk_lub</span> <span class="main">(</span>lambda <span class="entity">n</span> <span class="main">(</span><span class="entity">take_const</span> $ <span class="entity">n</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="entity">mk_ID</span> <span class="entity">lhsT</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">tac</span> <span class="entity">ctxt</span> <span class="main">=</span>
            EVERY
            <span class="main">[</span>resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> trans<span class="antiquote">}</span></span></span> <span class="inner_numeral">1</span><span class="main">,</span>
             resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">map_ID_thm</span><span class="main">]</span> <span class="inner_numeral">2</span><span class="main">,</span>
             cut_facts_tac <span class="main">[</span><span class="entity">lub_take_lemma</span><span class="main">]</span> <span class="inner_numeral">1</span><span class="main">,</span>
             REPEAT <span class="main">(</span>eresolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> Pair_inject<span class="antiquote">}</span></span></span> <span class="inner_numeral">1</span><span class="main">)</span><span class="main">,</span> assume_tac <span class="entity">ctxt</span> <span class="inner_numeral">1</span><span class="main">]</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lub_take_thm</span> <span class="main">=</span> Goal.prove_global <span class="entity">thy</span> <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="entity">goal</span> <span class="main">(</span><span class="entity">tac</span> o <span class="main">#</span>context<span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="entity">add_qualified_thm</span> <span class="inner_quoted">"lub_take"</span> <span class="main">(</span><span class="entity">dbind</span><span class="main">,</span> <span class="entity">lub_take_thm</span><span class="main">)</span> <span class="entity">thy</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">lub_take_thms</span><span class="main">,</span> <span class="entity">thy</span><span class="main">)</span> <span class="main">=</span>
        fold_map <span class="entity">prove_lub_take</span>
          <span class="main">(</span><span class="entity">dbinds</span> ~~ <span class="entity">take_consts</span> ~~ <span class="entity">map_ID_thms</span> ~~ <span class="entity">dom_eqns</span><span class="main">)</span> <span class="entity">thy</span>

    <span class="comment1">(* prove additional take theorems *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">take_info2</span><span class="main">,</span> <span class="entity">thy</span><span class="main">)</span> <span class="main">=</span>
        <span class="entity">Domain_Take_Proofs.add_lub_take_theorems</span>
          <span class="main">(</span><span class="entity">dbinds</span> ~~ <span class="entity">iso_infos</span><span class="main">)</span> <span class="entity">take_info</span> <span class="entity">lub_take_thms</span> <span class="entity">thy</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">fmapU_const</span> <span class="entity">T</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">U</span> <span class="main">=</span> <span class="entity">mk_appT</span> <span class="entity">udomT</span> <span class="entity">T</span>
      <span class="keyword2"><span class="keyword">in</span></span> Const <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> fmapU<span class="antiquote">}</span></span><span class="main">,</span> <span class="main">(</span><span class="entity">udomT</span> <span class="entity">-&gt;&gt;</span> <span class="entity">udomT</span><span class="main">)</span> <span class="entity">-&gt;&gt;</span> <span class="main">(</span><span class="entity">U</span> <span class="entity">-&gt;&gt;</span> <span class="entity">U</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>

    <span class="comment1">(* instantiate prefunctor class *)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">inst_prefunctor</span> <span class="main">(</span><span class="entity">map_const</span><span class="main">,</span> <span class="main">(</span><span class="main">(</span><span class="entity">lhsT</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span><span class="main">,</span> <span class="entity">tbind</span><span class="main">)</span><span class="main">)</span> <span class="entity">thy</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">tyconT</span><span class="main">)</span> <span class="main">=</span> <span class="entity">dest_appT</span> <span class="entity">lhsT</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">full_tname</span><span class="main">,</span> <span class="entity">Ts</span><span class="main">)</span> <span class="main">=</span> dest_Type <span class="entity">tyconT</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs_tfrees</span> <span class="main">=</span> map dest_TFree <span class="entity">Ts</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">argTs</span> <span class="main">=</span> filter <span class="main">(</span><span class="entity">is_cpo</span> <span class="entity">thy</span><span class="main">)</span> <span class="entity">Ts</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">U</span> <span class="main">=</span> <span class="entity">mk_appT</span> <span class="entity">udomT</span> <span class="entity">tyconT</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mapT</span> <span class="main">=</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">T</span> <span class="main">=&gt;</span> <span class="entity">T</span> <span class="entity">-&gt;&gt;</span> <span class="entity">T</span><span class="main">)</span> <span class="entity">argTs</span> <span class="entity">--&gt;&gt;</span> <span class="main">(</span><span class="entity">udomT</span> <span class="entity">-&gt;&gt;</span> <span class="entity">udomT</span><span class="main">)</span> <span class="entity">-&gt;&gt;</span> <span class="main">(</span><span class="entity">U</span> <span class="entity">-&gt;&gt;</span> <span class="entity">U</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">mapC</span> <span class="main">=</span> Const <span class="main">(</span>fst <span class="main">(</span>dest_Const <span class="entity">map_const</span><span class="main">)</span><span class="main">,</span> <span class="entity">mapT</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fmap_rhs</span> <span class="main">=</span> <span class="entity">list_ccomb</span> <span class="main">(</span><span class="entity">mapC</span><span class="main">,</span> map <span class="entity">mk_ID</span> <span class="entity">argTs</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fmap_eqn</span> <span class="main">=</span> Logic.mk_equals <span class="main">(</span><span class="entity">fmapU_const</span> <span class="entity">tyconT</span><span class="main">,</span> <span class="entity">fmap_rhs</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fmap_def_bind</span> <span class="main">=</span> <span class="entity">tbind</span>
          |&gt; Binding.suffix_name <span class="inner_quoted">"_def"</span>
          |&gt; Binding.prefix_name <span class="inner_quoted">"fmapU_"</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">fmap_ldef</span><span class="main">)</span><span class="main">)</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span> <span class="main">=</span> <span class="entity">thy</span>
          |&gt; <span class="entity">Class.instantiation</span> <span class="main">(</span><span class="main">[</span><span class="entity">full_tname</span><span class="main">]</span><span class="main">,</span> <span class="entity">lhs_tfrees</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">prefunctor</span><span class="antiquote">}</span></span><span class="main">)</span>
          |&gt; <span class="entity">Specification.definition</span> NONE <span class="main">[</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span> <span class="main">(</span><span class="main">(</span><span class="entity">fmap_def_bind</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">fmap_eqn</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt_thy</span> <span class="main">=</span> Proof_Context.init_global <span class="main">(</span>Proof_Context.theory_of <span class="entity">lthy</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fmap_def</span> <span class="main">=</span> singleton <span class="main">(</span>Proof_Context.export <span class="entity">lthy</span> <span class="entity">ctxt_thy</span><span class="main">)</span> <span class="entity">fmap_ldef</span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">tacf</span> <span class="entity">ctxt</span> <span class="main">=</span> EVERY
          <span class="main">[</span><span class="entity">Class.intro_classes_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="main">]</span><span class="main">,</span>
           rewrite_goals_tac <span class="entity">ctxt</span> <span class="main">(</span><span class="entity">fmap_def</span> :: <span class="entity">tc_defs</span><span class="main">)</span><span class="main">,</span>
           resolve_tac <span class="entity">ctxt</span> <span class="entity">isodefl_thms</span> <span class="inner_numeral">1</span><span class="main">,</span>
           REPEAT <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> isodefl_ID_DEFL isodefl_LIFTDEFL isodefl_cast<span class="antiquote">}</span></span></span> <span class="inner_numeral">1</span><span class="main">)</span><span class="main">]</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> <span class="entity">lthy</span>
          |&gt; <span class="entity">Class.prove_instantiation_exit</span> <span class="entity">tacf</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="main">(</span><span class="entity">fmap_def</span><span class="main">,</span> <span class="entity">thy</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">fmap_defs</span><span class="main">,</span> <span class="entity">thy</span><span class="main">)</span> <span class="main">=</span> fold_map <span class="entity">inst_prefunctor</span>
      <span class="main">(</span><span class="entity">map_consts</span> ~~ <span class="main">(</span><span class="entity">dom_eqns</span> ~~ <span class="entity">dbinds</span><span class="main">)</span><span class="main">)</span> <span class="entity">thy</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="main">(</span><span class="main">(</span><span class="entity">iso_infos</span><span class="main">,</span> <span class="entity">take_info2</span><span class="main">)</span><span class="main">,</span> <span class="entity">thy</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="comment1">(******************************************************************************)</span>
<span class="comment1">(****************************** top-level command *****************************)</span>
<span class="comment1">(******************************************************************************)</span>

<span class="comment1">(* ----- calls for building new thy and thms -------------------------------- *)</span>

<span class="keyword1"><span class="keyword">type</span></span> <span class="entity">info</span> <span class="main">=</span>
     <span class="entity">Domain_Take_Proofs.iso_info</span> list * <span class="entity">Domain_Take_Proofs.take_induct_info</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">add_arity</span> <span class="main">(</span><span class="main">(</span><span class="entity">b</span><span class="main">,</span> <span class="entity">sorts</span><span class="main">,</span> <span class="entity">mx</span><span class="main">)</span><span class="main">,</span> <span class="entity">sort</span><span class="main">)</span> <span class="entity">thy</span> <span class="main">:</span> theory <span class="main">=</span>
  <span class="entity">thy</span>
  |&gt; Sign.add_types_global <span class="main">[</span><span class="main">(</span><span class="entity">b</span><span class="main">,</span> length <span class="entity">sorts</span><span class="main">,</span> <span class="entity">mx</span><span class="main">)</span><span class="main">]</span>
  |&gt; <span class="entity">Axclass.arity_axiomatization</span> <span class="main">(</span>Sign.full_name <span class="entity">thy</span> <span class="entity">b</span><span class="main">,</span> <span class="entity">sorts</span><span class="main">,</span> <span class="entity">sort</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">gen_add_tycon</span>
    <span class="main">(</span><span class="entity">prep_sort</span> <span class="main">:</span> theory <span class="main">-&gt;</span> 'a <span class="main">-&gt;</span> sort<span class="main">)</span>
    <span class="main">(</span><span class="entity">prep_typ</span> <span class="main">:</span> theory <span class="main">-&gt;</span> <span class="main">(</span>string * sort<span class="main">)</span> list <span class="main">-&gt;</span> 'b <span class="main">-&gt;</span> typ<span class="main">)</span>
    <span class="main">(</span><span class="entity">arg_sort</span> <span class="main">:</span> bool <span class="main">-&gt;</span> sort<span class="main">)</span>
    <span class="main">(</span><span class="entity">raw_specs</span> <span class="main">:</span> <span class="main">(</span>string * <span class="main">(</span>string * 'a<span class="main">)</span> list * binding * mixfix *
               <span class="main">(</span>binding * <span class="main">(</span>bool * binding option * 'b<span class="main">)</span> list * mixfix<span class="main">)</span> list<span class="main">)</span> list<span class="main">)</span>
    <span class="main">(</span><span class="entity">thy</span> <span class="main">:</span> theory<span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dtnvs0</span> <span class="main">:</span> <span class="main">(</span>binding * <span class="main">(</span>string * sort<span class="main">)</span> list * mixfix<span class="main">)</span> list <span class="main">=</span>
        map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="entity">vs</span><span class="main">,</span> <span class="entity">dbind</span><span class="main">,</span> <span class="entity">mx</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span>
            <span class="main">(</span><span class="entity">dbind</span><span class="main">,</span> map <span class="main">(</span>apsnd <span class="main">(</span><span class="entity">prep_sort</span> <span class="entity">thy</span><span class="main">)</span><span class="main">)</span> <span class="entity">vs</span><span class="main">,</span> <span class="entity">mx</span><span class="main">)</span><span class="main">)</span> <span class="entity">raw_specs</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dtnvs</span> <span class="main">:</span> <span class="main">(</span>binding * typ list * mixfix<span class="main">)</span> list <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prep_tvar</span> <span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="entity">s</span><span class="main">)</span> <span class="main">=</span> TFree <span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="entity">prep_sort</span> <span class="entity">thy</span> <span class="entity">s</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="entity">vs</span><span class="main">,</span> <span class="entity">dbind</span><span class="main">,</span> <span class="entity">mx</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span>
                <span class="main">(</span><span class="entity">dbind</span><span class="main">,</span> map <span class="entity">prep_tvar</span> <span class="entity">vs</span><span class="main">,</span> <span class="entity">mx</span><span class="main">)</span><span class="main">)</span> <span class="entity">raw_specs</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">thy_arity</span> <span class="main">(</span><span class="entity">dbind</span><span class="main">,</span> <span class="entity">tvars</span><span class="main">,</span> <span class="entity">mx</span><span class="main">)</span> <span class="main">=</span>
      <span class="main">(</span><span class="main">(</span><span class="entity">dbind</span><span class="main">,</span> map <span class="main">(</span>snd o dest_TFree<span class="main">)</span> <span class="entity">tvars</span><span class="main">,</span> <span class="entity">mx</span><span class="main">)</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">tycon</span><span class="antiquote">}</span></span><span class="main">)</span>

    <span class="comment1">(* this theory is used just for parsing and error checking *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tmp_thy</span> <span class="main">=</span> <span class="entity">thy</span>
      |&gt; fold <span class="main">(</span><span class="entity">add_arity</span> o <span class="entity">thy_arity</span><span class="main">)</span> <span class="entity">dtnvs</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dbinds</span> <span class="main">:</span> binding list <span class="main">=</span>
        map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span><span class="main">_</span><span class="main">,</span><span class="entity">dbind</span><span class="main">,</span><span class="main">_</span><span class="main">,</span><span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">dbind</span><span class="main">)</span> <span class="entity">raw_specs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">raw_rhss</span> <span class="main">:</span>
        <span class="main">(</span>binding * <span class="main">(</span>bool * binding option * 'b<span class="main">)</span> list * mixfix<span class="main">)</span> list list <span class="main">=</span>
        map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span><span class="main">_</span><span class="main">,</span><span class="main">_</span><span class="main">,</span><span class="main">_</span><span class="main">,</span><span class="entity">cons</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="entity">cons</span><span class="main">)</span> <span class="entity">raw_specs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dtnvs'</span> <span class="main">:</span> <span class="main">(</span>string * typ list<span class="main">)</span> list <span class="main">=</span>
        map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="entity">dbind</span><span class="main">,</span> <span class="entity">vs</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span>Sign.full_name <span class="entity">thy</span> <span class="entity">dbind</span><span class="main">,</span> <span class="entity">vs</span><span class="main">)</span><span class="main">)</span> <span class="entity">dtnvs</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_cons</span> <span class="main">=</span> map <span class="main">(</span>Binding.name_of o <span class="entity">first</span><span class="main">)</span> <span class="main">(</span>flat <span class="entity">raw_rhss</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">case</span></span> duplicates <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">all_cons</span> <span class="keyword2"><span class="keyword">of</span></span> 
        <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> false <span class="main">|</span> <span class="entity">dups</span> <span class="main">=&gt;</span> error <span class="main">(</span><span class="inner_quoted">"Duplicate constructors: "</span> 
                                      ^ commas_quote <span class="entity">dups</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_sels</span> <span class="main">=</span>
      <span class="main">(</span>map Binding.name_of o map_filter <span class="entity">second</span> o maps <span class="entity">second</span><span class="main">)</span> <span class="main">(</span>flat <span class="entity">raw_rhss</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">case</span></span> duplicates <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">all_sels</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> false <span class="main">|</span> <span class="entity">dups</span> <span class="main">=&gt;</span> error<span class="main">(</span><span class="inner_quoted">"Duplicate selectors: "</span>^commas_quote <span class="entity">dups</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">test_dupl_tvars</span> <span class="entity">s</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">case</span></span> duplicates <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="main">(</span>map<span class="main">(</span>fst o dest_TFree<span class="main">)</span><span class="entity">s</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> false <span class="main">|</span> <span class="entity">dups</span> <span class="main">=&gt;</span> error<span class="main">(</span><span class="inner_quoted">"Duplicate type arguments: "</span> 
                                    ^commas_quote <span class="entity">dups</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> exists <span class="entity">test_dupl_tvars</span> <span class="main">(</span>map snd <span class="entity">dtnvs'</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">param</span> <span class="main">:</span> string * sort <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_params</span> <span class="main">=</span> map <span class="main">#</span><span class="inner_numeral">1</span> <span class="entity">raw_specs</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="keyword2"><span class="keyword">case</span></span> distinct <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">all_params</span> <span class="keyword2"><span class="keyword">of</span></span>
          <span class="main">[</span><span class="entity">param</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">param</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">domain</span><span class="antiquote">}</span></span><span class="main">)</span>
        <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> error <span class="inner_quoted">"Mutually recursive domains must have same type parameter"</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sorts</span> <span class="main">:</span> <span class="main">(</span>string * sort<span class="main">)</span> list <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">all_sorts</span> <span class="main">=</span> map <span class="main">(</span>map dest_TFree o snd<span class="main">)</span> <span class="entity">dtnvs'</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="keyword2"><span class="keyword">case</span></span> distinct <span class="main">(</span>eq_set <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span><span class="main">)</span> <span class="entity">all_sorts</span> <span class="keyword2"><span class="keyword">of</span></span>
          <span class="main">[</span><span class="entity">sorts</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="entity">sorts</span>
        <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> error <span class="inner_quoted">"Mutually recursive domains must have same type parameters"</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sorts'</span> <span class="main">:</span> <span class="main">(</span>string * sort<span class="main">)</span> list <span class="main">=</span> <span class="entity">param</span> :: <span class="entity">sorts</span>

    <span class="comment1">(* a lazy argument may have an unpointed type *)</span>
    <span class="comment1">(* unless the argument has a selector function *)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">check_pcpo</span> <span class="main">(</span><span class="entity">lazy</span><span class="main">,</span> <span class="entity">sel</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sort</span> <span class="main">=</span> <span class="entity">arg_sort</span> <span class="main">(</span><span class="entity">lazy</span> <span class="keyword1"><span class="keyword">andalso</span></span> is_none <span class="entity">sel</span><span class="main">)</span> <span class="keyword2"><span class="keyword">in</span></span>
        <span class="keyword2"><span class="keyword">if</span></span> Sign.of_sort <span class="entity">tmp_thy</span> <span class="main">(</span><span class="entity">T</span><span class="main">,</span> <span class="entity">sort</span><span class="main">)</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">(</span><span class="main">)</span>
        <span class="keyword2"><span class="keyword">else</span></span> error <span class="main">(</span><span class="inner_quoted">"Constructor argument type is not of sort "</span> ^
                    Syntax.string_of_sort_global <span class="entity">tmp_thy</span> <span class="entity">sort</span> ^ <span class="inner_quoted">": "</span> ^
                    Syntax.string_of_typ_global <span class="entity">tmp_thy</span> <span class="entity">T</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>

    <span class="comment1">(* test for free type variables, illegal sort constraints on rhs,
       non-pcpo-types and invalid use of recursive type
       replace sorts in type variables on rhs *)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rec_tab</span> <span class="main">=</span> <span class="entity">Domain_Take_Proofs.get_rec_tab</span> <span class="entity">thy</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">check_rec</span> <span class="main">_</span> <span class="main">(</span><span class="entity">T</span> <span class="keyword1"><span class="keyword">as</span></span> TFree <span class="main">(</span><span class="entity">v</span><span class="main">,</span><span class="main">_</span><span class="main">)</span><span class="main">)</span>  <span class="main">=</span>
        <span class="keyword2"><span class="keyword">if</span></span> AList.defined <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">sorts'</span> <span class="entity">v</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">T</span>
        <span class="keyword2"><span class="keyword">else</span></span> error <span class="main">(</span><span class="inner_quoted">"Free type variable "</span> ^ quote <span class="entity">v</span> ^ <span class="inner_quoted">" on rhs."</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">check_rec</span> <span class="entity">no_rec</span> <span class="main">(</span><span class="entity">T</span> <span class="keyword1"><span class="keyword">as</span></span> Type <span class="main">(</span><span class="entity">s</span><span class="main">,</span> <span class="entity">Ts</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
        <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> AList.lookup <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="entity">dtnvs'</span> <span class="entity">s</span> <span class="keyword2"><span class="keyword">of</span></span>
          NONE <span class="main">=&gt;</span>
            <span class="keyword2"><span class="keyword">let</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">no_rec'</span> <span class="main">=</span>
                  <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">no_rec</span> <span class="main">=</span> NONE <span class="keyword2"><span class="keyword">then</span></span>
                    <span class="keyword2"><span class="keyword">if</span></span> Symtab.defined <span class="entity">rec_tab</span> <span class="entity">s</span> <span class="keyword2"><span class="keyword">then</span></span> NONE <span class="keyword2"><span class="keyword">else</span></span> SOME <span class="entity">s</span>
                  <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">no_rec</span>
            <span class="keyword2"><span class="keyword">in</span></span> Type <span class="main">(</span><span class="entity">s</span><span class="main">,</span> map <span class="main">(</span><span class="entity">check_rec</span> <span class="entity">no_rec'</span><span class="main">)</span> <span class="entity">Ts</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>
        <span class="main">|</span> SOME <span class="entity">typevars</span> <span class="main">=&gt;</span>
          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">typevars</span> &lt;&gt; <span class="entity">Ts</span>
          <span class="keyword2"><span class="keyword">then</span></span> error <span class="main">(</span><span class="inner_quoted">"Recursion of type "</span> ^ 
                      quote <span class="main">(</span>Syntax.string_of_typ_global <span class="entity">tmp_thy</span> <span class="entity">T</span><span class="main">)</span> ^ 
                      <span class="inner_quoted">" with different arguments"</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">case</span></span> <span class="entity">no_rec</span> <span class="keyword2"><span class="keyword">of</span></span>
                  NONE <span class="main">=&gt;</span> <span class="entity">T</span>
                <span class="main">|</span> SOME <span class="entity">c</span> <span class="main">=&gt;</span>
                  error <span class="main">(</span><span class="inner_quoted">"Illegal indirect recursion of type "</span> ^ 
                         quote <span class="main">(</span>Syntax.string_of_typ_global <span class="entity">tmp_thy</span> <span class="entity">T</span><span class="main">)</span> ^
                         <span class="inner_quoted">" under type constructor "</span> ^ quote <span class="entity">c</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">check_rec</span> <span class="main">_</span> <span class="main">(</span>TVar <span class="main">_</span><span class="main">)</span> <span class="main">=</span> error <span class="inner_quoted">"extender:check_rec"</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prep_arg</span> <span class="main">(</span><span class="entity">lazy</span><span class="main">,</span> <span class="entity">sel</span><span class="main">,</span> <span class="entity">raw_T</span><span class="main">)</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">T</span> <span class="main">=</span> <span class="entity">prep_typ</span> <span class="entity">tmp_thy</span> <span class="entity">sorts</span> <span class="entity">raw_T</span>
<span class="comment1">(*
        val _ = check_rec NONE T
*)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="entity">check_pcpo</span> <span class="main">(</span><span class="entity">lazy</span><span class="main">,</span> <span class="entity">sel</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span> <span class="main">(</span><span class="entity">lazy</span><span class="main">,</span> <span class="entity">sel</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prep_con</span> <span class="main">(</span><span class="entity">b</span><span class="main">,</span> <span class="entity">args</span><span class="main">,</span> <span class="entity">mx</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="entity">b</span><span class="main">,</span> map <span class="entity">prep_arg</span> <span class="entity">args</span><span class="main">,</span> <span class="entity">mx</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prep_rhs</span> <span class="entity">cons</span> <span class="main">=</span> map <span class="entity">prep_con</span> <span class="entity">cons</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhss</span> <span class="main">:</span> <span class="main">(</span>binding * <span class="main">(</span>bool * binding option * typ<span class="main">)</span> list * mixfix<span class="main">)</span> list list <span class="main">=</span>
        map <span class="entity">prep_rhs</span> <span class="entity">raw_rhss</span>

    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_arg_typ</span> <span class="main">(</span><span class="entity">lazy</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="entity">T</span><span class="main">)</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">lazy</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">mk_upT</span> <span class="entity">T</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">T</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_con_typ</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">args</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span>
        <span class="keyword2"><span class="keyword">if</span></span> null <span class="entity">args</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="entity">oneT</span> <span class="keyword2"><span class="keyword">else</span></span> foldr1 <span class="entity">mk_sprodT</span> <span class="main">(</span>map <span class="entity">mk_arg_typ</span> <span class="entity">args</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_rhs_typ</span> <span class="entity">cons</span> <span class="main">=</span> foldr1 <span class="entity">mk_ssumT</span> <span class="main">(</span>map <span class="entity">mk_con_typ</span> <span class="entity">cons</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">repTs</span> <span class="main">:</span> typ list <span class="main">=</span> map <span class="entity">mk_rhs_typ</span> <span class="entity">rhss</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">doms</span> <span class="main">:</span> <span class="main">(</span><span class="main">(</span>string * sort<span class="main">)</span> list * binding * mixfix * typ * <span class="main">(</span>binding * binding<span class="main">)</span> option<span class="main">)</span> list <span class="main">=</span>
      map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">tbind</span><span class="main">,</span> <span class="entity">vs</span><span class="main">,</span> <span class="entity">mx</span><span class="main">)</span><span class="main">,</span> <span class="entity">repT</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">vs</span><span class="main">,</span> <span class="entity">tbind</span><span class="main">,</span> <span class="entity">mx</span><span class="main">,</span> <span class="entity">repT</span><span class="main">,</span> NONE<span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="entity">dtnvs0</span> ~~ <span class="entity">repTs</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">iso_infos</span><span class="main">,</span> <span class="entity">take_info</span><span class="main">)</span><span class="main">,</span> <span class="entity">thy</span><span class="main">)</span> <span class="main">=</span> <span class="entity">domain_isomorphism</span> <span class="main">(</span>fst <span class="entity">param</span><span class="main">)</span> <span class="entity">doms</span> <span class="entity">thy</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">constr_infos</span><span class="main">,</span> <span class="entity">thy</span><span class="main">)</span> <span class="main">=</span>
        <span class="entity">thy</span>
          |&gt; fold_map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">dbind</span><span class="main">,</span> <span class="entity">cons</span><span class="main">)</span><span class="main">,</span> <span class="entity">info</span><span class="main">)</span> <span class="main">=&gt;</span>
                <span class="entity">Domain_Constructors.add_domain_constructors</span> <span class="entity">dbind</span> <span class="entity">cons</span> <span class="entity">info</span><span class="main">)</span>
             <span class="main">(</span><span class="entity">dbinds</span> ~~ <span class="entity">rhss</span> ~~ <span class="entity">iso_infos</span><span class="main">)</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">thy</span><span class="main">)</span> <span class="main">=</span>
        <span class="entity">Domain_Induction.comp_theorems</span>
          <span class="entity">dbinds</span> <span class="entity">take_info</span> <span class="entity">constr_infos</span> <span class="entity">thy</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">thy</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">rep_arg</span> <span class="entity">lazy</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">lazy</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">predomain</span><span class="antiquote">}</span></span> <span class="keyword2"><span class="keyword">else</span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">sort</span> <span class="quoted">"domain"</span><span class="antiquote">}</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">read_sort</span> <span class="entity">thy</span> <span class="main">(</span>SOME <span class="entity">s</span><span class="main">)</span> <span class="main">=</span> Syntax.read_sort_global <span class="entity">thy</span> <span class="entity">s</span>
  <span class="main">|</span> <span class="entity">read_sort</span> <span class="entity">thy</span> NONE <span class="main">=</span> Sign.defaultS <span class="entity">thy</span>

<span class="comment1">(* Adapted from src/HOL/Tools/Datatype/datatype_data.ML *)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">read_typ</span> <span class="entity">thy</span> <span class="entity">sorts</span> <span class="entity">str</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctxt</span> <span class="main">=</span> Proof_Context.init_global <span class="entity">thy</span>
      |&gt; fold <span class="main">(</span>Variable.declare_typ o TFree<span class="main">)</span> <span class="entity">sorts</span>
  <span class="keyword2"><span class="keyword">in</span></span> Syntax.read_typ <span class="entity">ctxt</span> <span class="entity">str</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">cert_typ</span> <span class="entity">sign</span> <span class="entity">sorts</span> <span class="entity">raw_T</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">T</span> <span class="main">=</span> Type.no_tvars <span class="main">(</span>Sign.certify_typ <span class="entity">sign</span> <span class="entity">raw_T</span><span class="main">)</span>
      <span class="keyword3"><span class="keyword">handle</span></span> TYPE <span class="main">(</span><span class="entity">msg</span><span class="main">,</span> <span class="main">_</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> error <span class="entity">msg</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">sorts'</span> <span class="main">=</span> Term.add_tfreesT <span class="entity">T</span> <span class="entity">sorts</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
      <span class="keyword2"><span class="keyword">case</span></span> duplicates <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span><span class="main">)</span> <span class="main">(</span>map fst <span class="entity">sorts'</span><span class="main">)</span> <span class="keyword2"><span class="keyword">of</span></span>
        <span class="main">[</span><span class="main">]</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="main">)</span>
      <span class="main">|</span> <span class="entity">dups</span> <span class="main">=&gt;</span> error <span class="main">(</span><span class="inner_quoted">"Inconsistent sort constraints for "</span> ^ commas <span class="entity">dups</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span> <span class="entity">T</span> <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">add_tycon</span> <span class="main">=</span>
    <span class="entity">gen_add_tycon</span> <span class="main">(</span>K I<span class="main">)</span> <span class="entity">cert_typ</span> <span class="entity">rep_arg</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">add_tycon_cmd</span> <span class="main">=</span>
    <span class="entity">gen_add_tycon</span> <span class="entity">read_sort</span> <span class="entity">read_typ</span> <span class="entity">rep_arg</span>


<span class="comment1">(** outer syntax **)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">dest_decl</span> <span class="main">:</span> <span class="main">(</span>bool * binding option * string<span class="main">)</span> parser <span class="main">=</span>
  <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">keyword</span> "<span class="keyword2">(</span>"<span class="antiquote">}</span></span></span> |-- Scan.optional <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">keyword</span> "<span class="keyword2">lazy</span>"<span class="antiquote">}</span></span></span> &gt;&gt; K true<span class="main">)</span> false --
    <span class="main">(</span>Parse.binding &gt;&gt; SOME<span class="main">)</span> -- <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">keyword</span> "<span class="keyword2">::</span>"<span class="antiquote">}</span></span></span> |-- Parse.typ<span class="main">)</span>  --| <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">keyword</span> "<span class="keyword2">)</span>"<span class="antiquote">}</span></span></span> &gt;&gt; Scan.triple1
    || <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">keyword</span> "<span class="keyword2">(</span>"<span class="antiquote">}</span></span></span> |-- <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">keyword</span> "<span class="keyword2">lazy</span>"<span class="antiquote">}</span></span></span> |-- Parse.typ --| <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">keyword</span> "<span class="keyword2">)</span>"<span class="antiquote">}</span></span></span>
    &gt;&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="main">=&gt;</span> <span class="main">(</span>true<span class="main">,</span>NONE<span class="main">,</span><span class="entity">t</span><span class="main">)</span><span class="main">)</span>
    || Parse.typ &gt;&gt; <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">t</span> <span class="main">=&gt;</span> <span class="main">(</span>false<span class="main">,</span>NONE<span class="main">,</span><span class="entity">t</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cons_decl</span> <span class="main">=</span>
  Parse.binding -- Scan.repeat <span class="entity">dest_decl</span> -- Parse.opt_mixfix

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tycon_decl</span> <span class="main">=</span>
  <span class="main">(</span>Parse.type_ident --| <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">keyword</span> "<span class="keyword2">⋅</span>"<span class="antiquote">}</span></span></span> -- Parse.type_args_constrained --
    Parse.binding -- Parse.opt_mixfix<span class="main">)</span> --
    <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">keyword</span> "<span class="keyword2">=</span>"<span class="antiquote">}</span></span></span> |-- Parse.enum1 <span class="inner_quoted">"|"</span> <span class="entity">cons_decl</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">tycons_decl</span> <span class="main">=</span>
  Parse.and_list1 <span class="entity">tycon_decl</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_tycon</span>
    <span class="main">(</span><span class="entity">doms</span> <span class="main">:</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="main">(</span>string * <span class="main">(</span>string * string option<span class="main">)</span> list<span class="main">)</span> * binding<span class="main">)</span> * mixfix<span class="main">)</span> *
             <span class="main">(</span><span class="main">(</span>binding * <span class="main">(</span>bool * binding option * string<span class="main">)</span> list<span class="main">)</span> * mixfix<span class="main">)</span> list<span class="main">)</span> list <span class="main">)</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">specs</span> <span class="main">:</span> <span class="main">(</span>string * <span class="main">(</span>string * string option<span class="main">)</span> list * binding * mixfix *
                 <span class="main">(</span>binding * <span class="main">(</span>bool * binding option * string<span class="main">)</span> list * mixfix<span class="main">)</span> list<span class="main">)</span> list <span class="main">=</span>
        map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="entity">vs</span><span class="main">)</span><span class="main">,</span> <span class="entity">t</span><span class="main">)</span><span class="main">,</span> <span class="entity">mx</span><span class="main">)</span><span class="main">,</span> <span class="entity">cons</span><span class="main">)</span> <span class="main">=&gt;</span>
                <span class="main">(</span><span class="entity">a</span><span class="main">,</span> <span class="entity">vs</span><span class="main">,</span> <span class="entity">t</span><span class="main">,</span> <span class="entity">mx</span><span class="main">,</span> map <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">ds</span><span class="main">)</span><span class="main">,</span> <span class="entity">mx</span><span class="main">)</span> <span class="main">=&gt;</span> <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="entity">ds</span><span class="main">,</span> <span class="entity">mx</span><span class="main">)</span><span class="main">)</span> <span class="entity">cons</span><span class="main">)</span><span class="main">)</span> <span class="entity">doms</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">add_tycon_cmd</span> <span class="entity">specs</span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  <span class="entity">Outer_Syntax.command</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">command_keyword</span> <span class="keyword1">tycondef</span><span class="antiquote">}</span></span></span>
    <span class="inner_quoted">"define recursive type constructors (HOLCF)"</span>
    <span class="main">(</span><span class="entity">tycons_decl</span> &gt;&gt; <span class="main">(</span><span class="entity">Toplevel.theory</span> o <span class="entity">mk_tycon</span><span class="main">)</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Monad">
<div class="head">
<h1>Theory Monad</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Monad Class›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Monad
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Functor.html">Functor</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Class definition›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In Haskell, class \emph{Monad} is defined as follows:›</span></span>

<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹
\begin{verbatim}
class Monad m where
  return :: a -&gt; m a
  (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b
\end{verbatim}
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We formalize class <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>monad›</span></span></span></span> in a manner similar to the
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>functor›</span></span></span></span> class: We fix monomorphic versions of the class
constants, replacing type variables with <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>udom›</span></span></span></span>, and assume
monomorphic versions of the class axioms.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Because the monad laws imply the composition rule for <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>fmap›</span></span></span></span>, we declare <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>prefunctor›</span></span></span></span> as the superclass, and separately
prove a subclass relationship with <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>functor›</span></span></span></span>.›</span></span>

<span class="keyword1"><span class="command">class</span></span> monad <span class="main">=</span> prefunctor <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free"><span class="free"><span class="free">returnU</span></span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom <span class="main">→</span> udom<span class="main">⋅</span><span class="tfree">'a</span><span class="main">::</span>tycon"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free"><span class="free"><span class="free">bindU</span></span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom<span class="main">⋅</span><span class="tfree">'a</span> <span class="main">→</span> <span class="main">(</span>udom <span class="main">→</span> udom<span class="main">⋅</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">→</span> udom<span class="main">⋅</span><span class="tfree">'a</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> fmapU_eq_bindU<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">f</span> <span class="bound">xs</span><span class="main">.</span> fmapU<span class="main">⋅</span><span class="bound">f</span><span class="main">⋅</span><span class="bound">xs</span> <span class="main">=</span> <span class="free">bindU</span><span class="main">⋅</span><span class="bound">xs</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="free">returnU</span><span class="main">⋅</span><span class="main">(</span><span class="bound">f</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> bindU_returnU<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">f</span> <span class="bound">x</span><span class="main">.</span> <span class="free">bindU</span><span class="main">⋅</span><span class="main">(</span><span class="free">returnU</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">⋅</span><span class="bound">f</span> <span class="main">=</span> <span class="bound">f</span><span class="main">⋅</span><span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> bindU_bindU<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span> <span class="bound">f</span> <span class="bound">g</span><span class="main">.</span> <span class="free">bindU</span><span class="main">⋅</span><span class="main">(</span><span class="free">bindU</span><span class="main">⋅</span><span class="bound">xs</span><span class="main">⋅</span><span class="bound">f</span><span class="main">)</span><span class="main">⋅</span><span class="bound">g</span> <span class="main">=</span> <span class="free">bindU</span><span class="main">⋅</span><span class="bound">xs</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="free">bindU</span><span class="main">⋅</span><span class="main">(</span><span class="bound">f</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">⋅</span><span class="bound">g</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">instance</span></span> monad <span class="main">⊆</span> <span class="quoted">"functor"</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">f</span> <span class="skolem">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom <span class="main">→</span> udom"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom<span class="main">⋅</span><span class="tfree">'a</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"fmapU<span class="main">⋅</span><span class="skolem">f</span><span class="main">⋅</span><span class="main">(</span>fmapU<span class="main">⋅</span><span class="skolem">g</span><span class="main">⋅</span><span class="skolem">xs</span><span class="main">)</span> <span class="main">=</span> fmapU<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="skolem">f</span><span class="main">⋅</span><span class="main">(</span><span class="skolem">g</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">xs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmapU_eq_bindU bindU_bindU bindU_returnU<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹As with <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>fmap›</span></span></span></span>, we define the polymorphic <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>return›</span></span></span></span>
and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>bind›</span></span></span></span> by coercion from the monomorphic <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>returnU›</span></span></span></span> and
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>bindU›</span></span></span></span>.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'m</span><span class="main">::</span>monad"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">return</span> <span class="main">=</span> coerce<span class="main">⋅</span><span class="main">(</span>returnU <span class="main">::</span> udom <span class="main">→</span> udom<span class="main">⋅</span><span class="tfree">'m</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'m</span><span class="main">::</span>monad <span class="main">→</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'b</span><span class="main">⋅</span><span class="tfree">'m</span><span class="main">)</span> <span class="main">→</span> <span class="tfree">'b</span><span class="main">⋅</span><span class="tfree">'m</span>"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">bind</span> <span class="main">=</span> coerce<span class="main">⋅</span><span class="main">(</span>bindU <span class="main">::</span> udom<span class="main">⋅</span><span class="tfree">'m</span> <span class="main">→</span> <span class="main">_</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">bind_syn</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'m</span><span class="main">::</span>monad <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'b</span><span class="main">⋅</span><span class="tfree">'m</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">⋅</span><span class="tfree">'m</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">⤜</span>"</span> 55<span class="main">)</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main"><span class="free">⤜</span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> bind<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span>"</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Naturality of bind and return›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The three class axioms imply naturality properties of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>returnU›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>bindU›</span></span></span></span>, i.e., that both commute with <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>fmapU›</span></span></span></span>.›</span></span>

<span class="keyword1" id="Monad-fmapU_returnU"><span class="command">lemma</span></span> fmapU_returnU <span class="main">[</span><span class="operator">coerce_simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"fmapU<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span>returnU<span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> returnU<span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmapU_eq_bindU bindU_returnU<span class="main">)</span>

<span class="keyword1" id="Monad-fmapU_bindU"><span class="command">lemma</span></span> fmapU_bindU <span class="main">[</span><span class="operator">coerce_simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"fmapU<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span>bindU<span class="main">⋅</span><span class="free">m</span><span class="main">⋅</span><span class="free">k</span><span class="main">)</span> <span class="main">=</span> bindU<span class="main">⋅</span><span class="free">m</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> fmapU<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="free">k</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmapU_eq_bindU bindU_bindU<span class="main">)</span>

<span class="keyword1" id="Monad-bindU_fmapU"><span class="command">lemma</span></span> bindU_fmapU<span class="main">:</span>
  <span class="quoted"><span class="quoted">"bindU<span class="main">⋅</span><span class="main">(</span>fmapU<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span><span class="main">⋅</span><span class="free">k</span> <span class="main">=</span> bindU<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="free">k</span><span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmapU_eq_bindU bindU_returnU bindU_bindU<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Polymorphic versions of class assumptions›</span></span>

<span class="keyword1" id="Monad-monad_fmap"><span class="command">lemma</span></span> monad_fmap<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'m</span><span class="main">::</span>monad"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'b</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> <span class="free">xs</span> <span class="main">⤜</span> <span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> return<span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> bind_def return_def fmap_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">coerce_simp</span></span> fmapU_eq_bindU bindU_returnU<span class="main">)</span>

<span class="keyword1" id="Monad-monad_left_unit"><span class="command">lemma</span></span> monad_left_unit <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>return<span class="main">⋅</span><span class="free">x</span> <span class="main">⤜</span> <span class="free">f</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> bind_def return_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">coerce_simp</span></span> bindU_returnU<span class="main">)</span>

<span class="keyword1" id="Monad-bind_bind"><span class="command">lemma</span></span> bind_bind<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">m</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'m</span><span class="main">::</span>monad"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">m</span> <span class="main">⤜</span> <span class="free">f</span><span class="main">)</span> <span class="main">⤜</span> <span class="free">g</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">m</span> <span class="main">⤜</span> <span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="free">f</span><span class="main">⋅</span><span class="bound">x</span> <span class="main">⤜</span> <span class="free">g</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> bind_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">coerce_simp</span></span> bindU_bindU<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Derived rules›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The following properties can be derived using only the
abstract monad laws.›</span></span>

<span class="keyword1" id="Monad-monad_right_unit"><span class="command">lemma</span></span> monad_right_unit <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">m</span> <span class="main">⤜</span> return<span class="main">)</span> <span class="main">=</span> <span class="free">m</span>"</span></span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"fmap<span class="main">⋅</span>ID<span class="main">⋅</span><span class="free">m</span> <span class="main">=</span> <span class="free">m</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> monad_fmap<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eta_cfun<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Monad-fmap_return"><span class="command">lemma</span></span> fmap_return<span class="main">:</span> <span class="quoted"><span class="quoted">"fmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span>return<span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> return<span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> monad_fmap<span class="main">)</span>

<span class="keyword1" id="Monad-fmap_bind"><span class="command">lemma</span></span> fmap_bind<span class="main">:</span> <span class="quoted"><span class="quoted">"fmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span>bind<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="free">k</span><span class="main">)</span> <span class="main">=</span> bind<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> fmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="free">k</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> monad_fmap bind_bind<span class="main">)</span>

<span class="keyword1" id="Monad-bind_fmap"><span class="command">lemma</span></span> bind_fmap<span class="main">:</span> <span class="quoted"><span class="quoted">"bind<span class="main">⋅</span><span class="main">(</span>fmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span><span class="main">⋅</span><span class="free">k</span> <span class="main">=</span> bind<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="free">k</span><span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> monad_fmap bind_bind<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Bind is strict in its first argument, if its second argument
is a strict function.›</span></span>

<span class="keyword1" id="Monad-bind_strict"><span class="command">lemma</span></span> bind_strict<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">k</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">⊥</span> <span class="main">⤜</span> <span class="free">k</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⊥</span> <span class="main">⤜</span> <span class="free">k</span> <span class="main">⊑</span> return<span class="main">⋅</span><span class="main">⊥</span> <span class="main">⤜</span> <span class="free">k</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> monofun_cfun below_refl minimal<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">⊥</span> <span class="main">⤜</span> <span class="free">k</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Monad-congruent_bind"><span class="command">lemma</span></span> congruent_bind<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">m</span><span class="main">.</span> <span class="bound">m</span> <span class="main">⤜</span> <span class="free">k1</span> <span class="main">=</span> <span class="bound">m</span> <span class="main">⤜</span> <span class="free">k2</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">k1</span> <span class="main">=</span> <span class="free">k2</span><span class="main">)</span>"</span></span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">safe</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> cfun_eqI<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"return<span class="main">⋅</span><span class="improper">x</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Laws for join›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">join</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'m</span><span class="main">)</span><span class="main">⋅</span><span class="tfree">'m</span> <span class="main">→</span> <span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'m</span><span class="main">::</span>monad"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">join</span> <span class="main">≡</span> <span class="keyword1">Λ</span> m<span class="main">.</span> <span class="bound">m</span> <span class="main">⤜</span> <span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="bound">x</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Monad-join_fmap_fmap"><span class="command">lemma</span></span> join_fmap_fmap<span class="main">:</span> <span class="quoted"><span class="quoted">"join<span class="main">⋅</span><span class="main">(</span>fmap<span class="main">⋅</span><span class="main">(</span>fmap<span class="main">⋅</span><span class="free">f</span><span class="main">)</span><span class="main">⋅</span><span class="free">xss</span><span class="main">)</span> <span class="main">=</span> fmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span>join<span class="main">⋅</span><span class="free">xss</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> join_def monad_fmap bind_bind<span class="main">)</span>

<span class="keyword1" id="Monad-join_return"><span class="command">lemma</span></span> join_return<span class="main">:</span> <span class="quoted"><span class="quoted">"join<span class="main">⋅</span><span class="main">(</span>return<span class="main">⋅</span><span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> join_def<span class="main">)</span>

<span class="keyword1" id="Monad-join_fmap_return"><span class="command">lemma</span></span> join_fmap_return<span class="main">:</span> <span class="quoted"><span class="quoted">"join<span class="main">⋅</span><span class="main">(</span>fmap<span class="main">⋅</span>return<span class="main">⋅</span><span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> join_def monad_fmap eta_cfun bind_bind<span class="main">)</span>

<span class="keyword1" id="Monad-join_fmap_join"><span class="command">lemma</span></span> join_fmap_join<span class="main">:</span> <span class="quoted"><span class="quoted">"join<span class="main">⋅</span><span class="main">(</span>fmap<span class="main">⋅</span>join<span class="main">⋅</span><span class="free">xsss</span><span class="main">)</span> <span class="main">=</span> join<span class="main">⋅</span><span class="main">(</span>join<span class="main">⋅</span><span class="free">xsss</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> join_def monad_fmap bind_bind<span class="main">)</span>

<span class="keyword1" id="Monad-bind_def2"><span class="command">lemma</span></span> bind_def2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">⤜</span> <span class="free">k</span> <span class="main">=</span> join<span class="main">⋅</span><span class="main">(</span>fmap<span class="main">⋅</span><span class="free">k</span><span class="main">⋅</span><span class="free">m</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> join_def monad_fmap eta_cfun bind_bind<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Equivalence of monad laws and fmap/join laws›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>return<span class="main">⋅</span><span class="free">x</span> <span class="main">⤜</span> <span class="free">f</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> bind_def2 fmap_return join_return<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">m</span> <span class="main">⤜</span> return<span class="main">)</span> <span class="main">=</span> <span class="free">m</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> bind_def2 join_fmap_return<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">m</span> <span class="main">⤜</span> <span class="free">f</span><span class="main">)</span> <span class="main">⤜</span> <span class="free">g</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">m</span> <span class="main">⤜</span> <span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="free">f</span><span class="main">⋅</span><span class="bound">x</span> <span class="main">⤜</span> <span class="free">g</span><span class="main">)</span><span class="main">)</span>"</span></span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> bind_def2<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"join<span class="main">⋅</span><span class="main">(</span>fmap<span class="main">⋅</span><span class="free">g</span><span class="main">⋅</span><span class="main">(</span>join<span class="main">⋅</span><span class="main">(</span>fmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">m</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
    join<span class="main">⋅</span><span class="main">(</span>fmap<span class="main">⋅</span>join<span class="main">⋅</span><span class="main">(</span>fmap<span class="main">⋅</span><span class="main">(</span>fmap<span class="main">⋅</span><span class="free">g</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>fmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">m</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmap_fmap<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> join_fmap_join join_fmap_fmap<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Simplification of coercions›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We configure rewrite rules that push coercions inwards, and
reduce them to coercions on simpler types.›</span></span>

<span class="keyword1" id="Monad-coerce_return"><span class="command">lemma</span></span> coerce_return <span class="main">[</span><span class="operator">coerce_simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="keyword1">COERCE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'m</span><span class="main">,</span><span class="tfree">'b</span><span class="main">⋅</span><span class="tfree">'m</span><span class="main">::</span>monad<span class="main">)</span><span class="main">⋅</span><span class="main">(</span>return<span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> return<span class="main">⋅</span><span class="main">(</span><span class="keyword1">COERCE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span><span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> coerce_functor fmap_return<span class="main">)</span>

<span class="keyword1" id="Monad-coerce_bind"><span class="command">lemma</span></span> coerce_bind <span class="main">[</span><span class="operator">coerce_simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">m</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'m</span><span class="main">::</span>monad"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">k</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'b</span><span class="main">⋅</span><span class="tfree">'m</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">COERCE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">⋅</span><span class="tfree">'m</span><span class="main">,</span><span class="tfree">'c</span><span class="main">⋅</span><span class="tfree">'m</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free">m</span> <span class="main">⤜</span> <span class="free">k</span><span class="main">)</span> <span class="main">=</span> <span class="free">m</span> <span class="main">⤜</span> <span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="keyword1">COERCE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">⋅</span><span class="tfree">'m</span><span class="main">,</span><span class="tfree">'c</span><span class="main">⋅</span><span class="tfree">'m</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free">k</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> coerce_functor fmap_bind<span class="main">)</span>

<span class="keyword1" id="Monad-bind_coerce"><span class="command">lemma</span></span> bind_coerce <span class="main">[</span><span class="operator">coerce_simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">m</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'m</span><span class="main">::</span>monad"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">k</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">→</span> <span class="tfree">'c</span><span class="main">⋅</span><span class="tfree">'m</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">COERCE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'m</span><span class="main">,</span><span class="tfree">'b</span><span class="main">⋅</span><span class="tfree">'m</span><span class="main">)</span><span class="main">⋅</span><span class="free">m</span> <span class="main">⤜</span> <span class="free">k</span> <span class="main">=</span> <span class="free">m</span> <span class="main">⤜</span> <span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="free">k</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">COERCE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> coerce_functor bind_fmap<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Monad_Zero">
<div class="head">
<h1>Theory Monad_Zero</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Monad-Zero Class›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Monad_Zero
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Monad.html">Monad</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">class</span></span> zeroU <span class="main">=</span> tycon <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free"><span class="free"><span class="free">zeroU</span></span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom<span class="main">⋅</span><span class="tfree">'a</span><span class="main">::</span>tycon"</span></span>

<span class="keyword1"><span class="command">class</span></span> functor_zero <span class="main">=</span> zeroU <span class="main">+</span> <span class="quoted">"functor"</span> <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> fmapU_zeroU <span class="main">[</span><span class="operator">coerce_simp</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"fmapU<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span>zeroU <span class="main">=</span> zeroU"</span></span>

<span class="keyword1"><span class="command">class</span></span> monad_zero <span class="main">=</span> zeroU <span class="main">+</span> monad <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> bindU_zeroU<span class="main">:</span>
    <span class="quoted"><span class="quoted">"bindU<span class="main">⋅</span>zeroU<span class="main">⋅</span><span class="free">f</span> <span class="main">=</span> zeroU"</span></span>

<span class="keyword1"><span class="command">instance</span></span> monad_zero <span class="main">⊆</span> functor_zero
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">f</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"fmapU<span class="main">⋅</span><span class="skolem">f</span><span class="main">⋅</span>zeroU <span class="main">=</span> <span class="main">(</span>zeroU <span class="main">::</span> udom<span class="main">⋅</span><span class="tfree">'a</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> fmapU_eq_bindU
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> bindU_zeroU<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">fzero</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'f</span><span class="main">::</span>functor_zero"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">fzero</span> <span class="main">=</span> coerce<span class="main">⋅</span><span class="main">(</span>zeroU <span class="main">::</span> udom<span class="main">⋅</span><span class="tfree">'f</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Monad_Zero-fmap_fzero"><span class="command">lemma</span></span> fmap_fzero<span class="main">:</span>
  <span class="quoted"><span class="quoted">"fmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span>fzero <span class="main">::</span> <span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'f</span><span class="main">::</span>functor_zero<span class="main">)</span> <span class="main">=</span> <span class="main">(</span>fzero <span class="main">::</span> <span class="tfree">'b</span><span class="main">⋅</span><span class="tfree">'f</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> fmap_def fzero_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">coerce_simp</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">mzero</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'m</span><span class="main">::</span>monad_zero"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">mzero</span> <span class="main">≡</span> fzero"</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> mzero_def <span class="main">=</span> fzero_def <span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'f</span><span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="tfree">'m</span><span class="main">::</span>monad_zero"</span></span><span class="main">]</span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">f</span>
<span class="keyword1"><span class="command">lemmas</span></span> fmap_mzero <span class="main">=</span> fmap_fzero <span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'f</span><span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="tfree">'m</span><span class="main">::</span>monad_zero"</span></span><span class="main">]</span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">f</span>

<span class="keyword1" id="Monad_Zero-bindU_eq_bind"><span class="command">lemma</span></span> bindU_eq_bind<span class="main">:</span> <span class="quoted"><span class="quoted">"bindU <span class="main">=</span> bind"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> bind_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Monad_Zero-bind_mzero"><span class="command">lemma</span></span> bind_mzero<span class="main">:</span>
  <span class="quoted"><span class="quoted">"bind<span class="main">⋅</span><span class="main">(</span>fzero <span class="main">::</span> <span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'m</span><span class="main">::</span>monad_zero<span class="main">)</span><span class="main">⋅</span><span class="free">k</span> <span class="main">=</span> <span class="main">(</span>mzero <span class="main">::</span> <span class="tfree">'b</span><span class="main">⋅</span><span class="tfree">'m</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> bind_def mzero_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">coerce_simp</span></span> bindU_zeroU<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Monad_Plus">
<div class="head">
<h1>Theory Monad_Plus</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Monad-Plus Class›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Monad_Plus
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Monad.html">Monad</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">hide_const</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="main">)</span> Fixrec.mplus

<span class="keyword1"><span class="command">class</span></span> plusU <span class="main">=</span> tycon <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free"><span class="free"><span class="free">plusU</span></span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom<span class="main">⋅</span><span class="tfree">'a</span> <span class="main">→</span> udom<span class="main">⋅</span><span class="tfree">'a</span> <span class="main">→</span> udom<span class="main">⋅</span><span class="tfree">'a</span><span class="main">::</span>tycon"</span></span>

<span class="keyword1"><span class="command">class</span></span> functor_plus <span class="main">=</span> plusU <span class="main">+</span> <span class="quoted">"functor"</span> <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> fmapU_plusU <span class="main">[</span><span class="operator">coerce_simp</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"fmapU<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span>plusU<span class="main">⋅</span><span class="free">a</span><span class="main">⋅</span><span class="free">b</span><span class="main">)</span> <span class="main">=</span> plusU<span class="main">⋅</span><span class="main">(</span>fmapU<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">a</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>fmapU<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">b</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> plusU_assoc<span class="main">:</span>
    <span class="quoted"><span class="quoted">"plusU<span class="main">⋅</span><span class="main">(</span>plusU<span class="main">⋅</span><span class="free">a</span><span class="main">⋅</span><span class="free">b</span><span class="main">)</span><span class="main">⋅</span><span class="free">c</span> <span class="main">=</span> plusU<span class="main">⋅</span><span class="free">a</span><span class="main">⋅</span><span class="main">(</span>plusU<span class="main">⋅</span><span class="free">b</span><span class="main">⋅</span><span class="free">c</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">class</span></span> monad_plus <span class="main">=</span> plusU <span class="main">+</span> monad <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> bindU_plusU<span class="main">:</span>
    <span class="quoted"><span class="quoted">"bindU<span class="main">⋅</span><span class="main">(</span>plusU<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="free">ys</span><span class="main">)</span><span class="main">⋅</span><span class="free">k</span> <span class="main">=</span> plusU<span class="main">⋅</span><span class="main">(</span>bindU<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="free">k</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>bindU<span class="main">⋅</span><span class="free">ys</span><span class="main">⋅</span><span class="free">k</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> plusU_assoc'<span class="main">:</span>
    <span class="quoted"><span class="quoted">"plusU<span class="main">⋅</span><span class="main">(</span>plusU<span class="main">⋅</span><span class="free">a</span><span class="main">⋅</span><span class="free">b</span><span class="main">)</span><span class="main">⋅</span><span class="free">c</span> <span class="main">=</span> plusU<span class="main">⋅</span><span class="free">a</span><span class="main">⋅</span><span class="main">(</span>plusU<span class="main">⋅</span><span class="free">b</span><span class="main">⋅</span><span class="free">c</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">instance</span></span> monad_plus <span class="main">⊆</span> functor_plus
<span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> fmapU_eq_bindU bindU_plusU plusU_assoc'<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">fplus</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'f</span><span class="main">::</span>functor_plus <span class="main">→</span> <span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'f</span> <span class="main">→</span> <span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'f</span>"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">fplus</span> <span class="main">=</span> coerce<span class="main">⋅</span><span class="main">(</span>plusU <span class="main">::</span> udom<span class="main">⋅</span><span class="tfree">'f</span> <span class="main">→</span> <span class="main">_</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Monad_Plus-fmap_fplus"><span class="command">lemma</span></span> fmap_fplus<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'b</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">a</span> <span class="free">b</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'f</span><span class="main">::</span>functor_plus"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span>fplus<span class="main">⋅</span><span class="free">a</span><span class="main">⋅</span><span class="free">b</span><span class="main">)</span> <span class="main">=</span> fplus<span class="main">⋅</span><span class="main">(</span>fmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">a</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>fmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">b</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> fmap_def fplus_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">coerce_simp</span></span><span class="main">)</span>

<span class="keyword1" id="Monad_Plus-fplus_assoc"><span class="command">lemma</span></span> fplus_assoc<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">a</span> <span class="free">b</span> <span class="free">c</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'f</span><span class="main">::</span>functor_plus"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fplus<span class="main">⋅</span><span class="main">(</span>fplus<span class="main">⋅</span><span class="free">a</span><span class="main">⋅</span><span class="free">b</span><span class="main">)</span><span class="main">⋅</span><span class="free">c</span> <span class="main">=</span> fplus<span class="main">⋅</span><span class="free">a</span><span class="main">⋅</span><span class="main">(</span>fplus<span class="main">⋅</span><span class="free">b</span><span class="main">⋅</span><span class="free">c</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> fplus_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">coerce_simp</span></span> plusU_assoc<span class="main">)</span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">mplus</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'m</span><span class="main">::</span>monad_plus <span class="main">→</span> <span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'m</span> <span class="main">→</span> <span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'m</span>"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">mplus</span> <span class="main">≡</span> fplus"</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> mplus_def <span class="main">=</span> fplus_def <span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'f</span><span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="tfree">'m</span><span class="main">::</span>monad_plus"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">for</span></span></span> <span class="free">f</span><span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> fmap_mplus <span class="main">=</span> fmap_fplus <span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'f</span><span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="tfree">'m</span><span class="main">::</span>monad_plus"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">for</span></span></span> <span class="free">f</span><span class="main">]</span>
<span class="keyword1"><span class="command">lemmas</span></span> mplus_assoc <span class="main">=</span> fplus_assoc <span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'f</span><span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="tfree">'m</span><span class="main">::</span>monad_plus"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">for</span></span></span> <span class="free">f</span><span class="main">]</span>

<span class="keyword1" id="Monad_Plus-bind_mplus"><span class="command">lemma</span></span> bind_mplus<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">a</span> <span class="free">b</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'m</span><span class="main">::</span>monad_plus"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"bind<span class="main">⋅</span><span class="main">(</span>mplus<span class="main">⋅</span><span class="free">a</span><span class="main">⋅</span><span class="free">b</span><span class="main">)</span><span class="main">⋅</span><span class="free">k</span> <span class="main">=</span> mplus<span class="main">⋅</span><span class="main">(</span>bind<span class="main">⋅</span><span class="free">a</span><span class="main">⋅</span><span class="free">k</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>bind<span class="main">⋅</span><span class="free">b</span><span class="main">⋅</span><span class="free">k</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> bind_def mplus_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">coerce_simp</span></span> bindU_plusU<span class="main">)</span>

<span class="keyword1" id="Monad_Plus-join_mplus"><span class="command">lemma</span></span> join_mplus<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">xss</span> <span class="free">yss</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'m</span><span class="main">)</span><span class="main">⋅</span><span class="tfree">'m</span><span class="main">::</span>monad_plus"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"join<span class="main">⋅</span><span class="main">(</span>mplus<span class="main">⋅</span><span class="free">xss</span><span class="main">⋅</span><span class="free">yss</span><span class="main">)</span> <span class="main">=</span> mplus<span class="main">⋅</span><span class="main">(</span>join<span class="main">⋅</span><span class="free">xss</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>join<span class="main">⋅</span><span class="free">yss</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> join_def bind_mplus<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Monad_Zero_Plus">
<div class="head">
<h1>Theory Monad_Zero_Plus</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Monad-Zero-Plus Class›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Monad_Zero_Plus
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Monad_Zero.html">Monad_Zero</a> <a href="Monad_Plus.html">Monad_Plus</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">hide_const</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="main">)</span> Fixrec.mplus

<span class="keyword1"><span class="command">class</span></span> functor_zero_plus <span class="main">=</span> functor_zero <span class="main">+</span> functor_plus <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> plusU_zeroU_left<span class="main">:</span>
    <span class="quoted"><span class="quoted">"plusU<span class="main">⋅</span>zeroU<span class="main">⋅</span><span class="free">m</span> <span class="main">=</span> <span class="free">m</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> plusU_zeroU_right<span class="main">:</span>
    <span class="quoted"><span class="quoted">"plusU<span class="main">⋅</span><span class="free">m</span><span class="main">⋅</span>zeroU <span class="main">=</span> <span class="free">m</span>"</span></span>

<span class="keyword1"><span class="command">class</span></span> monad_zero_plus <span class="main">=</span> monad_zero <span class="main">+</span> monad_plus <span class="main">+</span> functor_zero_plus

<span class="keyword1" id="Monad_Zero_Plus-fplus_fzero_left"><span class="command">lemma</span></span> fplus_fzero_left<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">m</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'f</span><span class="main">::</span>functor_zero_plus"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fplus<span class="main">⋅</span>fzero<span class="main">⋅</span><span class="free">m</span> <span class="main">=</span> <span class="free">m</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> fplus_def fzero_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">coerce_simp</span></span> plusU_zeroU_left<span class="main">)</span>

<span class="keyword1" id="Monad_Zero_Plus-fplus_fzero_right"><span class="command">lemma</span></span> fplus_fzero_right<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">m</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'f</span><span class="main">::</span>functor_zero_plus"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fplus<span class="main">⋅</span><span class="free">m</span><span class="main">⋅</span>fzero <span class="main">=</span> <span class="free">m</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> fplus_def fzero_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">coerce_simp</span></span> plusU_zeroU_right<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> mplus_mzero_left <span class="main">=</span>
  fplus_fzero_left <span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'f</span><span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="tfree">'m</span><span class="main">::</span>monad_zero_plus"</span></span><span class="main">]</span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">f</span>

<span class="keyword1"><span class="command">lemmas</span></span> mplus_mzero_right <span class="main">=</span>
  fplus_fzero_right <span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'f</span><span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="tfree">'m</span><span class="main">::</span>monad_zero_plus"</span></span><span class="main">]</span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">f</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Lazy_List_Monad">
<div class="head">
<h1>Theory Lazy_List_Monad</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Lazy list monad›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Lazy_List_Monad
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Monad_Zero_Plus.html">Monad_Zero_Plus</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹To illustrate the general process of defining a new type
constructor, we formalize the datatype of lazy lists. Below are the
Haskell datatype definition and class instances.›</span></span>

<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹
\begin{verbatim}
data List a = Nil | Cons a (List a)

instance Functor List where
  fmap f Nil = Nil
  fmap f (Cons x xs) = Cons (f x) (fmap f xs)

instance Monad List where
  return x        = Cons x Nil
  Nil       &gt;&gt;= k = Nil
  Cons x xs &gt;&gt;= k = mplus (k x) (xs &gt;&gt;= k)

instance MonadZero List where
  mzero = Nil

instance MonadPlus List where
  mplus Nil         ys = ys
  mplus (Cons x xs) ys = Cons x (mplus xs ys)
\end{verbatim}
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Type definition›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The first step is to register the datatype definition with
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>tycondef›</span></span></span></span>.›</span></span>

<span class="keyword1"><span class="command">tycondef</span></span> <span class="tfree">'a</span><span class="main">⋅</span>llist <span class="main">=</span> LNil <span class="main">|</span> LCons <span class="main">(</span><span class="keyword2"><span class="keyword">lazy</span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span>"</span></span><span class="main">)</span> <span class="main">(</span><span class="keyword2"><span class="keyword">lazy</span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">⋅</span>llist"</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>tycondef›</span></span></span></span> command generates lots of theorems
automatically, but there are a few more involving <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>coerce›</span></span></span></span> and
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>fmapU›</span></span></span></span> that we still need to prove manually. These proofs could
be automated in a later version of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>tycondef›</span></span></span></span>.›</span></span>

<span class="keyword1" id="Lazy_List_Monad-coerce_llist_abs"><span class="command">lemma</span></span> coerce_llist_abs <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"coerce<span class="main">⋅</span><span class="main">(</span>llist_abs<span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> llist_abs<span class="main">⋅</span><span class="main">(</span>coerce<span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> llist_abs_def coerce_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> emb_prj_emb prj_emb_prj DEFL_eq_llist<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Lazy_List_Monad-coerce_LNil"><span class="command">lemma</span></span> coerce_LNil <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"coerce<span class="main">⋅</span>LNil <span class="main">=</span> LNil"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> LNil_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Lazy_List_Monad-coerce_LCons"><span class="command">lemma</span></span> coerce_LCons <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"coerce<span class="main">⋅</span><span class="main">(</span>LCons<span class="main">⋅</span><span class="free">x</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span> <span class="main">=</span> LCons<span class="main">⋅</span><span class="main">(</span>coerce<span class="main">⋅</span><span class="free">x</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>coerce<span class="main">⋅</span><span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> LCons_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Lazy_List_Monad-fmapU_llist_simps"><span class="command">lemma</span></span> fmapU_llist_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"fmapU<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="main">⊥</span><span class="main">::</span>udom<span class="main">⋅</span>llist<span class="main">)</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"fmapU<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span>LNil <span class="main">=</span> LNil"</span></span>
  <span class="quoted"><span class="quoted">"fmapU<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span>LCons<span class="main">⋅</span><span class="free">x</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span> <span class="main">=</span> LCons<span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="free">x</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>fmapU<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> fmapU_llist_def llist_map_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> fix_eq<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> fix_eq<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> LNil_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> fix_eq<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> LCons_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Class instances›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>tycondef›</span></span></span></span> command defines <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>fmapU›</span></span></span></span> for us and
proves a <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>prefunctor›</span></span></span></span> class instance automatically. For the
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>functor›</span></span></span></span> instance we only need to prove the composition law,
which we can do by induction.›</span></span>

<span class="keyword1"><span class="command">instance</span></span> llist <span class="main">::</span> <span class="quoted"><span class="quoted">"functor"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">f</span> <span class="skolem">g</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom<span class="main">⋅</span>llist"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"fmapU<span class="main">⋅</span><span class="skolem">f</span><span class="main">⋅</span><span class="main">(</span>fmapU<span class="main">⋅</span><span class="skolem">g</span><span class="main">⋅</span><span class="skolem">xs</span><span class="main">)</span> <span class="main">=</span> fmapU<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="skolem">f</span><span class="main">⋅</span><span class="main">(</span><span class="skolem">g</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">xs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> llist.induct<span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹For the other class instances, we need to provide definitions
for a few constants: <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>returnU›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>bindU›</span></span></span></span> <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>zeroU›</span></span></span></span>, and
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>plusU›</span></span></span></span>. We can use ordinary commands like <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>definition›</span></span></span></span>
and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>fixrec›</span></span></span></span> for this purpose. Finally we prove the class
axioms, along with a few helper lemmas, using ordinary proof
procedures like induction.›</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> llist <span class="main">::</span> <span class="quoted">monad_zero_plus</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity"><span class="class_parameter">plusU_llist</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom<span class="main">⋅</span>llist <span class="main">→</span> udom<span class="main">⋅</span>llist <span class="main">→</span> udom<span class="main">⋅</span>llist"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">plusU_llist</span><span class="main">⋅</span>LNil<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span>"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">plusU_llist</span><span class="main">⋅</span><span class="main">(</span>LCons<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">=</span> LCons<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="free">plusU_llist</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Lazy_List_Monad-plusU_llist_strict"><span class="command">lemma</span></span> plusU_llist_strict <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"plusU<span class="main">⋅</span><span class="main">⊥</span><span class="main">⋅</span><span class="free">ys</span> <span class="main">=</span> <span class="main">(</span><span class="main">⊥</span><span class="main">::</span>udom<span class="main">⋅</span>llist<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity"><span class="class_parameter">bindU_llist</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom<span class="main">⋅</span>llist <span class="main">→</span> <span class="main">(</span>udom <span class="main">→</span> udom<span class="main">⋅</span>llist<span class="main">)</span> <span class="main">→</span> udom<span class="main">⋅</span>llist"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">bindU_llist</span><span class="main">⋅</span>LNil<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">=</span> LNil"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">bindU_llist</span><span class="main">⋅</span><span class="main">(</span>LCons<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">=</span> plusU<span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free">bindU_llist</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Lazy_List_Monad-bindU_llist_strict"><span class="command">lemma</span></span> bindU_llist_strict <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"bindU<span class="main">⋅</span><span class="main">⊥</span><span class="main">⋅</span><span class="free">k</span> <span class="main">=</span> <span class="main">(</span><span class="main">⊥</span><span class="main">::</span>udom<span class="main">⋅</span>llist<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>

<span class="keyword1"><span class="command">definition</span></span> zeroU_llist_def<span class="main">:</span>
  <span class="quoted"><span class="quoted">"zeroU <span class="main">=</span> LNil"</span></span>

<span class="keyword1"><span class="command">definition</span></span> returnU_llist_def<span class="main">:</span>
  <span class="quoted"><span class="quoted">"returnU <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> LCons<span class="main">⋅</span><span class="bound">x</span><span class="main">⋅</span>LNil<span class="main">)</span>"</span></span>

<span class="keyword1" id="Lazy_List_Monad-plusU_LNil_right"><span class="command">lemma</span></span> plusU_LNil_right<span class="main">:</span> <span class="quoted"><span class="quoted">"plusU<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span>LNil <span class="main">=</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> llist.induct<span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Lazy_List_Monad-plusU_llist_assoc"><span class="command">lemma</span></span> plusU_llist_assoc<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">xs</span> <span class="free">ys</span> <span class="free">zs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom<span class="main">⋅</span>llist"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"plusU<span class="main">⋅</span><span class="main">(</span>plusU<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="free">ys</span><span class="main">)</span><span class="main">⋅</span><span class="free">zs</span> <span class="main">=</span> plusU<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="main">(</span>plusU<span class="main">⋅</span><span class="free">ys</span><span class="main">⋅</span><span class="free">zs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> llist.induct<span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Lazy_List_Monad-bindU_plusU_llist"><span class="command">lemma</span></span> bindU_plusU_llist<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">xs</span> <span class="free">ys</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom<span class="main">⋅</span>llist"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"bindU<span class="main">⋅</span><span class="main">(</span>plusU<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="free">ys</span><span class="main">)</span><span class="main">⋅</span><span class="free">f</span> <span class="main">=</span> plusU<span class="main">⋅</span><span class="main">(</span>bindU<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="free">f</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>bindU<span class="main">⋅</span><span class="free">ys</span><span class="main">⋅</span><span class="free">f</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> llist.induct<span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> plusU_llist_assoc<span class="main">)</span>

<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom"</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom <span class="main">→</span> udom"</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">h</span> <span class="skolem">k</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom <span class="main">→</span> udom<span class="main">⋅</span>llist"</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="skolem">ys</span> <span class="skolem">zs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom<span class="main">⋅</span>llist"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"fmapU<span class="main">⋅</span><span class="skolem">f</span><span class="main">⋅</span><span class="skolem">xs</span> <span class="main">=</span> bindU<span class="main">⋅</span><span class="skolem">xs</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> returnU<span class="main">⋅</span><span class="main">(</span><span class="skolem">f</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> llist.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> returnU_llist_def<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bindU<span class="main">⋅</span><span class="main">(</span>returnU<span class="main">⋅</span><span class="skolem">x</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">k</span> <span class="main">=</span> <span class="skolem">k</span><span class="main">⋅</span><span class="skolem">x</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> returnU_llist_def plusU_LNil_right<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bindU<span class="main">⋅</span><span class="main">(</span>bindU<span class="main">⋅</span><span class="skolem">xs</span><span class="main">⋅</span><span class="skolem">h</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">k</span> <span class="main">=</span> bindU<span class="main">⋅</span><span class="skolem">xs</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> bindU<span class="main">⋅</span><span class="main">(</span><span class="skolem">h</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">k</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> llist.induct<span class="main">)</span>
       <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bindU_plusU_llist<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bindU<span class="main">⋅</span><span class="main">(</span>plusU<span class="main">⋅</span><span class="skolem">xs</span><span class="main">⋅</span><span class="skolem">ys</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">k</span> <span class="main">=</span> plusU<span class="main">⋅</span><span class="main">(</span>bindU<span class="main">⋅</span><span class="skolem">xs</span><span class="main">⋅</span><span class="skolem">k</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>bindU<span class="main">⋅</span><span class="skolem">ys</span><span class="main">⋅</span><span class="skolem">k</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> llist.induct<span class="main">)</span>
       <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> plusU_llist_assoc<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"plusU<span class="main">⋅</span><span class="main">(</span>plusU<span class="main">⋅</span><span class="skolem">xs</span><span class="main">⋅</span><span class="skolem">ys</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">zs</span> <span class="main">=</span> plusU<span class="main">⋅</span><span class="skolem">xs</span><span class="main">⋅</span><span class="main">(</span>plusU<span class="main">⋅</span><span class="skolem">ys</span><span class="main">⋅</span><span class="skolem">zs</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> plusU_llist_assoc<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bindU<span class="main">⋅</span>zeroU<span class="main">⋅</span><span class="skolem">k</span> <span class="main">=</span> zeroU"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zeroU_llist_def<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"fmapU<span class="main">⋅</span><span class="skolem">f</span><span class="main">⋅</span><span class="main">(</span>plusU<span class="main">⋅</span><span class="skolem">xs</span><span class="main">⋅</span><span class="skolem">ys</span><span class="main">)</span> <span class="main">=</span> plusU<span class="main">⋅</span><span class="main">(</span>fmapU<span class="main">⋅</span><span class="skolem">f</span><span class="main">⋅</span><span class="skolem">xs</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>fmapU<span class="main">⋅</span><span class="skolem">f</span><span class="main">⋅</span><span class="skolem">ys</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> llist.induct<span class="main">)</span> <span class="operator">simp_all</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"fmapU<span class="main">⋅</span><span class="skolem">f</span><span class="main">⋅</span>zeroU <span class="main">=</span> <span class="main">(</span>zeroU <span class="main">::</span> udom<span class="main">⋅</span>llist<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zeroU_llist_def<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"plusU<span class="main">⋅</span>zeroU<span class="main">⋅</span><span class="skolem">xs</span> <span class="main">=</span> <span class="skolem">xs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zeroU_llist_def<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"plusU<span class="main">⋅</span><span class="skolem">xs</span><span class="main">⋅</span>zeroU <span class="main">=</span> <span class="skolem">xs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zeroU_llist_def plusU_LNil_right<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Transfer properties to polymorphic versions›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹After proving the class instances, there is still one more
step: We must transfer all the list-specific lemmas about the
monomorphic constants (e.g., <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>fmapU›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>bindU›</span></span></span></span>) to the
corresponding polymorphic constants (<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>fmap›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>bind›</span></span></span></span>).
These lemmas primarily consist of the defining equations for each
constant. The polymorphic constants are defined using <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>coerce›</span></span></span></span>,
so the proofs proceed by unfolding the definitions and simplifying
with the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>coerce_simp›</span></span></span></span> rules.›</span></span>

<span class="keyword1" id="Lazy_List_Monad-fmap_llist_simps"><span class="command">lemma</span></span> fmap_llist_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"fmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="main">⊥</span><span class="main">::</span><span class="tfree">'a</span><span class="main">⋅</span>llist<span class="main">)</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"fmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span>LNil <span class="main">=</span> LNil"</span></span>
  <span class="quoted"><span class="quoted">"fmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span>LCons<span class="main">⋅</span><span class="free">x</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span> <span class="main">=</span> LCons<span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="free">x</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>fmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> fmap_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="keyword1" id="Lazy_List_Monad-mplus_llist_simps"><span class="command">lemma</span></span> mplus_llist_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"mplus<span class="main">⋅</span><span class="main">(</span><span class="main">⊥</span><span class="main">::</span><span class="tfree">'a</span><span class="main">⋅</span>llist<span class="main">)</span><span class="main">⋅</span><span class="free">ys</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"mplus<span class="main">⋅</span>LNil<span class="main">⋅</span><span class="free">ys</span> <span class="main">=</span> <span class="free">ys</span>"</span></span>
  <span class="quoted"><span class="quoted">"mplus<span class="main">⋅</span><span class="main">(</span>LCons<span class="main">⋅</span><span class="free">x</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span><span class="main">⋅</span><span class="free">ys</span> <span class="main">=</span> LCons<span class="main">⋅</span><span class="free">x</span><span class="main">⋅</span><span class="main">(</span>mplus<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> mplus_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="keyword1" id="Lazy_List_Monad-bind_llist_simps"><span class="command">lemma</span></span> bind_llist_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"bind<span class="main">⋅</span><span class="main">(</span><span class="main">⊥</span><span class="main">::</span><span class="tfree">'a</span><span class="main">⋅</span>llist<span class="main">)</span><span class="main">⋅</span><span class="free">f</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"bind<span class="main">⋅</span>LNil<span class="main">⋅</span><span class="free">f</span> <span class="main">=</span> LNil"</span></span>
  <span class="quoted"><span class="quoted">"bind<span class="main">⋅</span><span class="main">(</span>LCons<span class="main">⋅</span><span class="free">x</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span><span class="main">⋅</span><span class="free">f</span> <span class="main">=</span> mplus<span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="free">x</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>bind<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="free">f</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> bind_def mplus_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">coerce_simp</span></span><span class="main">)</span>

<span class="keyword1" id="Lazy_List_Monad-return_llist_def"><span class="command">lemma</span></span> return_llist_def<span class="main">:</span>
  <span class="quoted"><span class="quoted">"return <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> LCons<span class="main">⋅</span><span class="bound">x</span><span class="main">⋅</span>LNil<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_def returnU_llist_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">coerce_simp</span></span><span class="main">)</span>

<span class="keyword1" id="Lazy_List_Monad-mzero_llist_def"><span class="command">lemma</span></span> mzero_llist_def<span class="main">:</span>
  <span class="quoted"><span class="quoted">"mzero <span class="main">=</span> LNil"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> mzero_def zeroU_llist_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Lazy_List_Monad-join_llist_simps"><span class="command">lemma</span></span> join_llist_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"join<span class="main">⋅</span><span class="main">(</span><span class="main">⊥</span><span class="main">::</span><span class="tfree">'a</span><span class="main">⋅</span>llist<span class="main">⋅</span>llist<span class="main">)</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"join<span class="main">⋅</span>LNil <span class="main">=</span> LNil"</span></span>
  <span class="quoted"><span class="quoted">"join<span class="main">⋅</span><span class="main">(</span>LCons<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="free">xss</span><span class="main">)</span> <span class="main">=</span> mplus<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="main">(</span>join<span class="main">⋅</span><span class="free">xss</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> join_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Maybe_Monad">
<div class="head">
<h1>Theory Maybe_Monad</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Maybe monad›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Maybe_Monad
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Monad_Zero_Plus.html">Monad_Zero_Plus</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Type definition›</span></span>

<span class="keyword1"><span class="command">tycondef</span></span> <span class="tfree">'a</span><span class="main">⋅</span>maybe <span class="main">=</span> Nothing <span class="main">|</span> Just <span class="main">(</span><span class="keyword2"><span class="keyword">lazy</span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span>"</span></span><span class="main">)</span>

<span class="keyword1" id="Maybe_Monad-coerce_maybe_abs"><span class="command">lemma</span></span> coerce_maybe_abs <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"coerce<span class="main">⋅</span><span class="main">(</span>maybe_abs<span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> maybe_abs<span class="main">⋅</span><span class="main">(</span>coerce<span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> maybe_abs_def coerce_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> emb_prj_emb prj_emb_prj DEFL_eq_maybe<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Maybe_Monad-coerce_Nothing"><span class="command">lemma</span></span> coerce_Nothing <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"coerce<span class="main">⋅</span>Nothing <span class="main">=</span> Nothing"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> Nothing_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Maybe_Monad-coerce_Just"><span class="command">lemma</span></span> coerce_Just <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"coerce<span class="main">⋅</span><span class="main">(</span>Just<span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> Just<span class="main">⋅</span><span class="main">(</span>coerce<span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> Just_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Maybe_Monad-fmapU_maybe_simps"><span class="command">lemma</span></span> fmapU_maybe_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"fmapU<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="main">⊥</span><span class="main">::</span>udom<span class="main">⋅</span>maybe<span class="main">)</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"fmapU<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span>Nothing <span class="main">=</span> Nothing"</span></span>
  <span class="quoted"><span class="quoted">"fmapU<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span>Just<span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> Just<span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> fmapU_maybe_def maybe_map_def fix_const
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Nothing_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Just_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Class instance proofs›</span></span>

<span class="keyword1"><span class="command">instance</span></span> maybe <span class="main">::</span> <span class="quoted"><span class="quoted">"functor"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">standard</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="improper"><span class="quoted"><span class="improper">xs</span></span></span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> maybe.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">instantiation</span></span> maybe <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">{</span>functor_zero_plus<span class="main">,</span> monad_zero<span class="main">}</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity"><span class="class_parameter">plusU_maybe</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom<span class="main">⋅</span>maybe <span class="main">→</span> udom<span class="main">⋅</span>maybe <span class="main">→</span> udom<span class="main">⋅</span>maybe"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">plusU_maybe</span><span class="main">⋅</span>Nothing<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span>"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">plusU_maybe</span><span class="main">⋅</span><span class="main">(</span>Just<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">=</span> Just<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>

<span class="keyword1" id="Maybe_Monad-plusU_maybe_strict"><span class="command">lemma</span></span> plusU_maybe_strict <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"plusU<span class="main">⋅</span><span class="main">⊥</span><span class="main">⋅</span><span class="free">ys</span> <span class="main">=</span> <span class="main">(</span><span class="main">⊥</span><span class="main">::</span>udom<span class="main">⋅</span>maybe<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity"><span class="class_parameter">bindU_maybe</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom<span class="main">⋅</span>maybe <span class="main">→</span> <span class="main">(</span>udom <span class="main">→</span> udom<span class="main">⋅</span>maybe<span class="main">)</span> <span class="main">→</span> udom<span class="main">⋅</span>maybe"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">bindU_maybe</span><span class="main">⋅</span>Nothing<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">=</span> Nothing"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">bindU_maybe</span><span class="main">⋅</span><span class="main">(</span>Just<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>

<span class="keyword1" id="Maybe_Monad-bindU_maybe_strict"><span class="command">lemma</span></span> bindU_maybe_strict <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"bindU<span class="main">⋅</span><span class="main">⊥</span><span class="main">⋅</span><span class="free">k</span> <span class="main">=</span> <span class="main">(</span><span class="main">⊥</span><span class="main">::</span>udom<span class="main">⋅</span>maybe<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>

<span class="keyword1"><span class="command">definition</span></span> zeroU_maybe_def<span class="main">:</span>
  <span class="quoted"><span class="quoted">"zeroU <span class="main">=</span> Nothing"</span></span>

<span class="keyword1"><span class="command">definition</span></span> returnU_maybe_def<span class="main">:</span>
  <span class="quoted"><span class="quoted">"returnU <span class="main">=</span> Just"</span></span>

<span class="keyword1" id="Maybe_Monad-plusU_Nothing_right"><span class="command">lemma</span></span> plusU_Nothing_right<span class="main">:</span> <span class="quoted"><span class="quoted">"plusU<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span>Nothing <span class="main">=</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> maybe.induct<span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Maybe_Monad-bindU_plusU_maybe"><span class="command">lemma</span></span> bindU_plusU_maybe<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">xs</span> <span class="free">ys</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom<span class="main">⋅</span>maybe"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"bindU<span class="main">⋅</span><span class="main">(</span>plusU<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="free">ys</span><span class="main">)</span><span class="main">⋅</span><span class="free">f</span> <span class="main">=</span> plusU<span class="main">⋅</span><span class="main">(</span>bindU<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="free">f</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>bindU<span class="main">⋅</span><span class="free">ys</span><span class="main">⋅</span><span class="free">f</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> maybe.induct<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom"</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom <span class="main">→</span> udom"</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">h</span> <span class="skolem">k</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom <span class="main">→</span> udom<span class="main">⋅</span>maybe"</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="skolem">ys</span> <span class="skolem">zs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom<span class="main">⋅</span>maybe"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"fmapU<span class="main">⋅</span><span class="skolem">f</span><span class="main">⋅</span><span class="skolem">xs</span> <span class="main">=</span> bindU<span class="main">⋅</span><span class="skolem">xs</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> returnU<span class="main">⋅</span><span class="main">(</span><span class="skolem">f</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> maybe.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> returnU_maybe_def<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bindU<span class="main">⋅</span><span class="main">(</span>returnU<span class="main">⋅</span><span class="skolem">x</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">k</span> <span class="main">=</span> <span class="skolem">k</span><span class="main">⋅</span><span class="skolem">x</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> returnU_maybe_def plusU_Nothing_right<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bindU<span class="main">⋅</span><span class="main">(</span>bindU<span class="main">⋅</span><span class="skolem">xs</span><span class="main">⋅</span><span class="skolem">h</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">k</span> <span class="main">=</span> bindU<span class="main">⋅</span><span class="skolem">xs</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> bindU<span class="main">⋅</span><span class="main">(</span><span class="skolem">h</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">k</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> maybe.induct<span class="main">)</span> <span class="operator">simp_all</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"plusU<span class="main">⋅</span><span class="main">(</span>plusU<span class="main">⋅</span><span class="skolem">xs</span><span class="main">⋅</span><span class="skolem">ys</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">zs</span> <span class="main">=</span> plusU<span class="main">⋅</span><span class="skolem">xs</span><span class="main">⋅</span><span class="main">(</span>plusU<span class="main">⋅</span><span class="skolem">ys</span><span class="main">⋅</span><span class="skolem">zs</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> maybe.induct<span class="main">)</span> <span class="operator">simp_all</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bindU<span class="main">⋅</span>zeroU<span class="main">⋅</span><span class="skolem">k</span> <span class="main">=</span> zeroU"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zeroU_maybe_def<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"fmapU<span class="main">⋅</span><span class="skolem">f</span><span class="main">⋅</span><span class="main">(</span>plusU<span class="main">⋅</span><span class="skolem">xs</span><span class="main">⋅</span><span class="skolem">ys</span><span class="main">)</span> <span class="main">=</span> plusU<span class="main">⋅</span><span class="main">(</span>fmapU<span class="main">⋅</span><span class="skolem">f</span><span class="main">⋅</span><span class="skolem">xs</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>fmapU<span class="main">⋅</span><span class="skolem">f</span><span class="main">⋅</span><span class="skolem">ys</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> maybe.induct<span class="main">)</span> <span class="operator">simp_all</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"fmapU<span class="main">⋅</span><span class="skolem">f</span><span class="main">⋅</span>zeroU <span class="main">=</span> <span class="main">(</span>zeroU <span class="main">::</span> udom<span class="main">⋅</span>maybe<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zeroU_maybe_def<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"plusU<span class="main">⋅</span>zeroU<span class="main">⋅</span><span class="skolem">xs</span> <span class="main">=</span> <span class="skolem">xs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zeroU_maybe_def<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"plusU<span class="main">⋅</span><span class="skolem">xs</span><span class="main">⋅</span>zeroU <span class="main">=</span> <span class="skolem">xs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zeroU_maybe_def plusU_Nothing_right<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Transfer properties to polymorphic versions›</span></span>

<span class="keyword1" id="Maybe_Monad-fmap_maybe_simps"><span class="command">lemma</span></span> fmap_maybe_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"fmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="main">⊥</span><span class="main">::</span><span class="tfree">'a</span><span class="main">⋅</span>maybe<span class="main">)</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"fmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span>Nothing <span class="main">=</span> Nothing"</span></span>
  <span class="quoted"><span class="quoted">"fmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span>Just<span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> Just<span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> fmap_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="keyword1" id="Maybe_Monad-fplus_maybe_simps"><span class="command">lemma</span></span> fplus_maybe_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"fplus<span class="main">⋅</span><span class="main">(</span><span class="main">⊥</span><span class="main">::</span><span class="tfree">'a</span><span class="main">⋅</span>maybe<span class="main">)</span><span class="main">⋅</span><span class="free">ys</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"fplus<span class="main">⋅</span>Nothing<span class="main">⋅</span><span class="free">ys</span> <span class="main">=</span> <span class="free">ys</span>"</span></span>
  <span class="quoted"><span class="quoted">"fplus<span class="main">⋅</span><span class="main">(</span>Just<span class="main">⋅</span><span class="free">x</span><span class="main">)</span><span class="main">⋅</span><span class="free">ys</span> <span class="main">=</span> Just<span class="main">⋅</span><span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> fplus_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="keyword1" id="Maybe_Monad-fplus_Nothing_right"><span class="command">lemma</span></span> fplus_Nothing_right <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"fplus<span class="main">⋅</span><span class="free">m</span><span class="main">⋅</span>Nothing <span class="main">=</span> <span class="free">m</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fplus_def plusU_Nothing_right<span class="main">)</span>

<span class="keyword1" id="Maybe_Monad-bind_maybe_simps"><span class="command">lemma</span></span> bind_maybe_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"bind<span class="main">⋅</span><span class="main">(</span><span class="main">⊥</span><span class="main">::</span><span class="tfree">'a</span><span class="main">⋅</span>maybe<span class="main">)</span><span class="main">⋅</span><span class="free">f</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"bind<span class="main">⋅</span>Nothing<span class="main">⋅</span><span class="free">f</span> <span class="main">=</span> Nothing"</span></span>
  <span class="quoted"><span class="quoted">"bind<span class="main">⋅</span><span class="main">(</span>Just<span class="main">⋅</span><span class="free">x</span><span class="main">)</span><span class="main">⋅</span><span class="free">f</span> <span class="main">=</span> <span class="free">f</span><span class="main">⋅</span><span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> bind_def fplus_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="keyword1" id="Maybe_Monad-return_maybe_def"><span class="command">lemma</span></span> return_maybe_def<span class="main">:</span> <span class="quoted"><span class="quoted">"return <span class="main">=</span> Just"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_def returnU_maybe_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> coerce_cfun cfcomp1 eta_cfun<span class="main">)</span>

<span class="keyword1" id="Maybe_Monad-mzero_maybe_def"><span class="command">lemma</span></span> mzero_maybe_def<span class="main">:</span> <span class="quoted"><span class="quoted">"mzero <span class="main">=</span> Nothing"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> mzero_def zeroU_maybe_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Maybe_Monad-join_maybe_simps"><span class="command">lemma</span></span> join_maybe_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"join<span class="main">⋅</span><span class="main">(</span><span class="main">⊥</span><span class="main">::</span><span class="tfree">'a</span><span class="main">⋅</span>maybe<span class="main">⋅</span>maybe<span class="main">)</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"join<span class="main">⋅</span>Nothing <span class="main">=</span> Nothing"</span></span>
  <span class="quoted"><span class="quoted">"join<span class="main">⋅</span><span class="main">(</span>Just<span class="main">⋅</span><span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> join_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Maybe is not in <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>monad_plus›</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>maybe›</span></span></span></span> type does not satisfy the law <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>bind_mplus›</span></span></span></span>.
›</span></span>

<span class="keyword1" id="Maybe_Monad-maybe_counterexample1"><span class="command">lemma</span></span> maybe_counterexample1<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">a</span> <span class="main">=</span> Just<span class="main">⋅</span><span class="free">x</span><span class="main">;</span> <span class="free">b</span> <span class="main">=</span> <span class="main">⊥</span><span class="main">;</span> <span class="free">k</span><span class="main">⋅</span><span class="free">x</span> <span class="main">=</span> Nothing<span class="main">⟧</span>
    <span class="main">⟹</span> fplus<span class="main">⋅</span><span class="free">a</span><span class="main">⋅</span><span class="free">b</span> <span class="main">⤜</span> <span class="free">k</span> <span class="main">≠</span> fplus<span class="main">⋅</span><span class="main">(</span><span class="free">a</span> <span class="main">⤜</span> <span class="free">k</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free">b</span> <span class="main">⤜</span> <span class="free">k</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Maybe_Monad-maybe_counterexample2"><span class="command">lemma</span></span> maybe_counterexample2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">a</span> <span class="main">=</span> Just<span class="main">⋅</span><span class="free">x</span><span class="main">;</span> <span class="free">b</span> <span class="main">=</span> Just<span class="main">⋅</span><span class="free">y</span><span class="main">;</span> <span class="free">k</span><span class="main">⋅</span><span class="free">x</span> <span class="main">=</span> Nothing<span class="main">;</span> <span class="free">k</span><span class="main">⋅</span><span class="free">y</span> <span class="main">=</span> Just<span class="main">⋅</span><span class="free">z</span><span class="main">⟧</span>
    <span class="main">⟹</span> fplus<span class="main">⋅</span><span class="free">a</span><span class="main">⋅</span><span class="free">b</span> <span class="main">⤜</span> <span class="free">k</span> <span class="main">≠</span> fplus<span class="main">⋅</span><span class="main">(</span><span class="free">a</span> <span class="main">⤜</span> <span class="free">k</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free">b</span> <span class="main">⤜</span> <span class="free">k</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Error_Monad">
<div class="head">
<h1>Theory Error_Monad</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Error monad›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Error_Monad
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Monad_Plus.html">Monad_Plus</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Type definition›</span></span>

<span class="keyword1"><span class="command">tycondef</span></span> <span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'e</span> error <span class="main">=</span> Err <span class="main">(</span><span class="keyword2"><span class="keyword">lazy</span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'e</span>"</span></span><span class="main">)</span> <span class="main">|</span> Ok <span class="main">(</span><span class="keyword2"><span class="keyword">lazy</span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span>"</span></span><span class="main">)</span>

<span class="keyword1" id="Error_Monad-coerce_error_abs"><span class="command">lemma</span></span> coerce_error_abs <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"coerce<span class="main">⋅</span><span class="main">(</span>error_abs<span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> error_abs<span class="main">⋅</span><span class="main">(</span>coerce<span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> error_abs_def coerce_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> emb_prj_emb prj_emb_prj DEFL_eq_error<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Error_Monad-coerce_Err"><span class="command">lemma</span></span> coerce_Err <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"coerce<span class="main">⋅</span><span class="main">(</span>Err<span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> Err<span class="main">⋅</span><span class="main">(</span>coerce<span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> Err_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Error_Monad-coerce_Ok"><span class="command">lemma</span></span> coerce_Ok <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"coerce<span class="main">⋅</span><span class="main">(</span>Ok<span class="main">⋅</span><span class="free">m</span><span class="main">)</span> <span class="main">=</span> Ok<span class="main">⋅</span><span class="main">(</span>coerce<span class="main">⋅</span><span class="free">m</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> Ok_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Error_Monad-fmapU_error_simps"><span class="command">lemma</span></span> fmapU_error_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"fmapU<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="main">⊥</span><span class="main">::</span>udom<span class="main">⋅</span><span class="tfree">'a</span> error<span class="main">)</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"fmapU<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span>Err<span class="main">⋅</span><span class="free">e</span><span class="main">)</span> <span class="main">=</span> Err<span class="main">⋅</span><span class="free">e</span>"</span></span>
  <span class="quoted"><span class="quoted">"fmapU<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span>Ok<span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> Ok<span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> fmapU_error_def error_map_def fix_const
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Err_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Ok_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Monad class instance›</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> error <span class="main">::</span> <span class="main">(</span><span class="quoted"><span class="quoted">"domain"</span></span><span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="main">{</span>monad<span class="main">,</span> functor_plus<span class="main">}</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"returnU <span class="main">=</span> Ok"</span></span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity"><span class="class_parameter">bindU_error</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom<span class="main">⋅</span><span class="tfree">'a</span> error <span class="main">→</span> <span class="main">(</span>udom <span class="main">→</span> udom<span class="main">⋅</span><span class="tfree">'a</span> error<span class="main">)</span> <span class="main">→</span> udom<span class="main">⋅</span><span class="tfree">'a</span> error"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">bindU_error</span><span class="main">⋅</span><span class="main">(</span>Err<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> Err<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">e</span></span></span>"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">bindU_error</span><span class="main">⋅</span><span class="main">(</span>Ok<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>

<span class="keyword1" id="Error_Monad-bindU_error_strict"><span class="command">lemma</span></span> bindU_error_strict <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"bindU<span class="main">⋅</span><span class="main">⊥</span><span class="main">⋅</span><span class="free">k</span> <span class="main">=</span> <span class="main">(</span><span class="main">⊥</span><span class="main">::</span>udom<span class="main">⋅</span><span class="tfree">'a</span> error<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity"><span class="class_parameter">plusU_error</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom<span class="main">⋅</span><span class="tfree">'a</span> error <span class="main">→</span> udom<span class="main">⋅</span><span class="tfree">'a</span> error <span class="main">→</span> udom<span class="main">⋅</span><span class="tfree">'a</span> error"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">plusU_error</span><span class="main">⋅</span><span class="main">(</span>Err<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span>"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">plusU_error</span><span class="main">⋅</span><span class="main">(</span>Ok<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> Ok<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>

<span class="keyword1" id="Error_Monad-plusU_error_strict"><span class="command">lemma</span></span> plusU_error_strict <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"plusU<span class="main">⋅</span><span class="main">(</span><span class="main">⊥</span> <span class="main">::</span> udom<span class="main">⋅</span><span class="tfree">'a</span> error<span class="main">)</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>

<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">f</span> <span class="skolem">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom <span class="main">→</span> udom"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">r</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom<span class="main">⋅</span><span class="tfree">'a</span> error"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"fmapU<span class="main">⋅</span><span class="skolem">f</span><span class="main">⋅</span><span class="main">(</span>fmapU<span class="main">⋅</span><span class="skolem">g</span><span class="main">⋅</span><span class="skolem">r</span><span class="main">)</span> <span class="main">=</span> fmapU<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="skolem">f</span><span class="main">⋅</span><span class="main">(</span><span class="skolem">g</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">r</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">r</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> error.induct<span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom <span class="main">→</span> udom"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">r</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom<span class="main">⋅</span><span class="tfree">'a</span> error"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"fmapU<span class="main">⋅</span><span class="skolem">f</span><span class="main">⋅</span><span class="skolem">r</span> <span class="main">=</span> bindU<span class="main">⋅</span><span class="skolem">r</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> returnU<span class="main">⋅</span><span class="main">(</span><span class="skolem">f</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">r</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> error.induct<span class="main">)</span>
       <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> returnU_error_def<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom <span class="main">→</span> udom<span class="main">⋅</span><span class="tfree">'a</span> error"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bindU<span class="main">⋅</span><span class="main">(</span>returnU<span class="main">⋅</span><span class="skolem">x</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">f</span> <span class="main">=</span> <span class="skolem">f</span><span class="main">⋅</span><span class="skolem">x</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> returnU_error_def<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">r</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom<span class="main">⋅</span><span class="tfree">'a</span> error"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="skolem">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom <span class="main">→</span> udom<span class="main">⋅</span><span class="tfree">'a</span> error"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bindU<span class="main">⋅</span><span class="main">(</span>bindU<span class="main">⋅</span><span class="skolem">r</span><span class="main">⋅</span><span class="skolem">f</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">g</span> <span class="main">=</span> bindU<span class="main">⋅</span><span class="skolem">r</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> bindU<span class="main">⋅</span><span class="main">(</span><span class="skolem">f</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">g</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">r</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> error.induct<span class="main">)</span>
       <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom <span class="main">→</span> udom"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom<span class="main">⋅</span><span class="tfree">'a</span> error"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"fmapU<span class="main">⋅</span><span class="skolem">f</span><span class="main">⋅</span><span class="main">(</span>plusU<span class="main">⋅</span><span class="skolem">a</span><span class="main">⋅</span><span class="skolem">b</span><span class="main">)</span> <span class="main">=</span> plusU<span class="main">⋅</span><span class="main">(</span>fmapU<span class="main">⋅</span><span class="skolem">f</span><span class="main">⋅</span><span class="skolem">a</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>fmapU<span class="main">⋅</span><span class="skolem">f</span><span class="main">⋅</span><span class="skolem">b</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">a</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> error.induct<span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="skolem">c</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom<span class="main">⋅</span><span class="tfree">'a</span> error"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"plusU<span class="main">⋅</span><span class="main">(</span>plusU<span class="main">⋅</span><span class="skolem">a</span><span class="main">⋅</span><span class="skolem">b</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">c</span> <span class="main">=</span> plusU<span class="main">⋅</span><span class="skolem">a</span><span class="main">⋅</span><span class="main">(</span>plusU<span class="main">⋅</span><span class="skolem">b</span><span class="main">⋅</span><span class="skolem">c</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">a</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> error.induct<span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Transfer properties to polymorphic versions›</span></span>

<span class="keyword1" id="Error_Monad-fmap_error_simps"><span class="command">lemma</span></span> fmap_error_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"fmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="main">⊥</span><span class="main">::</span><span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'e</span> error<span class="main">)</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"fmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span>Err<span class="main">⋅</span><span class="free">e</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'e</span> error<span class="main">)</span> <span class="main">=</span> Err<span class="main">⋅</span><span class="free">e</span>"</span></span>
  <span class="quoted"><span class="quoted">"fmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span>Ok<span class="main">⋅</span><span class="free">x</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'e</span> error<span class="main">)</span> <span class="main">=</span> Ok<span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> fmap_def <span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'f</span><span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="tfree">'e</span> error"</span></span><span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">coerce_simp</span></span><span class="main">)</span>

<span class="keyword1" id="Error_Monad-return_error_def"><span class="command">lemma</span></span> return_error_def<span class="main">:</span> <span class="quoted"><span class="quoted">"return <span class="main">=</span> Ok"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_def returnU_error_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">coerce_simp</span></span> eta_cfun<span class="main">)</span>

<span class="keyword1" id="Error_Monad-bind_error_simps"><span class="command">lemma</span></span> bind_error_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"bind<span class="main">⋅</span><span class="main">(</span><span class="main">⊥</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'e</span> error<span class="main">)</span><span class="main">⋅</span><span class="free">f</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"bind<span class="main">⋅</span><span class="main">(</span>Err<span class="main">⋅</span><span class="free">e</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'e</span> error<span class="main">)</span><span class="main">⋅</span><span class="free">f</span> <span class="main">=</span> Err<span class="main">⋅</span><span class="free">e</span>"</span></span>
  <span class="quoted"><span class="quoted">"bind<span class="main">⋅</span><span class="main">(</span>Ok<span class="main">⋅</span><span class="free">x</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'e</span> error<span class="main">)</span><span class="main">⋅</span><span class="free">f</span> <span class="main">=</span> <span class="free">f</span><span class="main">⋅</span><span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> bind_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">coerce_simp</span></span><span class="main">)</span>

<span class="keyword1" id="Error_Monad-join_error_simps"><span class="command">lemma</span></span> join_error_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"join<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">(</span><span class="main">⊥</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'e</span> error<span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"join<span class="main">⋅</span><span class="main">(</span>Err<span class="main">⋅</span><span class="free">e</span><span class="main">)</span> <span class="main">=</span> Err<span class="main">⋅</span><span class="free">e</span>"</span></span>
  <span class="quoted"><span class="quoted">"join<span class="main">⋅</span><span class="main">(</span>Ok<span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> join_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="keyword1" id="Error_Monad-fplus_error_simps"><span class="command">lemma</span></span> fplus_error_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"fplus<span class="main">⋅</span><span class="main">⊥</span><span class="main">⋅</span><span class="free">r</span> <span class="main">=</span> <span class="main">(</span><span class="main">⊥</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'e</span> error<span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"fplus<span class="main">⋅</span><span class="main">(</span>Err<span class="main">⋅</span><span class="free">e</span><span class="main">)</span><span class="main">⋅</span><span class="free">r</span> <span class="main">=</span> <span class="free">r</span>"</span></span>
  <span class="quoted"><span class="quoted">"fplus<span class="main">⋅</span><span class="main">(</span>Ok<span class="main">⋅</span><span class="free">x</span><span class="main">)</span><span class="main">⋅</span><span class="free">r</span> <span class="main">=</span> Ok<span class="main">⋅</span><span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> fplus_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">coerce_simp</span></span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Writer_Monad">
<div class="head">
<h1>Theory Writer_Monad</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Writer monad›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Writer_Monad
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Monad.html">Monad</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Monoid class›</span></span>

<span class="keyword1"><span class="command">class</span></span> monoid <span class="main">=</span> <span class="quoted">"domain"</span> <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free"><span class="free"><span class="free">mempty</span></span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span>"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free"><span class="free"><span class="free">mappend</span></span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'a</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> mempty_left<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">ys</span><span class="main">.</span> <span class="free">mappend</span><span class="main">⋅</span><span class="free">mempty</span><span class="main">⋅</span><span class="bound">ys</span> <span class="main">=</span> <span class="bound">ys</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> mempty_right<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span><span class="main">.</span> <span class="free">mappend</span><span class="main">⋅</span><span class="bound">xs</span><span class="main">⋅</span><span class="free">mempty</span> <span class="main">=</span> <span class="bound">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> mappend_assoc<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xs</span> <span class="bound">ys</span> <span class="bound">zs</span><span class="main">.</span> <span class="free">mappend</span><span class="main">⋅</span><span class="main">(</span><span class="free">mappend</span><span class="main">⋅</span><span class="bound">xs</span><span class="main">⋅</span><span class="bound">ys</span><span class="main">)</span><span class="main">⋅</span><span class="bound">zs</span> <span class="main">=</span> <span class="free">mappend</span><span class="main">⋅</span><span class="bound">xs</span><span class="main">⋅</span><span class="main">(</span><span class="free">mappend</span><span class="main">⋅</span><span class="bound">ys</span><span class="main">⋅</span><span class="bound">zs</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Writer monad type›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Below is the standard Haskell definition of a writer monad
type; it is an isomorphic copy of the lazy pair type \texttt{(a, w)}.
›</span></span>

<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹
\begin{verbatim}
newtype Writer w a = Writer { runWriter :: (a, w) }
\end{verbatim}
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Since HOLCF does not have a pre-defined lazy pair type, we
will base this formalization on an equivalent, more direct definition:
›</span></span>

<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹
\begin{verbatim}
data Writer w a = Writer w a
\end{verbatim}
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We can directly translate the above Haskell type definition
using <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>tycondef›</span></span></span></span>. \medskip›</span></span>

<span class="keyword1"><span class="command">tycondef</span></span> <span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'w</span> writer <span class="main">=</span> Writer <span class="main">(</span><span class="keyword2"><span class="keyword">lazy</span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'w</span>"</span></span><span class="main">)</span> <span class="main">(</span><span class="keyword2"><span class="keyword">lazy</span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span>"</span></span><span class="main">)</span>

<span class="keyword1" id="Writer_Monad-coerce_writer_abs"><span class="command">lemma</span></span> coerce_writer_abs <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"coerce<span class="main">⋅</span><span class="main">(</span>writer_abs<span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> writer_abs<span class="main">⋅</span><span class="main">(</span>coerce<span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> writer_abs_def coerce_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> emb_prj_emb prj_emb_prj DEFL_eq_writer<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Writer_Monad-coerce_Writer"><span class="command">lemma</span></span> coerce_Writer <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"coerce<span class="main">⋅</span><span class="main">(</span>Writer<span class="main">⋅</span><span class="free">w</span><span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> Writer<span class="main">⋅</span><span class="main">(</span>coerce<span class="main">⋅</span><span class="free">w</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>coerce<span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> Writer_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Writer_Monad-fmapU_writer_simps"><span class="command">lemma</span></span> fmapU_writer_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"fmapU<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="main">⊥</span><span class="main">::</span>udom<span class="main">⋅</span><span class="tfree">'w</span> writer<span class="main">)</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"fmapU<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span>Writer<span class="main">⋅</span><span class="free">w</span><span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> Writer<span class="main">⋅</span><span class="free">w</span><span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> fmapU_writer_def writer_map_def fix_const
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Writer_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Class instance proofs›</span></span>

<span class="keyword1"><span class="command">instance</span></span> writer <span class="main">::</span> <span class="main">(</span><span class="quoted"><span class="quoted">"domain"</span></span><span class="main">)</span> <span class="quoted"><span class="quoted">"functor"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">f</span> <span class="skolem">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom <span class="main">→</span> udom"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom<span class="main">⋅</span><span class="tfree">'a</span> writer"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"fmapU<span class="main">⋅</span><span class="skolem">f</span><span class="main">⋅</span><span class="main">(</span>fmapU<span class="main">⋅</span><span class="skolem">g</span><span class="main">⋅</span><span class="skolem">xs</span><span class="main">)</span> <span class="main">=</span> fmapU<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="skolem">f</span><span class="main">⋅</span><span class="main">(</span><span class="skolem">g</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">xs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> writer.induct<span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> writer <span class="main">::</span> <span class="main">(</span><span class="quoted">monoid</span><span class="main">)</span> <span class="quoted">monad</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity"><span class="class_parameter">bindU_writer</span></span> <span class="main">::</span>
    <span class="quoted"><span class="quoted">"udom<span class="main">⋅</span><span class="tfree">'a</span> writer <span class="main">→</span> <span class="main">(</span>udom <span class="main">→</span> udom<span class="main">⋅</span><span class="tfree">'a</span> writer<span class="main">)</span> <span class="main">→</span> udom<span class="main">⋅</span><span class="tfree">'a</span> writer"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">bindU_writer</span><span class="main">⋅</span><span class="main">(</span>Writer<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">w</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span>
    <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">of</span> Writer<span class="main">⋅</span><span class="bound">w'</span><span class="main">⋅</span><span class="bound">y</span> <span class="main">⇒</span> Writer<span class="main">⋅</span><span class="main">(</span>mappend<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">w</span></span></span><span class="main">⋅</span><span class="bound">w'</span><span class="main">)</span><span class="main">⋅</span><span class="bound">y</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Writer_Monad-bindU_writer_strict"><span class="command">lemma</span></span> bindU_writer_strict <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"bindU<span class="main">⋅</span><span class="main">⊥</span><span class="main">⋅</span><span class="free">k</span> <span class="main">=</span> <span class="main">(</span><span class="main">⊥</span><span class="main">::</span>udom<span class="main">⋅</span><span class="tfree">'a</span> writer<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"returnU <span class="main">=</span> Writer<span class="main">⋅</span>mempty"</span></span>

<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom <span class="main">→</span> udom"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">m</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom<span class="main">⋅</span><span class="tfree">'a</span> writer"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"fmapU<span class="main">⋅</span><span class="skolem">f</span><span class="main">⋅</span><span class="skolem">m</span> <span class="main">=</span> bindU<span class="main">⋅</span><span class="skolem">m</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> returnU<span class="main">⋅</span><span class="main">(</span><span class="skolem">f</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">m</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> writer.induct<span class="main">)</span>
       <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> returnU_writer_def mempty_right<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom <span class="main">→</span> udom<span class="main">⋅</span><span class="tfree">'a</span> writer"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bindU<span class="main">⋅</span><span class="main">(</span>returnU<span class="main">⋅</span><span class="skolem">x</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">f</span> <span class="main">=</span> <span class="skolem">f</span><span class="main">⋅</span><span class="skolem">x</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span><span class="main">⋅</span><span class="skolem">x</span>"</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> writer.exhaust<span class="main">)</span>
       <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> returnU_writer_def mempty_left<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">m</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom<span class="main">⋅</span><span class="tfree">'a</span> writer"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="skolem">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom <span class="main">→</span> udom<span class="main">⋅</span><span class="tfree">'a</span> writer"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bindU<span class="main">⋅</span><span class="main">(</span>bindU<span class="main">⋅</span><span class="skolem">m</span><span class="main">⋅</span><span class="skolem">f</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">g</span> <span class="main">=</span> bindU<span class="main">⋅</span><span class="skolem">m</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> bindU<span class="main">⋅</span><span class="main">(</span><span class="skolem">f</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">g</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">m</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> writer.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span><span class="main">⋅</span><span class="improper">a</span>"</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> writer.exhaust<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"<span class="skolem">g</span><span class="main">⋅</span><span class="improper">aa</span>"</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> writer.exhaust<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mappend_assoc<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Transfer properties to polymorphic versions›</span></span>

<span class="keyword1" id="Writer_Monad-fmap_writer_simps"><span class="command">lemma</span></span> fmap_writer_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"fmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="main">⊥</span><span class="main">::</span><span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'w</span> writer<span class="main">)</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"fmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span>Writer<span class="main">⋅</span><span class="free">w</span><span class="main">⋅</span><span class="free">x</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'w</span> writer<span class="main">)</span> <span class="main">=</span> Writer<span class="main">⋅</span><span class="free">w</span><span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> fmap_def <span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'f</span><span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="tfree">'w</span> writer"</span></span><span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">coerce_simp</span></span><span class="main">)</span>

<span class="keyword1" id="Writer_Monad-return_writer_def"><span class="command">lemma</span></span> return_writer_def<span class="main">:</span> <span class="quoted"><span class="quoted">"return <span class="main">=</span> Writer<span class="main">⋅</span>mempty"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_def returnU_writer_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">coerce_simp</span></span> eta_cfun<span class="main">)</span>

<span class="keyword1" id="Writer_Monad-bind_writer_simps"><span class="command">lemma</span></span> bind_writer_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"bind<span class="main">⋅</span><span class="main">(</span><span class="main">⊥</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'w</span><span class="main">::</span>monoid writer<span class="main">)</span><span class="main">⋅</span><span class="free">f</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"bind<span class="main">⋅</span><span class="main">(</span>Writer<span class="main">⋅</span><span class="free">w</span><span class="main">⋅</span><span class="free">x</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'w</span><span class="main">::</span>monoid writer<span class="main">)</span><span class="main">⋅</span><span class="free">k</span> <span class="main">=</span>
    <span class="main">(</span><span class="keyword1">case</span> <span class="free">k</span><span class="main">⋅</span><span class="free">x</span> <span class="keyword1">of</span> Writer<span class="main">⋅</span><span class="bound">w'</span><span class="main">⋅</span><span class="bound">y</span> <span class="main">⇒</span> Writer<span class="main">⋅</span><span class="main">(</span>mappend<span class="main">⋅</span><span class="free">w</span><span class="main">⋅</span><span class="bound">w'</span><span class="main">)</span><span class="main">⋅</span><span class="bound">y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> bind_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">coerce_simp</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">k</span><span class="main">⋅</span><span class="free">x</span>"</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> writer.exhaust<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">coerce_simp</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Writer_Monad-join_writer_simps"><span class="command">lemma</span></span> join_writer_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"join<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">(</span><span class="main">⊥</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'w</span><span class="main">::</span>monoid writer<span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"join<span class="main">⋅</span><span class="main">(</span>Writer<span class="main">⋅</span><span class="free">w</span><span class="main">⋅</span><span class="main">(</span>Writer<span class="main">⋅</span><span class="free">w'</span><span class="main">⋅</span><span class="free">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> Writer<span class="main">⋅</span><span class="main">(</span>mappend<span class="main">⋅</span><span class="free">w</span><span class="main">⋅</span><span class="free">w'</span><span class="main">)</span><span class="main">⋅</span><span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> join_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Extra operations›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">tell</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'w</span> <span class="main">→</span> unit<span class="main">⋅</span><span class="main">(</span><span class="tfree">'w</span><span class="main">::</span>monoid writer<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">tell</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> w<span class="main">.</span> Writer<span class="main">⋅</span><span class="bound">w</span><span class="main">⋅</span><span class="main">()</span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Binary_Tree_Monad">
<div class="head">
<h1>Theory Binary_Tree_Monad</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Binary tree monad›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Binary_Tree_Monad
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Monad.html">Monad</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Type definition›</span></span>

<span class="keyword1"><span class="command">tycondef</span></span> <span class="tfree">'a</span><span class="main">⋅</span>btree <span class="main">=</span>
  Leaf <span class="main">(</span><span class="keyword2"><span class="keyword">lazy</span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span>"</span></span><span class="main">)</span> <span class="main">|</span> Node <span class="main">(</span><span class="keyword2"><span class="keyword">lazy</span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">⋅</span>btree"</span></span><span class="main">)</span> <span class="main">(</span><span class="keyword2"><span class="keyword">lazy</span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">⋅</span>btree"</span></span><span class="main">)</span>

<span class="keyword1" id="Binary_Tree_Monad-coerce_btree_abs"><span class="command">lemma</span></span> coerce_btree_abs <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"coerce<span class="main">⋅</span><span class="main">(</span>btree_abs<span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> btree_abs<span class="main">⋅</span><span class="main">(</span>coerce<span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> btree_abs_def coerce_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> emb_prj_emb prj_emb_prj DEFL_eq_btree<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Binary_Tree_Monad-coerce_Leaf"><span class="command">lemma</span></span> coerce_Leaf <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"coerce<span class="main">⋅</span><span class="main">(</span>Leaf<span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> Leaf<span class="main">⋅</span><span class="main">(</span>coerce<span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> Leaf_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Binary_Tree_Monad-coerce_Node"><span class="command">lemma</span></span> coerce_Node <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"coerce<span class="main">⋅</span><span class="main">(</span>Node<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="free">ys</span><span class="main">)</span> <span class="main">=</span> Node<span class="main">⋅</span><span class="main">(</span>coerce<span class="main">⋅</span><span class="free">xs</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>coerce<span class="main">⋅</span><span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> Node_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Binary_Tree_Monad-fmapU_btree_simps"><span class="command">lemma</span></span> fmapU_btree_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"fmapU<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="main">⊥</span><span class="main">::</span>udom<span class="main">⋅</span>btree<span class="main">)</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"fmapU<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span>Leaf<span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> Leaf<span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"fmapU<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span>Node<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="free">ys</span><span class="main">)</span> <span class="main">=</span> Node<span class="main">⋅</span><span class="main">(</span>fmapU<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>fmapU<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> fmapU_btree_def btree_map_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> fix_eq<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> fix_eq<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Leaf_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> fix_eq<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Node_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Class instance proofs›</span></span>

<span class="keyword1"><span class="command">instance</span></span> btree <span class="main">::</span> <span class="quoted"><span class="quoted">"functor"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">standard</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="improper"><span class="quoted"><span class="improper">xs</span></span></span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> btree.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">instantiation</span></span> btree <span class="main">::</span> <span class="quoted">monad</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"returnU <span class="main">=</span> Leaf"</span></span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity"><span class="class_parameter">bindU_btree</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom<span class="main">⋅</span>btree <span class="main">→</span> <span class="main">(</span>udom <span class="main">→</span> udom<span class="main">⋅</span>btree<span class="main">)</span> <span class="main">→</span> udom<span class="main">⋅</span>btree"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">bindU_btree</span><span class="main">⋅</span><span class="main">(</span>Leaf<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">bindU_btree</span><span class="main">⋅</span><span class="main">(</span>Node<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">=</span>
      Node<span class="main">⋅</span><span class="main">(</span><span class="free">bindU_btree</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free">bindU_btree</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Binary_Tree_Monad-bindU_btree_strict"><span class="command">lemma</span></span> bindU_btree_strict <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"bindU<span class="main">⋅</span><span class="main">⊥</span><span class="main">⋅</span><span class="free">k</span> <span class="main">=</span> <span class="main">(</span><span class="main">⊥</span><span class="main">::</span>udom<span class="main">⋅</span>btree<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>

<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom"</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom <span class="main">→</span> udom"</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">h</span> <span class="skolem">k</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom <span class="main">→</span> udom<span class="main">⋅</span>btree"</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom<span class="main">⋅</span>btree"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"fmapU<span class="main">⋅</span><span class="skolem">f</span><span class="main">⋅</span><span class="skolem">xs</span> <span class="main">=</span> bindU<span class="main">⋅</span><span class="skolem">xs</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> returnU<span class="main">⋅</span><span class="main">(</span><span class="skolem">f</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> btree.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> returnU_btree_def<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bindU<span class="main">⋅</span><span class="main">(</span>returnU<span class="main">⋅</span><span class="skolem">x</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">k</span> <span class="main">=</span> <span class="skolem">k</span><span class="main">⋅</span><span class="skolem">x</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> returnU_btree_def<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bindU<span class="main">⋅</span><span class="main">(</span>bindU<span class="main">⋅</span><span class="skolem">xs</span><span class="main">⋅</span><span class="skolem">h</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">k</span> <span class="main">=</span> bindU<span class="main">⋅</span><span class="skolem">xs</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> bindU<span class="main">⋅</span><span class="main">(</span><span class="skolem">h</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">k</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> btree.induct<span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Transfer properties to polymorphic versions›</span></span>

<span class="keyword1" id="Binary_Tree_Monad-fmap_btree_simps"><span class="command">lemma</span></span> fmap_btree_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"fmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="main">⊥</span><span class="main">::</span><span class="tfree">'a</span><span class="main">⋅</span>btree<span class="main">)</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"fmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span>Leaf<span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> Leaf<span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"fmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span>Node<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="free">ys</span><span class="main">)</span> <span class="main">=</span> Node<span class="main">⋅</span><span class="main">(</span>fmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>fmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> fmap_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="keyword1" id="Binary_Tree_Monad-bind_btree_simps"><span class="command">lemma</span></span> bind_btree_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"bind<span class="main">⋅</span><span class="main">(</span><span class="main">⊥</span><span class="main">::</span><span class="tfree">'a</span><span class="main">⋅</span>btree<span class="main">)</span><span class="main">⋅</span><span class="free">k</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"bind<span class="main">⋅</span><span class="main">(</span>Leaf<span class="main">⋅</span><span class="free">x</span><span class="main">)</span><span class="main">⋅</span><span class="free">k</span> <span class="main">=</span> <span class="free">k</span><span class="main">⋅</span><span class="free">x</span>"</span></span>
  <span class="quoted"><span class="quoted">"bind<span class="main">⋅</span><span class="main">(</span>Node<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="free">ys</span><span class="main">)</span><span class="main">⋅</span><span class="free">k</span> <span class="main">=</span> Node<span class="main">⋅</span><span class="main">(</span>bind<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="free">k</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>bind<span class="main">⋅</span><span class="free">ys</span><span class="main">⋅</span><span class="free">k</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> bind_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">coerce_simp</span></span><span class="main">)</span>

<span class="keyword1" id="Binary_Tree_Monad-return_btree_def"><span class="command">lemma</span></span> return_btree_def<span class="main">:</span>
  <span class="quoted"><span class="quoted">"return <span class="main">=</span> Leaf"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_def returnU_btree_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">coerce_simp</span></span> eta_cfun<span class="main">)</span>

<span class="keyword1" id="Binary_Tree_Monad-join_btree_simps"><span class="command">lemma</span></span> join_btree_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"join<span class="main">⋅</span><span class="main">(</span><span class="main">⊥</span><span class="main">::</span><span class="tfree">'a</span><span class="main">⋅</span>btree<span class="main">⋅</span>btree<span class="main">)</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"join<span class="main">⋅</span><span class="main">(</span>Leaf<span class="main">⋅</span><span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
  <span class="quoted"><span class="quoted">"join<span class="main">⋅</span><span class="main">(</span>Node<span class="main">⋅</span><span class="free">xss</span><span class="main">⋅</span><span class="free">yss</span><span class="main">)</span> <span class="main">=</span> Node<span class="main">⋅</span><span class="main">(</span>join<span class="main">⋅</span><span class="free">xss</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>join<span class="main">⋅</span><span class="free">yss</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> join_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Lift_Monad">
<div class="head">
<h1>Theory Lift_Monad</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Lift monad›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Lift_Monad
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Monad.html">Monad</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Type definition›</span></span>

<span class="keyword1"><span class="command">tycondef</span></span> <span class="tfree">'a</span><span class="main">⋅</span>lifted <span class="main">=</span> Lifted <span class="main">(</span><span class="keyword2"><span class="keyword">lazy</span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span>"</span></span><span class="main">)</span>

<span class="keyword1" id="Lift_Monad-coerce_lifted_abs"><span class="command">lemma</span></span> coerce_lifted_abs <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"coerce<span class="main">⋅</span><span class="main">(</span>lifted_abs<span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> lifted_abs<span class="main">⋅</span><span class="main">(</span>coerce<span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lifted_abs_def coerce_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> emb_prj_emb prj_emb_prj DEFL_eq_lifted<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Lift_Monad-coerce_Lifted"><span class="command">lemma</span></span> coerce_Lifted <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"coerce<span class="main">⋅</span><span class="main">(</span>Lifted<span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> Lifted<span class="main">⋅</span><span class="main">(</span>coerce<span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> Lifted_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Lift_Monad-fmapU_lifted_simps"><span class="command">lemma</span></span> fmapU_lifted_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"fmapU<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="main">⊥</span><span class="main">::</span>udom<span class="main">⋅</span>lifted<span class="main">)</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"fmapU<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span>Lifted<span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> Lifted<span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> fmapU_lifted_def lifted_map_def fix_const
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Lifted_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Class instance proofs›</span></span>

<span class="keyword1"><span class="command">instance</span></span> lifted <span class="main">::</span> <span class="quoted"><span class="quoted">"functor"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="improper"><span class="quoted"><span class="improper">xs</span></span></span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lifted.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1"><span class="command">instantiation</span></span> lifted <span class="main">::</span> <span class="quoted">monad</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity"><span class="class_parameter">bindU_lifted</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom<span class="main">⋅</span>lifted <span class="main">→</span> <span class="main">(</span>udom <span class="main">→</span> udom<span class="main">⋅</span>lifted<span class="main">)</span> <span class="main">→</span> udom<span class="main">⋅</span>lifted"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">bindU_lifted</span><span class="main">⋅</span><span class="main">(</span>Lifted<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>

<span class="keyword1" id="Lift_Monad-bindU_lifted_strict"><span class="command">lemma</span></span> bindU_lifted_strict <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"bindU<span class="main">⋅</span><span class="main">⊥</span><span class="main">⋅</span><span class="free">k</span> <span class="main">=</span> <span class="main">(</span><span class="main">⊥</span><span class="main">::</span>udom<span class="main">⋅</span>lifted<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>

<span class="keyword1"><span class="command">definition</span></span> returnU_lifted_def<span class="main">:</span>
  <span class="quoted"><span class="quoted">"returnU <span class="main">=</span> Lifted"</span></span>

<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom"</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom <span class="main">→</span> udom"</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">h</span> <span class="skolem">k</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom <span class="main">→</span> udom<span class="main">⋅</span>lifted"</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom<span class="main">⋅</span>lifted"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"fmapU<span class="main">⋅</span><span class="skolem">f</span><span class="main">⋅</span><span class="skolem">xs</span> <span class="main">=</span> bindU<span class="main">⋅</span><span class="skolem">xs</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> returnU<span class="main">⋅</span><span class="main">(</span><span class="skolem">f</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lifted.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> returnU_lifted_def<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bindU<span class="main">⋅</span><span class="main">(</span>returnU<span class="main">⋅</span><span class="skolem">x</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">k</span> <span class="main">=</span> <span class="skolem">k</span><span class="main">⋅</span><span class="skolem">x</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> returnU_lifted_def<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bindU<span class="main">⋅</span><span class="main">(</span>bindU<span class="main">⋅</span><span class="skolem">xs</span><span class="main">⋅</span><span class="skolem">h</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">k</span> <span class="main">=</span> bindU<span class="main">⋅</span><span class="skolem">xs</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> bindU<span class="main">⋅</span><span class="main">(</span><span class="skolem">h</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">k</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> lifted.induct<span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Transfer properties to polymorphic versions›</span></span>

<span class="keyword1" id="Lift_Monad-fmap_lifted_simps"><span class="command">lemma</span></span> fmap_lifted_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"fmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="main">⊥</span><span class="main">::</span><span class="tfree">'a</span><span class="main">⋅</span>lifted<span class="main">)</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"fmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span>Lifted<span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> Lifted<span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> fmap_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="keyword1" id="Lift_Monad-bind_lifted_simps"><span class="command">lemma</span></span> bind_lifted_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"bind<span class="main">⋅</span><span class="main">(</span><span class="main">⊥</span><span class="main">::</span><span class="tfree">'a</span><span class="main">⋅</span>lifted<span class="main">)</span><span class="main">⋅</span><span class="free">f</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"bind<span class="main">⋅</span><span class="main">(</span>Lifted<span class="main">⋅</span><span class="free">x</span><span class="main">)</span><span class="main">⋅</span><span class="free">f</span> <span class="main">=</span> <span class="free">f</span><span class="main">⋅</span><span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> bind_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="keyword1" id="Lift_Monad-return_lifted_def"><span class="command">lemma</span></span> return_lifted_def<span class="main">:</span> <span class="quoted"><span class="quoted">"return <span class="main">=</span> Lifted"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_def returnU_lifted_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> coerce_cfun cfcomp1 eta_cfun<span class="main">)</span>

<span class="keyword1" id="Lift_Monad-join_lifted_simps"><span class="command">lemma</span></span> join_lifted_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"join<span class="main">⋅</span><span class="main">(</span><span class="main">⊥</span><span class="main">::</span><span class="tfree">'a</span><span class="main">⋅</span>lifted<span class="main">⋅</span>lifted<span class="main">)</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"join<span class="main">⋅</span><span class="main">(</span>Lifted<span class="main">⋅</span><span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> join_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Resumption_Transformer">
<div class="head">
<h1>Theory Resumption_Transformer</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Resumption monad transformer›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Resumption_Transformer
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Monad_Plus.html">Monad_Plus</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Type definition›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The standard Haskell libraries do not include a resumption
monad transformer type; below is the Haskell definition for the one we
will use here.›</span></span>

<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹
\begin{verbatim}
data ResT m a = Done a | More (m (ResT m a))
\end{verbatim}
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The above datatype definition can be translated directly into
HOLCF using <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>tycondef›</span></span></span></span>. \medskip›</span></span>

<span class="keyword1"><span class="command">tycondef</span></span> <span class="tfree">'a</span><span class="main">⋅</span><span class="main">(</span><span class="tfree">'f</span><span class="main">::</span><span class="quoted"><span class="quoted"><span class="quoted">"functor"</span></span></span><span class="main">)</span> resT <span class="main">=</span>
  Done <span class="main">(</span><span class="keyword2"><span class="keyword">lazy</span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span>"</span></span><span class="main">)</span> <span class="main">|</span> More <span class="main">(</span><span class="keyword2"><span class="keyword">lazy</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'f</span> resT<span class="main">)</span><span class="main">⋅</span><span class="tfree">'f</span>"</span></span><span class="main">)</span>

<span class="keyword1" id="Resumption_Transformer-coerce_resT_abs"><span class="command">lemma</span></span> coerce_resT_abs <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"coerce<span class="main">⋅</span><span class="main">(</span>resT_abs<span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> resT_abs<span class="main">⋅</span><span class="main">(</span>coerce<span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> resT_abs_def coerce_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> emb_prj_emb prj_emb_prj DEFL_eq_resT<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Resumption_Transformer-coerce_Done"><span class="command">lemma</span></span> coerce_Done <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"coerce<span class="main">⋅</span><span class="main">(</span>Done<span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> Done<span class="main">⋅</span><span class="main">(</span>coerce<span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> Done_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Resumption_Transformer-coerce_More"><span class="command">lemma</span></span> coerce_More <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"coerce<span class="main">⋅</span><span class="main">(</span>More<span class="main">⋅</span><span class="free">m</span><span class="main">)</span> <span class="main">=</span> More<span class="main">⋅</span><span class="main">(</span>coerce<span class="main">⋅</span><span class="free">m</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> More_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Resumption_Transformer-resT_induct"><span class="command">lemma</span></span> resT_induct <span class="main">[</span><span class="operator">case_names</span> adm bottom Done More<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">P</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'f</span><span class="main">::</span>functor resT <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> adm<span class="main">:</span> <span class="quoted"><span class="quoted">"adm <span class="free">P</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> bottom<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> Done<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span>Done<span class="main">⋅</span><span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> More<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">m</span> <span class="bound">f</span><span class="main">.</span> <span class="main">(</span><span class="main">⋀</span><span class="main">(</span><span class="bound">r</span><span class="main">::</span><span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'f</span> resT<span class="main">)</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span><span class="bound">f</span><span class="main">⋅</span><span class="bound">r</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span>More<span class="main">⋅</span><span class="main">(</span>fmap<span class="main">⋅</span><span class="bound">f</span><span class="main">⋅</span><span class="bound">m</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">r</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">r</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> resT.take_induct <span class="main"><span class="main">[</span></span><span class="operator">OF</span> adm<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">n</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">(</span>resT_take <span class="skolem">n</span><span class="main">⋅</span><span class="free">r</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">r</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bottom<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">r</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> resT.exhaust<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bottom<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Done<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> More<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Class instance proofs›</span></span>

<span class="keyword1" id="Resumption_Transformer-fmapU_resT_simps"><span class="command">lemma</span></span> fmapU_resT_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"fmapU<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="main">⊥</span><span class="main">::</span>udom<span class="main">⋅</span><span class="tfree">'f</span><span class="main">::</span>functor resT<span class="main">)</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"fmapU<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span>Done<span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> Done<span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"fmapU<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span>More<span class="main">⋅</span><span class="free">m</span><span class="main">)</span> <span class="main">=</span> More<span class="main">⋅</span><span class="main">(</span>fmap<span class="main">⋅</span><span class="main">(</span>fmapU<span class="main">⋅</span><span class="free">f</span><span class="main">)</span><span class="main">⋅</span><span class="free">m</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> fmapU_resT_def resT_map_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> fix_eq<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> fix_eq<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Done_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> fix_eq<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> More_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">instance</span></span> resT <span class="main">::</span> <span class="main">(</span><span class="quoted"><span class="quoted">"functor"</span></span><span class="main">)</span> <span class="quoted"><span class="quoted">"functor"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">f</span> <span class="skolem">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom <span class="main">→</span> udom"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom<span class="main">⋅</span><span class="tfree">'a</span> resT"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"fmapU<span class="main">⋅</span><span class="skolem">f</span><span class="main">⋅</span><span class="main">(</span>fmapU<span class="main">⋅</span><span class="skolem">g</span><span class="main">⋅</span><span class="skolem">xs</span><span class="main">)</span> <span class="main">=</span> fmapU<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="skolem">f</span><span class="main">⋅</span><span class="main">(</span><span class="skolem">g</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">xs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> resT_induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmap_fmap<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> resT <span class="main">::</span> <span class="main">(</span><span class="quoted"><span class="quoted">"functor"</span></span><span class="main">)</span> <span class="quoted">monad</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity"><span class="class_parameter">bindU_resT</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom<span class="main">⋅</span><span class="tfree">'a</span> resT <span class="main">→</span> <span class="main">(</span>udom <span class="main">→</span> udom<span class="main">⋅</span><span class="tfree">'a</span> resT<span class="main">)</span> <span class="main">→</span> udom<span class="main">⋅</span><span class="tfree">'a</span> resT"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">bindU_resT</span><span class="main">⋅</span><span class="main">(</span>Done<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">bindU_resT</span><span class="main">⋅</span><span class="main">(</span>More<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> More<span class="main">⋅</span><span class="main">(</span>fmap<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> r<span class="main">.</span> <span class="free">bindU_resT</span><span class="main">⋅</span><span class="bound">r</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Resumption_Transformer-bindU_resT_strict"><span class="command">lemma</span></span> bindU_resT_strict <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"bindU<span class="main">⋅</span><span class="main">⊥</span><span class="main">⋅</span><span class="free">k</span> <span class="main">=</span> <span class="main">(</span><span class="main">⊥</span><span class="main">::</span>udom<span class="main">⋅</span><span class="tfree">'a</span> resT<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"returnU <span class="main">=</span> Done"</span></span>

<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom <span class="main">→</span> udom"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom<span class="main">⋅</span><span class="tfree">'a</span> resT"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"fmapU<span class="main">⋅</span><span class="skolem">f</span><span class="main">⋅</span><span class="skolem">xs</span> <span class="main">=</span> bindU<span class="main">⋅</span><span class="skolem">xs</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> returnU<span class="main">⋅</span><span class="main">(</span><span class="skolem">f</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> resT_induct<span class="main">)</span>
       <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmap_fmap returnU_resT_def<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom <span class="main">→</span> udom<span class="main">⋅</span><span class="tfree">'a</span> resT"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bindU<span class="main">⋅</span><span class="main">(</span>returnU<span class="main">⋅</span><span class="skolem">x</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">f</span> <span class="main">=</span> <span class="skolem">f</span><span class="main">⋅</span><span class="skolem">x</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> returnU_resT_def<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom<span class="main">⋅</span><span class="tfree">'a</span> resT"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">h</span> <span class="skolem">k</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom <span class="main">→</span> udom<span class="main">⋅</span><span class="tfree">'a</span> resT"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bindU<span class="main">⋅</span><span class="main">(</span>bindU<span class="main">⋅</span><span class="skolem">xs</span><span class="main">⋅</span><span class="skolem">h</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">k</span> <span class="main">=</span> bindU<span class="main">⋅</span><span class="skolem">xs</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> bindU<span class="main">⋅</span><span class="main">(</span><span class="skolem">h</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">k</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> resT_induct<span class="main">)</span>
       <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmap_fmap<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Transfer properties to polymorphic versions›</span></span>

<span class="keyword1" id="Resumption_Transformer-fmap_resT_simps"><span class="command">lemma</span></span> fmap_resT_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"fmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="main">⊥</span><span class="main">::</span><span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'f</span><span class="main">::</span>functor resT<span class="main">)</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"fmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span>Done<span class="main">⋅</span><span class="free">x</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'f</span><span class="main">::</span>functor resT<span class="main">)</span> <span class="main">=</span> Done<span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"fmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span>More<span class="main">⋅</span><span class="free">m</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'f</span><span class="main">::</span>functor resT<span class="main">)</span> <span class="main">=</span> More<span class="main">⋅</span><span class="main">(</span>fmap<span class="main">⋅</span><span class="main">(</span>fmap<span class="main">⋅</span><span class="free">f</span><span class="main">)</span><span class="main">⋅</span><span class="free">m</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> fmap_def <span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'f</span><span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="tfree">'f</span> resT"</span></span><span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">coerce_simp</span></span><span class="main">)</span>

<span class="keyword1" id="Resumption_Transformer-return_resT_def"><span class="command">lemma</span></span> return_resT_def<span class="main">:</span> <span class="quoted"><span class="quoted">"return <span class="main">=</span> Done"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_def returnU_resT_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">coerce_simp</span></span> eta_cfun<span class="main">)</span>

<span class="keyword1" id="Resumption_Transformer-bind_resT_simps"><span class="command">lemma</span></span> bind_resT_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"bind<span class="main">⋅</span><span class="main">(</span><span class="main">⊥</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'f</span><span class="main">::</span>functor resT<span class="main">)</span><span class="main">⋅</span><span class="free">f</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"bind<span class="main">⋅</span><span class="main">(</span>Done<span class="main">⋅</span><span class="free">x</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'f</span><span class="main">::</span>functor resT<span class="main">)</span><span class="main">⋅</span><span class="free">f</span> <span class="main">=</span> <span class="free">f</span><span class="main">⋅</span><span class="free">x</span>"</span></span>
  <span class="quoted"><span class="quoted">"bind<span class="main">⋅</span><span class="main">(</span>More<span class="main">⋅</span><span class="free">m</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'f</span><span class="main">::</span>functor resT<span class="main">)</span><span class="main">⋅</span><span class="free">f</span> <span class="main">=</span> More<span class="main">⋅</span><span class="main">(</span>fmap<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> r<span class="main">.</span> bind<span class="main">⋅</span><span class="bound">r</span><span class="main">⋅</span><span class="free">f</span><span class="main">)</span><span class="main">⋅</span><span class="free">m</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> bind_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">coerce_simp</span></span><span class="main">)</span>

<span class="keyword1" id="Resumption_Transformer-join_resT_simps"><span class="command">lemma</span></span> join_resT_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"join<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">(</span><span class="main">⊥</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'f</span><span class="main">::</span>functor resT<span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"join<span class="main">⋅</span><span class="main">(</span>Done<span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="quoted"><span class="quoted">"join<span class="main">⋅</span><span class="main">(</span>More<span class="main">⋅</span><span class="free">m</span><span class="main">)</span> <span class="main">=</span> More<span class="main">⋅</span><span class="main">(</span>fmap<span class="main">⋅</span>join<span class="main">⋅</span><span class="free">m</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> join_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Nondeterministic interleaving›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In this section we present a more general formalization of the
nondeterministic interleaving operation presented in Chapter 7 of the
author's PhD thesis \cite{holcf11}. If both arguments are <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Done›</span></span></span></span>, then <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>zipRT›</span></span></span></span> combines the results with the function
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f›</span></span></span></span> and terminates. While either argument is <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>More›</span></span></span></span>,
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>zipRT›</span></span></span></span> nondeterministically chooses one such argument, runs
it for one step, and then calls itself recursively.›</span></span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">zipRT</span> <span class="main">::</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'b</span> <span class="main">→</span> <span class="tfree">'c</span><span class="main">)</span> <span class="main">→</span> <span class="tfree">'a</span><span class="main">⋅</span><span class="main">(</span><span class="tfree">'m</span><span class="main">::</span>functor_plus<span class="main">)</span> resT <span class="main">→</span> <span class="tfree">'b</span><span class="main">⋅</span><span class="tfree">'m</span> resT <span class="main">→</span> <span class="tfree">'c</span><span class="main">⋅</span><span class="tfree">'m</span> resT"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> zipRT_Done_Done<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="free">zipRT</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="main">(</span>Done<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>Done<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">=</span> Done<span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span>"</span></span>
  <span class="main">|</span> zipRT_Done_More<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="free">zipRT</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="main">(</span>Done<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>More<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span> <span class="main">=</span>
      More<span class="main">⋅</span><span class="main">(</span>fmap<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> r<span class="main">.</span> <span class="free">zipRT</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="main">(</span>Done<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="bound">r</span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span>"</span></span>
  <span class="main">|</span> zipRT_More_Done<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="free">zipRT</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="main">(</span>More<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>Done<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span> <span class="main">=</span>
      More<span class="main">⋅</span><span class="main">(</span>fmap<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> r<span class="main">.</span> <span class="free">zipRT</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="bound">r</span><span class="main">⋅</span><span class="main">(</span>Done<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span>"</span></span>
  <span class="main">|</span> zipRT_More_More<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="free">zipRT</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="main">(</span>More<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>More<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span> <span class="main">=</span>
      More<span class="main">⋅</span><span class="main">(</span>fplus<span class="main">⋅</span><span class="main">(</span>fmap<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> r<span class="main">.</span> <span class="free">zipRT</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="main">(</span>More<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="bound">r</span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span>
                 <span class="main">⋅</span><span class="main">(</span>fmap<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> r<span class="main">.</span> <span class="free">zipRT</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="bound">r</span><span class="main">⋅</span><span class="main">(</span>More<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Resumption_Transformer-zipRT_strict1"><span class="command">lemma</span></span> zipRT_strict1 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"zipRT<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">⊥</span><span class="main">⋅</span><span class="free">r</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>

<span class="keyword1" id="Resumption_Transformer-zipRT_strict2"><span class="command">lemma</span></span> zipRT_strict2 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"zipRT<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">r</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fixrec_simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">r</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">apR</span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">⋄</span>"</span> 70<span class="main">)</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main"><span class="free">⋄</span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">≡</span> zipRT<span class="main">⋅</span>ID<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">b</span></span></span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Proofs that <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>zipRT›</span></span></span></span> satisfies the applicative functor laws:›</span></span>

<span class="keyword1" id="Resumption_Transformer-zipRT_homomorphism"><span class="command">lemma</span></span> zipRT_homomorphism<span class="main">:</span> <span class="quoted"><span class="quoted">"Done<span class="main">⋅</span><span class="free">f</span> <span class="main">⋄</span> Done<span class="main">⋅</span><span class="free">x</span> <span class="main">=</span> Done<span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Resumption_Transformer-zipRT_identity"><span class="command">lemma</span></span> zipRT_identity<span class="main">:</span> <span class="quoted"><span class="quoted">"Done<span class="main">⋅</span>ID <span class="main">⋄</span> <span class="free">r</span> <span class="main">=</span> <span class="free">r</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">r</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> resT_induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmap_fmap eta_cfun<span class="main">)</span>

<span class="keyword1" id="Resumption_Transformer-zipRT_interchange"><span class="command">lemma</span></span> zipRT_interchange<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">⋄</span> Done<span class="main">⋅</span><span class="free">x</span> <span class="main">=</span> Done<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> f<span class="main">.</span> <span class="bound">f</span><span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">⋄</span> <span class="free">r</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">r</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> resT_induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmap_fmap<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The associativity rule is the hard one!›</span></span>

<span class="keyword1" id="Resumption_Transformer-zipRT_associativity"><span class="command">lemma</span></span> zipRT_associativity<span class="main">:</span> <span class="quoted"><span class="quoted">"Done<span class="main">⋅</span>cfcomp <span class="main">⋄</span> <span class="free">r1</span> <span class="main">⋄</span> <span class="free">r2</span> <span class="main">⋄</span> <span class="free">r3</span> <span class="main">=</span> <span class="free">r1</span> <span class="main">⋄</span> <span class="main">(</span><span class="free">r2</span> <span class="main">⋄</span> <span class="free">r3</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">r1</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">r2</span></span> <span class="quoted"><span class="free">r3</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> resT_induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Done <span class="skolem">x1</span><span class="main">)</span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">r2</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">r3</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> resT_induct<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Done <span class="skolem">x2</span><span class="main">)</span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">r3</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> resT_induct<span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>More <span class="skolem">p3</span> <span class="skolem">c3</span><span class="main">)</span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="comment1">(* Done/Done/More *)</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmap_fmap<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>More <span class="skolem">p2</span> <span class="skolem">c2</span><span class="main">)</span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">r3</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> resT_induct<span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Done <span class="skolem">x3</span><span class="main">)</span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="comment1">(* Done/More/Done *)</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmap_fmap<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>More <span class="skolem">p3</span> <span class="skolem">c3</span><span class="main">)</span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="comment1">(* Done/More/More *)</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmap_fmap fmap_fplus<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>More <span class="skolem">p1</span> <span class="skolem">c1</span><span class="main">)</span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">r2</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">r3</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> resT_induct<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Done <span class="skolem">y</span><span class="main">)</span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">r3</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> resT_induct<span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Done <span class="skolem">x3</span><span class="main">)</span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmap_fmap<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>More <span class="skolem">p3</span> <span class="skolem">c3</span><span class="main">)</span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmap_fmap<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>More <span class="skolem">p2</span> <span class="skolem">c2</span><span class="main">)</span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">r3</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> resT_induct<span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Done <span class="skolem">x3</span><span class="main">)</span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmap_fmap fmap_fplus<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>More <span class="skolem">p3</span> <span class="skolem">c3</span><span class="main">)</span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmap_fmap fmap_fplus fplus_assoc<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="State_Transformer">
<div class="head">
<h1>Theory State_Transformer</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹State monad transformer›</span></span>

<span class="keyword1"><span class="command">theory</span></span> State_Transformer
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Monad_Zero_Plus.html">Monad_Zero_Plus</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  This version has non-lifted product, and a non-lifted function space.
›</span></span>

<span class="keyword1"><span class="command">tycondef</span></span> <span class="tfree">'a</span><span class="main">⋅</span><span class="main">(</span><span class="tfree">'f</span><span class="main">::</span><span class="quoted"><span class="quoted"><span class="quoted">"functor"</span></span></span><span class="main">,</span> <span class="tfree">'s</span><span class="main">)</span> stateT <span class="main">=</span>
  StateT <span class="main">(</span>runStateT <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s</span> <span class="main">→</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'s</span><span class="main">)</span><span class="main">⋅</span><span class="tfree">'f</span>"</span></span><span class="main">)</span>

<span class="keyword1" id="State_Transformer-coerce_stateT_abs"><span class="command">lemma</span></span> coerce_stateT_abs <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"coerce<span class="main">⋅</span><span class="main">(</span>stateT_abs<span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> stateT_abs<span class="main">⋅</span><span class="main">(</span>coerce<span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> stateT_abs_def coerce_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> emb_prj_emb prj_emb_prj DEFL_eq_stateT<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="State_Transformer-coerce_StateT"><span class="command">lemma</span></span> coerce_StateT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"coerce<span class="main">⋅</span><span class="main">(</span>StateT<span class="main">⋅</span><span class="free">k</span><span class="main">)</span> <span class="main">=</span> StateT<span class="main">⋅</span><span class="main">(</span>coerce<span class="main">⋅</span><span class="free">k</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> StateT_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="State_Transformer-stateT_cases"><span class="command">lemma</span></span> stateT_cases <span class="main">[</span><span class="operator">case_names</span> StateT<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">k</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">=</span> StateT<span class="main">⋅</span><span class="free">k</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">=</span> StateT<span class="main">⋅</span><span class="main">(</span>runStateT<span class="main">⋅</span><span class="free">y</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">y</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="State_Transformer-stateT_induct"><span class="command">lemma</span></span> stateT_induct <span class="main">[</span><span class="operator">case_names</span> StateT<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">P</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">⋅</span><span class="main">(</span><span class="tfree">'f</span><span class="main">::</span>functor<span class="main">,</span><span class="tfree">'s</span><span class="main">)</span> stateT <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">k</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span>StateT<span class="main">⋅</span><span class="bound">k</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">y</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> stateT_cases<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main">)</span>

<span class="keyword1" id="State_Transformer-stateT_eqI"><span class="command">lemma</span></span> stateT_eqI<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> runStateT<span class="main">⋅</span><span class="free">a</span><span class="main">⋅</span><span class="bound">s</span> <span class="main">=</span> runStateT<span class="main">⋅</span><span class="free">b</span><span class="main">⋅</span><span class="bound">s</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">a</span> <span class="main">=</span> <span class="free">b</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">a</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> stateT_cases<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">b</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> stateT_cases<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cfun_eq_iff<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="State_Transformer-runStateT_coerce"><span class="command">lemma</span></span> runStateT_coerce <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"runStateT<span class="main">⋅</span><span class="main">(</span>coerce<span class="main">⋅</span><span class="free">k</span><span class="main">)</span><span class="main">⋅</span><span class="free">s</span> <span class="main">=</span> coerce<span class="main">⋅</span><span class="main">(</span>runStateT<span class="main">⋅</span><span class="free">k</span><span class="main">⋅</span><span class="free">s</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">k</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> stateT_induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Functor class instance›</span></span>

<span class="keyword1" id="State_Transformer-fmapU_StateT"><span class="command">lemma</span></span> fmapU_StateT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"fmapU<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span>StateT<span class="main">⋅</span><span class="free">k</span><span class="main">)</span> <span class="main">=</span>
    StateT<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> s<span class="main">.</span> fmap<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span><span class="main">(</span>x<span class="main">,</span> s'<span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="bound">x</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free">k</span><span class="main">⋅</span><span class="bound">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> fmapU_stateT_def stateT_map_def StateT_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> fix_eq<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cfun_map_def csplit_def prod_map_def<span class="main">)</span>

<span class="keyword1" id="State_Transformer-runStateT_fmapU"><span class="command">lemma</span></span> runStateT_fmapU <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"runStateT<span class="main">⋅</span><span class="main">(</span>fmapU<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">m</span><span class="main">)</span><span class="main">⋅</span><span class="free">s</span> <span class="main">=</span>
    fmap<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span><span class="main">(</span>x<span class="main">,</span> s'<span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="bound">x</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>runStateT<span class="main">⋅</span><span class="free">m</span><span class="main">⋅</span><span class="free">s</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">m</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> stateT_cases<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">instantiation</span></span> stateT <span class="main">::</span> <span class="main">(</span><span class="quoted"><span class="quoted">"functor"</span></span><span class="main">,</span> <span class="quoted"><span class="quoted">"domain"</span></span><span class="main">)</span> <span class="quoted"><span class="quoted">"functor"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">instance</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">standard</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="improper"><span class="quoted"><span class="improper">xs</span></span></span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> stateT_induct<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmap_fmap ID_def csplit_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Monad class instance›</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> stateT <span class="main">::</span> <span class="main">(</span><span class="quoted">monad</span><span class="main">,</span> <span class="quoted"><span class="quoted">"domain"</span></span><span class="main">)</span> <span class="quoted">monad</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> returnU_stateT_def<span class="main">:</span>
  <span class="quoted"><span class="quoted">"returnU <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> StateT<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> s<span class="main">.</span> return<span class="main">⋅</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> bindU_stateT_def<span class="main">:</span>
  <span class="quoted"><span class="quoted">"bindU <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> m k<span class="main">.</span> StateT<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> s<span class="main">.</span> runStateT<span class="main">⋅</span><span class="bound">m</span><span class="main">⋅</span><span class="bound">s</span> <span class="main">⤜</span> <span class="main">(</span><span class="keyword1">Λ</span> <span class="main">(</span>x<span class="main">,</span> s'<span class="main">)</span><span class="main">.</span> runStateT<span class="main">⋅</span><span class="main">(</span><span class="bound">k</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">⋅</span><span class="bound">s'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="State_Transformer-bindU_stateT_StateT"><span class="command">lemma</span></span> bindU_stateT_StateT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"bindU<span class="main">⋅</span><span class="main">(</span>StateT<span class="main">⋅</span><span class="free">f</span><span class="main">)</span><span class="main">⋅</span><span class="free">k</span> <span class="main">=</span>
    StateT<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> s<span class="main">.</span> <span class="free">f</span><span class="main">⋅</span><span class="bound">s</span> <span class="main">⤜</span> <span class="main">(</span><span class="keyword1">Λ</span> <span class="main">(</span>x<span class="main">,</span> s'<span class="main">)</span><span class="main">.</span> runStateT<span class="main">⋅</span><span class="main">(</span><span class="free">k</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">⋅</span><span class="bound">s'</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> bindU_stateT_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="State_Transformer-runStateT_bindU"><span class="command">lemma</span></span> runStateT_bindU <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"runStateT<span class="main">⋅</span><span class="main">(</span>bindU<span class="main">⋅</span><span class="free">m</span><span class="main">⋅</span><span class="free">k</span><span class="main">)</span><span class="main">⋅</span><span class="free">s</span> <span class="main">=</span> runStateT<span class="main">⋅</span><span class="free">m</span><span class="main">⋅</span><span class="free">s</span> <span class="main">⤜</span> <span class="main">(</span><span class="keyword1">Λ</span> <span class="main">(</span>x<span class="main">,</span> s'<span class="main">)</span><span class="main">.</span> runStateT<span class="main">⋅</span><span class="main">(</span><span class="free">k</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">⋅</span><span class="bound">s'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> bindU_stateT_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom <span class="main">→</span> udom"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">r</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom<span class="main">⋅</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span> stateT"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"fmapU<span class="main">⋅</span><span class="skolem">f</span><span class="main">⋅</span><span class="skolem">r</span> <span class="main">=</span> bindU<span class="main">⋅</span><span class="skolem">r</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> returnU<span class="main">⋅</span><span class="main">(</span><span class="skolem">f</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> stateT_eqI<span class="main">)</span>
       <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> returnU_stateT_def monad_fmap prod_map_def csplit_def<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom <span class="main">→</span> udom<span class="main">⋅</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span> stateT"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bindU<span class="main">⋅</span><span class="main">(</span>returnU<span class="main">⋅</span><span class="skolem">x</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">f</span> <span class="main">=</span> <span class="skolem">f</span><span class="main">⋅</span><span class="skolem">x</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> stateT_eqI<span class="main">)</span>
       <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> returnU_stateT_def eta_cfun<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">r</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom<span class="main">⋅</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span> stateT"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="skolem">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom <span class="main">→</span> udom<span class="main">⋅</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span> stateT"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bindU<span class="main">⋅</span><span class="main">(</span>bindU<span class="main">⋅</span><span class="skolem">r</span><span class="main">⋅</span><span class="skolem">f</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">g</span> <span class="main">=</span> bindU<span class="main">⋅</span><span class="skolem">r</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> bindU<span class="main">⋅</span><span class="main">(</span><span class="skolem">f</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">g</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> stateT_eqI<span class="main">)</span>
       <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_bind csplit_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Monad zero instance›</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> stateT <span class="main">::</span> <span class="main">(</span><span class="quoted">monad_zero</span><span class="main">,</span> <span class="quoted"><span class="quoted">"domain"</span></span><span class="main">)</span> <span class="quoted">monad_zero</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> zeroU_stateT_def<span class="main">:</span>
  <span class="quoted"><span class="quoted">"zeroU <span class="main">=</span> StateT<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> s<span class="main">.</span> mzero<span class="main">)</span>"</span></span>

<span class="keyword1" id="State_Transformer-runStateT_zeroU"><span class="command">lemma</span></span> runStateT_zeroU <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"runStateT<span class="main">⋅</span>zeroU<span class="main">⋅</span><span class="free">s</span> <span class="main">=</span> mzero"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> zeroU_stateT_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">k</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom <span class="main">→</span> udom<span class="main">⋅</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span> stateT"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bindU<span class="main">⋅</span>zeroU<span class="main">⋅</span><span class="skolem">k</span> <span class="main">=</span> zeroU"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> stateT_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_mzero<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Monad plus instance›</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> stateT <span class="main">::</span> <span class="main">(</span><span class="quoted">monad_plus</span><span class="main">,</span> <span class="quoted"><span class="quoted">"domain"</span></span><span class="main">)</span> <span class="quoted">monad_plus</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> plusU_stateT_def<span class="main">:</span>
  <span class="quoted"><span class="quoted">"plusU <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> a b<span class="main">.</span> StateT<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> s<span class="main">.</span> mplus<span class="main">⋅</span><span class="main">(</span>runStateT<span class="main">⋅</span><span class="bound">a</span><span class="main">⋅</span><span class="bound">s</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>runStateT<span class="main">⋅</span><span class="bound">b</span><span class="main">⋅</span><span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="State_Transformer-runStateT_plusU"><span class="command">lemma</span></span> runStateT_plusU <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"runStateT<span class="main">⋅</span><span class="main">(</span>plusU<span class="main">⋅</span><span class="free">a</span><span class="main">⋅</span><span class="free">b</span><span class="main">)</span><span class="main">⋅</span><span class="free">s</span> <span class="main">=</span>
    mplus<span class="main">⋅</span><span class="main">(</span>runStateT<span class="main">⋅</span><span class="free">a</span><span class="main">⋅</span><span class="free">s</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>runStateT<span class="main">⋅</span><span class="free">b</span><span class="main">⋅</span><span class="free">s</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> plusU_stateT_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom<span class="main">⋅</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> stateT"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">k</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom <span class="main">→</span> udom<span class="main">⋅</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> stateT"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bindU<span class="main">⋅</span><span class="main">(</span>plusU<span class="main">⋅</span><span class="skolem">a</span><span class="main">⋅</span><span class="skolem">b</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">k</span> <span class="main">=</span> plusU<span class="main">⋅</span><span class="main">(</span>bindU<span class="main">⋅</span><span class="skolem">a</span><span class="main">⋅</span><span class="skolem">k</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>bindU<span class="main">⋅</span><span class="skolem">b</span><span class="main">⋅</span><span class="skolem">k</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> stateT_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_mplus<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="skolem">c</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom<span class="main">⋅</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> stateT"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"plusU<span class="main">⋅</span><span class="main">(</span>plusU<span class="main">⋅</span><span class="skolem">a</span><span class="main">⋅</span><span class="skolem">b</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">c</span> <span class="main">=</span> plusU<span class="main">⋅</span><span class="skolem">a</span><span class="main">⋅</span><span class="main">(</span>plusU<span class="main">⋅</span><span class="skolem">b</span><span class="main">⋅</span><span class="skolem">c</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> stateT_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mplus_assoc<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Monad zero plus instance›</span></span>

<span class="keyword1"><span class="command">instance</span></span> stateT <span class="main">::</span> <span class="main">(</span><span class="quoted">monad_zero_plus</span><span class="main">,</span> <span class="quoted"><span class="quoted">"domain"</span></span><span class="main">)</span> <span class="quoted">monad_zero_plus</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">m</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom<span class="main">⋅</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> stateT"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"plusU<span class="main">⋅</span>zeroU<span class="main">⋅</span><span class="skolem">m</span> <span class="main">=</span> <span class="skolem">m</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> stateT_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mplus_mzero_left<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">m</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom<span class="main">⋅</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> stateT"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"plusU<span class="main">⋅</span><span class="skolem">m</span><span class="main">⋅</span>zeroU <span class="main">=</span> <span class="skolem">m</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> stateT_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mplus_mzero_right<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Transfer properties to polymorphic versions›</span></span>

<span class="keyword1" id="State_Transformer-coerce_csplit"><span class="command">lemma</span></span> coerce_csplit <span class="main">[</span><span class="operator">coerce_simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"coerce<span class="main">⋅</span><span class="main">(</span>csplit<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">p</span><span class="main">)</span> <span class="main">=</span> csplit<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x y<span class="main">.</span> coerce<span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="bound">x</span><span class="main">⋅</span><span class="bound">y</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> csplit_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="State_Transformer-csplit_coerce"><span class="command">lemma</span></span> csplit_coerce <span class="main">[</span><span class="operator">coerce_simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">p</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"csplit<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">COERCE</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">,</span> <span class="tfree">'c</span> <span class="main">×</span> <span class="tfree">'d</span><span class="main">)</span><span class="main">⋅</span><span class="free">p</span><span class="main">)</span> <span class="main">=</span>
    csplit<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x y<span class="main">.</span> <span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">COERCE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'c</span><span class="main">)</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">COERCE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">,</span> <span class="tfree">'d</span><span class="main">)</span><span class="main">⋅</span><span class="bound">y</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> coerce_prod csplit_def prod_map_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="State_Transformer-fmap_stateT_simps"><span class="command">lemma</span></span> fmap_stateT_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"fmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span>StateT<span class="main">⋅</span><span class="free">m</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">⋅</span><span class="main">(</span><span class="tfree">'f</span><span class="main">::</span>functor<span class="main">,</span><span class="tfree">'s</span><span class="main">)</span> stateT<span class="main">)</span> <span class="main">=</span>
    StateT<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> s<span class="main">.</span> fmap<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> <span class="main">(</span>x<span class="main">,</span> s'<span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="bound">x</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free">m</span><span class="main">⋅</span><span class="bound">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> fmap_def <span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'f</span><span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'f</span><span class="main">,</span> <span class="tfree">'s</span><span class="main">)</span> stateT"</span></span><span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">coerce_simp</span></span> eta_cfun<span class="main">)</span>

<span class="keyword1" id="State_Transformer-runStateT_fmap"><span class="command">lemma</span></span> runStateT_fmap <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"runStateT<span class="main">⋅</span><span class="main">(</span>fmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">m</span><span class="main">)</span><span class="main">⋅</span><span class="free">s</span> <span class="main">=</span> fmap<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> <span class="main">(</span>x<span class="main">,</span> s'<span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="bound">x</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>runStateT<span class="main">⋅</span><span class="free">m</span><span class="main">⋅</span><span class="free">s</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">m</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> stateT_induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="State_Transformer-return_stateT_def"><span class="command">lemma</span></span> return_stateT_def<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>return <span class="main">::</span> <span class="main">_</span> <span class="main">→</span> <span class="tfree">'a</span><span class="main">⋅</span><span class="main">(</span><span class="tfree">'m</span><span class="main">::</span>monad<span class="main">,</span> <span class="tfree">'s</span><span class="main">)</span> stateT<span class="main">)</span> <span class="main">=</span>
    <span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> StateT<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> s<span class="main">.</span> return<span class="main">⋅</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_def <span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'m</span><span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'m</span><span class="main">,</span> <span class="tfree">'s</span><span class="main">)</span> stateT"</span></span><span class="main">]</span> returnU_stateT_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">coerce_simp</span></span><span class="main">)</span>

<span class="keyword1" id="State_Transformer-bind_stateT_def"><span class="command">lemma</span></span> bind_stateT_def<span class="main">:</span>
  <span class="quoted"><span class="quoted">"bind <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> m k<span class="main">.</span> StateT<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> s<span class="main">.</span> runStateT<span class="main">⋅</span><span class="bound">m</span><span class="main">⋅</span><span class="bound">s</span> <span class="main">⤜</span> <span class="main">(</span><span class="keyword1">Λ</span> <span class="main">(</span>x<span class="main">,</span> s'<span class="main">)</span><span class="main">.</span> runStateT<span class="main">⋅</span><span class="main">(</span><span class="bound">k</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">⋅</span><span class="bound">s'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> bind_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">subst</span> bindU_stateT_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">coerce_simp</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> coerce_idem <span class="dynamic"><span class="dynamic">domain_defl_simps</span></span> monofun_cfun<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eta_cfun<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">"TODO: add <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>coerce_idem›</span></span></span></span> to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>coerce_simps›</span></span></span></span>, along\010with monotonicity rules for DEFL."</span></span>

<span class="keyword1" id="State_Transformer-bind_stateT_simps"><span class="command">lemma</span></span> bind_stateT_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"bind<span class="main">⋅</span><span class="main">(</span>StateT<span class="main">⋅</span><span class="free">m</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">⋅</span><span class="main">(</span><span class="tfree">'m</span><span class="main">::</span>monad<span class="main">,</span><span class="tfree">'s</span><span class="main">)</span> stateT<span class="main">)</span><span class="main">⋅</span><span class="free">k</span> <span class="main">=</span>
    StateT<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> s<span class="main">.</span> <span class="free">m</span><span class="main">⋅</span><span class="bound">s</span> <span class="main">⤜</span> <span class="main">(</span><span class="keyword1">Λ</span> <span class="main">(</span>x<span class="main">,</span> s'<span class="main">)</span><span class="main">.</span> runStateT<span class="main">⋅</span><span class="main">(</span><span class="free">k</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">⋅</span><span class="bound">s'</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> bind_stateT_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="State_Transformer-runStateT_bind"><span class="command">lemma</span></span> runStateT_bind <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"runStateT<span class="main">⋅</span><span class="main">(</span><span class="free">m</span> <span class="main">⤜</span> <span class="free">k</span><span class="main">)</span><span class="main">⋅</span><span class="free">s</span> <span class="main">=</span> runStateT<span class="main">⋅</span><span class="free">m</span><span class="main">⋅</span><span class="free">s</span> <span class="main">⤜</span> <span class="main">(</span><span class="keyword1">Λ</span> <span class="main">(</span>x<span class="main">,</span> s'<span class="main">)</span><span class="main">.</span> runStateT<span class="main">⋅</span><span class="main">(</span><span class="free">k</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">⋅</span><span class="bound">s'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> bind_stateT_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Error_Transformer">
<div class="head">
<h1>Theory Error_Transformer</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Error monad transformer›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Error_Transformer
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Error_Monad.html">Error_Monad</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Type definition›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The error monad transformer is defined in Haskell by composing
the given monad with a standard error monad:›</span></span>

<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹
\begin{verbatim}
data Error e a = Err e | Ok a
newtype ErrorT e m a = ErrorT { runErrorT :: m (Error e a) }
\end{verbatim}
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We can formalize this definition directly using <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>tycondef›</span></span></span></span>. \medskip›</span></span>

<span class="keyword1"><span class="command">tycondef</span></span> <span class="tfree">'a</span><span class="main">⋅</span><span class="main">(</span><span class="tfree">'f</span><span class="main">::</span><span class="quoted"><span class="quoted"><span class="quoted">"functor"</span></span></span><span class="main">,</span><span class="tfree">'e</span><span class="main">::</span><span class="quoted"><span class="quoted"><span class="quoted">"domain"</span></span></span><span class="main">)</span> errorT <span class="main">=</span>
  ErrorT <span class="main">(</span>runErrorT <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'e</span> error<span class="main">)</span><span class="main">⋅</span><span class="tfree">'f</span>"</span></span><span class="main">)</span>

<span class="keyword1" id="Error_Transformer-coerce_errorT_abs"><span class="command">lemma</span></span> coerce_errorT_abs <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"coerce<span class="main">⋅</span><span class="main">(</span>errorT_abs<span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> errorT_abs<span class="main">⋅</span><span class="main">(</span>coerce<span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> errorT_abs_def coerce_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> emb_prj_emb prj_emb_prj DEFL_eq_errorT<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Error_Transformer-coerce_ErrorT"><span class="command">lemma</span></span> coerce_ErrorT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"coerce<span class="main">⋅</span><span class="main">(</span>ErrorT<span class="main">⋅</span><span class="free">k</span><span class="main">)</span> <span class="main">=</span> ErrorT<span class="main">⋅</span><span class="main">(</span>coerce<span class="main">⋅</span><span class="free">k</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> ErrorT_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Error_Transformer-errorT_cases"><span class="command">lemma</span></span> errorT_cases <span class="main">[</span><span class="operator">case_names</span> ErrorT<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">k</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">=</span> ErrorT<span class="main">⋅</span><span class="free">k</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">=</span> ErrorT<span class="main">⋅</span><span class="main">(</span>runErrorT<span class="main">⋅</span><span class="free">y</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">y</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Error_Transformer-ErrorT_runErrorT"><span class="command">lemma</span></span> ErrorT_runErrorT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ErrorT<span class="main">⋅</span><span class="main">(</span>runErrorT<span class="main">⋅</span><span class="free">m</span><span class="main">)</span> <span class="main">=</span> <span class="free">m</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">m</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> errorT_cases<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="Error_Transformer-errorT_induct"><span class="command">lemma</span></span> errorT_induct <span class="main">[</span><span class="operator">case_names</span> ErrorT<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">P</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">⋅</span><span class="main">(</span><span class="tfree">'f</span><span class="main">::</span>functor<span class="main">,</span><span class="tfree">'e</span><span class="main">)</span> errorT <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">k</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span>ErrorT<span class="main">⋅</span><span class="bound">k</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">y</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> errorT_cases<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main">)</span>

<span class="keyword1" id="Error_Transformer-errorT_eq_iff"><span class="command">lemma</span></span> errorT_eq_iff<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">=</span> <span class="free">b</span> <span class="main">⟷</span> runErrorT<span class="main">⋅</span><span class="free">a</span> <span class="main">=</span> runErrorT<span class="main">⋅</span><span class="free">b</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">a</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> errorT_cases<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">b</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> errorT_cases<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Error_Transformer-errorT_eqI"><span class="command">lemma</span></span> errorT_eqI<span class="main">:</span>
  <span class="quoted"><span class="quoted">"runErrorT<span class="main">⋅</span><span class="free">a</span> <span class="main">=</span> runErrorT<span class="main">⋅</span><span class="free">b</span> <span class="main">⟹</span> <span class="free">a</span> <span class="main">=</span> <span class="free">b</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> errorT_eq_iff<span class="main">)</span>

<span class="keyword1" id="Error_Transformer-runErrorT_coerce"><span class="command">lemma</span></span> runErrorT_coerce <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"runErrorT<span class="main">⋅</span><span class="main">(</span>coerce<span class="main">⋅</span><span class="free">k</span><span class="main">)</span> <span class="main">=</span> coerce<span class="main">⋅</span><span class="main">(</span>runErrorT<span class="main">⋅</span><span class="free">k</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">k</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> errorT_induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Functor class instance›</span></span>

<span class="keyword1" id="Error_Transformer-fmap_error_def"><span class="command">lemma</span></span> fmap_error_def<span class="main">:</span> <span class="quoted"><span class="quoted">"fmap <span class="main">=</span> error_map<span class="main">⋅</span>ID"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">rename_tac</span> f<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">rename_tac</span> x<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> error.exhaust<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> error_map_def fix_const<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> error_map_def fix_const Err_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> error_map_def fix_const Ok_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Error_Transformer-fmapU_ErrorT"><span class="command">lemma</span></span> fmapU_ErrorT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"fmapU<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span>ErrorT<span class="main">⋅</span><span class="free">m</span><span class="main">)</span> <span class="main">=</span> ErrorT<span class="main">⋅</span><span class="main">(</span>fmap<span class="main">⋅</span><span class="main">(</span>fmap<span class="main">⋅</span><span class="free">f</span><span class="main">)</span><span class="main">⋅</span><span class="free">m</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> fmapU_errorT_def errorT_map_def fmap_error_def fix_const ErrorT_def
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Error_Transformer-runErrorT_fmapU"><span class="command">lemma</span></span> runErrorT_fmapU <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"runErrorT<span class="main">⋅</span><span class="main">(</span>fmapU<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">m</span><span class="main">)</span> <span class="main">=</span> fmap<span class="main">⋅</span><span class="main">(</span>fmap<span class="main">⋅</span><span class="free">f</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>runErrorT<span class="main">⋅</span><span class="free">m</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">m</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> errorT_induct<span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">instance</span></span> errorT <span class="main">::</span> <span class="main">(</span><span class="quoted"><span class="quoted">"functor"</span></span><span class="main">,</span> <span class="quoted"><span class="quoted">"domain"</span></span><span class="main">)</span> <span class="quoted"><span class="quoted">"functor"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">f</span> <span class="skolem">g</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom<span class="main">⋅</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> errorT"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"fmapU<span class="main">⋅</span><span class="skolem">f</span><span class="main">⋅</span><span class="main">(</span>fmapU<span class="main">⋅</span><span class="skolem">g</span><span class="main">⋅</span><span class="skolem">xs</span><span class="main">)</span> <span class="main">=</span> fmapU<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="skolem">f</span><span class="main">⋅</span><span class="main">(</span><span class="skolem">g</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">xs</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> errorT_induct<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmap_fmap eta_cfun<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Transfer properties to polymorphic versions›</span></span>

<span class="keyword1" id="Error_Transformer-fmap_ErrorT"><span class="command">lemma</span></span> fmap_ErrorT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'b</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">m</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'e</span> error<span class="main">⋅</span><span class="main">(</span><span class="tfree">'m</span><span class="main">::</span>functor<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span>ErrorT<span class="main">⋅</span><span class="free">m</span><span class="main">)</span> <span class="main">=</span> ErrorT<span class="main">⋅</span><span class="main">(</span>fmap<span class="main">⋅</span><span class="main">(</span>fmap<span class="main">⋅</span><span class="free">f</span><span class="main">)</span><span class="main">⋅</span><span class="free">m</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> fmap_def <span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'f</span><span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'m</span><span class="main">,</span><span class="tfree">'e</span><span class="main">)</span> errorT"</span></span><span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">coerce_simp</span></span> eta_cfun<span class="main">)</span>

<span class="keyword1" id="Error_Transformer-runErrorT_fmap"><span class="command">lemma</span></span> runErrorT_fmap <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'b</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">m</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">⋅</span><span class="main">(</span><span class="tfree">'m</span><span class="main">::</span>functor<span class="main">,</span><span class="tfree">'e</span><span class="main">)</span> errorT"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"runErrorT<span class="main">⋅</span><span class="main">(</span>fmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">m</span><span class="main">)</span> <span class="main">=</span> fmap<span class="main">⋅</span><span class="main">(</span>fmap<span class="main">⋅</span><span class="free">f</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>runErrorT<span class="main">⋅</span><span class="free">m</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> fmap_ErrorT <span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">f</span></span> <span class="quoted"><span class="quoted">"runErrorT<span class="main">⋅</span><span class="free">m</span>"</span></span><span class="main">]</span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Error_Transformer-errorT_fmap_strict"><span class="command">lemma</span></span> errorT_fmap_strict <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="main">⊥</span><span class="main">::</span><span class="tfree">'a</span><span class="main">⋅</span><span class="main">(</span><span class="tfree">'m</span><span class="main">::</span>monad<span class="main">,</span><span class="tfree">'e</span><span class="main">)</span> errorT<span class="main">)</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> errorT_eq_iff fmap_strict<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Monad operations›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The error monad transformer does not yield a monad in the
usual sense: We cannot prove a <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>monad›</span></span></span></span> class instance, because
type <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>'a⋅('m,'e) errorT›</span></span></span></span> contains values that break the monad
laws. However, it turns out that such values are inaccessible: The
monad laws are satisfied by all values constructible from the abstract
operations.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹To explore the properties of the error monad transformer
operations, we define them all as non-overloaded functions. \medskip
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">unitET</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'a</span><span class="main">⋅</span><span class="main">(</span><span class="tfree">'m</span><span class="main">::</span>monad<span class="main">,</span><span class="tfree">'e</span><span class="main">)</span> errorT"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">unitET</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> ErrorT<span class="main">⋅</span><span class="main">(</span>return<span class="main">⋅</span><span class="main">(</span>Ok<span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">bindET</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">⋅</span><span class="main">(</span><span class="tfree">'m</span><span class="main">::</span>monad<span class="main">,</span><span class="tfree">'e</span><span class="main">)</span> errorT <span class="main">→</span>
    <span class="main">(</span><span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'b</span><span class="main">⋅</span><span class="main">(</span><span class="tfree">'m</span><span class="main">,</span><span class="tfree">'e</span><span class="main">)</span> errorT<span class="main">)</span> <span class="main">→</span> <span class="tfree">'b</span><span class="main">⋅</span><span class="main">(</span><span class="tfree">'m</span><span class="main">,</span><span class="tfree">'e</span><span class="main">)</span> errorT"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">bindET</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> m k<span class="main">.</span> ErrorT<span class="main">⋅</span><span class="main">(</span>bind<span class="main">⋅</span><span class="main">(</span>runErrorT<span class="main">⋅</span><span class="bound">m</span><span class="main">)</span><span class="main">⋅</span>
    <span class="main">(</span><span class="keyword1">Λ</span> n<span class="main">.</span> <span class="keyword1">case</span> <span class="bound">n</span> <span class="keyword1">of</span> Err<span class="main">⋅</span><span class="bound">e</span> <span class="main">⇒</span> return<span class="main">⋅</span><span class="main">(</span>Err<span class="main">⋅</span><span class="bound">e</span><span class="main">)</span> <span class="main">|</span> Ok<span class="main">⋅</span><span class="bound">x</span> <span class="main">⇒</span> runErrorT<span class="main">⋅</span><span class="main">(</span><span class="bound">k</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">liftET</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'m</span><span class="main">::</span>monad <span class="main">→</span> <span class="tfree">'a</span><span class="main">⋅</span><span class="main">(</span><span class="tfree">'m</span><span class="main">,</span><span class="tfree">'e</span><span class="main">)</span> errorT"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">liftET</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> m<span class="main">.</span> ErrorT<span class="main">⋅</span><span class="main">(</span>fmap<span class="main">⋅</span>Ok<span class="main">⋅</span><span class="bound">m</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">throwET</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'e</span> <span class="main">→</span> <span class="tfree">'a</span><span class="main">⋅</span><span class="main">(</span><span class="tfree">'m</span><span class="main">::</span>monad<span class="main">,</span><span class="tfree">'e</span><span class="main">)</span> errorT"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">throwET</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> e<span class="main">.</span> ErrorT<span class="main">⋅</span><span class="main">(</span>return<span class="main">⋅</span><span class="main">(</span>Err<span class="main">⋅</span><span class="bound">e</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">catchET</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">⋅</span><span class="main">(</span><span class="tfree">'m</span><span class="main">::</span>monad<span class="main">,</span><span class="tfree">'e</span><span class="main">)</span> errorT <span class="main">→</span>
    <span class="main">(</span><span class="tfree">'e</span> <span class="main">→</span> <span class="tfree">'a</span><span class="main">⋅</span><span class="main">(</span><span class="tfree">'m</span><span class="main">,</span><span class="tfree">'e</span><span class="main">)</span> errorT<span class="main">)</span> <span class="main">→</span> <span class="tfree">'a</span><span class="main">⋅</span><span class="main">(</span><span class="tfree">'m</span><span class="main">,</span><span class="tfree">'e</span><span class="main">)</span> errorT"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">catchET</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> m h<span class="main">.</span> ErrorT<span class="main">⋅</span><span class="main">(</span>bind<span class="main">⋅</span><span class="main">(</span>runErrorT<span class="main">⋅</span><span class="bound">m</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> n<span class="main">.</span> <span class="keyword1">case</span> <span class="bound">n</span> <span class="keyword1">of</span>
    Err<span class="main">⋅</span><span class="bound">e</span> <span class="main">⇒</span> runErrorT<span class="main">⋅</span><span class="main">(</span><span class="bound">h</span><span class="main">⋅</span><span class="bound">e</span><span class="main">)</span> <span class="main">|</span> Ok<span class="main">⋅</span><span class="bound">x</span> <span class="main">⇒</span> return<span class="main">⋅</span><span class="main">(</span>Ok<span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">fmapET</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">→</span>
    <span class="tfree">'a</span><span class="main">⋅</span><span class="main">(</span><span class="tfree">'m</span><span class="main">::</span>monad<span class="main">,</span><span class="tfree">'e</span><span class="main">)</span> errorT <span class="main">→</span> <span class="tfree">'b</span><span class="main">⋅</span><span class="main">(</span><span class="tfree">'m</span><span class="main">,</span><span class="tfree">'e</span><span class="main">)</span> errorT"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">fmapET</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> f m<span class="main">.</span> bindET<span class="main">⋅</span><span class="bound">m</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> unitET<span class="main">⋅</span><span class="main">(</span><span class="bound">f</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Error_Transformer-runErrorT_unitET"><span class="command">lemma</span></span> runErrorT_unitET <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"runErrorT<span class="main">⋅</span><span class="main">(</span>unitET<span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> return<span class="main">⋅</span><span class="main">(</span>Ok<span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> unitET_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Error_Transformer-runErrorT_bindET"><span class="command">lemma</span></span> runErrorT_bindET <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"runErrorT<span class="main">⋅</span><span class="main">(</span>bindET<span class="main">⋅</span><span class="free">m</span><span class="main">⋅</span><span class="free">k</span><span class="main">)</span> <span class="main">=</span> bind<span class="main">⋅</span><span class="main">(</span>runErrorT<span class="main">⋅</span><span class="free">m</span><span class="main">)</span><span class="main">⋅</span>
    <span class="main">(</span><span class="keyword1">Λ</span> n<span class="main">.</span> <span class="keyword1">case</span> <span class="bound">n</span> <span class="keyword1">of</span> Err<span class="main">⋅</span><span class="bound">e</span> <span class="main">⇒</span> return<span class="main">⋅</span><span class="main">(</span>Err<span class="main">⋅</span><span class="bound">e</span><span class="main">)</span> <span class="main">|</span> Ok<span class="main">⋅</span><span class="bound">x</span> <span class="main">⇒</span> runErrorT<span class="main">⋅</span><span class="main">(</span><span class="free">k</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> bindET_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Error_Transformer-runErrorT_liftET"><span class="command">lemma</span></span> runErrorT_liftET <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"runErrorT<span class="main">⋅</span><span class="main">(</span>liftET<span class="main">⋅</span><span class="free">m</span><span class="main">)</span> <span class="main">=</span> fmap<span class="main">⋅</span>Ok<span class="main">⋅</span><span class="free">m</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> liftET_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Error_Transformer-runErrorT_throwET"><span class="command">lemma</span></span> runErrorT_throwET <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"runErrorT<span class="main">⋅</span><span class="main">(</span>throwET<span class="main">⋅</span><span class="free">e</span><span class="main">)</span> <span class="main">=</span> return<span class="main">⋅</span><span class="main">(</span>Err<span class="main">⋅</span><span class="free">e</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> throwET_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Error_Transformer-runErrorT_catchET"><span class="command">lemma</span></span> runErrorT_catchET <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"runErrorT<span class="main">⋅</span><span class="main">(</span>catchET<span class="main">⋅</span><span class="free">m</span><span class="main">⋅</span><span class="free">h</span><span class="main">)</span> <span class="main">=</span>
    bind<span class="main">⋅</span><span class="main">(</span>runErrorT<span class="main">⋅</span><span class="free">m</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> n<span class="main">.</span> <span class="keyword1">case</span> <span class="bound">n</span> <span class="keyword1">of</span>
      Err<span class="main">⋅</span><span class="bound">e</span> <span class="main">⇒</span> runErrorT<span class="main">⋅</span><span class="main">(</span><span class="free">h</span><span class="main">⋅</span><span class="bound">e</span><span class="main">)</span> <span class="main">|</span> Ok<span class="main">⋅</span><span class="bound">x</span> <span class="main">⇒</span> return<span class="main">⋅</span><span class="main">(</span>Ok<span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> catchET_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Error_Transformer-runErrorT_fmapET"><span class="command">lemma</span></span> runErrorT_fmapET <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"runErrorT<span class="main">⋅</span><span class="main">(</span>fmapET<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">m</span><span class="main">)</span> <span class="main">=</span>
    bind<span class="main">⋅</span><span class="main">(</span>runErrorT<span class="main">⋅</span><span class="free">m</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> n<span class="main">.</span> <span class="keyword1">case</span> <span class="bound">n</span> <span class="keyword1">of</span>
      Err<span class="main">⋅</span><span class="bound">e</span> <span class="main">⇒</span> return<span class="main">⋅</span><span class="main">(</span>Err<span class="main">⋅</span><span class="bound">e</span><span class="main">)</span> <span class="main">|</span> Ok<span class="main">⋅</span><span class="bound">x</span> <span class="main">⇒</span> return<span class="main">⋅</span><span class="main">(</span>Ok<span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> fmapET_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Laws›</span></span>

<span class="keyword1" id="Error_Transformer-bindET_unitET"><span class="command">lemma</span></span> bindET_unitET <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"bindET<span class="main">⋅</span><span class="main">(</span>unitET<span class="main">⋅</span><span class="free">x</span><span class="main">)</span><span class="main">⋅</span><span class="free">k</span> <span class="main">=</span> <span class="free">k</span><span class="main">⋅</span><span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> errorT_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="Error_Transformer-catchET_unitET"><span class="command">lemma</span></span> catchET_unitET <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"catchET<span class="main">⋅</span><span class="main">(</span>unitET<span class="main">⋅</span><span class="free">x</span><span class="main">)</span><span class="main">⋅</span><span class="free">h</span> <span class="main">=</span> unitET<span class="main">⋅</span><span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> errorT_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="Error_Transformer-catchET_throwET"><span class="command">lemma</span></span> catchET_throwET <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"catchET<span class="main">⋅</span><span class="main">(</span>throwET<span class="main">⋅</span><span class="free">e</span><span class="main">)</span><span class="main">⋅</span><span class="free">h</span> <span class="main">=</span> <span class="free">h</span><span class="main">⋅</span><span class="free">e</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> errorT_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="Error_Transformer-liftET_return"><span class="command">lemma</span></span> liftET_return<span class="main">:</span>
  <span class="quoted"><span class="quoted">"liftET<span class="main">⋅</span><span class="main">(</span>return<span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> unitET<span class="main">⋅</span><span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> errorT_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmap_return<span class="main">)</span>

<span class="keyword1" id="Error_Transformer-liftET_bind"><span class="command">lemma</span></span> liftET_bind<span class="main">:</span>
  <span class="quoted"><span class="quoted">"liftET<span class="main">⋅</span><span class="main">(</span>bind<span class="main">⋅</span><span class="free">m</span><span class="main">⋅</span><span class="free">k</span><span class="main">)</span> <span class="main">=</span> bindET<span class="main">⋅</span><span class="main">(</span>liftET<span class="main">⋅</span><span class="free">m</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>liftET <span class="keyword1">oo</span> <span class="free">k</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> errorT_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmap_bind bind_fmap<span class="main">)</span>

<span class="keyword1" id="Error_Transformer-bindET_throwET"><span class="command">lemma</span></span> bindET_throwET<span class="main">:</span>
  <span class="quoted"><span class="quoted">"bindET<span class="main">⋅</span><span class="main">(</span>throwET<span class="main">⋅</span><span class="free">e</span><span class="main">)</span><span class="main">⋅</span><span class="free">k</span> <span class="main">=</span> throwET<span class="main">⋅</span><span class="free">e</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> errorT_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="Error_Transformer-bindET_bindET"><span class="command">lemma</span></span> bindET_bindET<span class="main">:</span>
  <span class="quoted"><span class="quoted">"bindET<span class="main">⋅</span><span class="main">(</span>bindET<span class="main">⋅</span><span class="free">m</span><span class="main">⋅</span><span class="free">h</span><span class="main">)</span><span class="main">⋅</span><span class="free">k</span> <span class="main">=</span> bindET<span class="main">⋅</span><span class="free">m</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> bindET<span class="main">⋅</span><span class="main">(</span><span class="free">h</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">⋅</span><span class="free">k</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> errorT_eqI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_bind<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_arg_cong<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_strict<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Error_Transformer-fmapET_fmapET"><span class="command">lemma</span></span> fmapET_fmapET<span class="main">:</span>
  <span class="quoted"><span class="quoted">"fmapET<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span>fmapET<span class="main">⋅</span><span class="free">g</span><span class="main">⋅</span><span class="free">m</span><span class="main">)</span> <span class="main">=</span> fmapET<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="free">g</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="free">m</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmapET_def bindET_bindET<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Right unit monad law is not satisfied in general.›</span></span>

<span class="keyword1" id="Error_Transformer-bindET_unitET_right_counterexample"><span class="command">lemma</span></span> bindET_unitET_right_counterexample<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">m</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">⋅</span><span class="main">(</span><span class="tfree">'m</span><span class="main">::</span>monad<span class="main">,</span><span class="tfree">'e</span><span class="main">)</span> errorT"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">=</span> ErrorT<span class="main">⋅</span><span class="main">(</span>return<span class="main">⋅</span><span class="main">⊥</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"return<span class="main">⋅</span><span class="main">⊥</span> <span class="main">≠</span> <span class="main">(</span><span class="main">⊥</span> <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'e</span> error<span class="main">)</span><span class="main">⋅</span><span class="tfree">'m</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"bindET<span class="main">⋅</span><span class="free">m</span><span class="main">⋅</span>unitET <span class="main">≠</span> <span class="free">m</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> errorT_eq_iff assms<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Right unit is satisfied for inner monads with strict return.›</span></span>

<span class="keyword1" id="Error_Transformer-bindET_unitET_right_restricted"><span class="command">lemma</span></span> bindET_unitET_right_restricted<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">m</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">⋅</span><span class="main">(</span><span class="tfree">'m</span><span class="main">::</span>monad<span class="main">,</span><span class="tfree">'e</span><span class="main">)</span> errorT"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"return<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">(</span><span class="main">⊥</span> <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'e</span> error<span class="main">)</span><span class="main">⋅</span><span class="tfree">'m</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"bindET<span class="main">⋅</span><span class="free">m</span><span class="main">⋅</span>unitET <span class="main">=</span> <span class="free">m</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> errorT_eq_iff
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> trans <span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ monad_right_unit<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_arg_cong<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Error monad transformer invariant›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This inductively-defined invariant is supposed to represent
the set of all values constructible using the standard <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>errorT›</span></span></span></span>
operations.›</span></span>

<span class="keyword1"><span class="command">inductive</span></span> <span class="entity">invar</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">⋅</span><span class="main">(</span><span class="tfree">'m</span><span class="main">::</span>monad<span class="main">,</span> <span class="tfree">'e</span><span class="main">)</span> errorT <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> invar_bottom<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="main">⊥</span>"</span></span>
  <span class="main">|</span> invar_lub<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">Y</span><span class="main">.</span> <span class="main">⟦</span>chain <span class="bound">Y</span><span class="main">;</span> <span class="main">⋀</span><span class="bound">i</span><span class="main">.</span> <span class="free">invar</span> <span class="main">(</span><span class="bound">Y</span> <span class="bound">i</span><span class="main">)</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">invar</span> <span class="main">(</span><span class="main">⨆</span><span class="bound">i</span><span class="main">.</span> <span class="bound">Y</span> <span class="bound">i</span><span class="main">)</span>"</span></span>
  <span class="main">|</span> invar_unitET<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="free">invar</span> <span class="main">(</span>unitET<span class="main">⋅</span><span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="main">|</span> invar_bindET<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">m</span> <span class="bound">k</span><span class="main">.</span> <span class="main">⟦</span><span class="free">invar</span> <span class="bound">m</span><span class="main">;</span> <span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="free">invar</span> <span class="main">(</span><span class="bound">k</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">invar</span> <span class="main">(</span>bindET<span class="main">⋅</span><span class="bound">m</span><span class="main">⋅</span><span class="bound">k</span><span class="main">)</span>"</span></span>
  <span class="main">|</span> invar_throwET<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">e</span><span class="main">.</span> <span class="free">invar</span> <span class="main">(</span>throwET<span class="main">⋅</span><span class="bound">e</span><span class="main">)</span>"</span></span>
  <span class="main">|</span> invar_catchET<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">m</span> <span class="bound">h</span><span class="main">.</span> <span class="main">⟦</span><span class="free">invar</span> <span class="bound">m</span><span class="main">;</span> <span class="main">⋀</span><span class="bound">e</span><span class="main">.</span> <span class="free">invar</span> <span class="main">(</span><span class="bound">h</span><span class="main">⋅</span><span class="bound">e</span><span class="main">)</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">invar</span> <span class="main">(</span>catchET<span class="main">⋅</span><span class="bound">m</span><span class="main">⋅</span><span class="bound">h</span><span class="main">)</span>"</span></span>
  <span class="main">|</span> invar_liftET<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">m</span><span class="main">.</span> <span class="free">invar</span> <span class="main">(</span>liftET<span class="main">⋅</span><span class="bound">m</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Right unit is satisfied for arguments built from standard functions.›</span></span>

<span class="keyword1" id="Error_Transformer-bindET_unitET_right_invar"><span class="command">lemma</span></span> bindET_unitET_right_invar<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"invar <span class="free">m</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"bindET<span class="main">⋅</span><span class="free">m</span><span class="main">⋅</span>unitET <span class="main">=</span> <span class="free">m</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">set</span><span class="main"><span class="main">:</span></span> invar<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> errorT_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_strict<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> admD<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> errorT_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> errorT_eq_iff bind_bind<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_arg_cong<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_strict<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> errorT_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> errorT_eq_iff bind_bind<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_arg_cong<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_strict<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> errorT_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> monad_fmap bind_bind<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Monad-fmap is satisfied for arguments built from standard functions.›</span></span>

<span class="keyword1" id="Error_Transformer-errorT_monad_fmap_invar"><span class="command">lemma</span></span> errorT_monad_fmap_invar<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'b</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">m</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">⋅</span><span class="main">(</span><span class="tfree">'m</span><span class="main">::</span>monad<span class="main">,</span><span class="tfree">'e</span><span class="main">)</span> errorT"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"invar <span class="free">m</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">m</span> <span class="main">=</span> bindET<span class="main">⋅</span><span class="free">m</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> unitET<span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">set</span><span class="main"><span class="main">:</span></span> invar<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> errorT_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_strict fmap_strict<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> admD<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> errorT_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmap_return<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> errorT_eq_iff bind_bind fmap_bind<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_arg_cong<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_strict fmap_strict<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmap_return<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> errorT_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmap_return<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> errorT_eq_iff bind_bind fmap_bind<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_arg_cong<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_strict fmap_strict<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmap_return<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> errorT_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> monad_fmap bind_bind return_error_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Invariant expressed as a deflation›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We can also define an invariant in a more semantic way, as the
set of fixed-points of a deflation.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">invar'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">⋅</span><span class="main">(</span><span class="tfree">'m</span><span class="main">::</span>monad<span class="main">,</span> <span class="tfree">'e</span><span class="main">)</span> errorT <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">invar'</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">⟷</span> fmapET<span class="main">⋅</span>ID<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹All standard operations preserve the invariant.›</span></span>

<span class="keyword1" id="Error_Transformer-invar'_unitET"><span class="command">lemma</span></span> invar'_unitET<span class="main">:</span> <span class="quoted"><span class="quoted">"invar' <span class="main">(</span>unitET<span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> invar'_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmapET_def<span class="main">)</span>

<span class="keyword1" id="Error_Transformer-invar'_fmapET"><span class="command">lemma</span></span> invar'_fmapET<span class="main">:</span> <span class="quoted"><span class="quoted">"invar' <span class="free">m</span> <span class="main">⟹</span> invar' <span class="main">(</span>fmapET<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">m</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> invar'_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">erule</span> subst<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmapET_def bindET_bindET eta_cfun<span class="main">)</span>

<span class="keyword1" id="Error_Transformer-invar'_bindET"><span class="command">lemma</span></span> invar'_bindET<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>invar' <span class="free">m</span><span class="main">;</span> <span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> invar' <span class="main">(</span><span class="free">k</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">⟧</span> <span class="main">⟹</span> invar' <span class="main">(</span>bindET<span class="main">⋅</span><span class="free">m</span><span class="main">⋅</span><span class="free">k</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> invar'_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmapET_def bindET_bindET eta_cfun<span class="main">)</span>

<span class="keyword1" id="Error_Transformer-invar'_throwET"><span class="command">lemma</span></span> invar'_throwET<span class="main">:</span> <span class="quoted"><span class="quoted">"invar' <span class="main">(</span>throwET<span class="main">⋅</span><span class="free">e</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> invar'_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmapET_def bindET_throwET eta_cfun<span class="main">)</span>

<span class="keyword1" id="Error_Transformer-invar'_catchET"><span class="command">lemma</span></span> invar'_catchET<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>invar' <span class="free">m</span><span class="main">;</span> <span class="main">⋀</span><span class="bound">e</span><span class="main">.</span> invar' <span class="main">(</span><span class="free">h</span><span class="main">⋅</span><span class="bound">e</span><span class="main">)</span><span class="main">⟧</span> <span class="main">⟹</span> invar' <span class="main">(</span>catchET<span class="main">⋅</span><span class="free">m</span><span class="main">⋅</span><span class="free">h</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> invar'_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmapET_def eta_cfun<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> errorT_eqI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_bind eta_cfun<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_arg_cong<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_strict<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">e</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> meta_spec<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule_tac</span> t<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="free">h</span><span class="main">⋅</span><span class="improper">e</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> subst<span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">back</span></span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eta_cfun<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Error_Transformer-invar'_liftET"><span class="command">lemma</span></span> invar'_liftET<span class="main">:</span> <span class="quoted"><span class="quoted">"invar' <span class="main">(</span>liftET<span class="main">⋅</span><span class="free">m</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> invar'_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmapET_def errorT_eq_iff<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> monad_fmap bind_bind<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Error_Transformer-invar'_bottom"><span class="command">lemma</span></span> invar'_bottom<span class="main">:</span> <span class="quoted"><span class="quoted">"invar' <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> invar'_def fmapET_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> errorT_eq_iff bind_strict<span class="main">)</span>

<span class="keyword1" id="Error_Transformer-adm_invar'"><span class="command">lemma</span></span> adm_invar'<span class="main">:</span> <span class="quoted"><span class="quoted">"adm invar'"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> invar'_def <span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹All monad laws are preserved by values satisfying the invariant.›</span></span>

<span class="keyword1" id="Error_Transformer-bindET_fmapET_unitET"><span class="command">lemma</span></span> bindET_fmapET_unitET<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"bindET<span class="main">⋅</span><span class="main">(</span>fmapET<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">m</span><span class="main">)</span><span class="main">⋅</span>unitET <span class="main">=</span> fmapET<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">m</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmapET_def bindET_bindET<span class="main">)</span>

<span class="keyword1" id="Error_Transformer-invar'_right_unit"><span class="command">lemma</span></span> invar'_right_unit<span class="main">:</span> <span class="quoted"><span class="quoted">"invar' <span class="free">m</span> <span class="main">⟹</span> bindET<span class="main">⋅</span><span class="free">m</span><span class="main">⋅</span>unitET <span class="main">=</span> <span class="free">m</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> invar'_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">erule</span> subst<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> bindET_fmapET_unitET<span class="main">)</span>

<span class="keyword1" id="Error_Transformer-invar'_monad_fmap"><span class="command">lemma</span></span> invar'_monad_fmap<span class="main">:</span>
  <span class="quoted"><span class="quoted">"invar' <span class="free">m</span> <span class="main">⟹</span> fmapET<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">m</span> <span class="main">=</span> bindET<span class="main">⋅</span><span class="free">m</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> unitET<span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> invar'_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">erule</span> subst<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> errorT_eq_iff<span class="main">)</span>

<span class="keyword1" id="Error_Transformer-invar'_bind_assoc"><span class="command">lemma</span></span> invar'_bind_assoc<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>invar' <span class="free">m</span><span class="main">;</span> <span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> invar' <span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">;</span> <span class="main">⋀</span><span class="bound">y</span><span class="main">.</span> invar' <span class="main">(</span><span class="free">g</span><span class="main">⋅</span><span class="bound">y</span><span class="main">)</span><span class="main">⟧</span>
    <span class="main">⟹</span> bindET<span class="main">⋅</span><span class="main">(</span>bindET<span class="main">⋅</span><span class="free">m</span><span class="main">⋅</span><span class="free">f</span><span class="main">)</span><span class="main">⋅</span><span class="free">g</span> <span class="main">=</span> bindET<span class="main">⋅</span><span class="free">m</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> bindET<span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">⋅</span><span class="free">g</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> bindET_bindET<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Writer_Transformer">
<div class="head">
<h1>Theory Writer_Transformer</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Writer monad transformer›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Writer_Transformer
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Writer_Monad.html">Writer_Monad</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Type definition›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Below is the standard Haskell definition of a writer monad
transformer:›</span></span>

<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹
\begin{verbatim}
newtype WriterT w m a = WriterT { runWriterT :: m (a, w) }
\end{verbatim}
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In this development, since a lazy pair type is not pre-defined
in HOLCF, we will use an equivalent formulation in terms of our
previous \texttt{Writer} type:›</span></span>

<span class="keyword1"><span class="command">text_raw</span></span> <span class="quoted"><span class="plain_text">‹
\begin{verbatim}
data Writer w a = Writer w a
newtype WriterT w m a = WriterT { runWriterT :: m (Writer w a) }
\end{verbatim}
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We can translate this definition directly into HOLCF using
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>tycondef›</span></span></span></span>. \medskip›</span></span>

<span class="keyword1"><span class="command">tycondef</span></span> <span class="tfree">'a</span><span class="main">⋅</span><span class="main">(</span><span class="tfree">'m</span><span class="main">::</span><span class="quoted"><span class="quoted"><span class="quoted">"functor"</span></span></span><span class="main">,</span><span class="tfree">'w</span><span class="main">)</span> writerT <span class="main">=</span>
  WriterT <span class="main">(</span>runWriterT <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'w</span> writer<span class="main">)</span><span class="main">⋅</span><span class="tfree">'m</span>"</span></span><span class="main">)</span>

<span class="keyword1" id="Writer_Transformer-coerce_writerT_abs"><span class="command">lemma</span></span> coerce_writerT_abs <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"coerce<span class="main">⋅</span><span class="main">(</span>writerT_abs<span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> writerT_abs<span class="main">⋅</span><span class="main">(</span>coerce<span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> writerT_abs_def coerce_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> emb_prj_emb prj_emb_prj DEFL_eq_writerT<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Writer_Transformer-coerce_WriterT"><span class="command">lemma</span></span> coerce_WriterT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"coerce<span class="main">⋅</span><span class="main">(</span>WriterT<span class="main">⋅</span><span class="free">k</span><span class="main">)</span> <span class="main">=</span> WriterT<span class="main">⋅</span><span class="main">(</span>coerce<span class="main">⋅</span><span class="free">k</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> WriterT_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Writer_Transformer-writerT_cases"><span class="command">lemma</span></span> writerT_cases <span class="main">[</span><span class="operator">case_names</span> WriterT<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">k</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">=</span> WriterT<span class="main">⋅</span><span class="free">k</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">=</span> WriterT<span class="main">⋅</span><span class="main">(</span>runWriterT<span class="main">⋅</span><span class="free">y</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">y</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Writer_Transformer-WriterT_runWriterT"><span class="command">lemma</span></span> WriterT_runWriterT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"WriterT<span class="main">⋅</span><span class="main">(</span>runWriterT<span class="main">⋅</span><span class="free">m</span><span class="main">)</span> <span class="main">=</span> <span class="free">m</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">m</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> writerT_cases<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="Writer_Transformer-writerT_induct"><span class="command">lemma</span></span> writerT_induct <span class="main">[</span><span class="operator">case_names</span> WriterT<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">P</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">⋅</span><span class="main">(</span><span class="tfree">'f</span><span class="main">::</span>functor<span class="main">,</span><span class="tfree">'e</span><span class="main">)</span> writerT <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">k</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span>WriterT<span class="main">⋅</span><span class="bound">k</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">y</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> writerT_cases<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main">)</span>

<span class="keyword1" id="Writer_Transformer-writerT_eq_iff"><span class="command">lemma</span></span> writerT_eq_iff<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">=</span> <span class="free">b</span> <span class="main">⟷</span> runWriterT<span class="main">⋅</span><span class="free">a</span> <span class="main">=</span> runWriterT<span class="main">⋅</span><span class="free">b</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">a</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> writerT_cases<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">b</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> writerT_cases<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Writer_Transformer-writerT_below_iff"><span class="command">lemma</span></span> writerT_below_iff<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">⊑</span> <span class="free">b</span> <span class="main">⟷</span> runWriterT<span class="main">⋅</span><span class="free">a</span> <span class="main">⊑</span> runWriterT<span class="main">⋅</span><span class="free">b</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">a</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> writerT_cases<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">b</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> writerT_cases<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Writer_Transformer-writerT_eqI"><span class="command">lemma</span></span> writerT_eqI<span class="main">:</span>
  <span class="quoted"><span class="quoted">"runWriterT<span class="main">⋅</span><span class="free">a</span> <span class="main">=</span> runWriterT<span class="main">⋅</span><span class="free">b</span> <span class="main">⟹</span> <span class="free">a</span> <span class="main">=</span> <span class="free">b</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> writerT_eq_iff<span class="main">)</span>

<span class="keyword1" id="Writer_Transformer-writerT_belowI"><span class="command">lemma</span></span> writerT_belowI<span class="main">:</span>
  <span class="quoted"><span class="quoted">"runWriterT<span class="main">⋅</span><span class="free">a</span> <span class="main">⊑</span> runWriterT<span class="main">⋅</span><span class="free">b</span> <span class="main">⟹</span> <span class="free">a</span> <span class="main">⊑</span> <span class="free">b</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> writerT_below_iff<span class="main">)</span>

<span class="keyword1" id="Writer_Transformer-runWriterT_coerce"><span class="command">lemma</span></span> runWriterT_coerce <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"runWriterT<span class="main">⋅</span><span class="main">(</span>coerce<span class="main">⋅</span><span class="free">k</span><span class="main">)</span> <span class="main">=</span> coerce<span class="main">⋅</span><span class="main">(</span>runWriterT<span class="main">⋅</span><span class="free">k</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">k</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> writerT_induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Functor class instance›</span></span>

<span class="keyword1" id="Writer_Transformer-fmap_writer_def"><span class="command">lemma</span></span> fmap_writer_def<span class="main">:</span> <span class="quoted"><span class="quoted">"fmap <span class="main">=</span> writer_map<span class="main">⋅</span>ID"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">rename_tac</span> f<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">rename_tac</span> x<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> writer.exhaust<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> writer_map_def fix_const<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> writer_map_def fix_const Writer_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Writer_Transformer-fmapU_WriterT"><span class="command">lemma</span></span> fmapU_WriterT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"fmapU<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span>WriterT<span class="main">⋅</span><span class="free">m</span><span class="main">)</span> <span class="main">=</span> WriterT<span class="main">⋅</span><span class="main">(</span>fmap<span class="main">⋅</span><span class="main">(</span>fmap<span class="main">⋅</span><span class="free">f</span><span class="main">)</span><span class="main">⋅</span><span class="free">m</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> fmapU_writerT_def writerT_map_def fmap_writer_def fix_const
  WriterT_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Writer_Transformer-runWriterT_fmapU"><span class="command">lemma</span></span> runWriterT_fmapU <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"runWriterT<span class="main">⋅</span><span class="main">(</span>fmapU<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">m</span><span class="main">)</span> <span class="main">=</span> fmap<span class="main">⋅</span><span class="main">(</span>fmap<span class="main">⋅</span><span class="free">f</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>runWriterT<span class="main">⋅</span><span class="free">m</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">m</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> writerT_induct<span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">instance</span></span> writerT <span class="main">::</span> <span class="main">(</span><span class="quoted"><span class="quoted">"functor"</span></span><span class="main">,</span> <span class="quoted"><span class="quoted">"domain"</span></span><span class="main">)</span> <span class="quoted"><span class="quoted">"functor"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">f</span> <span class="skolem">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom <span class="main">→</span> udom"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"udom<span class="main">⋅</span><span class="main">(</span><span class="tfree">'a</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span> writerT"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"fmapU<span class="main">⋅</span><span class="skolem">f</span><span class="main">⋅</span><span class="main">(</span>fmapU<span class="main">⋅</span><span class="skolem">g</span><span class="main">⋅</span><span class="skolem">xs</span><span class="main">)</span> <span class="main">=</span> fmapU<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="skolem">f</span><span class="main">⋅</span><span class="main">(</span><span class="skolem">g</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">xs</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> writerT_induct<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmap_fmap eta_cfun<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Monad operations›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The writer monad transformer does not yield a monad in the
usual sense: We cannot prove a <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>monad›</span></span></span></span> class instance, because
type <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>'a⋅('m,'w) writerT›</span></span></span></span> contains values that break the monad
laws. However, it turns out that such values are inaccessible: The
monad laws are satisfied by all values constructible from the abstract
operations.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹To explore the properties of the writer monad transformer
operations, we define them all as non-overloaded functions. \medskip
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">unitWT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'a</span><span class="main">⋅</span><span class="main">(</span><span class="tfree">'m</span><span class="main">::</span>monad<span class="main">,</span><span class="tfree">'w</span><span class="main">::</span>monoid<span class="main">)</span> writerT"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">unitWT</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> WriterT<span class="main">⋅</span><span class="main">(</span>return<span class="main">⋅</span><span class="main">(</span>Writer<span class="main">⋅</span>mempty<span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">bindWT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">⋅</span><span class="main">(</span><span class="tfree">'m</span><span class="main">::</span>monad<span class="main">,</span><span class="tfree">'w</span><span class="main">::</span>monoid<span class="main">)</span> writerT <span class="main">→</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'b</span><span class="main">⋅</span><span class="main">(</span><span class="tfree">'m</span><span class="main">,</span><span class="tfree">'w</span><span class="main">)</span> writerT<span class="main">)</span> <span class="main">→</span> <span class="tfree">'b</span><span class="main">⋅</span><span class="main">(</span><span class="tfree">'m</span><span class="main">,</span><span class="tfree">'w</span><span class="main">)</span> writerT"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">bindWT</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> m k<span class="main">.</span> WriterT<span class="main">⋅</span><span class="main">(</span>bind<span class="main">⋅</span><span class="main">(</span>runWriterT<span class="main">⋅</span><span class="bound">m</span><span class="main">)</span><span class="main">⋅</span>
    <span class="main">(</span><span class="keyword1">Λ</span><span class="main">(</span>Writer<span class="main">⋅</span>w<span class="main">⋅</span>x<span class="main">)</span><span class="main">.</span> bind<span class="main">⋅</span><span class="main">(</span>runWriterT<span class="main">⋅</span><span class="main">(</span><span class="bound">k</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span><span class="main">(</span>Writer<span class="main">⋅</span>w'<span class="main">⋅</span>y<span class="main">)</span><span class="main">.</span>
      return<span class="main">⋅</span><span class="main">(</span>Writer<span class="main">⋅</span><span class="main">(</span>mappend<span class="main">⋅</span><span class="bound">w</span><span class="main">⋅</span><span class="bound">w'</span><span class="main">)</span><span class="main">⋅</span><span class="bound">y</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">liftWT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'m</span> <span class="main">→</span> <span class="tfree">'a</span><span class="main">⋅</span><span class="main">(</span><span class="tfree">'m</span><span class="main">::</span>monad<span class="main">,</span><span class="tfree">'w</span><span class="main">::</span>monoid<span class="main">)</span> writerT"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">liftWT</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> m<span class="main">.</span> WriterT<span class="main">⋅</span><span class="main">(</span>fmap<span class="main">⋅</span><span class="main">(</span>Writer<span class="main">⋅</span>mempty<span class="main">)</span><span class="main">⋅</span><span class="bound">m</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">tellWT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'w</span> <span class="main">→</span> <span class="tfree">'a</span><span class="main">⋅</span><span class="main">(</span><span class="tfree">'m</span><span class="main">::</span>monad<span class="main">,</span><span class="tfree">'w</span><span class="main">::</span>monoid<span class="main">)</span> writerT"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">tellWT</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> x w<span class="main">.</span> WriterT<span class="main">⋅</span><span class="main">(</span>return<span class="main">⋅</span><span class="main">(</span>Writer<span class="main">⋅</span><span class="bound">w</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">fmapWT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">→</span> <span class="tfree">'a</span><span class="main">⋅</span><span class="main">(</span><span class="tfree">'m</span><span class="main">::</span>monad<span class="main">,</span><span class="tfree">'w</span><span class="main">::</span>monoid<span class="main">)</span> writerT <span class="main">→</span> <span class="tfree">'b</span><span class="main">⋅</span><span class="main">(</span><span class="tfree">'m</span><span class="main">,</span><span class="tfree">'w</span><span class="main">)</span> writerT"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">fmapWT</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> f m<span class="main">.</span> bindWT<span class="main">⋅</span><span class="bound">m</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> unitWT<span class="main">⋅</span><span class="main">(</span><span class="bound">f</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Writer_Transformer-runWriterT_fmap"><span class="command">lemma</span></span> runWriterT_fmap <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"runWriterT<span class="main">⋅</span><span class="main">(</span>fmap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">m</span><span class="main">)</span> <span class="main">=</span> fmap<span class="main">⋅</span><span class="main">(</span>fmap<span class="main">⋅</span><span class="free">f</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>runWriterT<span class="main">⋅</span><span class="free">m</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> fmap_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">coerce_simp</span></span> eta_cfun<span class="main">)</span>

<span class="keyword1" id="Writer_Transformer-runWriterT_unitWT"><span class="command">lemma</span></span> runWriterT_unitWT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"runWriterT<span class="main">⋅</span><span class="main">(</span>unitWT<span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> return<span class="main">⋅</span><span class="main">(</span>Writer<span class="main">⋅</span>mempty<span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> unitWT_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Writer_Transformer-runWriterT_bindWT"><span class="command">lemma</span></span> runWriterT_bindWT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"runWriterT<span class="main">⋅</span><span class="main">(</span>bindWT<span class="main">⋅</span><span class="free">m</span><span class="main">⋅</span><span class="free">k</span><span class="main">)</span> <span class="main">=</span> bind<span class="main">⋅</span><span class="main">(</span>runWriterT<span class="main">⋅</span><span class="free">m</span><span class="main">)</span><span class="main">⋅</span>
    <span class="main">(</span><span class="keyword1">Λ</span><span class="main">(</span>Writer<span class="main">⋅</span>w<span class="main">⋅</span>x<span class="main">)</span><span class="main">.</span> bind<span class="main">⋅</span><span class="main">(</span>runWriterT<span class="main">⋅</span><span class="main">(</span><span class="free">k</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span><span class="main">(</span>Writer<span class="main">⋅</span>w'<span class="main">⋅</span>y<span class="main">)</span><span class="main">.</span>
      return<span class="main">⋅</span><span class="main">(</span>Writer<span class="main">⋅</span><span class="main">(</span>mappend<span class="main">⋅</span><span class="bound">w</span><span class="main">⋅</span><span class="bound">w'</span><span class="main">)</span><span class="main">⋅</span><span class="bound">y</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> bindWT_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Writer_Transformer-runWriterT_liftWT"><span class="command">lemma</span></span> runWriterT_liftWT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"runWriterT<span class="main">⋅</span><span class="main">(</span>liftWT<span class="main">⋅</span><span class="free">m</span><span class="main">)</span> <span class="main">=</span> fmap<span class="main">⋅</span><span class="main">(</span>Writer<span class="main">⋅</span>mempty<span class="main">)</span><span class="main">⋅</span><span class="free">m</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> liftWT_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Writer_Transformer-runWriterT_tellWT"><span class="command">lemma</span></span> runWriterT_tellWT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"runWriterT<span class="main">⋅</span><span class="main">(</span>tellWT<span class="main">⋅</span><span class="free">x</span><span class="main">⋅</span><span class="free">w</span><span class="main">)</span> <span class="main">=</span> return<span class="main">⋅</span><span class="main">(</span>Writer<span class="main">⋅</span><span class="free">w</span><span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> tellWT_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Writer_Transformer-runWriterT_fmapWT"><span class="command">lemma</span></span> runWriterT_fmapWT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"runWriterT<span class="main">⋅</span><span class="main">(</span>fmapWT<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">m</span><span class="main">)</span> <span class="main">=</span>
    runWriterT<span class="main">⋅</span><span class="free">m</span> <span class="main">⤜</span> <span class="main">(</span><span class="keyword1">Λ</span> <span class="main">(</span>Writer<span class="main">⋅</span>w<span class="main">⋅</span>x<span class="main">)</span><span class="main">.</span> return<span class="main">⋅</span><span class="main">(</span>Writer<span class="main">⋅</span><span class="bound">w</span><span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmapWT_def bindWT_def mempty_right<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Laws›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>liftWT›</span></span></span></span> function maps <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>return›</span></span></span></span> and
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>bind›</span></span></span></span> on the inner monad to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>unitWT›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>bindWT›</span></span></span></span>, as expected. \medskip›</span></span>

<span class="keyword1" id="Writer_Transformer-liftWT_return"><span class="command">lemma</span></span> liftWT_return<span class="main">:</span>
  <span class="quoted"><span class="quoted">"liftWT<span class="main">⋅</span><span class="main">(</span>return<span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> unitWT<span class="main">⋅</span><span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> writerT_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmap_return<span class="main">)</span>

<span class="keyword1" id="Writer_Transformer-liftWT_bind"><span class="command">lemma</span></span> liftWT_bind<span class="main">:</span>
  <span class="quoted"><span class="quoted">"liftWT<span class="main">⋅</span><span class="main">(</span>bind<span class="main">⋅</span><span class="free">m</span><span class="main">⋅</span><span class="free">k</span><span class="main">)</span> <span class="main">=</span> bindWT<span class="main">⋅</span><span class="main">(</span>liftWT<span class="main">⋅</span><span class="free">m</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>liftWT <span class="keyword1">oo</span> <span class="free">k</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> writerT_eqI<span class="main">)</span>
   <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> monad_fmap bind_bind mempty_left<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The composition rule holds unconditionally for fmap. The fmap
function also interacts as expected with unit and bind. \medskip›</span></span>

<span class="keyword1" id="Writer_Transformer-fmapWT_fmapWT"><span class="command">lemma</span></span> fmapWT_fmapWT<span class="main">:</span>
  <span class="quoted"><span class="quoted">"fmapWT<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span>fmapWT<span class="main">⋅</span><span class="free">g</span><span class="main">⋅</span><span class="free">m</span><span class="main">)</span> <span class="main">=</span> fmapWT<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="free">g</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="free">m</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> writerT_eq_iff bind_bind<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_arg_cong<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_strict<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mempty_right<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Writer_Transformer-fmapWT_unitWT"><span class="command">lemma</span></span> fmapWT_unitWT<span class="main">:</span>
  <span class="quoted"><span class="quoted">"fmapWT<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span>unitWT<span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> unitWT<span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> writerT_eq_iff mempty_right<span class="main">)</span>

<span class="keyword1" id="Writer_Transformer-fmapWT_bindWT"><span class="command">lemma</span></span> fmapWT_bindWT<span class="main">:</span>
  <span class="quoted"><span class="quoted">"fmapWT<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span>bindWT<span class="main">⋅</span><span class="free">m</span><span class="main">⋅</span><span class="free">k</span><span class="main">)</span> <span class="main">=</span> bindWT<span class="main">⋅</span><span class="free">m</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> fmapWT<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="free">k</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> writerT_eq_iff bind_bind<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_arg_cong<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">rename_tac</span> x<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_strict<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_bind<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_arg_cong<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">rename_tac</span> y<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">y</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_strict<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mempty_right<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Writer_Transformer-bindWT_fmapWT"><span class="command">lemma</span></span> bindWT_fmapWT<span class="main">:</span>
  <span class="quoted"><span class="quoted">"bindWT<span class="main">⋅</span><span class="main">(</span>fmapWT<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">m</span><span class="main">)</span><span class="main">⋅</span><span class="free">k</span> <span class="main">=</span> bindWT<span class="main">⋅</span><span class="free">m</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="free">k</span><span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> writerT_eq_iff bind_bind<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_arg_cong<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">rename_tac</span> x<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_strict<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mempty_right<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The left unit monad law is not satisfied in general. \medskip›</span></span>

<span class="keyword1" id="Writer_Transformer-bindWT_unitWT_counterexample"><span class="command">lemma</span></span> bindWT_unitWT_counterexample<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">k</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'b</span><span class="main">⋅</span><span class="main">(</span><span class="tfree">'m</span><span class="main">::</span>monad<span class="main">,</span><span class="tfree">'w</span><span class="main">::</span>monoid<span class="main">)</span> writerT"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">k</span><span class="main">⋅</span><span class="free">x</span> <span class="main">=</span> WriterT<span class="main">⋅</span><span class="main">(</span>return<span class="main">⋅</span><span class="main">⊥</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> 2<span class="main">:</span> <span class="quoted"><span class="quoted">"return<span class="main">⋅</span><span class="main">⊥</span> <span class="main">≠</span> <span class="main">(</span><span class="main">⊥</span> <span class="main">::</span> <span class="main">(</span><span class="tfree">'b</span><span class="main">⋅</span><span class="tfree">'w</span> writer<span class="main">)</span><span class="main">⋅</span><span class="tfree">'m</span><span class="main">::</span>monad<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"bindWT<span class="main">⋅</span><span class="main">(</span>unitWT<span class="main">⋅</span><span class="free">x</span><span class="main">)</span><span class="main">⋅</span><span class="free">k</span> <span class="main">≠</span> <span class="free">k</span><span class="main">⋅</span><span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> writerT_eq_iff mempty_left assms<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹However, left unit is satisfied for inner monads with a strict
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>return›</span></span></span></span> function.›</span></span>

<span class="keyword1" id="Writer_Transformer-bindWT_unitWT_restricted"><span class="command">lemma</span></span> bindWT_unitWT_restricted<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">k</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'b</span><span class="main">⋅</span><span class="main">(</span><span class="tfree">'m</span><span class="main">::</span>monad<span class="main">,</span><span class="tfree">'w</span><span class="main">::</span>monoid<span class="main">)</span> writerT"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"return<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">(</span><span class="main">⊥</span> <span class="main">::</span> <span class="main">(</span><span class="tfree">'b</span><span class="main">⋅</span><span class="tfree">'w</span> writer<span class="main">)</span><span class="main">⋅</span><span class="tfree">'m</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"bindWT<span class="main">⋅</span><span class="main">(</span>unitWT<span class="main">⋅</span><span class="free">x</span><span class="main">)</span><span class="main">⋅</span><span class="free">k</span> <span class="main">=</span> <span class="free">k</span><span class="main">⋅</span><span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> writerT_eq_iff
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mempty_left<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> trans <span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ monad_right_unit<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_arg_cong<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The associativity of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>bindWT›</span></span></span></span> holds
unconditionally. \medskip›</span></span>

<span class="keyword1" id="Writer_Transformer-bindWT_bindWT"><span class="command">lemma</span></span> bindWT_bindWT<span class="main">:</span>
  <span class="quoted"><span class="quoted">"bindWT<span class="main">⋅</span><span class="main">(</span>bindWT<span class="main">⋅</span><span class="free">m</span><span class="main">⋅</span><span class="free">h</span><span class="main">)</span><span class="main">⋅</span><span class="free">k</span> <span class="main">=</span> bindWT<span class="main">⋅</span><span class="free">m</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> bindWT<span class="main">⋅</span><span class="main">(</span><span class="free">h</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">⋅</span><span class="free">k</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> writerT_eqI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_bind<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_arg_cong<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_strict<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_bind<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_arg_cong<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">rename_tac</span> y<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">y</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_strict<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_bind<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_arg_cong<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">rename_tac</span> z<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">z</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_strict<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mappend_assoc<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The right unit monad law is not satisfied in general. \medskip›</span></span>

<span class="keyword1" id="Writer_Transformer-bindWT_unitWT_right_counterexample"><span class="command">lemma</span></span> bindWT_unitWT_right_counterexample<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">m</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">⋅</span><span class="main">(</span><span class="tfree">'m</span><span class="main">::</span>monad<span class="main">,</span><span class="tfree">'w</span><span class="main">::</span>monoid<span class="main">)</span> writerT"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">=</span> WriterT<span class="main">⋅</span><span class="main">(</span>return<span class="main">⋅</span><span class="main">⊥</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"return<span class="main">⋅</span><span class="main">⊥</span> <span class="main">≠</span> <span class="main">(</span><span class="main">⊥</span> <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'w</span> writer<span class="main">)</span><span class="main">⋅</span><span class="tfree">'m</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"bindWT<span class="main">⋅</span><span class="free">m</span><span class="main">⋅</span>unitWT <span class="main">≠</span> <span class="free">m</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> writerT_eq_iff assms<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Right unit is satisfied for inner monads with a strict <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>return›</span></span></span></span> function. \medskip›</span></span>

<span class="keyword1" id="Writer_Transformer-bindWT_unitWT_right_restricted"><span class="command">lemma</span></span> bindWT_unitWT_right_restricted<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">m</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">⋅</span><span class="main">(</span><span class="tfree">'m</span><span class="main">::</span>monad<span class="main">,</span><span class="tfree">'w</span><span class="main">::</span>monoid<span class="main">)</span> writerT"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"return<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">(</span><span class="main">⊥</span> <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">⋅</span><span class="tfree">'w</span> writer<span class="main">)</span><span class="main">⋅</span><span class="tfree">'m</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"bindWT<span class="main">⋅</span><span class="free">m</span><span class="main">⋅</span>unitWT <span class="main">=</span> <span class="free">m</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> writerT_eq_iff
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> trans <span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ monad_right_unit<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_arg_cong<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms mempty_right<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Writer monad transformer invariant›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We inductively define a predicate that includes all values
that can be constructed from the standard <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>writerT›</span></span></span></span> operations.
\medskip›</span></span>

<span class="keyword1"><span class="command">inductive</span></span> <span class="entity">invar</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">⋅</span><span class="main">(</span><span class="tfree">'m</span><span class="main">::</span>monad<span class="main">,</span> <span class="tfree">'w</span><span class="main">::</span>monoid<span class="main">)</span> writerT <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> invar_bottom<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="main">⊥</span>"</span></span>
  <span class="main">|</span> invar_lub<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">Y</span><span class="main">.</span> <span class="main">⟦</span>chain <span class="bound">Y</span><span class="main">;</span> <span class="main">⋀</span><span class="bound">i</span><span class="main">.</span> <span class="free">invar</span> <span class="main">(</span><span class="bound">Y</span> <span class="bound">i</span><span class="main">)</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">invar</span> <span class="main">(</span><span class="main">⨆</span><span class="bound">i</span><span class="main">.</span> <span class="bound">Y</span> <span class="bound">i</span><span class="main">)</span>"</span></span>
  <span class="main">|</span> invar_unitWT<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="free">invar</span> <span class="main">(</span>unitWT<span class="main">⋅</span><span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="main">|</span> invar_bindWT<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">m</span> <span class="bound">k</span><span class="main">.</span> <span class="main">⟦</span><span class="free">invar</span> <span class="bound">m</span><span class="main">;</span> <span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="free">invar</span> <span class="main">(</span><span class="bound">k</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">invar</span> <span class="main">(</span>bindWT<span class="main">⋅</span><span class="bound">m</span><span class="main">⋅</span><span class="bound">k</span><span class="main">)</span>"</span></span>
  <span class="main">|</span> invar_tellWT<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">w</span><span class="main">.</span> <span class="free">invar</span> <span class="main">(</span>tellWT<span class="main">⋅</span><span class="bound">x</span><span class="main">⋅</span><span class="bound">w</span><span class="main">)</span>"</span></span>
  <span class="main">|</span> invar_liftWT<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">m</span><span class="main">.</span> <span class="free">invar</span> <span class="main">(</span>liftWT<span class="main">⋅</span><span class="bound">m</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Right unit is satisfied for arguments built from standard
functions. \medskip›</span></span>

<span class="keyword1" id="Writer_Transformer-bindWT_unitWT_right_invar"><span class="command">lemma</span></span> bindWT_unitWT_right_invar<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">m</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">⋅</span><span class="main">(</span><span class="tfree">'m</span><span class="main">::</span>monad<span class="main">,</span><span class="tfree">'w</span><span class="main">::</span>monoid<span class="main">)</span> writerT"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"invar <span class="free">m</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"bindWT<span class="main">⋅</span><span class="free">m</span><span class="main">⋅</span>unitWT <span class="main">=</span> <span class="free">m</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">set</span><span class="main"><span class="main">:</span></span> invar<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> invar_bottom <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> writerT_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_strict<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> invar_lub <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">rule</span> admD<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> invar_unitWT <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> writerT_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_bind mempty_left<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> invar_bindWT <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> writerT_eq_iff bind_bind<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_arg_cong<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_strict<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_bind<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_arg_cong<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">rename_tac</span> y<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">y</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_strict<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mempty_right<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> invar_tellWT <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> writerT_eq_iff mempty_right<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> invar_liftWT <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> writerT_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> monad_fmap bind_bind mempty_right<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Left unit is also satisfied for arguments built from standard
functions. \medskip›</span></span>

<span class="keyword1" id="Writer_Transformer-writerT_left_unit_invar_lemma"><span class="command">lemma</span></span> writerT_left_unit_invar_lemma<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"invar <span class="free">m</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"runWriterT<span class="main">⋅</span><span class="free">m</span> <span class="main">⤜</span> <span class="main">(</span><span class="keyword1">Λ</span> <span class="main">(</span>Writer<span class="main">⋅</span>w<span class="main">⋅</span>x<span class="main">)</span><span class="main">.</span> return<span class="main">⋅</span><span class="main">(</span>Writer<span class="main">⋅</span><span class="bound">w</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> runWriterT<span class="main">⋅</span><span class="free">m</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">m</span></span> <span class="quasi_keyword">set</span><span class="main"><span class="main">:</span></span> invar<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> invar_bottom <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_strict<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> invar_lub <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">rule</span> admD<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> invar_unitWT <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> invar_bindWT <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_bind<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_arg_cong<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">rename_tac</span> n<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">n</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_strict<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_bind<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_arg_cong<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">rename_tac</span> p<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">p</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_strict<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> invar_tellWT <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> invar_liftWT <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> monad_fmap bind_bind<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Writer_Transformer-bindWT_unitWT_invar"><span class="command">lemma</span></span> bindWT_unitWT_invar<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"invar <span class="main">(</span><span class="free">k</span><span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"bindWT<span class="main">⋅</span><span class="main">(</span>unitWT<span class="main">⋅</span><span class="free">x</span><span class="main">)</span><span class="main">⋅</span><span class="free">k</span> <span class="main">=</span> <span class="free">k</span><span class="main">⋅</span><span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> writerT_eq_iff mempty_left<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> writerT_left_unit_invar_lemma <span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Invariant expressed as a deflation›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">invar'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">⋅</span><span class="main">(</span><span class="tfree">'m</span><span class="main">::</span>monad<span class="main">,</span> <span class="tfree">'w</span><span class="main">::</span>monoid<span class="main">)</span> writerT <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">invar'</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">⟷</span> fmapWT<span class="main">⋅</span>ID<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹All standard operations preserve the invariant.›</span></span>

<span class="keyword1" id="Writer_Transformer-invar'_bottom"><span class="command">lemma</span></span> invar'_bottom<span class="main">:</span> <span class="quoted"><span class="quoted">"invar' <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> invar'_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> writerT_eq_iff bind_strict<span class="main">)</span>

<span class="keyword1" id="Writer_Transformer-adm_invar'"><span class="command">lemma</span></span> adm_invar'<span class="main">:</span> <span class="quoted"><span class="quoted">"adm invar'"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> invar'_def <span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Writer_Transformer-invar'_unitWT"><span class="command">lemma</span></span> invar'_unitWT<span class="main">:</span> <span class="quoted"><span class="quoted">"invar' <span class="main">(</span>unitWT<span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> invar'_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> writerT_eq_iff<span class="main">)</span>

<span class="keyword1" id="Writer_Transformer-invar'_bindWT"><span class="command">lemma</span></span> invar'_bindWT<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>invar' <span class="free">m</span><span class="main">;</span> <span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> invar' <span class="main">(</span><span class="free">k</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">⟧</span> <span class="main">⟹</span> invar' <span class="main">(</span>bindWT<span class="main">⋅</span><span class="free">m</span><span class="main">⋅</span><span class="free">k</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> invar'_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> subst<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> writerT_eq_iff<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_bind<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_arg_cong<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_strict<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_bind<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_arg_cong<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">rename_tac</span> x<span class="main"><span class="keyword3">,</span></span> <span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_strict<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Writer_Transformer-invar'_tellWT"><span class="command">lemma</span></span> invar'_tellWT<span class="main">:</span> <span class="quoted"><span class="quoted">"invar' <span class="main">(</span>tellWT<span class="main">⋅</span><span class="free">x</span><span class="main">⋅</span><span class="free">w</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> invar'_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> writerT_eq_iff<span class="main">)</span>

<span class="keyword1" id="Writer_Transformer-invar'_liftWT"><span class="command">lemma</span></span> invar'_liftWT<span class="main">:</span> <span class="quoted"><span class="quoted">"invar' <span class="main">(</span>liftWT<span class="main">⋅</span><span class="free">m</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> invar'_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> writerT_eq_iff monad_fmap bind_bind<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Left unit is satisfied for arguments built from fmap.›</span></span>

<span class="keyword1" id="Writer_Transformer-bindWT_unitWT_fmapWT"><span class="command">lemma</span></span> bindWT_unitWT_fmapWT<span class="main">:</span>
  <span class="quoted"><span class="quoted">"bindWT<span class="main">⋅</span><span class="main">(</span>unitWT<span class="main">⋅</span><span class="free">x</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> fmapWT<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="free">k</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span>
    <span class="main">=</span> fmapWT<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="free">k</span><span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmapWT_def writerT_eq_iff bind_bind<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cfun_arg_cong<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> cfun_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_strict mempty_left<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Right unit is satisfied for arguments built from fmap.›</span></span>

<span class="keyword1" id="Writer_Transformer-bindWT_fmapWT_unitWT"><span class="command">lemma</span></span> bindWT_fmapWT_unitWT<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"bindWT<span class="main">⋅</span><span class="main">(</span>fmapWT<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">m</span><span class="main">)</span><span class="main">⋅</span>unitWT <span class="main">=</span> fmapWT<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">m</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bindWT_fmapWT<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmapWT_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹All monad laws are preserved by values satisfying the invariant.›</span></span>

<span class="keyword1" id="Writer_Transformer-invar'_right_unit"><span class="command">lemma</span></span> invar'_right_unit<span class="main">:</span> <span class="quoted"><span class="quoted">"invar' <span class="free">m</span> <span class="main">⟹</span> bindWT<span class="main">⋅</span><span class="free">m</span><span class="main">⋅</span>unitWT <span class="main">=</span> <span class="free">m</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> invar'_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">erule</span> subst<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> bindWT_fmapWT_unitWT<span class="main">)</span>

<span class="keyword1" id="Writer_Transformer-invar'_monad_fmap"><span class="command">lemma</span></span> invar'_monad_fmap<span class="main">:</span>
  <span class="quoted"><span class="quoted">"invar' <span class="free">m</span> <span class="main">⟹</span> fmapWT<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">m</span> <span class="main">=</span> bindWT<span class="main">⋅</span><span class="free">m</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> unitWT<span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> invar'_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">erule</span> subst<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> writerT_eq_iff mempty_right<span class="main">)</span>

<span class="keyword1" id="Writer_Transformer-invar'_bind_assoc"><span class="command">lemma</span></span> invar'_bind_assoc<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>invar' <span class="free">m</span><span class="main">;</span> <span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> invar' <span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">;</span> <span class="main">⋀</span><span class="bound">y</span><span class="main">.</span> invar' <span class="main">(</span><span class="free">g</span><span class="main">⋅</span><span class="bound">y</span><span class="main">)</span><span class="main">⟧</span>
    <span class="main">⟹</span> bindWT<span class="main">⋅</span><span class="main">(</span>bindWT<span class="main">⋅</span><span class="free">m</span><span class="main">⋅</span><span class="free">f</span><span class="main">)</span><span class="main">⋅</span><span class="free">g</span> <span class="main">=</span> bindWT<span class="main">⋅</span><span class="free">m</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> bindWT<span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">⋅</span><span class="free">g</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> bindWT_bindWT<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Monad_Transformer">
<div class="head">
<h1>Theory Monad_Transformer</h1>
</div>
<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">theory</span></span> Monad_Transformer
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Lazy_List_Monad.html">Lazy_List_Monad</a>
  <a href="Maybe_Monad.html">Maybe_Monad</a>
  <a href="Error_Monad.html">Error_Monad</a>
  <a href="Writer_Monad.html">Writer_Monad</a>
  <a href="Binary_Tree_Monad.html">Binary_Tree_Monad</a>
  <a href="Lift_Monad.html">Lift_Monad</a>
  <a href="Resumption_Transformer.html">Resumption_Transformer</a>
  <a href="State_Transformer.html">State_Transformer</a>
  <a href="Error_Transformer.html">Error_Transformer</a>
  <a href="Writer_Transformer.html">Writer_Transformer</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div>