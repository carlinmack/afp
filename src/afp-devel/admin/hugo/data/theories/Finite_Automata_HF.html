<div id="Finite_Automata_HF">
<div class="head">
<h1>Theory Finite_Automata_HF</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">chapter</span></span> <span class="quoted"><span class="plain_text">‹Finite Automata using the Hereditarily Finite Sets›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Finite_Automata_HF <span class="keyword2"><span class="keyword">imports</span></span>
  <a href="../HereditarilyFinite/Ordinal.html">HereditarilyFinite.Ordinal</a>
  <span class="quoted">"<a href="../Regular-Sets/Regular_Exp.html">Regular-Sets.Regular_Exp</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Finite Automata, both deterministic and non-deterministic, for regular languages.
  The Myhill-Nerode Theorem. Closure under intersection, concatenation, etc.
  Regular expressions define regular languages. Closure under reversal;
  the powerset construction mapping NFAs to DFAs. Left and right languages; minimal DFAs.
  Brzozowski's minimization algorithm. Uniqueness up to isomorphism of minimal DFAs.›</span></span>

<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹Deterministic Finite Automata›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Right invariance is the key property for equivalence relations on states of DFAs.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">right_invariant</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> list <span class="main">×</span> <span class="tfree">'a</span> list<span class="main">)</span> set <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">right_invariant</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="main">∀</span><span class="bound">u</span> <span class="bound">v</span> <span class="bound">w</span><span class="main">.</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">⟶</span> <span class="main">(</span><span class="bound">u</span><span class="main">@</span><span class="bound">w</span><span class="main">,</span> <span class="bound">v</span><span class="main">@</span><span class="bound">w</span><span class="main">)</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Basic Definitions›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹First, the record for DFAs›</span></span>
<span class="keyword1"><span class="command">record</span></span> <span class="tfree">'a</span> dfa <span class="main">=</span> states <span class="main">::</span> <span class="quoted"><span class="quoted">"hf set"</span></span>
                init   <span class="main">::</span> <span class="quoted"><span class="quoted">"hf"</span></span>
                final  <span class="main">::</span> <span class="quoted"><span class="quoted">"hf set"</span></span>
                nxt    <span class="main">::</span> <span class="quoted"><span class="quoted">"hf <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> hf"</span></span>

<span class="keyword1"><span class="command">locale</span></span> dfa <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">M</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> dfa"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> init <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"init <span class="free">M</span> <span class="main">∈</span> states <span class="free">M</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> final<span class="main">:</span>       <span class="quoted"><span class="quoted">"final <span class="free">M</span> <span class="main">⊆</span> states <span class="free">M</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> nxt<span class="main">:</span>         <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">q</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">q</span> <span class="main">∈</span> states <span class="free">M</span> <span class="main">⟹</span> nxt <span class="free">M</span> <span class="bound">q</span> <span class="bound">x</span> <span class="main">∈</span> states <span class="free">M</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> finite<span class="main">:</span>      <span class="quoted"><span class="quoted">"finite <span class="main">(</span>states <span class="free">M</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Finite_Automata_HF-finite_final"><span class="command">lemma</span></span> finite_final <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>final <span class="free">M</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> final finite_subset finite <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Transition function for a given starting state and word.›</span></span>
<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">nextl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[</span>hf<span class="main">,</span> <span class="tfree">'a</span> list<span class="main">]</span> <span class="main">⇒</span> hf"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">nextl</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">[]</span>     <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span>"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">nextl</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">nextl</span> <span class="main">(</span>nxt <span class="free">M</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">language</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list set"</span></span>  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">language</span> <span class="main">≡</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> nextl <span class="main">(</span>init <span class="free">M</span><span class="main">)</span> <span class="bound">xs</span> <span class="main">∈</span> final <span class="free">M</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The left language WRT a state q is the set of words that lead to q.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">left_lang</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"hf <span class="main">⇒</span> <span class="tfree">'a</span> list set"</span></span>  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">left_lang</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">≡</span> <span class="main">{</span><span class="bound">u</span><span class="main">.</span> nextl <span class="main">(</span>init <span class="free">M</span><span class="main">)</span> <span class="bound">u</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Part of Prop 1 of
  Jean-Marc Champarnaud, A. Khorsi and T. Paranthoën,
  Split and join for minimizing: Brzozowski's algorithm,
  Prague Stringology Conference 2002›</span></span>
<span class="keyword1" id="Finite_Automata_HF-left_lang_disjoint"><span class="command">lemma</span></span> left_lang_disjoint<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">q1</span> <span class="main">≠</span> <span class="free">q2</span> <span class="main">⟹</span> left_lang <span class="free">q1</span> <span class="main">∩</span> left_lang <span class="free">q2</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> left_lang_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The right language WRT a state q is the set of words that go from q to F.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">right_lang</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"hf <span class="main">⇒</span> <span class="tfree">'a</span> list set"</span></span>  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">right_lang</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">≡</span> <span class="main">{</span><span class="bound">u</span><span class="main">.</span> nextl <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="bound">u</span> <span class="main">∈</span> final <span class="free">M</span><span class="main">}</span>"</span></span>

<span class="keyword1" id="Finite_Automata_HF-language_eq_right_lang"><span class="command">lemma</span></span> language_eq_right_lang<span class="main">:</span> <span class="quoted"><span class="quoted">"language <span class="main">=</span> right_lang <span class="main">(</span>init <span class="free">M</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> language_def right_lang_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Finite_Automata_HF-nextl_app"><span class="command">lemma</span></span> nextl_app<span class="main">:</span> <span class="quoted"><span class="quoted">"nextl <span class="free">q</span> <span class="main">(</span><span class="free">xs</span><span class="main">@</span><span class="free">ys</span><span class="main">)</span> <span class="main">=</span> nextl <span class="main">(</span>nextl <span class="free">q</span> <span class="free">xs</span><span class="main">)</span> <span class="free">ys</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">q</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Finite_Automata_HF-nextl_snoc"><span class="command">lemma</span></span> nextl_snoc <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"nextl <span class="free">q</span> <span class="main">(</span><span class="free">xs</span><span class="main">@</span><span class="main">[</span><span class="free">x</span><span class="main">]</span><span class="main">)</span> <span class="main">=</span> nxt <span class="free">M</span> <span class="main">(</span>nextl <span class="free">q</span> <span class="free">xs</span><span class="main">)</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nextl_app<span class="main">)</span>

<span class="keyword1" id="Finite_Automata_HF-nextl_state"><span class="command">lemma</span></span> nextl_state<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">q</span> <span class="main">∈</span> states <span class="free">M</span> <span class="main">⟹</span> nextl <span class="free">q</span> <span class="free">xs</span> <span class="main">∈</span> states <span class="free">M</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">q</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> nxt<span class="main">)</span>

<span class="keyword1" id="Finite_Automata_HF-nextl_init_state"><span class="command">lemma</span></span> nextl_init_state <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"nextl <span class="main">(</span>init <span class="free">M</span><span class="main">)</span> <span class="free">xs</span> <span class="main">∈</span> states <span class="free">M</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nextl_state<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹An Equivalence Relation on States›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Two words are equivalent if they take the machine to the same state.
  See e.g. Kozen, Automata and Computability, Springer, 1997, page 90.›</span></span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹This relation asks, do <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">u</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">v</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> lead to the same state?›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">eq_nextl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> list <span class="main">×</span> <span class="tfree">'a</span> list<span class="main">)</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">eq_nextl</span> <span class="main">≡</span> <span class="main">{</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">.</span> nextl <span class="main">(</span>init <span class="free">M</span><span class="main">)</span> <span class="bound">u</span> <span class="main">=</span> nextl <span class="main">(</span>init <span class="free">M</span><span class="main">)</span> <span class="bound">v</span><span class="main">}</span>"</span></span>

<span class="keyword1" id="Finite_Automata_HF-equiv_eq_nextl"><span class="command">lemma</span></span> equiv_eq_nextl<span class="main">:</span> <span class="quoted"><span class="quoted">"equiv UNIV eq_nextl"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> equivI refl_on_def sym_def trans_def eq_nextl_def<span class="main">)</span>

<span class="keyword1" id="Finite_Automata_HF-right_invariant_eq_nextl"><span class="command">lemma</span></span> right_invariant_eq_nextl<span class="main">:</span> <span class="quoted"><span class="quoted">"right_invariant eq_nextl"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> right_invariant_def eq_nextl_def nextl_app<span class="main">)</span>

<span class="keyword1" id="Finite_Automata_HF-range_nextl"><span class="command">lemma</span></span> range_nextl<span class="main">:</span> <span class="quoted"><span class="quoted">"range <span class="main">(</span>nextl <span class="main">(</span>init <span class="free">M</span><span class="main">)</span><span class="main">)</span> <span class="main">⊆</span> states <span class="free">M</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> hmem_def nextl_init_state <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Finite_Automata_HF-eq_nextl_class_in_left_lang_im"><span class="command">lemma</span></span> eq_nextl_class_in_left_lang_im<span class="main">:</span> <span class="quoted"><span class="quoted">"eq_nextl <span class="main">``</span> <span class="main">{</span><span class="free">u</span><span class="main">}</span> <span class="main">∈</span> left_lang <span class="main">`</span> states <span class="free">M</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> rev_image_eqI <span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted">"nextl <span class="main"><span class="main">(</span></span>init <span class="free"><span class="free">M</span></span><span class="main"><span class="main">)</span></span> <span class="free"><span class="free">u</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> eq_nextl_def left_lang_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Finite_Automata_HF-language_eq_nextl"><span class="command">lemma</span></span> language_eq_nextl<span class="main">:</span> <span class="quoted"><span class="quoted">"language <span class="main">=</span> eq_nextl <span class="main">``</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">q</span> <span class="main">∈</span> final <span class="free">M</span><span class="main">.</span> left_lang <span class="bound">q</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> language_def eq_nextl_def left_lang_def hmem_def<span class="main">)</span>

<span class="keyword1" id="Finite_Automata_HF-finite_index_eq_nextl"><span class="command">lemma</span></span> finite_index_eq_nextl<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>UNIV <span class="main">//</span> eq_nextl<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> finite_surj <span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted">left_lang</span></span><span class="main"><span class="main">,</span></span> <span class="operator">OF</span> finite<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> quotient_def eq_nextl_class_in_left_lang_im<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Finite_Automata_HF-index_eq_nextl_le_states"><span class="command">lemma</span></span> index_eq_nextl_le_states<span class="main">:</span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>UNIV <span class="main">//</span> eq_nextl<span class="main">)</span> <span class="main">≤</span> card <span class="main">(</span>states <span class="free">M</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> surj_card_le <span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted">left_lang</span></span><span class="main"><span class="main">,</span></span> <span class="operator">OF</span> finite<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> quotient_def eq_nextl_class_in_left_lang_im<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Minimisation via Accessibility›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">accessible</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"hf set"</span></span>  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">accessible</span> <span class="main">≡</span> <span class="main">{</span><span class="bound">q</span><span class="main">.</span> left_lang <span class="bound">q</span> <span class="main">≠</span> <span class="main">{}</span><span class="main">}</span>"</span></span>

<span class="keyword1" id="Finite_Automata_HF-accessible_imp_states"><span class="command">lemma</span></span> accessible_imp_states<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">q</span> <span class="main">∈</span> accessible <span class="main">⟹</span> <span class="free">q</span> <span class="main">∈</span> states <span class="free">M</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> accessible_def left_lang_def<span class="main">)</span>

<span class="keyword1" id="Finite_Automata_HF-nxt_accessible"><span class="command">lemma</span></span> nxt_accessible<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">q</span> <span class="main">∈</span> accessible <span class="main">⟹</span> nxt <span class="free">M</span> <span class="free">q</span> <span class="free">a</span> <span class="main">∈</span> accessible"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> image_iff accessible_def left_lang_def<span class="main">)</span> <span class="main">(</span><span class="operator">metis</span> nextl.simps nextl_app<span class="main">)</span>

<span class="keyword1" id="Finite_Automata_HF-inj_on_left_lang"><span class="command">lemma</span></span> inj_on_left_lang<span class="main">:</span> <span class="quoted"><span class="quoted">"inj_on left_lang accessible"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> inj_on_def left_lang_def accessible_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">path_to</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"hf <span class="main">⇒</span> <span class="tfree">'a</span> list"</span></span>  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">path_to</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">≡</span> <span class="keyword1">SOME</span> <span class="bound">u</span><span class="main">.</span> <span class="bound">u</span> <span class="main">∈</span> left_lang <span class="free"><span class="bound"><span class="entity">q</span></span></span>"</span></span>

<span class="keyword1" id="Finite_Automata_HF-path_to_left_lang"><span class="command">lemma</span></span> path_to_left_lang<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">q</span> <span class="main">∈</span> accessible <span class="main">⟹</span> path_to <span class="free">q</span> <span class="main">∈</span> left_lang <span class="free">q</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> path_to_def left_lang_def accessible_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> someI<span class="main">)</span>

<span class="keyword1" id="Finite_Automata_HF-nextl_path_to"><span class="command">lemma</span></span> nextl_path_to<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">q</span> <span class="main">∈</span> accessible <span class="main">⟹</span> nextl <span class="main">(</span>dfa.init <span class="free">M</span><span class="main">)</span> <span class="main">(</span>path_to <span class="free">q</span><span class="main">)</span> <span class="main">=</span> <span class="free">q</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> path_to_left_lang  <span class="keyword1"><span class="command">unfolding</span></span> left_lang_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">Accessible_dfa</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> dfa"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">Accessible_dfa</span> <span class="main">=</span> <span class="main">⦇</span>dfa.states <span class="main">=</span> accessible<span class="main">,</span>
                     init  <span class="main">=</span> init <span class="free">M</span><span class="main">,</span>
                     final <span class="main">=</span> final <span class="free">M</span> <span class="main">∩</span> accessible<span class="main">,</span>
                     nxt   <span class="main">=</span> nxt <span class="free">M</span><span class="main">⦈</span>"</span></span>

<span class="keyword1" id="Finite_Automata_HF-states_Accessible_dfa"><span class="command">lemma</span></span> states_Accessible_dfa <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"states Accessible_dfa <span class="main">=</span> accessible"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Accessible_dfa_def<span class="main">)</span>

<span class="keyword1" id="Finite_Automata_HF-init_Accessible_dfa"><span class="command">lemma</span></span> init_Accessible_dfa <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"init Accessible_dfa <span class="main">=</span> init <span class="free">M</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Accessible_dfa_def<span class="main">)</span>

<span class="keyword1" id="Finite_Automata_HF-final_Accessible_dfa"><span class="command">lemma</span></span> final_Accessible_dfa <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"final Accessible_dfa <span class="main">=</span> final <span class="free">M</span> <span class="main">∩</span> accessible"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Accessible_dfa_def<span class="main">)</span>

<span class="keyword1" id="Finite_Automata_HF-nxt_Accessible_dfa"><span class="command">lemma</span></span> nxt_Accessible_dfa <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"nxt Accessible_dfa <span class="main">=</span> nxt <span class="free">M</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Accessible_dfa_def<span class="main">)</span>

<span class="keyword1"><span class="command">interpretation</span></span> Accessible<span class="main">:</span> dfa <span class="quoted">Accessible_dfa</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">unfold_locales</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"init Accessible_dfa <span class="main">∈</span> states Accessible_dfa"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> accessible_def left_lang_def<span class="main">)</span> <span class="main">(</span><span class="operator">metis</span> nextl.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"final Accessible_dfa <span class="main">⊆</span> states Accessible_dfa"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> accessible_imp_states<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">q</span> <span class="skolem">a</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span> <span class="main">∈</span> states Accessible_dfa <span class="main">⟹</span> nxt Accessible_dfa <span class="skolem">q</span> <span class="skolem">a</span> <span class="main">∈</span> states Accessible_dfa"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> nxt nxt_accessible<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>states Accessible_dfa<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> accessible_imp_states finite_subset finite<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Finite_Automata_HF-dfa_Accessible"><span class="command">lemma</span></span> dfa_Accessible<span class="main">:</span> <span class="quoted"><span class="quoted">"dfa Accessible_dfa"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>

<span class="keyword1" id="Finite_Automata_HF-nextl_Accessible_dfa"><span class="command">lemma</span></span> nextl_Accessible_dfa <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="free">q</span> <span class="main">∈</span> accessible <span class="main">⟹</span> Accessible.nextl <span class="free">q</span> <span class="free">u</span> <span class="main">=</span> nextl <span class="free">q</span> <span class="free">u</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">u</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> List.rev_induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1" id="Finite_Automata_HF-init_Accessible"><span class="command">lemma</span></span> init_Accessible<span class="main">:</span> <span class="quoted"><span class="quoted">"init <span class="free">M</span> <span class="main">∈</span> accessible"</span></span>
  <span class="keyword1"><span class="command">using</span></span> dfa.init dfa_Accessible <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>

<span class="keyword1"><span class="command">declare</span></span> nextl_Accessible_dfa <span class="main">[</span><span class="operator">OF</span> init_Accessible<span class="main">,</span> <span class="operator">simp</span><span class="main">]</span>

<span class="keyword1" id="Finite_Automata_HF-Accessible_left_lang_eq"><span class="command">lemma</span></span> Accessible_left_lang_eq <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Accessible.left_lang <span class="free">q</span> <span class="main">=</span> left_lang <span class="free">q</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Accessible.left_lang_def left_lang_def<span class="main">)</span>

<span class="keyword1" id="Finite_Automata_HF-Accessible_right_lang_eq"><span class="command">lemma</span></span> Accessible_right_lang_eq <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">q</span> <span class="main">∈</span> accessible <span class="main">⟹</span> Accessible.right_lang <span class="free">q</span> <span class="main">=</span> right_lang <span class="free">q</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Accessible.right_lang_def right_lang_def accessible_def left_lang_def nextl_app <span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Finite_Automata_HF-Accessible_language"><span class="command">lemma</span></span> Accessible_language <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Accessible.language <span class="main">=</span> language"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Accessible.language_eq_right_lang language_eq_right_lang
                Accessible_right_lang_eq <span class="main"><span class="main">[</span></span><span class="operator">OF</span> init_Accessible<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Finite_Automata_HF-Accessible_accessible"><span class="command">lemma</span></span> Accessible_accessible <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Accessible.accessible <span class="main">=</span> accessible"</span></span>
  <span class="keyword1"><span class="command">using</span></span> Accessible.accessible_def accessible_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>


<span class="keyword1" id="Finite_Automata_HF-left_lang_half"><span class="command">lemma</span></span> left_lang_half<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> sb<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋃</span><span class="main">(</span>left_lang <span class="main">`</span> <span class="free">qs1</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">⋃</span><span class="main">(</span>left_lang <span class="main">`</span> <span class="free">qs2</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> ne<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">qs1</span> <span class="main">⟹</span> left_lang <span class="bound">x</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">qs1</span> <span class="main">⊆</span> <span class="free">qs2</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
  <span class="keyword3"><span class="command">assume</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">qs1</span>"</span></span>
  <span class="keyword1"><span class="command">with</span></span> ne <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">y</span></span> <span class="keyword2"><span class="keyword">where</span></span> y<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> left_lang <span class="skolem">x</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> <span class="main">⋃</span><span class="main">(</span>left_lang <span class="main">`</span> <span class="free">qs2</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> x sb <span class="main">[</span><span class="operator">THEN</span> subsetD<span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="free">qs2</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> UN_E disjoint_iff_not_equal left_lang_disjoint y<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Finite_Automata_HF-left_lang_UN"><span class="command">lemma</span></span> left_lang_UN<span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">⋃</span><span class="main">(</span>left_lang <span class="main">`</span> <span class="free">qs1</span><span class="main">)</span> <span class="main">=</span> <span class="main">⋃</span><span class="main">(</span>left_lang <span class="main">`</span> <span class="free">qs2</span><span class="main">)</span><span class="main">;</span> <span class="free">qs1</span> <span class="main">∪</span> <span class="free">qs2</span> <span class="main">⊆</span> accessible<span class="main">⟧</span>
      <span class="main">⟹</span> <span class="free">qs1</span> <span class="main">=</span> <span class="free">qs2</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> equalityI <span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ dfa.left_lang_half <span class="main"><span class="main">[</span></span><span class="operator">OF</span> dfa_Accessible<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> dfa.left_lang_half <span class="main"><span class="main">[</span></span><span class="operator">OF</span> dfa_Accessible<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> accessible_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">minimal</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">minimal</span> <span class="main">≡</span> accessible <span class="main">=</span> states <span class="free">M</span> <span class="main">∧</span> inj_on right_lang <span class="main">(</span>dfa.states <span class="free">M</span><span class="main">)</span>"</span></span>



<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹An Equivalence Relation on States›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Collapsing map on states. Two states are equivalent if they yield identical outcomes›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">eq_right_lang</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>hf <span class="main">×</span> hf<span class="main">)</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">eq_right_lang</span> <span class="main">≡</span> <span class="main">{</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">.</span> <span class="bound">u</span> <span class="main">∈</span> states <span class="free">M</span> <span class="main">∧</span> <span class="bound">v</span> <span class="main">∈</span> states <span class="free">M</span> <span class="main">∧</span> right_lang <span class="bound">u</span> <span class="main">=</span> right_lang <span class="bound">v</span><span class="main">}</span>"</span></span>

<span class="keyword1" id="Finite_Automata_HF-equiv_eq_right_lang"><span class="command">lemma</span></span> equiv_eq_right_lang<span class="main">:</span> <span class="quoted"><span class="quoted">"equiv <span class="main">(</span>states <span class="free">M</span><span class="main">)</span> eq_right_lang"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> equiv_def refl_on_def sym_def trans_def eq_right_lang_def<span class="main">)</span>

<span class="keyword1" id="Finite_Automata_HF-eq_right_lang_finite_index"><span class="command">lemma</span></span> eq_right_lang_finite_index<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>states <span class="free">M</span> <span class="main">//</span> eq_right_lang<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> finite_imageI finite proj_image<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">Collapse_dfa</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> dfa"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">Collapse_dfa</span> <span class="main">=</span> <span class="main">⦇</span>dfa.states <span class="main">=</span> HF <span class="main">`</span> <span class="main">(</span>states <span class="free">M</span> <span class="main">//</span> eq_right_lang<span class="main">)</span><span class="main">,</span>
                   init       <span class="main">=</span> HF <span class="main">(</span>eq_right_lang <span class="main">``</span> <span class="main">{</span>init <span class="free">M</span><span class="main">}</span><span class="main">)</span><span class="main">,</span>
                   final      <span class="main">=</span> <span class="main">{</span>HF <span class="main">(</span>eq_right_lang <span class="main">``</span> <span class="main">{</span><span class="bound">q</span><span class="main">}</span><span class="main">)</span> <span class="main">|</span> <span class="bound">q</span><span class="main">.</span> <span class="bound">q</span> <span class="main">∈</span> final <span class="free">M</span><span class="main">}</span><span class="main">,</span>
                   nxt        <span class="main">=</span> <span class="main">λ</span><span class="bound">Q</span> <span class="bound">x</span><span class="main">.</span> HF <span class="main">(</span><span class="main">⋃</span><span class="bound">q</span> <span class="main">∈</span> hfset <span class="bound">Q</span><span class="main">.</span> eq_right_lang <span class="main">``</span> <span class="main">{</span>nxt <span class="free">M</span> <span class="bound">q</span> <span class="bound">x</span><span class="main">}</span><span class="main">)</span><span class="main">⦈</span>"</span></span>

<span class="keyword1" id="Finite_Automata_HF-nxt_Collapse_resp"><span class="command">lemma</span></span> nxt_Collapse_resp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">q</span><span class="main">.</span> eq_right_lang <span class="main">``</span> <span class="main">{</span>nxt <span class="free">M</span> <span class="bound">q</span> <span class="free">x</span><span class="main">}</span><span class="main">)</span> <span class="keyword1">respects</span> eq_right_lang"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> nextl.simps <span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> congruent_def eq_right_lang_def nxt right_lang_def
           <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> nextl.simps<span class="main">)</span>

<span class="keyword1" id="Finite_Automata_HF-finite_Collapse_state"><span class="command">lemma</span></span> finite_Collapse_state<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="main">∈</span> states <span class="free">M</span> <span class="main">//</span> eq_right_lang <span class="main">⟹</span> finite <span class="free">Q</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> equiv_eq_right_lang finite_subset in_quotient_imp_subset finite<span class="main">)</span>

<span class="keyword1"><span class="command">interpretation</span></span> Collapse<span class="main">:</span> dfa <span class="quoted">Collapse_dfa</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">unfold_locales</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"dfa.init Collapse_dfa <span class="main">∈</span> dfa.states Collapse_dfa"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Collapse_dfa_def quotientI<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"dfa.final Collapse_dfa <span class="main">⊆</span> dfa.states Collapse_dfa"</span></span>
    <span class="keyword1"><span class="command">using</span></span> final
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Collapse_dfa_def quotientI<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">q</span> <span class="skolem">a</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span> <span class="main">∈</span> dfa.states Collapse_dfa <span class="main">⟹</span> dfa.nxt Collapse_dfa <span class="skolem">q</span> <span class="skolem">a</span> <span class="main">∈</span> dfa.states Collapse_dfa"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Collapse_dfa_def nxt quotientI finite_Collapse_state
                   UN_equiv_class_type <span class="main"><span class="main">[</span></span><span class="operator">OF</span> equiv_eq_right_lang nxt_Collapse_resp<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>dfa.states Collapse_dfa<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Collapse_dfa_def eq_right_lang_finite_index<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">corollary</span></span> dfa_Collapse<span class="main">:</span> <span class="quoted"><span class="quoted">"dfa Collapse_dfa"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>

<span class="keyword1" id="Finite_Automata_HF-nextl_Collapse_dfa"><span class="command">lemma</span></span> nextl_Collapse_dfa<span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="main">=</span> HF <span class="main">(</span>eq_right_lang <span class="main">``</span> <span class="main">{</span><span class="free">q</span><span class="main">}</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">Q</span> <span class="main">∈</span> dfa.states Collapse_dfa <span class="main">⟹</span>
      <span class="free">q</span> <span class="main">∈</span> states <span class="free">M</span> <span class="main">⟹</span>
             Collapse.nextl <span class="free">Q</span> <span class="free">u</span> <span class="main">=</span> HF <span class="main">(</span>eq_right_lang <span class="main">``</span> <span class="main">{</span>nextl <span class="free">q</span> <span class="free">u</span><span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">u</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> List.rev_induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Collapse_dfa_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> inj_on_eq_iff <span class="main"><span class="main">[</span></span><span class="operator">OF</span> inj_on_HF<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> UN_equiv_class_type <span class="main"><span class="main">[</span></span><span class="operator">OF</span> equiv_eq_right_lang nxt_Collapse_resp<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> nxt quotientI finite_Collapse_state nextl_state<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nextl.simps <span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span>  eq_right_lang_def nxt right_lang_def
               <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> nextl.simps<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> equiv_class_self equiv_eq_right_lang nextl_state<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Finite_Automata_HF-ext_language_Collapse_dfa"><span class="command">lemma</span></span> ext_language_Collapse_dfa<span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="free">u</span> <span class="main">∈</span> Collapse.language <span class="main">⟷</span> <span class="free">u</span> <span class="main">∈</span> language"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Collapse.language_def language_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> nextl_Collapse_dfa<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Collapse_dfa_def<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> final <span class="main">[</span><span class="operator">THEN</span> subsetD<span class="main">]</span> init
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> quotientI  inj_on_eq_iff <span class="main"><span class="main">[</span></span><span class="operator">OF</span> inj_on_HF<span class="main"><span class="main">]</span></span> finite_Collapse_state
                    UN_equiv_class_type <span class="main"><span class="main">[</span></span><span class="operator">OF</span> equiv_eq_right_lang nxt_Collapse_resp<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> eq_equiv_class <span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ equiv_eq_right_lang<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> eq_right_lang_def right_lang_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> mem_Collect_eq nextl.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">theorem</span></span> language_Collapse_dfa<span class="main">:</span>
     <span class="quoted"><span class="quoted">"Collapse.language <span class="main">=</span> language"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ext_language_Collapse_dfa subset_antisym subset_iff<span class="main">)</span>

<span class="keyword1" id="Finite_Automata_HF-card_Collapse_dfa"><span class="command">lemma</span></span> card_Collapse_dfa<span class="main">:</span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>states <span class="free">M</span> <span class="main">//</span> eq_right_lang<span class="main">)</span> <span class="main">≤</span> card <span class="main">(</span>states <span class="free">M</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> card_image_le finite proj_image<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Isomorphisms Between DFAs›</span></span>

<span class="keyword1"><span class="command">locale</span></span> dfa_isomorphism <span class="main">=</span> M<span class="main">:</span> dfa <span class="quoted"><span class="free">M</span></span> <span class="main">+</span> N<span class="main">:</span> dfa <span class="quoted"><span class="free">N</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">M</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> dfa"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">N</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> dfa"</span></span> <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">h</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"hf <span class="main">⇒</span> hf"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> h<span class="main">:</span> <span class="quoted"><span class="quoted">"bij_betw <span class="free">h</span> <span class="main">(</span>states <span class="free">M</span><span class="main">)</span> <span class="main">(</span>states <span class="free">N</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> init  <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">(</span>init <span class="free">M</span><span class="main">)</span> <span class="main">=</span> init <span class="free">N</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> final <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">`</span> final <span class="free">M</span> <span class="main">=</span> final <span class="free">N</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> nxt   <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">q</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">q</span> <span class="main">∈</span> states <span class="free">M</span> <span class="main">⟹</span> <span class="free">h</span> <span class="main">(</span>nxt <span class="free">M</span> <span class="bound">q</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> nxt <span class="free">N</span> <span class="main">(</span><span class="free">h</span> <span class="bound">q</span><span class="main">)</span> <span class="bound">x</span>"</span></span>

<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Finite_Automata_HF-nextl"><span class="command">lemma</span></span> nextl <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">q</span> <span class="main">∈</span> states <span class="free">M</span> <span class="main">⟹</span> <span class="free">h</span> <span class="main">(</span>M.nextl <span class="free">q</span> <span class="free">u</span><span class="main">)</span> <span class="main">=</span> N.nextl <span class="main">(</span><span class="free">h</span> <span class="free">q</span><span class="main">)</span> <span class="free">u</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">u</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> List.rev_induct<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> M.nextl_state<span class="main">)</span>

<span class="keyword1"><span class="command">theorem</span></span> language<span class="main">:</span> <span class="quoted"><span class="quoted">"M.language <span class="main">=</span> N.language"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> set_eqI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">u</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"M.nextl <span class="main">(</span>init <span class="free">M</span><span class="main">)</span> <span class="skolem">u</span> <span class="main">∈</span> final <span class="free">M</span> <span class="main">⟷</span> <span class="free">h</span> <span class="main">(</span>M.nextl <span class="main">(</span>init <span class="free">M</span><span class="main">)</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> <span class="free">h</span> <span class="main">`</span> final <span class="free">M</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> inj_on_image_mem_iff <span class="main"><span class="main">[</span></span><span class="operator">OF</span> bij_betw_imp_inj_on <span class="main"><span class="main">[</span></span><span class="operator">OF</span> h<span class="main"><span class="main">]</span></span> _ M.final<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">...</span> <span class="main">⟷</span> N.nextl <span class="main">(</span>init <span class="free">N</span><span class="main">)</span> <span class="skolem">u</span> <span class="main">∈</span> final <span class="free">N</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∈</span> M.language <span class="main">⟷</span> <span class="skolem">u</span> <span class="main">∈</span> dfa.language <span class="free">N</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> M.language_def N.language_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Finite_Automata_HF-nxt_inv_into"><span class="command">lemma</span></span> nxt_inv_into<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">q</span> <span class="main">∈</span> states <span class="free">N</span> <span class="main">⟹</span> nxt <span class="free">N</span> <span class="free">q</span> <span class="free">x</span> <span class="main">=</span> <span class="free">h</span> <span class="main">(</span>nxt <span class="free">M</span> <span class="main">(</span>inv_into <span class="main">(</span>states <span class="free">M</span><span class="main">)</span> <span class="free">h</span> <span class="free">q</span><span class="main">)</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> nxt<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> bij_betw_def h inv_into_into<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> bij_betw_inv_into_right h<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Finite_Automata_HF-sym"><span class="command">lemma</span></span> sym<span class="main">:</span> <span class="quoted"><span class="quoted">"dfa_isomorphism <span class="free">N</span> <span class="free">M</span> <span class="main">(</span>inv_into <span class="main">(</span>states <span class="free">M</span><span class="main">)</span> <span class="free">h</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> bij_betw_inv_into h<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> M.init bij_betw_imp_inj_on h inv_into_f_eq init<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> M.final bij_betw_def bij_betw_inv_into_subset h final<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nxt_inv_into<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> M.nxt bij_betw_def h inv_into_f_eq inv_into_into<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Finite_Automata_HF-trans"><span class="command">lemma</span></span> trans<span class="main">:</span> <span class="quoted"><span class="quoted">"dfa_isomorphism <span class="free">N</span> <span class="free">N'</span> <span class="free">h'</span> <span class="main">⟹</span> dfa_isomorphism <span class="free">M</span> <span class="free">N'</span> <span class="main">(</span><span class="free">h'</span> <span class="keyword1">o</span> <span class="free">h</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> dfa_isomorphism_def dfa_isomorphism_axioms_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> bij_betw_comp_iff h<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> imageI final<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> final <span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> image_comp<span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> bij_betw_def h image_iff<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹The Myhill-Nerode theorem: three characterisations of a regular language›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">regular</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list set <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">regular</span> <span class="free"><span class="bound"><span class="entity">L</span></span></span> <span class="main">≡</span> <span class="main">∃</span><span class="bound">M</span><span class="main">.</span> dfa <span class="bound">M</span> <span class="main">∧</span> dfa.language <span class="bound">M</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">L</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">MyhillNerode</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> list <span class="main">*</span> <span class="tfree">'a</span> list<span class="main">)</span> set <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">MyhillNerode</span> <span class="free"><span class="bound"><span class="entity">L</span></span></span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">≡</span> equiv UNIV <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">∧</span> right_invariant <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">∧</span> finite <span class="main">(</span>UNIV<span class="main">//</span><span class="free"><span class="bound"><span class="entity">R</span></span></span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∃</span><span class="bound">A</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">L</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span><span class="main">``</span><span class="bound">A</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹This relation can be seen as an abstraction of the idea, do <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">u</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">v</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
  lead to the same state?  Compare with <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">eq_nextl</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, which does precisely that.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">eq_app_right</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list set <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> list <span class="main">*</span> <span class="tfree">'a</span> list<span class="main">)</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">eq_app_right</span> <span class="free"><span class="bound"><span class="entity">L</span></span></span> <span class="main">≡</span> <span class="main">{</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">.</span> <span class="main">∀</span><span class="bound">w</span><span class="main">.</span> <span class="bound">u</span><span class="main">@</span><span class="bound">w</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">L</span></span></span> <span class="main">⟷</span> <span class="bound">v</span><span class="main">@</span><span class="bound">w</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">L</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1" id="Finite_Automata_HF-equiv_eq_app_right"><span class="command">lemma</span></span> equiv_eq_app_right<span class="main">:</span> <span class="quoted"><span class="quoted">"equiv UNIV <span class="main">(</span>eq_app_right <span class="free">L</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> equivI refl_on_def sym_def trans_def eq_app_right_def<span class="main">)</span>

<span class="keyword1" id="Finite_Automata_HF-right_invariant_eq_app_right"><span class="command">lemma</span></span> right_invariant_eq_app_right<span class="main">:</span> <span class="quoted"><span class="quoted">"right_invariant <span class="main">(</span>eq_app_right <span class="free">L</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> right_invariant_def eq_app_right_def<span class="main">)</span>

<span class="keyword1" id="Finite_Automata_HF-eq_app_right_eq"><span class="command">lemma</span></span> eq_app_right_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"eq_app_right <span class="free">L</span> <span class="main">``</span> <span class="free">L</span> <span class="main">=</span> <span class="free">L</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> eq_app_right_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> <span class="main">(</span><span class="operator">metis</span> append_Nil2<span class="main">)</span>

<span class="keyword1" id="Finite_Automata_HF-MN_eq_app_right"><span class="command">lemma</span></span> MN_eq_app_right<span class="main">:</span>
     <span class="quoted"><span class="quoted">"finite <span class="main">(</span>UNIV <span class="main">//</span> eq_app_right <span class="free">L</span><span class="main">)</span> <span class="main">⟹</span> MyhillNerode <span class="free">L</span> <span class="main">(</span>eq_app_right <span class="free">L</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> MyhillNerode_def
  <span class="keyword1"><span class="command">using</span></span> eq_app_right_eq
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> equiv_eq_app_right right_invariant_eq_app_right<span class="main">)</span>

<span class="keyword1" id="Finite_Automata_HF-MN_refines"><span class="command">lemma</span></span> MN_refines<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>MyhillNerode <span class="free">L</span> <span class="free">R</span><span class="main">;</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">∈</span> <span class="free">L</span> <span class="main">⟷</span> <span class="free">y</span> <span class="main">∈</span> <span class="free">L</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> equiv_def trans_def sym_def MyhillNerode_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="Finite_Automata_HF-MN_refines_eq_app_right"><span class="command">lemma</span></span> MN_refines_eq_app_right<span class="main">:</span> <span class="quoted"><span class="quoted">"MyhillNerode <span class="free">L</span> <span class="free">R</span> <span class="main">⟹</span> <span class="free">R</span> <span class="main">⊆</span> eq_app_right <span class="free">L</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> eq_app_right_def MyhillNerode_def right_invariant_def equiv_def trans_def sym_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Step 1 in the circle of implications: every regular language <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">L</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is recognised
  by some Myhill-Nerode relation, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">R</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>
<span class="keyword1"><span class="command">context</span></span> dfa
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1" id="Finite_Automata_HF-MN_eq_nextl"><span class="command">lemma</span></span> MN_eq_nextl<span class="main">:</span> <span class="quoted"><span class="quoted">"MyhillNerode language eq_nextl"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> MyhillNerode_def
    <span class="keyword1"><span class="command">using</span></span> language_eq_nextl
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> equiv_eq_nextl right_invariant_eq_nextl finite_index_eq_nextl<span class="main">)</span>

  <span class="keyword1"><span class="command">corollary</span></span> eq_nextl_refines_eq_app_right<span class="main">:</span> <span class="quoted"><span class="quoted">"eq_nextl <span class="main">⊆</span> eq_app_right language"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> MN_eq_nextl MN_refines_eq_app_right<span class="main">)</span>

  <span class="keyword1" id="Finite_Automata_HF-index_le_index_eq_nextl"><span class="command">lemma</span></span> index_le_index_eq_nextl<span class="main">:</span>
       <span class="quoted"><span class="quoted">"card <span class="main">(</span>UNIV <span class="main">//</span> eq_app_right language<span class="main">)</span> <span class="main">≤</span> card <span class="main">(</span>UNIV <span class="main">//</span> eq_nextl<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> finite_refines_card_le finite_index_eq_nextl equiv_eq_nextl equiv_eq_app_right
              eq_nextl_refines_eq_app_right<span class="main">)</span>

  <span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹A specific lower bound on the number of states in a DFA›</span></span>
  <span class="keyword1" id="Finite_Automata_HF-index_eq_app_right_lower"><span class="command">lemma</span></span> index_eq_app_right_lower<span class="main">:</span>
       <span class="quoted"><span class="quoted">"card <span class="main">(</span>UNIV <span class="main">//</span> eq_app_right language<span class="main">)</span> <span class="main">≤</span> card <span class="main">(</span>states <span class="free">M</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> index_eq_nextl_le_states index_le_index_eq_nextl order_trans <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Finite_Automata_HF-L1_2"><span class="command">lemma</span></span> L1_2<span class="main">:</span> <span class="quoted"><span class="quoted">"regular <span class="free">L</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">R</span><span class="main">.</span> MyhillNerode <span class="free">L</span> <span class="bound">R</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> dfa.MN_eq_nextl regular_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Step 2: every Myhill-Nerode relation <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">R</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> for the language <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">L</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
  can be mapped to the canonical M-N relation.›</span></span>
<span class="keyword1" id="Finite_Automata_HF-L2_3"><span class="command">lemma</span></span> L2_3<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"MyhillNerode <span class="free">L</span> <span class="free">R</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>UNIV <span class="main">//</span> eq_app_right <span class="free">L</span><span class="main">)</span>"</span></span>
          <span class="quoted"><span class="quoted">"card <span class="main">(</span>UNIV <span class="main">//</span> eq_app_right <span class="free">L</span><span class="main">)</span> <span class="main">≤</span> card <span class="main">(</span>UNIV <span class="main">//</span> <span class="free">R</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> assms MN_refines_eq_app_right MyhillNerode_def equiv_eq_app_right finite_refines_finite finite_refines_card_le<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Working towards step 3.  Also, every Myhill-Nerode relation <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">R</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">L</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
  can be mapped to a machine. The locale below constructs such a DFA.›</span></span>

<span class="keyword1"><span class="command">locale</span></span> MyhillNerode_dfa <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">L</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list set"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">R</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> list <span class="main">*</span> <span class="tfree">'a</span> list<span class="main">)</span> set"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">A</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list set"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">n</span> <span class="main">::</span> <span class="quoted">nat</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">h</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list set <span class="main">⇒</span> hf"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> eqR<span class="main">:</span> <span class="quoted"><span class="quoted">"equiv UNIV <span class="free">R</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> riR<span class="main">:</span> <span class="quoted"><span class="quoted">"right_invariant <span class="free">R</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> L<span class="main">:</span>   <span class="quoted"><span class="quoted">"<span class="free">L</span> <span class="main">=</span> <span class="free">R</span><span class="main">``</span><span class="free">A</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> h<span class="main">:</span>   <span class="quoted"><span class="quoted">"bij_betw <span class="free">h</span> <span class="main">(</span>UNIV<span class="main">//</span><span class="free">R</span><span class="main">)</span> <span class="main">(</span>hfset <span class="main">(</span>ord_of <span class="free">n</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1" id="Finite_Automata_HF-injh"><span class="command">lemma</span></span> injh<span class="main">:</span> <span class="quoted"><span class="quoted">"inj_on <span class="free">h</span> <span class="main">(</span>UNIV<span class="main">//</span><span class="free">R</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> h bij_betw_imp_inj_on <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">hinv</span> <span class="main">(</span><span class="quoted">"<span class="keyword1">h<span class="hidden">⇧</span><sup>-</sup><span class="hidden">⇧</span><sup>1</sup></span>"</span><span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="free">h<span class="hidden">⇧</span><sup>-</sup><span class="hidden">⇧</span><sup>1</sup></span></span> <span class="main">≡</span> inv_into <span class="main">(</span>UNIV<span class="main">//</span><span class="free">R</span><span class="main">)</span> <span class="free">h</span>"</span></span>

  <span class="keyword1" id="Finite_Automata_HF-finix"><span class="command">lemma</span></span> finix<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>UNIV<span class="main">//</span><span class="free">R</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> h bij_betw_finite finite_hfset <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">DFA</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> dfa"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">DFA</span> <span class="main">=</span> <span class="main">⦇</span>states <span class="main">=</span> <span class="free">h</span> <span class="main">`</span> <span class="main">(</span>UNIV<span class="main">//</span><span class="free">R</span><span class="main">)</span><span class="main">,</span>
            init  <span class="main">=</span> <span class="free">h</span> <span class="main">(</span><span class="free">R</span> <span class="main">``</span> <span class="main">{</span><span class="main">[]</span><span class="main">}</span><span class="main">)</span><span class="main">,</span>
            final <span class="main">=</span> <span class="main">{</span><span class="free">h</span> <span class="main">(</span><span class="free">R</span> <span class="main">``</span> <span class="main">{</span><span class="bound">u</span><span class="main">}</span><span class="main">)</span> <span class="main">|</span> <span class="bound">u</span><span class="main">.</span> <span class="bound">u</span> <span class="main">∈</span> <span class="free">A</span><span class="main">}</span><span class="main">,</span>
            nxt   <span class="main">=</span> <span class="main">λ</span><span class="bound">q</span> <span class="bound">x</span><span class="main">.</span> <span class="free">h</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">u</span> <span class="main">∈</span> <span class="keyword1">h<span class="hidden">⇧</span><sup>-</sup><span class="hidden">⇧</span><sup>1</sup></span> <span class="bound">q</span><span class="main">.</span> <span class="free">R</span> <span class="main">``</span> <span class="main">{</span><span class="bound">u</span><span class="main">@</span><span class="main">[</span><span class="bound">x</span><span class="main">]</span><span class="main">}</span><span class="main">)</span><span class="main">⦈</span>"</span></span>

  <span class="keyword1" id="Finite_Automata_HF-resp"><span class="command">lemma</span></span> resp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="main">λ</span><span class="bound">u</span><span class="main">.</span> <span class="free">R</span> <span class="main">``</span> <span class="main">{</span><span class="bound">u</span> <span class="main">@</span> <span class="main">[</span><span class="bound">x</span><span class="main">]</span><span class="main">}</span><span class="main">)</span> <span class="keyword1">respects</span> <span class="free">R</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> riR
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> congruent_def right_invariant_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> equiv_class_eq <span class="main"><span class="main">[</span></span><span class="operator">OF</span> eqR<span class="main"><span class="main">]</span></span><span class="main">)</span>

  <span class="keyword1" id="Finite_Automata_HF-dfa"><span class="command">lemma</span></span> dfa<span class="main">:</span> <span class="quoted"><span class="quoted">"dfa DFA"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> dfa_def DFA_def quotientI finix<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> inj_on_image_mem_iff <span class="main"><span class="main">[</span></span><span class="operator">OF</span> injh<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> UN_equiv_class_type <span class="main"><span class="main">[</span></span><span class="operator">OF</span> eqR resp<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> injh DFA_def hinv_def quotientI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">interpretation</span></span> MN<span class="main">:</span> dfa <span class="quoted">DFA</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dfa<span class="main">)</span>

  <span class="keyword1" id="Finite_Automata_HF-MyhillNerode"><span class="command">lemma</span></span> MyhillNerode<span class="main">:</span> <span class="quoted"><span class="quoted">"MyhillNerode <span class="free">L</span> <span class="free">R</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> L
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> MyhillNerode_def eqR riR finix<span class="main">)</span>

  <span class="keyword1" id="Finite_Automata_HF-R_iff"><span class="command">lemma</span></span> R_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∃</span><span class="bound">x</span><span class="main">∈</span><span class="free">L</span><span class="main">.</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span> <span class="bound">x</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">u</span> <span class="main">∈</span> <span class="free">L</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> MN_refines MyhillNerode eqR eq_equiv_class_iff
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

  <span class="keyword1" id="Finite_Automata_HF-nextl"><span class="command">lemma</span></span> nextl<span class="main">:</span> <span class="quoted"><span class="quoted">"MN.nextl <span class="main">(</span>init DFA<span class="main">)</span> <span class="free">u</span> <span class="main">=</span> <span class="free">h</span> <span class="main">(</span><span class="free">R</span> <span class="main">``</span> <span class="main">{</span><span class="free">u</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">u</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> List.rev_induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> DFA_def hinv_def injh quotientI UN_equiv_class <span class="main"><span class="main">[</span></span><span class="operator">OF</span> eqR resp<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1" id="Finite_Automata_HF-language"><span class="command">lemma</span></span> language<span class="main">:</span> <span class="quoted"><span class="quoted">"MN.language <span class="main">=</span> <span class="free">L</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
   <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">u</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∈</span> MN.language <span class="main">⟷</span> <span class="skolem">u</span> <span class="main">∈</span> <span class="free">L</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> L eqR
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> MN.language_def nextl<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> DFA_def inj_on_eq_iff <span class="main"><span class="main">[</span></span><span class="operator">OF</span> injh<span class="main"><span class="main">]</span></span> eq_equiv_class_iff <span class="main"><span class="main">[</span></span><span class="operator">OF</span> eqR<span class="main"><span class="main">]</span></span> quotientI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> equiv_def sym_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
   <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
       <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1" id="Finite_Automata_HF-card_states"><span class="command">lemma</span></span> card_states<span class="main">:</span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>states DFA<span class="main">)</span> <span class="main">=</span> card <span class="main">(</span>UNIV <span class="main">//</span> <span class="free">R</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> h
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> DFA_def bij_betw_def<span class="main">)</span> <span class="main">(</span><span class="operator">metis</span> card_image<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">theorem</span></span> MN_imp_dfa<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"MyhillNerode <span class="free">L</span> <span class="free">R</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">M</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"dfa <span class="free">M</span>"</span></span> <span class="quoted"><span class="quoted">"dfa.language <span class="free">M</span> <span class="main">=</span> <span class="free">L</span>"</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>states <span class="free">M</span><span class="main">)</span> <span class="main">=</span> card <span class="main">(</span>UNIV<span class="main">//</span><span class="free">R</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">A</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> eqR<span class="main">:</span> <span class="quoted"><span class="quoted">"equiv UNIV <span class="free">R</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> riR<span class="main">:</span> <span class="quoted"><span class="quoted">"right_invariant <span class="free">R</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> finix<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>UNIV<span class="main">//</span><span class="free">R</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> L<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">L</span> <span class="main">=</span> <span class="free">R</span><span class="main">``</span><span class="skolem">A</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> MyhillNerode_def<span class="main">)</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?n</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>UNIV<span class="main">//</span><span class="free">R</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> ex_bij_betw_finite_nat <span class="main">[</span><span class="operator">OF</span> finix<span class="main">]</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">h</span></span> <span class="keyword2"><span class="keyword">where</span></span> h<span class="main">:</span> <span class="quoted"><span class="quoted">"bij_betw <span class="skolem">h</span> <span class="main">(</span>UNIV<span class="main">//</span><span class="free">R</span><span class="main">)</span> <span class="main">(</span>hfset <span class="main">(</span>ord_of <span class="var">?n</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> bij_betw_ord_ofI <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">interpret</span></span> MN<span class="main">:</span> MyhillNerode_dfa <span class="quoted"><span class="free">L</span></span> <span class="quoted"><span class="free">R</span></span> <span class="quoted"><span class="skolem">A</span></span> <span class="quoted"><span class="quoted">"<span class="var">?n</span>"</span></span> <span class="quoted"><span class="skolem">h</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> MyhillNerode_dfa_def eqR riR L h<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> MN.language <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> that MN.dfa MN.language MN.card_states<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">corollary</span></span> MN_imp_regular<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"MyhillNerode <span class="free">L</span> <span class="free">R</span>"</span></span>  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"regular <span class="free">L</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> MN_imp_dfa <span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> <span class="keyword1"><span class="command">unfolding</span></span> regular_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">corollary</span></span> eq_app_right_finite_index_imp_dfa<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>UNIV <span class="main">//</span> eq_app_right <span class="free">L</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">M</span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"dfa <span class="free">M</span>"</span></span> <span class="quoted"><span class="quoted">"dfa.language <span class="free">M</span> <span class="main">=</span> <span class="free">L</span>"</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>states <span class="free">M</span><span class="main">)</span> <span class="main">=</span> card <span class="main">(</span>UNIV <span class="main">//</span> eq_app_right <span class="free">L</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> MN_eq_app_right MN_imp_dfa assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Step 3›</span></span>
<span class="keyword1"><span class="command">corollary</span></span> L3_1<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>UNIV <span class="main">//</span> eq_app_right <span class="free">L</span><span class="main">)</span> <span class="main">⟹</span> regular <span class="free">L</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> eq_app_right_finite_index_imp_dfa regular_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>


<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹Non-Deterministic Finite Automata›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹These NFAs may include epsilon-transitions and multiple start states.›</span></span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Basic Definitions›</span></span>

<span class="keyword1"><span class="command">record</span></span> <span class="tfree">'a</span> nfa <span class="main">=</span> states <span class="main">::</span> <span class="quoted"><span class="quoted">"hf set"</span></span>
                init   <span class="main">::</span> <span class="quoted"><span class="quoted">"hf set"</span></span>
                final  <span class="main">::</span> <span class="quoted"><span class="quoted">"hf set"</span></span>
                nxt    <span class="main">::</span> <span class="quoted"><span class="quoted">"hf <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> hf set"</span></span>
                eps    <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>hf <span class="main">*</span> hf<span class="main">)</span> set"</span></span>

<span class="keyword1"><span class="command">locale</span></span> nfa <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">M</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> nfa"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> init<span class="main">:</span> <span class="quoted"><span class="quoted">"init <span class="free">M</span> <span class="main">⊆</span> states <span class="free">M</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> final<span class="main">:</span> <span class="quoted"><span class="quoted">"final <span class="free">M</span> <span class="main">⊆</span> states <span class="free">M</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> nxt<span class="main">:</span>   <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">q</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">q</span> <span class="main">∈</span> states <span class="free">M</span> <span class="main">⟹</span> nxt <span class="free">M</span> <span class="bound">q</span> <span class="bound">x</span> <span class="main">⊆</span> states <span class="free">M</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> finite<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>states <span class="free">M</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Finite_Automata_HF-subset_states_finite"><span class="command">lemma</span></span> subset_states_finite <span class="main">[</span><span class="operator">intro</span><span class="main">,</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="main">⊆</span> states <span class="free">M</span> <span class="main">⟹</span> finite <span class="free">Q</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> finite_subset finite<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">epsclo</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"hf set <span class="main">⇒</span> hf set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">epsclo</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="main">≡</span> states <span class="free">M</span> <span class="main">∩</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">q</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">.</span> <span class="main">{</span><span class="bound">q'</span><span class="main">.</span> <span class="main">(</span><span class="bound">q</span><span class="main">,</span><span class="bound">q'</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>eps <span class="free">M</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Finite_Automata_HF-epsclo_eq_Image"><span class="command">lemma</span></span> epsclo_eq_Image<span class="main">:</span> <span class="quoted"><span class="quoted">"epsclo <span class="free">Q</span> <span class="main">=</span> states <span class="free">M</span> <span class="main">∩</span> <span class="main">(</span>eps <span class="free">M</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="free">Q</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> epsclo_def<span class="main">)</span>

<span class="keyword1" id="Finite_Automata_HF-epsclo_empty"><span class="command">lemma</span></span> epsclo_empty <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"epsclo <span class="main">{}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> epsclo_def<span class="main">)</span>

<span class="keyword1" id="Finite_Automata_HF-epsclo_idem"><span class="command">lemma</span></span> epsclo_idem <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"epsclo <span class="main">(</span>epsclo <span class="free">Q</span><span class="main">)</span> <span class="main">=</span> epsclo <span class="free">Q</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> epsclo_def<span class="main">)</span>

<span class="keyword1" id="Finite_Automata_HF-epsclo_increasing"><span class="command">lemma</span></span> epsclo_increasing<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="main">∩</span> states <span class="free">M</span> <span class="main">⊆</span> epsclo <span class="free">Q</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> epsclo_def<span class="main">)</span>

<span class="keyword1" id="Finite_Automata_HF-epsclo_Un"><span class="command">lemma</span></span> epsclo_Un <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"epsclo <span class="main">(</span><span class="free">Q1</span> <span class="main">∪</span> <span class="free">Q2</span><span class="main">)</span> <span class="main">=</span> epsclo <span class="free">Q1</span> <span class="main">∪</span> epsclo <span class="free">Q2</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> epsclo_def<span class="main">)</span>

<span class="keyword1" id="Finite_Automata_HF-epsclo_UN"><span class="command">lemma</span></span> epsclo_UN <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"epsclo <span class="main">(</span><span class="main">⋃</span><span class="bound">x</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> <span class="free">B</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">x</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> epsclo <span class="main">(</span><span class="free">B</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> epsclo_def<span class="main">)</span>

<span class="keyword1" id="Finite_Automata_HF-epsclo_subset"><span class="command">lemma</span></span> epsclo_subset <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"epsclo <span class="free">Q</span> <span class="main">⊆</span> states <span class="free">M</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> epsclo_def<span class="main">)</span>

<span class="keyword1" id="Finite_Automata_HF-epsclo_trivial"><span class="command">lemma</span></span> epsclo_trivial <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"eps <span class="free">M</span> <span class="main">⊆</span> <span class="free">Q</span> <span class="main">×</span> <span class="free">Q</span> <span class="main">⟹</span> epsclo <span class="free">Q</span> <span class="main">=</span> states <span class="free">M</span> <span class="main">∩</span> <span class="free">Q</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> epsclo_def <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> rtranclE<span class="main">)</span>

<span class="keyword1" id="Finite_Automata_HF-epsclo_mono"><span class="command">lemma</span></span> epsclo_mono<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Q'</span> <span class="main">⊆</span> <span class="free">Q</span> <span class="main">⟹</span> epsclo <span class="free">Q'</span> <span class="main">⊆</span> epsclo <span class="free">Q</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> epsclo_def<span class="main">)</span>

<span class="keyword1" id="Finite_Automata_HF-finite_epsclo"><span class="command">lemma</span></span> finite_epsclo <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>epsclo <span class="free">Q</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> epsclo_subset finite_subset finite <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="Finite_Automata_HF-finite_final"><span class="command">lemma</span></span> finite_final<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>final <span class="free">M</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> final finite_subset finite <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="Finite_Automata_HF-finite_nxt"><span class="command">lemma</span></span> finite_nxt<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">q</span> <span class="main">∈</span> states <span class="free">M</span> <span class="main">⟹</span> finite <span class="main">(</span>nxt <span class="free">M</span> <span class="free">q</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> finite_subset finite nxt<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Transition function for a given starting state and word.›</span></span>
<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">nextl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[</span>hf set<span class="main">,</span> <span class="tfree">'a</span> list<span class="main">]</span> <span class="main">⇒</span> hf set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">nextl</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="main">[]</span>     <span class="main">=</span> epsclo <span class="free"><span class="bound"><span class="entity">Q</span></span></span>"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">nextl</span> <span class="free"><span class="bound"><span class="entity">Q</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">nextl</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">q</span> <span class="main">∈</span> epsclo <span class="free"><span class="bound"><span class="entity">Q</span></span></span><span class="main">.</span> nxt <span class="free">M</span> <span class="bound">q</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">language</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list set"</span></span>  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">language</span> <span class="main">≡</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> nextl <span class="main">(</span>init <span class="free">M</span><span class="main">)</span> <span class="bound">xs</span> <span class="main">∩</span> final <span class="free">M</span> <span class="main">≠</span> <span class="main">{}</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The right language WRT a state q is the set of words that go from q to F.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">right_lang</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"hf <span class="main">⇒</span> <span class="tfree">'a</span> list set"</span></span>  <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">right_lang</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">≡</span> <span class="main">{</span><span class="bound">u</span><span class="main">.</span> nextl <span class="main">{</span><span class="free"><span class="bound"><span class="entity">q</span></span></span><span class="main">}</span> <span class="bound">u</span> <span class="main">∩</span> final <span class="free">M</span> <span class="main">≠</span> <span class="main">{}</span><span class="main">}</span>"</span></span>

<span class="keyword1" id="Finite_Automata_HF-nextl_epsclo"><span class="command">lemma</span></span> nextl_epsclo <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"nextl <span class="main">(</span>epsclo <span class="free">Q</span><span class="main">)</span> <span class="free">xs</span> <span class="main">=</span> nextl <span class="free">Q</span> <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Finite_Automata_HF-epsclo_nextl"><span class="command">lemma</span></span> epsclo_nextl <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"epsclo <span class="main">(</span>nextl <span class="free">Q</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> nextl <span class="free">Q</span> <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">Q</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Finite_Automata_HF-nextl_app"><span class="command">lemma</span></span> nextl_app<span class="main">:</span> <span class="quoted"><span class="quoted">"nextl <span class="free">Q</span> <span class="main">(</span><span class="free">xs</span><span class="main">@</span><span class="free">ys</span><span class="main">)</span> <span class="main">=</span> nextl <span class="main">(</span>nextl <span class="free">Q</span> <span class="free">xs</span><span class="main">)</span> <span class="free">ys</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">Q</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Finite_Automata_HF-nextl_snoc"><span class="command">lemma</span></span> nextl_snoc <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"nextl <span class="free">Q</span> <span class="main">(</span><span class="free">xs</span><span class="main">@</span><span class="main">[</span><span class="free">x</span><span class="main">]</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">q</span> <span class="main">∈</span> nextl <span class="free">Q</span> <span class="free">xs</span><span class="main">.</span> epsclo <span class="main">(</span>nxt <span class="free">M</span> <span class="bound">q</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nextl_app<span class="main">)</span>

<span class="keyword1" id="Finite_Automata_HF-nextl_state"><span class="command">lemma</span></span> nextl_state<span class="main">:</span> <span class="quoted"><span class="quoted">"nextl <span class="free">Q</span> <span class="free">xs</span> <span class="main">⊆</span> states <span class="free">M</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">Q</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Finite_Automata_HF-nextl_mono"><span class="command">lemma</span></span> nextl_mono<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Q'</span> <span class="main">⊆</span> <span class="free">Q</span> <span class="main">⟹</span> nextl <span class="free">Q'</span> <span class="free">u</span> <span class="main">⊆</span> nextl <span class="free">Q</span> <span class="free">u</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">u</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_induct<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> epsclo_mono<span class="main">)</span>

<span class="keyword1" id="Finite_Automata_HF-nextl_eps"><span class="command">lemma</span></span> nextl_eps<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">q</span> <span class="main">∈</span> nextl <span class="free">Q</span> <span class="free">u</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">q</span><span class="main">,</span><span class="free">q'</span><span class="main">)</span> <span class="main">∈</span> eps <span class="free">M</span> <span class="main">⟹</span> <span class="free">q'</span> <span class="main">∈</span> states <span class="free">M</span> <span class="main">⟹</span> <span class="free">q'</span> <span class="main">∈</span> nextl <span class="free">Q</span> <span class="free">u</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> rtrancl_into_rtrancl epsclo_nextl epsclo_eq_Image <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1" id="Finite_Automata_HF-finite_nextl"><span class="command">lemma</span></span> finite_nextl<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>nextl <span class="free">Q</span> <span class="free">u</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">u</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> List.rev_induct<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Finite_Automata_HF-nextl_empty"><span class="command">lemma</span></span> nextl_empty <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"nextl <span class="main">{}</span> <span class="free">xs</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Finite_Automata_HF-nextl_Un"><span class="command">lemma</span></span> nextl_Un<span class="main">:</span> <span class="quoted"><span class="quoted">"nextl <span class="main">(</span><span class="free">Q1</span> <span class="main">∪</span> <span class="free">Q2</span><span class="main">)</span> <span class="free">xs</span> <span class="main">=</span> nextl <span class="free">Q1</span> <span class="free">xs</span> <span class="main">∪</span> nextl <span class="free">Q2</span> <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">Q1</span></span> <span class="quoted"><span class="free">Q2</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Finite_Automata_HF-nextl_UN"><span class="command">lemma</span></span> nextl_UN<span class="main">:</span> <span class="quoted"><span class="quoted">"nextl <span class="main">(</span><span class="main">⋃</span><span class="bound">i</span><span class="main">∈</span><span class="free">I</span><span class="main">.</span> <span class="free">f</span> <span class="bound">i</span><span class="main">)</span> <span class="free">xs</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">i</span><span class="main">∈</span><span class="free">I</span><span class="main">.</span> nextl <span class="main">(</span><span class="free">f</span> <span class="bound">i</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">f</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹The Powerset Construction›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">Power_dfa</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> dfa"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">Power_dfa</span> <span class="main">=</span> <span class="main">⦇</span>dfa.states <span class="main">=</span> <span class="main">{</span>HF <span class="main">(</span>epsclo <span class="bound">q</span><span class="main">)</span> <span class="main">|</span> <span class="bound">q</span><span class="main">.</span> <span class="bound">q</span> <span class="main">∈</span> Pow <span class="main">(</span>states <span class="free">M</span><span class="main">)</span><span class="main">}</span><span class="main">,</span>
                     init  <span class="main">=</span> HF <span class="main">(</span>epsclo <span class="main">(</span>init <span class="free">M</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
                     final <span class="main">=</span> <span class="main">{</span>HF <span class="main">(</span>epsclo <span class="bound">Q</span><span class="main">)</span> <span class="main">|</span> <span class="bound">Q</span><span class="main">.</span> <span class="bound">Q</span> <span class="main">⊆</span> states <span class="free">M</span> <span class="main">∧</span> <span class="bound">Q</span> <span class="main">∩</span> final <span class="free">M</span> <span class="main">≠</span> <span class="main">{}</span><span class="main">}</span><span class="main">,</span>
                     nxt   <span class="main">=</span> <span class="main">λ</span><span class="bound">Q</span> <span class="bound">x</span><span class="main">.</span> HF<span class="main">(</span><span class="main">⋃</span><span class="bound">q</span> <span class="main">∈</span> epsclo <span class="main">(</span>hfset <span class="bound">Q</span><span class="main">)</span><span class="main">.</span> epsclo <span class="main">(</span>nxt <span class="free">M</span> <span class="bound">q</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">⦈</span>"</span></span>

<span class="keyword1" id="Finite_Automata_HF-states_Power_dfa"><span class="command">lemma</span></span> states_Power_dfa <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"dfa.states Power_dfa <span class="main">=</span> HF <span class="main">`</span> epsclo <span class="main">`</span> Pow <span class="main">(</span>states <span class="free">M</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Power_dfa_def<span class="main">)</span>

<span class="keyword1" id="Finite_Automata_HF-init_Power_dfa"><span class="command">lemma</span></span> init_Power_dfa <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"dfa.init Power_dfa <span class="main">=</span> HF <span class="main">(</span>epsclo <span class="main">(</span>nfa.init <span class="free">M</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Power_dfa_def<span class="main">)</span>

<span class="keyword1" id="Finite_Automata_HF-final_Power_dfa"><span class="command">lemma</span></span> final_Power_dfa <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"dfa.final Power_dfa <span class="main">=</span> <span class="main">{</span>HF <span class="main">(</span>epsclo <span class="bound">Q</span><span class="main">)</span> <span class="main">|</span> <span class="bound">Q</span><span class="main">.</span> <span class="bound">Q</span> <span class="main">⊆</span> states <span class="free">M</span> <span class="main">∧</span> <span class="bound">Q</span> <span class="main">∩</span> final <span class="free">M</span> <span class="main">≠</span> <span class="main">{}</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Power_dfa_def<span class="main">)</span>

<span class="keyword1" id="Finite_Automata_HF-nxt_Power_dfa"><span class="command">lemma</span></span> nxt_Power_dfa <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"dfa.nxt Power_dfa <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">Q</span> <span class="bound">x</span><span class="main">.</span> HF<span class="main">(</span><span class="main">⋃</span><span class="bound">q</span> <span class="main">∈</span> epsclo <span class="main">(</span>hfset <span class="bound">Q</span><span class="main">)</span><span class="main">.</span> epsclo <span class="main">(</span>nxt <span class="free">M</span> <span class="bound">q</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Power_dfa_def<span class="main">)</span>

<span class="keyword1"><span class="command">interpretation</span></span> Power<span class="main">:</span> dfa <span class="quoted">Power_dfa</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">unfold_locales</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"dfa.init Power_dfa <span class="main">∈</span> dfa.states Power_dfa"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> init<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"dfa.final Power_dfa <span class="main">⊆</span> dfa.states Power_dfa"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">q</span> <span class="skolem">a</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span> <span class="main">∈</span> dfa.states Power_dfa <span class="main">⟹</span> dfa.nxt Power_dfa <span class="skolem">q</span> <span class="skolem">a</span> <span class="main">∈</span> dfa.states Power_dfa"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> nxt<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> inj_on_image_mem_iff <span class="main"><span class="main">[</span></span><span class="operator">OF</span> inj_on_HF<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rev_finite_subset <span class="main"><span class="main">[</span></span><span class="operator">OF</span> finite<span class="main"><span class="main">]</span></span> nxt<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> Pow_iff epsclo_UN epsclo_idem epsclo_subset image_eqI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>dfa.states Power_dfa<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> finite<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">corollary</span></span> dfa_Power<span class="main">:</span> <span class="quoted"><span class="quoted">"dfa Power_dfa"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>

<span class="keyword1" id="Finite_Automata_HF-nextl_Power_dfa"><span class="command">lemma</span></span> nextl_Power_dfa<span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="free">qs</span> <span class="main">∈</span> dfa.states Power_dfa
     <span class="main">⟹</span> dfa.nextl Power_dfa <span class="free">qs</span> <span class="free">u</span> <span class="main">=</span> HF <span class="main">(</span><span class="main">⋃</span><span class="bound">q</span> <span class="main">∈</span> hfset <span class="free">qs</span><span class="main">.</span> nextl <span class="main">{</span><span class="bound">q</span><span class="main">}</span> <span class="free">u</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">u</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> List.rev_induct<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> finite_nextl inj_on_HF <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> inj_on_eq_iff<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> Int_empty_left Int_insert_left_if1 epsclo_increasing epsclo_subset subsetD singletonI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> contra_subsetD empty_subsetI epsclo_idem epsclo_mono insert_subset<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Part of Prop 4 of Jean-Marc Champarnaud, A. Khorsi and T. Paranthoën (2002)›</span></span>
<span class="keyword1" id="Finite_Automata_HF-Power_right_lang"><span class="command">lemma</span></span> Power_right_lang<span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="free">qs</span> <span class="main">∈</span> dfa.states Power_dfa <span class="main">⟹</span> Power.right_lang <span class="free">qs</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">q</span> <span class="main">∈</span> hfset <span class="free">qs</span><span class="main">.</span> right_lang <span class="bound">q</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> epsclo_increasing
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Power.right_lang_def right_lang_def nextl_Power_dfa
                  inj_on_HF <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> inj_on_eq_iff<span class="main"><span class="main">]</span></span> finite_nextl<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> Q u q1 q2<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋃</span><span class="bound">x</span><span class="main">∈</span>epsclo <span class="improper">Q</span><span class="main">.</span> nextl <span class="main">{</span><span class="bound">x</span><span class="main">}</span> <span class="improper">u</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">using</span></span> nextl_state <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The Power DFA accepts the same language as the NFA.›</span></span>
<span class="keyword1"><span class="command">theorem</span></span> Power_language <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Power.language <span class="main">=</span> language"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">u</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Power.nextl <span class="main">(</span>dfa.init Power_dfa<span class="main">)</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">=</span> HF <span class="main">(</span>nextl <span class="main">(</span>init <span class="free">M</span><span class="main">)</span> <span class="skolem">u</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">u</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> List.rev_induct<span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
        <span class="keyword1"><span class="command">using</span></span> Power.nextl.simps
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hinsert_def<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>snoc <span class="skolem">x</span> <span class="skolem">u</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> init finite_nextl nextl_state <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> subsetD<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∈</span> Power.language <span class="main">⟷</span> <span class="skolem">u</span> <span class="main">∈</span> language"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Power.language_def language_def disjoint_iff_not_equal<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> Int_iff finite_nextl hfset_HF nextl.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> epsclo_increasing subsetCE<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> epsclo_nextl nextl_state<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Every language accepted by a NFA is also accepted by a DFA.›</span></span>
<span class="keyword1"><span class="command">corollary</span></span> imp_regular<span class="main">:</span> <span class="quoted"><span class="quoted">"regular language"</span></span>
  <span class="keyword1"><span class="command">using</span></span> Power_language dfa_Power regular_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹As above, outside the locale›</span></span>
<span class="keyword1"><span class="command">corollary</span></span> nfa_imp_regular<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"nfa <span class="free">M</span>"</span></span> <span class="quoted"><span class="quoted">"nfa.language <span class="free">M</span> <span class="main">=</span> <span class="free">L</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"regular <span class="free">L</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms nfa.imp_regular <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>


<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹Closure Properties for Regular Languages›</span></span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹The Empty Language›</span></span>

<span class="keyword1"><span class="command">theorem</span></span> regular_empty<span class="main">:</span>  <span class="quoted"><span class="quoted">"regular <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> D<span class="main">:</span> dfa <span class="quoted"><span class="quoted">"<span class="main">⦇</span>dfa.states <span class="main">=</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">,</span> init <span class="main">=</span> <span class="main">0</span><span class="main">,</span> final <span class="main">=</span> <span class="main">{}</span><span class="main">,</span> nxt <span class="main">=</span> <span class="main">λ</span><span class="bound">q</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">q</span><span class="main">⦈</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> dfa_def<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"D.language <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> D.language_def<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> regular_def dfa_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹The Empty Word›</span></span>

<span class="keyword1"><span class="command">theorem</span></span> regular_nullstr<span class="main">:</span>  <span class="quoted"><span class="quoted">"regular <span class="main">{</span><span class="main">[]</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> N<span class="main">:</span> nfa <span class="quoted"><span class="quoted">"<span class="main">⦇</span>states <span class="main">=</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">,</span> init <span class="main">=</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">,</span> final <span class="main">=</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">,</span> nxt <span class="main">=</span> <span class="main">λ</span><span class="bound">q</span> <span class="bound">x</span><span class="main">.</span> <span class="main">{}</span><span class="main">,</span> eps <span class="main">=</span> <span class="main">{}</span> <span class="main">⦈</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> nfa_def<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">u</span><span class="main">.</span> <span class="main">0</span> <span class="main">∈</span> N.nextl <span class="main">{</span><span class="main">0</span><span class="main">}</span> <span class="bound">u</span> <span class="main">⟹</span> <span class="bound">u</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> list.exhaust<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"N.language <span class="main">=</span> <span class="main">{</span><span class="main">[]</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> N.language_def<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> N.imp_regular<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Single Symbol Languages›</span></span>

<span class="keyword1"><span class="command">theorem</span></span> regular_singstr<span class="main">:</span> <span class="quoted"><span class="quoted">"regular <span class="main">{</span><span class="main">[</span><span class="free">a</span><span class="main">]</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?N</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">⦇</span>states <span class="main">=</span> <span class="main">{</span><span class="main">0</span><span class="main">,</span><span class="main">1</span><span class="main">}</span><span class="main">,</span> init <span class="main">=</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span><span class="main">,</span> final <span class="main">=</span> <span class="main">{</span><span class="main">1</span><span class="main">}</span><span class="main">,</span>
             nxt <span class="main">=</span> <span class="main">λ</span><span class="bound">q</span> <span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">q</span><span class="main">=</span><span class="main">0</span> <span class="main">∧</span> <span class="bound">x</span><span class="main">=</span><span class="free">a</span> <span class="keyword1">then</span> <span class="main">{</span><span class="main">1</span><span class="main">}</span> <span class="keyword1">else</span> <span class="main">{}</span><span class="main">,</span>
             eps <span class="main">=</span> <span class="main">{}</span><span class="main">⦈</span>"</span></span>
  <span class="keyword1"><span class="command">interpret</span></span> N<span class="main">:</span> nfa <span class="var"><span class="quoted"><span class="var">?N</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> nfa_def<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">u</span><span class="main">.</span> <span class="main">1</span> <span class="main">∈</span> N.nextl <span class="main">{</span><span class="main">1</span><span class="main">}</span> <span class="bound">u</span> <span class="main">⟹</span> <span class="bound">u</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> list.exhaust<span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">u</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">1</span> <span class="main">∈</span> nfa.nextl <span class="var">?N</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span> <span class="skolem">u</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="skolem">u</span> <span class="main">=</span> <span class="main">[</span><span class="free">a</span><span class="main">]</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">u</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"N.language <span class="main">=</span> <span class="main">{</span><span class="main">[</span><span class="free">a</span><span class="main">]</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> N.language_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> N.imp_regular<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹The Complement of a Language›</span></span>

<span class="keyword1"><span class="command">theorem</span></span> regular_Compl<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> S<span class="main">:</span> <span class="quoted"><span class="quoted">"regular <span class="free">S</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"regular <span class="main">(</span><span class="main">-</span><span class="free">S</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">MS</span></span>  <span class="keyword2"><span class="keyword">where</span></span> M<span class="main">:</span> <span class="quoted"><span class="quoted">"dfa <span class="skolem">MS</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> lang<span class="main">:</span> <span class="quoted"><span class="quoted">"dfa.language <span class="skolem">MS</span> <span class="main">=</span> <span class="free">S</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> S <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> regular_def<span class="main">)</span>
  <span class="keyword1"><span class="command">interpret</span></span> ST<span class="main">:</span> dfa <span class="quoted"><span class="quoted">"<span class="main">⦇</span>dfa.states<span class="main">=</span> dfa.states <span class="skolem">MS</span><span class="main">,</span>
                     init<span class="main">=</span> dfa.init <span class="skolem">MS</span><span class="main">,</span> final<span class="main">=</span> dfa.states <span class="skolem">MS</span> <span class="main">-</span> dfa.final <span class="skolem">MS</span><span class="main">,</span>
                     nxt<span class="main">=</span> <span class="main">λ</span><span class="bound">q</span> <span class="bound">x</span><span class="main">.</span> dfa.nxt <span class="skolem">MS</span> <span class="bound">q</span> <span class="bound">x</span><span class="main">⦈</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> M
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dfa_def<span class="main">)</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">u</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ST.nextl <span class="main">(</span>dfa.init <span class="skolem">MS</span><span class="main">)</span> <span class="skolem">u</span> <span class="main">=</span> dfa.nextl <span class="skolem">MS</span> <span class="main">(</span>dfa.init <span class="skolem">MS</span><span class="main">)</span> <span class="skolem">u</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">u</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> List.rev_induct<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> dfa.nextl_snoc dfa.nextl.simps M<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∈</span> ST.language <span class="main">⟷</span> <span class="skolem">u</span> <span class="main">∉</span> dfa.language <span class="skolem">MS</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> M dfa.nextl_init_state ST.language_def dfa.language_def<span class="main">)</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> eq_L<span class="main">:</span> <span class="quoted"><span class="quoted">"ST.language <span class="main">=</span> <span class="main">-</span><span class="free">S</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> lang  <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> regular_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> exI conjI<span class="main"><span class="keyword3">,</span></span> <span class="operator">unfold_locales</span><span class="main">)</span> <span class="main">(</span><span class="operator">rule</span> eq_L<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹The Intersection and Union of Two Languages›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹By the familiar product construction›</span></span>

<span class="keyword1"><span class="command">theorem</span></span> regular_Int<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> S<span class="main">:</span> <span class="quoted"><span class="quoted">"regular <span class="free">S</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> T<span class="main">:</span> <span class="quoted"><span class="quoted">"regular <span class="free">T</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"regular <span class="main">(</span><span class="free">S</span> <span class="main">∩</span> <span class="free">T</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">MS</span></span> <span class="skolem"><span class="skolem">MT</span></span> <span class="keyword2"><span class="keyword">where</span></span> M<span class="main">:</span> <span class="quoted"><span class="quoted">"dfa <span class="skolem">MS</span>"</span></span> <span class="quoted"><span class="quoted">"dfa <span class="skolem">MT</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> lang<span class="main">:</span> <span class="quoted"><span class="quoted">"dfa.language <span class="skolem">MS</span> <span class="main">=</span> <span class="free">S</span>"</span></span> <span class="quoted"><span class="quoted">"dfa.language <span class="skolem">MT</span> <span class="main">=</span> <span class="free">T</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> S T <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> regular_def<span class="main">)</span>
  <span class="keyword1"><span class="command">interpret</span></span> ST<span class="main">:</span> dfa <span class="quoted"><span class="quoted">"<span class="main">⦇</span>dfa.states <span class="main">=</span> <span class="main">{</span><span class="main">⟨</span><span class="bound">q1</span><span class="main">,</span><span class="bound">q2</span><span class="main">⟩</span> <span class="main">|</span> <span class="bound">q1</span> <span class="bound">q2</span><span class="main">.</span> <span class="bound">q1</span> <span class="main">∈</span> dfa.states <span class="skolem">MS</span> <span class="main">∧</span> <span class="bound">q2</span> <span class="main">∈</span> dfa.states <span class="skolem">MT</span><span class="main">}</span><span class="main">,</span>
                     init       <span class="main">=</span> <span class="main">⟨</span>dfa.init <span class="skolem">MS</span><span class="main">,</span> dfa.init <span class="skolem">MT</span><span class="main">⟩</span><span class="main">,</span>
                     final      <span class="main">=</span> <span class="main">{</span><span class="main">⟨</span><span class="bound">q1</span><span class="main">,</span><span class="bound">q2</span><span class="main">⟩</span> <span class="main">|</span> <span class="bound">q1</span> <span class="bound">q2</span><span class="main">.</span> <span class="bound">q1</span> <span class="main">∈</span> dfa.final <span class="skolem">MS</span> <span class="main">∧</span> <span class="bound">q2</span> <span class="main">∈</span> dfa.final <span class="skolem">MT</span><span class="main">}</span><span class="main">,</span>
                     nxt        <span class="main">=</span> <span class="main">λ</span><span class="main">⟨</span><span class="bound">qs</span><span class="main">,</span><span class="bound">qt</span><span class="main">⟩</span> <span class="bound">x</span><span class="main">.</span> <span class="main">⟨</span>dfa.nxt <span class="skolem">MS</span> <span class="bound">qs</span> <span class="bound">x</span><span class="main">,</span> dfa.nxt <span class="skolem">MT</span> <span class="bound">qt</span> <span class="bound">x</span><span class="main">⟩</span><span class="main">⦈</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> M
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> dfa_def finite_image_set2<span class="main">)</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">u</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ST.nextl <span class="main">⟨</span>dfa.init <span class="skolem">MS</span><span class="main">,</span> dfa.init <span class="skolem">MT</span><span class="main">⟩</span> <span class="skolem">u</span> <span class="main">=</span>
         <span class="main">⟨</span>dfa.nextl <span class="skolem">MS</span> <span class="main">(</span>dfa.init <span class="skolem">MS</span><span class="main">)</span> <span class="skolem">u</span><span class="main">,</span> dfa.nextl <span class="skolem">MT</span> <span class="main">(</span>dfa.init <span class="skolem">MT</span><span class="main">)</span> <span class="skolem">u</span><span class="main">⟩</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">u</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> List.rev_induct<span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> dfa.nextl.simps M<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>snoc <span class="skolem">x</span> <span class="skolem">u</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dfa.nextl_snoc M<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∈</span> ST.language <span class="main">⟷</span> <span class="skolem">u</span> <span class="main">∈</span> dfa.language <span class="skolem">MS</span> <span class="main">∧</span> <span class="skolem">u</span> <span class="main">∈</span> dfa.language <span class="skolem">MT</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> M ST.language_def dfa.language_def dfa.finite_final<span class="main">)</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> eq_L<span class="main">:</span> <span class="quoted"><span class="quoted">"ST.language <span class="main">=</span> <span class="free">S</span> <span class="main">∩</span> <span class="free">T</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> lang
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> regular_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> exI conjI<span class="main"><span class="keyword3">,</span></span> <span class="operator">unfold_locales</span><span class="main">)</span> <span class="main">(</span><span class="operator">rule</span> eq_L<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">corollary</span></span> regular_Un<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> S<span class="main">:</span> <span class="quoted"><span class="quoted">"regular <span class="free">S</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> T<span class="main">:</span> <span class="quoted"><span class="quoted">"regular <span class="free">T</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"regular <span class="main">(</span><span class="free">S</span> <span class="main">∪</span> <span class="free">T</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> S T compl_sup double_compl regular_Compl  regular_Int <span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main"><span class="main">-</span></span></span><span class="free"><span class="free"><span class="free">S</span></span></span>"</span></span></span></span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main"><span class="main">-</span></span></span><span class="free"><span class="free"><span class="free">T</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹The Concatenation of Two Languages›</span></span>

<span class="keyword1" id="Finite_Automata_HF-Inlr_rtrancl"><span class="command">lemma</span></span> Inlr_rtrancl <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">q</span><span class="main">.</span> <span class="main">(</span>Inl <span class="bound">q</span><span class="main">,</span> Inr <span class="free">a</span><span class="main">)</span><span class="main">)</span> <span class="main">`</span> <span class="free">A</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">q</span><span class="main">.</span> <span class="main">(</span>Inl <span class="bound">q</span><span class="main">,</span> Inr <span class="free">a</span><span class="main">)</span><span class="main">)</span> <span class="main">`</span> <span class="free">A</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>=</sup></span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> rtranclE<span class="main">)</span>

<span class="keyword1"><span class="command">theorem</span></span> regular_conc<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> S<span class="main">:</span> <span class="quoted"><span class="quoted">"regular <span class="free">S</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> T<span class="main">:</span> <span class="quoted"><span class="quoted">"regular <span class="free">T</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"regular <span class="main">(</span><span class="free">S</span> <span class="main">@@</span> <span class="free">T</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">MS</span></span> <span class="skolem"><span class="skolem">MT</span></span> <span class="keyword2"><span class="keyword">where</span></span> M<span class="main">:</span> <span class="quoted"><span class="quoted">"dfa <span class="skolem">MS</span>"</span></span> <span class="quoted"><span class="quoted">"dfa <span class="skolem">MT</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> lang<span class="main">:</span> <span class="quoted"><span class="quoted">"dfa.language <span class="skolem">MS</span> <span class="main">=</span> <span class="free">S</span>"</span></span> <span class="quoted"><span class="quoted">"dfa.language <span class="skolem">MT</span> <span class="main">=</span> <span class="free">T</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> S T <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> regular_def<span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> dfa.init dfa.nxt dfa.nextl.simps dfa.nextl_snoc
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?ST</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">⦇</span>nfa.states <span class="main">=</span> Inl <span class="main">`</span> <span class="main">(</span>dfa.states <span class="skolem">MS</span><span class="main">)</span> <span class="main">∪</span> Inr <span class="main">`</span> <span class="main">(</span>dfa.states <span class="skolem">MT</span><span class="main">)</span><span class="main">,</span>
                  init  <span class="main">=</span> <span class="main">{</span>Inl <span class="main">(</span>dfa.init <span class="skolem">MS</span><span class="main">)</span><span class="main">}</span><span class="main">,</span>
                  final <span class="main">=</span> Inr <span class="main">`</span> <span class="main">(</span>dfa.final <span class="skolem">MT</span><span class="main">)</span><span class="main">,</span>
                  nxt   <span class="main">=</span> <span class="main">λ</span><span class="bound">q</span> <span class="bound">x</span><span class="main">.</span> sum_case <span class="main">(</span><span class="main">λ</span><span class="bound">qs</span><span class="main">.</span> <span class="main">{</span>Inl <span class="main">(</span>dfa.nxt <span class="skolem">MS</span> <span class="bound">qs</span> <span class="bound">x</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>
                                             <span class="main">(</span><span class="main">λ</span><span class="bound">qt</span><span class="main">.</span> <span class="main">{</span>Inr <span class="main">(</span>dfa.nxt <span class="skolem">MT</span> <span class="bound">qt</span> <span class="bound">x</span><span class="main">)</span><span class="main">}</span><span class="main">)</span> <span class="bound">q</span><span class="main">,</span>
                  eps   <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">q</span><span class="main">.</span> <span class="main">(</span>Inl <span class="bound">q</span><span class="main">,</span> Inr <span class="main">(</span>dfa.init <span class="skolem">MT</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">`</span> dfa.final <span class="skolem">MS</span><span class="main">⦈</span>"</span></span>
  <span class="keyword1"><span class="command">interpret</span></span> ST<span class="main">:</span> nfa <span class="var"><span class="quoted"><span class="var">?ST</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> M dfa.final
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nfa_def dfa.finite<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> Inl_in_eps_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">q</span> <span class="bound">Q</span><span class="main">.</span> Inl <span class="bound">q</span> <span class="main">∈</span> nfa.epsclo <span class="var">?ST</span> <span class="bound">Q</span> <span class="main">⟷</span> Inl <span class="bound">q</span> <span class="main">∈</span> <span class="bound">Q</span> <span class="main">∧</span> <span class="bound">q</span> <span class="main">∈</span> dfa.states <span class="skolem">MS</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> M dfa.finite ST.epsclo_def<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> Inr_in_eps_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">q</span> <span class="bound">Q</span><span class="main">.</span> Inr <span class="bound">q</span> <span class="main">∈</span> nfa.epsclo <span class="var">?ST</span> <span class="bound">Q</span> <span class="main">⟷</span>
           <span class="main">(</span>Inr <span class="bound">q</span> <span class="main">∈</span> <span class="bound">Q</span> <span class="main">∧</span> <span class="bound">q</span> <span class="main">∈</span> dfa.states <span class="skolem">MT</span> <span class="main">∨</span> <span class="main">(</span><span class="bound">q</span> <span class="main">=</span> dfa.init <span class="skolem">MT</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∃</span><span class="bound">qf</span> <span class="main">∈</span> dfa.final <span class="skolem">MS</span><span class="main">.</span> Inl <span class="bound">qf</span> <span class="main">∈</span> <span class="bound">Q</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> M dfa.finite ST.epsclo_def<span class="main">)</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">u</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">q</span><span class="main">.</span> Inl <span class="bound">q</span> <span class="main">∈</span> ST.nextl <span class="main">{</span>Inl <span class="main">(</span>dfa.init <span class="skolem">MS</span><span class="main">)</span><span class="main">}</span> <span class="skolem">u</span> <span class="main">⟷</span> <span class="bound">q</span> <span class="main">=</span> <span class="main">(</span>dfa.nextl <span class="skolem">MS</span> <span class="main">(</span>dfa.init <span class="skolem">MS</span><span class="main">)</span> <span class="skolem">u</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">u</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> List.rev_induct<span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> M Inl_in_eps_iff<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>snoc <span class="skolem">x</span> <span class="skolem">u</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> M dfa.nextl_init_state Inl_in_eps_iff is_hsum_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> sum_case_split<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> ST.nextl_state <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> subsetD<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> Inl_ST_iff <span class="main">=</span> this
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">u</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">q</span><span class="main">.</span> Inr <span class="bound">q</span> <span class="main">∈</span> ST.nextl <span class="main">{</span>Inl <span class="main">(</span>dfa.init <span class="skolem">MS</span><span class="main">)</span><span class="main">}</span> <span class="skolem">u</span>  <span class="main">⟷</span>
               <span class="main">(</span><span class="main">∃</span><span class="bound">uS</span> <span class="bound">uT</span><span class="main">.</span> <span class="bound">uS</span> <span class="main">∈</span> dfa.language <span class="skolem">MS</span> <span class="main">∧</span> <span class="skolem">u</span> <span class="main">=</span> <span class="bound">uS</span><span class="main">@</span><span class="bound">uT</span> <span class="main">∧</span> <span class="bound">q</span> <span class="main">=</span> dfa.nextl <span class="skolem">MT</span> <span class="main">(</span>dfa.init <span class="skolem">MT</span><span class="main">)</span> <span class="bound">uT</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">u</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> List.rev_induct<span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> M dfa.language_def Inr_in_eps_iff<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>snoc <span class="skolem">x</span> <span class="skolem">u</span><span class="main">)</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> M
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Inr_in_eps_iff<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> ST.nextl_state <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> subsetD<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">force</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> ST.nextl_state <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> subsetD<span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> dfa.language_def Inl_ST_iff<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>lifting<span class="main"><span class="main">)</span></span> append_Nil2 dfa.nextl.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> dfa.nextl_snoc<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> uS uT<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> xs<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">uT</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> rev_exhaust<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> bexI <span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"Inl <span class="main"><span class="main">(</span></span>dfa.nextl <span class="skolem"><span class="skolem">MS</span></span> <span class="main"><span class="main">(</span></span>dfa.init <span class="skolem"><span class="skolem">MS</span></span><span class="main"><span class="main">)</span></span> <span class="skolem"><span class="skolem">u</span></span><span class="main"><span class="main">)</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Inl_ST_iff<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> bexI<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> dfa.nextl_init_state<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∈</span> ST.language <span class="main">⟷</span>
               <span class="main">(</span><span class="main">∃</span><span class="bound">uS</span> <span class="bound">uT</span><span class="main">.</span> <span class="bound">uS</span> <span class="main">∈</span> dfa.language <span class="skolem">MS</span> <span class="main">∧</span> <span class="bound">uT</span> <span class="main">∈</span> dfa.language <span class="skolem">MT</span> <span class="main">∧</span> <span class="skolem">u</span> <span class="main">=</span> <span class="bound">uS</span><span class="main">@</span><span class="bound">uT</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> M ST.language_def dfa.language_def<span class="main">)</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> eq_L<span class="main">:</span> <span class="quoted"><span class="quoted">"ST.language <span class="main">=</span> <span class="free">S</span> <span class="main">@@</span> <span class="free">T</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> lang <span class="keyword1"><span class="command">unfolding</span></span> conc_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> ST.imp_regular<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Finite_Automata_HF-regular_word"><span class="command">lemma</span></span> regular_word<span class="main">:</span> <span class="quoted"><span class="quoted">"regular <span class="main">{</span><span class="free">u</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">u</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> regular_nullstr<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">x</span> <span class="skolem">l</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="skolem">x</span><span class="main">#</span><span class="skolem">l</span><span class="main">}</span> <span class="main">=</span> <span class="main">{</span><span class="main">[</span><span class="skolem">x</span><span class="main">]</span><span class="main">}</span> <span class="main">@@</span> <span class="main">{</span><span class="skolem">l</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> conc_def<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Cons.IH regular_conc regular_singstr<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹All finite sets are regular.›</span></span>
<span class="keyword1"><span class="command">theorem</span></span> regular_finite<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="free">L</span> <span class="main">⟹</span> regular <span class="free">L</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">L</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> finite.induct<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> regular_empty<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> regular_Un regular_word <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹The Kleene Star of a Language›</span></span>

<span class="keyword1"><span class="command">theorem</span></span> regular_star<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> S<span class="main">:</span> <span class="quoted"><span class="quoted">"regular <span class="free">S</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"regular <span class="main">(</span>star <span class="free">S</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">MS</span></span> <span class="keyword2"><span class="keyword">where</span></span> M<span class="main">:</span> <span class="quoted"><span class="quoted">"dfa <span class="skolem">MS</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> lang<span class="main">:</span> <span class="quoted"><span class="quoted">"dfa.language <span class="skolem">MS</span> <span class="main">=</span> <span class="free">S</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> S <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> regular_def<span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> dfa.init <span class="main">[</span><span class="operator">OF</span> M<span class="main">]</span> dfa.nextl.simps <span class="main">[</span><span class="operator">OF</span> M<span class="main">]</span> dfa.nextl_snoc <span class="main">[</span><span class="operator">OF</span> M<span class="main">]</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">q0</span></span> <span class="keyword2"><span class="keyword">where</span></span> q0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">q0</span> <span class="main">∉</span> dfa.states <span class="skolem">MS</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> dfa.finite <span class="main">[</span><span class="operator">OF</span> M<span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> hdomain_not_mem hfset_HF hmem_def<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">q0</span> <span class="main">≠</span> dfa.init <span class="skolem">MS</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> M dfa.init q0 <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">q</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">q</span> <span class="main">∈</span> dfa.states <span class="skolem">MS</span> <span class="main">⟹</span> <span class="skolem">q0</span> <span class="main">≠</span> dfa.nxt <span class="skolem">MS</span> <span class="bound">q</span> <span class="bound">x</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> M dfa.nxt q0 <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">q</span> <span class="bound">u</span><span class="main">.</span> <span class="bound">q</span> <span class="main">∈</span> dfa.states <span class="skolem">MS</span> <span class="main">⟹</span> <span class="skolem">q0</span> <span class="main">≠</span> dfa.nextl <span class="skolem">MS</span> <span class="bound">q</span> <span class="bound">u</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> M dfa.nextl_state q0 <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?ST</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">⦇</span>nfa.states <span class="main">=</span> insert <span class="skolem">q0</span> <span class="main">(</span>dfa.states <span class="skolem">MS</span><span class="main">)</span><span class="main">,</span>
                   init  <span class="main">=</span> <span class="main">{</span><span class="skolem">q0</span><span class="main">}</span><span class="main">,</span>
                   final <span class="main">=</span> <span class="main">{</span><span class="skolem">q0</span><span class="main">}</span><span class="main">,</span>
                   nxt   <span class="main">=</span> <span class="main">λ</span><span class="bound">q</span> <span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">q</span> <span class="main">∈</span> dfa.states <span class="skolem">MS</span> <span class="keyword1">then</span> <span class="main">{</span>dfa.nxt <span class="skolem">MS</span> <span class="bound">q</span> <span class="bound">x</span><span class="main">}</span> <span class="keyword1">else</span> <span class="main">{}</span><span class="main">,</span>
                   eps   <span class="main">=</span> insert <span class="main">(</span><span class="skolem">q0</span><span class="main">,</span> dfa.init <span class="skolem">MS</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">q</span><span class="main">.</span> <span class="main">(</span><span class="bound">q</span><span class="main">,</span> <span class="skolem">q0</span><span class="main">)</span><span class="main">)</span> <span class="main">`</span> <span class="main">(</span>dfa.final <span class="skolem">MS</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">⦈</span>"</span></span>
  <span class="keyword1"><span class="command">interpret</span></span> ST<span class="main">:</span> nfa <span class="var"><span class="quoted"><span class="var">?ST</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> M dfa.final
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> q0 nfa_def dfa.init dfa.finite dfa.nxt<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∈</span> <span class="main">(</span>insert <span class="main">(</span><span class="skolem">q0</span><span class="main">,</span> dfa.init <span class="skolem">MS</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">q</span><span class="main">.</span> <span class="main">(</span><span class="bound">q</span><span class="main">,</span> <span class="skolem">q0</span><span class="main">)</span><span class="main">)</span> <span class="main">`</span> dfa.final <span class="skolem">MS</span><span class="main">)</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">⟷</span>
                 <span class="main">(</span><span class="bound">x</span><span class="main">=</span><span class="bound">y</span><span class="main">)</span> <span class="main">∨</span> <span class="main">(</span><span class="bound">x</span> <span class="main">=</span> <span class="skolem">q0</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">=</span> dfa.init <span class="skolem">MS</span><span class="main">)</span> <span class="main">∨</span>
                 <span class="main">(</span><span class="bound">x</span> <span class="main">∈</span> dfa.final <span class="skolem">MS</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">∈</span> <span class="main">{</span><span class="skolem">q0</span><span class="main">,</span> dfa.init <span class="skolem">MS</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> iffI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> rtrancl_induct<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rtrancl.rtrancl_into_rtrancl<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> eps_iff<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">q</span> <span class="bound">Q</span><span class="main">.</span> <span class="bound">q</span> <span class="main">∈</span> ST.epsclo <span class="bound">Q</span> <span class="main">⟷</span>
                 <span class="bound">q</span> <span class="main">∈</span> <span class="bound">Q</span> <span class="main">∩</span> insert <span class="skolem">q0</span> <span class="main">(</span>dfa.states <span class="skolem">MS</span><span class="main">)</span> <span class="main">∨</span>
                 <span class="main">(</span><span class="bound">q</span> <span class="main">=</span> <span class="skolem">q0</span> <span class="main">∧</span> dfa.final <span class="skolem">MS</span> <span class="main">∩</span> <span class="bound">Q</span> <span class="main">≠</span> <span class="main">{}</span><span class="main">)</span> <span class="main">∨</span>
                 <span class="main">(</span><span class="bound">q</span> <span class="main">=</span> dfa.init <span class="skolem">MS</span> <span class="main">∧</span> insert <span class="skolem">q0</span> <span class="main">(</span>dfa.final <span class="skolem">MS</span><span class="main">)</span> <span class="main">∩</span> <span class="bound">Q</span> <span class="main">≠</span> <span class="main">{}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> q0 ST.epsclo_def<span class="main">)</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">u</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"dfa.nextl <span class="skolem">MS</span> <span class="main">(</span>dfa.init <span class="skolem">MS</span><span class="main">)</span> <span class="skolem">u</span> <span class="main">∈</span> ST.nextl <span class="main">{</span><span class="skolem">q0</span><span class="main">}</span> <span class="skolem">u</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">u</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> List.rev_induct<span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> M eps_iff<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>snoc <span class="skolem">x</span> <span class="skolem">u</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
        <span class="keyword1"><span class="command">using</span></span> M q0
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eps_iff<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> bexI <span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"dfa.nextl <span class="skolem"><span class="skolem">MS</span></span> <span class="main"><span class="main">(</span></span>dfa.init <span class="skolem"><span class="skolem">MS</span></span><span class="main"><span class="main">)</span></span> <span class="skolem"><span class="skolem">u</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> dfa.nextl_init_state dfa.nxt<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> dfa_in_ST <span class="main">=</span> this
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">ustar</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ustar</span> <span class="main">∈</span> star <span class="main">(</span>dfa.language <span class="skolem">MS</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">q0</span> <span class="main">∈</span> ST.nextl <span class="main">{</span><span class="skolem">q0</span><span class="main">}</span> <span class="skolem">ustar</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> star_induct<span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> eps_iff<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>append <span class="skolem">u</span> <span class="skolem">v</span><span class="main">)</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"dfa.nextl <span class="skolem">MS</span> <span class="main">(</span>dfa.init <span class="skolem">MS</span><span class="main">)</span> <span class="skolem">u</span> <span class="main">∈</span> dfa.final <span class="skolem">MS</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> M dfa.language_def<span class="main">)</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">q0</span> <span class="main">∈</span> ST.nextl <span class="main">{</span><span class="skolem">q0</span><span class="main">}</span> <span class="skolem">u</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> ST.nextl_eps dfa_in_ST<span class="main">)</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
        <span class="keyword1"><span class="command">using</span></span> append ST.nextl_mono
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ST.nextl_app<span class="main">)</span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> star_dfa_in_ST <span class="main">=</span> this
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">u</span> <span class="skolem">q</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span> <span class="main">∈</span> ST.nextl <span class="main">{</span><span class="skolem">q0</span><span class="main">}</span> <span class="skolem">u</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span>  <span class="quoted"><span class="quoted">"<span class="skolem">q</span> <span class="main">=</span> <span class="skolem">q0</span> <span class="main">∧</span> <span class="skolem">u</span><span class="main">=</span><span class="main">[]</span> <span class="main">∨</span>
                <span class="main">(</span><span class="main">∃</span><span class="bound">u1</span> <span class="bound">u2</span><span class="main">.</span> <span class="skolem">u</span> <span class="main">=</span> <span class="bound">u1</span><span class="main">@</span><span class="bound">u2</span> <span class="main">∧</span> <span class="bound">u1</span> <span class="main">∈</span> star <span class="main">(</span>dfa.language <span class="skolem">MS</span><span class="main">)</span> <span class="main">∧</span>
                  <span class="main">(</span><span class="skolem">q</span> <span class="main">∈</span> ST.epsclo <span class="main">{</span>dfa.nextl <span class="skolem">MS</span> <span class="main">(</span>dfa.init <span class="skolem">MS</span><span class="main">)</span> <span class="bound">u2</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">u</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">q</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> List.rev_induct<span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> M  dfa.init eps_iff<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>snoc <span class="skolem">x</span> <span class="skolem">u</span><span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> snoc.prems q0 M
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> dfa.language_def eps_iff
                    <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> snoc.IH<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> dfa.nextl_snoc<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> u1 u2<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="improper">u1</span><span class="main">@</span><span class="improper">u2</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="improper">u1</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="improper">u1</span><span class="main">@</span><span class="improper">u2</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="improper">u1</span><span class="main">@</span><span class="improper">u2</span><span class="main">@</span><span class="main">[</span><span class="skolem">x</span><span class="main">]</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="improper">u1</span><span class="main">@</span><span class="improper">u2</span><span class="main">@</span><span class="main">[</span><span class="skolem">x</span><span class="main">]</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> in_ST_imp <span class="main">=</span> this
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">u</span><span class="main">.</span> <span class="skolem">q0</span> <span class="main">∈</span> ST.nextl <span class="main">{</span><span class="skolem">q0</span><span class="main">}</span> <span class="bound">u</span> <span class="main">⟹</span> <span class="bound">u</span> <span class="main">∈</span> star <span class="main">(</span>dfa.language <span class="skolem">MS</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> M dfa.init dfa.language_def eps_iff <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> in_ST_imp<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> eq_L<span class="main">:</span> <span class="quoted"><span class="quoted">"ST.language <span class="main">=</span> star <span class="free">S</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> lang
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ST.language_def star_dfa_in_ST<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> ST.imp_regular<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹The Reversal of a Regular Language›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">Reverse_nfa</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> dfa <span class="main">⇒</span> <span class="tfree">'a</span> nfa"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">Reverse_nfa</span> <span class="free"><span class="bound"><span class="entity">MS</span></span></span> <span class="main">=</span> <span class="main">⦇</span>nfa.states <span class="main">=</span> dfa.states <span class="free"><span class="bound"><span class="entity">MS</span></span></span><span class="main">,</span>
                         init  <span class="main">=</span> dfa.final <span class="free"><span class="bound"><span class="entity">MS</span></span></span><span class="main">,</span>
                         final <span class="main">=</span> <span class="main">{</span>dfa.init <span class="free"><span class="bound"><span class="entity">MS</span></span></span><span class="main">}</span><span class="main">,</span>
                         nxt   <span class="main">=</span> <span class="main">λ</span><span class="bound">q</span> <span class="bound">x</span><span class="main">.</span> <span class="main">{</span><span class="bound"><span class="bound">q'</span></span> <span class="main">∈</span> dfa.states <span class="free"><span class="bound"><span class="entity">MS</span></span></span><span class="main">.</span> <span class="bound">q</span> <span class="main">=</span> dfa.nxt <span class="free"><span class="bound"><span class="entity">MS</span></span></span> <span class="bound">q'</span> <span class="bound">x</span><span class="main">}</span><span class="main">,</span>
                         eps   <span class="main">=</span> <span class="main">{}</span><span class="main">⦈</span>"</span></span>

<span class="keyword1" id="Finite_Automata_HF-states_Reverse_nfa"><span class="command">lemma</span></span> states_Reverse_nfa <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"states <span class="main">(</span>Reverse_nfa <span class="free">MS</span><span class="main">)</span> <span class="main">=</span> dfa.states <span class="free">MS</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Reverse_nfa_def<span class="main">)</span>

<span class="keyword1" id="Finite_Automata_HF-init_Reverse_nfa"><span class="command">lemma</span></span> init_Reverse_nfa <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"init <span class="main">(</span>Reverse_nfa <span class="free">MS</span><span class="main">)</span> <span class="main">=</span> dfa.final <span class="free">MS</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Reverse_nfa_def<span class="main">)</span>

<span class="keyword1" id="Finite_Automata_HF-final_Reverse_nfa"><span class="command">lemma</span></span> final_Reverse_nfa <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"final <span class="main">(</span>Reverse_nfa <span class="free">MS</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span>dfa.init <span class="free">MS</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Reverse_nfa_def<span class="main">)</span>

<span class="keyword1" id="Finite_Automata_HF-nxt_Reverse_nfa"><span class="command">lemma</span></span> nxt_Reverse_nfa <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"nxt <span class="main">(</span>Reverse_nfa <span class="free">MS</span><span class="main">)</span> <span class="free">q</span> <span class="free">x</span> <span class="main">=</span> <span class="main">{</span><span class="bound"><span class="bound">q'</span></span> <span class="main">∈</span> dfa.states <span class="free">MS</span><span class="main">.</span> <span class="free">q</span> <span class="main">=</span> dfa.nxt <span class="free">MS</span> <span class="bound">q'</span> <span class="free">x</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Reverse_nfa_def<span class="main">)</span>

<span class="keyword1" id="Finite_Automata_HF-eps_Reverse_nfa"><span class="command">lemma</span></span> eps_Reverse_nfa <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"eps <span class="main">(</span>Reverse_nfa <span class="free">MS</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Reverse_nfa_def<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span> dfa
<span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1" id="Finite_Automata_HF-nfa_Reverse_nfa"><span class="command">lemma</span></span> nfa_Reverse_nfa<span class="main">:</span> <span class="quoted"><span class="quoted">"nfa <span class="main">(</span>Reverse_nfa <span class="free">M</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> final finite<span class="main">)</span>

  <span class="keyword1" id="Finite_Automata_HF-nextl_Reverse_nfa"><span class="command">lemma</span></span> nextl_Reverse_nfa<span class="main">:</span>
    <span class="quoted"><span class="quoted">"nfa.nextl <span class="main">(</span>Reverse_nfa <span class="free">M</span><span class="main">)</span> <span class="free">Q</span> <span class="free">u</span> <span class="main">=</span> <span class="main">{</span><span class="bound"><span class="bound">q'</span></span> <span class="main">∈</span> dfa.states <span class="free">M</span><span class="main">.</span> dfa.nextl <span class="free">M</span> <span class="bound">q'</span> <span class="main">(</span>rev <span class="free">u</span><span class="main">)</span> <span class="main">∈</span> <span class="free">Q</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">interpret</span></span> NR<span class="main">:</span> nfa <span class="quoted"><span class="quoted">"Reverse_nfa <span class="free">M</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> nfa_Reverse_nfa<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">u</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_induct<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> nxt<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Part of Prop 3 of Jean-Marc Champarnaud, A. Khorsi and T. Paranthoën (2002)›</span></span>
  <span class="keyword1" id="Finite_Automata_HF-right_lang_Reverse"><span class="command">lemma</span></span> right_lang_Reverse<span class="main">:</span> <span class="quoted"><span class="quoted">"nfa.right_lang <span class="main">(</span>Reverse_nfa <span class="free">M</span><span class="main">)</span> <span class="free">q</span> <span class="main">=</span> rev <span class="main">`</span> <span class="main">(</span>dfa.left_lang <span class="free">M</span> <span class="free">q</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">interpret</span></span> NR<span class="main">:</span> nfa <span class="quoted"><span class="quoted">"Reverse_nfa <span class="free">M</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> nfa_Reverse_nfa<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> left_lang_def NR.right_lang_def nfa_Reverse_nfa nextl_Reverse_nfa<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1" id="Finite_Automata_HF-right_lang_Reverse_disjoint"><span class="command">lemma</span></span> right_lang_Reverse_disjoint<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="free">q1</span> <span class="main">≠</span> <span class="free">q2</span> <span class="main">⟹</span> nfa.right_lang <span class="main">(</span>Reverse_nfa <span class="free">M</span><span class="main">)</span> <span class="free">q1</span> <span class="main">∩</span> nfa.right_lang <span class="main">(</span>Reverse_nfa <span class="free">M</span><span class="main">)</span> <span class="free">q2</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> left_lang_def right_lang_Reverse<span class="main">)</span>

  <span class="keyword1" id="Finite_Automata_HF-epsclo_Reverse_nfa"><span class="command">lemma</span></span> epsclo_Reverse_nfa <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"nfa.epsclo <span class="main">(</span>Reverse_nfa <span class="free">M</span><span class="main">)</span> <span class="free">Q</span> <span class="main">=</span> <span class="free">Q</span> <span class="main">∩</span> dfa.states <span class="free">M</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> nfa.epsclo_def nfa_Reverse_nfa<span class="main">)</span>

  <span class="keyword1"><span class="command">theorem</span></span> language_Reverse_nfa <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"nfa.language <span class="main">(</span>Reverse_nfa <span class="free">M</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>rev <span class="main">`</span> dfa.language <span class="free">M</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">interpret</span></span> NR<span class="main">:</span> nfa <span class="quoted"><span class="quoted">"Reverse_nfa <span class="free">M</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> nfa_Reverse_nfa<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"NR.language <span class="main">=</span> <span class="main">{</span><span class="bound">u</span><span class="main">.</span> rev <span class="bound">u</span> <span class="main">∈</span> dfa.language <span class="free">M</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> set_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">u</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">Q</span> <span class="bound">q'</span><span class="main">.</span> <span class="bound">q'</span> <span class="main">∈</span> dfa.states <span class="free">M</span> <span class="main">⟹</span>
                   <span class="bound">q'</span> <span class="main">∈</span> NR.nextl <span class="bound">Q</span> <span class="skolem">u</span> <span class="main">⟷</span> dfa.nextl <span class="free">M</span> <span class="bound">q'</span> <span class="main">(</span>rev <span class="skolem">u</span><span class="main">)</span> <span class="main">∈</span> <span class="bound">Q</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">u</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> List.rev_induct<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> nxt<span class="main">)</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">u</span> <span class="main">∈</span> nfa.language <span class="main">(</span>Reverse_nfa <span class="free">M</span><span class="main">)</span> <span class="main">⟷</span> rev <span class="skolem">u</span> <span class="main">∈</span> language"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> NR.language_def language_def<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> language_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">corollary</span></span> regular_Reverse<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> S<span class="main">:</span> <span class="quoted"><span class="quoted">"regular <span class="free">S</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"regular <span class="main">(</span>rev <span class="main">`</span> <span class="free">S</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">MS</span></span> <span class="keyword2"><span class="keyword">where</span></span> MS<span class="main">:</span> <span class="quoted"><span class="quoted">"dfa <span class="skolem">MS</span>"</span></span> <span class="quoted"><span class="quoted">"dfa.language <span class="skolem">MS</span> <span class="main">=</span> <span class="free">S</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> S <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> regular_def<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> dfa <span class="quoted"><span class="quoted">"<span class="skolem">MS</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> nfa_Reverse_nfa nfa_imp_regular language_Reverse_nfa MS
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹All regular expressions yield regular languages.›</span></span>
<span class="keyword1"><span class="command">theorem</span></span> regular_lang<span class="main">:</span> <span class="quoted"><span class="quoted">"regular <span class="main">(</span>lang <span class="free">r</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">r</span></span><span class="main">)</span>
     <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> regular_empty regular_nullstr regular_singstr regular_Un regular_conc regular_star<span class="main">)</span>


<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹Brzozowski's Minimization Algorithm›</span></span>

<span class="keyword1"><span class="command">context</span></span> dfa
  <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹More about the relation <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">eq_app_right</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

  <span class="keyword1" id="Finite_Automata_HF-left_eq_app_right"><span class="command">lemma</span></span> left_eq_app_right<span class="main">:</span>
       <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">u</span> <span class="main">∈</span> left_lang <span class="free">q</span><span class="main">;</span> <span class="free">v</span> <span class="main">∈</span> left_lang <span class="free">q</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">u</span><span class="main">,</span><span class="free">v</span><span class="main">)</span> <span class="main">∈</span> eq_app_right language"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq_app_right_def left_lang_def language_def nextl_app<span class="main">)</span>

  <span class="keyword1" id="Finite_Automata_HF-eq_app_right_class_eq"><span class="command">lemma</span></span> eq_app_right_class_eq<span class="main">:</span>
    <span class="quoted"><span class="quoted">"UNIV <span class="main">//</span> eq_app_right language <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">q</span><span class="main">.</span> eq_app_right language <span class="main">``</span> <span class="main">{</span>path_to <span class="bound">q</span><span class="main">}</span><span class="main">)</span> <span class="main">`</span> accessible"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">u</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"eq_app_right language <span class="main">``</span> <span class="main">{</span><span class="skolem">u</span><span class="main">}</span> <span class="main">∈</span> <span class="main">(</span><span class="main">λ</span><span class="bound">q</span><span class="main">.</span> eq_app_right language <span class="main">``</span> <span class="main">{</span>path_to <span class="bound">q</span><span class="main">}</span><span class="main">)</span> <span class="main">`</span> accessible"</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> image_eqI<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> equiv_class_eq <span class="main"><span class="main">[</span></span><span class="operator">OF</span> equiv_eq_app_right<span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> left_eq_app_right <span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ path_to_left_lang<span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> left_lang_def accessible_def<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> quotient_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1" id="Finite_Automata_HF-inj_right_lang_imp_eq_app_right_index"><span class="command">lemma</span></span> inj_right_lang_imp_eq_app_right_index<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"inj_on right_lang <span class="main">(</span>dfa.states <span class="free">M</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"bij_betw <span class="main">(</span><span class="main">λ</span><span class="bound">q</span><span class="main">.</span> eq_app_right language <span class="main">``</span> <span class="main">{</span>path_to <span class="bound">q</span><span class="main">}</span><span class="main">)</span>
                      accessible  <span class="main">(</span>UNIV <span class="main">//</span> eq_app_right language<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> bij_betw_def inj_on_def eq_app_right_class_eq<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> eq_equiv_class <span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ equiv_eq_app_right<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> nextl_path_to eq_app_right_def language_def right_lang_def
                 nextl_app accessible_imp_states<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">min_states</span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">min_states</span> <span class="main">≡</span> card <span class="main">(</span>UNIV <span class="main">//</span> eq_app_right language<span class="main">)</span>"</span></span>

  <span class="keyword1" id="Finite_Automata_HF-minimal_imp_index_eq_app_right"><span class="command">lemma</span></span> minimal_imp_index_eq_app_right<span class="main">:</span>
    <span class="quoted"><span class="quoted">"minimal <span class="main">⟹</span> card <span class="main">(</span>dfa.states <span class="free">M</span><span class="main">)</span> <span class="main">=</span> min_states"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> min_states_def minimal_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> bij_betw_def card_image inj_right_lang_imp_eq_app_right_index<span class="main">)</span>

  <span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹A minimal machine has a minimal number of states, compared with any other machine
        for the same language.›</span></span>
  <span class="keyword1"><span class="command">theorem</span></span> minimal_imp_card_states_le<span class="main">:</span>
       <span class="quoted"><span class="quoted">"<span class="main">⟦</span>minimal<span class="main">;</span> dfa <span class="free">M'</span><span class="main">;</span> dfa.language <span class="free">M'</span> <span class="main">=</span> language<span class="main">⟧</span>
        <span class="main">⟹</span> card <span class="main">(</span>dfa.states <span class="free">M</span><span class="main">)</span> <span class="main">≤</span> card <span class="main">(</span>dfa.states <span class="free">M'</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> minimal_imp_index_eq_app_right dfa.index_eq_app_right_lower min_states_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">index_f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list set <span class="main">⇒</span> hf"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">index_f</span> <span class="main">≡</span> <span class="keyword1">SOME</span> <span class="bound">h</span><span class="main">.</span> bij_betw <span class="bound">h</span> <span class="main">(</span>UNIV <span class="main">//</span> eq_app_right language<span class="main">)</span> <span class="main">(</span>hfset <span class="main">(</span>ord_of min_states<span class="main">)</span><span class="main">)</span>"</span></span>

  <span class="keyword1" id="Finite_Automata_HF-index_f"><span class="command">lemma</span></span> index_f<span class="main">:</span> <span class="quoted"><span class="quoted">"bij_betw index_f <span class="main">(</span>UNIV <span class="main">//</span> eq_app_right language<span class="main">)</span> <span class="main">(</span>hfset <span class="main">(</span>ord_of min_states<span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">h</span><span class="main">.</span> bij_betw <span class="bound">h</span> <span class="main">(</span>UNIV <span class="main">//</span> eq_app_right language<span class="main">)</span> <span class="main">(</span>hfset <span class="main">(</span>ord_of min_states<span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> min_states_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> L2_3 MN_eq_nextl ex_bij_betw_finite_nat bij_betw_ord_ofI<span class="main">)</span>
   <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> index_f_def  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> someI_ex<span class="main">)</span>
   <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">interpretation</span></span> Canon<span class="main">:</span>
      MyhillNerode_dfa <span class="quoted">language</span> <span class="quoted"><span class="quoted">"eq_app_right language"</span></span>
                       <span class="quoted">language</span>
                       <span class="quoted">min_states</span> <span class="quoted">index_f</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> MyhillNerode_dfa_def equiv_eq_app_right right_invariant_eq_app_right
                  index_f eq_app_right_eq<span class="main">)</span>

  <span class="keyword1"><span class="command">interpretation</span></span> MN<span class="main">:</span> dfa <span class="quoted">Canon.DFA</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fact</span> Canon.dfa<span class="main">)</span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">iso</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"hf <span class="main">⇒</span> hf"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">iso</span> <span class="main">≡</span> index_f <span class="keyword1">o</span> <span class="main">(</span><span class="main">λ</span><span class="bound">q</span><span class="main">.</span> eq_app_right language <span class="main">``</span> <span class="main">{</span>path_to <span class="bound">q</span><span class="main">}</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">theorem</span></span> minimal_imp_isomorphic_to_canonical<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted">minimal</span>
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"dfa_isomorphism <span class="free">M</span> Canon.DFA iso"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Canon.DFA_def<span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"bij_betw iso accessible <span class="main">(</span>hfset <span class="main">(</span>ord_of min_states<span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> assms bij_betw_trans index_f inj_right_lang_imp_eq_app_right_index
        <span class="keyword1"><span class="command">unfolding</span></span> iso_def minimal_def
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bij_betw iso <span class="main">(</span>dfa.states <span class="free">M</span><span class="main">)</span> <span class="main">(</span>index_f <span class="main">`</span> <span class="main">(</span>UNIV <span class="main">//</span> eq_app_right language<span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> assms bij_betw_def index_f minimal_def<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"eq_app_right language <span class="main">``</span> <span class="main">{</span>path_to <span class="main">(</span>dfa.init <span class="free">M</span><span class="main">)</span><span class="main">}</span> <span class="main">=</span> eq_app_right language <span class="main">``</span> <span class="main">{</span><span class="main">[]</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> equiv_class_eq <span class="main"><span class="main">[</span></span><span class="operator">OF</span> equiv_eq_app_right<span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>path_to <span class="main">(</span>dfa.init <span class="free">M</span><span class="main">)</span><span class="main">,</span> <span class="main">[]</span><span class="main">)</span> <span class="main">∈</span> eq_app_right language"</span></span>
        <span class="keyword1"><span class="command">using</span></span> nextl_path_to assms
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> minimal_def eq_app_right_def language_def nextl_app<span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"iso <span class="main">(</span>dfa.init <span class="free">M</span><span class="main">)</span> <span class="main">=</span> index_f <span class="main">(</span>eq_app_right language <span class="main">``</span> <span class="main">{</span><span class="main">[]</span><span class="main">}</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> iso_def<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">u</span><span class="main">.</span> eq_app_right language <span class="main">``</span> <span class="main">{</span>path_to <span class="bound">u</span><span class="main">}</span><span class="main">)</span> <span class="main">`</span> dfa.final <span class="free">M</span> <span class="main">=</span>
            <span class="main">(</span><span class="main">λ</span><span class="bound">l</span><span class="main">.</span> eq_app_right language <span class="main">``</span> <span class="main">{</span><span class="bound">l</span><span class="main">}</span><span class="main">)</span> <span class="main">`</span> language"</span></span>
        <span class="keyword1"><span class="command">using</span></span> assms final nextl_path_to nextl_app
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> dfa_isomorphism_def language_def minimal_def<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> eq_app_right_def
                    <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rev_image_eqI equiv_class_eq <span class="main"><span class="main">[</span></span><span class="operator">OF</span> equiv_eq_app_right<span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
      <span class="keyword1"><span class="command">from</span></span> this <span class="main">[</span><span class="operator">THEN</span> image_eq_imp_comp <span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> h <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted">index_f</span><span class="main"><span class="main">]</span></span><span class="main">]</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"iso <span class="main">`</span> dfa.final <span class="free">M</span> <span class="main">=</span> <span class="main">{</span>index_f <span class="main">(</span>eq_app_right language <span class="main">``</span> <span class="main">{</span><span class="bound">u</span><span class="main">}</span><span class="main">)</span> <span class="main">|</span><span class="bound">u</span><span class="main">.</span> <span class="bound">u</span> <span class="main">∈</span> language<span class="main">}</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> iso_def o_def Setcompr_eq_image<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword1"><span class="command">have</span></span> nxt<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">q</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">q</span> <span class="main">∈</span> dfa.states <span class="free">M</span> <span class="main">⟹</span>
                       eq_app_right language <span class="main">``</span> <span class="main">{</span>path_to <span class="main">(</span>dfa.nxt <span class="free">M</span> <span class="bound">q</span> <span class="bound">x</span><span class="main">)</span><span class="main">}</span> <span class="main">=</span>
                       eq_app_right language <span class="main">``</span> <span class="main">{</span>path_to <span class="bound">q</span> <span class="main">@</span> <span class="main">[</span><span class="bound">x</span><span class="main">]</span><span class="main">}</span>"</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> equiv_class_eq <span class="main"><span class="main">[</span></span><span class="operator">OF</span> equiv_eq_app_right<span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command">using</span></span> assms nextl_path_to nxt nextl_app
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> minimal_def nextl_path_to eq_app_right_def language_def<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">q</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">q</span> <span class="main">∈</span> dfa.states <span class="free">M</span> <span class="main">⟹</span>
           iso <span class="main">(</span>dfa.nxt <span class="free">M</span> <span class="bound">q</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span>
           index_f
            <span class="main">(</span><span class="main">⋃</span><span class="bound">u</span><span class="main">∈</span>MyhillNerode_dfa.hinv <span class="main">(</span>eq_app_right language<span class="main">)</span> index_f <span class="main">(</span>iso <span class="bound">q</span><span class="main">)</span><span class="main">.</span>
                eq_app_right language <span class="main">``</span> <span class="main">{</span><span class="bound">u</span> <span class="main">@</span> <span class="main">[</span><span class="bound">x</span><span class="main">]</span><span class="main">}</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> iso_def Canon.injh Canon.hinv_def quotientI Canon.resp nxt
                      UN_equiv_class <span class="main"><span class="main">[</span></span><span class="operator">OF</span> equiv_eq_app_right<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1" id="Finite_Automata_HF-states_PR"><span class="command">lemma</span></span> states_PR <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
       <span class="quoted"><span class="quoted">"dfa.states <span class="main">(</span>nfa.Power_dfa <span class="main">(</span>Reverse_nfa <span class="free">M</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> HF <span class="main">`</span> Pow <span class="main">(</span>dfa.states <span class="free">M</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> set_eqI<span class="main">)</span>
       <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> nfa.states_Power_dfa nfa_Reverse_nfa image_iff Bex_def<span class="main">)</span>

  <span class="keyword1" id="Finite_Automata_HF-inj_on_right_lang_PR"><span class="command">lemma</span></span> inj_on_right_lang_PR<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"dfa.states <span class="free">M</span> <span class="main">=</span> accessible"</span></span>
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"inj_on <span class="main">(</span>dfa.right_lang <span class="main">(</span>nfa.Power_dfa <span class="main">(</span>Reverse_nfa <span class="free">M</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
                    <span class="main">(</span>dfa.states <span class="main">(</span>nfa.Power_dfa <span class="main">(</span>Reverse_nfa <span class="free">M</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> inj_onI<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">q1</span> <span class="skolem">q2</span>
    <span class="keyword3"><span class="command">assume</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">q1</span> <span class="main">∈</span> dfa.states <span class="main">(</span>nfa.Power_dfa <span class="main">(</span>Reverse_nfa <span class="free">M</span><span class="main">)</span><span class="main">)</span>"</span></span>
              <span class="quoted"><span class="quoted">"<span class="skolem">q2</span> <span class="main">∈</span> dfa.states <span class="main">(</span>nfa.Power_dfa <span class="main">(</span>Reverse_nfa <span class="free">M</span><span class="main">)</span><span class="main">)</span>"</span></span>
              <span class="quoted"><span class="quoted">"dfa.right_lang <span class="main">(</span>nfa.Power_dfa <span class="main">(</span>Reverse_nfa <span class="free">M</span><span class="main">)</span><span class="main">)</span> <span class="skolem">q1</span> <span class="main">=</span>
               dfa.right_lang <span class="main">(</span>nfa.Power_dfa <span class="main">(</span>Reverse_nfa <span class="free">M</span><span class="main">)</span><span class="main">)</span> <span class="skolem">q2</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"hfset <span class="skolem">q1</span> <span class="main">⊆</span> accessible <span class="main">∧</span> hfset <span class="skolem">q2</span> <span class="main">⊆</span> accessible"</span></span>
      <span class="keyword1"><span class="command">using</span></span> assms rev_finite_subset <span class="main">[</span><span class="operator">OF</span> finite<span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
    <span class="keyword1"><span class="command">with</span></span> * <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">q1</span> <span class="main">=</span> <span class="skolem">q2</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nfa_Reverse_nfa nfa.Power_right_lang right_lang_Reverse
                       image_UN <span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> inj_image_eq_iff<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> HF_hfset le_sup_iff left_lang_UN<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">APR</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'x</span> dfa <span class="main">⇒</span> <span class="tfree">'x</span> dfa"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">APR</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">≡</span> dfa.Accessible_dfa <span class="main">(</span>nfa.Power_dfa <span class="main">(</span>Reverse_nfa <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">theorem</span></span> minimal_APR<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"dfa.states <span class="free">M</span> <span class="main">=</span> accessible"</span></span>
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"dfa.minimal <span class="main">(</span>APR <span class="free">M</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command">have</span></span> PR<span class="main">:</span> <span class="quoted"><span class="quoted">"dfa <span class="main">(</span>APR <span class="free">M</span><span class="main">)</span>"</span></span>
               <span class="quoted"><span class="quoted">"dfa <span class="main">(</span>nfa.Power_dfa <span class="main">(</span>Reverse_nfa <span class="free">M</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> dfa.dfa_Accessible nfa.dfa_Power nfa_Reverse_nfa<span class="main">)</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dfa.minimal_def dfa.states_Accessible_dfa dfa.Accessible_accessible<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inj_on_def dfa.Accessible_right_lang_eq<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">meson</span> assms dfa.accessible_imp_states inj_onD inj_on_right_lang_PR<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">Brzozowski</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> dfa"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">Brzozowski</span> <span class="main">≡</span> APR <span class="main">(</span>APR <span class="free">M</span><span class="main">)</span>"</span></span>

  <span class="keyword1" id="Finite_Automata_HF-dfa_Brzozowski"><span class="command">lemma</span></span> dfa_Brzozowski<span class="main">:</span> <span class="quoted"><span class="quoted">"dfa Brzozowski"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Brzozowski_def dfa.dfa_Accessible dfa.nfa_Reverse_nfa
                  nfa.dfa_Power nfa_Reverse_nfa<span class="main">)</span>

  <span class="keyword1"><span class="command">theorem</span></span> language_Brzozowski<span class="main">:</span> <span class="quoted"><span class="quoted">"dfa.language Brzozowski <span class="main">=</span> language"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Brzozowski_def dfa.Accessible_language nfa.Power_language
          dfa.dfa_Accessible dfa.nfa_Reverse_nfa nfa.dfa_Power nfa_Reverse_nfa
          dfa.language_Reverse_nfa image_image<span class="main">)</span>

  <span class="keyword1"><span class="command">theorem</span></span> minimal_Brzozowski<span class="main">:</span> <span class="quoted"><span class="quoted">"dfa.minimal Brzozowski"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Brzozowski_def
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> dfa.minimal_APR<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"dfa <span class="main">(</span>APR <span class="free">M</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dfa.dfa_Accessible nfa.dfa_Power nfa_Reverse_nfa<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"dfa.states <span class="main">(</span>APR <span class="free">M</span><span class="main">)</span> <span class="main">=</span> dfa.accessible <span class="main">(</span>APR <span class="free">M</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dfa.Accessible_accessible dfa.states_Accessible_dfa nfa.dfa_Power nfa_Reverse_nfa<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Finite_Automata_HF-index_f_cong"><span class="command">lemma</span></span> index_f_cong<span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">⟦</span>dfa.language <span class="free">M</span> <span class="main">=</span> dfa.language <span class="free">N</span><span class="main">;</span> dfa <span class="free">M</span><span class="main">;</span> dfa <span class="free">N</span><span class="main">⟧</span> <span class="main">⟹</span> dfa.index_f <span class="free">M</span> <span class="main">=</span> dfa.index_f <span class="free">N</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dfa.index_f_def dfa.min_states_def<span class="main">)</span>

<span class="keyword1"><span class="command">theorem</span></span> minimal_imp_isomorphic<span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">⟦</span>dfa.language <span class="free">M</span> <span class="main">=</span> dfa.language <span class="free">N</span><span class="main">;</span> dfa.minimal <span class="free">M</span><span class="main">;</span> dfa.minimal <span class="free">N</span><span class="main">;</span> dfa <span class="free">M</span><span class="main">;</span> dfa <span class="free">N</span><span class="main">⟧</span>
      <span class="main">⟹</span> <span class="main">∃</span><span class="bound">h</span><span class="main">.</span> dfa_isomorphism <span class="free">M</span> <span class="free">N</span> <span class="bound">h</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> dfa_isomorphism.sym dfa_isomorphism.trans
            dfa.minimal_imp_isomorphic_to_canonical index_f_cong<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

</pre>
</div>