<div id="Exc_Nres_Monad">
<div class="head">
<h1>Theory Exc_Nres_Monad</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Exception Monad for Refine-Monadic›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Exc_Nres_Monad
<span class="keyword2"><span class="keyword">imports</span></span> <span class="quoted">"<a href="../Refine_Imperative_HOL/IICF.html">Refine_Imperative_HOL.IICF</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(*
  TODO:
    * Integrate with sepref --- currently, it's "integrated" by providing 
        some support to translate the program in to a plain nres monad before 
        sepref is invoked.
    * Move to Refine_Monadic.
*)</span>
  
<span class="keyword1"><span class="command">declare</span></span> TrueI<span class="main">[</span><span class="operator">refine_vcg</span><span class="main">]</span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'e</span><span class="main">,</span><span class="tfree">'a</span><span class="main">)</span> enres <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'e</span> <span class="main">+</span> <span class="tfree">'a</span><span class="main">)</span> nres"</span></span>

<span class="keyword1"><span class="command">named_theorems</span></span> enres_unfolds <span class="quoted">‹Unfolding theorems from enres to nres›</span>


<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">enres_unfolds</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">ERETURN</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≡</span> RETURN <span class="main">(</span>Inr <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ebind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'e</span><span class="main">,</span><span class="tfree">'a</span><span class="main">)</span> enres <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'e</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span> enres<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'e</span><span class="main">,</span><span class="tfree">'b</span><span class="main">)</span> enres"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">enres_unfolds</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">ebind</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    <span class="bound">x</span> <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">;</span>
    <span class="keyword1">case</span> <span class="bound">x</span> <span class="keyword1">of</span> Inl <span class="bound">e</span> <span class="main">⇒</span> RETURN <span class="main">(</span>Inl <span class="bound">e</span><span class="main">)</span> <span class="main">|</span> Inr <span class="bound">x</span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">x</span>
  <span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">enres_unfolds</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">THROW</span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">==</span> RETURN <span class="main">(</span>Inl <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">enres_unfolds</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">ESPEC</span> <span class="free"><span class="bound"><span class="entity">Φ</span></span></span> <span class="free"><span class="bound"><span class="entity">Ψ</span></span></span> <span class="main">≡</span> SPEC <span class="main">(</span><span class="main">λ</span>Inl <span class="bound">e</span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">Φ</span></span></span> <span class="bound">e</span> <span class="main">|</span> Inr <span class="bound">r</span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">Ψ</span></span></span> <span class="bound">r</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">enres_unfolds</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">CATCH</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span> <span class="bound">r</span><span class="main">←</span><span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">;</span> <span class="keyword1">case</span> <span class="bound">r</span> <span class="keyword1">of</span> Inl <span class="bound">e</span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="bound">e</span> <span class="main">|</span> Inr <span class="bound">r</span> <span class="main">⇒</span> RETURN <span class="main">(</span>Inr <span class="bound">r</span><span class="main">)</span> <span class="main">}</span>"</span></span>



<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>do_notation<span class="main">)</span> <span class="entity">bind_doE</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">bind_doE</span> <span class="main">≡</span> ebind"</span></span>

<span class="keyword1"><span class="command">notation</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">output</span></span><span class="main">)</span> bind_doE <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">⤜</span>"</span> 54<span class="main">)</span>
<span class="keyword1"><span class="command">notation</span></span> <span class="main">(</span>ASCII <span class="keyword2"><span class="keyword">output</span></span><span class="main">)</span> bind_doE <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">&gt;&gt;=</span>"</span> 54<span class="main">)</span>


<span class="keyword1"><span class="command">nonterminal</span></span> doE_binds <span class="keyword2"><span class="keyword">and</span></span> doE_bind
<span class="keyword1"><span class="command">syntax</span></span>
  <span class="quoted">"_doE_block"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"doE_binds <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">doE</span> <span class="keyword1">{</span><span class="keyword3">//</span><span class="keyword3">(2</span>  _<span class="keyword3">)</span><span class="keyword3">//</span><span class="keyword1">}</span>"</span> <span class="main">[</span>12<span class="main">]</span> 62<span class="main">)</span>
  <span class="quoted">"_doE_bind"</span>  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[</span>pttrn<span class="main">,</span> <span class="tfree">'a</span><span class="main">]</span> <span class="main">⇒</span> doE_bind"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword3">(2</span>_ <span class="keyword1">←</span><span class="keyword3">/ </span>_<span class="keyword3">)</span>"</span> 13<span class="main">)</span>
  <span class="quoted">"_doE_let"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[</span>pttrn<span class="main">,</span> <span class="tfree">'a</span><span class="main">]</span> <span class="main">⇒</span> doE_bind"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword3">(2</span><span class="keyword1">let</span> _ <span class="keyword1">=</span><span class="keyword3">/ </span>_<span class="keyword3">)</span>"</span> <span class="main">[</span>1000<span class="main">,</span> 13<span class="main">]</span> 13<span class="main">)</span>
  <span class="quoted">"_doE_then"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> doE_bind"</span></span> <span class="main">(</span><span class="quoted">"_"</span> <span class="main">[</span>14<span class="main">]</span> 13<span class="main">)</span>
  <span class="quoted">"_doE_final"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> doE_binds"</span></span> <span class="main">(</span><span class="quoted">"_"</span><span class="main">)</span>
  <span class="quoted">"_doE_cons"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[</span>doE_bind<span class="main">,</span> doE_binds<span class="main">]</span> <span class="main">⇒</span> doE_binds"</span></span> <span class="main">(</span><span class="quoted">"_<span class="keyword1">;</span><span class="keyword3">//</span>_"</span> <span class="main">[</span>13<span class="main">,</span> 12<span class="main">]</span> 12<span class="main">)</span>
  <span class="quoted">"_thenM"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">]</span> <span class="main">⇒</span> <span class="tfree">'c</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">⪢</span>"</span> 54<span class="main">)</span>

<span class="keyword1"><span class="command">syntax</span></span> <span class="main">(</span>ASCII<span class="main">)</span>
  <span class="quoted">"_doE_bind"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[</span>pttrn<span class="main">,</span> <span class="tfree">'a</span><span class="main">]</span> <span class="main">⇒</span> doE_bind"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword3">(2</span>_ <span class="keyword1">&lt;-</span><span class="keyword3">/ </span>_<span class="keyword3">)</span>"</span> 13<span class="main">)</span>
  <span class="quoted">"_thenM"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">]</span> <span class="main">⇒</span> <span class="tfree">'c</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixr</span></span> <span class="quoted">"<span class="keyword1">&gt;&gt;</span>"</span> 54<span class="main">)</span>

<span class="keyword1"><span class="command">translations</span></span>
  <span class="quoted">"_doE_block <span class="main">(</span>_doE_cons <span class="main">(</span>_doE_then <span class="free">t</span><span class="main">)</span> <span class="main">(</span>_doE_final <span class="free">e</span><span class="main">)</span><span class="main">)</span>"</span>
    <span class="main">⇌</span> <span class="quoted">"<span class="keyword1">CONST</span> bind_doE <span class="free">t</span> <span class="main">(</span><span class="main">λ</span><span class="main">_</span><span class="main">.</span> <span class="free">e</span><span class="main">)</span>"</span>
  <span class="quoted">"_doE_block <span class="main">(</span>_doE_cons <span class="main">(</span>_doE_bind <span class="free">p</span> <span class="free">t</span><span class="main">)</span> <span class="main">(</span>_doE_final <span class="free">e</span><span class="main">)</span><span class="main">)</span>"</span>
    <span class="main">⇌</span> <span class="quoted">"<span class="keyword1">CONST</span> bind_doE <span class="free">t</span> <span class="main">(</span><span class="main">λ</span><span class="free">p</span><span class="main">.</span> <span class="free">e</span><span class="main">)</span>"</span>
  <span class="quoted">"_doE_block <span class="main">(</span>_doE_cons <span class="main">(</span>_doE_let <span class="free">p</span> <span class="free">t</span><span class="main">)</span> <span class="free">bs</span><span class="main">)</span>"</span>
    <span class="main">⇌</span> <span class="quoted">"<span class="keyword1">let</span> <span class="free">p</span> <span class="main">=</span> <span class="free">t</span> <span class="keyword1">in</span> _doE_block <span class="free">bs</span>"</span>
  <span class="quoted">"_doE_block <span class="main">(</span>_doE_cons <span class="free">b</span> <span class="main">(</span>_doE_cons <span class="free">c</span> <span class="free">cs</span><span class="main">)</span><span class="main">)</span>"</span>
    <span class="main">⇌</span> <span class="quoted">"_doE_block <span class="main">(</span>_doE_cons <span class="free">b</span> <span class="main">(</span>_doE_final <span class="main">(</span>_doE_block <span class="main">(</span>_doE_cons <span class="free">c</span> <span class="free">cs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span>
  <span class="quoted">"_doE_cons <span class="main">(</span>_doE_let <span class="free">p</span> <span class="free">t</span><span class="main">)</span> <span class="main">(</span>_doE_final <span class="free">s</span><span class="main">)</span>"</span>
    <span class="main">⇌</span> <span class="quoted">"_doE_final <span class="main">(</span><span class="keyword1">let</span> <span class="free">p</span> <span class="main">=</span> <span class="free">t</span> <span class="keyword1">in</span> <span class="free">s</span><span class="main">)</span>"</span>
  <span class="quoted">"_doE_block <span class="main">(</span>_doE_final <span class="free">e</span><span class="main">)</span>"</span> <span class="main">⇀</span> <span class="quoted">"<span class="free">e</span>"</span>
  <span class="quoted">"<span class="main">(</span><span class="free">m</span> <span class="main">⪢</span> <span class="free">n</span><span class="main">)</span>"</span> <span class="main">⇀</span> <span class="quoted">"<span class="main">(</span><span class="free">m</span> <span class="main">⤜</span> <span class="main">(</span><span class="main">λ</span><span class="main">_</span><span class="main">.</span> <span class="free">n</span><span class="main">)</span><span class="main">)</span>"</span>


<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">enres_unfolds</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">CHECK</span> <span class="free"><span class="bound"><span class="entity">Φ</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">≡</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">Φ</span></span></span> <span class="keyword1">then</span> ERETURN <span class="main">()</span> <span class="keyword1">else</span> THROW <span class="free"><span class="bound"><span class="entity">e</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">enres_unfolds</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">EASSUME</span> <span class="free"><span class="bound"><span class="entity">Φ</span></span></span> <span class="main">≡</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">Φ</span></span></span> <span class="keyword1">then</span> ERETURN <span class="main">()</span> <span class="keyword1">else</span> SUCCEED"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">enres_unfolds</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">EASSERT</span> <span class="free"><span class="bound"><span class="entity">Φ</span></span></span> <span class="main">≡</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">Φ</span></span></span> <span class="keyword1">then</span> ERETURN <span class="main">()</span> <span class="keyword1">else</span> FAIL"</span></span>

<span class="keyword1" id="Exc_Nres_Monad-EASSUME_simps"><span class="command">lemma</span></span> EASSUME_simps<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"EASSUME True <span class="main">=</span> ERETURN <span class="main">()</span>"</span></span>
  <span class="quoted"><span class="quoted">"EASSUME False <span class="main">=</span> SUCCEED"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> EASSUME_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Exc_Nres_Monad-EASSERT_simps"><span class="command">lemma</span></span> EASSERT_simps<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"EASSERT True <span class="main">=</span> ERETURN <span class="main">()</span>"</span></span>
  <span class="quoted"><span class="quoted">"EASSERT False <span class="main">=</span> FAIL"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> EASSERT_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Exc_Nres_Monad-CHECK_simps"><span class="command">lemma</span></span> CHECK_simps<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"CHECK True <span class="free">e</span> <span class="main">=</span> ERETURN <span class="main">()</span>"</span></span> 
  <span class="quoted"><span class="quoted">"CHECK False <span class="free">e</span> <span class="main">=</span> THROW <span class="free">e</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> CHECK_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Exc_Nres_Monad-pw_ESPEC"><span class="command">lemma</span></span> pw_ESPEC<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">refine_pw_simps</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"nofail <span class="main">(</span>ESPEC <span class="free">Φ</span> <span class="free">Ψ</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"inres <span class="main">(</span>ESPEC <span class="free">Φ</span> <span class="free">Ψ</span><span class="main">)</span> <span class="main">(</span>Inl <span class="free">e</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">Φ</span> <span class="free">e</span>"</span></span>
  <span class="quoted"><span class="quoted">"inres <span class="main">(</span>ESPEC <span class="free">Φ</span> <span class="free">Ψ</span><span class="main">)</span> <span class="main">(</span>Inr <span class="free">x</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">Ψ</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> <span class="dynamic"><span class="dynamic">enres_unfolds</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Exc_Nres_Monad-pw_ERETURN"><span class="command">lemma</span></span> pw_ERETURN<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">refine_pw_simps</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"nofail <span class="main">(</span>ERETURN <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">¬</span>inres <span class="main">(</span>ERETURN <span class="free">x</span><span class="main">)</span> <span class="main">(</span>Inl <span class="free">e</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"inres <span class="main">(</span>ERETURN <span class="free">x</span><span class="main">)</span> <span class="main">(</span>Inr <span class="free">y</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">x</span><span class="main">=</span><span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> <span class="dynamic"><span class="dynamic">enres_unfolds</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Exc_Nres_Monad-pw_ebind"><span class="command">lemma</span></span> pw_ebind<span class="main">[</span><span class="operator">refine_pw_simps</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"nofail <span class="main">(</span>ebind <span class="free">m</span> <span class="free">f</span><span class="main">)</span> <span class="main">⟷</span> nofail <span class="free">m</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">.</span> inres <span class="free">m</span> <span class="main">(</span>Inr <span class="bound">x</span><span class="main">)</span> <span class="main">⟶</span> nofail <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"inres <span class="main">(</span>ebind <span class="free">m</span> <span class="free">f</span><span class="main">)</span> <span class="main">(</span>Inl <span class="free">e</span><span class="main">)</span> <span class="main">⟷</span> inres <span class="free">m</span> <span class="main">(</span>Inl <span class="free">e</span><span class="main">)</span> <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span><span class="main">.</span> inres <span class="free">m</span> <span class="main">(</span>Inr <span class="bound">x</span><span class="main">)</span> <span class="main">∧</span> inres <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span>Inl <span class="free">e</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"inres <span class="main">(</span>ebind <span class="free">m</span> <span class="free">f</span><span class="main">)</span> <span class="main">(</span>Inr <span class="free">x</span><span class="main">)</span> <span class="main">⟷</span> nofail <span class="free">m</span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∃</span><span class="bound">y</span><span class="main">.</span> inres <span class="free">m</span> <span class="main">(</span>Inr <span class="bound">y</span><span class="main">)</span> <span class="main">∧</span> inres <span class="main">(</span><span class="free">f</span> <span class="bound">y</span><span class="main">)</span> <span class="main">(</span>Inr <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> <span class="dynamic"><span class="dynamic">enres_unfolds</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> sum.split<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> sum.exhaust_sel <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">using</span></span> sum.exhaust_sel <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Exc_Nres_Monad-pw_THROW"><span class="command">lemma</span></span> pw_THROW<span class="main">[</span><span class="operator">simp</span><span class="main">,</span><span class="operator">refine_pw_simps</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"nofail <span class="main">(</span>THROW <span class="free">e</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"inres <span class="main">(</span>THROW <span class="free">e</span><span class="main">)</span> <span class="main">(</span>Inl <span class="free">f</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">f</span><span class="main">=</span><span class="free">e</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">¬</span>inres <span class="main">(</span>THROW <span class="free">e</span><span class="main">)</span> <span class="main">(</span>Inr <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> <span class="dynamic"><span class="dynamic">enres_unfolds</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>

<span class="keyword1" id="Exc_Nres_Monad-pw_CHECK"><span class="command">lemma</span></span> pw_CHECK<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">refine_pw_simps</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"nofail <span class="main">(</span>CHECK <span class="free">Φ</span> <span class="free">e</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"inres <span class="main">(</span>CHECK <span class="free">Φ</span> <span class="free">e</span><span class="main">)</span> <span class="main">(</span>Inl <span class="free">f</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">¬</span><span class="free">Φ</span> <span class="main">∧</span> <span class="free">f</span><span class="main">=</span><span class="free">e</span>"</span></span>
  <span class="quoted"><span class="quoted">"inres <span class="main">(</span>CHECK <span class="free">Φ</span> <span class="free">e</span><span class="main">)</span> <span class="main">(</span>Inr <span class="free">u</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">Φ</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> <span class="dynamic"><span class="dynamic">enres_unfolds</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>
  
<span class="keyword1" id="Exc_Nres_Monad-pw_EASSUME"><span class="command">lemma</span></span> pw_EASSUME<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">refine_pw_simps</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"nofail <span class="main">(</span>EASSUME <span class="free">Φ</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">¬</span>inres <span class="main">(</span>EASSUME <span class="free">Φ</span><span class="main">)</span> <span class="main">(</span>Inl <span class="free">e</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"inres <span class="main">(</span>EASSUME <span class="free">Φ</span><span class="main">)</span> <span class="main">(</span>Inr <span class="free">u</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">Φ</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> EASSUME_def  
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>

<span class="keyword1" id="Exc_Nres_Monad-pw_EASSERT"><span class="command">lemma</span></span> pw_EASSERT<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">refine_pw_simps</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"nofail <span class="main">(</span>EASSERT <span class="free">Φ</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">Φ</span>"</span></span>
  <span class="quoted"><span class="quoted">"inres <span class="main">(</span>EASSERT <span class="free">Φ</span><span class="main">)</span> <span class="main">(</span>Inr <span class="free">u</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"inres <span class="main">(</span>EASSERT <span class="free">Φ</span><span class="main">)</span> <span class="main">(</span>Inl <span class="free">e</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">¬</span><span class="free">Φ</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> EASSERT_def  
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>

<span class="keyword1" id="Exc_Nres_Monad-pw_CATCH"><span class="command">lemma</span></span> pw_CATCH<span class="main">[</span><span class="operator">refine_pw_simps</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"nofail <span class="main">(</span>CATCH <span class="free">m</span> <span class="free">h</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span>nofail <span class="free">m</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">.</span> inres <span class="free">m</span> <span class="main">(</span>Inl <span class="bound">x</span><span class="main">)</span> <span class="main">⟶</span> nofail <span class="main">(</span><span class="free">h</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"inres <span class="main">(</span>CATCH <span class="free">m</span> <span class="free">h</span><span class="main">)</span> <span class="main">(</span>Inl <span class="free">e</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span>nofail <span class="free">m</span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∃</span><span class="bound">e'</span><span class="main">.</span> inres <span class="free">m</span> <span class="main">(</span>Inl <span class="bound">e'</span><span class="main">)</span> <span class="main">∧</span> inres <span class="main">(</span><span class="free">h</span> <span class="bound">e'</span><span class="main">)</span> <span class="main">(</span>Inl <span class="free">e</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"inres <span class="main">(</span>CATCH <span class="free">m</span> <span class="free">h</span><span class="main">)</span> <span class="main">(</span>Inr <span class="free">x</span><span class="main">)</span> <span class="main">⟷</span> inres <span class="free">m</span> <span class="main">(</span>Inr <span class="free">x</span><span class="main">)</span> <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">e</span><span class="main">.</span> inres <span class="free">m</span> <span class="main">(</span>Inl <span class="bound">e</span><span class="main">)</span> <span class="main">∧</span> inres <span class="main">(</span><span class="free">h</span> <span class="bound">e</span><span class="main">)</span> <span class="main">(</span>Inr <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> CATCH_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> sum.splits<span class="main">)</span>  
  <span class="keyword1"><span class="command">using</span></span> sum.exhaust_sel <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">using</span></span> sum.exhaust_sel <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  
<span class="keyword1" id="Exc_Nres_Monad-pw_ele_iff"><span class="command">lemma</span></span> pw_ele_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">≤</span> <span class="free">n</span> <span class="main">⟷</span> <span class="main">(</span>nofail <span class="free">n</span> <span class="main">⟶</span> 
    nofail <span class="free">m</span> 
  <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">e</span><span class="main">.</span> inres <span class="free">m</span> <span class="main">(</span>Inl <span class="bound">e</span><span class="main">)</span> <span class="main">⟶</span> inres <span class="free">n</span> <span class="main">(</span>Inl <span class="bound">e</span><span class="main">)</span><span class="main">)</span>
  <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">.</span> inres <span class="free">m</span> <span class="main">(</span>Inr <span class="bound">x</span><span class="main">)</span> <span class="main">⟶</span> inres <span class="free">n</span> <span class="main">(</span>Inr <span class="bound">x</span><span class="main">)</span><span class="main">)</span>
  <span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_le_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> sum.exhaust_sel<span class="main">)</span>

<span class="keyword1" id="Exc_Nres_Monad-pw_eeq_iff"><span class="command">lemma</span></span> pw_eeq_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">=</span> <span class="free">n</span> <span class="main">⟷</span> 
    <span class="main">(</span>nofail <span class="free">m</span> <span class="main">⟷</span> nofail <span class="free">n</span><span class="main">)</span> 
  <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">e</span><span class="main">.</span> inres <span class="free">m</span> <span class="main">(</span>Inl <span class="bound">e</span><span class="main">)</span> <span class="main">⟷</span> inres <span class="free">n</span> <span class="main">(</span>Inl <span class="bound">e</span><span class="main">)</span><span class="main">)</span>
  <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">.</span> inres <span class="free">m</span> <span class="main">(</span>Inr <span class="bound">x</span><span class="main">)</span> <span class="main">⟷</span> inres <span class="free">n</span> <span class="main">(</span>Inr <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_eq_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> sum.exhaust_sel<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  


<span class="keyword1" id="Exc_Nres_Monad-enres_monad_laws"><span class="command">lemma</span></span> enres_monad_laws<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"ebind <span class="main">(</span>ERETURN <span class="free">x</span><span class="main">)</span> <span class="free">f</span> <span class="main">=</span> <span class="free">f</span> <span class="free">x</span>"</span></span>
  <span class="quoted"><span class="quoted">"ebind <span class="free">m</span> <span class="main">(</span>ERETURN<span class="main">)</span> <span class="main">=</span> <span class="free">m</span>"</span></span>
  <span class="quoted"><span class="quoted">"ebind <span class="main">(</span>ebind <span class="free">m</span> <span class="free">f</span><span class="main">)</span> <span class="free">g</span> <span class="main">=</span> ebind <span class="free">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> ebind <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="free">g</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_eeq_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>
  
<span class="keyword1" id="Exc_Nres_Monad-enres_additional_laws"><span class="command">lemma</span></span> enres_additional_laws<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"ebind <span class="main">(</span>THROW <span class="free">e</span><span class="main">)</span> <span class="free">f</span> <span class="main">=</span> THROW <span class="free">e</span>"</span></span>
  
  <span class="quoted"><span class="quoted">"CATCH <span class="main">(</span>THROW <span class="free">e</span><span class="main">)</span> <span class="free">h</span> <span class="main">=</span> <span class="free">h</span> <span class="free">e</span>"</span></span>
  <span class="quoted"><span class="quoted">"CATCH <span class="main">(</span>ERETURN <span class="free">x</span><span class="main">)</span> <span class="free">h</span> <span class="main">=</span> ERETURN <span class="free">x</span>"</span></span>
  <span class="quoted"><span class="quoted">"CATCH <span class="free">m</span> THROW <span class="main">=</span> <span class="free">m</span>"</span></span>
  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_eeq_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>  

<span class="keyword1"><span class="command">lemmas</span></span> ESPEC_trans <span class="main">=</span> order_trans<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> z<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"ESPEC <span class="free">Error_Postcond</span> <span class="free">Normal_Postcond</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">for</span></span></span> <span class="free">Error_Postcond</span> <span class="free">Normal_Postcond</span><span class="main">,</span> <span class="operator">zero_var_indexes</span><span class="main">]</span>

<span class="keyword1" id="Exc_Nres_Monad-ESPEC_cons"><span class="command">lemma</span></span> ESPEC_cons<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">≤</span> ESPEC <span class="free">E</span> <span class="free">Q</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">e</span><span class="main">.</span> <span class="free">E</span> <span class="bound">e</span> <span class="main">⟹</span> <span class="free">E'</span> <span class="bound">e</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">x</span> <span class="main">⟹</span> <span class="free">Q'</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">≤</span> ESPEC <span class="free">E'</span> <span class="free">Q'</span>"</span></span>  
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_ele_iff<span class="main">)</span>
  
  
<span class="keyword1" id="Exc_Nres_Monad-ebind_rule_iff"><span class="command">lemma</span></span> ebind_rule_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">doE</span> <span class="main">{</span> <span class="bound">x</span><span class="main">←</span><span class="free">m</span><span class="main">;</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">}</span> <span class="main">≤</span> ESPEC <span class="free">Φ</span> <span class="free">Ψ</span> <span class="main">⟷</span> <span class="free">m</span> <span class="main">≤</span> ESPEC <span class="free">Φ</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">≤</span> ESPEC <span class="free">Φ</span> <span class="free">Ψ</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_ele_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> ebind_rule<span class="main">[</span><span class="operator">refine_vcg</span><span class="main">]</span> <span class="main">=</span> ebind_rule_iff<span class="main">[</span><span class="operator">THEN</span> iffD2<span class="main">]</span>

<span class="keyword1" id="Exc_Nres_Monad-ERETURN_rule_iff"><span class="command">lemma</span></span> ERETURN_rule_iff<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ERETURN <span class="free">x</span> <span class="main">≤</span> ESPEC <span class="free">Φ</span> <span class="free">Ψ</span> <span class="main">⟷</span> <span class="free">Ψ</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_ele_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">lemmas</span></span> ERETURN_rule<span class="main">[</span><span class="operator">refine_vcg</span><span class="main">]</span> <span class="main">=</span> ERETURN_rule_iff<span class="main">[</span><span class="operator">THEN</span> iffD2<span class="main">]</span>

<span class="keyword1" id="Exc_Nres_Monad-ESPEC_rule_iff"><span class="command">lemma</span></span> ESPEC_rule_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"ESPEC <span class="free">Φ</span> <span class="free">Ψ</span> <span class="main">≤</span> ESPEC <span class="free">Φ'</span> <span class="free">Ψ'</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">e</span><span class="main">.</span> <span class="free">Φ</span> <span class="bound">e</span> <span class="main">⟶</span> <span class="free">Φ'</span> <span class="bound">e</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">Ψ</span> <span class="bound">x</span> <span class="main">⟶</span> <span class="free">Ψ'</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_ele_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">lemmas</span></span> ESPEC_rule<span class="main">[</span><span class="operator">refine_vcg</span><span class="main">]</span> <span class="main">=</span> ESPEC_rule_iff<span class="main">[</span><span class="operator">THEN</span> iffD2<span class="main">]</span>

<span class="keyword1" id="Exc_Nres_Monad-THROW_rule_iff"><span class="command">lemma</span></span> THROW_rule_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"THROW <span class="free">e</span> <span class="main">≤</span> ESPEC <span class="free">Φ</span> <span class="free">Ψ</span> <span class="main">⟷</span> <span class="free">Φ</span> <span class="free">e</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_ele_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">lemmas</span></span> THROW_rule<span class="main">[</span><span class="operator">refine_vcg</span><span class="main">]</span> <span class="main">=</span> THROW_rule_iff<span class="main">[</span><span class="operator">THEN</span> iffD2<span class="main">]</span>

<span class="keyword1" id="Exc_Nres_Monad-CATCH_rule_iff"><span class="command">lemma</span></span> CATCH_rule_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"CATCH <span class="free">m</span> <span class="free">h</span> <span class="main">≤</span> ESPEC <span class="free">Φ</span> <span class="free">Ψ</span> <span class="main">⟷</span> <span class="free">m</span> <span class="main">≤</span> ESPEC <span class="main">(</span><span class="main">λ</span><span class="bound">e</span><span class="main">.</span> <span class="free">h</span> <span class="bound">e</span> <span class="main">≤</span> ESPEC <span class="free">Φ</span> <span class="free">Ψ</span><span class="main">)</span> <span class="free">Ψ</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_ele_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">lemmas</span></span> CATCH_rule<span class="main">[</span><span class="operator">refine_vcg</span><span class="main">]</span> <span class="main">=</span> CATCH_rule_iff<span class="main">[</span><span class="operator">THEN</span> iffD2<span class="main">]</span>



<span class="keyword1" id="Exc_Nres_Monad-CHECK_rule_iff"><span class="command">lemma</span></span> CHECK_rule_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"CHECK <span class="free">c</span> <span class="free">e</span> <span class="main">≤</span> ESPEC <span class="free">Φ</span> <span class="free">Ψ</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">c</span> <span class="main">⟶</span> <span class="free">Ψ</span> <span class="main">()</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">¬</span><span class="free">c</span> <span class="main">⟶</span> <span class="free">Φ</span> <span class="free">e</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_ele_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>

<span class="keyword1" id="Exc_Nres_Monad-CHECK_rule"><span class="command">lemma</span></span> CHECK_rule<span class="main">[</span><span class="operator">refine_vcg</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">⟹</span> <span class="free">Ψ</span> <span class="main">()</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="free">c</span> <span class="main">⟹</span> <span class="free">Φ</span> <span class="free">e</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"CHECK <span class="free">c</span> <span class="free">e</span> <span class="main">≤</span> ESPEC <span class="free">Φ</span> <span class="free">Ψ</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> CHECK_rule_iff<span class="main">)</span>



<span class="keyword1" id="Exc_Nres_Monad-EASSUME_rule"><span class="command">lemma</span></span> EASSUME_rule<span class="main">[</span><span class="operator">refine_vcg</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">Φ</span> <span class="main">⟹</span> <span class="free">Ψ</span> <span class="main">()</span><span class="main">⟧</span> <span class="main">⟹</span> EASSUME <span class="free">Φ</span> <span class="main">≤</span> ESPEC <span class="free">E</span> <span class="free">Ψ</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">Φ</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Exc_Nres_Monad-EASSERT_rule"><span class="command">lemma</span></span> EASSERT_rule<span class="main">[</span><span class="operator">refine_vcg</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">Φ</span><span class="main">;</span> <span class="free">Φ</span> <span class="main">⟹</span> <span class="free">Ψ</span> <span class="main">()</span><span class="main">⟧</span> <span class="main">⟹</span> EASSERT <span class="free">Φ</span> <span class="main">≤</span> ESPEC <span class="free">E</span> <span class="free">Ψ</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Exc_Nres_Monad-eprod_rule"><span class="command">lemma</span></span> eprod_rule<span class="main">[</span><span class="operator">refine_vcg</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">⋀</span><span class="bound">a</span> <span class="bound">b</span><span class="main">.</span> <span class="free">p</span><span class="main">=</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">S</span> <span class="bound">a</span> <span class="bound">b</span> <span class="main">≤</span> ESPEC <span class="free">Φ</span> <span class="free">Ψ</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">p</span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span> <span class="main">⇒</span> <span class="free">S</span> <span class="bound">a</span> <span class="bound">b</span><span class="main">)</span> <span class="main">≤</span> ESPEC <span class="free">Φ</span> <span class="free">Ψ</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span>

<span class="comment1">(* TODO: Add a simplifier setup that normalizes nested case-expressions to
  the vcg! *)</span>
<span class="keyword1" id="Exc_Nres_Monad-eprod2_rule"><span class="command">lemma</span></span> eprod2_rule<span class="main">[</span><span class="operator">refine_vcg</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">a</span> <span class="bound">b</span> <span class="bound">c</span> <span class="bound">d</span><span class="main">.</span> <span class="main">⟦</span><span class="free">ab</span><span class="main">=</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span><span class="main">;</span> <span class="free">cd</span><span class="main">=</span><span class="main">(</span><span class="bound">c</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">f</span> <span class="bound">a</span> <span class="bound">b</span> <span class="bound">c</span> <span class="bound">d</span> <span class="main">≤</span> ESPEC <span class="free">Φ</span> <span class="free">Ψ</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span> <span class="main">(</span><span class="bound">c</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span><span class="main">.</span> <span class="free">f</span> <span class="bound">a</span> <span class="bound">b</span> <span class="bound">c</span> <span class="bound">d</span><span class="main">)</span> <span class="free">ab</span> <span class="free">cd</span> <span class="main">≤</span> ESPEC <span class="free">Φ</span> <span class="free">Ψ</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span>

<span class="keyword1" id="Exc_Nres_Monad-eif_rule"><span class="command">lemma</span></span> eif_rule<span class="main">[</span><span class="operator">refine_vcg</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">b</span> <span class="main">⟹</span> <span class="free">S1</span> <span class="main">≤</span> ESPEC <span class="free">Φ</span> <span class="free">Ψ</span><span class="main">;</span> <span class="main">¬</span><span class="free">b</span> <span class="main">⟹</span> <span class="free">S2</span> <span class="main">≤</span> ESPEC <span class="free">Φ</span> <span class="free">Ψ</span><span class="main">⟧</span> 
  <span class="main">⟹</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">b</span> <span class="keyword1">then</span> <span class="free">S1</span> <span class="keyword1">else</span> <span class="free">S2</span><span class="main">)</span> <span class="main">≤</span> ESPEC <span class="free">Φ</span> <span class="free">Ψ</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword1" id="Exc_Nres_Monad-eoption_rule"><span class="command">lemma</span></span> eoption_rule<span class="main">[</span><span class="operator">refine_vcg</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">v</span><span class="main">=</span>None <span class="main">⟹</span> <span class="free">S1</span> <span class="main">≤</span> ESPEC <span class="free">Φ</span> <span class="free">Ψ</span><span class="main">;</span> <span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="free">v</span><span class="main">=</span>Some <span class="bound">x</span> <span class="main">⟹</span> <span class="free">f2</span> <span class="bound">x</span> <span class="main">≤</span> ESPEC <span class="free">Φ</span> <span class="free">Ψ</span><span class="main">⟧</span> 
  <span class="main">⟹</span> case_option <span class="free">S1</span> <span class="free">f2</span> <span class="free">v</span> <span class="main">≤</span> ESPEC <span class="free">Φ</span> <span class="free">Ψ</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

<span class="keyword1" id="Exc_Nres_Monad-eLet_rule"><span class="command">lemma</span></span> eLet_rule<span class="main">[</span><span class="operator">refine_vcg</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="free">v</span> <span class="main">≤</span> ESPEC <span class="free">Φ</span> <span class="free">Ψ</span> <span class="main">⟹</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">x</span><span class="main">=</span><span class="free">v</span> <span class="keyword1">in</span> <span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">≤</span> ESPEC <span class="free">Φ</span> <span class="free">Ψ</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Exc_Nres_Monad-eLet_rule'"><span class="command">lemma</span></span> eLet_rule'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">=</span><span class="free">v</span> <span class="main">⟹</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">≤</span> ESPEC <span class="free">Φ</span> <span class="free">Ψ</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Let <span class="free">v</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">≤</span> ESPEC <span class="free">Φ</span> <span class="free">Ψ</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">enres_unfolds</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">EWHILEIT</span> <span class="free"><span class="bound"><span class="entity">I</span></span></span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> WHILEIT 
  <span class="main">(</span><span class="main">λ</span>Inl <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> True <span class="main">|</span> Inr <span class="bound">s</span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">I</span></span></span> <span class="bound">s</span><span class="main">)</span> 
  <span class="main">(</span><span class="main">λ</span>Inl <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> False <span class="main">|</span> Inr <span class="bound">s</span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="bound">s</span><span class="main">)</span>
  <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> ASSERT <span class="main">(</span><span class="main">¬</span>isl <span class="bound">s</span><span class="main">)</span> <span class="main">⪢</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">s</span> <span class="main">=</span> projr <span class="bound">s</span> <span class="keyword1">in</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span>
  <span class="main">(</span>Inr <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">enres_unfolds</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">EWHILET</span> <span class="main">≡</span> EWHILEIT <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span>"</span></span>

<span class="keyword1" id="Exc_Nres_Monad-EWHILEIT_rule"><span class="command">lemma</span></span> EWHILEIT_rule<span class="main">[</span><span class="operator">refine_vcg</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> WF<span class="main">:</span> <span class="quoted"><span class="quoted">"wf <span class="free">R</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> I0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">I</span> <span class="free">s<span class="hidden">⇩</span><sub>0</sub></span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> IS<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> <span class="main">⟦</span><span class="free">I</span> <span class="bound">s</span><span class="main">;</span> <span class="free">b</span> <span class="bound">s</span><span class="main">;</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span><span class="free">s<span class="hidden">⇩</span><sub>0</sub></span><span class="main">)</span><span class="main">∈</span><span class="free">R</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">f</span> <span class="bound">s</span> <span class="main">≤</span> ESPEC <span class="free">E</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s'</span><span class="main">.</span> <span class="free">I</span> <span class="bound">s'</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">s'</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> IMP<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> <span class="main">⟦</span><span class="free">I</span> <span class="bound">s</span><span class="main">;</span> <span class="main">¬</span> <span class="free">b</span> <span class="bound">s</span><span class="main">;</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span><span class="free">s<span class="hidden">⇩</span><sub>0</sub></span><span class="main">)</span><span class="main">∈</span><span class="free">R</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">Φ</span> <span class="bound">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"EWHILEIT <span class="free">I</span> <span class="free">b</span> <span class="free">f</span> <span class="free">s<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">≤</span> ESPEC <span class="free">E</span> <span class="free">Φ</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> EWHILEIT_def ESPEC_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> WHILEIT_weaken<span class="main"><span class="main"><span class="main">[</span></span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> I<span class="main"><span class="main"><span class="main"><span class="main">=</span></span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span>Inl <span class="bound">e</span> <span class="main">⇒</span> <span class="free">E</span> <span class="bound">e</span> <span class="main">|</span> Inr <span class="bound">s</span> <span class="main">⇒</span> <span class="free">I</span> <span class="bound">s</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span><span class="free">s<span class="hidden">⇩</span><sub>0</sub></span><span class="main">)</span><span class="main">∈</span><span class="free">R</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> sum.splits<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> WHILEIT_rule<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"inv_image <span class="main">(</span>less_than <span class="keyword1">&lt;*lex*&gt;</span> <span class="free">R</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span>Inl <span class="bound">e</span> <span class="main">⇒</span> <span class="main">(</span><span class="main">0</span><span class="main">,</span>undefined<span class="main">)</span> <span class="main">|</span> Inr <span class="bound">s</span> <span class="main">⇒</span> <span class="main">(</span><span class="main">1</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> WF <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> I0 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> sum.splits <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ESPEC_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> IS<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ESPEC_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> IMP <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> sum.splits<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  
<span class="keyword1" id="Exc_Nres_Monad-EWHILET_rule"><span class="command">lemma</span></span> EWHILET_rule<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> WF<span class="main">:</span> <span class="quoted"><span class="quoted">"wf <span class="free">R</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> I0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">I</span> <span class="free">s<span class="hidden">⇩</span><sub>0</sub></span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> IS<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> <span class="main">⟦</span><span class="free">I</span> <span class="bound">s</span><span class="main">;</span> <span class="free">b</span> <span class="bound">s</span><span class="main">;</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span><span class="free">s<span class="hidden">⇩</span><sub>0</sub></span><span class="main">)</span><span class="main">∈</span><span class="free">R</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">f</span> <span class="bound">s</span> <span class="main">≤</span> ESPEC <span class="free">E</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s'</span><span class="main">.</span> <span class="free">I</span> <span class="bound">s'</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">s'</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> IMP<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> <span class="main">⟦</span><span class="free">I</span> <span class="bound">s</span><span class="main">;</span> <span class="main">¬</span> <span class="free">b</span> <span class="bound">s</span><span class="main">;</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span><span class="free">s<span class="hidden">⇩</span><sub>0</sub></span><span class="main">)</span><span class="main">∈</span><span class="free">R</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">Φ</span> <span class="bound">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"EWHILET <span class="free">b</span> <span class="free">f</span> <span class="free">s<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">≤</span> ESPEC <span class="free">E</span> <span class="free">Φ</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> EWHILET_def EWHILEIT_def ESPEC_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> WHILEIT_weaken<span class="main"><span class="main"><span class="main">[</span></span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> I<span class="main"><span class="main"><span class="main"><span class="main">=</span></span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span>Inl <span class="bound">e</span> <span class="main">⇒</span> <span class="free">E</span> <span class="bound">e</span> <span class="main">|</span> Inr <span class="bound">s</span> <span class="main">⇒</span> <span class="free">I</span> <span class="bound">s</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span><span class="free">s<span class="hidden">⇩</span><sub>0</sub></span><span class="main">)</span><span class="main">∈</span><span class="free">R</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> sum.splits<span class="main">)</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> WHILEIT_rule<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"inv_image <span class="main">(</span>less_than <span class="keyword1">&lt;*lex*&gt;</span> <span class="free">R</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span>Inl <span class="bound">e</span> <span class="main">⇒</span> <span class="main">(</span><span class="main">0</span><span class="main">,</span>undefined<span class="main">)</span> <span class="main">|</span> Inr <span class="bound">s</span> <span class="main">⇒</span> <span class="main">(</span><span class="main">1</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> WF <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> I0 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> sum.splits <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ESPEC_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> IS<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ESPEC_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> IMP <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> sum.splits<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  
<span class="keyword1" id="Exc_Nres_Monad-EWHILEIT_weaken"><span class="command">lemma</span></span> EWHILEIT_weaken<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="free">I</span> <span class="bound">x</span> <span class="main">⟹</span> <span class="free">I'</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"EWHILEIT <span class="free">I'</span> <span class="free">b</span> <span class="free">f</span> <span class="free">x</span> <span class="main">≤</span> EWHILEIT <span class="free">I</span> <span class="free">b</span> <span class="free">f</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> <span class="dynamic"><span class="dynamic">enres_unfolds</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> WHILEIT_weaken<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> sum.split<span class="main">)</span>
    
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Explicitly specify a different invariant. ›</span></span>    
<span class="keyword1" id="Exc_Nres_Monad-EWHILEIT_expinv_rule"><span class="command">lemma</span></span> EWHILEIT_expinv_rule<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> WF<span class="main">:</span> <span class="quoted"><span class="quoted">"wf <span class="free">R</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> I0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">I</span> <span class="free">s<span class="hidden">⇩</span><sub>0</sub></span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> IS<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> <span class="main">⟦</span><span class="free">I</span> <span class="bound">s</span><span class="main">;</span> <span class="free">b</span> <span class="bound">s</span><span class="main">;</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span><span class="free">s<span class="hidden">⇩</span><sub>0</sub></span><span class="main">)</span><span class="main">∈</span><span class="free">R</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">f</span> <span class="bound">s</span> <span class="main">≤</span> ESPEC <span class="free">E</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s'</span><span class="main">.</span> <span class="free">I</span> <span class="bound">s'</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">s'</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> IMP<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> <span class="main">⟦</span><span class="free">I</span> <span class="bound">s</span><span class="main">;</span> <span class="main">¬</span> <span class="free">b</span> <span class="bound">s</span><span class="main">;</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span><span class="free">s<span class="hidden">⇩</span><sub>0</sub></span><span class="main">)</span><span class="main">∈</span><span class="free">R</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">Φ</span> <span class="bound">s</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> INVIMP<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> <span class="free">I</span> <span class="bound">s</span> <span class="main">⟹</span> <span class="free">I'</span> <span class="bound">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"EWHILEIT <span class="free">I'</span> <span class="free">b</span> <span class="free">f</span> <span class="free">s<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">≤</span> ESPEC <span class="free">E</span> <span class="free">Φ</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> EWHILEIT_weaken<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> INVIMP <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> EWHILEIT_rule<span class="main"><span class="keyword3">;</span></span> <span class="operator">fact</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  

<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">enres_unfolds</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">enfoldli</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> 
  nfoldli <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">(</span><span class="main">λ</span>Inl <span class="bound">e</span><span class="main">⇒</span>False <span class="main">|</span> Inr <span class="bound">x</span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">s</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span>ASSERT <span class="main">(</span><span class="main">¬</span>isl <span class="bound">s</span><span class="main">)</span><span class="main">;</span> <span class="keyword1">let</span> <span class="bound">s</span><span class="main">=</span>projr <span class="bound">s</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">x</span> <span class="bound">s</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span>Inr <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Exc_Nres_Monad-enfoldli_simps"><span class="command">lemma</span></span> enfoldli_simps<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"enfoldli <span class="main">[]</span> <span class="free">c</span> <span class="free">f</span> <span class="free">s</span> <span class="main">=</span> ERETURN <span class="free">s</span>"</span></span>
  <span class="quoted"><span class="quoted">"enfoldli <span class="main">(</span><span class="free">x</span><span class="main">#</span><span class="free">ls</span><span class="main">)</span> <span class="free">c</span> <span class="free">f</span> <span class="free">s</span> <span class="main">=</span> 
    <span class="main">(</span><span class="keyword1">if</span> <span class="free">c</span> <span class="free">s</span> <span class="keyword1">then</span> <span class="keyword1">doE</span> <span class="main">{</span> <span class="bound">s</span><span class="main">←</span><span class="free">f</span> <span class="free">x</span> <span class="free">s</span><span class="main">;</span> enfoldli <span class="free">ls</span> <span class="free">c</span> <span class="free">f</span> <span class="bound">s</span><span class="main">}</span> <span class="keyword1">else</span> ERETURN <span class="free">s</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> <span class="dynamic"><span class="dynamic">enres_unfolds</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> sum.split <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> arg_cong<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted">"Refine_Basic.bind <span class="main">_</span>"</span></span><span class="main"><span class="main">]</span></span> ext<span class="main">)</span>

<span class="keyword1" id="Exc_Nres_Monad-enfoldli_rule"><span class="command">lemma</span></span> enfoldli_rule<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> I0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">I</span> <span class="main">[]</span> <span class="free">l0</span> <span class="free">σ0</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> IS<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">l1</span> <span class="bound">l2</span> <span class="bound">σ</span><span class="main">.</span> <span class="main">⟦</span> <span class="free">l0</span><span class="main">=</span><span class="bound">l1</span><span class="main">@</span><span class="bound">x</span><span class="main">#</span><span class="bound">l2</span><span class="main">;</span> <span class="free">I</span> <span class="bound">l1</span> <span class="main">(</span><span class="bound">x</span><span class="main">#</span><span class="bound">l2</span><span class="main">)</span> <span class="bound">σ</span><span class="main">;</span> <span class="free">c</span> <span class="bound">σ</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">f</span> <span class="bound">x</span> <span class="bound">σ</span> <span class="main">≤</span> ESPEC <span class="free">E</span> <span class="main">(</span><span class="free">I</span> <span class="main">(</span><span class="bound">l1</span><span class="main">@</span><span class="main">[</span><span class="bound">x</span><span class="main">]</span><span class="main">)</span> <span class="bound">l2</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> FNC<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">l1</span> <span class="bound">l2</span> <span class="bound">σ</span><span class="main">.</span> <span class="main">⟦</span> <span class="free">l0</span><span class="main">=</span><span class="bound">l1</span><span class="main">@</span><span class="bound">l2</span><span class="main">;</span> <span class="free">I</span> <span class="bound">l1</span> <span class="bound">l2</span> <span class="bound">σ</span><span class="main">;</span> <span class="main">¬</span><span class="free">c</span> <span class="bound">σ</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">σ</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> FC<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">σ</span><span class="main">.</span> <span class="main">⟦</span> <span class="free">I</span> <span class="free">l0</span> <span class="main">[]</span> <span class="bound">σ</span><span class="main">;</span> <span class="free">c</span> <span class="bound">σ</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">σ</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"enfoldli <span class="free">l0</span> <span class="free">c</span> <span class="free">f</span> <span class="free">σ0</span> <span class="main">≤</span> ESPEC <span class="free">E</span> <span class="free">P</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> enfoldli_def ESPEC_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> nfoldli_rule<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> I<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">l1</span> <span class="bound">l2</span><span class="main">.</span> <span class="main">λ</span>Inl <span class="bound">e</span> <span class="main">⇒</span> <span class="free">E</span> <span class="bound">e</span> <span class="main">|</span> Inr <span class="bound">σ</span> <span class="main">⇒</span> <span class="free">I</span> <span class="bound">l1</span> <span class="bound">l2</span> <span class="bound">σ</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> I0<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> sum.splits<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> IS<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ESPEC_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> FNC <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> sum.split<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> FC <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> sum.split<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


    
    
    
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Data Refinement›</span></span>

<span class="keyword1" id="Exc_Nres_Monad-sum_rel_conv"><span class="command">lemma</span></span> sum_rel_conv<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>Inl <span class="free">l</span><span class="main">,</span> <span class="free">s'</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span><span class="free">L</span><span class="main">,</span><span class="free">R</span><span class="main">⟩</span>sum_rel <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">l'</span><span class="main">.</span> <span class="free">s'</span><span class="main">=</span>Inl <span class="bound">l'</span> <span class="main">∧</span> <span class="main">(</span><span class="free">l</span><span class="main">,</span><span class="bound">l'</span><span class="main">)</span><span class="main">∈</span><span class="free">L</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>Inr <span class="free">r</span><span class="main">,</span> <span class="free">s'</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span><span class="free">L</span><span class="main">,</span><span class="free">R</span><span class="main">⟩</span>sum_rel <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">r'</span><span class="main">.</span> <span class="free">s'</span><span class="main">=</span>Inr <span class="bound">r'</span> <span class="main">∧</span> <span class="main">(</span><span class="free">r</span><span class="main">,</span><span class="bound">r'</span><span class="main">)</span><span class="main">∈</span><span class="free">R</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">s</span><span class="main">,</span> Inl <span class="free">l'</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span><span class="free">L</span><span class="main">,</span><span class="free">R</span><span class="main">⟩</span>sum_rel <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">l</span><span class="main">.</span> <span class="free">s</span><span class="main">=</span>Inl <span class="bound">l</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="free">l'</span><span class="main">)</span><span class="main">∈</span><span class="free">L</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">s</span><span class="main">,</span> Inr <span class="free">r'</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span><span class="free">L</span><span class="main">,</span><span class="free">R</span><span class="main">⟩</span>sum_rel <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">r</span><span class="main">.</span> <span class="free">s</span><span class="main">=</span>Inr <span class="bound">r</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">r</span><span class="main">,</span><span class="free">r'</span><span class="main">)</span><span class="main">∈</span><span class="free">R</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">l</span><span class="main">.</span> <span class="free">s</span> <span class="main">≠</span> Inl <span class="bound">l</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">r</span><span class="main">.</span> <span class="free">s</span><span class="main">=</span>Inr <span class="bound">r</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">r</span><span class="main">.</span> <span class="free">s</span> <span class="main">≠</span> Inr <span class="bound">r</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">l</span><span class="main">.</span> <span class="free">s</span><span class="main">=</span>Inl <span class="bound">l</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">s'</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">s'</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">s</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">s</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">s</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">s</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>  

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">econc_fun</span> <span class="main">(</span><span class="quoted">"<span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span>"</span><span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">enres_unfolds</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">econc_fun</span> <span class="free"><span class="bound"><span class="entity">E</span></span></span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">≡</span> <span class="main">⇓</span><span class="main">(</span><span class="main">⟨</span><span class="free"><span class="bound"><span class="entity">E</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">R</span></span></span><span class="main">⟩</span>sum_rel<span class="main">)</span>"</span></span>

<span class="keyword1" id="Exc_Nres_Monad-RELATES_pat_erefine"><span class="command">lemma</span></span> RELATES_pat_erefine<span class="main">[</span><span class="operator">refine_dref_pattern</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>RELATES <span class="free">R</span><span class="main">;</span> <span class="free">mi</span> <span class="main">≤</span><span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="free">m</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">mi</span> <span class="main">≤</span><span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="free">m</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1" id="Exc_Nres_Monad-pw_econc_iff"><span class="command">lemma</span></span> pw_econc_iff<span class="main">[</span><span class="operator">refine_pw_simps</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"inres <span class="main">(</span><span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="free">m</span><span class="main">)</span> <span class="main">(</span>Inl <span class="free">ei</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span>nofail <span class="free">m</span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∃</span><span class="bound">e</span><span class="main">.</span> inres <span class="free">m</span> <span class="main">(</span>Inl <span class="bound">e</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="free">ei</span><span class="main">,</span><span class="bound">e</span><span class="main">)</span><span class="main">∈</span><span class="free">E</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"inres <span class="main">(</span><span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="free">m</span><span class="main">)</span> <span class="main">(</span>Inr <span class="free">xi</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span>nofail <span class="free">m</span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span><span class="main">.</span> inres <span class="free">m</span> <span class="main">(</span>Inr <span class="bound">x</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="free">xi</span><span class="main">,</span><span class="bound">x</span><span class="main">)</span><span class="main">∈</span><span class="free">R</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"nofail <span class="main">(</span><span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="free">m</span><span class="main">)</span> <span class="main">⟷</span> nofail <span class="free">m</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> econc_fun_def sum_rel_conv<span class="main">)</span>

<span class="keyword1" id="Exc_Nres_Monad-econc_fun_id"><span class="command">lemma</span></span> econc_fun_id<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> Id Id <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_eeq_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ext<span class="main">)</span>

<span class="keyword1" id="Exc_Nres_Monad-econc_fun_ESPEC"><span class="command">lemma</span></span> econc_fun_ESPEC<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="main">(</span>ESPEC <span class="free">Φ</span> <span class="free">Ψ</span><span class="main">)</span> <span class="main">=</span> ESPEC <span class="main">(</span><span class="main">λ</span><span class="bound">ei</span><span class="main">.</span> <span class="main">∃</span><span class="bound">e</span><span class="main">.</span> <span class="main">(</span><span class="bound">ei</span><span class="main">,</span><span class="bound">e</span><span class="main">)</span><span class="main">∈</span><span class="free">E</span> <span class="main">∧</span> <span class="free">Φ</span> <span class="bound">e</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">ri</span><span class="main">.</span> <span class="main">∃</span><span class="bound">r</span><span class="main">.</span> <span class="main">(</span><span class="bound">ri</span><span class="main">,</span><span class="bound">r</span><span class="main">)</span><span class="main">∈</span><span class="free">R</span> <span class="main">∧</span> <span class="free">Ψ</span> <span class="bound">r</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_eeq_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>

<span class="keyword1" id="Exc_Nres_Monad-econc_fun_ERETURN"><span class="command">lemma</span></span> econc_fun_ERETURN<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="main">(</span>ERETURN <span class="free">x</span><span class="main">)</span> <span class="main">=</span> ESPEC <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> False<span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">xi</span><span class="main">.</span> <span class="main">(</span><span class="bound">xi</span><span class="main">,</span><span class="free">x</span><span class="main">)</span><span class="main">∈</span><span class="free">R</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_eeq_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>

<span class="keyword1" id="Exc_Nres_Monad-econc_fun_univ_id"><span class="command">lemma</span></span> econc_fun_univ_id<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> UNIV Id <span class="main">(</span>ESPEC <span class="free">Φ</span> <span class="free">Ψ</span><span class="main">)</span> <span class="main">=</span> ESPEC <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> Ex <span class="free">Φ</span><span class="main">)</span> <span class="free">Ψ</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_eeq_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>

<span class="keyword1" id="Exc_Nres_Monad-erefine_same_sup_Id"><span class="command">lemma</span></span> erefine_same_sup_Id<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> Id<span class="main">⊆</span><span class="free">E</span><span class="main">;</span> Id<span class="main">⊆</span><span class="free">R</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">m</span> <span class="main">≤</span><span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="free">m</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_ele_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>

<span class="keyword1" id="Exc_Nres_Monad-econc_mono3"><span class="command">lemma</span></span> econc_mono3<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">m</span><span class="main">≤</span><span class="free">m'</span> <span class="main">⟹</span> <span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="free">m</span> <span class="main">≤</span> <span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="free">m'</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_ele_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>

<span class="comment1">(* Order of these two is important! *)</span>    
<span class="keyword1" id="Exc_Nres_Monad-econc_x_trans"><span class="command">lemma</span></span> econc_x_trans<span class="main">[</span><span class="operator">trans</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≤</span> <span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="free">y</span> <span class="main">⟹</span> <span class="free">y</span> <span class="main">≤</span> <span class="free">z</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">≤</span> <span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="free">z</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_ele_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>
<span class="keyword1" id="Exc_Nres_Monad-econc_econc_trans"><span class="command">lemma</span></span> econc_econc_trans<span class="main">[</span><span class="operator">trans</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≤</span><span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E1</span> <span class="free">R1</span> <span class="free">y</span> <span class="main">⟹</span> <span class="free">y</span> <span class="main">≤</span> <span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E2</span> <span class="free">R2</span> <span class="free">z</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">≤</span> <span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="main">(</span><span class="free">E1</span> <span class="keyword1">O</span> <span class="free">E2</span><span class="main">)</span> <span class="main">(</span><span class="free">R1</span> <span class="keyword1">O</span> <span class="free">R2</span><span class="main">)</span> <span class="free">z</span>"</span></span>    
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_ele_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>
  
    
    
<span class="keyword1" id="Exc_Nres_Monad-ERETURN_refine"><span class="command">lemma</span></span> ERETURN_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">xi</span><span class="main">,</span><span class="free">x</span><span class="main">)</span><span class="main">∈</span><span class="free">R</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ERETURN <span class="free">xi</span> <span class="main">≤</span> <span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span><span class="free">E</span> <span class="free">R</span> <span class="main">(</span>ERETURN <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_ele_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>

<span class="keyword1" id="Exc_Nres_Monad-EASSERT_bind_refine_right"><span class="command">lemma</span></span> EASSERT_bind_refine_right<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">Φ</span> <span class="main">⟹</span> <span class="free">mi</span> <span class="main">≤</span><span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="free">m</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">mi</span> <span class="main">≤</span><span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="main">(</span><span class="keyword1">doE</span> <span class="main">{</span>EASSERT <span class="free">Φ</span><span class="main">;</span> <span class="free">m</span><span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pw_ele_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>
  
<span class="keyword1" id="Exc_Nres_Monad-EASSERT_bind_refine_left"><span class="command">lemma</span></span> EASSERT_bind_refine_left<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">Φ</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">mi</span> <span class="main">≤</span><span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="free">m</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">doE</span> <span class="main">{</span>EASSERT <span class="free">Φ</span><span class="main">;</span> <span class="free">mi</span><span class="main">}</span><span class="main">)</span> <span class="main">≤</span><span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="free">m</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Exc_Nres_Monad-EASSUME_bind_refine_right"><span class="command">lemma</span></span> EASSUME_bind_refine_right<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">Φ</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">mi</span> <span class="main">≤</span><span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="free">m</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">mi</span> <span class="main">≤</span><span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="main">(</span><span class="keyword1">doE</span> <span class="main">{</span>EASSUME <span class="free">Φ</span><span class="main">;</span> <span class="free">m</span><span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="Exc_Nres_Monad-EASSUME_bind_refine_left"><span class="command">lemma</span></span> EASSUME_bind_refine_left<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">Φ</span> <span class="main">⟹</span> <span class="free">mi</span> <span class="main">≤</span><span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="free">m</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">doE</span> <span class="main">{</span>EASSUME <span class="free">Φ</span><span class="main">;</span> <span class="free">mi</span><span class="main">}</span><span class="main">)</span> <span class="main">≤</span><span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="free">m</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pw_ele_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>

<span class="keyword1" id="Exc_Nres_Monad-ebind_refine"><span class="command">lemma</span></span> ebind_refine<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">mi</span> <span class="main">≤</span><span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R'</span> <span class="free">m</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xi</span> <span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="bound">xi</span><span class="main">,</span><span class="bound">x</span><span class="main">)</span><span class="main">∈</span><span class="free">R'</span> <span class="main">⟹</span> <span class="free">fi</span> <span class="bound">xi</span> <span class="main">≤</span><span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">doE</span> <span class="main">{</span> <span class="bound">xi</span> <span class="main">←</span> <span class="free">mi</span><span class="main">;</span> <span class="free">fi</span> <span class="bound">xi</span> <span class="main">}</span> <span class="main">≤</span> <span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="main">(</span><span class="keyword1">doE</span> <span class="main">{</span> <span class="bound">x</span> <span class="main">←</span> <span class="free">m</span><span class="main">;</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pw_ele_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Order of this lemmas matters!›</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">refine</span><span class="main">]</span> <span class="main">=</span> 
  ebind_refine
  EASSERT_bind_refine_left EASSUME_bind_refine_right
  EASSUME_bind_refine_left EASSERT_bind_refine_right

<span class="keyword1"><span class="command">thm</span></span> <span class="dynamic"><span class="dynamic">refine</span></span><span class="main">(</span>1-10<span class="main">)</span>

<span class="keyword1" id="Exc_Nres_Monad-ebind_refine'"><span class="command">lemma</span></span> ebind_refine'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">mi</span> <span class="main">≤</span><span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R'</span> <span class="free">m</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xi</span> <span class="bound">x</span><span class="main">.</span> <span class="main">⟦</span><span class="main">(</span><span class="bound">xi</span><span class="main">,</span><span class="bound">x</span><span class="main">)</span><span class="main">∈</span><span class="free">R'</span><span class="main">;</span> inres <span class="free">mi</span> <span class="main">(</span>Inr <span class="bound">xi</span><span class="main">)</span><span class="main">;</span> inres <span class="free">m</span> <span class="main">(</span>Inr <span class="bound">x</span><span class="main">)</span><span class="main">;</span> nofail <span class="free">mi</span><span class="main">;</span> nofail <span class="free">m</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">fi</span> <span class="bound">xi</span> <span class="main">≤</span><span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">doE</span> <span class="main">{</span> <span class="bound">xi</span> <span class="main">←</span> <span class="free">mi</span><span class="main">;</span> <span class="free">fi</span> <span class="bound">xi</span> <span class="main">}</span> <span class="main">≤</span> <span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="main">(</span><span class="keyword1">doE</span> <span class="main">{</span> <span class="bound">x</span> <span class="main">←</span> <span class="free">m</span><span class="main">;</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pw_ele_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span> <span class="operator">blast</span>

<span class="keyword1" id="Exc_Nres_Monad-THROW_refine"><span class="command">lemma</span></span> THROW_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">ei</span><span class="main">,</span><span class="free">e</span><span class="main">)</span><span class="main">∈</span><span class="free">E</span> <span class="main">⟹</span> THROW <span class="free">ei</span> <span class="main">≤</span><span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="main">(</span>THROW <span class="free">e</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_ele_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>

<span class="keyword1" id="Exc_Nres_Monad-CATCH_refine'"><span class="command">lemma</span></span> CATCH_refine'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">mi</span> <span class="main">≤</span> <span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E'</span> <span class="free">R</span> <span class="free">m</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">ei</span> <span class="bound">e</span><span class="main">.</span> <span class="main">⟦</span> <span class="main">(</span><span class="bound">ei</span><span class="main">,</span><span class="bound">e</span><span class="main">)</span><span class="main">∈</span><span class="free">E'</span><span class="main">;</span> inres <span class="free">mi</span> <span class="main">(</span>Inl <span class="bound">ei</span><span class="main">)</span><span class="main">;</span> inres <span class="free">m</span> <span class="main">(</span>Inl <span class="bound">e</span><span class="main">)</span><span class="main">;</span> nofail <span class="free">mi</span><span class="main">;</span> nofail <span class="free">m</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">hi</span> <span class="bound">ei</span> <span class="main">≤</span><span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="main">(</span><span class="free">h</span> <span class="bound">e</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"CATCH <span class="free">mi</span> <span class="free">hi</span> <span class="main">≤</span> <span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="main">(</span>CATCH <span class="free">m</span> <span class="free">h</span><span class="main">)</span>"</span></span>  
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pw_ele_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span> <span class="operator">blast</span>
  
<span class="keyword1" id="Exc_Nres_Monad-CATCH_refine"><span class="command">lemma</span></span> CATCH_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">mi</span> <span class="main">≤</span> <span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E'</span> <span class="free">R</span> <span class="free">m</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">ei</span> <span class="bound">e</span><span class="main">.</span> <span class="main">⟦</span> <span class="main">(</span><span class="bound">ei</span><span class="main">,</span><span class="bound">e</span><span class="main">)</span><span class="main">∈</span><span class="free">E'</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">hi</span> <span class="bound">ei</span> <span class="main">≤</span><span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="main">(</span><span class="free">h</span> <span class="bound">e</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"CATCH <span class="free">mi</span> <span class="free">hi</span> <span class="main">≤</span> <span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="main">(</span>CATCH <span class="free">m</span> <span class="free">h</span><span class="main">)</span>"</span></span>  
  <span class="keyword1"><span class="command">using</span></span> assms CATCH_refine' <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>

<span class="keyword1" id="Exc_Nres_Monad-CHECK_refine"><span class="command">lemma</span></span> CHECK_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">Φi</span> <span class="main">⟷</span> <span class="free">Φ</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="free">Φ</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">msgi</span><span class="main">,</span><span class="free">msg</span><span class="main">)</span><span class="main">∈</span><span class="free">E</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"CHECK <span class="free">Φi</span> <span class="free">msgi</span> <span class="main">≤</span><span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> Id <span class="main">(</span>CHECK <span class="free">Φ</span> <span class="free">msg</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_ele_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This must be declared after <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> CHECK_refine<span class="antiquote"><span class="antiquote">}</span></span></span></span>!›</span></span>
<span class="keyword1" id="Exc_Nres_Monad-CHECK_bind_refine"><span class="command">lemma</span></span> CHECK_bind_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">Φi</span> <span class="main">⟷</span> <span class="free">Φ</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="free">Φ</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">msgi</span><span class="main">,</span><span class="free">msg</span><span class="main">)</span><span class="main">∈</span><span class="free">E</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">Φ</span> <span class="main">⟹</span> <span class="free">mi</span> <span class="main">≤</span><span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="free">m</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">doE</span> <span class="main">{</span>CHECK <span class="free">Φi</span> <span class="free">msgi</span><span class="main">;</span><span class="free">mi</span><span class="main">}</span> <span class="main">≤</span><span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="main">(</span><span class="keyword1">doE</span> <span class="main">{</span>CHECK <span class="free">Φ</span> <span class="free">msg</span><span class="main">;</span> <span class="free">m</span><span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_ele_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>
    
<span class="keyword1" id="Exc_Nres_Monad-Let_unfold_refine"><span class="command">lemma</span></span> Let_unfold_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="free">x</span> <span class="main">≤</span> <span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="main">(</span><span class="free">f'</span> <span class="free">x'</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Let <span class="free">x</span> <span class="free">f</span> <span class="main">≤</span> <span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="main">(</span>Let <span class="free">x'</span> <span class="free">f'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Exc_Nres_Monad-Let_refine"><span class="command">lemma</span></span> Let_refine<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">m</span><span class="main">,</span><span class="free">m'</span><span class="main">)</span><span class="main">∈</span><span class="free">R'</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">x'</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">x'</span><span class="main">)</span><span class="main">∈</span><span class="free">R'</span> <span class="main">⟹</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">≤</span> <span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="main">(</span><span class="free">f'</span> <span class="bound">x'</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Let <span class="free">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">≤</span><span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="main">(</span>Let <span class="free">m'</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x'</span><span class="main">.</span> <span class="free">f'</span> <span class="bound">x'</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Exc_Nres_Monad-eif_refine"><span class="command">lemma</span></span> eif_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">b</span><span class="main">,</span><span class="free">b'</span><span class="main">)</span><span class="main">∈</span>bool_rel"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">b</span><span class="main">;</span><span class="free">b'</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">S1</span> <span class="main">≤</span> <span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="free">S1'</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">¬</span><span class="free">b</span><span class="main">;</span><span class="main">¬</span><span class="free">b'</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">S2</span> <span class="main">≤</span> <span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="free">S2'</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">if</span> <span class="free">b</span> <span class="keyword1">then</span> <span class="free">S1</span> <span class="keyword1">else</span> <span class="free">S2</span><span class="main">)</span> <span class="main">≤</span> <span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">b'</span> <span class="keyword1">then</span> <span class="free">S1'</span> <span class="keyword1">else</span> <span class="free">S2'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>




<span class="comment1">(* TODO: Also add enfoldli_invar_refine *)</span>
<span class="keyword1" id="Exc_Nres_Monad-enfoldli_refine"><span class="command">lemma</span></span> enfoldli_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">li</span><span class="main">,</span> <span class="free">l</span><span class="main">)</span> <span class="main">∈</span> <span class="main">⟨</span><span class="free">S</span><span class="main">⟩</span>list_rel"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">si</span><span class="main">,</span> <span class="free">s</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> CR<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">ci</span><span class="main">,</span> <span class="free">c</span><span class="main">)</span> <span class="main">∈</span> <span class="free">R</span> <span class="main">→</span> bool_rel"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> FR<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">xi</span> <span class="bound">x</span> <span class="bound">si</span> <span class="bound">s</span><span class="main">.</span> <span class="main">⟦</span> <span class="main">(</span><span class="bound">xi</span><span class="main">,</span><span class="bound">x</span><span class="main">)</span><span class="main">∈</span><span class="free">S</span><span class="main">;</span> <span class="main">(</span><span class="bound">si</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span><span class="main">∈</span><span class="free">R</span><span class="main">;</span> <span class="free">c</span> <span class="bound">s</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">fi</span> <span class="bound">xi</span> <span class="bound">si</span> <span class="main">≤</span> <span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span> <span class="bound">s</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"enfoldli <span class="free">li</span> <span class="free">ci</span> <span class="free">fi</span> <span class="free">si</span> <span class="main">≤</span> <span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="main">(</span>enfoldli <span class="free">l</span> <span class="free">c</span> <span class="free">f</span> <span class="free">s</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> <span class="dynamic"><span class="dynamic">enres_unfolds</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> nfoldli_refine<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> CR<span class="main">[</span><span class="operator">param_fo</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> sum.split <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sum_rel_conv<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_rcg</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">applyS</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> sum.splits <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sum_rel_conv<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> FR<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> <span class="dynamic"><span class="dynamic">enres_unfolds</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> sum.splits <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sum_rel_conv<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Exc_Nres_Monad-EWHILET_refine"><span class="command">lemma</span></span> EWHILET_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> R0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">x'</span><span class="main">)</span><span class="main">∈</span><span class="free">R</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> COND_REF<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">x'</span><span class="main">.</span> <span class="main">⟦</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">x'</span><span class="main">)</span><span class="main">∈</span><span class="free">R</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">b</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">b'</span> <span class="bound">x'</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> STEP_REF<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">x'</span><span class="main">.</span> <span class="main">⟦</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">x'</span><span class="main">)</span><span class="main">∈</span><span class="free">R</span><span class="main">;</span> <span class="free">b</span> <span class="bound">x</span><span class="main">;</span> <span class="free">b'</span> <span class="bound">x'</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">≤</span> <span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="main">(</span><span class="free">f'</span> <span class="bound">x'</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"EWHILET <span class="free">b</span> <span class="free">f</span> <span class="free">x</span> <span class="main">≤</span><span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="main">(</span>EWHILET <span class="free">b'</span> <span class="free">f'</span> <span class="free">x'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> <span class="dynamic"><span class="dynamic">enres_unfolds</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_rcg</span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> sum.splits <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> econc_fun_def<span class="main">)</span>

<span class="keyword1"><span class="command">thm</span></span> WHILEIT_refine

<span class="keyword1" id="Exc_Nres_Monad-EWHILEIT_refine"><span class="command">lemma</span></span> EWHILEIT_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> R0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">I'</span> <span class="free">x'</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">x'</span><span class="main">)</span><span class="main">∈</span><span class="free">R</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> I_REF<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">x'</span><span class="main">.</span> <span class="main">⟦</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">x'</span><span class="main">)</span><span class="main">∈</span><span class="free">R</span><span class="main">;</span> <span class="free">I'</span> <span class="bound">x'</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">I</span> <span class="bound">x</span>"</span></span>  
  <span class="keyword2"><span class="keyword">assumes</span></span> COND_REF<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">x'</span><span class="main">.</span> <span class="main">⟦</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">x'</span><span class="main">)</span><span class="main">∈</span><span class="free">R</span><span class="main">;</span> <span class="free">I</span> <span class="bound">x</span><span class="main">;</span> <span class="free">I'</span> <span class="bound">x'</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">b</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">b'</span> <span class="bound">x'</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> STEP_REF<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">x'</span><span class="main">.</span> <span class="main">⟦</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">x'</span><span class="main">)</span><span class="main">∈</span><span class="free">R</span><span class="main">;</span> <span class="free">b</span> <span class="bound">x</span><span class="main">;</span> <span class="free">b'</span> <span class="bound">x'</span><span class="main">;</span> <span class="free">I</span> <span class="bound">x</span><span class="main">;</span> <span class="free">I'</span> <span class="bound">x'</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">≤</span> <span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="main">(</span><span class="free">f'</span> <span class="bound">x'</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"EWHILEIT <span class="free">I</span> <span class="free">b</span> <span class="free">f</span> <span class="free">x</span> <span class="main">≤</span><span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="main">(</span>EWHILEIT <span class="free">I'</span> <span class="free">b'</span> <span class="free">f'</span> <span class="free">x'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> <span class="dynamic"><span class="dynamic">enres_unfolds</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_rcg</span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> sum.splits <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> econc_fun_def<span class="main">)</span>



<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Refine2- heuristics›</span></span>

<span class="keyword1" id="Exc_Nres_Monad-remove_eLet_refine"><span class="command">lemma</span></span> remove_eLet_refine<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">M</span> <span class="main">≤</span> <span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="main">(</span><span class="free">f</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">M</span> <span class="main">≤</span> <span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="main">(</span>Let <span class="free">x</span> <span class="free">f</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Exc_Nres_Monad-intro_eLet_refine"><span class="command">lemma</span></span> intro_eLet_refine<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="free">x</span> <span class="main">≤</span> <span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="free">M'</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Let <span class="free">x</span> <span class="free">f</span> <span class="main">≤</span> <span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="free">M'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Exc_Nres_Monad-ebind2let_refine"><span class="command">lemma</span></span> ebind2let_refine<span class="main">[</span><span class="operator">refine2</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ERETURN <span class="free">x</span> <span class="main">≤</span> <span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R'</span> <span class="free">M'</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x'</span><span class="main">.</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="bound">x'</span><span class="main">)</span><span class="main">∈</span><span class="free">R'</span> <span class="main">⟹</span> <span class="free">f</span> <span class="free">x</span> <span class="main">≤</span> <span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="main">(</span><span class="free">f'</span> <span class="bound">x'</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Let <span class="free">x</span> <span class="free">f</span> <span class="main">≤</span> <span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="main">(</span>ebind <span class="free">M'</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x'</span><span class="main">.</span> <span class="free">f'</span> <span class="bound">x'</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pw_ele_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fast</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Exc_Nres_Monad-ebind_Let_refine2"><span class="command">lemma</span></span> ebind_Let_refine2<span class="main">[</span><span class="operator">refine2</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> 
    <span class="free">m'</span> <span class="main">≤</span><span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R'</span> <span class="main">(</span>ERETURN <span class="free">x</span><span class="main">)</span><span class="main">;</span>
    <span class="main">⋀</span><span class="bound">x'</span><span class="main">.</span> <span class="main">⟦</span>inres <span class="free">m'</span> <span class="main">(</span>Inr <span class="bound">x'</span><span class="main">)</span><span class="main">;</span> <span class="main">(</span><span class="bound">x'</span><span class="main">,</span><span class="free">x</span><span class="main">)</span><span class="main">∈</span><span class="free">R'</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">f'</span> <span class="bound">x'</span> <span class="main">≤</span> <span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="main">(</span><span class="free">f</span> <span class="free">x</span><span class="main">)</span> 
  <span class="main">⟧</span> <span class="main">⟹</span> ebind <span class="free">m'</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x'</span><span class="main">.</span> <span class="free">f'</span> <span class="bound">x'</span><span class="main">)</span> <span class="main">≤</span> <span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="main">(</span>Let <span class="free">x</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pw_ele_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Exc_Nres_Monad-ebind2letRETURN_refine"><span class="command">lemma</span></span> ebind2letRETURN_refine<span class="main">[</span><span class="operator">refine2</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ERETURN <span class="free">x</span> <span class="main">≤</span> <span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R'</span> <span class="free">M'</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x'</span><span class="main">.</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="bound">x'</span><span class="main">)</span><span class="main">∈</span><span class="free">R'</span> <span class="main">⟹</span> ERETURN <span class="main">(</span><span class="free">f</span> <span class="free">x</span><span class="main">)</span> <span class="main">≤</span> <span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="main">(</span><span class="free">f'</span> <span class="bound">x'</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ERETURN <span class="main">(</span>Let <span class="free">x</span> <span class="free">f</span><span class="main">)</span> <span class="main">≤</span> <span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="main">(</span>ebind <span class="free">M'</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x'</span><span class="main">.</span> <span class="free">f'</span> <span class="bound">x'</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pw_ele_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fast</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Exc_Nres_Monad-ERETURN_as_SPEC_refine"><span class="command">lemma</span></span> ERETURN_as_SPEC_refine<span class="main">[</span><span class="operator">refine2</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"RELATES <span class="free">R</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">M</span> <span class="main">≤</span> ESPEC <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> False<span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">c</span><span class="main">.</span> <span class="main">(</span><span class="bound">c</span><span class="main">,</span><span class="free">a</span><span class="main">)</span><span class="main">∈</span><span class="free">R</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">M</span> <span class="main">≤</span> <span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="main">(</span>ERETURN <span class="free">a</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pw_ele_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>

<span class="keyword1" id="Exc_Nres_Monad-if_ERETURN_refine"><span class="command">lemma</span></span> if_ERETURN_refine<span class="main">[</span><span class="operator">refine2</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">⟷</span> <span class="free">b'</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">b</span><span class="main">;</span><span class="free">b'</span><span class="main">⟧</span> <span class="main">⟹</span> ERETURN <span class="free">S1</span> <span class="main">≤</span> <span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="free">S1'</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">¬</span><span class="free">b</span><span class="main">;</span><span class="main">¬</span><span class="free">b'</span><span class="main">⟧</span> <span class="main">⟹</span> ERETURN <span class="free">S2</span> <span class="main">≤</span> <span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="free">S2'</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"ERETURN <span class="main">(</span><span class="keyword1">if</span> <span class="free">b</span> <span class="keyword1">then</span> <span class="free">S1</span> <span class="keyword1">else</span> <span class="free">S2</span><span class="main">)</span> <span class="main">≤</span> <span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">E</span> <span class="free">R</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">b'</span> <span class="keyword1">then</span> <span class="free">S1'</span> <span class="keyword1">else</span> <span class="free">S2'</span><span class="main">)</span>"</span></span>
  <span class="comment1">(* this is nice to have for small functions, hence keep it in refine2 *)</span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pw_le_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>



<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Breaking down enres-monad ›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">enres_lift</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> nres <span class="main">⇒</span> <span class="main">(</span><span class="main">_</span><span class="main">,</span><span class="tfree">'a</span><span class="main">)</span> enres"</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">enres_lift</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span> <span class="bound">x</span> <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">;</span> RETURN <span class="main">(</span>Inr <span class="bound">x</span><span class="main">)</span> <span class="main">}</span>"</span></span>

<span class="keyword1" id="Exc_Nres_Monad-enres_lift_rule"><span class="command">lemma</span></span> enres_lift_rule<span class="main">[</span><span class="operator">refine_vcg</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">m</span><span class="main">≤</span>SPEC <span class="free">Φ</span> <span class="main">⟹</span> enres_lift <span class="free">m</span> <span class="main">≤</span> ESPEC <span class="free">E</span> <span class="free">Φ</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_ele_iff pw_le_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span> enres_lift_def<span class="main">)</span>
  
<span class="keyword1"><span class="command">named_theorems_rev</span></span> enres_breakdown  
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">enres_breakdown</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"ERETURN <span class="free">x</span> <span class="main">=</span> enres_lift <span class="main">(</span>RETURN <span class="free">x</span><span class="main">)</span>"</span></span>  
  <span class="quoted"><span class="quoted">"EASSERT <span class="free">Φ</span> <span class="main">=</span> enres_lift <span class="main">(</span>ASSERT <span class="free">Φ</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="keyword1">doE</span> <span class="main">{</span> <span class="bound">x</span> <span class="main">←</span> enres_lift <span class="free">m</span><span class="main">;</span> <span class="free">ef</span> <span class="bound">x</span> <span class="main">}</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span> <span class="bound">x</span> <span class="main">←</span> <span class="free">m</span><span class="main">;</span> <span class="free">ef</span> <span class="bound">x</span> <span class="main">}</span>"</span></span>
  <span class="comment1">(*"NO_MATCH (enres_lift m) em ⟹ doE { x ← em; ef x } = do { ex ← em; case ex of Inl e ⇒ RETURN (Inl e) | Inr x ⇒ ef x }"*)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> <span class="dynamic"><span class="dynamic">enres_unfolds</span></span> enres_lift_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> sum.splits <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_eq_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">enres_breakdown</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="keyword1">do</span> <span class="main">{</span> <span class="bound">x</span> <span class="main">←</span> <span class="free">m</span><span class="main">;</span> enres_lift <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">}</span> <span class="main">=</span> enres_lift <span class="main">(</span><span class="keyword1">do</span> <span class="main">{</span> <span class="bound">x</span> <span class="main">←</span> <span class="free">m</span><span class="main">;</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="keyword1">do</span> <span class="main">{</span> <span class="keyword1">let</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">v</span><span class="main">;</span> enres_lift <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">}</span> <span class="main">=</span> enres_lift <span class="main">(</span><span class="keyword1">do</span> <span class="main">{</span> <span class="keyword1">let</span> <span class="bound">x</span><span class="main">=</span><span class="free">v</span><span class="main">;</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> <span class="dynamic"><span class="dynamic">enres_unfolds</span></span> enres_lift_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> sum.splits <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_eq_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">enres_breakdown</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"CATCH <span class="main">(</span>enres_lift <span class="free">m</span><span class="main">)</span> <span class="free">h</span> <span class="main">=</span> enres_lift <span class="free">m</span>"</span></span>  
  <span class="keyword1"><span class="command">unfolding</span></span> <span class="dynamic"><span class="dynamic">enres_unfolds</span></span> enres_lift_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> sum.splits <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_eq_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  
<span class="keyword1" id="Exc_Nres_Monad-enres_lift_fail"><span class="command">lemma</span></span> enres_lift_fail<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>  <span class="quoted"><span class="quoted">"enres_lift FAIL <span class="main">=</span> FAIL"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> enres_lift_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>


<span class="comment1">(* TODO: Also do breakdown-thm for RECT. It's exactly the same approach! *)</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">enres_breakdown</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"EWHILEIT <span class="free">I</span> <span class="free">c</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> enres_lift <span class="main">(</span><span class="free">f</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span> <span class="free">s</span> <span class="main">=</span> enres_lift <span class="main">(</span>WHILEIT <span class="free">I</span> <span class="free">c</span> <span class="free">f</span> <span class="free">s</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> antisym<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">≤</span> <span class="var">?rhs</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> <span class="dynamic"><span class="dynamic">enres_unfolds</span></span> WHILEIT_def WHILET_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> RECT_transfer_rel'<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> P<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">c</span> <span class="bound">a</span><span class="main">.</span> <span class="bound">c</span> <span class="main">=</span> Inr <span class="bound">a</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> while.WHILEI_body_trimono<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> while.WHILEI_body_trimono<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> WHILEI_body_def enres_lift_def pw_le_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?rhs</span> <span class="main">≤</span> <span class="var">?lhs</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> <span class="dynamic"><span class="dynamic">enres_unfolds</span></span> WHILEIT_def WHILET_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> RECT_transfer_rel'<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> P<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">a</span> <span class="bound">c</span><span class="main">.</span> <span class="bound">c</span> <span class="main">=</span> Inr <span class="bound">a</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> while.WHILEI_body_trimono<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> while.WHILEI_body_trimono<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> WHILEI_body_def enres_lift_def pw_le_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>    



<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">enres_breakdown</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"EWHILET <span class="free">c</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> enres_lift <span class="main">(</span><span class="free">f</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span> <span class="free">s</span> <span class="main">=</span> enres_lift <span class="main">(</span>WHILET <span class="free">c</span> <span class="free">f</span> <span class="free">s</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> EWHILET_def WHILET_def <span class="dynamic"><span class="dynamic">enres_breakdown</span></span> <span class="keyword1"><span class="command">..</span></span>
  
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">enres_breakdown</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"enfoldli <span class="free">l</span> <span class="free">c</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">s</span><span class="main">.</span> enres_lift <span class="main">(</span><span class="free">f</span> <span class="bound">x</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span> <span class="free">s</span> <span class="main">=</span> enres_lift <span class="main">(</span>nfoldli <span class="free">l</span> <span class="free">c</span> <span class="free">f</span> <span class="free">s</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">l</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">s</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">enres_breakdown</span></span><span class="main">)</span>  
    
    
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">enres_breakdown</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span><span class="main">.</span> enres_lift <span class="main">(</span><span class="free">f</span> <span class="bound">a</span> <span class="bound">b</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> enres_lift <span class="main">(</span><span class="keyword1">case</span> <span class="bound">x</span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span> <span class="main">⇒</span> <span class="free">f</span> <span class="bound">a</span> <span class="bound">b</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">enres_breakdown</span><span class="main">]</span> <span class="main">=</span> nres_monad_laws nres_bind_let_law

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">enres_breakdown</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="keyword1">doE</span> <span class="main">{</span> CHECK <span class="free">Φ</span> <span class="free">e</span><span class="main">;</span> <span class="free">m</span> <span class="main">}</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">Φ</span> <span class="keyword1">then</span> <span class="free">m</span> <span class="keyword1">else</span> THROW <span class="free">e</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">enres_unfolds</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">enres_breakdown</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">if</span> <span class="free">b</span> <span class="keyword1">then</span> enres_lift <span class="free">m</span> <span class="keyword1">else</span> enres_lift <span class="free">n</span><span class="main">)</span> <span class="main">=</span> enres_lift <span class="main">(</span><span class="keyword1">if</span> <span class="free">b</span> <span class="keyword1">then</span> <span class="free">m</span> <span class="keyword1">else</span> <span class="free">n</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Exc_Nres_Monad-option_case_enbd"><span class="command">lemma</span></span> option_case_enbd<span class="main">[</span><span class="operator">enres_breakdown</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"case_option <span class="main">(</span>enres_lift <span class="free">fn</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> enres_lift <span class="main">(</span><span class="free">fs</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> enres_lift <span class="main">(</span>case_option <span class="free">fn</span> <span class="free">fs</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
    
    
    
<span class="keyword1"><span class="command">named_theorems</span></span> enres_inline
    
<span class="keyword1"><span class="command">method</span></span> opt_enres_unfold <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="operator">unfold</span> <span class="dynamic"><span class="dynamic">enres_inline</span></span><span class="main">)</span><span class="main"><span class="keyword3">?</span></span><span class="main"><span class="keyword3">;</span></span> <span class="main">(</span><span class="operator">unfold</span> enres_monad_laws<span class="main">)</span><span class="main"><span class="keyword3">?</span></span><span class="main"><span class="keyword3">;</span></span> <span class="main">(</span><span class="operator">unfold</span> <span class="dynamic"><span class="dynamic">enres_breakdown</span></span><span class="main">)</span><span class="main"><span class="keyword3">?</span></span><span class="main"><span class="keyword3">;</span></span> <span class="main">(</span><span class="operator">rule</span> refl<span class="main">)</span><span class="main"><span class="keyword3">?</span></span><span class="main"><span class="keyword3">;</span></span> <span class="main">(</span><span class="operator">unfold</span> <span class="dynamic"><span class="dynamic">enres_unfolds</span></span> enres_lift_def nres_monad_laws<span class="main">)</span><span class="main"><span class="keyword3">?</span></span><span class="main"><span class="keyword3">;</span></span> <span class="main">(</span><span class="operator">rule</span> refl<span class="main">)</span><span class="main"><span class="keyword3">?</span></span><span class="main">)</span>

  
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹More Combinators›</span></span>  
  <span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹CHECK-Monadic›</span></span>
    
  <span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">enres_unfolds</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">CHECK_monadic</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">≡</span> <span class="keyword1">doE</span> <span class="main">{</span> <span class="bound">b</span> <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">;</span> CHECK <span class="bound">b</span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">}</span>"</span></span>
  
  <span class="keyword1" id="Exc_Nres_Monad-CHECK_monadic_rule_iff"><span class="command">lemma</span></span> CHECK_monadic_rule_iff<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span>CHECK_monadic <span class="free">c</span> <span class="free">e</span> <span class="main">≤</span> ESPEC <span class="free">E</span> <span class="free">P</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">c</span> <span class="main">≤</span> ESPEC <span class="free">E</span> <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="main">(</span><span class="bound">r</span> <span class="main">⟶</span> <span class="free">P</span> <span class="main">()</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">¬</span><span class="bound">r</span> <span class="main">⟶</span> <span class="free">E</span> <span class="free">e</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_ele_iff CHECK_monadic_def <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>
  
  <span class="keyword1" id="Exc_Nres_Monad-CHECK_monadic_pw"><span class="command">lemma</span></span> CHECK_monadic_pw<span class="main">[</span><span class="operator">refine_pw_simps</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"nofail <span class="main">(</span>CHECK_monadic <span class="free">c</span> <span class="free">e</span><span class="main">)</span> <span class="main">⟷</span> nofail <span class="free">c</span>"</span></span>
    <span class="quoted"><span class="quoted">"inres <span class="main">(</span>CHECK_monadic <span class="free">c</span> <span class="free">e</span><span class="main">)</span> <span class="main">(</span>Inl <span class="free">ee</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span>inres <span class="free">c</span> <span class="main">(</span>Inl <span class="free">ee</span><span class="main">)</span> <span class="main">∨</span> inres <span class="free">c</span> <span class="main">(</span>Inr False<span class="main">)</span> <span class="main">∧</span> <span class="free">ee</span><span class="main">=</span><span class="free">e</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"inres <span class="main">(</span>CHECK_monadic <span class="free">c</span> <span class="free">e</span><span class="main">)</span> <span class="main">(</span>Inr <span class="free">x</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span>inres <span class="free">c</span> <span class="main">(</span>Inr True<span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> CHECK_monadic_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>
  
  <span class="keyword1" id="Exc_Nres_Monad-CHECK_monadic_rule"><span class="command">lemma</span></span> CHECK_monadic_rule<span class="main">[</span><span class="operator">refine_vcg</span><span class="main">]</span><span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">≤</span> ESPEC <span class="free">E</span> <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="main">(</span><span class="bound">r</span> <span class="main">⟶</span> <span class="free">P</span> <span class="main">()</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">¬</span><span class="bound">r</span> <span class="main">⟶</span> <span class="free">E</span> <span class="free">e</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"CHECK_monadic <span class="free">c</span> <span class="free">e</span> <span class="main">≤</span> ESPEC <span class="free">E</span> <span class="free">P</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> CHECK_monadic_rule_iff<span class="main">)</span>  
  
  <span class="keyword1" id="Exc_Nres_Monad-CHECK_monadic_refine"><span class="command">lemma</span></span> CHECK_monadic_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">ci</span> <span class="main">≤</span> <span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">ER</span> bool_rel <span class="free">c</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">ei</span><span class="main">,</span><span class="free">e</span><span class="main">)</span><span class="main">∈</span><span class="free">ER</span>"</span></span>  
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"CHECK_monadic <span class="free">ci</span> <span class="free">ei</span> <span class="main">≤</span><span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">ER</span> unit_rel <span class="main">(</span>CHECK_monadic <span class="free">c</span> <span class="free">e</span><span class="main">)</span>"</span></span>  
    <span class="keyword1"><span class="command">using</span></span> assms  
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_ele_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>
  
  <span class="keyword1" id="Exc_Nres_Monad-CHECK_monadic_CHECK_refine"><span class="command">lemma</span></span> CHECK_monadic_CHECK_refine<span class="main">[</span><span class="operator">refine</span><span class="main">]</span><span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">ci</span> <span class="main">≤</span> ESPEC <span class="main">(</span><span class="main">λ</span><span class="bound">e'</span><span class="main">.</span> <span class="main">(</span><span class="bound">e'</span><span class="main">,</span><span class="free">e</span><span class="main">)</span><span class="main">∈</span><span class="free">ER</span> <span class="main">∧</span> <span class="main">¬</span><span class="free">c</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="bound">r</span> <span class="main">⟷</span> <span class="free">c</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">ei</span><span class="main">,</span><span class="free">e</span><span class="main">)</span><span class="main">∈</span><span class="free">ER</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"CHECK_monadic <span class="free">ci</span> <span class="free">ei</span> <span class="main">≤</span><span class="keyword1">⇓<span class="hidden">⇩</span><sub>E</sub></span> <span class="free">ER</span> unit_rel <span class="main">(</span>CHECK <span class="free">c</span> <span class="free">e</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms  
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pw_ele_iff <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>
  
  <span class="keyword1" id="Exc_Nres_Monad-CHECK_monadic_endb"><span class="command">lemma</span></span> CHECK_monadic_endb<span class="main">[</span><span class="operator">enres_breakdown</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"CHECK_monadic <span class="main">(</span>enres_lift <span class="free">c</span><span class="main">)</span> <span class="free">e</span> <span class="main">=</span> 
    <span class="keyword1">do</span> <span class="main">{</span><span class="bound">b</span> <span class="main">←</span> <span class="free">c</span><span class="main">;</span> CHECK <span class="bound">b</span> <span class="free">e</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">enres_unfolds</span></span> enres_lift_def<span class="main">)</span>
  
  
  
  
  

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="VTcomp">
<div class="head">
<h1>Theory VTcomp</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">theory</span></span> VTcomp
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="Exc_Nres_Monad.html">Exc_Nres_Monad</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Library›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
This theory contains a collection of auxiliary material that was used as a library for the contest.
›</span></span>

<span class="keyword1" id="VTcomp-monadic_WHILEIT_unfold"><span class="command">lemma</span></span> monadic_WHILEIT_unfold<span class="main">:</span>
  <span class="quoted"><span class="quoted">"monadic_WHILEIT <span class="free">I</span> <span class="free">b</span> <span class="free">f</span> <span class="free">s</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
    ASSERT <span class="main">(</span><span class="free">I</span> <span class="free">s</span><span class="main">)</span><span class="main">;</span> <span class="bound">bb</span><span class="main">←</span><span class="free">b</span> <span class="free">s</span><span class="main">;</span> <span class="keyword1">if</span> <span class="bound">bb</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="main">{</span> <span class="bound">s</span> <span class="main">←</span> <span class="free">f</span> <span class="free">s</span><span class="main">;</span> monadic_WHILEIT <span class="free">I</span> <span class="free">b</span> <span class="free">f</span> <span class="bound">s</span> <span class="main">}</span> <span class="keyword1">else</span> RETURN <span class="free">s</span>
  <span class="main">}</span>"</span></span>      
  <span class="keyword1"><span class="command">unfolding</span></span> monadic_WHILEIT_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> RECT_unfold<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_mono</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">no_notation</span></span> Ref.lookup <span class="main">(</span><span class="quoted">"<span class="keyword1">!</span>_"</span> 61<span class="main">)</span>
<span class="keyword1"><span class="command">no_notation</span></span> Ref.update <span class="main">(</span><span class="quoted">"_ <span class="keyword1">:=</span> _"</span> 62<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Specialized Rules for Foreach-Loops›</span></span>
<span class="keyword1" id="VTcomp-nfoldli_upt_rule"><span class="command">lemma</span></span> nfoldli_upt_rule<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> INTV<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">lb</span><span class="main">≤</span><span class="free">ub</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> I0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">I</span> <span class="free">lb</span> <span class="free">σ0</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> IS<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">i</span> <span class="bound">σ</span><span class="main">.</span> <span class="main">⟦</span> <span class="free">lb</span><span class="main">≤</span><span class="bound">i</span><span class="main">;</span> <span class="bound">i</span><span class="main">&lt;</span><span class="free">ub</span><span class="main">;</span> <span class="free">I</span> <span class="bound">i</span> <span class="bound">σ</span><span class="main">;</span> <span class="free">c</span> <span class="bound">σ</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">f</span> <span class="bound">i</span> <span class="bound">σ</span> <span class="main">≤</span> SPEC <span class="main">(</span><span class="free">I</span> <span class="main">(</span><span class="bound">i</span><span class="main">+</span><span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> FNC<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">i</span> <span class="bound">σ</span><span class="main">.</span> <span class="main">⟦</span> <span class="free">lb</span><span class="main">≤</span><span class="bound">i</span><span class="main">;</span> <span class="bound">i</span><span class="main">≤</span><span class="free">ub</span><span class="main">;</span> <span class="free">I</span> <span class="bound">i</span> <span class="bound">σ</span><span class="main">;</span> <span class="main">¬</span><span class="free">c</span> <span class="bound">σ</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">σ</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> FC<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">σ</span><span class="main">.</span> <span class="main">⟦</span> <span class="free">I</span> <span class="free">ub</span> <span class="bound">σ</span><span class="main">;</span> <span class="free">c</span> <span class="bound">σ</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">σ</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"nfoldli <span class="main">[</span><span class="free">lb</span><span class="main">..&lt;</span><span class="free">ub</span><span class="main">]</span> <span class="free">c</span> <span class="free">f</span> <span class="free">σ0</span> <span class="main">≤</span> SPEC <span class="free">P</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> nfoldli_rule<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> I<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">l</span> <span class="main"><span class="bound">_</span></span> <span class="bound">σ</span><span class="main">.</span> <span class="free">I</span> <span class="main">(</span><span class="free">lb</span><span class="main">+</span>length <span class="bound">l</span><span class="main">)</span> <span class="bound">σ</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> I0<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> IS
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Suc_eq_plus1 add_diff_cancel_left' eq_diff_iff le_add1 length_upt upt_eq_lel_conv<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> l1 l2 σ 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> FNC<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> i<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="free">lb</span> <span class="main">+</span> length <span class="skolem">l1</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> INTV<span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> INTV upt_eq_append_conv <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> FC<span class="main">)</span> <span class="keyword1"><span class="command">using</span></span> INTV 
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  


<span class="keyword1"><span class="command">definition</span></span> <span class="main">[</span><span class="operator">enres_unfolds</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">efor</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">lb</span></span></span><span class="main">::</span>int<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">ub</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main">≡</span> <span class="keyword1">doE</span> <span class="main">{</span>
  EASSERT <span class="main">(</span><span class="free"><span class="bound"><span class="entity">lb</span></span></span><span class="main">≤</span><span class="free"><span class="bound"><span class="entity">ub</span></span></span><span class="main">)</span><span class="main">;</span>
  <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">σ</span><span class="main">)</span> <span class="main">←</span> EWHILET <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">i</span><span class="main">,</span><span class="bound">σ</span><span class="main">)</span><span class="main">.</span> <span class="bound">i</span><span class="main">&lt;</span><span class="free"><span class="bound"><span class="entity">ub</span></span></span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">i</span><span class="main">,</span><span class="bound">σ</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">doE</span> <span class="main">{</span> <span class="bound">σ</span> <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">i</span> <span class="bound">σ</span><span class="main">;</span> ERETURN <span class="main">(</span><span class="bound">i</span><span class="main">+</span><span class="main">1</span><span class="main">,</span><span class="bound">σ</span><span class="main">)</span> <span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">lb</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">)</span><span class="main">;</span>
  ERETURN <span class="bound">σ</span>
<span class="main">}</span>"</span></span>  
  
<span class="keyword1" id="VTcomp-efor_rule"><span class="command">lemma</span></span> efor_rule<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> INTV<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">lb</span><span class="main">≤</span><span class="free">ub</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> I0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">I</span> <span class="free">lb</span> <span class="free">σ0</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> IS<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">i</span> <span class="bound">σ</span><span class="main">.</span> <span class="main">⟦</span> <span class="free">lb</span><span class="main">≤</span><span class="bound">i</span><span class="main">;</span> <span class="bound">i</span><span class="main">&lt;</span><span class="free">ub</span><span class="main">;</span> <span class="free">I</span> <span class="bound">i</span> <span class="bound">σ</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">f</span> <span class="bound">i</span> <span class="bound">σ</span> <span class="main">≤</span> ESPEC <span class="free">E</span> <span class="main">(</span><span class="free">I</span> <span class="main">(</span><span class="bound">i</span><span class="main">+</span><span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> FC<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">σ</span><span class="main">.</span> <span class="main">⟦</span> <span class="free">I</span> <span class="free">ub</span> <span class="bound">σ</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">σ</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"efor <span class="free">lb</span> <span class="free">ub</span> <span class="free">f</span> <span class="free">σ0</span> <span class="main">≤</span> ESPEC <span class="free">E</span> <span class="free">P</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> efor_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">supply</span></span></span></span> EWHILET_rule<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"measure <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">i</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> nat <span class="main">(</span><span class="free">ub</span><span class="main">-</span><span class="bound">i</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> I<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="bound">i</span><span class="main">,</span><span class="bound">σ</span><span class="main">)</span><span class="main">.</span> <span class="free">lb</span><span class="main">≤</span><span class="bound">i</span> <span class="main">∧</span> <span class="bound">i</span><span class="main">≤</span><span class="free">ub</span> <span class="main">∧</span> <span class="free">I</span> <span class="bound">i</span> <span class="bound">σ</span>"</span></span><span class="main">,</span> <span class="operator">refine_vcg</span><span class="main">]</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">refine_vcg</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  
  
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Improved Do-Notation for the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>nres›</span></span></span></span>-Monad›</span></span>  

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>do_notation<span class="main">)</span> <span class="entity">bind_doN</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">bind_doN</span> <span class="main">≡</span> Refine_Basic.bind"</span></span>

<span class="keyword1"><span class="command">notation</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">output</span></span><span class="main">)</span> bind_doN <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">⤜</span>"</span> 54<span class="main">)</span>
<span class="keyword1"><span class="command">notation</span></span> <span class="main">(</span>ASCII <span class="keyword2"><span class="keyword">output</span></span><span class="main">)</span> bind_doN <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">&gt;&gt;=</span>"</span> 54<span class="main">)</span>

<span class="keyword1"><span class="command">nonterminal</span></span> doN_binds <span class="keyword2"><span class="keyword">and</span></span> doN_bind
<span class="keyword1"><span class="command">syntax</span></span>
  <span class="quoted">"_doN_block"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"doN_binds <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">doN</span> <span class="keyword1">{</span><span class="keyword3">//</span><span class="keyword3">(2</span>  _<span class="keyword3">)</span><span class="keyword3">//</span><span class="keyword1">}</span>"</span> <span class="main">[</span>12<span class="main">]</span> 62<span class="main">)</span>
  <span class="quoted">"_doN_bind"</span>  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[</span>pttrn<span class="main">,</span> <span class="tfree">'a</span><span class="main">]</span> <span class="main">⇒</span> doN_bind"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword3">(2</span>_ <span class="keyword1">←</span><span class="keyword3">/ </span>_<span class="keyword3">)</span>"</span> 13<span class="main">)</span>
  <span class="quoted">"_doN_let"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[</span>pttrn<span class="main">,</span> <span class="tfree">'a</span><span class="main">]</span> <span class="main">⇒</span> doN_bind"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword3">(2</span><span class="keyword1">let</span> _ <span class="keyword1">=</span><span class="keyword3">/ </span>_<span class="keyword3">)</span>"</span> <span class="main">[</span>1000<span class="main">,</span> 13<span class="main">]</span> 13<span class="main">)</span>
  <span class="quoted">"_doN_then"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> doN_bind"</span></span> <span class="main">(</span><span class="quoted">"_"</span> <span class="main">[</span>14<span class="main">]</span> 13<span class="main">)</span>
  <span class="quoted">"_doN_final"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> doN_binds"</span></span> <span class="main">(</span><span class="quoted">"_"</span><span class="main">)</span>
  <span class="quoted">"_doN_cons"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[</span>doN_bind<span class="main">,</span> doN_binds<span class="main">]</span> <span class="main">⇒</span> doN_binds"</span></span> <span class="main">(</span><span class="quoted">"_<span class="keyword1">;</span><span class="keyword3">//</span>_"</span> <span class="main">[</span>13<span class="main">,</span> 12<span class="main">]</span> 12<span class="main">)</span>
  <span class="quoted">"_thenM"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">]</span> <span class="main">⇒</span> <span class="tfree">'c</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">⪢</span>"</span> 54<span class="main">)</span>

<span class="keyword1"><span class="command">syntax</span></span> <span class="main">(</span>ASCII<span class="main">)</span>
  <span class="quoted">"_doN_bind"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[</span>pttrn<span class="main">,</span> <span class="tfree">'a</span><span class="main">]</span> <span class="main">⇒</span> doN_bind"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword3">(2</span>_ <span class="keyword1">&lt;-</span><span class="keyword3">/ </span>_<span class="keyword3">)</span>"</span> 13<span class="main">)</span>
  <span class="quoted">"_thenM"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">]</span> <span class="main">⇒</span> <span class="tfree">'c</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">&gt;&gt;</span>"</span> 54<span class="main">)</span>

<span class="keyword1"><span class="command">translations</span></span>
  <span class="quoted">"_doN_block <span class="main">(</span>_doN_cons <span class="main">(</span>_doN_then <span class="free">t</span><span class="main">)</span> <span class="main">(</span>_doN_final <span class="free">e</span><span class="main">)</span><span class="main">)</span>"</span>
    <span class="main">⇌</span> <span class="quoted">"<span class="keyword1">CONST</span> bind_doN <span class="free">t</span> <span class="main">(</span><span class="main">λ</span><span class="main">_</span><span class="main">.</span> <span class="free">e</span><span class="main">)</span>"</span>
  <span class="quoted">"_doN_block <span class="main">(</span>_doN_cons <span class="main">(</span>_doN_bind <span class="free">p</span> <span class="free">t</span><span class="main">)</span> <span class="main">(</span>_doN_final <span class="free">e</span><span class="main">)</span><span class="main">)</span>"</span>
    <span class="main">⇌</span> <span class="quoted">"<span class="keyword1">CONST</span> bind_doN <span class="free">t</span> <span class="main">(</span><span class="main">λ</span><span class="free">p</span><span class="main">.</span> <span class="free">e</span><span class="main">)</span>"</span>
  <span class="quoted">"_doN_block <span class="main">(</span>_doN_cons <span class="main">(</span>_doN_let <span class="free">p</span> <span class="free">t</span><span class="main">)</span> <span class="free">bs</span><span class="main">)</span>"</span>
    <span class="main">⇌</span> <span class="quoted">"<span class="keyword1">let</span> <span class="free">p</span> <span class="main">=</span> <span class="free">t</span> <span class="keyword1">in</span> _doN_block <span class="free">bs</span>"</span>
  <span class="quoted">"_doN_block <span class="main">(</span>_doN_cons <span class="free">b</span> <span class="main">(</span>_doN_cons <span class="free">c</span> <span class="free">cs</span><span class="main">)</span><span class="main">)</span>"</span>
    <span class="main">⇌</span> <span class="quoted">"_doN_block <span class="main">(</span>_doN_cons <span class="free">b</span> <span class="main">(</span>_doN_final <span class="main">(</span>_doN_block <span class="main">(</span>_doN_cons <span class="free">c</span> <span class="free">cs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span>
  <span class="quoted">"_doN_cons <span class="main">(</span>_doN_let <span class="free">p</span> <span class="free">t</span><span class="main">)</span> <span class="main">(</span>_doN_final <span class="free">s</span><span class="main">)</span>"</span>
    <span class="main">⇌</span> <span class="quoted">"_doN_final <span class="main">(</span><span class="keyword1">let</span> <span class="free">p</span> <span class="main">=</span> <span class="free">t</span> <span class="keyword1">in</span> <span class="free">s</span><span class="main">)</span>"</span>
  <span class="quoted">"_doN_block <span class="main">(</span>_doN_final <span class="free">e</span><span class="main">)</span>"</span> <span class="main">⇀</span> <span class="quoted">"<span class="free">e</span>"</span>
  <span class="quoted">"<span class="main">(</span><span class="free">m</span> <span class="main">⪢</span> <span class="free">n</span><span class="main">)</span>"</span> <span class="main">⇀</span> <span class="quoted">"<span class="main">(</span><span class="free">m</span> <span class="main">⤜</span> <span class="main">(</span><span class="main">λ</span><span class="main">_</span><span class="main">.</span> <span class="free">n</span><span class="main">)</span><span class="main">)</span>"</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Array Blit exposed to Sepref›</span></span>  

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">op_list_blit</span> <span class="free"><span class="bound"><span class="entity">src</span></span></span> <span class="free"><span class="bound"><span class="entity">si</span></span></span> <span class="free"><span class="bound"><span class="entity">dst</span></span></span> <span class="free"><span class="bound"><span class="entity">di</span></span></span> <span class="free"><span class="bound"><span class="entity">len</span></span></span> <span class="main">≡</span> 
    <span class="main">(</span>take <span class="free"><span class="bound"><span class="entity">di</span></span></span> <span class="free"><span class="bound"><span class="entity">dst</span></span></span> <span class="main">@</span> take <span class="free"><span class="bound"><span class="entity">len</span></span></span> <span class="main">(</span>drop <span class="free"><span class="bound"><span class="entity">si</span></span></span> <span class="free"><span class="bound"><span class="entity">src</span></span></span><span class="main">)</span> <span class="main">@</span> drop <span class="main">(</span><span class="free"><span class="bound"><span class="entity">di</span></span></span><span class="main">+</span><span class="free"><span class="bound"><span class="entity">len</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">dst</span></span></span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">context</span></span> 
    <span class="keyword2"><span class="keyword">notes</span></span> op_list_blit_def<span class="main">[</span><span class="operator">simp</span><span class="main">]</span> 
  <span class="keyword2"><span class="keyword">begin</span></span>  
    <span class="keyword1"><span class="command">sepref_decl_op</span></span> <span class="main">(</span>no_def<span class="main">)</span> list_blit <span class="main">:</span> 
      <span class="quoted"><span class="quoted">"op_list_blit"</span></span> 
      <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">λ</span><span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="bound">src</span><span class="main">,</span><span class="bound">si</span><span class="main">)</span><span class="main">,</span><span class="bound">dst</span><span class="main">)</span><span class="main">,</span><span class="bound">di</span><span class="main">)</span><span class="main">,</span><span class="bound">len</span><span class="main">)</span><span class="main">.</span> <span class="bound">si</span><span class="main">+</span><span class="bound">len</span> <span class="main">≤</span> length <span class="bound">src</span> <span class="main">∧</span> <span class="bound">di</span><span class="main">+</span><span class="bound">len</span> <span class="main">≤</span> length <span class="bound">dst</span><span class="keyword1">]<span class="hidden">⇩</span><sub>f</sub></span>  
        <span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="main">⟨</span><span class="free">A</span><span class="main">⟩</span>list_rel <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> nat_rel<span class="main">)</span> <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> <span class="main">⟨</span><span class="free">A</span><span class="main">⟩</span>list_rel<span class="main">)</span> <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> nat_rel<span class="main">)</span> <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> nat_rel<span class="main">)</span> <span class="main">→</span> <span class="main">⟨</span><span class="free">A</span><span class="main">⟩</span>list_rel"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1" id="VTcomp-blit_len"><span class="command">lemma</span></span> blit_len<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">si</span> <span class="main">+</span> <span class="free">len</span> <span class="main">≤</span> length <span class="free">src</span> <span class="main">∧</span> <span class="free">di</span> <span class="main">+</span> <span class="free">len</span> <span class="main">≤</span> length <span class="free">dst</span> 
    <span class="main">⟹</span> length <span class="main">(</span>op_list_blit <span class="free">src</span> <span class="free">si</span> <span class="free">dst</span> <span class="free">di</span> <span class="free">len</span><span class="main">)</span> <span class="main">=</span> length <span class="free">dst</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> op_list_blit_def<span class="main">)</span>
  
    
  <span class="keyword1"><span class="command">context</span></span> 
    <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="operator">fcomp_norm_unfold</span><span class="main">]</span> <span class="main">=</span> array_assn_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">begin</span></span>    
    <span class="keyword1" id="VTcomp-array_blit_hnr_aux"><span class="command">lemma</span></span> array_blit_hnr_aux<span class="main">:</span> 
          <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry4 <span class="main">(</span><span class="main">λ</span><span class="bound">src</span> <span class="bound">si</span> <span class="bound">dst</span> <span class="bound">di</span> <span class="bound">len</span><span class="main">.</span> <span class="keyword1">do</span> <span class="main">{</span> blit <span class="bound">src</span> <span class="bound">si</span> <span class="bound">dst</span> <span class="bound">di</span> <span class="bound">len</span><span class="main">;</span> return <span class="bound">dst</span> <span class="main">}</span><span class="main">)</span><span class="main">,</span> 
            uncurry4 mop_list_blit<span class="main">)</span> 
      <span class="main">∈</span> is_array<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span><span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span>nat_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span><span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span>is_array<span class="keyword1"><span class="hidden">⇧</span><sup>d</sup></span><span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span>nat_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span><span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span>nat_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> is_array"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">sepref_to_hoare</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">refine_pw_simps</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">sep_auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> is_array_def op_list_blit_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    
    <span class="keyword1"><span class="command">sepref_decl_impl</span></span> <span class="main">(</span>ismop<span class="main">)</span> array_blit<span class="main">:</span> array_blit_hnr_aux <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword2"><span class="keyword">end</span></span>  

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Challenge1A">
<div class="head">
<h1>Theory Challenge1A</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Challenge 1.A›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Challenge1A
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Problem definition:
<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">🌐</span></span>‹https://ethz.ch/content/dam/ethz/special-interest/infk/chair-program-method/pm/documents/Verify%20This/Challenges%202019/ghc_sort.pdf›</span></span>›</span></span>

  <span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Implementation›</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We phrase the algorithm as a functional program. 
    Instead of a list of indexes for segment boundaries,
    we return a list of lists, containing the segments.›</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We start with auxiliary functions to take the longest
    increasing/decreasing sequence from the start of the list
  ›</span></span>  
  <span class="keyword1"><span class="command">fun</span></span> <span class="entity">take_incr</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"int list <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">take_incr</span> <span class="main">[]</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">take_incr</span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">]</span>"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">take_incr</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">&lt;</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">#</span><span class="free">take_incr</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">]</span><span class="main">)</span>"</span></span>  

  <span class="keyword1"><span class="command">fun</span></span> <span class="entity">take_decr</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"int list <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">take_decr</span> <span class="main">[]</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">take_decr</span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">]</span>"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">take_decr</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">≥</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">#</span><span class="free">take_decr</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">]</span><span class="main">)</span>"</span></span>  
  
  <span class="keyword1"><span class="command">fun</span></span> <span class="entity">take</span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">take</span> <span class="main">[]</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">take</span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">]</span>"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">take</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">&lt;</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="keyword1">then</span> take_incr <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="keyword1">else</span> take_decr <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>  

  
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">take2</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">≡</span> <span class="keyword1">let</span> <span class="bound">l</span><span class="main">=</span>take <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">in</span> <span class="main">(</span><span class="bound">l</span><span class="main">,</span>drop <span class="main">(</span>length <span class="bound">l</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>
    <span class="comment1">― ‹Splits of a longest increasing/decreasing sequence from the list›</span>

  
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The main algorithm then iterates until the whole input list is split›</span></span>
  <span class="keyword1"><span class="command">function</span></span> <span class="entity">cuts</span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">cuts</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">=</span><span class="main">[]</span> <span class="keyword1">then</span> <span class="main">[]</span> <span class="keyword1">else</span> <span class="keyword1">let</span> <span class="main">(</span><span class="bound">c</span><span class="main">,</span><span class="bound">xs</span><span class="main">)</span> <span class="main">=</span> take2 <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">in</span> <span class="bound">c</span><span class="main">#</span><span class="free">cuts</span> <span class="bound">xs</span><span class="main">)</span>"</span></span>    
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">pat_completeness</span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Termination›</span></span>  
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹First, we show termination. This will give us induction and proper unfolding lemmas.›</span></span>

  <span class="keyword1" id="Challenge1A-take_non_empty"><span class="command">lemma</span></span> take_non_empty<span class="main">:</span>
    <span class="quoted"><span class="quoted">"take <span class="free">xs</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> that
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> x ys
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">ys</span></span><span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">termination</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">relation</span> <span class="quoted"><span class="quoted">"measure length"</span></span><span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> take2_def Let_def<span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> take_non_empty
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    
  <span class="keyword1"><span class="command">declare</span></span> cuts.simps<span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span>  
    
  <span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Correctness›</span></span>
  

  <span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Property 1: The Exact Sequence is Covered›</span></span>
  <span class="keyword1" id="Challenge1A-tdconc"><span class="command">lemma</span></span> tdconc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">ys</span><span class="main">.</span> <span class="free">xs</span> <span class="main">=</span> take_decr <span class="free">xs</span> <span class="main">@</span> <span class="bound">ys</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> take_decr.induct<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1" id="Challenge1A-ticonc"><span class="command">lemma</span></span> ticonc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">ys</span><span class="main">.</span> <span class="free">xs</span> <span class="main">=</span> take_incr <span class="free">xs</span> <span class="main">@</span> <span class="bound">ys</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> take_incr.induct<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1" id="Challenge1A-take_conc"><span class="command">lemma</span></span> take_conc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">ys</span><span class="main">.</span> <span class="free">xs</span> <span class="main">=</span> take <span class="free">xs</span><span class="main">@</span><span class="bound">ys</span>"</span></span>  
    <span class="keyword1"><span class="command">using</span></span> tdconc ticonc 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> take.cases<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> 
  
  <span class="keyword1"><span class="command">theorem</span></span> concat_cuts<span class="main">:</span> <span class="quoted"><span class="quoted">"concat <span class="main">(</span>cuts <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> cuts.induct<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> cuts.simps<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> take2_def Let_def<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> append_eq_conv_conj take_conc<span class="main">)</span>  
  
        
        
  <span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Property 2: Monotonicity›</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We define constants to specify increasing/decreasing sequences.›</span></span>
  <span class="keyword1"><span class="command">fun</span></span> <span class="entity">incr</span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">incr</span> <span class="main">[]</span> <span class="main">⟷</span> True"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">incr</span> <span class="main">[</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">]</span> <span class="main">⟷</span> True"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">incr</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">&lt;</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">∧</span> <span class="free">incr</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>  
  
  <span class="keyword1"><span class="command">fun</span></span> <span class="entity">decr</span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">decr</span> <span class="main">[]</span> <span class="main">⟷</span> True"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">decr</span> <span class="main">[</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">]</span> <span class="main">⟷</span> True"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">decr</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">≥</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">∧</span> <span class="free">decr</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>  
  
  <span class="keyword1" id="Challenge1A-tki"><span class="command">lemma</span></span> tki<span class="main">:</span> <span class="quoted"><span class="quoted">"incr <span class="main">(</span>take_incr <span class="free">xs</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> take_incr.induct<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">xs</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    
  <span class="keyword1" id="Challenge1A-tkd"><span class="command">lemma</span></span> tkd<span class="main">:</span> <span class="quoted"><span class="quoted">"decr <span class="main">(</span>take_decr <span class="free">xs</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> take_decr.induct<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">xs</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  
  <span class="keyword1" id="Challenge1A-icod"><span class="command">lemma</span></span> icod<span class="main">:</span> <span class="quoted"><span class="quoted">"incr <span class="main">(</span>take <span class="free">xs</span><span class="main">)</span> <span class="main">∨</span> decr <span class="main">(</span>take <span class="free">xs</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> take.cases<span class="main">)</span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> tki tkd <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> take_incr.simps take_decr.simps<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>   
        
  <span class="keyword1"><span class="command">theorem</span></span> cuts_incr_decr<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">c</span><span class="main">∈</span>set <span class="main">(</span>cuts <span class="free">xs</span><span class="main">)</span><span class="main">.</span> incr <span class="bound">c</span> <span class="main">∨</span> decr <span class="bound">c</span>"</span></span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> cuts.induct<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> cuts.simps<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> take2_def Let_def<span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> icod <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    
      
  <span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Property 3: Maximality›</span></span>      
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Specification of a cut that consists of maximal segments:
    The segements are non-empty, and for every two neighbouring segments,
    the first value of the last segment cannot be used to continue the first segment:
  ›</span></span>
  <span class="keyword1"><span class="command">fun</span></span> <span class="entity">maxi</span> <span class="keyword2"><span class="keyword">where</span></span>
     <span class="quoted"><span class="quoted">"<span class="free">maxi</span> <span class="main">[]</span> <span class="main">⟷</span> True"</span></span>
   <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">maxi</span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">]</span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">≠</span><span class="main">[]</span>"</span></span>
   <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">maxi</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">c1</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">c2</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">cs</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">c1</span></span></span><span class="main">≠</span><span class="main">[]</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">c2</span></span></span><span class="main">≠</span><span class="main">[]</span> <span class="main">∧</span> <span class="free">maxi</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">c2</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">cs</span></span></span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span> 
        incr <span class="free"><span class="bound"><span class="entity">c1</span></span></span> <span class="main">∧</span> <span class="main">¬</span><span class="main">(</span>last <span class="free"><span class="bound"><span class="entity">c1</span></span></span> <span class="main">&lt;</span> hd <span class="free"><span class="bound"><span class="entity">c2</span></span></span><span class="main">)</span> 
      <span class="main">∨</span> decr <span class="free"><span class="bound"><span class="entity">c1</span></span></span> <span class="main">∧</span> <span class="main">¬</span><span class="main">(</span>last <span class="free"><span class="bound"><span class="entity">c1</span></span></span> <span class="main">≥</span> hd <span class="free"><span class="bound"><span class="entity">c2</span></span></span><span class="main">)</span>        
        <span class="main">)</span><span class="main">)</span>"</span></span>  

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Obviously, our specification implies that there are no 
    empty segments›</span></span>    
  <span class="keyword1" id="Challenge1A-maxi_imp_non_empty"><span class="command">lemma</span></span> maxi_imp_non_empty<span class="main">:</span> <span class="quoted"><span class="quoted">"maxi <span class="free">xs</span> <span class="main">⟹</span> <span class="main">[]</span><span class="main">∉</span>set <span class="free">xs</span>"</span></span>  
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> maxi.induct<span class="main">)</span> <span class="operator">auto</span>
        
          
  <span class="keyword1" id="Challenge1A-tdconc'"><span class="command">lemma</span></span> tdconc'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span><span class="main">≠</span><span class="main">[]</span> <span class="main">⟹</span> 
    <span class="main">∃</span><span class="bound">ys</span><span class="main">.</span> <span class="free">xs</span> <span class="main">=</span> take_decr <span class="free">xs</span> <span class="main">@</span> <span class="bound">ys</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">ys</span><span class="main">≠</span><span class="main">[]</span> 
      <span class="main">⟶</span> <span class="main">¬</span><span class="main">(</span>last <span class="main">(</span>take_decr <span class="free">xs</span><span class="main">)</span> <span class="main">≥</span> hd <span class="bound">ys</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> take_decr.induct<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">xs</span></span><span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    
  <span class="keyword1" id="Challenge1A-ticonc'"><span class="command">lemma</span></span> ticonc'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span><span class="main">≠</span><span class="main">[]</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">ys</span><span class="main">.</span> <span class="free">xs</span> <span class="main">=</span> take_incr <span class="free">xs</span> <span class="main">@</span> <span class="bound">ys</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">ys</span><span class="main">≠</span><span class="main">[]</span> <span class="main">⟶</span> <span class="main">¬</span><span class="main">(</span>last <span class="main">(</span>take_incr <span class="free">xs</span><span class="main">)</span> <span class="main">&lt;</span> hd <span class="bound">ys</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> take_incr.induct<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">xs</span></span><span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1" id="Challenge1A-take_conc'"><span class="command">lemma</span></span> take_conc'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span><span class="main">≠</span><span class="main">[]</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">ys</span><span class="main">.</span> <span class="free">xs</span> <span class="main">=</span> take <span class="free">xs</span><span class="main">@</span><span class="bound">ys</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">ys</span><span class="main">≠</span><span class="main">[]</span> <span class="main">⟶</span> <span class="main">(</span>
    take <span class="free">xs</span><span class="main">=</span>take_incr <span class="free">xs</span> <span class="main">∧</span> <span class="main">¬</span><span class="main">(</span>last <span class="main">(</span>take_incr <span class="free">xs</span><span class="main">)</span> <span class="main">&lt;</span> hd <span class="bound">ys</span><span class="main">)</span>
  <span class="main">∨</span> take <span class="free">xs</span><span class="main">=</span>take_decr <span class="free">xs</span> <span class="main">∧</span> <span class="main">¬</span><span class="main">(</span>last <span class="main">(</span>take_decr <span class="free">xs</span><span class="main">)</span> <span class="main">≥</span> hd <span class="bound">ys</span><span class="main">)</span>  
  <span class="main">)</span><span class="main">)</span>"</span></span>  
    <span class="keyword1"><span class="command">using</span></span> tdconc' ticonc' 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> take.cases<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> 
    
    
  <span class="keyword1" id="Challenge1A-take_decr_non_empty"><span class="command">lemma</span></span> take_decr_non_empty<span class="main">:</span>
    <span class="quoted"><span class="quoted">"take_decr <span class="free">xs</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> that
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> x ys
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">ys</span></span><span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  
  <span class="keyword1" id="Challenge1A-take_incr_non_empty"><span class="command">lemma</span></span> take_incr_non_empty<span class="main">:</span>
    <span class="quoted"><span class="quoted">"take_incr <span class="free">xs</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> that
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> x ys
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">ys</span></span><span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    
  <span class="keyword1" id="Challenge1A-take_conc''"><span class="command">lemma</span></span> take_conc''<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span><span class="main">≠</span><span class="main">[]</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">ys</span><span class="main">.</span> <span class="free">xs</span> <span class="main">=</span> take <span class="free">xs</span><span class="main">@</span><span class="bound">ys</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">ys</span><span class="main">≠</span><span class="main">[]</span> <span class="main">⟶</span> <span class="main">(</span>
    incr <span class="main">(</span>take <span class="free">xs</span><span class="main">)</span> <span class="main">∧</span> <span class="main">¬</span><span class="main">(</span>last <span class="main">(</span>take <span class="free">xs</span><span class="main">)</span> <span class="main">&lt;</span> hd <span class="bound">ys</span><span class="main">)</span>
  <span class="main">∨</span> decr <span class="main">(</span>take <span class="free">xs</span><span class="main">)</span> <span class="main">∧</span> <span class="main">¬</span><span class="main">(</span>last <span class="main">(</span>take <span class="free">xs</span><span class="main">)</span> <span class="main">≥</span> hd <span class="bound">ys</span><span class="main">)</span>  
  <span class="main">)</span><span class="main">)</span>"</span></span>  
    <span class="keyword1"><span class="command">using</span></span> tdconc' ticonc' tki tkd 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> take.cases<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> take_incr_non_empty<span class="main">)</span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> take_decr_non_empty<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> list.distinct<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> take_incr.simps<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> list.simps<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> take_decr.simps<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span>
    
    
  
  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"cuts <span class="main">[]</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> cuts.simps<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    
  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"cuts <span class="free">xs</span> <span class="main">≠</span> <span class="main">[]</span> <span class="main">⟷</span> <span class="free">xs</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> cuts.simps<span class="main">)</span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> take2_def Let_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1" id="Challenge1A-inv_cuts"><span class="command">lemma</span></span> inv_cuts<span class="main">:</span> <span class="quoted"><span class="quoted">"cuts <span class="free">xs</span> <span class="main">=</span> <span class="free">c</span><span class="main">#</span><span class="free">cs</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">ys</span><span class="main">.</span> <span class="free">c</span><span class="main">=</span>take <span class="free">xs</span> <span class="main">∧</span> <span class="free">xs</span><span class="main">=</span><span class="free">c</span><span class="main">@</span><span class="bound">ys</span> <span class="main">∧</span> <span class="free">cs</span> <span class="main">=</span> cuts <span class="bound">ys</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> cuts.simps<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> cuts.cases<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> take2_def Let_def<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> append_eq_conv_conj take_conc<span class="main">)</span>
    
  <span class="keyword1"><span class="command">theorem</span></span> maximal_cuts<span class="main">:</span> <span class="quoted"><span class="quoted">"maxi <span class="main">(</span>cuts <span class="free">xs</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="quoted">"cuts <span class="free">xs</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> maxi.induct<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> c xs
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> sym<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> cuts.simps<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits prod.splits <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> take2_def Let_def take_non_empty<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> c1 c2 cs xs
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> sym<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> inv_cuts<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> cuts.simps list.distinct<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> take_non_empty<span class="main">)</span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> append.left_neutral inv_cuts not_Cons_self<span class="main">)</span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> icod <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span>
            Nil_is_append_conv cuts.simps hd_append2 inv_cuts list.distinct<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span>
            same_append_eq take_conc'' take_non_empty<span class="main">)</span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span>
            append_is_Nil_conv cuts.simps hd_append2 inv_cuts list.distinct<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span>
            same_append_eq take_conc'' take_non_empty<span class="main">)</span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Equivalent Formulation Over Indexes›</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹After the competition, we got the comment that a specification of 
    monotonic sequences via indexes might be more readable.
  
    We show that our functional specification is equivalent to a 
    specification over indexes.›</span></span>
    
  <span class="keyword1"><span class="command">fun</span></span> <span class="entity">ii_induction</span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">ii_induction</span> <span class="main">[]</span> <span class="main">=</span> <span class="main">()</span>"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ii_induction</span> <span class="main">[</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">]</span> <span class="main">=</span> <span class="main">()</span>"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ii_induction</span> <span class="main">(</span><span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">ii_induction</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>      

  <span class="keyword1"><span class="command">locale</span></span> cnvSpec <span class="main">=</span>
    <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">fP</span> <span class="free">P</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">fP</span> <span class="main">[]</span> <span class="main">⟷</span> True"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">fP</span> <span class="main">[</span><span class="free">x</span><span class="main">]</span> <span class="main">⟷</span> True"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">fP</span> <span class="main">(</span><span class="free">a</span><span class="main">#</span><span class="free">b</span><span class="main">#</span><span class="free">xs</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">P</span> <span class="free">a</span> <span class="free">b</span> <span class="main">∧</span> <span class="free">fP</span> <span class="main">(</span><span class="free">b</span><span class="main">#</span><span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">begin</span></span>

    <span class="keyword1" id="Challenge1A-idx_spec"><span class="command">lemma</span></span> idx_spec<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">fP</span> <span class="free">xs</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">i</span></span><span class="main">&lt;</span>length <span class="free">xs</span> <span class="main">-</span> <span class="main">1</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span><span class="free">xs</span><span class="main">!</span><span class="bound">i</span><span class="main">)</span> <span class="main">(</span><span class="free">xs</span><span class="main">!</span>Suc <span class="bound">i</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> ii_induction.induct<span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> less_Suc_eq_0_disj
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
  <span class="keyword2"><span class="keyword">end</span></span>

  <span class="keyword1"><span class="command">locale</span></span> cnvSpec' <span class="main">=</span>
    <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">fP</span> <span class="free">P</span> <span class="free">P'</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">fP</span> <span class="main">[]</span> <span class="main">⟷</span> True"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">fP</span> <span class="main">[</span><span class="free">x</span><span class="main">]</span> <span class="main">⟷</span> <span class="free">P'</span> <span class="free">x</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">fP</span> <span class="main">(</span><span class="free">a</span><span class="main">#</span><span class="free">b</span><span class="main">#</span><span class="free">xs</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">P'</span> <span class="free">a</span> <span class="main">∧</span> <span class="free">P'</span> <span class="free">b</span> <span class="main">∧</span> <span class="free">P</span> <span class="free">a</span> <span class="free">b</span> <span class="main">∧</span> <span class="free">fP</span> <span class="main">(</span><span class="free">b</span><span class="main">#</span><span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">begin</span></span>

    <span class="keyword1" id="Challenge1A-idx_spec"><span class="command">lemma</span></span> idx_spec<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">fP</span> <span class="free">xs</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">i</span></span><span class="main">&lt;</span>length <span class="free">xs</span><span class="main">.</span> <span class="free">P'</span> <span class="main">(</span><span class="free">xs</span><span class="main">!</span><span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">i</span></span><span class="main">&lt;</span>length <span class="free">xs</span> <span class="main">-</span> <span class="main">1</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span><span class="free">xs</span><span class="main">!</span><span class="bound">i</span><span class="main">)</span> <span class="main">(</span><span class="free">xs</span><span class="main">!</span>Suc <span class="bound">i</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> ii_induction.induct<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> <span class="main"><span class="keyword3">[</span></span><span class="main"><span class="keyword3">]</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> less_Suc_eq_0_disj nth_Cons_0 nth_Cons_Suc<span class="main">)</span>
  
  <span class="keyword2"><span class="keyword">end</span></span>
    
  <span class="keyword1"><span class="command">interpretation</span></span> INCR<span class="main">:</span> cnvSpec <span class="quoted">incr</span> <span class="quoted"><span class="quoted">"<span class="main">(&lt;)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
  <span class="keyword1"><span class="command">interpretation</span></span> DECR<span class="main">:</span> cnvSpec <span class="quoted">decr</span> <span class="quoted"><span class="quoted">"<span class="main">(≥)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
  <span class="keyword1"><span class="command">interpretation</span></span> MAXI<span class="main">:</span> cnvSpec' <span class="quoted">maxi</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">c1</span> <span class="bound">c2</span><span class="main">.</span> <span class="main">(</span> <span class="main">(</span> 
        incr <span class="bound">c1</span> <span class="main">∧</span> <span class="main">¬</span><span class="main">(</span>last <span class="bound">c1</span> <span class="main">&lt;</span> hd <span class="bound">c2</span><span class="main">)</span> 
      <span class="main">∨</span> decr <span class="bound">c1</span> <span class="main">∧</span> <span class="main">¬</span><span class="main">(</span>last <span class="bound">c1</span> <span class="main">≥</span> hd <span class="bound">c2</span><span class="main">)</span>        
        <span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
  <span class="keyword1" id="Challenge1A-incr_by_idx"><span class="command">lemma</span></span> incr_by_idx<span class="main">:</span> <span class="quoted"><span class="quoted">"incr <span class="free">xs</span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">i</span></span><span class="main">&lt;</span>length <span class="free">xs</span> <span class="main">-</span> <span class="main">1</span><span class="main">.</span> <span class="free">xs</span> <span class="main">!</span> <span class="bound">i</span> <span class="main">&lt;</span> <span class="free">xs</span> <span class="main">!</span> Suc <span class="bound">i</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> INCR.idx_spec<span class="main">)</span>
    
  <span class="keyword1" id="Challenge1A-decr_by_idx"><span class="command">lemma</span></span> decr_by_idx<span class="main">:</span> <span class="quoted"><span class="quoted">"decr <span class="free">xs</span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">i</span></span><span class="main">&lt;</span>length <span class="free">xs</span> <span class="main">-</span> <span class="main">1</span><span class="main">.</span> <span class="free">xs</span> <span class="main">!</span> <span class="bound">i</span> <span class="main">≥</span> <span class="free">xs</span> <span class="main">!</span> Suc <span class="bound">i</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> DECR.idx_spec<span class="main">)</span>
    
  <span class="keyword1" id="Challenge1A-maxi_by_idx"><span class="command">lemma</span></span> maxi_by_idx<span class="main">:</span> <span class="quoted"><span class="quoted">"maxi <span class="free">xs</span> <span class="main">⟷</span>
    <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">i</span></span><span class="main">&lt;</span>length <span class="free">xs</span><span class="main">.</span> <span class="free">xs</span> <span class="main">!</span> <span class="bound">i</span> <span class="main">≠</span> <span class="main">[]</span><span class="main">)</span> <span class="main">∧</span>
    <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">i</span></span><span class="main">&lt;</span>length <span class="free">xs</span> <span class="main">-</span> <span class="main">1</span><span class="main">.</span> 
         incr <span class="main">(</span><span class="free">xs</span> <span class="main">!</span> <span class="bound">i</span><span class="main">)</span> <span class="main">∧</span> <span class="main">¬</span> last <span class="main">(</span><span class="free">xs</span> <span class="main">!</span> <span class="bound">i</span><span class="main">)</span> <span class="main">&lt;</span> hd <span class="main">(</span><span class="free">xs</span> <span class="main">!</span> Suc <span class="bound">i</span><span class="main">)</span> 
       <span class="main">∨</span> decr <span class="main">(</span><span class="free">xs</span> <span class="main">!</span> <span class="bound">i</span><span class="main">)</span> <span class="main">∧</span> <span class="main">¬</span> hd <span class="main">(</span><span class="free">xs</span> <span class="main">!</span> Suc <span class="bound">i</span><span class="main">)</span> <span class="main">≤</span> last <span class="main">(</span><span class="free">xs</span> <span class="main">!</span> <span class="bound">i</span><span class="main">)</span>
    <span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> MAXI.idx_spec<span class="main">)</span>

  <span class="keyword1"><span class="command">theorem</span></span> all_correct<span class="main">:</span>  
    <span class="quoted"><span class="quoted">"concat <span class="main">(</span>cuts <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">c</span><span class="main">∈</span>set <span class="main">(</span>cuts <span class="free">xs</span><span class="main">)</span><span class="main">.</span> incr <span class="bound">c</span> <span class="main">∨</span> decr <span class="bound">c</span>"</span></span>
    <span class="quoted"><span class="quoted">"maxi <span class="main">(</span>cuts <span class="free">xs</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">[]</span> <span class="main">∉</span> set <span class="main">(</span>cuts <span class="free">xs</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> cuts_incr_decr concat_cuts maximal_cuts 
          maxi_imp_non_empty<span class="main">[</span><span class="operator">OF</span> maximal_cuts<span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="Challenge1B">
<div class="head">
<h1>Theory Challenge1B</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Challenge 1.B›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Challenge1B
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="Challenge1A.html">Challenge1A</a> <span class="quoted">"<a href="../../HOL/HOL-Library/Multiset.html">HOL-Library.Multiset</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(* TODO: Move *)</span>
<span class="keyword1" id="Challenge1B-mset_concat"><span class="command">lemma</span></span> mset_concat<span class="main">:</span>
  <span class="quoted"><span class="quoted">"mset <span class="main">(</span>concat <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> fold <span class="main">(+)</span> <span class="main">(</span>map mset <span class="free">xs</span><span class="main">)</span> <span class="main">{#}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"mset <span class="main">(</span>concat <span class="free">xs</span><span class="main">)</span> <span class="main">+</span> <span class="skolem">a</span> <span class="main">=</span> fold <span class="main">(+)</span> <span class="main">(</span>map mset <span class="free">xs</span><span class="main">)</span> <span class="skolem">a</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">a</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">a</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> Nil
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">x</span> <span class="skolem">xs</span><span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">using</span></span> Cons.IH<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"mset <span class="skolem">x</span> <span class="main">+</span> <span class="skolem">a</span>"</span></span><span class="main">,</span> <span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">from</span></span> this<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">{#}</span>"</span></span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Merging Two Segments›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">merge</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span><span class="main">{</span>linorder<span class="main">}</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'a</span> list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
   <span class="quoted"><span class="quoted">"<span class="free">merge</span> <span class="main">[]</span> <span class="free"><span class="bound"><span class="entity">l2</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">l2</span></span></span>"</span></span>
 <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">merge</span> <span class="free"><span class="bound"><span class="entity">l1</span></span></span> <span class="main">[]</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">l1</span></span></span>"</span></span>
 <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">merge</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x1</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">l1</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x2</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">l2</span></span></span><span class="main">)</span> <span class="main">=</span>
    <span class="main">(</span><span class="keyword1">if</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x1</span></span></span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">x2</span></span></span><span class="main">)</span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">x1</span></span></span> <span class="main">#</span> <span class="main">(</span><span class="free">merge</span> <span class="free"><span class="bound"><span class="entity">l1</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x2</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">l2</span></span></span><span class="main">)</span><span class="main">)</span> <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">x2</span></span></span> <span class="main">#</span> <span class="main">(</span><span class="free">merge</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x1</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">l1</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">l2</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Challenge1B-merge_correct"><span class="command">lemma</span></span> merge_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"sorted <span class="free">l1</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"sorted <span class="free">l2</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"
    sorted <span class="main">(</span>merge <span class="free">l1</span> <span class="free">l2</span><span class="main">)</span>
  <span class="main">∧</span> mset <span class="main">(</span>merge <span class="free">l1</span> <span class="free">l2</span><span class="main">)</span> <span class="main">=</span> mset <span class="free">l1</span> <span class="main">+</span> mset <span class="free">l2</span>
  <span class="main">∧</span> set <span class="main">(</span>merge <span class="free">l1</span> <span class="free">l2</span><span class="main">)</span> <span class="main">=</span> set <span class="free">l1</span> <span class="main">∪</span> set <span class="free">l2</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">l1</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">l2</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">x1</span> <span class="skolem">l1</span> <span class="skolem">l2</span><span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> IH <span class="main">=</span> Cons.IH

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> Cons.prems
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">l2</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> Nil <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">x2</span> <span class="skolem">l2</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">using</span></span> IH <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Merging a List of Segments›</span></span>

<span class="keyword1"><span class="command">function</span></span> <span class="entity">merge_list</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span><span class="main">{</span>linorder<span class="main">}</span> list list <span class="main">⇒</span> <span class="tfree">'a</span> list list <span class="main">⇒</span> <span class="tfree">'a</span> list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
   <span class="quoted"><span class="quoted">"<span class="free">merge_list</span> <span class="main">[]</span> <span class="main">[]</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
 <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">merge_list</span> <span class="main">[]</span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">]</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span>"</span></span>
 <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">merge_list</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">la</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">acc2</span></span></span><span class="main">)</span> <span class="main">[]</span> <span class="main">=</span> <span class="free">merge_list</span> <span class="main">[]</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">la</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">acc2</span></span></span><span class="main">)</span>"</span></span>
 <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">merge_list</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">la</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">acc2</span></span></span><span class="main">)</span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">]</span> <span class="main">=</span> <span class="free">merge_list</span> <span class="main">[]</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">la</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">acc2</span></span></span><span class="main">)</span>"</span></span>
 <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">merge_list</span> <span class="free"><span class="bound"><span class="entity">acc2</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">l1</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">l2</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ls</span></span></span><span class="main">)</span> <span class="main">=</span>
    <span class="free">merge_list</span> <span class="main">(</span><span class="main">(</span>merge <span class="free"><span class="bound"><span class="entity">l1</span></span></span> <span class="free"><span class="bound"><span class="entity">l2</span></span></span><span class="main">)</span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">acc2</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">ls</span></span></span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">pat_completeness</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">termination</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">relation</span> <span class="quoted"><span class="quoted">"measure <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">acc</span><span class="main">,</span> <span class="bound">ls</span><span class="main">)</span><span class="main">.</span> <span class="numeral">3</span> <span class="main">*</span> length <span class="bound">acc</span> <span class="main">+</span> <span class="numeral">2</span> <span class="main">*</span> length <span class="bound">ls</span><span class="main">)</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="Challenge1B-merge_list_correct"><span class="command">lemma</span></span> merge_list_correct<span class="main">:</span>
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">l</span><span class="main">.</span> <span class="bound">l</span> <span class="main">∈</span> set <span class="free">ls</span> <span class="main">⟹</span> sorted <span class="bound">l</span>"</span></span>
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">l</span><span class="main">.</span> <span class="bound">l</span> <span class="main">∈</span> set <span class="free">as</span> <span class="main">⟹</span> sorted <span class="bound">l</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"
  sorted <span class="main">(</span>merge_list <span class="free">as</span> <span class="free">ls</span><span class="main">)</span>
<span class="main">∧</span> mset <span class="main">(</span>merge_list <span class="free">as</span> <span class="free">ls</span><span class="main">)</span> <span class="main">=</span> mset <span class="main">(</span>concat <span class="main">(</span><span class="free">as</span> <span class="main">@</span> <span class="free">ls</span><span class="main">)</span><span class="main">)</span>
<span class="main">∧</span> set <span class="main">(</span>merge_list <span class="free">as</span> <span class="free">ls</span><span class="main">)</span> <span class="main">=</span> set <span class="main">(</span>concat <span class="main">(</span><span class="free">as</span> <span class="main">@</span> <span class="free">ls</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">as</span></span> <span class="quoted"><span class="free">ls</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> merge_list.induct<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>4 <span class="skolem">la</span> <span class="skolem">acc2</span> <span class="skolem">l</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">algebra_simps</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>5 <span class="skolem">acc2</span> <span class="skolem">l1</span> <span class="skolem">l2</span> <span class="skolem">ls</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"sorted <span class="main">(</span>merge_list <span class="main">(</span>merge <span class="skolem">l1</span> <span class="skolem">l2</span> <span class="main">#</span> <span class="skolem">acc2</span><span class="main">)</span> <span class="skolem">ls</span><span class="main">)</span>
    <span class="main">∧</span> mset <span class="main">(</span>merge_list <span class="main">(</span>merge <span class="skolem">l1</span> <span class="skolem">l2</span> <span class="main">#</span> <span class="skolem">acc2</span><span class="main">)</span> <span class="skolem">ls</span><span class="main">)</span> <span class="main">=</span> mset <span class="main">(</span>concat <span class="main">(</span><span class="main">(</span>merge <span class="skolem">l1</span> <span class="skolem">l2</span> <span class="main">#</span> <span class="skolem">acc2</span><span class="main">)</span> <span class="main">@</span> <span class="skolem">ls</span><span class="main">)</span><span class="main">)</span>
    <span class="main">∧</span> set <span class="main">(</span>merge_list <span class="main">(</span>merge <span class="skolem">l1</span> <span class="skolem">l2</span> <span class="main">#</span> <span class="skolem">acc2</span><span class="main">)</span> <span class="skolem">ls</span><span class="main">)</span> <span class="main">=</span> set <span class="main">(</span>concat <span class="main">(</span><span class="main">(</span>merge <span class="skolem">l1</span> <span class="skolem">l2</span> <span class="main">#</span> <span class="skolem">acc2</span><span class="main">)</span> <span class="main">@</span> <span class="skolem">ls</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> 5<span class="main">(</span>2-<span class="main">)</span> merge_correct<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">l1</span></span> <span class="quoted"><span class="skolem">l2</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> 5<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> merge_correct<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">l1</span></span> <span class="quoted"><span class="skolem">l2</span></span><span class="main">]</span> 5<span class="main">(</span>2-<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹GHC-Sort›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ghc_sort</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> merge_list <span class="main">[]</span> <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">ys</span><span class="main">.</span> <span class="keyword1">if</span> decr <span class="bound">ys</span> <span class="keyword1">then</span> rev <span class="bound">ys</span> <span class="keyword1">else</span> <span class="bound">ys</span><span class="main">)</span> <span class="main">(</span>cuts <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Challenge1B-decr_sorted"><span class="command">lemma</span></span> decr_sorted<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"decr <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sorted <span class="main">(</span>rev <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> decr.induct<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sorted_append<span class="main">)</span>

<span class="keyword1" id="Challenge1B-incr_sorted"><span class="command">lemma</span></span> incr_sorted<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"incr <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sorted <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> incr.induct<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Challenge1B-reverse_phase_sorted"><span class="command">lemma</span></span> reverse_phase_sorted<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">ys</span> <span class="main">∈</span> set <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">ys</span><span class="main">.</span> <span class="keyword1">if</span> decr <span class="bound">ys</span> <span class="keyword1">then</span> rev <span class="bound">ys</span> <span class="keyword1">else</span> <span class="bound">ys</span><span class="main">)</span> <span class="main">(</span>cuts <span class="free">xs</span><span class="main">)</span><span class="main">)</span><span class="main">.</span> sorted <span class="bound">ys</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> cuts_incr_decr <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> decr_sorted incr_sorted<span class="main">)</span>

<span class="keyword1" id="Challenge1B-reverse_phase_elements"><span class="command">lemma</span></span> reverse_phase_elements<span class="main">:</span>
  <span class="quoted"><span class="quoted">"set <span class="main">(</span>concat <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">ys</span><span class="main">.</span> <span class="keyword1">if</span> decr <span class="bound">ys</span> <span class="keyword1">then</span> rev <span class="bound">ys</span> <span class="keyword1">else</span> <span class="bound">ys</span><span class="main">)</span> <span class="main">(</span>cuts <span class="free">xs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> set <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>concat <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">ys</span><span class="main">.</span> <span class="keyword1">if</span> decr <span class="bound">ys</span> <span class="keyword1">then</span> rev <span class="bound">ys</span> <span class="keyword1">else</span> <span class="bound">ys</span><span class="main">)</span> <span class="main">(</span>cuts <span class="free">xs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="main">=</span> set <span class="main">(</span>concat <span class="main">(</span>cuts <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> set <span class="free">xs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> concat_cuts<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Challenge1B-reverse_phase_permutation"><span class="command">lemma</span></span> reverse_phase_permutation<span class="main">:</span>
  <span class="quoted"><span class="quoted">"mset <span class="main">(</span>concat <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">ys</span><span class="main">.</span> <span class="keyword1">if</span> decr <span class="bound">ys</span> <span class="keyword1">then</span> rev <span class="bound">ys</span> <span class="keyword1">else</span> <span class="bound">ys</span><span class="main">)</span> <span class="main">(</span>cuts <span class="free">xs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> mset <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"mset <span class="main">(</span>concat <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">ys</span><span class="main">.</span> <span class="keyword1">if</span> decr <span class="bound">ys</span> <span class="keyword1">then</span> rev <span class="bound">ys</span> <span class="keyword1">else</span> <span class="bound">ys</span><span class="main">)</span> <span class="main">(</span>cuts <span class="free">xs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
    <span class="main">=</span> mset <span class="main">(</span>concat <span class="main">(</span>cuts <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> mset_concat <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> comp_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> arg_cong2<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted">"fold <span class="main">(+)</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> mset <span class="free">xs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> concat_cuts<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Correctness Lemmas›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The result is sorted and a permutation of the original elements.›</span></span>

<span class="keyword1"><span class="command">theorem</span></span> sorted_ghc_sort<span class="main">:</span>
  <span class="quoted"><span class="quoted">"sorted <span class="main">(</span>ghc_sort <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ghc_sort_def <span class="keyword1"><span class="command">using</span></span> reverse_phase_sorted
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> merge_list_correct<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> conjunct1<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">theorem</span></span> permutation_ghc_sort<span class="main">:</span>
  <span class="quoted"><span class="quoted">"mset <span class="main">(</span>ghc_sort <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> mset <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> ghc_sort_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> merge_list_correct<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> conjunct2<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">using</span></span> reverse_phase_sorted <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">using</span></span> reverse_phase_sorted <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> reverse_phase_permutation<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">corollary</span></span> elements_ghc_sort<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>ghc_sort <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> set <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> permutation_ghc_sort <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> set_mset_mset<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Executable Code›</span></span>  
<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">ghc_sort</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML Scala OCaml<span class="main">?</span> Haskell<span class="main">?</span>

<span class="keyword1"><span class="command">value</span></span> <span class="main">[</span>code<span class="main">]</span> <span class="quoted"><span class="quoted">"ghc_sort <span class="main">[</span><span class="main">1</span><span class="main">,</span><span class="numeral">2</span><span class="main">,</span><span class="numeral">7</span><span class="main">,</span><span class="numeral">3</span><span class="main">,</span><span class="numeral">5</span><span class="main">,</span><span class="numeral">6</span><span class="main">,</span><span class="numeral">9</span><span class="main">,</span><span class="numeral">8</span><span class="main">,</span><span class="numeral">4</span><span class="main">]</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="Challenge2A">
<div class="head">
<h1>Theory Challenge2A</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Challenge 2.A›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Challenge2A
<span class="keyword2"><span class="keyword">imports</span></span> <span class="quoted">"<a href="VTcomp.html">lib/VTcomp</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Problem definition:
<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">🌐</span></span>‹https://ethz.ch/content/dam/ethz/special-interest/infk/chair-program-method/pm/documents/Verify%20This/Challenges%202019/cartesian_trees.pdf›</span></span>›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Polished and worked-over version.›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Specification›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We first fix the input, a list of integers›</span></span>
<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"int list"</span></span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We then specify the desired output: 
  For each index <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>j›</span></span></span></span>, return the greatest index <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>i&lt;j›</span></span></span></span> such that <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>xs!i &lt; xs!j›</span></span></span></span>, or <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>None›</span></span></span></span> if
  no such index exists.
  
  Note that our indexes start at zero, and we use an option datatype to model that 
  no left-smaller value may exists.
›</span></span>  
<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">left_spec</span> <span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="main">(</span><span class="main">∃</span><span class="bound"><span class="bound">i</span></span><span class="main">&lt;</span><span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">.</span> <span class="free">xs</span> <span class="main">!</span> <span class="bound">i</span> <span class="main">&lt;</span> <span class="free">xs</span> <span class="main">!</span> <span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">)</span> <span class="keyword1">then</span> Some <span class="main">(</span><span class="keyword1">GREATEST</span> <span class="bound">i</span><span class="main">.</span> <span class="bound">i</span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="main">∧</span> <span class="free">xs</span> <span class="main">!</span> <span class="bound">i</span> <span class="main">&lt;</span> <span class="free">xs</span> <span class="main">!</span> <span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">)</span> <span class="keyword1">else</span> None<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The output of the algorithm should be an array <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>lf›</span></span></span></span>, containing the indexes of the 
  left-smaller values:
›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">all_left_spec</span> <span class="free"><span class="bound"><span class="entity">lf</span></span></span> <span class="main">≡</span> length <span class="free"><span class="bound"><span class="entity">lf</span></span></span> <span class="main">=</span> length <span class="free">xs</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">i</span></span><span class="main">&lt;</span>length <span class="free">xs</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">lf</span></span></span><span class="main">!</span><span class="bound">i</span> <span class="main">=</span> left_spec <span class="bound">i</span><span class="main">)</span>"</span></span>
      
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Auxiliary Theory›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We derive some theory specific to this algorithm›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Has-Left and The-Left›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We split the specification of nearest left value into a predicate and a total function›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">has_left</span> <span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">∃</span><span class="bound"><span class="bound">i</span></span><span class="main">&lt;</span><span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">.</span> <span class="free">xs</span> <span class="main">!</span> <span class="bound">i</span> <span class="main">&lt;</span> <span class="free">xs</span> <span class="main">!</span> <span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">the_left</span> <span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">GREATEST</span> <span class="bound">i</span><span class="main">.</span> <span class="bound">i</span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="main">∧</span> <span class="free">xs</span> <span class="main">!</span> <span class="bound">i</span> <span class="main">&lt;</span> <span class="free">xs</span> <span class="main">!</span> <span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Challenge2A-left_alt"><span class="command">lemma</span></span> left_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"left_spec <span class="free">j</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> has_left <span class="free">j</span> <span class="keyword1">then</span> Some <span class="main">(</span>the_left <span class="free">j</span><span class="main">)</span> <span class="keyword1">else</span> None<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> left_spec_def has_left_def the_left_def<span class="main">)</span>

<span class="keyword1" id="Challenge2A-the_leftI"><span class="command">lemma</span></span> the_leftI<span class="main">:</span> <span class="quoted"><span class="quoted">"has_left <span class="free">j</span> <span class="main">⟹</span> the_left <span class="free">j</span> <span class="main">&lt;</span> <span class="free">j</span> <span class="main">∧</span> <span class="free">xs</span><span class="main">!</span>the_left <span class="free">j</span> <span class="main">&lt;</span> <span class="free">xs</span><span class="main">!</span><span class="free">j</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> has_left_def the_left_def<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> GreatestI_nat less_le_not_le nat_le_linear pinf<span class="main"><span class="main">(</span></span>5<span class="main"><span class="main">)</span></span><span class="main">)</span>

<span class="keyword1" id="Challenge2A-the_left_decr"><span class="command">lemma</span></span> the_left_decr<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"has_left <span class="free">i</span> <span class="main">⟹</span> the_left <span class="free">i</span> <span class="main">&lt;</span> <span class="free">i</span>"</span></span>  
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> the_leftI<span class="main">)</span>

<span class="keyword1" id="Challenge2A-le_the_leftI"><span class="command">lemma</span></span> le_the_leftI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span><span class="main">≤</span><span class="free">j</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span><span class="main">!</span><span class="free">i</span> <span class="main">&lt;</span> <span class="free">xs</span><span class="main">!</span><span class="free">j</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">≤</span> the_left <span class="free">j</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> the_left_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span>
      Greatest_le_nat le_less_linear less_imp_not_less less_irrefl
      order.not_eq_order_implies_strict<span class="main">)</span>

<span class="keyword1" id="Challenge2A-the_left_leI"><span class="command">lemma</span></span> the_left_leI<span class="main">:</span>  
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">k</span><span class="main">.</span> <span class="free">j</span><span class="main">&lt;</span><span class="bound">k</span> <span class="main">∧</span> <span class="bound">k</span><span class="main">&lt;</span><span class="free">i</span> <span class="main">⟶</span> <span class="main">¬</span><span class="free">xs</span><span class="main">!</span><span class="bound">k</span><span class="main">&lt;</span><span class="free">xs</span><span class="main">!</span><span class="free">i</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"has_left <span class="free">i</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"the_left <span class="free">i</span> <span class="main">≤</span> <span class="free">j</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">unfolding</span></span> the_left_def has_left_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>full_types<span class="main"><span class="main">)</span></span> the_leftI assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> not_le the_left_def<span class="main">)</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Derived Stack›</span></span>    
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We note that the stack in the algorithm doesn't contain any 
  extra information. It can be derived from the left neighbours that have been 
  computed so far:
  The first element of the stack is the current index - 1, and each next element is
  the nearest left smaller value of the previous element:
›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">der_stack</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">der_stack</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> has_left <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="keyword1">then</span> the_left <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">#</span> <span class="free">der_stack</span> <span class="main">(</span>the_left <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> <span class="keyword1">else</span> <span class="main">[]</span><span class="main">)</span>"</span></span>  
<span class="keyword1"><span class="command">declare</span></span> der_stack.simps<span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span>  

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Although the refinement framework would allow us to phrase the 
  algorithm without a stack first, and then introduce the stack in a subsequent 
  refinement step (or omit it altogether), for simplicity of presentation, we decided
  to model the algorithm with a stack in first place. However, the invariant will account for
  the stack being derived.
›</span></span>

<span class="keyword1" id="Challenge2A-set_der_stack_lt"><span class="command">lemma</span></span> set_der_stack_lt<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">∈</span> set <span class="main">(</span>der_stack <span class="free">i<span class="hidden">⇩</span><sub>0</sub></span><span class="main">)</span> <span class="main">⟹</span> <span class="free">k</span><span class="main">&lt;</span><span class="free">i<span class="hidden">⇩</span><sub>0</sub></span>"</span></span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">i<span class="hidden">⇩</span><sub>0</sub></span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> der_stack.induct<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> der_stack.simps<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">using</span></span> less_trans the_leftI <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Abstract Implementation›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We first implement the algorithm on lists. 
  The assertions that we annotated into the algorithm ensure
  that all list index accesses are in bounds.
›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">pop</span> <span class="free"><span class="bound"><span class="entity">stk</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≡</span> dropWhile <span class="main">(</span><span class="main">λ</span><span class="bound">j</span><span class="main">.</span> <span class="free">xs</span><span class="main">!</span><span class="bound">j</span><span class="main">≥</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">stk</span></span></span>"</span></span>

<span class="keyword1" id="Challenge2A-pop_Nil"><span class="command">lemma</span></span> pop_Nil<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"pop <span class="main">[]</span> <span class="free">v</span> <span class="main">=</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pop_def<span class="main">)</span>
<span class="keyword1" id="Challenge2A-pop_cons"><span class="command">lemma</span></span> pop_cons<span class="main">:</span> <span class="quoted"><span class="quoted">"pop <span class="main">(</span><span class="free">j</span><span class="main">#</span><span class="free">js</span><span class="main">)</span> <span class="free">v</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">xs</span><span class="main">!</span><span class="free">j</span> <span class="main">≥</span> <span class="free">v</span> <span class="keyword1">then</span> pop <span class="free">js</span> <span class="free">v</span> <span class="keyword1">else</span> <span class="free">j</span><span class="main">#</span><span class="free">js</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pop_def<span class="main">)</span>


<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">all_left</span> <span class="main">≡</span> <span class="keyword1">doN</span> <span class="main">{</span>
  <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">lf</span><span class="main">)</span> <span class="main">←</span> nfoldli <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span>length <span class="free">xs</span><span class="main">]</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span> <span class="main">(</span><span class="bound">stk</span><span class="main">,</span><span class="bound">lf</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">doN</span> <span class="main">{</span>
    ASSERT <span class="main">(</span>set <span class="bound">stk</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span>length <span class="free">xs</span><span class="main">}</span> <span class="main">)</span><span class="main">;</span>
    <span class="keyword1">let</span> <span class="bound">stk</span> <span class="main">=</span> pop <span class="bound">stk</span> <span class="main">(</span><span class="free">xs</span><span class="main">!</span><span class="bound">i</span><span class="main">)</span><span class="main">;</span>
    ASSERT <span class="main">(</span><span class="bound">stk</span> <span class="main">=</span> der_stack <span class="bound">i</span><span class="main">)</span><span class="main">;</span>
    ASSERT <span class="main">(</span><span class="bound">i</span><span class="main">&lt;</span>length <span class="bound">lf</span><span class="main">)</span><span class="main">;</span>
    <span class="keyword1">if</span> <span class="main">(</span><span class="bound">stk</span> <span class="main">=</span> <span class="main">[]</span><span class="main">)</span> <span class="keyword1">then</span> <span class="keyword1">doN</span> <span class="main">{</span>
      <span class="keyword1">let</span> <span class="bound">lf</span> <span class="main">=</span> <span class="bound">lf</span><span class="main">[</span><span class="bound">i</span><span class="main">:=</span>None<span class="main">]</span><span class="main">;</span>
      RETURN <span class="main">(</span><span class="bound">i</span><span class="main">#</span><span class="bound">stk</span><span class="main">,</span><span class="bound">lf</span><span class="main">)</span>
    <span class="main">}</span> <span class="keyword1">else</span> <span class="keyword1">doN</span> <span class="main">{</span>
      <span class="keyword1">let</span> <span class="bound">lf</span> <span class="main">=</span> <span class="bound">lf</span><span class="main">[</span><span class="bound">i</span><span class="main">:=</span> Some <span class="main">(</span>hd <span class="bound">stk</span><span class="main">)</span><span class="main">]</span><span class="main">;</span>
      RETURN <span class="main">(</span><span class="bound">i</span><span class="main">#</span><span class="bound">stk</span><span class="main">,</span><span class="bound">lf</span><span class="main">)</span>
    <span class="main">}</span>
  <span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="main">[]</span><span class="main">,</span>replicate <span class="main">(</span>length <span class="free">xs</span><span class="main">)</span> None<span class="main">)</span><span class="main">;</span>
  RETURN <span class="bound">lf</span>
<span class="main">}</span>"</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Correctness Proof›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Popping From the Stack›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We show that the abstract algorithm implements its specification.
  The main idea here is the popping of the stack.
  Top obtain a left smaller value, it is enough to follow the left-values of
  the left-neighbour, until we have found the value or there are no more left-values.
  
  The following theorem formalizes this idea:
›</span></span>
<span class="keyword1"><span class="command">theorem</span></span> find_left_rl<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">i<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">&lt;</span> length <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span><span class="main">&lt;</span><span class="free">i<span class="hidden">⇩</span><sub>0</sub></span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"left_spec <span class="free">i<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">≤</span> Some <span class="free">i</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">if</span> <span class="free">xs</span><span class="main">!</span><span class="free">i</span> <span class="main">&lt;</span> <span class="free">xs</span><span class="main">!</span><span class="free">i<span class="hidden">⇩</span><sub>0</sub></span> <span class="keyword1">then</span> left_spec <span class="free">i<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">=</span> Some <span class="free">i</span>
         <span class="keyword1">else</span> left_spec <span class="free">i<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">≤</span> left_spec <span class="free">i</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms           
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">intro</span> impI conjI<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> left_alt <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> le_antisym le_the_leftI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> has_left_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> left_alt <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> the_leftI<span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> nat_less_le <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> has_left_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>  
      <span class="keyword1"><span class="command">using</span></span> le_the_leftI the_leftI <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>  

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Using this lemma, we can show that the stack popping procedure preserves the form of the stack.›</span></span>
<span class="keyword1" id="Challenge2A-pop_aux"><span class="command">lemma</span></span> pop_aux<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">k</span><span class="main">&lt;</span><span class="free">i<span class="hidden">⇩</span><sub>0</sub></span><span class="main">;</span> <span class="free">i<span class="hidden">⇩</span><sub>0</sub></span><span class="main">&lt;</span>length <span class="free">xs</span><span class="main">;</span> left_spec <span class="free">i<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">≤</span> Some <span class="free">k</span> <span class="main">⟧</span> <span class="main">⟹</span> pop <span class="main">(</span><span class="free">k</span> <span class="main">#</span> der_stack <span class="free">k</span><span class="main">)</span> <span class="main">(</span><span class="free">xs</span><span class="main">!</span><span class="free">i<span class="hidden">⇩</span><sub>0</sub></span><span class="main">)</span> <span class="main">=</span> der_stack <span class="free">i<span class="hidden">⇩</span><sub>0</sub></span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">k</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> nat_less_induct<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span><span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> der_stack.simps left_alt pop_def the_leftI dropWhile.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> find_left_rl leD less_option_None_Some option.inject pop_cons<span class="main">)</span>
  
  
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Main Algorithm›</span></span>  

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Ad-Hoc lemmas›</span></span>
<span class="keyword1" id="Challenge2A-swap_adhoc"><span class="command">lemma</span></span> swap_adhoc<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"None <span class="main">=</span> <span class="free">left</span> <span class="free">i</span> <span class="main">⟷</span> <span class="free">left</span> <span class="free">i</span> <span class="main">=</span> None"</span></span>
  <span class="quoted"><span class="quoted">"Some <span class="free">j</span> <span class="main">=</span> <span class="free">left</span> <span class="free">i</span> <span class="main">⟷</span> <span class="free">left</span> <span class="free">i</span> <span class="main">=</span> Some <span class="free">j</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Challenge2A-left_spec_None_iff"><span class="command">lemma</span></span> left_spec_None_iff<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"left_spec <span class="free">i</span> <span class="main">=</span> None <span class="main">⟷</span> <span class="main">¬</span>has_left <span class="free">i</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> left_alt<span class="main">)</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"left_spec <span class="main">0</span> <span class="main">=</span> None"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> left_spec_def<span class="main">)</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"has_left <span class="main">0</span> <span class="main">=</span> False"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> has_left_def<span class="main">)</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"der_stack <span class="main">0</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> der_stack.simps<span class="main">)</span> <span class="operator">auto</span>
  
  
<span class="keyword1" id="Challenge2A-algo_correct"><span class="command">lemma</span></span> algo_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"all_left <span class="main">≤</span> SPEC all_left_spec"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> all_left_def all_left_spec_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">refine_vcg</span> nfoldli_upt_rule<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> I<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"
    <span class="main">λ</span><span class="bound">k</span> <span class="main">(</span><span class="bound">stk</span><span class="main">,</span><span class="bound">lf</span><span class="main">)</span><span class="main">.</span> 
      <span class="main">(</span>length <span class="bound">lf</span> <span class="main">=</span> length <span class="free">xs</span><span class="main">)</span>
    <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">i</span></span><span class="main">&lt;</span><span class="bound">k</span><span class="main">.</span> <span class="bound">lf</span><span class="main">!</span><span class="bound">i</span> <span class="main">=</span> left_spec <span class="bound">i</span><span class="main">)</span>
    <span class="main">∧</span> <span class="main">(</span><span class="keyword1">case</span> <span class="bound">k</span> <span class="keyword1">of</span> Suc <span class="bound">kk</span> <span class="main">⇒</span> <span class="bound">stk</span> <span class="main">=</span> <span class="bound">kk</span><span class="main">#</span>der_stack <span class="bound">kk</span> <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span>  <span class="bound">stk</span><span class="main">=</span><span class="main">[]</span><span class="main">)</span>  
      "</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">vc_solve</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> nat.splits<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> set_der_stack_lt <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> lf k
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> left_alt less_Suc_eq_le less_eq_option_None less_eq_option_Some nat_in_between_eq<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> pop_aux the_leftI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> der_stack.simps left_alt less_Suc_eq list.distinct<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> nth_list_update<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> der_stack.simps left_alt less_Suc_eq list.sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> nth_list_update<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Implementation With Arrays›</span></span>    
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We refine the algorithm to use actual arrays for the input and output. 
  The stack remains a list, as pushing and popping from a (functional) list is efficient.
›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Implementation of Pop›</span></span>   
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In a first step, we refine the pop function to an explicit loop.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">pop2</span> <span class="free"><span class="bound"><span class="entity">stk</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≡</span> 
  monadic_WHILEIT 
    <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> set <span class="free"><span class="bound"><span class="entity">stk</span></span></span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span>length <span class="free">xs</span><span class="main">}</span><span class="main">)</span> 
    <span class="main">(</span><span class="main">λ</span><span class="main">[]</span> <span class="main">⇒</span> RETURN False <span class="main">|</span> <span class="bound">k</span><span class="main">#</span><span class="bound">stk</span> <span class="main">⇒</span> <span class="keyword1">doN</span> <span class="main">{</span> ASSERT <span class="main">(</span><span class="bound">k</span><span class="main">&lt;</span>length <span class="free">xs</span><span class="main">)</span><span class="main">;</span> RETURN <span class="main">(</span><span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≤</span> <span class="free">xs</span><span class="main">!</span><span class="bound">k</span><span class="main">)</span> <span class="main">}</span><span class="main">)</span>
    <span class="main">(</span><span class="main">λ</span><span class="bound">stk</span><span class="main">.</span> mop_list_tl <span class="bound">stk</span><span class="main">)</span>
    <span class="free"><span class="bound"><span class="entity">stk</span></span></span>"</span></span>
  
<span class="keyword1" id="Challenge2A-pop2_refine_aux"><span class="command">lemma</span></span> pop2_refine_aux<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="free">stk</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span>length <span class="free">xs</span><span class="main">}</span> <span class="main">⟹</span> pop2 <span class="free">stk</span> <span class="free">v</span> <span class="main">≤</span> RETURN <span class="main">(</span>pop <span class="free">stk</span> <span class="free">v</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">stk</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">unfolding</span></span> pop_def pop2_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> monadic_WHILEIT_unfold<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> monadic_WHILEIT_unfold<span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> mop_list_tl_def op_list_tl_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
        
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Context fixing the input <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>xs›</span></span>.›</span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The refinement lemma written in higher-order form.›</span></span>
<span class="keyword1" id="Challenge2A-pop2_refine"><span class="command">lemma</span></span> pop2_refine<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>uncurry2 pop2<span class="main">,</span> uncurry2 <span class="main">(</span>RETURN <span class="keyword1">ooo</span> pop<span class="main">)</span><span class="main">)</span> <span class="main">∈</span> <span class="main">[</span><span class="main">λ</span><span class="main">(</span><span class="main">(</span><span class="bound">xs</span><span class="main">,</span><span class="bound">stk</span><span class="main">)</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">.</span> set <span class="bound">stk</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span>length <span class="bound">xs</span><span class="main">}</span><span class="keyword1">]<span class="hidden">⇩</span><sub>f</sub></span> <span class="main">(</span>Id <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> Id<span class="main">)</span> <span class="keyword1">×<span class="hidden">⇩</span><sub>r</sub></span> Id <span class="main">→</span> <span class="main">⟨</span>Id<span class="main">⟩</span>nres_rel"</span></span>
  <span class="keyword1"><span class="command">using</span></span> pop2_refine_aux
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> frefI nres_relI<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Next, we use the Sepref tool to synthesize an implementation on arrays.›</span></span>
<span class="keyword1"><span class="command">sepref_definition</span></span> <span class="entity">pop2_impl</span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"uncurry2 pop2"</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>array_assn id_assn<span class="main">)</span><span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> <span class="main">(</span>list_assn id_assn<span class="main">)</span><span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">*<span class="hidden">⇩</span><sub>a</sub></span> id_assn<span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> list_assn id_assn"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> pop2_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">sepref</span>
<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">sepref_fr_rules</span><span class="main">]</span> <span class="main">=</span> pop2_impl.refine<span class="main">[</span><span class="operator">FCOMP</span> pop2_refine<span class="main">]</span>  

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Implementation of Main Algorithm›</span></span>  

<span class="keyword1"><span class="command">sepref_definition</span></span> <span class="entity">all_left_impl</span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">all_left</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>array_assn id_assn<span class="main">)</span><span class="keyword1"><span class="hidden">⇧</span><sup>k</sup></span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> array_assn <span class="main">(</span>option_assn id_assn<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> all_left_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rewrite</span> <span class="quasi_keyword">at</span> <span class="quoted"><span class="quoted"><span class="quoted">"nfoldli <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">(</span></span><span class="main"><span class="main">⌑</span></span><span class="main"><span class="main">,</span></span><span class="main"><span class="main">_</span></span><span class="main"><span class="main">)</span></span>"</span></span></span> HOL_list.fold_custom_empty<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rewrite</span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="quoted"><span class="quoted"><span class="quoted">"nfoldli <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">(</span></span><span class="main"><span class="main">_</span></span><span class="main"><span class="main">,</span></span><span class="main"><span class="main">⌑</span></span><span class="main"><span class="main">)</span></span>"</span></span></span> array_fold_custom_replicate<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">sepref</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Correctness Theorem for Concrete Algorithm›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We compose the correctness theorem and the refinement theorem, to get a correctness
  theorem for the final implementation.›</span></span>
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Abstract correctness theorem in higher-order form.›</span></span>
<span class="keyword1" id="Challenge2A-algo_correct'"><span class="command">lemma</span></span> algo_correct'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>all_left<span class="main">,</span> SPEC <span class="keyword1">o</span> all_left_spec<span class="main">)</span> 
  <span class="main">∈</span> <span class="main">⟨</span>Id<span class="main">⟩</span>list_rel <span class="main">→</span> <span class="main">⟨</span><span class="main">⟨</span><span class="main">⟨</span>Id<span class="main">⟩</span>option_rel<span class="main">⟩</span>list_rel<span class="main">⟩</span>nres_rel"</span></span>
  <span class="keyword1"><span class="command">using</span></span> algo_correct <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> nres_relI<span class="main">)</span>  

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Main correctness theorem in higher-order form.›</span></span>   
<span class="keyword1"><span class="command">theorem</span></span> algo_impl_correct<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">(</span>all_left_impl<span class="main">,</span> SPEC <span class="keyword1">o</span> all_left_spec<span class="main">)</span>
    <span class="main">∈</span> <span class="main">(</span>array_assn int_assn<span class="main">,</span> array_assn int_assn<span class="main">)</span> <span class="keyword1">→<span class="hidden">⇩</span><sub>a</sub></span> array_assn <span class="main">(</span>option_assn nat_assn<span class="main">)</span>"</span></span>      
  <span class="keyword1"><span class="command">using</span></span> all_left_impl.refine<span class="main">[</span><span class="operator">FCOMP</span> algo_correct'<span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span> <span class="keyword1"><span class="command">.</span></span>
    
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Main correctness theorem as Hoare-Triple›</span></span>  
<span class="keyword1"><span class="command">theorem</span></span> algo_impl_correct'<span class="main">:</span> <span class="quoted"><span class="quoted">"
  <span class="main">&lt;</span>array_assn int_assn <span class="free">xs</span> <span class="free">xsi</span><span class="main">&gt;</span> 
    all_left_impl <span class="free">xsi</span> 
  <span class="main">&lt;</span><span class="main">λ</span><span class="bound">lfi</span><span class="main">.</span> <span class="keyword1">∃<span class="hidden">⇩</span><sub>A</sub></span><span class="bound">lf</span><span class="main">.</span> array_assn int_assn <span class="free">xs</span> <span class="free">xsi</span> 
        <span class="main">*</span> array_assn <span class="main">(</span>option_assn id_assn<span class="main">)</span> <span class="bound">lf</span> <span class="bound">lfi</span> 
        <span class="main">*</span> <span class="main">↑</span><span class="main">(</span>all_left_spec <span class="free">xs</span> <span class="bound">lf</span><span class="main">)</span><span class="keyword1">&gt;<span class="hidden">⇩</span><sub>t</sub></span>"</span></span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> cons_rule<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ _ algo_impl_correct<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">to_hnr</span><span class="main"><span class="main"><span class="main">,</span></span></span> <span class="operator">THEN</span> hn_refineD<span class="main"><span class="main"><span class="main">,</span></span></span> <span class="operator">unfolded</span> <span class="dynamic"><span class="dynamic">autoref_tag_defs</span></span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> hn_ctxt_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> ent_refl<span class="main">)</span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hn_ctxt_def<span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Code Generation›</span></span>
    
<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">all_left_impl</span></span> <span class="keyword2"><span class="keyword">checking</span></span> SML Scala Haskell<span class="main">?</span> OCaml<span class="main">?</span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The example from the problem description, in ML using the verified algorithm›</span></span>
<span class="keyword1"><span class="command">ML_val</span></span> <span class="quoted">‹
  <span class="comment1">(* Convert from option to 1-based indexes *)</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">cnv</span> NONE <span class="main">=</span> <span class="inner_numeral">0</span>
    <span class="main">|</span> <span class="entity">cnv</span> <span class="main">(</span>SOME <span class="entity">i</span><span class="main">)</span> <span class="main">=</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">integer_of_nat</span><span class="antiquote">}</span></span></span> <span class="entity">i</span> + <span class="inner_numeral">1</span>

  <span class="comment1">(* The verified algorithm, boxing the input list into an array, 
    and unboxing the output to a list, and converting it from option to 1-based *)</span>
  <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">all_left</span> <span class="entity">xs</span> <span class="main">=</span> 
       <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">all_left_impl</span><span class="antiquote">}</span></span></span> <span class="main">(</span>Array.fromList <span class="main">(</span>map <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">code</span> <span class="quoted">int_of_integer</span><span class="antiquote">}</span></span></span> <span class="entity">xs</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">)</span>
    |&gt; Array.foldr <span class="main">(</span><span class="keyword1"><span class="keyword">op</span></span> ::<span class="main">)</span> <span class="main">[</span><span class="main">]</span>
    |&gt; map <span class="entity">cnv</span>

  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">test</span> <span class="main">=</span> <span class="entity">all_left</span> <span class="main">[</span> <span class="inner_numeral">4</span><span class="main">,</span> <span class="inner_numeral">7</span><span class="main">,</span> <span class="inner_numeral">8</span><span class="main">,</span> <span class="inner_numeral">1</span><span class="main">,</span> <span class="inner_numeral">2</span><span class="main">,</span> <span class="inner_numeral">3</span><span class="main">,</span> <span class="inner_numeral">9</span><span class="main">,</span> <span class="inner_numeral">5</span><span class="main">,</span> <span class="inner_numeral">6</span> <span class="main">]</span>  
›</span>
 
<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="Challenge2B">
<div class="head">
<h1>Theory Challenge2B</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Challenge 2.B›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Challenge2B
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="Challenge2A.html">Challenge2A</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We did not get very far on this part of the competition. Only Task 2 was finished.›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Basic Definitions›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> tree <span class="main">=</span> Leaf <span class="main">|</span> Node <span class="quoted">int</span> <span class="main">(</span><span class="free"><span class="entity">lc</span></span><span class="main">:</span> <span class="quoted">tree</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="entity">rc</span></span><span class="main">:</span> <span class="quoted">tree</span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Analogous to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">left_spec</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> from 2.A.›</span></span>
<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">right_spec</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="main">(</span><span class="main">∃</span><span class="bound"><span class="bound">i</span></span><span class="main">&gt;</span><span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">!</span> <span class="bound">i</span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">!</span> <span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">)</span> <span class="keyword1">then</span> Some <span class="main">(</span><span class="keyword1">LEAST</span> <span class="bound">i</span><span class="main">.</span> <span class="bound">i</span> <span class="main">&gt;</span> <span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">!</span> <span class="bound">i</span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">!</span> <span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">)</span> <span class="keyword1">else</span> None<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"int list"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"distinct <span class="free">xs</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Specification of the Parent›</span></span>
<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">parent</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">=</span> <span class="main">(</span>
    <span class="keyword1">case</span> <span class="main">(</span>left_spec <span class="free">xs</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">,</span> right_spec <span class="free">xs</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> <span class="keyword1">of</span>
      <span class="main">(</span>None<span class="main">,</span> None<span class="main">)</span> <span class="main">⇒</span> None
    <span class="main">|</span> <span class="main">(</span>Some <span class="bound">x</span><span class="main">,</span> None<span class="main">)</span> <span class="main">⇒</span> Some <span class="bound">x</span>
    <span class="main">|</span> <span class="main">(</span>None<span class="main">,</span> Some <span class="bound">y</span><span class="main">)</span> <span class="main">⇒</span> Some <span class="bound">y</span>
    <span class="main">|</span> <span class="main">(</span>Some <span class="bound">x</span><span class="main">,</span> Some <span class="bound">y</span><span class="main">)</span> <span class="main">⇒</span> Some <span class="main">(</span>max <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span>
  <span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹The Heap Property (Task 2)›</span></span>

<span class="keyword1" id="Challenge2B-parent_heap"><span class="command">lemma</span></span> parent_heap<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"parent <span class="free">j</span> <span class="main">=</span> Some <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">!</span> <span class="free">j</span> <span class="main">&gt;</span> <span class="free">xs</span> <span class="main">!</span> <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span> <span class="main">=</span> left_spec_None_iff swap_adhoc
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∃</span><span class="bound"><span class="bound">i</span></span><span class="main">&lt;</span><span class="free">j</span><span class="main">.</span> <span class="free">xs</span> <span class="main">!</span> <span class="bound">i</span> <span class="main">&lt;</span> <span class="free">xs</span> <span class="main">!</span> <span class="free">j</span><span class="main">)</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">!</span> the <span class="main">(</span>left_spec <span class="free">xs</span> <span class="free">j</span><span class="main">)</span> <span class="main">&lt;</span> <span class="free">xs</span> <span class="main">!</span> <span class="free">j</span>"</span></span> <span class="quoted"><span class="quoted">"left_spec <span class="free">xs</span> <span class="free">j</span> <span class="main">≠</span> None"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> left_spec_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> GreatestI_nat True less_le<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∃</span><span class="bound"><span class="bound">i</span></span><span class="main">&gt;</span><span class="free">j</span><span class="main">.</span> <span class="free">xs</span> <span class="main">!</span> <span class="bound">i</span> <span class="main">&lt;</span> <span class="free">xs</span> <span class="main">!</span> <span class="free">j</span><span class="main">)</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">!</span> the <span class="main">(</span>right_spec <span class="free">xs</span> <span class="free">j</span><span class="main">)</span> <span class="main">&lt;</span> <span class="free">xs</span> <span class="main">!</span> <span class="free">j</span>"</span></span> <span class="quoted"><span class="quoted">"right_spec <span class="free">xs</span> <span class="free">j</span> <span class="main">≠</span> None"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> right_spec_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> LeastI<span class="main">)</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">using</span></span> * assms <span class="keyword1"><span class="command">unfolding</span></span> parent_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> False
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"right_spec <span class="free">xs</span> <span class="free">j</span> <span class="main">=</span> None"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> right_spec_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">using</span></span> * assms <span class="keyword1"><span class="command">unfolding</span></span> parent_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"left_spec <span class="free">xs</span> <span class="free">j</span> <span class="main">=</span> None"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> left_spec_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∃</span><span class="bound"><span class="bound">i</span></span><span class="main">&gt;</span><span class="free">j</span><span class="main">.</span> <span class="free">xs</span> <span class="main">!</span> <span class="bound">i</span> <span class="main">&lt;</span> <span class="free">xs</span> <span class="main">!</span> <span class="free">j</span><span class="main">)</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">!</span> the <span class="main">(</span>right_spec <span class="free">xs</span> <span class="free">j</span><span class="main">)</span> <span class="main">&lt;</span> <span class="free">xs</span> <span class="main">!</span> <span class="free">j</span>"</span></span> <span class="quoted"><span class="quoted">"right_spec <span class="free">xs</span> <span class="free">j</span> <span class="main">≠</span> None"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> right_spec_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> LeastI<span class="main">)</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> parent_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> False
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"right_spec <span class="free">xs</span> <span class="free">j</span> <span class="main">=</span> None"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> right_spec_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> parent_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="Parallel_Multiset_Fold">
<div class="head">
<h1>Theory Parallel_Multiset_Fold</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Iterating a Commutative Computation Concurrently›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Parallel_Multiset_Fold
  <span class="keyword2"><span class="keyword">imports</span></span> <span class="quoted">"<a href="../../HOL/HOL-Library/Multiset.html">HOL-Library.Multiset</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
This theory formalizes a deep embedding of a simple parallel computation model.
In this model, we formalize a computation scheme to execute a fold-function over a
commutative operation concurrently, and prove it correct.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Misc›</span></span>

<span class="comment1">(* TODO: Move *)</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> comp_fun_commute<span class="main">)</span> fold_mset_rewr<span class="main">:</span> <span class="quoted"><span class="quoted">"fold_mset <span class="free">f</span> <span class="free">a</span> <span class="main">(</span>mset <span class="free">l</span><span class="main">)</span> <span class="main">=</span> fold <span class="free">f</span> <span class="free">l</span> <span class="free">a</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">l</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">a</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">metis</span> fold_mset_fun_left_comm<span class="main">)</span>

<span class="keyword1" id="Parallel_Multiset_Fold-finite_set_of_finite_maps"><span class="command">lemma</span></span> finite_set_of_finite_maps<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">A</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">B</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> set"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">B</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">{</span><span class="bound">m</span><span class="main">.</span> dom <span class="bound">m</span> <span class="main">⊆</span> <span class="free">A</span> <span class="main">∧</span> ran <span class="bound">m</span> <span class="main">⊆</span> <span class="free">B</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">m</span><span class="main">.</span> dom <span class="bound">m</span> <span class="main">⊆</span> <span class="free">A</span> <span class="main">∧</span> ran <span class="bound">m</span> <span class="main">⊆</span> <span class="free">B</span><span class="main">}</span> <span class="main">⊆</span> <span class="main">(</span><span class="main">⋃</span> <span class="bound">S</span> <span class="main">∈</span> <span class="main">{</span><span class="bound">S</span><span class="main">.</span> <span class="bound">S</span> <span class="main">⊆</span> <span class="free">A</span><span class="main">}</span><span class="main">.</span> <span class="main">{</span><span class="bound">m</span><span class="main">.</span> dom <span class="bound">m</span> <span class="main">=</span> <span class="bound">S</span> <span class="main">∧</span> ran <span class="bound">m</span> <span class="main">⊆</span> <span class="free">B</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">…</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> finite_set_of_finite_maps <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> finite_subset<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> finite_subset<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Parallel_Multiset_Fold-wf_rtranclp_ev_induct"><span class="command">lemma</span></span> wf_rtranclp_ev_induct<span class="main">[</span><span class="operator">consumes</span> 1<span class="main">,</span> <span class="operator">case_names</span> step<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"wf <span class="main">{</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="free">R</span> <span class="bound">y</span> <span class="bound">x</span><span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> step<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">x</span><span class="main">.</span> <span class="free">R</span><span class="main"><span class="hidden">⇧</span><sup>*</sup><span class="hidden">⇧</span><sup>*</sup></span> <span class="free">a</span> <span class="bound">x</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">x</span> <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span> <span class="bound">y</span><span class="main">.</span> <span class="free">R</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">x</span> <span class="main">∧</span> <span class="free">R</span><span class="main"><span class="hidden">⇧</span><sup>*</sup><span class="hidden">⇧</span><sup>*</sup></span> <span class="free">a</span> <span class="bound">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">y</span><span class="main">.</span> <span class="free">P</span> <span class="bound">y</span> <span class="main">∧</span> <span class="free">R</span><span class="main"><span class="hidden">⇧</span><sup>*</sup><span class="hidden">⇧</span><sup>*</sup></span> <span class="skolem">x</span> <span class="bound">y</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">R</span><span class="main"><span class="hidden">⇧</span><sup>*</sup><span class="hidden">⇧</span><sup>*</sup></span> <span class="free">a</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span>
    <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>1<span class="main">)</span> that
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">induction</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>less <span class="skolem">x</span><span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> step<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹<span class="free">R</span><span class="main"><span class="hidden">⇧</span><sup>*</sup><span class="hidden">⇧</span><sup>*</sup></span> <span class="free">a</span> <span class="skolem">x</span>›</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="skolem">x</span> <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">y</span><span class="main">.</span> <span class="free">R</span> <span class="skolem">x</span> <span class="bound">y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="skolem">x</span>"</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">y</span><span class="main">.</span> <span class="free">R</span> <span class="skolem">x</span> <span class="bound">y</span>"</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">y</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="skolem">x</span> <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
      <span class="keyword1"><span class="command">with</span></span> less<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">y</span></span><span class="main">]</span> less<span class="main">(</span>2<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="main">(</span><span class="operator">meson</span> converse_rtranclp_into_rtranclp rtranclp.rtrancl_into_rtrancl<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹The Concurrent System›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  A state of our concurrent systems consists of a list of tasks,
  a partial map from threads to the task they are currently working on,
  and the current computation result.›</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'s</span><span class="main">)</span> state <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">×</span> <span class="main">(</span>nat <span class="main">⇀</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">×</span> <span class="tfree">'s</span>"</span></span>

<span class="keyword1"><span class="command">context</span></span> comp_fun_commute
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">n</span> <span class="main">::</span> <span class="quoted">nat</span> <span class="comment1">― ‹The number of threads.›</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> n_gt_0<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  A state is <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">∗</span></span>‹final›</span></span> if there are no remaining tasks and if all workers have finished their work.›</span></span>
<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">final</span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">ts</span><span class="main">,</span> <span class="bound">ws</span><span class="main">,</span> <span class="bound">r</span><span class="main">)</span><span class="main">.</span> <span class="bound">ts</span> <span class="main">=</span> <span class="main">[]</span> <span class="main">∧</span> dom <span class="bound">ws</span> <span class="main">∩</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹At any point a thread can:
  <span class="antiquoted"><span class="antiquoted">▪</span></span> pick a new task from the queue if it is currently not busy
  <span class="antiquoted"><span class="antiquoted">▪</span></span> or execute its current task.›</span></span>
<span class="keyword1"><span class="command">inductive</span></span> <span class="entity">step</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> state <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'b</span><span class="main">)</span> state <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  pick<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">step</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">ts</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">ws</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">ts</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">ws</span></span></span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">:=</span> Some <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">)</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>"</span></span>   <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">ws</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">=</span> None"</span></span>   <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">&lt;</span> <span class="free">n</span>"</span></span>
<span class="main">|</span> exec<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">step</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">ts</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">ws</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>     <span class="main">(</span><span class="free"><span class="bound"><span class="entity">ts</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">ws</span></span></span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">:=</span> None<span class="main">)</span><span class="main">,</span> <span class="free">f</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">ws</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">=</span> Some <span class="free"><span class="bound"><span class="entity">a</span></span></span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">&lt;</span> <span class="free">n</span>"</span></span>

<span class="keyword1" id="Parallel_Multiset_Fold-no_deadlock"><span class="command">lemma</span></span> no_deadlock<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> final <span class="free">cfg</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">cfg'</span><span class="main">.</span> step <span class="free">cfg</span> <span class="bound">cfg'</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">cfg</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> ts ws s
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">ts</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">ws</span> <span class="main">0</span>"</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> 4 5 <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> final_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> step.intros<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Parallel_Multiset_Fold-wf_step"><span class="command">lemma</span></span> wf_step<span class="main">:</span>
  <span class="quoted"><span class="quoted">"wf <span class="main">{</span><span class="main">(</span><span class="main">(</span><span class="bound">ts'</span><span class="main">,</span> <span class="bound">ws'</span><span class="main">,</span> <span class="bound">r'</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="bound">ts</span><span class="main">,</span> <span class="bound">ws</span><span class="main">,</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span><span class="main">.</span>
    step <span class="main">(</span><span class="bound">ts</span><span class="main">,</span> <span class="bound">ws</span><span class="main">,</span> <span class="bound">r</span><span class="main">)</span> <span class="main">(</span><span class="bound">ts'</span><span class="main">,</span> <span class="bound">ws'</span><span class="main">,</span> <span class="bound">r'</span><span class="main">)</span> <span class="main">∧</span> set <span class="bound">ts'</span> <span class="main">⊆</span> <span class="free">S</span> <span class="main">∧</span> dom <span class="bound">ws</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">}</span> <span class="main">∧</span> ran <span class="bound">ws</span> <span class="main">⊆</span> <span class="free">S</span><span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">S</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?R1</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> dom <span class="bound">x</span> <span class="main">⊂</span> dom <span class="bound">y</span> <span class="main">∧</span> ran <span class="bound">x</span> <span class="main">⊆</span> <span class="free">S</span> <span class="main">∧</span> dom <span class="bound">y</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">}</span> <span class="main">∧</span> ran <span class="bound">y</span> <span class="main">⊆</span> <span class="free">S</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?R1</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound">y</span><span class="main">.</span> dom <span class="bound">y</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">}</span> <span class="main">∧</span> ran <span class="bound">y</span> <span class="main">⊆</span> <span class="free">S</span><span class="main">}</span> <span class="main">×</span> <span class="main">{</span><span class="bound">y</span><span class="main">.</span> dom <span class="bound">y</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">}</span> <span class="main">∧</span> ran <span class="bound">y</span> <span class="main">⊆</span> <span class="free">S</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="var">?R1</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹finite <span class="free">S</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">erule</span> finite_subset<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> finite_set_of_finite_maps<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"wf <span class="var">?R1</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> finite_acyclic_wf<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> preorder_class.acyclicI_order<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">x</span></span><span class="main"><span class="main">.</span></span> <span class="free"><span class="free">n</span></span> <span class="main"><span class="main">-</span></span> card <span class="main"><span class="main">(</span></span>dom <span class="bound"><span class="bound">x</span></span><span class="main"><span class="main">)</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>full_types<span class="main"><span class="main">)</span></span> 
        cancel_ab_semigroup_add_class.diff_right_commute diff_diff_cancel domD domI
        psubsetI psubset_card_mono subset_eq_atLeast0_lessThan_card
        subset_eq_atLeast0_lessThan_finite zero_less_diff<span class="main">)</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?R</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"measure length <span class="keyword1">&lt;*lex*&gt;</span> <span class="var">?R1</span> <span class="keyword1">&lt;*lex*&gt;</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"wf <span class="var">?R</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> wf_subset<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> step.cases<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span>
        Diff_iff domIff fun_upd_apply mem_Collect_eq option.simps<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> psubsetI ran_def
        singletonI subset_iff<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">ts</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">start</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">s<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">=</span> <span class="main">(</span><span class="free">ts</span><span class="main">,</span> <span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> None<span class="main">,</span> <span class="free">start</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">reachable</span> <span class="main">≡</span> <span class="main">(</span>step<span class="main"><span class="hidden">⇧</span><sup>*</sup><span class="hidden">⇧</span><sup>*</sup></span><span class="main">)</span> s<span class="hidden">⇩</span><sub>0</sub>"</span></span>

<span class="keyword1" id="Parallel_Multiset_Fold-reachable0"><span class="command">lemma</span></span> reachable0<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"reachable s<span class="hidden">⇩</span><sub>0</sub>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> reachable_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">is_invar</span> <span class="free"><span class="bound"><span class="entity">I</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">I</span></span></span> s<span class="hidden">⇩</span><sub>0</sub> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">s</span> <span class="bound">s'</span><span class="main">.</span> reachable <span class="bound">s</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">I</span></span></span> <span class="bound">s</span> <span class="main">∧</span> step <span class="bound">s</span> <span class="bound">s'</span> <span class="main">⟶</span> <span class="free"><span class="bound"><span class="entity">I</span></span></span> <span class="bound">s'</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Parallel_Multiset_Fold-is_invarI"><span class="command">lemma</span></span> is_invarI<span class="main">[</span><span class="operator">intro</span><span class="main"><span class="main"><span class="main">?</span></span></span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">I</span> s<span class="hidden">⇩</span><sub>0</sub><span class="main">;</span> <span class="main">⋀</span><span class="bound">s</span> <span class="bound">s'</span><span class="main">.</span> <span class="main">⟦</span> reachable <span class="bound">s</span><span class="main">;</span> <span class="free">I</span> <span class="bound">s</span><span class="main">;</span> step <span class="bound">s</span> <span class="bound">s'</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">I</span> <span class="bound">s'</span> <span class="main">⟧</span> <span class="main">⟹</span> is_invar <span class="free">I</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> is_invar_def<span class="main">)</span>

<span class="keyword1" id="Parallel_Multiset_Fold-invar_reachable"><span class="command">lemma</span></span> invar_reachable<span class="main">:</span> <span class="quoted"><span class="quoted">"is_invar <span class="free">I</span> <span class="main">⟹</span> reachable <span class="free">s</span> <span class="main">⟹</span> <span class="free">I</span> <span class="free">s</span>"</span></span>  
  <span class="keyword1"><span class="command">unfolding</span></span> reachable_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">rotate_tac</span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rtranclp_induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> is_invar_def reachable_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">invar</span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">ts2</span><span class="main">,</span> <span class="bound">ws</span><span class="main">,</span> <span class="bound">r</span><span class="main">)</span><span class="main">.</span>
    <span class="main">(</span><span class="main">∃</span><span class="bound">ts1</span><span class="main">.</span>
      mset <span class="free">ts</span> <span class="main">=</span> <span class="bound">ts1</span> <span class="main">+</span> <span class="main">{#</span> the <span class="main">(</span><span class="bound">ws</span> <span class="bound">i</span><span class="main">)</span><span class="main">.</span> <span class="bound">i</span> <span class="main">∈#</span> mset_set <span class="main">(</span>dom <span class="bound">ws</span> <span class="main">∩</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">}</span><span class="main">)</span> <span class="main">#}</span> <span class="main">+</span> mset <span class="bound">ts2</span>
    <span class="main">∧</span> <span class="bound">r</span> <span class="main">=</span> fold_mset <span class="free">f</span> <span class="free">start</span> <span class="bound">ts1</span>
    <span class="main">∧</span> set <span class="bound">ts2</span> <span class="main">⊆</span> set <span class="free">ts</span> <span class="main">∧</span> ran <span class="bound">ws</span> <span class="main">⊆</span> set <span class="free">ts</span> <span class="main">∧</span> dom <span class="bound">ws</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">}</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Parallel_Multiset_Fold-invariant"><span class="command">lemma</span></span> invariant<span class="main">:</span>
  <span class="quoted"><span class="quoted">"is_invar invar"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> s<span class="hidden">⇩</span><sub>0</sub>_def <span class="keyword1"><span class="command">unfolding</span></span> invar_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> invar_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">elim</span> step.cases<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split_asm<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> ws i t ts ts1
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">ts1</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> mset_set.insert<span class="main">)</span>
         <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> multiset.map_cong0<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> ws i a ts ts1
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="quoted">"add_mset <span class="skolem"><span class="skolem">a</span></span> <span class="skolem"><span class="skolem">ts1</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
         <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> Diff_Int_distrib2<span class="main">)</span>
         <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> mset_set.remove<span class="main">)</span>
           <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> multiset.map_cong0 <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ran_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Parallel_Multiset_Fold-final_state_correct1"><span class="command">lemma</span></span> final_state_correct1<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"invar <span class="main">(</span><span class="free">ts'</span><span class="main">,</span> <span class="free">ms</span><span class="main">,</span> <span class="free">r</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"final <span class="main">(</span><span class="free">ts'</span><span class="main">,</span> <span class="free">ms</span><span class="main">,</span> <span class="free">r</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">=</span> fold_mset <span class="free">f</span> <span class="free">start</span> <span class="main">(</span>mset <span class="free">ts</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> invar_def final_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Parallel_Multiset_Fold-final_state_correct2"><span class="command">lemma</span></span> final_state_correct2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"reachable <span class="main">(</span><span class="free">ts'</span><span class="main">,</span> <span class="free">ms</span><span class="main">,</span> <span class="free">r</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"final <span class="main">(</span><span class="free">ts'</span><span class="main">,</span> <span class="free">ms</span><span class="main">,</span> <span class="free">r</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">=</span> fold_mset <span class="free">f</span> <span class="free">start</span> <span class="main">(</span>mset <span class="free">ts</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">rule</span> final_state_correct1<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> invar_reachable<span class="main"><span class="main">[</span></span><span class="operator">OF</span> invariant<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Soundness: whenever we reach a final state, the computation result is correct.›</span></span>
<span class="keyword1"><span class="command">theorem</span></span> final_state_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"reachable <span class="main">(</span><span class="free">ts'</span><span class="main">,</span> <span class="free">ms</span><span class="main">,</span> <span class="free">r</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"final <span class="main">(</span><span class="free">ts'</span><span class="main">,</span> <span class="free">ms</span><span class="main">,</span> <span class="free">r</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">=</span> fold <span class="free">f</span> <span class="free">ts</span> <span class="free">start</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> final_state_correct2<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fold_mset_rewr<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Termination: at any point during the program execution, we can continue to a final state.
That is, the computation always terminates.
›</span></span>
<span class="keyword1"><span class="command">theorem</span></span> <span class="quoted">"termination"</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"reachable <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">s'</span><span class="main">.</span> final <span class="bound">s'</span> <span class="main">∧</span> step<span class="main"><span class="hidden">⇧</span><sup>*</sup><span class="hidden">⇧</span><sup>*</sup></span> <span class="free">s</span> <span class="bound">s'</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="main">(</span><span class="bound">s'</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span><span class="main">.</span> step <span class="bound">s</span> <span class="bound">s'</span> <span class="main">∧</span> reachable <span class="bound">s</span><span class="main">}</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">(</span><span class="bound">s'</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span><span class="main">.</span> step <span class="bound">s</span> <span class="bound">s'</span> <span class="main">∧</span> reachable <span class="bound">s</span> <span class="main">∧</span> reachable <span class="bound">s'</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> reachable_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">(</span><span class="main">(</span><span class="bound">ts'</span><span class="main">,</span> <span class="bound">ws'</span><span class="main">,</span> <span class="bound">r'</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="bound">ts1</span><span class="main">,</span> <span class="bound">ws</span><span class="main">,</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span><span class="main">.</span>
    step <span class="main">(</span><span class="bound">ts1</span><span class="main">,</span> <span class="bound">ws</span><span class="main">,</span> <span class="bound">r</span><span class="main">)</span> <span class="main">(</span><span class="bound">ts'</span><span class="main">,</span> <span class="bound">ws'</span><span class="main">,</span> <span class="bound">r'</span><span class="main">)</span> <span class="main">∧</span> set <span class="bound">ts'</span> <span class="main">⊆</span> set <span class="free">ts</span> <span class="main">∧</span> dom <span class="bound">ws</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">}</span> <span class="main">∧</span> ran <span class="bound">ws</span> <span class="main">⊆</span> set <span class="free">ts</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> invar_reachable<span class="main"><span class="main">[</span></span><span class="operator">OF</span> invariant<span class="main"><span class="main">]</span></span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> invar_def<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"wf <span class="main">{</span><span class="main">(</span><span class="bound">s'</span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span><span class="main">.</span> step <span class="bound">s</span> <span class="bound">s'</span> <span class="main">∧</span> reachable <span class="bound">s</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">elim</span> wf_subset<span class="main"><span class="main">[</span></span><span class="operator">OF</span> wf_step<span class="main"><span class="main">,</span></span> <span class="operator">rotated</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">s'</span><span class="main">.</span> final <span class="bound">s'</span> <span class="main">∧</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span> <span class="bound">s'</span><span class="main">.</span> step <span class="bound">s</span> <span class="bound">s'</span> <span class="main">∧</span> reachable <span class="bound">s</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup><span class="hidden">⇧</span><sup>*</sup></span> <span class="free">s</span> <span class="bound">s'</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> wf_rtranclp_ev_induct<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">x</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">s</span> <span class="bound">s'</span><span class="main">.</span> step <span class="bound">s</span> <span class="bound">s'</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup><span class="hidden">⇧</span><sup>*</sup></span> <span class="free">s</span> <span class="skolem">x</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">elim</span> mono_rtranclp<span class="main"><span class="main">[</span></span><span class="operator">rule_format</span><span class="main"><span class="main">,</span></span> <span class="operator">rotated</span><span class="main"><span class="main">]</span></span> conjE<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹reachable <span class="free">s</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"reachable <span class="skolem">x</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> reachable_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">using</span></span> no_deadlock<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> exI conjI<span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> mono_rtranclp<span class="main"><span class="main">[</span></span><span class="operator">rule_format</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Fixed task list *)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Fixed number of workers *)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* Commutative function *)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The main theorems outside the locale:›</span></span>
<span class="keyword1"><span class="command">thm</span></span> comp_fun_commute.final_state_correct comp_fun_commute.termination

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">(* End of theory *)</span></pre>
</div><div id="Challenge3">
<div class="head">
<h1>Theory Challenge3</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Challenge 3›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Challenge3
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="Parallel_Multiset_Fold.html">Parallel_Multiset_Fold</a> <a href="../Refine_Imperative_HOL/IICF.html">Refine_Imperative_HOL.IICF</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Problem definition:
<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">🌐</span></span>‹https://ethz.ch/content/dam/ethz/special-interest/infk/chair-program-method/pm/documents/Verify%20This/Challenges%202019/sparse_matrix_multiplication.pdf›</span></span>›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Single-Threaded Implementation›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We define type synonyms for values (which we fix to integers here) and 
  triplets, which are a pair of coordinates and a value.
›</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> val <span class="main">=</span> <span class="quoted">int</span>
<span class="keyword1"><span class="command">type_synonym</span></span> triplet <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nat <span class="main">×</span> nat<span class="main">)</span> <span class="main">×</span> val"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We fix a size <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>n›</span></span></span></span> for the vector.›</span></span>
<span class="keyword1"><span class="command">context</span></span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">n</span> <span class="main">::</span> <span class="quoted">nat</span> 
<span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹An algorithm finishing triples in any order.
  ›</span></span>
  <span class="keyword1"><span class="command">definition</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">alg</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">ts</span></span></span> <span class="main">::</span> triplet list<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> fold_mset <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main">(</span><span class="bound">r</span><span class="main">,</span><span class="bound">c</span><span class="main">)</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">y</span><span class="main">(</span><span class="bound">c</span><span class="main">:=</span><span class="bound">y</span> <span class="bound">c</span> <span class="main">+</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="bound">r</span> <span class="main">*</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">0</span> <span class="main">::</span> int<span class="main">)</span> <span class="main">(</span>mset <span class="free"><span class="bound"><span class="entity">ts</span></span></span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
    We show that the folding function is commutative, i.e., the order of the folding does not matter.
    We will use this below to show that the computation can be parallelized.
  ›</span></span>  
  <span class="keyword1"><span class="command">interpretation</span></span> comp_fun_commute <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main">(</span><span class="bound">r</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">y</span><span class="main">(</span><span class="bound">c</span> <span class="main">:=</span> <span class="main">(</span><span class="bound">y</span> <span class="bound">c</span> <span class="main">::</span> val<span class="main">)</span> <span class="main">+</span> <span class="free">x</span> <span class="bound">r</span> <span class="main">*</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ext<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Specification›</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Abstraction function, mapping a sparse matrix to a function from coordinates to values.›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">α</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"triplet list <span class="main">⇒</span> <span class="main">(</span>nat <span class="main">×</span> nat<span class="main">)</span> <span class="main">⇒</span> val"</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">α</span> <span class="main">=</span> the_default <span class="main">0</span> <span class="keyword1">oo</span> map_of"</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Abstract product.›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">pr</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">≡</span> <span class="main">∑</span><span class="bound">k</span><span class="main">=</span><span class="main">0</span><span class="main">..&lt;</span><span class="free">n</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="bound">k</span> <span class="main">*</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">(</span><span class="bound">k</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span>"</span></span>    

  <span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Correctness›</span></span>

  <span class="keyword1" id="Challenge3-aux"><span class="command">lemma</span></span> aux<span class="main">:</span> 
    <span class="quoted"><span class="quoted">"
    distinct <span class="main">(</span>map fst <span class="main">(</span><span class="free">ts1</span><span class="main">@</span><span class="free">ts2</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span>
    the_default <span class="main">(</span><span class="main">0</span><span class="main">::</span>val<span class="main">)</span> <span class="main">(</span><span class="keyword1">case</span> map_of <span class="free">ts1</span> <span class="main">(</span><span class="free">k</span><span class="main">,</span> <span class="free">i</span><span class="main">)</span> <span class="keyword1">of</span> None <span class="main">⇒</span> map_of <span class="free">ts2</span> <span class="main">(</span><span class="free">k</span><span class="main">,</span> <span class="free">i</span><span class="main">)</span> <span class="main">|</span> Some <span class="bound">x</span> <span class="main">⇒</span> Some <span class="bound">x</span><span class="main">)</span>
    
    <span class="main">=</span> the_default <span class="main">0</span> <span class="main">(</span>map_of <span class="free">ts1</span> <span class="main">(</span><span class="free">k</span><span class="main">,</span> <span class="free">i</span><span class="main">)</span><span class="main">)</span> <span class="main">+</span> the_default <span class="main">0</span> <span class="main">(</span>map_of <span class="free">ts2</span> <span class="main">(</span><span class="free">k</span><span class="main">,</span> <span class="free">i</span><span class="main">)</span><span class="main">)</span>
    "</span></span>    
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> disjoint_iff_not_equal img_fst map_of_eq_None_iff the_default.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
    
  <span class="keyword1" id="Challenge3-1"><span class="command">lemma</span></span> 1<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map fst <span class="main">(</span><span class="free">ts1</span><span class="main">@</span><span class="free">ts2</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> 
    pr <span class="main">(</span>α <span class="main">(</span><span class="free">ts1</span><span class="main">@</span><span class="free">ts2</span><span class="main">)</span><span class="main">)</span> <span class="free">x</span> <span class="free">i</span> <span class="main">=</span> pr <span class="main">(</span>α <span class="free">ts1</span><span class="main">)</span> <span class="free">x</span> <span class="free">i</span> <span class="main">+</span> pr <span class="main">(</span>α <span class="free">ts2</span><span class="main">)</span> <span class="free">x</span> <span class="free">i</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pr_def α_def map_add_def aux <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">algebra_simps</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sum.distrib<span class="main">)</span>

  <span class="keyword1"><span class="command">lemmas</span></span> 2 <span class="main">=</span> 1<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">(</span><span class="main">(</span><span class="free">r</span><span class="main">,</span><span class="free">c</span><span class="main">)</span><span class="main">,</span><span class="free">v</span><span class="main">)</span><span class="main">]</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">ts</span>"</span></span><span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">r</span> <span class="free">c</span> <span class="free">v</span> <span class="free">ts</span> 
    
  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"α <span class="main">[]</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">0</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> α_def<span class="main">)</span>  
    
  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"pr <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">0</span><span class="main">::</span>val<span class="main">)</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">0</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pr_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  
  <span class="keyword1" id="Challenge3-aux3"><span class="command">lemma</span></span> aux3<span class="main">:</span> <span class="quoted"><span class="quoted">"the_default <span class="main">0</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">b</span> <span class="keyword1">then</span> Some <span class="free">x</span> <span class="keyword1">else</span> None<span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">b</span> <span class="keyword1">then</span> <span class="free">x</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  
  <span class="keyword1" id="Challenge3-correct_aux"><span class="command">lemma</span></span> correct_aux<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>distinct <span class="main">(</span>map fst <span class="free">ts</span><span class="main">)</span><span class="main">;</span> <span class="main">∀</span><span class="main">(</span><span class="main">(</span><span class="bound">r</span><span class="main">,</span><span class="bound">c</span><span class="main">)</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">∈</span>set <span class="free">ts</span><span class="main">.</span> <span class="bound">r</span><span class="main">&lt;</span><span class="free">n</span><span class="main">⟧</span> 
    <span class="main">⟹</span> <span class="main">∀</span><span class="bound">i</span><span class="main">.</span> fold <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main">(</span><span class="bound">r</span><span class="main">,</span><span class="bound">c</span><span class="main">)</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">y</span><span class="main">(</span><span class="bound">c</span><span class="main">:=</span><span class="bound">y</span> <span class="bound">c</span> <span class="main">+</span> <span class="free">x</span> <span class="bound">r</span> <span class="main">*</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span> <span class="free">ts</span> <span class="free">m</span> <span class="bound">i</span> <span class="main">=</span> <span class="free">m</span> <span class="bound">i</span> <span class="main">+</span> pr <span class="main">(</span>α <span class="free">ts</span><span class="main">)</span> <span class="free">x</span> <span class="bound">i</span>"</span></span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">ts</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">m</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> 2<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> 
      <span class="keyword1"><span class="command">unfolding</span></span> pr_def α_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> sum.cong <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> aux3<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> if_distrib<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">_</span><span class="main">*</span><span class="bound">x</span>"</span></span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> sum.cong if_cong<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
        
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> 2<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span> 
      <span class="keyword1"><span class="command">unfolding</span></span> pr_def α_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> sum.cong <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> aux3<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

    
  <span class="keyword1" id="Challenge3-correct_fold"><span class="command">lemma</span></span> correct_fold<span class="main">:</span> 
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map fst <span class="free">ts</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="main">(</span><span class="main">(</span><span class="bound">r</span><span class="main">,</span><span class="bound">c</span><span class="main">)</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">∈</span>set <span class="free">ts</span><span class="main">.</span> <span class="bound">r</span><span class="main">&lt;</span><span class="free">n</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fold <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main">(</span><span class="bound">r</span><span class="main">,</span><span class="bound">c</span><span class="main">)</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">y</span><span class="main">(</span><span class="bound">c</span><span class="main">:=</span><span class="bound">y</span> <span class="bound">c</span> <span class="main">+</span> <span class="free">x</span> <span class="bound">r</span> <span class="main">*</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span> <span class="free">ts</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">0</span><span class="main">)</span> <span class="main">=</span> pr <span class="main">(</span>α <span class="free">ts</span><span class="main">)</span> <span class="free">x</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ext<span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> correct_aux<span class="main">[</span><span class="operator">OF</span> assms<span class="main">,</span> <span class="operator">rule_format</span><span class="main">,</span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> m <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">0</span>"</span></span><span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

  <span class="keyword1" id="Challenge3-alg_by_fold"><span class="command">lemma</span></span> alg_by_fold<span class="main">:</span> <span class="quoted"><span class="quoted">"alg <span class="free">ts</span> <span class="free">x</span> <span class="main">=</span> fold <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main">(</span><span class="bound">r</span><span class="main">,</span><span class="bound">c</span><span class="main">)</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">y</span><span class="main">(</span><span class="bound">c</span><span class="main">:=</span><span class="bound">y</span> <span class="bound">c</span> <span class="main">+</span> <span class="free">x</span> <span class="bound">r</span> <span class="main">*</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span> <span class="free">ts</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">0</span><span class="main">)</span>"</span></span>    
    <span class="keyword1"><span class="command">unfolding</span></span> alg_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fold_mset_rewr<span class="main">)</span>
          
  <span class="keyword1"><span class="command">theorem</span></span> correct<span class="main">:</span> 
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map fst <span class="free">ts</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="main">(</span><span class="main">(</span><span class="bound">r</span><span class="main">,</span><span class="bound">c</span><span class="main">)</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">∈</span>set <span class="free">ts</span><span class="main">.</span> <span class="bound">r</span><span class="main">&lt;</span><span class="free">n</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"alg <span class="free">ts</span> <span class="free">x</span> <span class="main">=</span> pr <span class="main">(</span>α <span class="free">ts</span><span class="main">)</span> <span class="free">x</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> alg_by_fold correct_fold<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> 

  <span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Multi-Threaded Implementation›</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Correctness of the parallel implementation:›</span></span>
  <span class="keyword1"><span class="command">theorem</span></span> parallel_correct<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map fst <span class="free">ts</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="main">(</span><span class="main">(</span><span class="bound">r</span><span class="main">,</span><span class="bound">c</span><span class="main">)</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">∈</span>set <span class="free">ts</span><span class="main">.</span> <span class="bound">r</span><span class="main">&lt;</span><span class="free">n</span>"</span></span>
        <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">&lt;</span> <span class="free">n</span>"</span></span> <span class="comment1">― ‹At least on thread›</span>
        <span class="comment1">―‹We have reached a final state.›</span>
        <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"reachable <span class="free">x</span> <span class="free">n</span> <span class="free">ts</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">0</span><span class="main">)</span> <span class="main">(</span><span class="free">ts'</span><span class="main">,</span> <span class="free">ms</span><span class="main">,</span> <span class="free">r</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"final <span class="free">n</span> <span class="main">(</span><span class="free">ts'</span><span class="main">,</span> <span class="free">ms</span><span class="main">,</span> <span class="free">r</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">=</span> pr <span class="main">(</span>α <span class="free">ts</span><span class="main">)</span> <span class="free">x</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> final_state_correct<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>3-<span class="main"><span class="main">)</span></span><span class="main">]</span> correct<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">,</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span> alg_by_fold<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">..</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We also know that the computation will always terminate.›</span></span>
  <span class="keyword1"><span class="command">theorem</span></span> parallel_termination<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">&lt;</span> <span class="free">n</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"reachable <span class="free">x</span> <span class="free">n</span> <span class="free">ts</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="main">0</span><span class="main">)</span> <span class="free">s</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">s'</span><span class="main">.</span> final <span class="free">n</span> <span class="bound">s'</span> <span class="main">∧</span> <span class="main">(</span>step <span class="free">x</span> <span class="free">n</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup><span class="hidden">⇧</span><sup>*</sup></span> <span class="free">s</span> <span class="bound">s'</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> <span class="quoted">"termination"</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Context for fixed <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>n›</span></span>.›</span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div>