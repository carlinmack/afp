{
    "theories": [
        {
            "Monads": [
                "bind_left_unit",
                "bind_right_unit",
                "bind_assoc",
                "mbind_unit",
                "mbind_nofailure",
                "mbind_try",
                "malt_SE_mt",
                "malt_SE_cons",
                "bind_left_unit_SB",
                "bind_right_unit_SB",
                "bind_assoc_SB",
                "bind_left_unit_SBE",
                "bind_right_unit_SBE",
                "bind_assoc_SBE",
                "syntax_test",
                "valid_true",
                "valid_failure",
                "valid_failure'",
                "valid_successElem",
                "valid_success",
                "valid_success''",
                "valid_success'",
                "valid_both",
                "valid_propagate_1",
                "valid_propagate_2",
                "valid_propagate_2'",
                "valid_propagate_2''",
                "valid_propoagate_3",
                "valid_propoagate_3'",
                "assert_disch1",
                "assert_disch2",
                "assert_disch3",
                "assert_D",
                "assume_D",
                "if_SE_D1",
                "if_SE_D2",
                "if_SE_split_asm",
                "if_SE_split",
                "assume_assert",
                "assert_intro"
            ]
        },
        {
            "UPFCore": [
                "test",
                "test2",
                "pol_upd_triv1",
                "pol_upd_triv2",
                "pol_upd_allow_nonempty",
                "pol_upd_deny_nonempty",
                "pol_upd_eqD1",
                "pol_upd_eqD2",
                "pol_upd_neq1",
                "override_empty",
                "empty_override",
                "override_assoc",
                "override_A_empty",
                "empty_override_A",
                "override_A_assoc",
                "override_D_empty",
                "empty_override_D",
                "override_D_assoc",
                "policy_range_comp_strict",
                "range_split_strict",
                "range_split_charn",
                "range_split_vs_range_compose",
                "range_split_id",
                "range_split_bi_compose"
            ]
        },
        {
            "ElementaryPolicies": [
                "AllD_norm",
                "AllD_norm2",
                "AllA_norm",
                "AllA_norm2",
                "AllA_apply",
                "AllD_apply",
                "neq_Allow_Deny",
                "allow_left_cancel",
                "deny_left_cancel",
                "sub_ran",
                "dom_allow_pfun",
                "dom_allow_all",
                "dom_deny_pfun",
                "dom_deny_all",
                "ran_allow_pfun",
                "ran_allow_all",
                "ran_deny_pfun",
                "ran_deny_all",
                "dom_dom_restrict",
                "dom_restrict_idem",
                "dom_restrict_inter",
                "ran_ran_restrict",
                "ran_restrict_idem",
                "ran_restrict_inter",
                "ran_gen_A",
                "ran_gen_D"
            ]
        },
        {
            "SeqComposition": [
                "flat_orA_deny",
                "flat_orA_allow",
                "flat_orD_allow",
                "flat_orD_deny",
                "flat_1_allow",
                "flat_1_deny",
                "flat_2_allow",
                "flat_2_deny",
                "lift_mt",
                "comp_orA_mt",
                "mt_comp_orA",
                "comp_orD_mt",
                "mt_comp_orD",
                "comp_1_mt",
                "mt_comp_1",
                "comp_2_mt",
                "mt_comp_2"
            ]
        },
        {
            "ParallelComposition": [
                "prod_orA_mt",
                "mt_prod_orA",
                "prod_orA_quasi_commute",
                "prod_orD_mt",
                "mt_prod_orD",
                "prod_orD_quasi_commute",
                "prod_1_mt",
                "mt_prod_1",
                "prod_2_mt",
                "mt_prod_2",
                "prod_1_id_mt",
                "mt_prod_1_id",
                "prod_2_id_mt",
                "mt_prod_2_id",
                "comp_ran_split_charn",
                "distr_or1_a",
                "distr_or1",
                "distr_or2_a",
                "distr_or2",
                "distr_orA",
                "distr_orD",
                "coerc_assoc"
            ]
        },
        {
            "Normalisation": [
                "none_MT_rules_vs_notMT",
                "rmnMT",
                "rmnMT2",
                "nMTcharn",
                "nMTeqSet",
                "notMTnMT",
                "none_MT_rulesconc",
                "nMTtail",
                "not_MTimpnotMT",
                "SR3nMT",
                "NMPcharn",
                "NMPrm",
                "mrconc",
                "mreq_end",
                "mrconcNone",
                "mreq_endNone",
                "mreq_end2",
                "mreq_end3",
                "mrNoneMT",
                "list2listNMT",
                "two_conc",
                "is_distr_orD",
                "is_strict_orD",
                "is_distr_2",
                "is_strict_2",
                "domStart",
                "notDom",
                "Norm_Distr_1",
                "Norm_Distr_2",
                "Norm_Distr_A",
                "Norm_Distr_D",
                "domSubsetDistr1",
                "domSubsetDistr2",
                "domSubsetDistrA",
                "domSubsetDistrD"
            ]
        },
        {
            "NormalisationTestSpecification": [
                "distrPUTL1",
                "PUTList_None",
                "PUTList_DomMT",
                "distrPUTL2",
                "distrPUTL",
                "distrPUTLG1",
                "distrPUTLG2",
                "distrPUTLG"
            ]
        },
        {
            "Analysis": [
                "strictly_more_vs_more",
                "more_permissive_refl",
                "more_permissive_trans",
                "more_rejective_trans",
                "more_rejective_refl",
                "policy_eq",
                "dom_inter",
                "dom_eq",
                "dom_split_alt_def"
            ]
        },
        {
            "UPF": []
        },
        {
            "Service": []
        },
        {
            "ServiceExample": [
                "exBool",
                "deny_allow",
                "allow_deny"
            ]
        }
    ],
    "url": "entries/upf/theories",
    "title": "Session UPF"
}