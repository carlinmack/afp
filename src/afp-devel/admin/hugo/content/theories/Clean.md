{
    "theories": [
        {
            "MonadSE": [
                "bind_right_unit",
                "bind_left_unit",
                "bind_assoc",
                "bind_left_fail_SE",
                "bind_assoc'",
                "bind_left_unit'",
                "bind_left_fail_SE'",
                "bind_right_unit'",
                "syntax_test",
                "malt_SE_mt",
                "malt_SE_cons",
                "Mon2Rel_Rel2Mon_id",
                "Rel2Mon_Id",
                "single_valued_Mon2Rel",
                "chain_total",
                "mono_if_cont",
                "chain_iterates",
                "single_valued_UN_chain",
                "single_valued_lfp",
                "cont_Î“",
                "Rel2Mon_if",
                "Rel2Mon_homomorphism",
                "bind_cong",
                "bind'_cong",
                "if",
                "if",
                "if",
                "while"
            ]
        },
        {
            "Seq_MonadSE": [
                "mbind_unit",
                "mbind_nofailure",
                "mbind'_unit",
                "mbind'_bind",
                "mbind_try"
            ]
        },
        {
            "Symbex_MonadSE": [
                "exec_unit_SE",
                "exec_unit_SE'",
                "exec_fail_SE",
                "exec_fail_SE'",
                "exec_bind_SE_failure",
                "exec_bind_SE_failure2",
                "exec_bind_SE_success",
                "exec_bind_SE_success2",
                "exec_bind_SE_success'",
                "exec_bind_SE_success''",
                "exec_bind_SE_success'''",
                "exec_bind_SE_success''''",
                "valid_bind_cong",
                "valid_bind'_cong",
                "valid_mbind_mt",
                "valid_mbind_mtE",
                "valid_mbind'_mt",
                "valid_mbind'_mtE",
                "valid_mbind''_mt",
                "valid_mbind''_mtE",
                "exec_mbindFSave_failure",
                "exec_mbindFStop_failure",
                "exec_mbindFPurge_failure",
                "exec_mbindFSave_success",
                "exec_mbindFStop_success",
                "exec_mbindFPurge_success",
                "exec_mbindFSave",
                "mbind_eq_sexec",
                "mbind_eq_sexec'",
                "mbind'_concat",
                "assert_suffix_inv",
                "exec_mbindFSave_E",
                "exec_mbindFStop_E",
                "exec_mbindFPurge_E",
                "assert_disch1",
                "assert_disch2",
                "assert_disch3",
                "assert_disch4",
                "assert_simp",
                "assert_bind_simp",
                "assume_D",
                "assume_E",
                "assume_E'",
                "if_SE_D1",
                "if_SE_D1'",
                "if_SE_D2",
                "if_SE_D2'",
                "if_SE_split_asm",
                "if_SE_split_asm'",
                "if_SE_split",
                "if_SE_split'",
                "if_SE_execE",
                "if_SE_execE'",
                "exec_while",
                "if_SE_execE''",
                "if_SE_execE''_pos",
                "monadic_sequence_rule",
                "exec_skip",
                "mbindFSave_vs_mbindFStop",
                "mbind"
            ]
        },
        {
            "Clean": [
                "exec_stop1",
                "exec_stop2",
                "exec_stop_vs_control_independence",
                "exec_stop_vs_control_independence'",
                "exec_stop_vs_control_independence''",
                "tl_map_hd"
            ]
        },
        {
            "Hoare_MonadSE": [
                "skip",
                "fail",
                "assert",
                "assert_conseq",
                "assume_conseq",
                "sequence",
                "sequence_irpt_l",
                "sequence_irpt_r",
                "sequence'",
                "sequence_irpt_l'",
                "sequence_irpt_r'",
                "consequence",
                "consequence_unit",
                "consequence_irpt",
                "consequence_mt_swap",
                "cond",
                "cond_irpt",
                "while",
                "while_irpt"
            ]
        },
        {
            "Hoare_Clean": [
                "break1",
                "unset_break1",
                "set_return1",
                "unset_return1",
                "assign_global_skip",
                "assign_local_skip",
                "return_skip",
                "assign_clean_skip",
                "if_clean_skip",
                "while_clean_skip",
                "if_opcall_skip",
                "if_funcall_skip",
                "if_funcall_skip'",
                "assign_global",
                "assign_local",
                "return_assign",
                "cond_clean",
                "while_clean_no_break",
                "while_clean'"
            ]
        },
        {
            "Clean_Symbex": [
                "non_exec_assign",
                "non_exec_assign'",
                "exec_assign",
                "exec_assign'",
                "non_exec_assign_global",
                "non_exec_assign_global'",
                "exec_assign_global",
                "exec_assign_global'",
                "non_exec_assign_local",
                "non_exec_assign_local'",
                "exec_assign_local",
                "exec_assign_local'",
                "exec_call_0",
                "exec_call_0'",
                "exec_call_1",
                "exec_call_1'",
                "exec_call",
                "exec_call'",
                "exec_call_2",
                "exec_call_2'",
                "non_exec_call_0",
                "non_exec_call_0'",
                "non_exec_call_1",
                "non_exec_call_1'",
                "non_exec_call",
                "non_exec_call'",
                "non_exec_call_2",
                "non_exec_call_2'",
                "exec_If",
                "valid_exec_If",
                "exec_If",
                "exec_While",
                "if",
                "break_assign_skip",
                "break_if_skip",
                "break_while_skip",
                "unset_break_idem",
                "return_cancel1_idem",
                "return_cancel2_idem",
                "while",
                "exec_while",
                "while_k_SE"
            ]
        },
        {
            "Test_Clean": []
        },
        {
            "Clean_Main": []
        },
        {
            "Quicksort_concept": [
                "quicksort_correct"
            ]
        },
        {
            "SquareRoot_concept": [
                "tm_independent",
                "i_independent",
                "sqsum_independent",
                "tm_simp",
                "tm_simp1",
                "tm_simp2",
                "sqsum_simp",
                "sqsum_simp1",
                "sqsum_simp2",
                "i_simp",
                "i_simp1",
                "i_simp2",
                "non_exec_assign_globalD'"
            ]
        }
    ]
}