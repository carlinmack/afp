{
    "theories": [
        {
            "Trilean": [
                "plus_trilean_assoc",
                "plus_trilean_commutative",
                "times_trilean_commutative",
                "times_trilean_assoc",
                "trilean_distributivity_1",
                "maybe_or_idempotent",
                "maybe_and_idempotent",
                "maybe_and_one",
                "maybe_or_zero",
                "maybe_double_negation",
                "maybe_negate_true",
                "maybe_negate_false",
                "maybe_and_true",
                "maybe_and_not_true",
                "negate_valid",
                "maybe_and_valid",
                "maybe_or_valid",
                "maybe_or_false",
                "maybe_or_true",
                "maybe_not_invalid",
                "maybe_or_invalid",
                "maybe_and_invalid",
                "maybe_and_false",
                "invalid_maybe_and",
                "maybe_not_eq",
                "de_morgans_1",
                "de_morgans_2",
                "not_true",
                "pull_negation",
                "comp_fun_commute_maybe_or",
                "comp_fun_commute_maybe_and"
            ]
        },
        {
            "Value": [
                "maybe_arith_int_not_None",
                "maybe_arith_int_Some",
                "maybe_arith_int_None",
                "maybe_arith_int_Not_Num",
                "maybe_arith_int_never_string",
                "value_plus_never_string",
                "value_plus_symmetry",
                "value_minus_never_string",
                "value_times_never_string",
                "MaybeBoolInt_not_num_1",
                "value_eq_true",
                "value_eq_false",
                "value_gt_true_Some",
                "value_gt_true",
                "value_gt_false_Some"
            ]
        },
        {
            "VName": []
        },
        {
            "Value_Lexorder": []
        },
        {
            "AExp": [
                "aexp_induct_separate_V_cases",
                "aval_plus_symmetry",
                "empty_None",
                "apply_empty_None",
                "input2state_append",
                "input2state_out_of_bounds",
                "input2state_within_bounds",
                "input2state_empty",
                "input2state_nth",
                "input2state_some",
                "input2state_take",
                "input2state_not_None",
                "input2state_Some",
                "input2state_cons",
                "input2state_cons_shift",
                "input2state_exists",
                "length_repeat",
                "length_append_repeat",
                "length_input2state_repeat",
                "input2state_double_exists",
                "input2state_double_exists_2",
                "join_ir_empty",
                "join_ir_R",
                "join_ir_double_exists",
                "join_ir_double_exists_2",
                "exists_join_ir_ext",
                "join_ir_nth",
                "enumerate_aexp_inputs_list",
                "finite_enumerate_regs",
                "no_variables_aval",
                "enumerate_aexp_inputs_not_empty",
                "aval_ir_take",
                "max_reg_V_I",
                "max_reg_V_R",
                "max_reg_Plus",
                "max_reg_Minus",
                "max_reg_Times",
                "no_reg_aval_swap_regs",
                "aval_reg_some_superset",
                "aval_reg_none_superset",
                "enumerate_regs_empty_reg_unconstrained",
                "enumerate_aexp_inputs_empty_input_unconstrained",
                "input_unconstrained_aval_input_swap",
                "input_unconstrained_aval_register_swap",
                "unconstrained_variable_swap_aval",
                "max_input_I",
                "max_input_Plus",
                "max_input_Minus",
                "max_input_Times",
                "aval_take",
                "aval_no_reg_swap_regs"
            ]
        },
        {
            "AExp_Lexorder": [
                "less_aexp_aux_antisym",
                "less_aexp_antisym",
                "less_aexp_aux_trans",
                "less_aexp_trans",
                "smaller_height"
            ]
        },
        {
            "GExp": [
                "gval_Lt",
                "gval_Le",
                "gval_Ge",
                "gval_Ne",
                "gval_gOr",
                "gval_gNot",
                "gval_gAnd",
                "gAnd_commute",
                "gOr_commute",
                "gval_gAnd_True",
                "nor_equiv",
                "unsatisfiable_false",
                "satisfiable_true",
                "valid_true",
                "gval_foldr_true",
                "enumerate_gexp_inputs_list",
                "max_input_list_cons",
                "finite_enumerate_regs",
                "max_reg_gNot",
                "max_reg_Eq",
                "max_reg_Gt",
                "max_reg_Nor",
                "gval_In_cons",
                "possible_to_be_in",
                "max_reg_list_cons",
                "max_reg_list_append_singleton",
                "max_reg_list_append",
                "apply_guards_singleton",
                "apply_guards_empty",
                "apply_guards_cons",
                "apply_guards_double_cons",
                "apply_guards_append",
                "apply_guards_foldr",
                "rev_apply_guards",
                "apply_guards_fold",
                "fold_apply_guards",
                "foldr_apply_guards",
                "apply_guards_subset",
                "apply_guards_subset_append",
                "apply_guards_rearrange",
                "apply_guards_condense",
                "apply_guards_false_condense",
                "max_input_Bc",
                "max_input_Eq",
                "max_input_Gt",
                "gexp_max_input_Nor",
                "gexp_max_input_In",
                "gval_foldr_gOr_invalid",
                "gval_foldr_gOr_true",
                "gval_foldr_gOr_false",
                "gval_fold_gOr_rev",
                "gval_fold_gOr_foldr",
                "gval_fold_gOr",
                "gval_In_fold",
                "gval_fold_In",
                "fold_maybe_or_invalid_base",
                "fold_maybe_or_true_base_never_false",
                "fold_true_fold_false_not_invalid",
                "fold_true_invalid_fold_rev_false_invalid",
                "fold_maybe_or_rev",
                "fold_maybe_or_cons",
                "gval_fold_gOr_map",
                "gval_unfold_first",
                "fold_Eq_true",
                "x_in_set_fold_eq",
                "x_not_in_set_fold_eq",
                "gval_take",
                "gval_fold_gAnd_append_singleton",
                "gval_fold_rev_true",
                "gval_fold_not_invalid_all_valid_contra",
                "gval_fold_not_invalid_all_valid",
                "all_gval_not_false",
                "must_have_one_false_contra",
                "must_have_one_false",
                "all_valid_fold",
                "one_false_all_valid_false",
                "gval_fold_rev_false",
                "fold_invalid_means_one_invalid",
                "gval_fold_rev_invalid",
                "gval_fold_rev_equiv_fold",
                "gval_fold_equiv_fold_rev",
                "gval_fold_equiv_gval_foldr",
                "gval_foldr_equiv_gval_fold",
                "gval_fold_cons",
                "gval_fold_take",
                "length_padding",
                "length_take_or_pad",
                "restricted_once_cons",
                "not_restricted_cons",
                "gval_reg_some_superset",
                "apply_guards_reg_some_superset"
            ]
        },
        {
            "GExp_Lexorder": [
                "less_gexp_aux_antisym",
                "less_gexp_antisym",
                "less_gexp_aux_trans",
                "less_gexp_trans"
            ]
        },
        {
            "FSet_Utils": [
                "fset_of_list_remdups",
                "fset_both_sides",
                "Abs_ffilter",
                "size_ffilter_card",
                "ffilter_empty",
                "ffilter_finsert",
                "fset_equiv",
                "finsert_equiv",
                "filter_elements",
                "sorted_list_of_fempty",
                "fmember_implies_member",
                "fold_union_ffUnion",
                "filter_filter",
                "fsubset_strict",
                "fsubset",
                "size_fsubset_elem",
                "size_fsubset",
                "arg_cong_ffilter",
                "ffilter_singleton",
                "fset_eq_alt",
                "ffold_empty",
                "sorted_list_of_fset_sort",
                "fMin_Min",
                "sorted_hd_Min",
                "hd_sort_Min",
                "hd_sort_remdups",
                "exists_fset_of_list",
                "hd_sorted_list_of_fset",
                "fminus_filter_singleton",
                "card_minus_fMin",
                "sorted_list_of_fset_Cons",
                "list_eq_hd_tl",
                "fset_of_list_sort",
                "exists_sorted_distinct_fset_of_list",
                "fset_of_list_empty",
                "ffold_ord_cons",
                "sorted_distinct_ffold_ord",
                "ffold_ord_fold_sorted",
                "fprod_empty_l",
                "fprod_empty_r",
                "fprod_finsert",
                "fprod_member",
                "fprod_subseteq",
                "fimage_fprod",
                "fprod_singletons",
                "fprod_equiv",
                "fis_singleton_alt",
                "singleton_singleton",
                "not_singleton_empty",
                "fis_singleton_fthe_elem",
                "fBall_ffilter",
                "fBall_ffilter2",
                "size_fset_of_list",
                "size_fsingleton",
                "ffilter_mono",
                "size_fimage",
                "size_ffilter",
                "fimage_size_le",
                "ffilter_size_le",
                "set_membership_eq",
                "size_le_1",
                "size_gt_1"
            ]
        },
        {
            "Transition": [
                "can_take_empty",
                "can_take_subset_append",
                "can_take_transition_empty_guard",
                "can_take_subset",
                "valid_list_can_take",
                "cant_take_if",
                "apply_outputs_nth",
                "apply_outputs_empty",
                "apply_outputs_preserves_length",
                "apply_outputs_literal",
                "apply_outputs_register",
                "apply_outputs_unupdated",
                "apply_updates_cons",
                "update_twice",
                "r_not_updated_stays_the_same"
            ]
        },
        {
            "Transition_Lexorder": []
        },
        {
            "EFSM": [
                "str_not_num",
                "S_ffUnion",
                "possible_steps_finsert",
                "split_origin",
                "split_label",
                "possible_steps_empty_guards_false",
                "fmember_possible_steps",
                "possible_steps_alt_aux",
                "possible_steps_alt",
                "possible_steps_alt3",
                "possible_steps_alt_atom",
                "possible_steps_alt2",
                "possible_steps_single_out",
                "possible_steps_singleton",
                "possible_steps_apply_guards",
                "possible_steps_empty",
                "singleton_dest",
                "no_outgoing_transitions",
                "ffilter_split",
                "one_outgoing_transition",
                "choice_alt",
                "choice_symmetry",
                "deterministic_alt_aux",
                "deterministic_alt",
                "size_le_1",
                "ffilter_empty_if",
                "empty_ffilter",
                "all_states_deterministic",
                "deterministic_finsert",
                "ffilter_fBall",
                "fsubset_if",
                "in_possible_steps",
                "possible_steps_can_take_transition",
                "not_deterministic",
                "not_deterministic_conv",
                "deterministic_if",
                "in_outgoing",
                "outgoing_transitions_deterministic",
                "outgoing_transitions_deterministic2",
                "outgoing_transitions_fprod_deterministic",
                "random_member_nonempty",
                "random_member_singleton",
                "random_member_is_member",
                "random_member_None",
                "random_member_empty",
                "possible_steps_not_empty_iff",
                "step_member",
                "step_outputs",
                "step",
                "step_None",
                "step_Some",
                "no_possible_steps_1",
                "observe_execution_step_def",
                "observe_execution_first_outputs_equiv",
                "observe_execution_step",
                "observe_execution_possible_step",
                "observe_execution_no_possible_step",
                "observe_execution_no_possible_steps",
                "observe_execution_one_possible_step",
                "finite_all_regs",
                "no_possible_steps_rejects",
                "recognises_step_equiv",
                "recognises_prim",
                "recognises_single_possible_step",
                "recognises_single_possible_step_atomic",
                "recognises_must_be_possible_step",
                "recognises_possible_steps_not_empty",
                "recognises_must_be_step",
                "recognises_cons_step",
                "no_step_none",
                "step_none_rejects",
                "trace_reject",
                "trace_reject_no_possible_steps_atomic",
                "trace_reject_later",
                "recognition_prefix_closure",
                "rejects_prefix",
                "recognises_head",
                "accepts_trace_step",
                "accepts_trace_exists_possible_step",
                "rejects_trace_step",
                "prefix_closure",
                "accepts_trace_prim",
                "trace_simulation_step",
                "trace_simulation_step_none",
                "rejects_trace_simulation",
                "accepts_trace_simulation",
                "simulates_trace_subset",
                "simulation_implies_trace_equivalent",
                "trace_equivalent_reflexive",
                "trace_equivalent_symmetric",
                "trace_equivalent_transitive",
                "trace_equivalent",
                "accepts_trace_step_2",
                "execution_simulation_step",
                "execution_simulation_trace_simulation",
                "execution_simulates_trace_simulates",
                "executionally_equivalent_step",
                "execution_end",
                "possible_steps_disparity",
                "executionally_equivalent_acceptance_map",
                "executionally_equivalent_acceptance",
                "executionally_equivalent_trace_equivalent",
                "executionally_equivalent_symmetry",
                "executionally_equivalent_transitivity",
                "no_further_steps",
                "visits_base",
                "visits_step",
                "reachable_initial",
                "visits_finsert",
                "reachable_finsert",
                "reachable_finsert_contra",
                "visits_empty",
                "obtains_obtainable",
                "obtains_base",
                "obtains_step",
                "obtains_recognises",
                "ex_comm4",
                "recognises_execution_obtains",
                "obtainable_empty_efsm",
                "obtains_visits",
                "unobtainable_if",
                "obtainable_if_unreachable",
                "obtains_step_append",
                "reachable_if_obtainable_step",
                "possible_steps_remove_unreachable",
                "executionally_equivalent_remove_unreachable_state_arbitrary",
                "executionally_equivalent_remove_unreachable_state",
                "replace_finsert",
                "possible_steps_replace_unchanged"
            ]
        },
        {
            "EFSM_LTL": [
                "ltl_step_singleton",
                "ltl_step_none",
                "ltl_step_none_2",
                "ltl_step_alt",
                "ltl_step_some",
                "ltl_step_cases",
                "state_eq_holds",
                "state_eq_None_not_Some",
                "watch_label",
                "join_iro_R",
                "alw_ev",
                "alw_state_eq_smap",
                "shd_state_is_none",
                "unfold_observe_none",
                "once_none_always_none_aux",
                "once_none_always_none",
                "once_none_nxt_always_none",
                "snth_sconst",
                "alw_sconst",
                "smap_statename_None",
                "alw_not_some",
                "state_none",
                "state_none_2",
                "no_output_none_aux",
                "no_output_none",
                "nxt_alw",
                "no_output_none_nxt",
                "no_output_none_if_empty",
                "no_updates_none_aux",
                "no_updates_none",
                "action_components"
            ]
        },
        {
            "Drinks_Machine": [
                "apply_updates_vend",
                "drinks_states",
                "possible_steps_0",
                "first_step_select",
                "drinks_vend_insufficient",
                "drinks_vend_invalid",
                "possible_steps_1_coin",
                "possible_steps_2_vend",
                "recognises_from_2",
                "recognises_from_1a",
                "recognises_from_1",
                "purchase_coke",
                "rejects_input",
                "rejects_recognises_prefix",
                "rejects_termination",
                "r2_0_vend",
                "drinks_vend_sufficient",
                "drinks_end",
                "drinks_vend_r2_String",
                "drinks_vend_r2_rejects",
                "drinks_0_rejects",
                "drinks_vend_empty",
                "drinks_1_rejects",
                "drinks_rejects_future",
                "drinks_1_rejects_trace",
                "rejects_state_step",
                "invalid_other_states",
                "vend_ge_100",
                "drinks_no_possible_steps_1",
                "possible_steps_0_not_select",
                "possible_steps_select_wrong_arity",
                "possible_steps_0_invalid"
            ]
        },
        {
            "Drinks_Machine_2": [
                "possible_steps_0",
                "possible_steps_1",
                "possible_steps_2_coin",
                "possible_steps_2_vend",
                "recognises_first_select",
                "drinks2_vend_insufficient",
                "drinks2_vend_insufficient2",
                "drinks2_vend_sufficient",
                "recognises_1_2",
                "drinks_reject_0_2",
                "purchase_coke",
                "drinks2_0_invalid",
                "drinks2_vend_r2_none",
                "drinks2_end",
                "drinks2_vend_r2_String",
                "drinks2_2_invalid",
                "drinks2_1_invalid",
                "drinks2_vend_invalid",
                "equiv_1_2",
                "equiv_1_1",
                "executional_equivalence",
                "observational_equivalence"
            ]
        },
        {
            "Drinks_Machine_LTL": [
                "P_ltl_step_0",
                "P_ltl_step_1",
                "LTL_r2_not_always_gt_100",
                "drinks_step_2_none",
                "one_before_two_2",
                "one_before_two_aux",
                "LTL_nxt_2_means_vend",
                "costsMoney_aux",
                "LTL_costsMoney",
                "LTL_costsMoney_aux",
                "implode_select",
                "implode_coin",
                "implode_vend",
                "LTL_neverReachS2",
                "ltl_step_not_select",
                "ltl_step_select",
                "ltl_step_not_coin_or_vend",
                "ltl_step_coin",
                "alw_tl",
                "stop_at_none",
                "drink_costs_money_aux",
                "LTL_drinks_cost_money",
                "steps_1_invalid",
                "output_vend_aux",
                "LTL_output_vend",
                "LTL_output_vend_unfolded"
            ]
        }
    ],
    "url": "entries/extended_finite_state_machines/theories",
    "title": "Session Extended_Finite_State_Machines"
}