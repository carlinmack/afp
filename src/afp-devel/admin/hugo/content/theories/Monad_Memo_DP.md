{
    "theories": [
        {
            "State_Monad_Ext": [
                "return_app_return",
                "return_app_return_meta"
            ]
        },
        {
            "Pure_Monad": [
                "Wrap_App_Wrap"
            ]
        },
        {
            "DP_CRelVS": [
                "run_state_cases",
                "lift_p_P",
                "checkmem_checkmem'",
                "checkmem_eq_alt",
                "cmem_intro",
                "cmem_elim",
                "crel_vs_intro",
                "crel_vs_elim",
                "consistentDP_intro",
                "crel_vs_return",
                "crel_vs_return_ext",
                "cmem_upd",
                "P_upd",
                "crel_vs_get",
                "crel_vs_set",
                "crel_vs_bind_eq",
                "bind_transfer",
                "cmem_lookup",
                "P_lookup",
                "crel_vs_lookup",
                "crel_vs_update",
                "crel_vs_checkmem",
                "crel_vs_checkmem_tupled",
                "return_transfer",
                "fun_app_lifted_transfer",
                "crel_vs_fun_app",
                "if"
            ]
        },
        {
            "State_Heap_Misc": [
                "rel_fun_comp",
                "rel_fun_comp1",
                "rel_fun_comp2",
                "rel_fun_relcompp",
                "rel_fun_comp1'",
                "rel_fun_comp2'"
            ]
        },
        {
            "Heap_Monad_Ext": [
                "return_app_return",
                "return_app_return_meta"
            ]
        },
        {
            "State_Heap": [
                "execute_cases",
                "execute_cases'",
                "lift_p_None",
                "lift_p_P",
                "lift_p_P'",
                "lift_p_P''",
                "lift_p_the_Some",
                "lift_p_E",
                "checkmem_checkmem'",
                "rel_state_elim",
                "rel_state_intro",
                "transfer_bind",
                "transfer_return",
                "fun_app_lifted_transfer",
                "transfer_get",
                "rel_state_lookup",
                "rel_state_update",
                "transfer_lookup",
                "transfer_update",
                "transfer_checkmem",
                "lookup'_correct",
                "update'_correct",
                "lookup'_inv",
                "update'_inv",
                "mem_correct_heap",
                "mem_correct_heap_correct"
            ]
        },
        {
            "DP_CRelVH": [
                "consistentDP_intro",
                "crel_vs_execute_None",
                "crel_vs_execute_Some",
                "crel_vs_executeD",
                "crel_vs_success",
                "crel_vsI",
                "transfer'_return",
                "crel_vs_return",
                "crel_vs_return_ext",
                "bind_transfer",
                "crel_vs_update",
                "crel_vs_lookup",
                "crel_vs_eq_eq_onp",
                "crel_vs_bind_eq",
                "crel_vs_checkmem",
                "crel_vs_checkmem_tupled",
                "transfer_fun_app_lifted",
                "crel_vs_fun_app",
                "dp_heap",
                "cmem_empty",
                "memoized_success",
                "memoized",
                "cmem_result"
            ]
        },
        {
            "Memory": [
                "lift_pI",
                "mem_correct_default",
                "mem_correct_rbt_mapping",
                "mem_correct_empty_default",
                "mem_correct_rbt_empty_mapping",
                "cmem_empty",
                "memoized",
                "cmem_result",
                "map_of_simp",
                "mem_correct_tracing",
                "mem_correct_tracing_empty"
            ]
        },
        {
            "Pair_Memory": [
                "map_add_mono",
                "map_add_upd2",
                "map_of_le_pair",
                "pair_le_map_of",
                "map_of_eq_pair",
                "inv_pair_neq",
                "inv_pair_P_D",
                "inv_pair_domD",
                "move12_correct1",
                "move12_correct2",
                "dom_empty",
                "inv_pair_lookup1",
                "inv_pair_lookup2",
                "inv_pair_update1",
                "inv_pair_update2",
                "inv_pair_move12",
                "mem_correct_pair",
                "emptyI",
                "map_of_le_pair",
                "pair_le_map_of",
                "map_of_eq_pair",
                "inv_pair_neq",
                "inv_pair_P_D1",
                "inv_pair_P_D2",
                "inv_pair_domD",
                "mem_correct_pair"
            ]
        },
        {
            "Index": [
                "index_mono",
                "index_eq_iff",
                "checked_idx_injective",
                "bound_int_simp"
            ]
        },
        {
            "Memory_Heap": [
                "map_emptyI",
                "result_of_return",
                "get_result_of_lookup",
                "success_empty",
                "length_mem_empty",
                "nth_mem_empty",
                "execute_bind_success'",
                "success_bind_I",
                "alloc_pair_alloc",
                "alloc_pairD1",
                "alloc_pairD2",
                "alloc_pairD3",
                "alloc_pairD4",
                "alloc_pair_array_get",
                "alloc_pair_array_length",
                "alloc_pair_nth",
                "succes_alloc_pair",
                "init_state_inner_alloc",
                "init_state_inner_distinct",
                "init_state_inner_present",
                "inite_state_inner_present'",
                "succes_init_state_inner",
                "init_state_inner_nth",
                "succes_init_state",
                "init_state_distinct",
                "init_state_present",
                "empty_present",
                "empty_present'",
                "init_state_present2",
                "init_state_neq",
                "present_alloc_get",
                "init_state_length",
                "init_state_inv",
                "inv_pair_lengthD1",
                "inv_pair_lengthD2",
                "inv_pair_presentD",
                "inv_pair_presentD2",
                "inv_pair_not_eqD",
                "run_state_state_of",
                "disjoint",
                "alloc_present",
                "alloc_present'",
                "length_get_upd",
                "rel_state_ofI",
                "inv_pair_iff",
                "lift_p_inv_pairI",
                "lift_p_success",
                "rel_state_ofI2",
                "rel_state_lookup",
                "rel_state_update",
                "inv_pairD",
                "mem_rel_state_ofI",
                "mem_rel_state_ofI'",
                "rel_state_lookup'",
                "rel_state_update'",
                "mem_rel_state_resultD",
                "map_of_heap_eq",
                "init_state_empty1",
                "init_state_empty2",
                "init_state_inv'",
                "init_state_empty"
            ]
        },
        {
            "Transform_Cmd": []
        },
        {
            "files/Transform_Misc.ML": []
        },
        {
            "files/Transform_Const.ML": []
        },
        {
            "files/Transform_Data.ML": []
        },
        {
            "files/Transform_Tactic.ML": []
        },
        {
            "files/Transform_Term.ML": []
        },
        {
            "files/Transform.ML": []
        },
        {
            "files/Transform_Parser.ML": []
        },
        {
            "Bottom_Up_Computation": [
                "admissible",
                "wellfounded",
                "iter_state_unfold",
                "iterator_to_list_unfold",
                "iter_state_iterate_state",
                "crel_vs_iterate_state",
                "crel_vs_bind_ignore",
                "crel_vs_iterate_and_compute",
                "crel_vs_iter_and_compute",
                "consistentDP_iter_and_compute",
                "memoized",
                "cmem_result",
                "dp_consistency_iterator_emptyI",
                "table_iterator_up",
                "table_iterator_down"
            ]
        },
        {
            "Bottom_Up_Computation_Heap": [
                "crel_vs_iterate_state",
                "crel_vs_bind_ignore",
                "crel_vs_iter_and_compute",
                "consistent_DP_iter_and_compute"
            ]
        },
        {
            "Solve_Cong": []
        },
        {
            "Heap_Main": [
                "ifT_cong",
                "return_app_return_cong",
                "mapT_cong",
                "foldT_cong",
                "abs_unit_cong",
                "arg_cong4",
                "if",
                "map",
                "fold",
                "refl2",
                "rel_fun2",
                "crel_vs_return_app_return",
                "option_case_cong'",
                "prod_case_cong'",
                "execute_heap_ofD",
                "execute_result_ofD",
                "memoized_empty",
                "memoized_empty",
                "memoized_empty",
                "memoized_empty"
            ]
        },
        {
            "State_Main": [
                "ifT_cong",
                "return_app_return_cong",
                "mapT_cong",
                "foldT_cong",
                "abs_unit_cong",
                "if",
                "map",
                "fold",
                "refl2",
                "rel_fun2",
                "crel_vs_return_app_return",
                "option_case_cong'",
                "prod_case_cong'",
                "nat_case_cong'"
            ]
        },
        {
            "Example_Misc": [
                "fold_min_commute",
                "min_list_fold",
                "induct_list012",
                "min_list_Min",
                "Pinf_add_right"
            ]
        },
        {
            "Tracing": [
                "trace_alt_def"
            ]
        },
        {
            "Ground_Function": []
        },
        {
            "files/Ground_Function.ML": []
        },
        {
            "Bellman_Ford": [
                "nat_le_cases",
                "crel_vs_iterate_state",
                "consistent_crel_vs_iterate_state",
                "Minf_eq_zero",
                "Sup_int",
                "Inf_int_in",
                "finite_setcompr_eq_image",
                "finite_lists_length_le1",
                "finite_lists_length_le2",
                "get_return",
                "list_pidgeonhole",
                "path_eq_cycleE",
                "le_add_same_cancel1",
                "add_gt_minfI",
                "add_lt_infI",
                "sum_list_not_infI",
                "sum_list_not_minfI",
                "weight_alt_def'",
                "weight_alt_def",
                "weight_append",
                "OPT_0",
                "OPT_cases",
                "OPT_Suc",
                "bf_correct",
                "iter_bf_unfold",
                "bellman_ford_alt_def",
                "fold_sum_aux'",
                "fold_sum_aux",
                "is_path2_remove_cycle",
                "is_path_eq",
                "is_path_remove_cycle",
                "is_path_remove_cycle2",
                "is_path_shorten",
                "reaches_non_inf_path",
                "OPT_sink_le_0",
                "is_path_appendD",
                "has_negative_cycleI",
                "OPT_cases2",
                "shortest_le_OPT",
                "weight_not_minfI",
                "OPT_not_minfI",
                "shortest_cases",
                "simple_paths",
                "OPT_mono",
                "bellman_ford_correct'",
                "bf",
                "iter_bf_heap_unfold",
                "bf_impl_correct",
                "bottom_up_alt"
            ]
        },
        {
            "Heap_Default": [
                "mem_empty_empty",
                "memoized_empty",
                "init_success"
            ]
        },
        {
            "Knapsack": [
                "OPT_0",
                "Max_add_left",
                "OPT_Suc",
                "knapsack_heap",
                "su_knapsack",
                "su_correct"
            ]
        },
        {
            "Counting_Tiles": [
                "lists_of_len_fin1",
                "disjE1",
                "valid_valid'",
                "valid'_valid",
                "valid_eq_valid'",
                "replicate_iff",
                "replicate_iff2",
                "replicate_Cons_eq",
                "valid_split",
                "valid_line_just_B",
                "F_base_0_aux",
                "F_base_0",
                "F_base_aux",
                "F_base_1",
                "valid_m_Rs",
                "F_base_aux_2",
                "F_base_2",
                "finite_valid_length",
                "valid_line_aux",
                "replicate_unequal_aux",
                "valid_prepend_B_iff",
                "F_rec",
                "lcount_correct"
            ]
        },
        {
            "CYK": [
                "append_iff_take_drop",
                "append_iff_take_drop1",
                "yield_not_Nil",
                "yield_eq1",
                "yield_eq2",
                "set_cyk_simp2",
                "cyk_correct",
                "set_aux",
                "cyk2_eq_cyk",
                "cyk_ix_simp2",
                "slice_append_iff_take_drop1",
                "cyk_ix_correct",
                "cyk_ix_impl_success",
                "min_wpl_heap",
                "CYK_ix_impl_correct"
            ]
        },
        {
            "Min_Ed_Dist0": [
                "min_eds_correct",
                "min_eds_same",
                "min_eds_eq_Nil_iff",
                "min_eds_Nil",
                "min_eds_Nil2",
                "if_edit_Nil2",
                "if_edit_eq_Nil",
                "min_eds_minimal",
                "min_ed_min_eds",
                "cost_Copy_Del",
                "cost_Copy_Ins",
                "min_ed_ix'_min_ed",
                "min_ed_Nil1",
                "min_ed_Nil2",
                "min_ed_ix_min_ed",
                "min_ed_ix",
                "iter_min_ed_ix_unfold",
                "bf_impl_correct"
            ]
        },
        {
            "OptBST": [
                "argmin_forall",
                "argmin_Min",
                "upto_join",
                "atLeastAtMost_split",
                "atLeastAtMost_split_insert",
                "min_wpl_heap",
                "min_wpl_minimal",
                "opt_bst_correct",
                "wpl_opt_bst",
                "opt_bst_is_optimal",
                "W_rec",
                "inorder_wpl_correct",
                "opt_bst_has_optimal_cost",
                "min_wpl_minimal_cost",
                "min_wpl_tree",
                "set_tree_depth",
                "depth_inf_iff",
                "depth_not_neg_inf",
                "depth_FinD",
                "cost'_Leaf",
                "cost'_Node",
                "weight_correct",
                "W_fun_correct",
                "compute_W_correct",
                "W_compute",
                "min_wpl'_correct",
                "opt_bst'_correct"
            ]
        },
        {
            "Longest_Common_Subsequence": [
                "finite_subseq",
                "subseq_singleton_right",
                "subseq_append_single_right",
                "Max_nat_plus",
                "finite_OPT",
                "non_empty_OPT",
                "OPT_0_left",
                "OPT_0_right",
                "OPT_rec1",
                "OPT_rec2",
                "lcs_correct'",
                "lcs_lcs_ia",
                "lcs"
            ]
        },
        {
            "All_Examples": []
        }
    ],
    "url": "entries/monad_memo_dp/theories",
    "title": "Session Monad_Memo_DP"
}