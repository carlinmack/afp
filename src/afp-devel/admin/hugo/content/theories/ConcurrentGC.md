{
    "theories": [
        {
            "Model": []
        },
        {
            "Proofs_Basis": [
                "Set_bind_insert",
                "option_bind_invE",
                "colours_distinct",
                "marked_imp_black_or_grey",
                "p_not_sys",
                "obj_at_cong",
                "obj_at_split",
                "obj_at_split_asm",
                "obj_at_eq_imp",
                "obj_at_simps",
                "obj_at_field_on_heap_cong",
                "obj_at_field_on_heap_split",
                "obj_at_field_on_heap_split_asm",
                "obj_at_field_on_heap_eq_imp",
                "obj_at_field_on_heap_imp_valid_ref",
                "obj_at_field_on_heapE",
                "valid_null_ref_eq_imp",
                "valid_null_ref_simps",
                "do_store_action_prj_simps",
                "reaches_refl",
                "reaches_step",
                "reaches_induct",
                "converse_reachesE",
                "reaches_fields",
                "reaches_eq_imp",
                "obj_at_mark_dequeue",
                "obj_at_field_on_heap_mw_simps",
                "obj_at_field_on_heap_no_pending_stores"
            ]
        },
        {
            "Global_Invariants": []
        },
        {
            "Local_Invariants": []
        },
        {
            "Tactics": [
                "valid_pre",
                "valid_conj_lift",
                "valid_all_lift",
                "atS_dests",
                "schematic_prem",
                "TrueE",
                "thin_locs_pre_discardE",
                "thin_locs_pre_keep_atE",
                "thin_locs_pre_keep_atSE",
                "thin_locs_post_discardE",
                "thin_locs_post_keep_locsE",
                "thin_locs_post_keepE",
                "ni_thin_locs_discardE",
                "ni_thin_locs_keep_atE",
                "ni_thin_locs_keep_atSE",
                "loc_mem_tac_intros"
            ]
        },
        {
            "Global_Invariants_Lemmas": [
                "tso_store_inv_eq_imp",
                "tso_store_invD",
                "mut_do_store_action",
                "tso_store_inv_sys_load_Mut",
                "tso_store_inv_sys_load_GC",
                "tso_no_pending_marksD",
                "no_pending_phase_sys_load",
                "gc_no_pending_fM_write",
                "tso_store_refs_simps",
                "fold_stores_points_to",
                "points_to_Mutate",
                "handshake_in_syncD",
                "phase_rel_invD",
                "mut_m_not_idle_no_fM_write",
                "mut_m_not_idle_no_fM_writeD",
                "reachableI",
                "reachable_points_to",
                "reachable_induct",
                "mutator_reachable_tso",
                "greyI",
                "blackD",
                "whiteI",
                "marked_not_white",
                "white_valid_ref",
                "not_white_marked",
                "black_eq_imp",
                "grey_eq_imp",
                "white_eq_imp",
                "black_heap_eq_imp",
                "white_heap_eq_imp",
                "no_black_refs_eq_imp",
                "white_heap_imp_no_black_refs",
                "black_heap_no_greys",
                "heap_colours_colours",
                "strong_tricolour_invD",
                "no_black_refsD",
                "has_white_path_to_induct",
                "has_white_path_toD",
                "has_white_path_to_refl",
                "has_white_path_to_step",
                "has_white_path_toE",
                "has_white_path_to_reaches",
                "has_white_path_to_blacken",
                "has_white_path_to_eq_imp'",
                "has_white_path_to_eq_imp",
                "grey_protects_whiteD",
                "grey_protects_whiteI",
                "grey_protects_whiteE",
                "grey_protects_white_reaches",
                "grey_protects_white_induct",
                "valid_W_inv_sys_ghg_empty_iff",
                "WLI",
                "WL_eq_imp",
                "valid_W_inv_eq_imp",
                "valid_W_invE",
                "valid_W_invD",
                "valid_W_inv_colours",
                "valid_W_inv_no_mark_stores_invD",
                "valid_W_inv_sys_load",
                "grey_reachable_eq_imp",
                "grey_reachableI",
                "grey_reachableE",
                "valid_refs_invI",
                "valid_refs_inv_eq_imp",
                "valid_refs_invD",
                "reachable_snapshot_invI",
                "reachable_snapshot_inv_eq_imp",
                "in_snapshotI",
                "in_snapshot_valid_ref",
                "reachableI2",
                "tso_pending_mw_mutate_cong",
                "marked_insertionD",
                "marked_insertions_store_buffer_empty",
                "marked_deletions_store_buffer_empty",
                "obj_at_ref_sweep_loop_free",
                "obj_at_alloc",
                "valid_ref_valid_null_ref_simps",
                "reachable_load",
                "WL_blacken",
                "WL_hs_done",
                "colours_load_W",
                "WL_load_W",
                "no_grey_refs_eq_imp",
                "no_grey_refs_no_pending_marks",
                "no_grey_refs_not_grey_reachableD",
                "no_grey_refsD",
                "no_grey_refs_marked",
                "no_grey_refs_bwD",
                "reachable_blackD",
                "no_grey_refs_not_reachable",
                "no_grey_refs_not_rootD",
                "reachable_snapshot_inv_white_root",
                "black_dequeue_Mark",
                "colours_sweep_loop_free",
                "colours_get_work_done",
                "colours_get_roots_done",
                "colours_flip_fM",
                "colours_alloc",
                "heap_colours_alloc",
                "grey_protects_white_hs_done",
                "grey_protects_white_alloc",
                "reachable_alloc",
                "reachable_snapshot_inv_alloc",
                "reachable_snapshot_inv_discard_roots",
                "reachable_snapshot_inv_load",
                "reachable_snapshot_inv_store_ins",
                "WL_mo_co_mark",
                "ghost_honorary_grey_mo_co_mark",
                "ghost_honorary_grey_mo_co_W",
                "reachable_sweep_loop_free",
                "reachable_deref_del",
                "no_black_refs_dequeue",
                "colours_blacken",
                "no_black_refs_alloc",
                "no_black_refs_mo_co_mark",
                "grey_protects_white_mark",
                "valid_refs_inv_dequeue_Mutate",
                "valid_refs_inv_dequeue_Mutate_Payload"
            ]
        },
        {
            "Local_Invariants_Lemmas": [
                "hs_get_roots_loop_locs_subseteq_hs_get_roots_locs",
                "hs_pending_locs_subseteq_hs_pending_loaded_locs",
                "ht_loaded_locs_subseteq_hs_pending_loaded_locs",
                "hs_noop_locs_subseteq_hs_pending_loaded_locs",
                "hs_noop_locs_subseteq_hs_pending_locs",
                "hs_noop_locs_subseteq_ht_loaded_locs",
                "hs_get_roots_locs_subseteq_hs_pending_loaded_locs",
                "hs_get_roots_locs_subseteq_hs_pending_locs",
                "hs_get_roots_locs_subseteq_ht_loaded_locs",
                "hs_get_work_locs_subseteq_hs_pending_loaded_locs",
                "hs_get_work_locs_subseteq_hs_pending_locs",
                "hs_get_work_locs_subseteq_ht_loaded_locs",
                "get_roots_UN_get_work_locs_subseteq_ghost_honorary_grey_empty_locs",
                "hs_get_roots_locs_subseteq_hp_IdleMarkSweep_locs",
                "hs_get_work_locs_subseteq_hp_IdleMarkSweep_locs",
                "obj_fields_marked_eq_imp",
                "obj_fields_marked_UNIV",
                "obj_fields_marked_invL_eq_imp",
                "obj_fields_marked_mark_field_done",
                "mark_object_invL_eq_imp",
                "mut_m_mark_object_invL_eq_imp"
            ]
        },
        {
            "Initial_Conditions": [
                "init_strong_tricolour_inv",
                "init_no_grey_refs",
                "valid_refs_imp_valid_refs_inv",
                "no_grey_refs_imp_valid_W_inv",
                "valid_refs_imp_reachable_snapshot_inv",
                "init_inv_sys",
                "init_inv_mut",
                "init_inv_gc"
            ]
        },
        {
            "Noninterference": [
                "mut_del_barrier1_subseteq_mut_mo_valid_ref_locs",
                "mut_del_barrier2_subseteq_mut_mo_valid_ref",
                "obj_fields_marked_locs_subseteq_hp_IdleMarkSweep_locs",
                "obj_fields_marked_locs_subseteq_hs_in_sync_locs",
                "obj_fields_marked_good_ref_subseteq_hp_IdleMarkSweep_locs",
                "mark_loop_mo_mark_loop_field_done_subseteq_hs_in_sync_locs",
                "no_grey_refs_locs_subseteq_hs_in_sync_locs",
                "get_roots_UN_get_work_locs_subseteq_gc_W_empty_locs",
                "handshake_obj_fields_markedD",
                "obj_fields_marked_good_ref_locs_hp_phaseD",
                "gc_marking_reaches_Mutate",
                "gc_W_empty_mut_inv_load_W",
                "gc_W_empty_mut_inv_hs_init",
                "gc_W_empty_invL",
                "empty_WL_GC",
                "gc_hs_get_roots_get_workD",
                "handshake_sweep_mark_endD",
                "gc_W_empty_mut_mo_co_mark",
                "no_grey_refs_mo_co_mark",
                "gc_W_empty_invL",
                "mut_store_old_mark_object_invL",
                "mut_store_ins_mark_object_invL",
                "mut_mark_object_invL",
                "mut_m_get_roots_no_fM_write"
            ]
        },
        {
            "Global_Noninterference": [
                "black_heap_reachable",
                "black_heap_valid_ref_marked_insertions",
                "reachable_snapshot_inv_black_heap_no_grey_refs_dequeue_Mutate",
                "marked_deletions_dequeue_Mark",
                "marked_deletions_dequeue_Mutate",
                "grey_protects_white_dequeue_Mark",
                "reachable_snapshot_inv_dequeue_Mark",
                "marked_insertions_dequeue_Mark",
                "marked_insertions_dequeue_Mutate",
                "grey_protects_white_dequeue_Mutate",
                "reachable_snapshot_inv_dequeue_Mutate",
                "mutator_phase_inv"
            ]
        },
        {
            "MarkObject": [
                "mark_object_invL",
                "mut_store_ins_mark_object_invL",
                "mut_store_del_mark_object_invL",
                "mut_get_roots_mark_object_invL",
                "gc_mark_mark_object_invL",
                "obj_fields_marked_invL",
                "mut_store_ins_mark_object_invL",
                "mut_store_del_mark_object_invL",
                "mut_get_roots_mark_object_invL",
                "gc_mark_mark_object_invL"
            ]
        },
        {
            "Phases": [
                "gc_handshake_invL_eq_imp",
                "gc_fM_fA_invL_eq_imp",
                "fM_fA_invL",
                "fM_rel_inv",
                "fA_rel_inv",
                "gc_fM_fA_invL",
                "fM_rel_inv",
                "fA_rel_inv",
                "fA_neq_locs_diff_fA_tso_empty_locs",
                "gc_fM_fA_invL",
                "fM_rel_inv",
                "fA_rel_inv",
                "sys_phase_inv",
                "no_grey_refs_no_marks",
                "black_heap_dequeue_mark",
                "white_heap_dequeue_fM",
                "black_heap_dequeue_fM",
                "sys_phase_inv"
            ]
        },
        {
            "StrongTricolour": [
                "marked_insertions_store_ins",
                "marked_insertions_alloc",
                "marked_deletions_store_ins",
                "marked_deletions_alloc",
                "sweep_loop_locs_subseteq_sweep_locs",
                "sweep_locs_subseteq_fM_tso_empty_locs",
                "sweep_loop_locs_fM_eq_locs",
                "sweep_loop_locs_fA_eq_locs",
                "black_heap_locs_subseteq_fM_tso_empty_locs",
                "black_heap_locs_fM_eq_locs",
                "black_heap_locs_fA_eq_locs",
                "fM_fA_invL_tso_emptyD",
                "gc_sweep_loop_invL_locsE",
                "reachable_snapshot_inv_mo_co_mark",
                "reachable_snapshot_inv_hs_get_roots_done",
                "reachable_snapshot_inv_hs_get_work_done",
                "reachable_snapshot_inv_deref_del",
                "mutator_phase_inv",
                "no_black_refs_sweep_loop_free",
                "no_black_refs_load_W",
                "marked_insertions_sweep_loop_free",
                "marked_deletions_sweep_loop_free",
                "obj_fields_marked_inv_blacken",
                "obj_fields_marked_inv_has_white_path_to_blacken",
                "mutator_phase_inv"
            ]
        },
        {
            "TSO": [
                "tso_lock_invL",
                "tso_store_inv",
                "mut_tso_lock_invL",
                "tso_store_inv",
                "gc_tso_lock_invL",
                "tso_lock_invL",
                "tso_lock_invL",
                "tso_gc_store_inv",
                "gc_tso_lock_invL",
                "mut_tso_lock_invL"
            ]
        },
        {
            "Valid_Refs": [
                "valid_refs_inv_sweep_loop_free",
                "valid_refs_inv_discard_roots",
                "valid_refs_inv_load",
                "valid_refs_inv_alloc",
                "valid_refs_inv_store_ins",
                "valid_refs_inv_deref_del",
                "valid_refs_inv_mo_co_mark",
                "valid_refs_inv"
            ]
        },
        {
            "Worklists": [
                "valid_W_invD0",
                "valid_W_distinct_simps",
                "valid_W_inv_sys_mem_store_buffersD",
                "valid_W_invE2",
                "valid_W_inv_ghg_disjoint",
                "valid_W_inv_mo_co_mark",
                "valid_W_inv_mo_co_lock",
                "valid_W_inv_mo_co_W",
                "valid_W_inv_mo_co_unlock"
            ]
        },
        {
            "Proofs": [
                "mut_invsL",
                "mutators_phase_inv"
            ]
        },
        {
            "Concrete_heap": []
        },
        {
            "Concrete": []
        }
    ],
    "url": "entries/concurrentgc/theories",
    "title": "Session ConcurrentGC"
}