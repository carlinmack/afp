<div id="MoreCoinductiveList2">
<div class="head">
<h1>Theory MoreCoinductiveList2</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Coinductive lists›</span></span>

<span class="keyword1"><span class="command">theory</span></span> MoreCoinductiveList2
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="../Parity_Game/MoreCoinductiveList.html">Parity_Game.MoreCoinductiveList</a> <span class="comment1">(* for notation and lemmas like infinite_small_llength *)</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="MoreCoinductiveList2-ltake_infinity"><span class="command">lemma</span></span> ltake_infinity<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ltake <span class="main">∞</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ltake_all<span class="main">)</span>

<span class="keyword1" id="MoreCoinductiveList2-coinductive_eq_iff_lnth_eq"><span class="command">lemma</span></span> coinductive_eq_iff_lnth_eq<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">=</span> <span class="free">b</span> <span class="main">⟷</span> <span class="main">(</span>llength <span class="free">a</span> <span class="main">=</span> llength <span class="free">b</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">n</span><span class="main">.</span> enat <span class="bound">n</span> <span class="main">&lt;</span> llength <span class="free">a</span> <span class="main">⟶</span> <span class="free">a</span> <span class="main">$</span> <span class="bound">n</span> <span class="main">=</span> <span class="free">b</span> <span class="main">$</span> <span class="bound">n</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"llength <span class="free">a</span> <span class="main">=</span> llength <span class="free">b</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">n</span><span class="main">.</span> enat <span class="bound">n</span> <span class="main">&lt;</span> llength <span class="free">a</span> <span class="main">⟶</span> <span class="free">a</span> <span class="main">$</span> <span class="bound">n</span> <span class="main">=</span> <span class="free">b</span> <span class="main">$</span> <span class="bound">n</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> len<span class="main">:</span><span class="quoted"><span class="quoted">"llength <span class="free">a</span> <span class="main">=</span> llength <span class="free">b</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> lnth<span class="main">:</span><span class="quoted"><span class="quoted">"enat <span class="skolem">n</span> <span class="main">&lt;</span> llength <span class="free">a</span> <span class="main">⟹</span> <span class="free">a</span> <span class="main">$</span> <span class="skolem">n</span> <span class="main">=</span> <span class="free">b</span> <span class="main">$</span> <span class="skolem">n</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">n</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">=</span> <span class="free">b</span>"</span></span> <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"llength <span class="free">a</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>enat <span class="skolem">nat</span><span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> leq<span class="main">:</span><span class="quoted"><span class="quoted">"llist_of <span class="main">(</span>list_of <span class="main">(</span>ltake <span class="skolem">nat</span> <span class="free">a</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">a</span>"</span></span> <span class="quoted"><span class="quoted">"llist_of <span class="main">(</span>list_of <span class="main">(</span>ltake <span class="skolem">nat</span> <span class="free">b</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">b</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> len llength_eq_enat_lfiniteD ltake_all<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> lnth_llist_of lnth
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&lt;</span> length <span class="main">(</span>list_of <span class="main">(</span>ltake <span class="main">(</span>enat <span class="skolem">nat</span><span class="main">)</span> <span class="free">a</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> ltake <span class="main">(</span>enat <span class="skolem">nat</span><span class="main">)</span> <span class="free">a</span> <span class="main">$</span> <span class="skolem">i</span> <span class="main">=</span> ltake <span class="main">(</span>enat <span class="skolem">nat</span><span class="main">)</span> <span class="free">b</span> <span class="main">$</span> <span class="skolem">i</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">i</span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> enat_ord_code<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span> enat_ord_simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> lfinite_ltake llength_llist_of llist_of_list_of<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> len <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span><span class="quoted"><span class="quoted">"length <span class="main">(</span>list_of <span class="main">(</span>ltake <span class="main">(</span>enat <span class="skolem">nat</span><span class="main">)</span> <span class="free">a</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> length <span class="main">(</span>list_of <span class="main">(</span>ltake <span class="main">(</span>enat <span class="skolem">nat</span><span class="main">)</span> <span class="free">b</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> length_list_of_conv_the_enat<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"list_of <span class="main">(</span>ltake <span class="skolem">nat</span> <span class="free">a</span><span class="main">)</span> <span class="main">=</span> list_of <span class="main">(</span>ltake <span class="skolem">nat</span> <span class="free">b</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> list_eq_iff_nth_eq<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> leq <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> infinity
    <span class="keyword1"><span class="command">hence</span></span> inf<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">¬</span> lfinite <span class="free">a</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lfinite <span class="free">b</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> len llength_eq_infty_conv_lfinite <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> lnth<span class="main">[</span><span class="operator">unfolded</span> infinity<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">($)</span> <span class="free">a</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">($)</span> <span class="free">b</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> inf<span class="main">[</span><span class="operator">THEN</span> inf_llist_lnth<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>

<span class="keyword1" id="MoreCoinductiveList2-coinductive_eq_I"><span class="command">lemma</span></span> coinductive_eq_I<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>llength <span class="free">a</span> <span class="main">=</span> llength <span class="free">b</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">n</span><span class="main">.</span> enat <span class="bound">n</span> <span class="main">&lt;</span> llength <span class="free">a</span> <span class="main">⟶</span> <span class="free">a</span> <span class="main">$</span> <span class="bound">n</span> <span class="main">=</span> <span class="free">b</span> <span class="main">$</span> <span class="bound">n</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">=</span> <span class="free">b</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> coinductive_eq_iff_lnth_eq assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Our co-inductive lists will have Option types in them, so we can return None for out of bounds.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">lnth_option</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lnth_option</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">≡</span> <span class="keyword1">if</span> enat <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">&lt;</span> llength <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">$</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="keyword1">else</span> None"</span></span>

<span class="keyword1" id="MoreCoinductiveList2-enat_times_less"><span class="command">lemma</span></span> enat_times_less<span class="main">:</span>
  <span class="quoted"><span class="quoted">"enat <span class="free">c</span> <span class="main">*</span> enat <span class="free">lst</span> <span class="main">&lt;</span> <span class="free">y</span> <span class="main">*</span> enat <span class="free">c</span> <span class="main">⟹</span> <span class="free">lst</span> <span class="main">&lt;</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">y</span></span><span class="main"><span class="keyword3">;</span></span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword1" id="MoreCoinductiveList2-llist_eq_lcons"><span class="command">lemma</span></span> llist_eq_lcons<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">≠</span> LNil"</span></span> <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">≠</span> LNil"</span></span> <span class="quoted"><span class="quoted">"lhd <span class="free">a</span> <span class="main">=</span> lhd <span class="free">b</span>"</span></span> <span class="quoted"><span class="quoted">"ltl <span class="free">a</span> <span class="main">=</span> ltl <span class="free">b</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">=</span> <span class="free">b</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">a</span></span><span class="main"><span class="keyword3">;</span></span><span class="operator">cases</span> <span class="quoted"><span class="free">b</span></span><span class="main"><span class="keyword3">;</span></span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="MoreENat">
<div class="head">
<h1>Theory MoreENat</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Theorems about the extended naturals›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Extended naturals are the natural numbers plus infinity.
      They are slightly more cumbersome to reason about, and this file contains
      some lemmas that should help with that.›</span></span>

<span class="keyword1"><span class="command">theory</span></span> MoreENat
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="MoreCoinductiveList2.html">MoreCoinductiveList2</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="MoreENat-eSuc_n_not_le_n"><span class="command">lemma</span></span> eSuc_n_not_le_n<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
<span class="quoted"><span class="quoted">"<span class="main">(</span>eSuc <span class="free">x</span> <span class="main">≤</span> <span class="free">x</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">=</span> <span class="main">∞</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> enat_ord_simps<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> Suc_n_not_le_n antisym ile_eSuc le_add2 plus_1_eq_Suc the_enat_eSuc<span class="main">)</span>

<span class="keyword1" id="MoreENat-mult_two_impl1"><span class="command">lemma</span></span> mult_two_impl1<span class="main">[</span><span class="operator">elim</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">*</span> <span class="numeral">2</span> <span class="main">=</span> <span class="numeral">2</span> <span class="main">*</span> <span class="free">b</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span><span class="main">::</span>enat<span class="main">)</span> <span class="main">=</span> <span class="free">b</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">a</span></span><span class="main"><span class="keyword3">;</span></span><span class="operator">cases</span> <span class="quoted"><span class="free">b</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mult_2 mult_2_right<span class="main">)</span>

<span class="keyword1" id="MoreENat-mult_two_impl2"><span class="command">lemma</span></span> mult_two_impl2<span class="main">[</span><span class="operator">dest</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">*</span> <span class="numeral">2</span> <span class="main">=</span> <span class="main">1</span> <span class="main">+</span> <span class="numeral">2</span> <span class="main">*</span> <span class="free">b</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span><span class="main">::</span>enat<span class="main">)</span> <span class="main">=</span> <span class="main">∞</span> <span class="main">∧</span> <span class="free">b</span><span class="main">=</span><span class="main">∞</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">a</span></span><span class="main"><span class="keyword3">;</span></span><span class="operator">cases</span> <span class="quoted"><span class="free">b</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> assms Suc_double_not_eq_double<span class="main">[</span><span class="operator">unfolded</span> mult_2<span class="main">,</span> <span class="operator">symmetric</span><span class="main">]</span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mult_2 one_enat_def mult_2_right<span class="main">)</span>

<span class="keyword1" id="MoreENat-mult_two_impl3"><span class="command">lemma</span></span> mult_two_impl3<span class="main">[</span><span class="operator">dest</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">*</span> <span class="numeral">2</span> <span class="main">=</span> <span class="main">1</span> <span class="main">+</span> <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="free">b</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span><span class="main">::</span>enat<span class="main">)</span> <span class="main">=</span> <span class="free">b</span> <span class="main">∧</span> <span class="free">a</span> <span class="main">≥</span> <span class="main">1</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">a</span></span><span class="main"><span class="keyword3">;</span></span><span class="operator">cases</span> <span class="quoted"><span class="free">b</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> one_enat_def mult_2 mult_2_right<span class="main">)</span>

<span class="keyword1" id="MoreENat-mult_two_impl4"><span class="command">lemma</span></span> mult_two_impl4<span class="main">[</span><span class="operator">dest</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">*</span> <span class="numeral">2</span> <span class="main">=</span> <span class="numeral">2</span> <span class="main">*</span> <span class="free">b</span> <span class="main">-</span> <span class="main">1</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">a</span><span class="main">::</span>enat<span class="main">)</span> <span class="main">=</span> <span class="main">0</span> <span class="main">∧</span> <span class="free">b</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span> <span class="main">∨</span> <span class="main">(</span><span class="free">a</span> <span class="main">=</span> <span class="main">∞</span> <span class="main">∧</span> <span class="free">b</span><span class="main">=</span><span class="main">∞</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">a</span></span><span class="main"><span class="keyword3">;</span></span><span class="operator">cases</span> <span class="quoted"><span class="free">b</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">anat</span> <span class="skolem">bnat</span>
  <span class="keyword3"><span class="command">assume</span></span> *<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">=</span> enat <span class="skolem">anat</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">=</span> enat <span class="skolem">bnat</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">anat</span> <span class="main">+</span> <span class="skolem">anat</span> <span class="main">=</span> <span class="skolem">bnat</span> <span class="main">+</span> <span class="skolem">bnat</span> <span class="main">-</span> Suc <span class="main">0</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>enat_0_iff one_enat_def mult_2 mult_2_right<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> * <span class="keyword1"><span class="command">using</span></span> Suc_double_not_eq_double<span class="main">[</span><span class="operator">unfolded</span> mult_2<span class="main">,</span> <span class="operator">symmetric</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Suc_pred add_gr_0 enat_0_iff<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> neq0_conv not_less0 zero_less_diff<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span><span class="main">(</span><span class="operator">insert</span> assms<span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>enat_0_iff one_enat_def mult_2 mult_2_right<span class="main">)</span>


<span class="keyword1" id="MoreENat-times_two_div_two"><span class="command">lemma</span></span> times_two_div_two<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"enat <span class="free">n</span> <span class="main">&lt;</span> <span class="free">x</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="numeral">2</span> <span class="main">*</span> enat <span class="main">(</span><span class="free">n</span> <span class="keyword1">div</span> <span class="numeral">2</span><span class="main">)</span> <span class="main">&lt;</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="numeral">2</span> <span class="main">*</span> <span class="free">n</span> <span class="keyword1">div</span> <span class="numeral">2</span> <span class="main">≤</span> <span class="free">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="numeral">2</span> <span class="main">*</span> enat <span class="main">(</span><span class="free">n</span> <span class="keyword1">div</span> <span class="numeral">2</span><span class="main">)</span> <span class="main">≤</span> enat <span class="free">n</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> enat_numeral enat_ord_simps<span class="main">(</span>2<span class="main">)</span> linorder_not_less mult.commute times_enat_simps<span class="main">(</span>1<span class="main">)</span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> div_times_less_eq_dividend<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="MoreENat-enat_sum_le"><span class="command">lemma</span></span> enat_sum_le<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"enat <span class="main">(</span><span class="free">a</span> <span class="main">+</span> <span class="free">b</span><span class="main">)</span> <span class="main">≤</span> <span class="free">c</span> <span class="main">⟹</span> <span class="free">b</span> <span class="main">≤</span> <span class="free">c</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> dual_order.trans enat_ord_simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> le_add2<span class="main">)</span>


<span class="keyword1" id="MoreENat-enat_Suc_nonzero"><span class="command">lemma</span></span> enat_Suc_nonzero<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"enat <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span><span class="main">≠</span> <span class="main">0</span>"</span></span>
 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Zero_not_Suc enat.inject zero_enat_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="MorePrefix">
<div class="head">
<h1>Theory MorePrefix</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Extra theorems on prefixes of Lists and their coinductive counterparts›</span></span>

<span class="keyword1"><span class="command">theory</span></span> MorePrefix
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="MoreCoinductiveList2.html">MoreCoinductiveList2</a> <span class="comment1">(* for notation and lemmas like infinite_small_llength *)</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹ Reasoning about prefixes ›</span></span>
<span class="keyword1" id="MorePrefix-head_prefixes"><span class="command">lemma</span></span> head_prefixes <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"prefixes <span class="free">list</span> <span class="main">!</span> <span class="main">0</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> hd_conv_nth hd_prefixes prefixes_not_Nil<span class="main">)</span>

<span class="keyword1" id="MorePrefix-non_head_prefixes"><span class="command">lemma</span></span> non_head_prefixes <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">&lt;</span> length <span class="free">p</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>prefixes <span class="free">p</span> <span class="main">!</span> Suc <span class="free">n</span><span class="main">)</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">&lt;</span> length <span class="main">(</span>prefixes <span class="free">p</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"Suc <span class="free">n</span> <span class="main">&lt;</span> length <span class="main">(</span>prefixes <span class="free">p</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> assms<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Zero_not_Suc distinct_prefixes head_prefixes nth_eq_iff_index_eq<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="MorePrefix-last_prefixes"><span class="command">lemma</span></span> last_prefixes<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">&lt;</span> length <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"last <span class="main">(</span>tl <span class="main">(</span>prefixes <span class="free">p</span><span class="main">)</span> <span class="main">!</span> <span class="free">i</span><span class="main">)</span> <span class="main">=</span> <span class="free">p</span> <span class="main">!</span> <span class="free">i</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span><span class="quoted"><span class="free">i</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">a</span> <span class="skolem">p</span> <span class="skolem">i</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">i</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">nat</span><span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> Cons <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">!</span> <span class="skolem">nat</span> <span class="main">=</span> last <span class="main">(</span>tl <span class="main">(</span>prefixes <span class="skolem">p</span><span class="main">)</span> <span class="main">!</span> <span class="skolem">nat</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">nat</span> <span class="main">&lt;</span> length <span class="skolem">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> Suc <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>nth_tl<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">force</span>

<span class="keyword1" id="MorePrefix-take_1_prefixes"><span class="command">lemma</span></span> take_1_prefixes<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"take <span class="main">(</span>Suc <span class="main">0</span><span class="main">)</span> <span class="main">(</span>prefixes <span class="free">list</span><span class="main">)</span> <span class="main">=</span> <span class="main">[</span><span class="main">[]</span><span class="main">]</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> take_Suc<span class="main">)</span>

<span class="keyword1" id="MorePrefix-map_last_prefixes"><span class="command">lemma</span></span> map_last_prefixes <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"map last <span class="main">(</span>tl <span class="main">(</span>prefixes <span class="free">p</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">p</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> list_eq_iff_nth_eq
  <span class="keyword1"><span class="command">using</span></span> last_prefixes <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="MorePrefix-ltake_zero"><span class="command">lemma</span></span> ltake_zero<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ltake <span class="main">(</span>enat <span class="main">(</span><span class="main">0</span><span class="main">::</span>nat<span class="main">)</span><span class="main">)</span> <span class="free">lst</span> <span class="main">=</span> LNil"</span></span>
  <span class="comment1">(* nitpick finds a counterexample in Isabelle2021*)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_enat_def<span class="main">)</span>

<span class="keyword1" id="MorePrefix-ltakes_one_iterates"><span class="command">lemma</span></span> ltakes_one_iterates<span class="main">:</span>
  <span class="quoted"><span class="quoted">"ltake <span class="main">(</span>enat <span class="main">(</span>Suc <span class="main">0</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>iterates <span class="free">f</span> <span class="free">p</span><span class="main">)</span> <span class="main">=</span> LCons <span class="free">p</span> LNil"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> One_nat_def iterates_lmap ltake_eSuc_LCons ltake_zero one_eSuc one_enat_def zero_enat_def<span class="main">)</span>

<span class="keyword1" id="MorePrefix-ltakes_suc_iterates"><span class="command">lemma</span></span> ltakes_suc_iterates<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"ltake <span class="main">(</span>enat <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>iterates <span class="free">f</span> <span class="free">p</span><span class="main">)</span> <span class="main">=</span> LCons <span class="free">p</span> <span class="main">(</span>ltake <span class="main">(</span>enat <span class="free">n</span><span class="main">)</span> <span class="main">(</span>iterates <span class="free">f</span> <span class="main">(</span><span class="free">f</span> <span class="free">p</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>ltakes_one_iterates<span class="main"><span class="keyword3">,</span></span><span class="operator">metis</span> eSuc_enat iterates.code ltake_eSuc_LCons<span class="main">)</span>

<span class="keyword1" id="MorePrefix-prefixes_nth_take"><span class="command">lemma</span></span> prefixes_nth_take<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">≤</span> length <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"prefixes <span class="free">p</span> <span class="main">!</span> <span class="free">i</span> <span class="main">=</span> take <span class="free">i</span> <span class="free">p</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span><span class="quoted"><span class="free">i</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">a</span> <span class="skolem">p</span> <span class="skolem">i</span><span class="main">)</span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">i</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>

<span class="keyword1" id="MorePrefix-tl_prefixes_idx"><span class="command">lemma</span></span> tl_prefixes_idx<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">&lt;</span> length <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"tl <span class="main">(</span>prefixes <span class="free">p</span><span class="main">)</span> <span class="main">!</span> <span class="free">i</span> <span class="main">=</span> take <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span> <span class="free">p</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">p</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword1" id="MorePrefix-list_of_lappend_llist_of"><span class="command">lemma</span></span> list_of_lappend_llist_of<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="free">q</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"list_of <span class="main">(</span>lappend <span class="main">(</span>llist_of <span class="free">p</span><span class="main">)</span> <span class="free">q</span><span class="main">)</span> <span class="main">=</span> append <span class="free">p</span> <span class="main">(</span>list_of <span class="free">q</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">p</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword1" id="MorePrefix-nth_prefixes"><span class="command">lemma</span></span> nth_prefixes<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">&lt;</span> length <span class="free">p</span> <span class="main">⟹</span> <span class="main">¬</span> Suc <span class="free">n</span> <span class="main">&lt;</span> length <span class="free">p</span> <span class="main">⟹</span> tl <span class="main">(</span>prefixes <span class="free">p</span><span class="main">)</span> <span class="main">!</span> <span class="free">n</span> <span class="main">=</span> <span class="free">p</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span><span class="quoted"><span class="free">n</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword1" id="MorePrefix-take_Suc_prefix"><span class="command">lemma</span></span> take_Suc_prefix<span class="main">:</span>
  <span class="quoted"><span class="quoted">"prefix <span class="main">(</span>take <span class="free">n</span> <span class="free">p</span><span class="main">)</span> <span class="main">(</span>take <span class="main">(</span>Suc <span class="free">n</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span><span class="quoted"><span class="free">n</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">a</span> <span class="skolem">p</span> <span class="skolem">n</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">n</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>

<span class="keyword1" id="MorePrefix-nth_prefixes_is_prefix"><span class="command">lemma</span></span> nth_prefixes_is_prefix<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">&lt;</span> length <span class="free">p</span>  <span class="main">⟹</span> prefix <span class="main">(</span><span class="main">(</span>prefixes <span class="free">p</span><span class="main">)</span> <span class="main">!</span> <span class="free">n</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span>prefixes <span class="free">p</span><span class="main">)</span> <span class="main">!</span> Suc <span class="free">n</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="quoted">"length <span class="free">p</span>"</span></span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span><span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span>diff_induct<span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>take_Suc_prefix<span class="main">)</span>

<span class="keyword1" id="MorePrefix-nth_prefixes_is_prefix_tl"><span class="command">lemma</span></span> nth_prefixes_is_prefix_tl<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Suc <span class="free">n</span> <span class="main">&lt;</span> length <span class="free">p</span>  <span class="main">⟹</span> prefix <span class="main">(</span>tl <span class="main">(</span>prefixes <span class="free">p</span><span class="main">)</span> <span class="main">!</span> <span class="free">n</span><span class="main">)</span> <span class="main">(</span>tl <span class="main">(</span>prefixes <span class="free">p</span><span class="main">)</span> <span class="main">!</span> Suc <span class="free">n</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>nth_prefixes_is_prefix take_Suc_prefix<span class="main">)</span>

<span class="keyword1" id="MorePrefix-prefix_same_length_eq"><span class="command">lemma</span></span> prefix_same_length_eq<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>prefix <span class="free">a</span> <span class="free">b</span> <span class="main">∧</span> length <span class="free">a</span> <span class="main">=</span> length <span class="free">b</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">a</span> <span class="main">=</span> <span class="free">b</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> prefix_length_le prefix_length_prefix prefix_order.antisym prefix_order.order_refl<span class="main">)</span>

<span class="keyword1" id="MorePrefix-prefix_takeI"><span class="command">lemma</span></span> prefix_takeI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"prefix <span class="free">a</span> <span class="free">b</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">≥</span> length <span class="free">a</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"prefix <span class="free">a</span> <span class="main">(</span>take <span class="free">n</span> <span class="free">b</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> <span class="main"><span class="main">(</span></span>verit<span class="main"><span class="main">)</span></span> prefix_length_prefix length_take min.absorb2 nat_le_linear take_all take_is_prefix<span class="main">)</span>

<span class="keyword1"><span class="command">thm</span></span> prefix_length_prefix <span class="comment1">(* compare to *)</span>
<span class="keyword1" id="MorePrefix-lprefix_llength_lprefix"><span class="command">lemma</span></span> lprefix_llength_lprefix<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"lprefix <span class="free">a</span> <span class="free">c</span>"</span></span> <span class="quoted"><span class="quoted">"lprefix <span class="free">b</span> <span class="free">c</span>"</span></span> <span class="quoted"><span class="quoted">"llength <span class="free">a</span> <span class="main">≤</span> llength <span class="free">b</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lprefix <span class="free">a</span> <span class="free">b</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> dual_order.antisym lprefix_down_linear lprefix_llength_eq_imp_eq lprefix_llength_le<span class="main">)</span>

<span class="keyword1"><span class="command">thm</span></span> prefix_takeI <span class="comment1">(* compare to *)</span>
<span class="keyword1" id="MorePrefix-lprefix_ltakeI"><span class="command">lemma</span></span> lprefix_ltakeI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"lprefix <span class="free">a</span> <span class="free">b</span>"</span></span> <span class="quoted"><span class="quoted">"llength <span class="free">a</span> <span class="main">≤</span> <span class="free">n</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lprefix <span class="free">a</span> <span class="main">(</span>ltake <span class="free">n</span> <span class="free">b</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> <span class="main"><span class="main">(</span></span>verit<span class="main"><span class="main">,</span></span> best<span class="main"><span class="main">)</span></span> dual_order.antisym lappend_eq_lappend_conv lappend_ltake_ldrop llength_ltake
                        assms lprefix_conv_lappend lprefix_down_linear lprefix_llength_le min_def<span class="main">)</span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">augment_list</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">augment_list</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">@</span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">]</span>"</span></span>

<span class="keyword1" id="MorePrefix-length_augment_list"><span class="command">lemma</span></span> length_augment_list<span class="main">:</span>
  <span class="quoted"><span class="quoted">"length <span class="main">(</span><span class="main">(</span>augment_list <span class="free">f</span> <span class="main">^^</span> <span class="free">n</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span> <span class="main">=</span> <span class="free">n</span> <span class="main">+</span> length <span class="free">p</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword1" id="MorePrefix-augment_list_nonempty"><span class="command">lemma</span></span> augment_list_nonempty<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">≠</span><span class="main">[]</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>augment_list <span class="free">f</span> <span class="main">^^</span> <span class="free">i</span><span class="main">)</span> <span class="free">p</span> <span class="main">≠</span> <span class="main">[]</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">i</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword1" id="MorePrefix-augment_list_Suc_prefix"><span class="command">lemma</span></span> augment_list_Suc_prefix<span class="main">:</span>
  <span class="quoted"><span class="quoted">"prefix <span class="main">(</span><span class="main">(</span>augment_list <span class="free">f</span> <span class="main">^^</span> <span class="free">n</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span>augment_list <span class="free">f</span> <span class="main">^^</span> Suc <span class="free">n</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">n</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>take_Suc_prefix<span class="main">)</span>

<span class="keyword1" id="MorePrefix-augment_list_prefix"><span class="command">lemma</span></span> augment_list_prefix<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">≤</span> <span class="free">m</span> <span class="main">⟹</span> prefix <span class="main">(</span><span class="main">(</span>augment_list <span class="free">f</span> <span class="main">^^</span> <span class="free">n</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span>augment_list <span class="free">f</span> <span class="main">^^</span> <span class="free">m</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="quoted">"<span class="free">m</span><span class="main">-</span><span class="free">n</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span><span class="quoted"><span class="free">m</span></span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">x</span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span><span class="quoted"><span class="quoted">"Suc <span class="main">(</span><span class="skolem">x</span> <span class="main">+</span> <span class="skolem">n</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">m</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> Suc.hyps<span class="main">(</span>2<span class="main">)</span> 
    prefix_order.order.trans<span class="main">[</span><span class="operator">OF</span> Suc.hyps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">+</span> <span class="skolem">n</span>"</span></span> <span class="quoted"><span class="skolem">n</span></span><span class="main"><span class="main">]</span></span> augment_list_Suc_prefix<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span><span class="main">+</span><span class="skolem">n</span>"</span></span> <span class="quoted"><span class="free">f</span></span> <span class="quoted"><span class="free">p</span></span><span class="main"><span class="main">]</span></span><span class="main">]</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>

<span class="keyword1" id="MorePrefix-augment_list_nonsense"><span class="command">lemma</span></span> augment_list_nonsense<span class="main">[</span><span class="operator">dest</span><span class="main">]</span><span class="main">:</span>
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>augment_list <span class="free">σ</span> <span class="main">^^</span> <span class="free">n</span><span class="main">)</span> <span class="free">p</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span><span class="main">=</span><span class="main">0</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">=</span><span class="main">[]</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword1" id="MorePrefix-prefix_augment"><span class="command">lemma</span></span> prefix_augment<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"prefix <span class="free">p</span> <span class="main">(</span><span class="main">(</span>augment_list <span class="free">s</span> <span class="main">^^</span> <span class="free">n</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>prefix_def<span class="main">)</span>


<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="AlternatingLists">
<div class="head">
<h1>Theory AlternatingLists</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹ Alternating lists ›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In lists where even and odd elements play different roles, it helps to define functions to
      take out the even elements. We defined the function (l)alternate on (coinductive) lists to
      do exactly this, and define certain properties.›</span></span>

<span class="keyword1"><span class="command">theory</span></span> AlternatingLists
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="MoreCoinductiveList2.html">MoreCoinductiveList2</a> <span class="comment1">(* for notation and lemmas like infinite_small_llength *)</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The functions ``alternate" and ``lalternate" are our main workhorses:
      they take every other item, so every item at even indices.›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">alternate</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">alternate</span> Nil <span class="main">=</span> Nil"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">alternate</span> <span class="main">(</span>Cons <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> Cons <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="free">alternate</span> <span class="main">(</span>tl <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹``lalternate" takes every other item from a co-inductive list.›</span></span>
<span class="keyword1"><span class="command">primcorec</span></span> <span class="entity">lalternate</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> llist <span class="main">⇒</span> <span class="tfree">'a</span> llist"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">lalternate</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">of</span> LNil <span class="main">⇒</span> LNil <span class="main">|</span>
                                 <span class="main">(</span>LCons <span class="bound">x</span> <span class="bound">xs</span><span class="main">)</span> <span class="main">⇒</span> LCons <span class="bound">x</span> <span class="main">(</span><span class="free">lalternate</span> <span class="main">(</span>ltl <span class="bound">xs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="AlternatingLists-lalternate_ltake"><span class="command">lemma</span></span> lalternate_ltake<span class="main">:</span>
  <span class="quoted"><span class="quoted">"ltake <span class="main">(</span>enat <span class="free">n</span><span class="main">)</span> <span class="main">(</span>lalternate <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> lalternate <span class="main">(</span>ltake <span class="main">(</span><span class="numeral">2</span><span class="main">*</span><span class="free">n</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span><span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 0
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> LNil_eq_ltake_iff enat_defs<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> lalternate.ctr<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> lnull_def mult_zero_right<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> lt<span class="main">:</span><span class="quoted"><span class="quoted">"ltake <span class="main">(</span>enat <span class="skolem">n</span><span class="main">)</span> <span class="main">(</span>lalternate <span class="main">(</span>ltl <span class="main">(</span>ltl <span class="skolem">xs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> lalternate <span class="main">(</span>ltake <span class="main">(</span>enat <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="skolem">n</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>ltl <span class="main">(</span>ltl <span class="skolem">xs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="keyword1"><span class="command">.</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"lalternate <span class="skolem">xs</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> LNil
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">metis</span> lalternate.disc<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> lnull_def ltake_LNil<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>LCons <span class="skolem">x21</span> <span class="skolem">x22</span><span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> ltake_ltl mult_Suc_right add_2_eq_Suc
      <span class="keyword1"><span class="command">using</span></span> eSuc_enat lalternate.code lalternate.ctr<span class="main">(</span>1<span class="main">)</span> lhd_LCons_ltl llist.sel<span class="main">(</span>1<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> <span class="main"><span class="main">(</span></span>z3<span class="main"><span class="main">)</span></span> lt ltake_ltl llist.simps<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> llist.simps<span class="main"><span class="main">(</span></span>5<span class="main"><span class="main">)</span></span> ltake_eSuc_LCons<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="AlternatingLists-lalternate_llist_of"><span class="command">lemma</span></span> lalternate_llist_of<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"lalternate <span class="main">(</span>llist_of <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> llist_of <span class="main">(</span>alternate <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="quoted">"alternate <span class="free">xs</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span><span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> Nil
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> alternate.elims lalternate.ctr<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> list.simps<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> llist_of.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> lnull_llist_of<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">a</span> <span class="skolem">xs</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> lalternate.ctr<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="AlternatingLists-lalternate_finite_helper"><span class="command">lemma</span></span> lalternate_finite_helper<span class="main">:</span> <span class="comment1">(* The other direction is proved later, added as SIMP rule *)</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="main">(</span>lalternate <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="quoted">"lalternate <span class="free">xs</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span><span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span>lfinite_induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> LNil
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> lalternate.code<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main"><span class="keyword3">;</span></span><span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>LCons <span class="skolem">xs</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> lalternate.code<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span>"</span></span><span class="main"><span class="keyword3">;</span></span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"ltl <span class="skolem">xs</span>"</span></span><span class="main"><span class="keyword3">;</span></span><span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="AlternatingLists-alternate_list_of"><span class="command">lemma</span></span> alternate_list_of<span class="main">:</span> <span class="comment1">(* Note that this only holds for finite lists,
                    as the other direction is left undefined with arguments (not just undefined) *)</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"alternate <span class="main">(</span>list_of <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> list_of <span class="main">(</span>lalternate <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> lalternate_llist_of list_of_llist_of llist_of_list_of<span class="main">)</span>

<span class="keyword1" id="AlternatingLists-alternate_length"><span class="command">lemma</span></span> alternate_length<span class="main">:</span>
  <span class="quoted"><span class="quoted">"length <span class="main">(</span>alternate <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">1</span><span class="main">+</span>length <span class="free">xs</span><span class="main">)</span> <span class="keyword1">div</span> <span class="numeral">2</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span>induct_list012<span class="main"><span class="keyword3">;</span></span><span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="AlternatingLists-lalternate_llength"><span class="command">lemma</span></span> lalternate_llength<span class="main">:</span>
  <span class="quoted"><span class="quoted">"llength <span class="main">(</span>lalternate <span class="free">xs</span><span class="main">)</span> <span class="main">*</span> <span class="numeral">2</span> <span class="main">=</span> <span class="main">(</span><span class="main">1</span><span class="main">+</span>llength <span class="free">xs</span><span class="main">)</span> <span class="main">∨</span> llength <span class="main">(</span>lalternate <span class="free">xs</span><span class="main">)</span> <span class="main">*</span> <span class="numeral">2</span> <span class="main">=</span> llength <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?xs</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"list_of <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>alternate <span class="var">?xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">1</span><span class="main">+</span>length <span class="var">?xs</span><span class="main">)</span> <span class="keyword1">div</span> <span class="numeral">2</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> alternate_length <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>alternate <span class="var">?xs</span><span class="main">)</span> <span class="main">*</span> <span class="numeral">2</span> <span class="main">=</span> <span class="main">(</span><span class="main">1</span><span class="main">+</span>length <span class="var">?xs</span><span class="main">)</span> <span class="main">∨</span> length <span class="main">(</span>alternate <span class="var">?xs</span><span class="main">)</span> <span class="main">*</span> <span class="numeral">2</span> <span class="main">=</span> length <span class="var">?xs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> alternate_list_of<span class="main">[</span><span class="operator">OF</span> True<span class="main">]</span> lalternate_llist_of True
    length_list_of_conv_the_enat<span class="main">[</span><span class="operator">OF</span> True<span class="main">]</span> llist_of_list_of<span class="main">[</span><span class="operator">OF</span> True<span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> llength_llist_of numeral_One of_nat_eq_enat of_nat_mult of_nat_numeral plus_enat_simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> lfinite <span class="main">(</span>lalternate <span class="free">xs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> False lalternate_finite_helper <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> l1<span class="main">:</span><span class="quoted"><span class="quoted">"llength <span class="main">(</span>lalternate <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">∞</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> not_lfinite_llength<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> False <span class="keyword1"><span class="command">have</span></span> l2<span class="main">:</span><span class="quoted"><span class="quoted">"llength <span class="free">xs</span> <span class="main">=</span> <span class="main">∞</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> not_lfinite_llength <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> l1 l2 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mult_2_right<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="AlternatingLists-lalternate_finite"><span class="command">lemma</span></span> lalternate_finite<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="main">(</span>lalternate <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> lfinite <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"lfinite <span class="free">xs</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"lfinite <span class="main">(</span>lalternate <span class="free">xs</span><span class="main">)</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> not_lfinite_llength<span class="main">[</span><span class="operator">OF</span> False<span class="main">]</span> True<span class="main">[</span><span class="operator">unfolded</span> lfinite_conv_llength_enat<span class="main">]</span>
                      lalternate_llength<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">xs</span></span><span class="main">]</span>
                <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>one_enat_def numeral_eq_enat<span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> lalternate_finite_helper <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="AlternatingLists-nth_alternate"><span class="command">lemma</span></span> nth_alternate<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="numeral">2</span><span class="main">*</span><span class="free">n</span> <span class="main">&lt;</span> length <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"alternate <span class="free">xs</span> <span class="main">!</span> <span class="free">n</span> <span class="main">=</span> <span class="free">xs</span> <span class="main">!</span> <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="free">n</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span><span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span>induct_list012<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>3 <span class="skolem">x</span> <span class="skolem">y</span> <span class="skolem">zs</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">n</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">nat</span><span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted">"3.hyps"</span><span class="main">(</span>1<span class="main">)</span> <span class="quoted">"3.prems"</span> Suc <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>

<span class="keyword1" id="AlternatingLists-lnth_lalternate"><span class="command">lemma</span></span> lnth_lalternate<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="numeral">2</span><span class="main">*</span><span class="free">n</span> <span class="main">&lt;</span> llength <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lalternate <span class="free">xs</span> <span class="main">$</span> <span class="free">n</span> <span class="main">=</span> <span class="free">xs</span> <span class="main">$</span> <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?xs</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"ltake <span class="main">(</span><span class="numeral">2</span><span class="main">*</span>Suc <span class="free">n</span><span class="main">)</span> <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lalternate <span class="var">?xs</span> <span class="main">$</span> <span class="free">n</span> <span class="main">=</span> <span class="var">?xs</span> <span class="main">$</span> <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="free">n</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms alternate_list_of<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"ltake <span class="main">(</span><span class="numeral">2</span><span class="main">*</span>Suc <span class="free">n</span><span class="main">)</span> <span class="free">xs</span>"</span></span><span class="main">]</span> nth_alternate<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">n</span></span> <span class="quoted"><span class="quoted">"list_of <span class="var">?xs</span>"</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> <span class="main"><span class="main">(</span></span>z3<span class="main"><span class="main">)</span></span> Suc_1 Suc_mult_less_cancel1 enat_ord_simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> infinite_small_llength lalternate_ltake length_list_of lessI llength_eq_enat_lfiniteD llength_ltake' ltake_all not_less nth_list_of numeral_eq_enat the_enat.simps times_enat_simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Suc_1 Suc_mult_less_cancel1 enat_ord_simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> lalternate_ltake lessI lnth_ltake<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="AlternatingLists-lnth_lalternate2"><span class="command">lemma</span></span> lnth_lalternate2<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">&lt;</span> llength <span class="main">(</span>lalternate <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lalternate <span class="free">xs</span> <span class="main">$</span> <span class="free">n</span> <span class="main">=</span> <span class="free">xs</span> <span class="main">$</span> <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="numeral">2</span><span class="main">*</span>enat <span class="free">n</span> <span class="main">&lt;</span> llength <span class="free">xs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> enat_numeral lalternate_ltake leI linorder_neq_iff llength_ltake' ltake_all times_enat_simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> lnth_lalternate<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span><span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="GaleStewartGames">
<div class="head">
<h1>Theory GaleStewartGames</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Gale Stewart Games›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Gale Stewart Games are infinite two player games.›</span></span>
<span class="comment1">(* [Gale &amp; Stewart 1953] David Gale, F. M. Stewart, Infinite games with perfect information,
   Contributions to the Theory of Games II, ed. H. W. Kuhn and A. W. Tucker,
   Annals of Mathematics Studies 28, Princeton University Press (1953), pp 245–266. *)</span>

<span class="keyword1"><span class="command">theory</span></span> GaleStewartGames
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="AlternatingLists.html">AlternatingLists</a> <a href="MorePrefix.html">MorePrefix</a> <a href="MoreENat.html">MoreENat</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Basic definitions and their properties.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A GSgame G(A) is defined by a set of sequences that denote the winning games for the first
      player. Our notion of GSgames generalizes both finite and infinite games by setting a game length.
      Note that the type of n is 'enat' (extended nat): either a nonnegative integer or infinity.
      Our only requirement on GSgames is that the winning games must have the length as specified
      as the length of the game. This helps certain theorems about winning look a bit more natural.›</span></span>

<span class="keyword1"><span class="command">locale</span></span> GSgame <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">A</span> <span class="free">N</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> length<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">e</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> llength <span class="bound">e</span> <span class="main">=</span> <span class="numeral">2</span><span class="main">*</span><span class="free">N</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A position is a finite sequence of valid moves.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted">"<span class="entity">position</span>"</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">position</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">::</span><span class="tfree">'a</span> list<span class="main">)</span> <span class="main">≡</span> length <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">≤</span> <span class="numeral">2</span><span class="main">*</span><span class="free">N</span>"</span></span>

<span class="keyword1" id="GaleStewartGames-position_maxlength_cannotbe_augmented"><span class="command">lemma</span></span> position_maxlength_cannotbe_augmented<span class="main">:</span>
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"length <span class="free">p</span> <span class="main">=</span> <span class="numeral">2</span><span class="main">*</span><span class="free">N</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> position <span class="main">(</span><span class="free">p</span> <span class="main">@</span> <span class="main">[</span><span class="free">m</span><span class="main">]</span><span class="main">)</span>"</span></span>
 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>position_def assms<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A play is a sequence of valid moves of the right length.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted">"<span class="entity">play</span>"</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">play</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">::</span><span class="tfree">'a</span> llist<span class="main">)</span> <span class="main">≡</span> llength <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">=</span> <span class="numeral">2</span><span class="main">*</span><span class="free">N</span>"</span></span>

<span class="keyword1" id="GaleStewartGames-plays_are_positions_conv"><span class="command">lemma</span></span> plays_are_positions_conv<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"play <span class="main">(</span>llist_of <span class="free">p</span><span class="main">)</span> <span class="main">⟷</span> position <span class="free">p</span> <span class="main">∧</span> length <span class="free">p</span> <span class="main">=</span> <span class="numeral">2</span><span class="main">*</span><span class="free">N</span>"</span></span> 
<span class="keyword1"><span class="command">unfolding</span></span> play_def position_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="GaleStewartGames-finite_plays_are_positions"><span class="command">lemma</span></span> finite_plays_are_positions<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"play <span class="free">p</span>"</span></span> <span class="quoted"><span class="quoted">"lfinite <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"position <span class="main">(</span>list_of <span class="free">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms 
<span class="keyword1"><span class="command">unfolding</span></span> play_def position_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"lfinite <span class="free">p</span>"</span></span><span class="main"><span class="keyword3">;</span></span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>length_list_of<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We call our players Even and Odd, where Even makes the first move.
      This means that Even is to make moves on plays of even length, and Odd on the others.
      This corresponds nicely to Even making all the moves in an even position, as
      the `nth' and `lnth' functions as predefined in Isabelle's library count from 0.
      In literature the players are sometimes called I and II.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A strategy for Even/Odd is simply a function that takes a position of even/odd length and
      returns a move. We use total functions for strategies. This means that their Isabelle-type
      determines that it is a strategy. Consequently, we do not have a definition of 'strategy'.
      Nevertheless, we will use $\sigma$ as a letter to indicate when something is a strategy.
      We can combine two strategies into one function, which gives a collective strategy that
      we will refer to as the joint strategy.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">joint_strategy</span>  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'b</span> list <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span> list <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span> list <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">joint_strategy</span> <span class="free"><span class="bound"><span class="entity">σ<span class="hidden">⇩</span><sub>e</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">σ<span class="hidden">⇩</span><sub>o</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> even <span class="main">(</span>length <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">σ<span class="hidden">⇩</span><sub>e</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">σ<span class="hidden">⇩</span><sub>o</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Following a strategy leads to an infinite sequence of moves.
      Note that we are not in the context of 'GSGame' where 'N' determines the length of our plays:
      we just let sequences go on ad infinitum here.
      Rather than reasoning about our own recursive definitions,
      we build this infinite sequence by reusing definitions that are already in place.
      We do this by first defining all prefixes of the infinite sequence we are interested in.
      This gives an infinite list such that the nth element is of length n.
      Note that this definition allows us to talk about how a strategy would continue if it were
      played from an arbitrary position (not necessarily one that is reached via that strategy). ›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">strategy_progression</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">strategy_progression</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> lappend <span class="main">(</span>llist_of <span class="main">(</span>prefixes <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>ltl <span class="main">(</span>iterates <span class="main">(</span>augment_list <span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="GaleStewartGames-induced_play_infinite"><span class="command">lemma</span></span> induced_play_infinite<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">¬</span> lfinite <span class="main">(</span>strategy_progression <span class="free">σ</span> <span class="free">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> strategy_progression_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="GaleStewartGames-plays_from_strategy_lengths"><span class="command">lemma</span></span> plays_from_strategy_lengths<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"length <span class="main">(</span>strategy_progression <span class="free">σ</span> <span class="free">p</span> <span class="main">$</span> <span class="free">i</span><span class="main">)</span> <span class="main">=</span> <span class="free">i</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">i</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 0
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span><span class="main"><span class="keyword3">;</span></span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>strategy_progression_def lnth_lappend take_map ltake_lappend<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">i</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span><span class="main">&lt;</span>length <span class="free">p</span>"</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>strategy_progression_def lnth_lappend length_augment_list tl_prefixes_idx<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="GaleStewartGames-length_plays_from_strategy"><span class="command">lemma</span></span> length_plays_from_strategy<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"llength <span class="main">(</span>strategy_progression <span class="free">σ</span> <span class="free">p</span><span class="main">)</span> <span class="main">=</span> <span class="main">∞</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> strategy_progression_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1" id="GaleStewartGames-length_ltl_plays_from_strategy"><span class="command">lemma</span></span> length_ltl_plays_from_strategy<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"llength <span class="main">(</span>ltl <span class="main">(</span>strategy_progression <span class="free">σ</span> <span class="free">p</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">∞</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> strategy_progression_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="GaleStewartGames-plays_from_strategy_chain_Suc"><span class="command">lemma</span></span> plays_from_strategy_chain_Suc<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"prefix <span class="main">(</span>strategy_progression <span class="free">σ</span> <span class="free">p</span>  <span class="main">$</span>  <span class="free">n</span><span class="main">)</span> <span class="main">(</span>strategy_progression <span class="free">σ</span> <span class="free">p</span>  <span class="main">$</span>  Suc <span class="free">n</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> strategy_progression_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>take_Suc_prefix nth_prefixes lnth_lappend nth_prefixes_is_prefix_tl
                augment_list_prefix<span class="main">)</span>

<span class="keyword1" id="GaleStewartGames-plays_from_strategy_chain"><span class="command">lemma</span></span> plays_from_strategy_chain<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">≤</span> <span class="free">m</span> <span class="main">⟹</span> prefix <span class="main">(</span>strategy_progression <span class="free">σ</span> <span class="free">p</span>  <span class="main">$</span>  <span class="free">n</span><span class="main">)</span> <span class="main">(</span>strategy_progression <span class="free">σ</span> <span class="free">p</span>  <span class="main">$</span>  <span class="free">m</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="quoted">"<span class="free">m</span><span class="main">-</span><span class="free">n</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span><span class="quoted"><span class="free">m</span></span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">x</span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span><span class="quoted"><span class="quoted">"Suc <span class="main">(</span><span class="skolem">x</span> <span class="main">+</span> <span class="skolem">n</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">m</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> Suc.hyps<span class="main">(</span>2<span class="main">)</span> 
    prefix_order.order.trans<span class="main">[</span><span class="operator">OF</span> Suc.hyps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">+</span> <span class="skolem">n</span>"</span></span> <span class="quoted"><span class="skolem">n</span></span><span class="main"><span class="main">]</span></span> plays_from_strategy_chain_Suc<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span><span class="main">+</span><span class="skolem">n</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">]</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>

<span class="keyword1" id="GaleStewartGames-plays_from_strategy_remains_const"><span class="command">lemma</span></span> plays_from_strategy_remains_const<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">≤</span> <span class="free">i</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"take <span class="free">n</span> <span class="main">(</span>strategy_progression <span class="free">σ</span> <span class="free">p</span>  <span class="main">$</span>  <span class="free">i</span><span class="main">)</span>  <span class="main">=</span>  strategy_progression <span class="free">σ</span> <span class="free">p</span>  <span class="main">$</span>  <span class="free">n</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> sym<span class="main"><span class="keyword3">,</span></span><span class="operator">subst</span> prefix_same_length_eq<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> assms plays_from_strategy_chain<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span>prefix_takeI<span class="main">)</span>

<span class="keyword1" id="GaleStewartGames-infplays_augment_one"><span class="command">lemma</span></span> infplays_augment_one<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"strategy_progression <span class="free">σ</span> <span class="main">(</span><span class="free">p</span> <span class="main">@</span> <span class="main">[</span><span class="free">σ</span> <span class="free">p</span><span class="main">]</span><span class="main">)</span> <span class="main">=</span> strategy_progression <span class="free">σ</span> <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> defs <span class="main">=</span> strategy_progression_def
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">case</span></span> Nil
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>defs iterates.code<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="free">σ</span> <span class="main">[]</span><span class="main">]</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">a</span> <span class="skolem">p</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>defs iterates.code<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">#</span> <span class="skolem">p</span> <span class="main">@</span> <span class="main">[</span><span class="free">σ</span> <span class="main">(</span><span class="skolem">a</span> <span class="main">#</span> <span class="skolem">p</span><span class="main">)</span><span class="main">]</span>"</span></span><span class="main"><span class="main">]</span></span> lappend_llist_of_LCons<span class="main">)</span>
  <span class="keyword1"><span class="command">}</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="GaleStewartGames-infplays_augment_many"><span class="command">lemma</span></span> infplays_augment_many<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"strategy_progression <span class="free">σ</span> <span class="main">(</span><span class="main">(</span>augment_list <span class="free">σ</span> <span class="main">^^</span> <span class="free">n</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span> <span class="main">=</span> strategy_progression <span class="free">σ</span> <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword1" id="GaleStewartGames-infplays_augment_one_joint"><span class="command">lemma</span></span> infplays_augment_one_joint<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"even <span class="main">(</span>length <span class="free">p</span><span class="main">)</span> <span class="main">⟹</span> strategy_progression <span class="main">(</span>joint_strategy <span class="free">σ<span class="hidden">⇩</span><sub>e</sub></span> <span class="free">σ<span class="hidden">⇩</span><sub>o</sub></span><span class="main">)</span> <span class="main">(</span>augment_list <span class="free">σ<span class="hidden">⇩</span><sub>e</sub></span> <span class="free">p</span><span class="main">)</span>
                     <span class="main">=</span> strategy_progression <span class="main">(</span>joint_strategy <span class="free">σ<span class="hidden">⇩</span><sub>e</sub></span> <span class="free">σ<span class="hidden">⇩</span><sub>o</sub></span><span class="main">)</span> <span class="free">p</span>"</span></span>
  <span class="quoted"><span class="quoted">"odd <span class="main">(</span>length <span class="free">p</span><span class="main">)</span>  <span class="main">⟹</span> strategy_progression <span class="main">(</span>joint_strategy <span class="free">σ<span class="hidden">⇩</span><sub>e</sub></span> <span class="free">σ<span class="hidden">⇩</span><sub>o</sub></span><span class="main">)</span> <span class="main">(</span>augment_list <span class="free">σ<span class="hidden">⇩</span><sub>o</sub></span> <span class="free">p</span><span class="main">)</span>
                     <span class="main">=</span> strategy_progression <span class="main">(</span>joint_strategy <span class="free">σ<span class="hidden">⇩</span><sub>e</sub></span> <span class="free">σ<span class="hidden">⇩</span><sub>o</sub></span><span class="main">)</span> <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> infplays_augment_one<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"joint_strategy <span class="free">σ<span class="hidden">⇩</span><sub>e</sub></span> <span class="free">σ<span class="hidden">⇩</span><sub>o</sub></span>"</span></span> <span class="quoted"><span class="free">p</span></span><span class="main">]</span>
<span class="keyword1"><span class="command">unfolding</span></span> joint_strategy_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Following two different strategies from a single position will lead to the same plays
      if the strategies agree on moves played after that position.
      This lemma allows us to ignore the behavior of strategies for moves that are already played. ›</span></span>
<span class="keyword1" id="GaleStewartGames-infplays_eq"><span class="command">lemma</span></span> infplays_eq<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">p'</span><span class="main">.</span> prefix <span class="free">p</span> <span class="bound">p'</span> <span class="main">⟹</span> augment_list <span class="free">s1</span> <span class="bound">p'</span> <span class="main">=</span> augment_list <span class="free">s2</span> <span class="bound">p'</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"strategy_progression <span class="free">s1</span> <span class="free">p</span> <span class="main">=</span> strategy_progression <span class="free">s2</span> <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">p</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span><span class="quoted"><span class="quoted">"<span class="free">s1</span> <span class="free">p</span> <span class="main">=</span> <span class="free">s2</span> <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>augment_list <span class="free">s1</span> <span class="main">^^</span> <span class="skolem">n</span><span class="main">)</span> <span class="main">(</span>augment_list <span class="free">s1</span> <span class="free">p</span><span class="main">)</span> <span class="main">=</span>
          <span class="main">(</span>augment_list <span class="free">s2</span> <span class="main">^^</span> <span class="skolem">n</span><span class="main">)</span> <span class="main">(</span>augment_list <span class="free">s2</span> <span class="free">p</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">n</span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">n</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> assms<span class="main">[</span><span class="operator">OF</span> prefix_order.order.trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ prefix_augment<span class="main"><span class="main">]</span></span><span class="main">]</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"strategy_progression <span class="free">s1</span> <span class="free">p</span> <span class="main">$</span> <span class="skolem">n</span> <span class="main">=</span> strategy_progression <span class="free">s2</span> <span class="free">p</span> <span class="main">$</span> <span class="skolem">n</span>"</span></span>
    <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">n</span> <span class="comment1">(* different n *)</span> <span class="keyword1"><span class="command">unfolding</span></span> strategy_progression_def lnth_lappend <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro</span> coinductive_eq_I<span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">context</span></span> GSgame
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹By looking at the last elements of the infinite progression,
      we can get a single sequence, which we trim down to the right length.
      Since it has the right length, this always forms a play.
      We therefore name this the 'induced play'. ›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">induced_play</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">induced_play</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main">≡</span> ltake <span class="main">(</span><span class="numeral">2</span><span class="main">*</span><span class="free">N</span><span class="main">)</span> <span class="keyword1">o</span> lmap last <span class="keyword1">o</span> ltl <span class="keyword1">o</span> strategy_progression <span class="free"><span class="bound"><span class="entity">σ</span></span></span>"</span></span>

<span class="keyword1" id="GaleStewartGames-induced_play_infinite_le"><span class="command">lemma</span></span> induced_play_infinite_le<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"enat <span class="free">x</span> <span class="main">&lt;</span> llength <span class="main">(</span>strategy_progression <span class="free">σ</span> <span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"enat <span class="free">x</span> <span class="main">&lt;</span> llength <span class="main">(</span>lmap <span class="free">f</span> <span class="main">(</span>strategy_progression <span class="free">σ</span> <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"enat <span class="free">x</span> <span class="main">&lt;</span> llength <span class="main">(</span>ltake <span class="main">(</span><span class="numeral">2</span><span class="main">*</span><span class="free">N</span><span class="main">)</span> <span class="main">(</span>lmap <span class="free">f</span> <span class="main">(</span>strategy_progression <span class="free">σ</span> <span class="free">p</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">&lt;</span> <span class="numeral">2</span><span class="main">*</span><span class="free">N</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> induced_play_infinite <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="GaleStewartGames-induced_play_is_lprefix"><span class="command">lemma</span></span> induced_play_is_lprefix<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"position <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lprefix <span class="main">(</span>llist_of <span class="free">p</span><span class="main">)</span> <span class="main">(</span>induced_play <span class="free">σ</span> <span class="free">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> l<span class="main">:</span><span class="quoted"><span class="quoted">"llength <span class="main">(</span>llist_of <span class="free">p</span><span class="main">)</span> <span class="main">≤</span> <span class="numeral">2</span> <span class="main">*</span> <span class="free">N</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> position_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lprefix <span class="main">(</span>llist_of <span class="free">p</span><span class="main">)</span> <span class="main">(</span>lmap last <span class="main">(</span>ltl <span class="main">(</span>llist_of <span class="main">(</span>prefixes <span class="free">p</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"lprefix <span class="main">(</span>llist_of <span class="free">p</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span>lmap last <span class="keyword1">o</span> ltl <span class="keyword1">o</span> strategy_progression <span class="free">σ</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> strategy_progression_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lmap_lappend_distrib lprefix_lappend<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> induced_play_def o_def
    <span class="keyword1"><span class="command">using</span></span> lprefix_ltakeI<span class="main">[</span><span class="operator">OF</span> _ l<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="GaleStewartGames-length_induced_play"><span class="command">lemma</span></span> length_induced_play<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"llength <span class="main">(</span>induced_play <span class="free">s</span> <span class="free">p</span><span class="main">)</span> <span class="main">=</span> <span class="numeral">2</span> <span class="main">*</span> <span class="free">N</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> induced_play_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="GaleStewartGames-induced_play_lprefix_non_positions"><span class="command">lemma</span></span> induced_play_lprefix_non_positions<span class="main">:</span> <span class="comment1">(* 'opposite' of induced_play_is_lprefix *)</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"length <span class="main">(</span><span class="free">p</span><span class="main">::</span><span class="tfree">'a</span> list<span class="main">)</span> <span class="main">≥</span> <span class="numeral">2</span> <span class="main">*</span> <span class="free">N</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"induced_play <span class="free">σ</span> <span class="free">p</span> <span class="main">=</span> ltake <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="free">N</span><span class="main">)</span> <span class="main">(</span>llist_of <span class="free">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">N</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>enat <span class="skolem">nat</span><span class="main">)</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?p</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"take <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="skolem">nat</span><span class="main">)</span> <span class="free">p</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span><span class="quoted"><span class="quoted">"<span class="numeral">2</span> <span class="main">*</span> <span class="free">N</span> <span class="main">≤</span> enat <span class="main">(</span>length <span class="free">p</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span><span class="quoted"><span class="quoted">"<span class="numeral">2</span> <span class="main">*</span> <span class="free">N</span> <span class="main">≤</span> enat <span class="main">(</span>min <span class="main">(</span>length <span class="free">p</span><span class="main">)</span> <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="skolem">nat</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> enat
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> assms enat min.orderI min_def numeral_eq_enat times_enat_simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span><span class="quoted"><span class="quoted">"enat <span class="main">(</span>min <span class="main">(</span>length <span class="free">p</span><span class="main">)</span> <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="skolem">nat</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="numeral">2</span> <span class="main">*</span> <span class="free">N</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> assms enat min.absorb2 min_enat_simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span>
        numeral_eq_enat times_enat_simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> n<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="numeral">2</span> <span class="main">*</span> <span class="free">N</span> <span class="main">≤</span> llength <span class="main">(</span>llist_of <span class="free">p</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="numeral">2</span> <span class="main">*</span> <span class="free">N</span> <span class="main">≤</span> llength <span class="main">(</span>llist_of <span class="main">(</span>take <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="skolem">nat</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> pp<span class="main">:</span><span class="quoted"><span class="quoted">"position <span class="var">?p</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> position_def<span class="main">)</span> <span class="comment1">(* for some reason 'unfolding' does not work here, tested in Isabelle 2021 *)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> assms dual_order.order_iff_strict enat llength_llist_of
               llength_ltake' ltake_llist_of numeral_eq_enat take_all times_enat_simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> lp<span class="main">:</span><span class="quoted"><span class="quoted">"lprefix <span class="main">(</span>llist_of <span class="var">?p</span><span class="main">)</span> <span class="main">(</span>induced_play <span class="free">σ</span> <span class="var">?p</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> induced_play_is_lprefix<span class="main"><span class="main">[</span></span><span class="operator">OF</span> pp<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="comment1">(* this would make a great separate lemma, but we have a conversion between N and its nat
     to make that more involved *)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ltake <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="free">N</span><span class="main">)</span> <span class="main">(</span>llist_of <span class="free">p</span><span class="main">)</span> <span class="main">=</span> ltake <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="free">N</span><span class="main">)</span> <span class="main">(</span>llist_of <span class="main">(</span>take <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="skolem">nat</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> ltake_llist_of<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> enat ltake_ltake numeral_eq_enat <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> eq<span class="main">:</span><span class="quoted"><span class="quoted">"induced_play <span class="free">σ</span> <span class="free">p</span> <span class="main">=</span> induced_play <span class="free">σ</span> <span class="var">?p</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> induced_play_def strategy_progression_def
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lmap_lappend_distrib n<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> ltake_lappend1<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"llist_of <span class="main">(</span>take <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="skolem">nat</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span> <span class="main">=</span> induced_play <span class="free">σ</span> <span class="free">p</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> lprefix_llength_eq_imp_eq<span class="main"><span class="main">[</span></span><span class="operator">OF</span> lp<span class="main"><span class="main">[</span></span><span class="operator">folded</span> eq<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
     <span class="keyword1"><span class="command">unfolding</span></span> enat ltake_llist_of<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="comment1">(* simp applies this one in the wrong direction *)</span>
               numeral_eq_enat times_enat_simps<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> infinity
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="numeral">2</span> <span class="main">*</span> <span class="free">N</span> <span class="main">=</span> <span class="main">∞</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> imult_is_infinity<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="GaleStewartGames-infplays_augment_many_lprefix"><span class="command">lemma</span></span> infplays_augment_many_lprefix<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lprefix <span class="main">(</span>llist_of <span class="main">(</span><span class="main">(</span>augment_list <span class="free">σ</span> <span class="main">^^</span> <span class="free">n</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>induced_play <span class="free">σ</span> <span class="free">p</span><span class="main">)</span>
        <span class="main">=</span> position <span class="main">(</span><span class="main">(</span>augment_list <span class="free">σ</span> <span class="main">^^</span> <span class="free">n</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span>
  <span class="keyword1"><span class="command">from</span></span> lprefix_llength_le<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?rhs</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> induced_play_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>position_def length_augment_list<span class="main">)</span> <span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> assm<span class="main">:</span><span class="var"><span class="quoted"><span class="var">?rhs</span></span></span>
  <span class="keyword1"><span class="command">from</span></span> induced_play_is_lprefix<span class="main">[</span><span class="operator">OF</span> this<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="free">σ</span>"</span></span><span class="main">]</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> induced_play_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹ Winning strategies ›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹ A strategy is winning (in position p) if, no matter the moves by the other player,
       it leads to a sequence in the winning set. ›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">strategy_winning_by_Even</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">strategy_winning_by_Even</span> <span class="free"><span class="bound"><span class="entity">σ<span class="hidden">⇩</span><sub>e</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">σ<span class="hidden">⇩</span><sub>o</sub></span><span class="main">.</span> induced_play <span class="main">(</span>joint_strategy <span class="free"><span class="bound"><span class="entity">σ<span class="hidden">⇩</span><sub>e</sub></span></span></span> <span class="bound">σ<span class="hidden">⇩</span><sub>o</sub></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∈</span> <span class="free">A</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">strategy_winning_by_Odd</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">strategy_winning_by_Odd</span> <span class="free"><span class="bound"><span class="entity">σ<span class="hidden">⇩</span><sub>o</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">σ<span class="hidden">⇩</span><sub>e</sub></span><span class="main">.</span> induced_play <span class="main">(</span>joint_strategy <span class="bound">σ<span class="hidden">⇩</span><sub>e</sub></span> <span class="free"><span class="bound"><span class="entity">σ<span class="hidden">⇩</span><sub>o</sub></span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∉</span> <span class="free">A</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹ It immediately follows that not both players can have a winning strategy. ›</span></span>
<span class="keyword1" id="GaleStewartGames-at_most_one_player_winning"><span class="command">lemma</span></span> at_most_one_player_winning<span class="main">:</span>
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="main">(</span><span class="main">∃</span> <span class="bound">σ<span class="hidden">⇩</span><sub>e</sub></span><span class="main">.</span> strategy_winning_by_Even <span class="bound">σ<span class="hidden">⇩</span><sub>e</sub></span> <span class="free">p</span><span class="main">)</span> <span class="main">∨</span> <span class="main">¬</span> <span class="main">(</span><span class="main">∃</span> <span class="bound">σ<span class="hidden">⇩</span><sub>o</sub></span><span class="main">.</span> strategy_winning_by_Odd <span class="bound">σ<span class="hidden">⇩</span><sub>o</sub></span> <span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> strategy_winning_by_Even_def strategy_winning_by_Odd_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹ If a player whose turn it is not makes any move, winning strategies remain winning.
       All of the following proofs are duplicated for Even and Odd,
       as the game is entirely symmetrical. These 'dual' theorems can be obtained
       by considering a game in which an additional first and final move are played yet ignored,
       but it is quite convenient to have both theorems at hand regardless, and the proofs are
       quite small, so we accept the code duplication. ›</span></span>

<span class="keyword1" id="GaleStewartGames-any_moves_remain_winning_Even"><span class="command">lemma</span></span> any_moves_remain_winning_Even<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"odd <span class="main">(</span>length <span class="free">p</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"strategy_winning_by_Even <span class="free">σ</span> <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"strategy_winning_by_Even <span class="free">σ</span> <span class="main">(</span><span class="free">p</span> <span class="main">@</span> <span class="main">[</span><span class="free">m</span><span class="main">]</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> strategy_winning_by_Even_def <span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">σ<span class="hidden">⇩</span><sub>o</sub></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?s</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="skolem">σ<span class="hidden">⇩</span><sub>o</sub></span><span class="main">(</span><span class="free">p</span><span class="main">:=</span><span class="free">m</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> prfx<span class="main">:</span><span class="quoted"><span class="quoted">"prefix <span class="main">(</span><span class="free">p</span> <span class="main">@</span> <span class="main">[</span><span class="free">m</span><span class="main">]</span><span class="main">)</span> <span class="skolem">p'</span> <span class="main">⟹</span>
             <span class="skolem">p'</span> <span class="main">@</span> <span class="main">[</span>joint_strategy <span class="free">σ</span> <span class="skolem">σ<span class="hidden">⇩</span><sub>o</sub></span> <span class="skolem">p'</span><span class="main">]</span> <span class="main">=</span> <span class="skolem">p'</span> <span class="main">@</span> <span class="main">[</span>joint_strategy <span class="free">σ</span> <span class="var">?s</span> <span class="skolem">p'</span><span class="main">]</span>"</span></span>
    <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">p'</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> joint_strategy_def<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> assms<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">unfolded</span> strategy_winning_by_Even_def<span class="main">,</span><span class="operator">rule_format</span><span class="main">,</span><span class="operator">of</span> <span class="var"><span class="quoted"><span class="var">?s</span></span></span><span class="main">]</span>
       infplays_augment_one_joint<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"induced_play <span class="main">(</span>joint_strategy <span class="free">σ</span> <span class="var">?s</span><span class="main">)</span> <span class="main">(</span>augment_list <span class="var">?s</span> <span class="free">p</span><span class="main">)</span> <span class="main">∈</span> <span class="free">A</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> induced_play_def comp_apply<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"induced_play <span class="main">(</span>joint_strategy <span class="free">σ</span> <span class="skolem">σ<span class="hidden">⇩</span><sub>o</sub></span><span class="main">)</span> <span class="main">(</span><span class="free">p</span> <span class="main">@</span> <span class="main">[</span><span class="free">m</span><span class="main">]</span><span class="main">)</span> <span class="main">∈</span> <span class="free">A</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> induced_play_def o_def
    <span class="keyword1"><span class="command">using</span></span> infplays_eq<span class="main">[</span><span class="operator">OF</span> prfx<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="GaleStewartGames-any_moves_remain_winning_Odd"><span class="command">lemma</span></span> any_moves_remain_winning_Odd<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"even <span class="main">(</span>length <span class="free">p</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"strategy_winning_by_Odd <span class="free">σ</span> <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"strategy_winning_by_Odd <span class="free">σ</span> <span class="main">(</span><span class="free">p</span> <span class="main">@</span> <span class="main">[</span><span class="free">m</span><span class="main">]</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> strategy_winning_by_Odd_def <span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">σ<span class="hidden">⇩</span><sub>e</sub></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?s</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="skolem">σ<span class="hidden">⇩</span><sub>e</sub></span><span class="main">(</span><span class="free">p</span><span class="main">:=</span><span class="free">m</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> prfx<span class="main">:</span><span class="quoted"><span class="quoted">"prefix <span class="main">(</span><span class="free">p</span> <span class="main">@</span> <span class="main">[</span><span class="free">m</span><span class="main">]</span><span class="main">)</span> <span class="skolem">p'</span> <span class="main">⟹</span>
             <span class="skolem">p'</span> <span class="main">@</span> <span class="main">[</span>joint_strategy <span class="skolem">σ<span class="hidden">⇩</span><sub>e</sub></span> <span class="free">σ</span> <span class="skolem">p'</span><span class="main">]</span> <span class="main">=</span> <span class="skolem">p'</span> <span class="main">@</span> <span class="main">[</span>joint_strategy <span class="var">?s</span> <span class="free">σ</span> <span class="skolem">p'</span><span class="main">]</span>"</span></span>
    <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">p'</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>joint_strategy_def<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> assms<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">unfolded</span> strategy_winning_by_Odd_def<span class="main">,</span><span class="operator">rule_format</span><span class="main">,</span><span class="operator">of</span> <span class="var"><span class="quoted"><span class="var">?s</span></span></span><span class="main">]</span>
       infplays_augment_one_joint<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"induced_play <span class="main">(</span>joint_strategy <span class="var">?s</span> <span class="free">σ</span><span class="main">)</span> <span class="main">(</span>augment_list <span class="var">?s</span> <span class="free">p</span><span class="main">)</span> <span class="main">∉</span> <span class="free">A</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> induced_play_def comp_apply<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"induced_play <span class="main">(</span>joint_strategy <span class="skolem">σ<span class="hidden">⇩</span><sub>e</sub></span> <span class="free">σ</span><span class="main">)</span> <span class="main">(</span><span class="free">p</span> <span class="main">@</span> <span class="main">[</span><span class="free">m</span><span class="main">]</span><span class="main">)</span> <span class="main">∉</span> <span class="free">A</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> induced_play_def o_def
    <span class="keyword1"><span class="command">using</span></span> infplays_eq<span class="main">[</span><span class="operator">OF</span> prfx<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹ If a player does not have a winning strategy,
       a move by that player will not give it one. ›</span></span>

<span class="keyword1" id="GaleStewartGames-non_winning_moves_remains_non_winning_Even"><span class="command">lemma</span></span> non_winning_moves_remains_non_winning_Even<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"even <span class="main">(</span>length <span class="free">p</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">σ</span><span class="main">.</span> <span class="main">¬</span> strategy_winning_by_Even <span class="bound">σ</span> <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> strategy_winning_by_Even <span class="free">σ</span> <span class="main">(</span><span class="free">p</span> <span class="main">@</span> <span class="main">[</span><span class="free">m</span><span class="main">]</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> contrapos_nn<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">∃</span></span> <span class="bound"><span class="bound">σ</span></span><span class="main"><span class="main">.</span></span> strategy_winning_by_Even <span class="bound"><span class="bound">σ</span></span> <span class="free"><span class="free">p</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> a<span class="main">:</span><span class="quoted"><span class="quoted">"strategy_winning_by_Even <span class="free">σ</span> <span class="main">(</span><span class="free">p</span> <span class="main">@</span> <span class="main">[</span><span class="free">m</span><span class="main">]</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?s</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="free">σ</span><span class="main">(</span><span class="free">p</span><span class="main">:=</span><span class="free">m</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> prfx<span class="main">:</span><span class="quoted"><span class="quoted">"prefix <span class="main">(</span><span class="free">p</span> <span class="main">@</span> <span class="main">[</span><span class="free">m</span><span class="main">]</span><span class="main">)</span> <span class="skolem">p'</span> <span class="main">⟹</span>
             <span class="skolem">p'</span> <span class="main">@</span> <span class="main">[</span>joint_strategy <span class="free">σ</span> <span class="skolem">σ<span class="hidden">⇩</span><sub>o</sub></span> <span class="skolem">p'</span><span class="main">]</span> <span class="main">=</span> <span class="skolem">p'</span> <span class="main">@</span> <span class="main">[</span>joint_strategy <span class="var">?s</span> <span class="skolem">σ<span class="hidden">⇩</span><sub>o</sub></span> <span class="skolem">p'</span><span class="main">]</span>"</span></span>
    <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">p'</span> <span class="skolem">σ<span class="hidden">⇩</span><sub>o</sub></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>joint_strategy_def<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> a infplays_eq<span class="main">[</span><span class="operator">OF</span> prfx<span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"strategy_winning_by_Even <span class="var">?s</span> <span class="main">(</span><span class="free">p</span> <span class="main">@</span> <span class="main">[</span><span class="free">m</span><span class="main">]</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> strategy_winning_by_Even_def induced_play_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"strategy_winning_by_Even <span class="var">?s</span> <span class="free">p</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> infplays_augment_one_joint<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span> 
    <span class="keyword1"><span class="command">unfolding</span></span> strategy_winning_by_Even_def induced_play_def o_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> fun_upd_same<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">σ</span><span class="main">.</span> strategy_winning_by_Even <span class="bound">σ</span> <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span> <span class="keyword1"><span class="command">next</span></span>
  <span class="keyword1"><span class="command">from</span></span> assms<span class="main">(</span>2<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="main">(</span><span class="main">∃</span> <span class="bound">σ</span><span class="main">.</span> strategy_winning_by_Even <span class="bound">σ</span> <span class="free">p</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">meson</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="GaleStewartGames-non_winning_moves_remains_non_winning_Odd"><span class="command">lemma</span></span> non_winning_moves_remains_non_winning_Odd<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"odd <span class="main">(</span>length <span class="free">p</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">σ</span><span class="main">.</span> <span class="main">¬</span> strategy_winning_by_Odd <span class="bound">σ</span> <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> strategy_winning_by_Odd <span class="free">σ</span> <span class="main">(</span><span class="free">p</span> <span class="main">@</span> <span class="main">[</span><span class="free">m</span><span class="main">]</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> contrapos_nn<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">∃</span></span> <span class="bound"><span class="bound">σ</span></span><span class="main"><span class="main">.</span></span> strategy_winning_by_Odd <span class="bound"><span class="bound">σ</span></span> <span class="free"><span class="free">p</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> a<span class="main">:</span><span class="quoted"><span class="quoted">"strategy_winning_by_Odd <span class="free">σ</span> <span class="main">(</span><span class="free">p</span> <span class="main">@</span> <span class="main">[</span><span class="free">m</span><span class="main">]</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?s</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="free">σ</span><span class="main">(</span><span class="free">p</span><span class="main">:=</span><span class="free">m</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> prfx<span class="main">:</span><span class="quoted"><span class="quoted">"prefix <span class="main">(</span><span class="free">p</span> <span class="main">@</span> <span class="main">[</span><span class="free">m</span><span class="main">]</span><span class="main">)</span> <span class="skolem">p'</span> <span class="main">⟹</span>
             <span class="skolem">p'</span> <span class="main">@</span> <span class="main">[</span>joint_strategy <span class="skolem">σ<span class="hidden">⇩</span><sub>e</sub></span> <span class="free">σ</span> <span class="skolem">p'</span><span class="main">]</span> <span class="main">=</span> <span class="skolem">p'</span> <span class="main">@</span> <span class="main">[</span>joint_strategy <span class="skolem">σ<span class="hidden">⇩</span><sub>e</sub></span> <span class="var">?s</span> <span class="skolem">p'</span><span class="main">]</span>"</span></span>
    <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">p'</span> <span class="skolem">σ<span class="hidden">⇩</span><sub>e</sub></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>joint_strategy_def<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> a infplays_eq<span class="main">[</span><span class="operator">OF</span> prfx<span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"strategy_winning_by_Odd <span class="var">?s</span> <span class="main">(</span><span class="free">p</span> <span class="main">@</span> <span class="main">[</span><span class="free">m</span><span class="main">]</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> strategy_winning_by_Odd_def induced_play_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"strategy_winning_by_Odd <span class="var">?s</span> <span class="free">p</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> infplays_augment_one_joint<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span> 
    <span class="keyword1"><span class="command">unfolding</span></span> strategy_winning_by_Odd_def induced_play_def o_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> fun_upd_same<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">σ</span><span class="main">.</span> strategy_winning_by_Odd <span class="bound">σ</span> <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span> <span class="keyword1"><span class="command">next</span></span>
  <span class="keyword1"><span class="command">from</span></span> assms<span class="main">(</span>2<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="main">(</span><span class="main">∃</span> <span class="bound">σ</span><span class="main">.</span> strategy_winning_by_Odd <span class="bound">σ</span> <span class="free">p</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">meson</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹ If a player whose turn it is makes a move according to its stragey,
       the new position will remain winning. ›</span></span>

<span class="keyword1" id="GaleStewartGames-winning_moves_remain_winning_Even"><span class="command">lemma</span></span> winning_moves_remain_winning_Even<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"even <span class="main">(</span>length <span class="free">p</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"strategy_winning_by_Even <span class="free">σ</span> <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"strategy_winning_by_Even <span class="free">σ</span> <span class="main">(</span><span class="free">p</span> <span class="main">@</span> <span class="main">[</span><span class="free">σ</span> <span class="free">p</span><span class="main">]</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms infplays_augment_one
<span class="keyword1"><span class="command">unfolding</span></span> induced_play_def strategy_winning_by_Even_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="GaleStewartGames-winning_moves_remain_winning_Odd"><span class="command">lemma</span></span> winning_moves_remain_winning_Odd<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"odd <span class="main">(</span>length <span class="free">p</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"strategy_winning_by_Odd <span class="free">σ</span> <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"strategy_winning_by_Odd <span class="free">σ</span> <span class="main">(</span><span class="free">p</span> <span class="main">@</span> <span class="main">[</span><span class="free">σ</span> <span class="free">p</span><span class="main">]</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms infplays_augment_one
<span class="keyword1"><span class="command">unfolding</span></span> induced_play_def strategy_winning_by_Odd_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹ We speak of winning positions as those positions in which the player has a winning strategy.
       This is mainly for presentation purposes. ›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">winning_position_Even</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">winning_position_Even</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span> position <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∧</span> <span class="main">(</span><span class="main">∃</span> <span class="bound">σ</span><span class="main">.</span> strategy_winning_by_Even <span class="bound">σ</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">winning_position_Odd</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">winning_position_Odd</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span> position <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∧</span> <span class="main">(</span><span class="main">∃</span> <span class="bound">σ</span><span class="main">.</span> strategy_winning_by_Odd <span class="bound">σ</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="GaleStewartGames-winning_position_can_remain_winning_Even"><span class="command">lemma</span></span> winning_position_can_remain_winning_Even<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"even <span class="main">(</span>length <span class="free">p</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">m</span><span class="main">.</span> position <span class="main">(</span><span class="free">p</span> <span class="main">@</span> <span class="main">[</span><span class="bound">m</span><span class="main">]</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"winning_position_Even <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">m</span><span class="main">.</span> winning_position_Even <span class="main">(</span><span class="free">p</span> <span class="main">@</span> <span class="main">[</span><span class="bound">m</span><span class="main">]</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms winning_moves_remain_winning_Even<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="GaleStewartGames-winning_position_can_remain_winning_Odd"><span class="command">lemma</span></span> winning_position_can_remain_winning_Odd<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"odd <span class="main">(</span>length <span class="free">p</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">m</span><span class="main">.</span> position <span class="main">(</span><span class="free">p</span> <span class="main">@</span> <span class="main">[</span><span class="bound">m</span><span class="main">]</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"winning_position_Odd <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">m</span><span class="main">.</span> winning_position_Odd <span class="main">(</span><span class="free">p</span> <span class="main">@</span> <span class="main">[</span><span class="bound">m</span><span class="main">]</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms winning_moves_remain_winning_Odd<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="GaleStewartGames-winning_position_will_remain_winning_Even"><span class="command">lemma</span></span> winning_position_will_remain_winning_Even<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"odd <span class="main">(</span>length <span class="free">p</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"position <span class="main">(</span><span class="free">p</span> <span class="main">@</span> <span class="main">[</span><span class="free">m</span><span class="main">]</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"winning_position_Even <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"winning_position_Even <span class="main">(</span><span class="free">p</span> <span class="main">@</span> <span class="main">[</span><span class="free">m</span><span class="main">]</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms any_moves_remain_winning_Even<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="GaleStewartGames-winning_position_will_remain_winning_Odd"><span class="command">lemma</span></span> winning_position_will_remain_winning_Odd<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"even <span class="main">(</span>length <span class="free">p</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"position <span class="main">(</span><span class="free">p</span> <span class="main">@</span> <span class="main">[</span><span class="free">m</span><span class="main">]</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"winning_position_Odd <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"winning_position_Odd <span class="main">(</span><span class="free">p</span> <span class="main">@</span> <span class="main">[</span><span class="free">m</span><span class="main">]</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms any_moves_remain_winning_Odd<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="GaleStewartGames-induced_play_eq"><span class="command">lemma</span></span> induced_play_eq<span class="main">:</span>
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">p'</span><span class="main">.</span> prefix <span class="free">p</span> <span class="bound">p'</span> <span class="main">⟶</span> <span class="main">(</span>augment_list <span class="free">s1</span><span class="main">)</span> <span class="bound">p'</span> <span class="main">=</span> <span class="main">(</span>augment_list <span class="free">s2</span><span class="main">)</span> <span class="bound">p'</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"induced_play <span class="free">s1</span> <span class="free">p</span> <span class="main">=</span> induced_play <span class="free">s2</span> <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> induced_play_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>infplays_eq<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">rule_format</span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="GaleStewartDefensiveStrategies">
<div class="head">
<h1>Theory GaleStewartDefensiveStrategies</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Defensive strategies›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹ A strategy is defensive if a player can avoid reaching winning positions.
       If the opponent is not already in a winning position, such defensive strategies exist.
       In closed games, a defensive strategy is winning for the closed player,
       so these strategies are a crucial step towards proving that such games are determined.
        ›</span></span>
<span class="keyword1"><span class="command">theory</span></span> GaleStewartDefensiveStrategies
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="GaleStewartGames.html">GaleStewartGames</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">context</span></span> GSgame
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">move_defensive_by_Even</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">move_defensive_by_Even</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span> even <span class="main">(</span>length <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="main">⟶</span> <span class="main">¬</span> winning_position_Odd <span class="main">(</span><span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">@</span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">]</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">move_defensive_by_Odd</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">move_defensive_by_Odd</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span>  <span class="main">≡</span> odd <span class="main">(</span>length <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="main">⟶</span> <span class="main">¬</span> winning_position_Even <span class="main">(</span><span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">@</span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">]</span><span class="main">)</span>"</span></span>

<span class="comment1">(* This was a tricky part of the proof, it required explicit use of the choice theorem *)</span>
<span class="keyword1" id="GaleStewartDefensiveStrategies-defensive_move_exists_for_Even"><span class="command">lemma</span></span> defensive_move_exists_for_Even<span class="main">:</span>
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span><span class="quoted"><span class="quoted">"position <span class="free">p</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"winning_position_Odd <span class="free">p</span> <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span> <span class="bound">m</span><span class="main">.</span> move_defensive_by_Even <span class="bound">m</span> <span class="free">p</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?w</span> <span class="main">∨</span> <span class="var">?d</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"length <span class="free">p</span> <span class="main">=</span> <span class="numeral">2</span><span class="main">*</span><span class="free">N</span> <span class="main">∨</span> odd <span class="main">(</span>length <span class="free">p</span><span class="main">)</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword1"><span class="command">hence</span></span> pl<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span><span class="quoted"><span class="quoted">"length <span class="free">p</span> <span class="main">&lt;</span> <span class="numeral">2</span><span class="main">*</span><span class="free">N</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> ev<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span><span class="quoted"><span class="quoted">"even <span class="main">(</span>length <span class="free">p</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">[</span><span class="operator">unfolded</span> position_def<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> impI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">¬</span></span> <span class="var"><span class="var">?d</span></span> <span class="main"><span class="main">⟶</span></span> <span class="main"><span class="main">¬</span></span> <span class="var"><span class="var">?w</span></span> <span class="main"><span class="main">⟶</span></span> False"</span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">rule_format</span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">force</span><span class="main">)</span>
    <span class="keyword3"><span class="command">assume</span></span> not_def<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="var">?d</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> not_def<span class="main">[</span><span class="operator">unfolded</span> move_defensive_by_Even_def<span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">m</span><span class="main">.</span> <span class="main">∃</span><span class="bound">σ</span><span class="main">.</span> strategy_winning_by_Odd <span class="bound">σ</span> <span class="main">(</span><span class="free">p</span> <span class="main">@</span> <span class="main">[</span><span class="bound">m</span><span class="main">]</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">from</span></span> choice<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">σ<span class="hidden">⇩</span><sub>o</sub></span></span> <span class="keyword2"><span class="keyword">where</span></span>
      str_Odd<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">m</span><span class="main">.</span> strategy_winning_by_Odd <span class="main">(</span><span class="skolem">σ<span class="hidden">⇩</span><sub>o</sub></span> <span class="bound">m</span><span class="main">)</span> <span class="main">(</span><span class="free">p</span> <span class="main">@</span> <span class="main">[</span><span class="bound">m</span><span class="main">]</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">σ</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">σ</span> <span class="skolem">p'</span> <span class="main">=</span> <span class="skolem">σ<span class="hidden">⇩</span><sub>o</sub></span> <span class="main">(</span><span class="skolem">p'</span> <span class="main">!</span> length <span class="free">p</span><span class="main">)</span> <span class="skolem">p'</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">p'</span>
    <span class="keyword3"><span class="command">assume</span></span> not_win<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="var">?w</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> not_win<span class="main">[</span><span class="operator">unfolded</span> move_defensive_by_Even_def strategy_winning_by_Odd_def<span class="main">]</span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">σ<span class="hidden">⇩</span><sub>e</sub></span></span> <span class="keyword2"><span class="keyword">where</span></span>
      str_Even<span class="main">:</span><span class="quoted"><span class="quoted">"induced_play <span class="main">(</span>joint_strategy <span class="skolem">σ<span class="hidden">⇩</span><sub>e</sub></span> <span class="skolem">σ</span><span class="main">)</span> <span class="free">p</span> <span class="main">∈</span> <span class="free">A</span>"</span></span>
      <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?pe</span> <span class="free">p</span> <span class="main">∈</span> <span class="free">A</span>"</span></span><span class="main">)</span>
           <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?pnext</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">@</span> <span class="main">[</span>joint_strategy <span class="skolem">σ<span class="hidden">⇩</span><sub>e</sub></span> <span class="skolem">σ</span> <span class="free">p</span><span class="main">]</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">p'</span> <span class="skolem">m</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"prefix <span class="main">(</span><span class="free">p</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">m</span><span class="main">]</span><span class="main">)</span> <span class="skolem">p'</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">p'</span> <span class="main">!</span> length <span class="free">p</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">m</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> prefix_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">hence</span></span> eq_a<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">p'</span><span class="main">.</span> prefix <span class="var">?pnext</span> <span class="bound">p'</span> <span class="main">⟶</span> <span class="bound">p'</span> <span class="main">@</span> <span class="main">[</span>joint_strategy <span class="skolem">σ<span class="hidden">⇩</span><sub>e</sub></span> <span class="skolem">σ</span> <span class="bound">p'</span><span class="main">]</span> <span class="main">=</span>
                                    <span class="bound">p'</span> <span class="main">@</span> <span class="main">[</span>joint_strategy <span class="skolem">σ<span class="hidden">⇩</span><sub>e</sub></span> <span class="main">(</span><span class="skolem">σ<span class="hidden">⇩</span><sub>o</sub></span> <span class="main">(</span>joint_strategy <span class="skolem">σ<span class="hidden">⇩</span><sub>e</sub></span> <span class="skolem">σ</span> <span class="free">p</span><span class="main">)</span><span class="main">)</span> <span class="bound">p'</span><span class="main">]</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> joint_strategy_def σ_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> simps<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="var">?pe</span> <span class="free">p</span> <span class="main">=</span> <span class="var">?pe</span> <span class="main">(</span><span class="free">p</span> <span class="main">@</span> <span class="main">[</span>joint_strategy <span class="skolem">σ<span class="hidden">⇩</span><sub>e</sub></span> <span class="skolem">σ</span> <span class="free">p</span><span class="main">]</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> induced_play_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> str_Even str_Odd<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"joint_strategy <span class="skolem">σ<span class="hidden">⇩</span><sub>e</sub></span> <span class="skolem">σ</span> <span class="free">p</span>"</span></span><span class="main">,</span> <span class="operator">unfolded</span> strategy_winning_by_Odd_def<span class="main">,</span> <span class="operator">rule_format</span><span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="skolem">σ<span class="hidden">⇩</span><sub>e</sub></span>"</span></span><span class="main">]</span>
         induced_play_eq<span class="main">[</span><span class="operator">OF</span> eq_a<span class="main">]</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">unfolding</span></span> simps <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> move_defensive_by_Even_def strategy_winning_by_Even_def position_maxlength_cannotbe_augmented<span class="main">)</span>

<span class="comment1">(* This is a repetition of the proof for defensive_move_exists_for_Even *)</span>
<span class="keyword1" id="GaleStewartDefensiveStrategies-defensive_move_exists_for_Odd"><span class="command">lemma</span></span> defensive_move_exists_for_Odd<span class="main">:</span>
<span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span><span class="quoted"><span class="quoted">"position <span class="free">p</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"winning_position_Even <span class="free">p</span> <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span> <span class="bound">m</span><span class="main">.</span> move_defensive_by_Odd <span class="bound">m</span> <span class="free">p</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?w</span> <span class="main">∨</span> <span class="var">?d</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"length <span class="free">p</span> <span class="main">=</span> <span class="numeral">2</span><span class="main">*</span><span class="free">N</span> <span class="main">∨</span> even <span class="main">(</span>length <span class="free">p</span><span class="main">)</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword1"><span class="command">hence</span></span> pl<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span><span class="quoted"><span class="quoted">"length <span class="free">p</span> <span class="main">&lt;</span> <span class="numeral">2</span><span class="main">*</span><span class="free">N</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> ev<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span><span class="quoted"><span class="quoted">"odd <span class="main">(</span>length <span class="free">p</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">[</span><span class="operator">unfolded</span> position_def<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> impI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">¬</span></span> <span class="var"><span class="var">?d</span></span> <span class="main"><span class="main">⟶</span></span> <span class="main"><span class="main">¬</span></span> <span class="var"><span class="var">?w</span></span> <span class="main"><span class="main">⟶</span></span> False"</span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">rule_format</span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">force</span><span class="main">)</span>
    <span class="keyword3"><span class="command">assume</span></span> not_def<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="var">?d</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> not_def<span class="main">[</span><span class="operator">unfolded</span> move_defensive_by_Odd_def<span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">m</span><span class="main">.</span> <span class="main">∃</span><span class="bound">σ</span><span class="main">.</span> strategy_winning_by_Even <span class="bound">σ</span> <span class="main">(</span><span class="free">p</span> <span class="main">@</span> <span class="main">[</span><span class="bound">m</span><span class="main">]</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">from</span></span> choice<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">σ<span class="hidden">⇩</span><sub>e</sub></span></span> <span class="keyword2"><span class="keyword">where</span></span>
      str_Even<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">m</span><span class="main">.</span> strategy_winning_by_Even <span class="main">(</span><span class="skolem">σ<span class="hidden">⇩</span><sub>e</sub></span> <span class="bound">m</span><span class="main">)</span> <span class="main">(</span><span class="free">p</span> <span class="main">@</span> <span class="main">[</span><span class="bound">m</span><span class="main">]</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">σ</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">σ</span> <span class="skolem">p'</span> <span class="main">=</span> <span class="skolem">σ<span class="hidden">⇩</span><sub>e</sub></span> <span class="main">(</span><span class="skolem">p'</span> <span class="main">!</span> length <span class="free">p</span><span class="main">)</span> <span class="skolem">p'</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">p'</span>
    <span class="keyword3"><span class="command">assume</span></span> not_win<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="var">?w</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> not_win<span class="main">[</span><span class="operator">unfolded</span> move_defensive_by_Odd_def strategy_winning_by_Even_def<span class="main">]</span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">σ<span class="hidden">⇩</span><sub>o</sub></span></span> <span class="keyword2"><span class="keyword">where</span></span>
      str_Odd<span class="main">:</span><span class="quoted"><span class="quoted">"induced_play <span class="main">(</span>joint_strategy <span class="skolem">σ</span> <span class="skolem">σ<span class="hidden">⇩</span><sub>o</sub></span><span class="main">)</span> <span class="free">p</span> <span class="main">∉</span> <span class="free">A</span>"</span></span>
      <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?pe</span> <span class="free">p</span> <span class="main">∉</span> <span class="free">A</span>"</span></span><span class="main">)</span>
           <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?strat</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"joint_strategy <span class="skolem">σ</span> <span class="skolem">σ<span class="hidden">⇩</span><sub>o</sub></span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?pnext</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">@</span> <span class="main">[</span><span class="var">?strat</span> <span class="free">p</span><span class="main">]</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">p'</span> <span class="skolem">m</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"prefix <span class="main">(</span><span class="free">p</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">m</span><span class="main">]</span><span class="main">)</span> <span class="skolem">p'</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">p'</span> <span class="main">!</span> length <span class="free">p</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">m</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> prefix_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">hence</span></span> eq_a<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">p'</span><span class="main">.</span> prefix <span class="var">?pnext</span> <span class="bound">p'</span> <span class="main">⟶</span> <span class="bound">p'</span> <span class="main">@</span> <span class="main">[</span><span class="var">?strat</span> <span class="bound">p'</span><span class="main">]</span> <span class="main">=</span>
                                    <span class="bound">p'</span> <span class="main">@</span> <span class="main">[</span>joint_strategy <span class="main">(</span><span class="skolem">σ<span class="hidden">⇩</span><sub>e</sub></span> <span class="main">(</span><span class="var">?strat</span> <span class="free">p</span><span class="main">)</span><span class="main">)</span> <span class="skolem">σ<span class="hidden">⇩</span><sub>o</sub></span> <span class="bound">p'</span><span class="main">]</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> joint_strategy_def σ_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> simps<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="var">?pe</span> <span class="free">p</span> <span class="main">=</span> <span class="var">?pe</span> <span class="main">(</span><span class="free">p</span> <span class="main">@</span> <span class="main">[</span><span class="var">?strat</span> <span class="free">p</span><span class="main">]</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> induced_play_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> str_Odd str_Even<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="var">?strat</span> <span class="free">p</span>"</span></span><span class="main">,</span> <span class="operator">unfolded</span> strategy_winning_by_Even_def<span class="main">,</span> <span class="operator">rule_format</span><span class="main">]</span>
         induced_play_eq<span class="main">[</span><span class="operator">OF</span> eq_a<span class="main">]</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">unfolding</span></span> simps <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> move_defensive_by_Odd_def strategy_winning_by_Odd_def position_maxlength_cannotbe_augmented<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">defensive_strategy_Even</span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">defensive_strategy_Even</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span> <span class="keyword1">SOME</span> <span class="bound">m</span><span class="main">.</span> move_defensive_by_Even <span class="bound">m</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">defensive_strategy_Odd</span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">defensive_strategy_Odd</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span> <span class="keyword1">SOME</span> <span class="bound">m</span><span class="main">.</span> move_defensive_by_Odd <span class="bound">m</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span>"</span></span>

<span class="keyword1" id="GaleStewartDefensiveStrategies-position_augment"><span class="command">lemma</span></span> position_augment<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"position <span class="main">(</span><span class="main">(</span>augment_list <span class="free">f</span> <span class="main">^^</span> <span class="free">n</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"position <span class="free">p</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms length_augment_list<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">n</span></span> <span class="quoted"><span class="free">f</span></span> <span class="quoted"><span class="free">p</span></span><span class="main">]</span> <span class="keyword1"><span class="command">unfolding</span></span> position_def
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1" id="GaleStewartDefensiveStrategies-defensive_strategy_Odd"><span class="command">lemma</span></span> defensive_strategy_Odd<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> winning_position_Even <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> winning_position_Even <span class="main">(</span><span class="main">(</span><span class="main">(</span>augment_list <span class="main">(</span>joint_strategy <span class="free">σ<span class="hidden">⇩</span><sub>e</sub></span> defensive_strategy_Odd<span class="main">)</span><span class="main">)</span> <span class="main">^^</span> <span class="free">n</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span><span class="quoted"><span class="free">p</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"position <span class="skolem">p</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True
      <span class="keyword1"><span class="command">from</span></span> Suc.prems defensive_move_exists_for_Odd<span class="main">[</span><span class="operator">OF</span> True<span class="main">]</span> defensive_strategy_Odd_def someI
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"move_defensive_by_Odd <span class="main">(</span>defensive_strategy_Odd <span class="skolem">p</span><span class="main">)</span> <span class="skolem">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
      <span class="keyword1"><span class="command">from</span></span> this<span class="main">[</span><span class="operator">unfolded</span> move_defensive_by_Odd_def<span class="main">]</span> Suc.prems
           non_winning_moves_remains_non_winning_Even<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">p</span></span><span class="main">]</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> winning_position_Even <span class="main">(</span><span class="skolem">p</span> <span class="main">@</span> <span class="main">[</span>joint_strategy <span class="free">σ<span class="hidden">⇩</span><sub>e</sub></span> defensive_strategy_Odd <span class="skolem">p</span><span class="main">]</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>  joint_strategy_def True<span class="main">)</span> 
      <span class="keyword1"><span class="command">with</span></span> Suc.hyps<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">@</span> <span class="main">[</span>joint_strategy <span class="free">σ<span class="hidden">⇩</span><sub>e</sub></span> defensive_strategy_Odd <span class="skolem">p</span><span class="main">]</span>"</span></span><span class="main">]</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> funpow_Suc_right comp_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">insert</span> position_augment<span class="main"><span class="keyword3">,</span></span><span class="operator">blast</span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="GaleStewartDefensiveStrategies-defensive_strategy_Even"><span class="command">lemma</span></span> defensive_strategy_Even<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> winning_position_Odd <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> winning_position_Odd <span class="main">(</span><span class="main">(</span><span class="main">(</span>augment_list <span class="main">(</span>joint_strategy defensive_strategy_Even <span class="free">σ<span class="hidden">⇩</span><sub>o</sub></span><span class="main">)</span><span class="main">)</span> <span class="main">^^</span> <span class="free">n</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span><span class="quoted"><span class="free">p</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"position <span class="skolem">p</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True
      <span class="keyword1"><span class="command">from</span></span> Suc.prems defensive_move_exists_for_Even<span class="main">[</span><span class="operator">OF</span> True<span class="main">]</span> defensive_strategy_Even_def someI
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"move_defensive_by_Even <span class="main">(</span>defensive_strategy_Even <span class="skolem">p</span><span class="main">)</span> <span class="skolem">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
      <span class="keyword1"><span class="command">from</span></span> this<span class="main">[</span><span class="operator">unfolded</span> move_defensive_by_Even_def<span class="main">]</span> Suc.prems
           non_winning_moves_remains_non_winning_Odd<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">p</span></span><span class="main">]</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> winning_position_Odd <span class="main">(</span><span class="skolem">p</span> <span class="main">@</span> <span class="main">[</span>joint_strategy defensive_strategy_Even <span class="free">σ<span class="hidden">⇩</span><sub>o</sub></span> <span class="skolem">p</span><span class="main">]</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> joint_strategy_def True<span class="main">)</span> 
      <span class="keyword1"><span class="command">with</span></span> Suc.hyps<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">@</span> <span class="main">[</span>joint_strategy defensive_strategy_Even <span class="free">σ<span class="hidden">⇩</span><sub>o</sub></span> <span class="skolem">p</span><span class="main">]</span>"</span></span><span class="main">]</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> funpow_Suc_right comp_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">insert</span> position_augment<span class="main"><span class="keyword3">,</span></span><span class="operator">blast</span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> closed_GSgame <span class="main">=</span> GSgame <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> closed<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="free">e</span> <span class="main">∈</span> <span class="free">A</span> <span class="main">⟹</span> <span class="main">∃</span> <span class="bound">p</span><span class="main">.</span> lprefix <span class="main">(</span>llist_of <span class="bound">p</span><span class="main">)</span> <span class="free">e</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">e'</span><span class="main">.</span> lprefix <span class="main">(</span>llist_of <span class="bound">p</span><span class="main">)</span> <span class="bound">e'</span> <span class="main">⟶</span> llength <span class="bound">e'</span> <span class="main">=</span> <span class="numeral">2</span><span class="main">*</span><span class="free">N</span> <span class="main">⟶</span> <span class="bound">e'</span> <span class="main">∈</span> <span class="free">A</span><span class="main">)</span>"</span></span>

<span class="comment1">(* Perhaps a misnomer, GSgames are supposed to be infinite ... *)</span>
<span class="keyword1"><span class="command">locale</span></span> finite_GSgame <span class="main">=</span> GSgame <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> fin<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="free">N</span> <span class="main">≠</span> <span class="main">∞</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹ Finite games are closed games. As a corollary to the GS theorem, this lets us conclude that finite games are determined. ›</span></span>
<span class="keyword1"><span class="command">sublocale</span></span> closed_GSgame
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">e</span> <span class="keyword3"><span class="command">assume</span></span> eA<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">e</span> <span class="main">∈</span> <span class="free">A</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?p</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"list_of <span class="skolem">e</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> eA <span class="keyword1"><span class="command">have</span></span> len<span class="main">:</span><span class="quoted"><span class="quoted">"llength <span class="skolem">e</span> <span class="main">=</span> <span class="numeral">2</span><span class="main">*</span><span class="free">N</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> length <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">with</span></span> fin <span class="keyword1"><span class="command">have</span></span> p<span class="main">:</span><span class="quoted"><span class="quoted">"llist_of <span class="var">?p</span> <span class="main">=</span> <span class="skolem">e</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> llist_of_list_of mult_2 not_lfinite_llength plus_eq_infty_iff_enat<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> pfx<span class="main">:</span><span class="quoted"><span class="quoted">"lprefix <span class="main">(</span>llist_of <span class="var">?p</span><span class="main">)</span> <span class="skolem">e</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">e'</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"lprefix <span class="main">(</span>llist_of <span class="var">?p</span><span class="main">)</span> <span class="skolem">e'</span>"</span></span> <span class="quoted"><span class="quoted">"llength <span class="skolem">e'</span> <span class="main">=</span> <span class="numeral">2</span> <span class="main">*</span> <span class="free">N</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">e'</span> <span class="main">=</span> <span class="skolem">e</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> len <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> lprefix_llength_eq_imp_eq p<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> eA <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">e'</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">with</span></span> pfx <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">p</span><span class="main">.</span> lprefix <span class="main">(</span>llist_of <span class="bound">p</span><span class="main">)</span> <span class="skolem">e</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">e'</span><span class="main">.</span> lprefix <span class="main">(</span>llist_of <span class="bound">p</span><span class="main">)</span> <span class="bound">e'</span> <span class="main">⟶</span> llength <span class="bound">e'</span> <span class="main">=</span> <span class="numeral">2</span> <span class="main">*</span> <span class="free">N</span> <span class="main">⟶</span> <span class="bound">e'</span> <span class="main">∈</span> <span class="free">A</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> closed_GSgame <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1" id="GaleStewartDefensiveStrategies-never_winning_is_losing_even"><span class="command">lemma</span></span> never_winning_is_losing_even<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"position <span class="free">p</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">n</span><span class="main">.</span> <span class="main">¬</span> winning_position_Even <span class="main">(</span><span class="main">(</span><span class="main">(</span>augment_list <span class="free">σ</span><span class="main">)</span> <span class="main">^^</span> <span class="bound">n</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"induced_play <span class="free">σ</span> <span class="free">p</span> <span class="main">∉</span> <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"induced_play <span class="free">σ</span> <span class="free">p</span> <span class="main">∈</span> <span class="free">A</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> closed<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p'</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    p'<span class="main">:</span><span class="quoted"><span class="quoted">"lprefix <span class="main">(</span>llist_of <span class="skolem">p'</span><span class="main">)</span> <span class="main">(</span>induced_play <span class="free">σ</span> <span class="free">p</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">e</span><span class="main">.</span> lprefix <span class="main">(</span>llist_of <span class="skolem">p'</span><span class="main">)</span> <span class="bound">e</span> <span class="main">⟹</span> llength <span class="bound">e</span> <span class="main">=</span> <span class="numeral">2</span> <span class="main">*</span> <span class="free">N</span> <span class="main">⟹</span> <span class="bound">e</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">from</span></span> lprefix_llength_le<span class="main">[</span><span class="operator">OF</span> p'<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> lp'<span class="main">:</span><span class="quoted"><span class="quoted">"llength <span class="main">(</span>llist_of <span class="skolem">p'</span><span class="main">)</span> <span class="main">≤</span> <span class="numeral">2</span> <span class="main">*</span> <span class="free">N</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"length <span class="skolem">p'</span> <span class="main">≤</span> length <span class="free">p</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"llength <span class="main">(</span>llist_of <span class="skolem">p'</span><span class="main">)</span> <span class="main">≤</span> llength <span class="main">(</span>llist_of <span class="free">p</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> lprefix_llength_lprefix<span class="main">[</span><span class="operator">OF</span> p'<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> _ this<span class="main">]</span>
      induced_play_is_lprefix<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span>
      lprefix_trans
    <span class="keyword1"><span class="command">have</span></span> pref<span class="main">:</span><span class="quoted"><span class="quoted">"lprefix <span class="main">(</span>llist_of <span class="skolem">p'</span><span class="main">)</span> <span class="main">(</span>induced_play <span class="skolem">strat</span> <span class="free">p</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">strat</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">from</span></span> assms<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">rule_format</span><span class="main">,</span><span class="operator">of</span> <span class="quoted"><span class="main">0</span></span><span class="main">]</span> assms<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> strategy_winning_by_Even <span class="skolem">σ</span> <span class="free">p</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">σ</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> this<span class="main">[</span><span class="operator">unfolded</span> strategy_winning_by_Even_def<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">strat</span></span> <span class="keyword2"><span class="keyword">where</span></span>
      strat<span class="main">:</span><span class="quoted"><span class="quoted">"induced_play <span class="skolem">strat</span> <span class="free">p</span> <span class="main">∉</span> <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> strat p'<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> pref<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?n</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"length <span class="skolem">p'</span> <span class="main">-</span> length <span class="free">p</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?pos</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>augment_list <span class="free">σ</span> <span class="main">^^</span> <span class="var">?n</span><span class="main">)</span> <span class="free">p</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> False <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"length <span class="skolem">p'</span> <span class="main">≥</span> length <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span><span class="quoted"><span class="quoted">"length <span class="var">?pos</span> <span class="main">=</span> length <span class="skolem">p'</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>length_augment_list<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> pos<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span><span class="quoted"><span class="quoted">"position <span class="var">?pos</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> False lp'<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> position_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"llist_of <span class="skolem">p'</span> <span class="main">=</span> llist_of <span class="var">?pos</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> p'<span class="main">(</span>1<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro</span> lprefix_antisym<span class="main"><span class="main">[</span></span><span class="operator">OF</span> lprefix_llength_lprefix lprefix_llength_lprefix<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span><span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> p'_pos<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">p'</span> <span class="main">=</span> <span class="var">?pos</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> assms<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">rule_format</span><span class="main">,</span><span class="operator">of</span> <span class="var"><span class="quoted"><span class="var">?n</span></span></span><span class="main">]</span> assms<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> strategy_winning_by_Even <span class="skolem">σ</span> <span class="var">?pos</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">σ</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> this<span class="main">[</span><span class="operator">unfolded</span> strategy_winning_by_Even_def<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">strat</span></span> <span class="keyword2"><span class="keyword">where</span></span>
      strat<span class="main">:</span><span class="quoted"><span class="quoted">"induced_play <span class="skolem">strat</span> <span class="var">?pos</span> <span class="main">∉</span> <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> p'_pos induced_play_is_lprefix<span class="main">[</span><span class="operator">OF</span> pos<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="skolem">strat</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> pref<span class="main">:</span><span class="quoted"><span class="quoted">"lprefix <span class="main">(</span>llist_of <span class="skolem">p'</span><span class="main">)</span> <span class="main">(</span>induced_play <span class="skolem">strat</span> <span class="var">?pos</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">with</span></span> p'<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> pref<span class="main">]</span> strat <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="GaleStewartDefensiveStrategies-every_position_is_determined"><span class="command">lemma</span></span> every_position_is_determined<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"position <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"winning_position_Even <span class="free">p</span> <span class="main">∨</span> winning_position_Odd <span class="free">p</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?we</span> <span class="main">∨</span> <span class="var">?wo</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> impI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">¬</span></span> <span class="var"><span class="var">?we</span></span> <span class="main"><span class="main">⟶</span></span> <span class="main"><span class="main">¬</span></span> <span class="var"><span class="var">?wo</span></span> <span class="main"><span class="main">⟶</span></span> False"</span></span></span><span class="main"><span class="main">,</span></span><span class="operator">rule_format</span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">force</span><span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="var">?we</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> defensive_strategy_Odd<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> never_winning_is_losing_even<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> js_no<span class="main">:</span><span class="quoted"><span class="quoted">"induced_play
         <span class="main">(</span>joint_strategy <span class="skolem">s</span> defensive_strategy_Odd<span class="main">)</span> <span class="free">p</span> <span class="main">∉</span> <span class="free">A</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">s</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="var">?wo</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> this<span class="main">[</span><span class="operator">unfolded</span> strategy_winning_by_Odd_def<span class="main">]</span> assms
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">s</span><span class="main">.</span> induced_play
         <span class="main">(</span>joint_strategy <span class="bound">s</span> defensive_strategy_Odd<span class="main">)</span> <span class="free">p</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> js_no <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="GaleStewartDeterminedGames">
<div class="head">
<h1>Theory GaleStewartDeterminedGames</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Determined games›</span></span>

<span class="keyword1"><span class="command">theory</span></span> GaleStewartDeterminedGames
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="GaleStewartDefensiveStrategies.html">GaleStewartDefensiveStrategies</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">locale</span></span> closed_GSgame <span class="main">=</span> GSgame <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> closed<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="free">e</span> <span class="main">∈</span> <span class="free">A</span> <span class="main">⟹</span> <span class="main">∃</span> <span class="bound">p</span><span class="main">.</span> lprefix <span class="main">(</span>llist_of <span class="bound">p</span><span class="main">)</span> <span class="free">e</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">e'</span><span class="main">.</span> lprefix <span class="main">(</span>llist_of <span class="bound">p</span><span class="main">)</span> <span class="bound">e'</span> <span class="main">⟶</span> llength <span class="bound">e'</span> <span class="main">=</span> <span class="numeral">2</span><span class="main">*</span><span class="free">N</span> <span class="main">⟶</span> <span class="bound">e'</span> <span class="main">∈</span> <span class="free">A</span><span class="main">)</span>"</span></span>

<span class="comment1">(* Perhaps a misnomer, GSgames are supposed to be infinite, but this is very much the GS variation
   of finite games, as definitions still use coinductive lists rather than the more common
   inductive (and finite) ones. *)</span>
<span class="keyword1"><span class="command">locale</span></span> finite_GSgame <span class="main">=</span> GSgame <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> fin<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="free">N</span> <span class="main">≠</span> <span class="main">∞</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹ Finite games are closed games. As a corollary to the GS theorem, this lets us conclude that finite games are determined. ›</span></span>
<span class="keyword1"><span class="command">sublocale</span></span> closed_GSgame
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">e</span> <span class="keyword3"><span class="command">assume</span></span> eA<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">e</span> <span class="main">∈</span> <span class="free">A</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?p</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"list_of <span class="skolem">e</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> eA <span class="keyword1"><span class="command">have</span></span> len<span class="main">:</span><span class="quoted"><span class="quoted">"llength <span class="skolem">e</span> <span class="main">=</span> <span class="numeral">2</span><span class="main">*</span><span class="free">N</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> length <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">with</span></span> fin <span class="keyword1"><span class="command">have</span></span> p<span class="main">:</span><span class="quoted"><span class="quoted">"llist_of <span class="var">?p</span> <span class="main">=</span> <span class="skolem">e</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> llist_of_list_of mult_2 not_lfinite_llength plus_eq_infty_iff_enat<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> pfx<span class="main">:</span><span class="quoted"><span class="quoted">"lprefix <span class="main">(</span>llist_of <span class="var">?p</span><span class="main">)</span> <span class="skolem">e</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">e'</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"lprefix <span class="main">(</span>llist_of <span class="var">?p</span><span class="main">)</span> <span class="skolem">e'</span>"</span></span> <span class="quoted"><span class="quoted">"llength <span class="skolem">e'</span> <span class="main">=</span> <span class="numeral">2</span> <span class="main">*</span> <span class="free">N</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">e'</span> <span class="main">=</span> <span class="skolem">e</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> len <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> lprefix_llength_eq_imp_eq p<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> eA <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">e'</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">with</span></span> pfx <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">p</span><span class="main">.</span> lprefix <span class="main">(</span>llist_of <span class="bound">p</span><span class="main">)</span> <span class="skolem">e</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">e'</span><span class="main">.</span> lprefix <span class="main">(</span>llist_of <span class="bound">p</span><span class="main">)</span> <span class="bound">e'</span> <span class="main">⟶</span> llength <span class="bound">e'</span> <span class="main">=</span> <span class="numeral">2</span> <span class="main">*</span> <span class="free">N</span> <span class="main">⟶</span> <span class="bound">e'</span> <span class="main">∈</span> <span class="free">A</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> closed_GSgame <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1" id="GaleStewartDeterminedGames-never_winning_is_losing_even"><span class="command">lemma</span></span> never_winning_is_losing_even<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"position <span class="free">p</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">n</span><span class="main">.</span> <span class="main">¬</span> winning_position_Even <span class="main">(</span><span class="main">(</span><span class="main">(</span>augment_list <span class="free">σ</span><span class="main">)</span> <span class="main">^^</span> <span class="bound">n</span><span class="main">)</span> <span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"induced_play <span class="free">σ</span> <span class="free">p</span> <span class="main">∉</span> <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"induced_play <span class="free">σ</span> <span class="free">p</span> <span class="main">∈</span> <span class="free">A</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> closed<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p'</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    p'<span class="main">:</span><span class="quoted"><span class="quoted">"lprefix <span class="main">(</span>llist_of <span class="skolem">p'</span><span class="main">)</span> <span class="main">(</span>induced_play <span class="free">σ</span> <span class="free">p</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">e</span><span class="main">.</span> lprefix <span class="main">(</span>llist_of <span class="skolem">p'</span><span class="main">)</span> <span class="bound">e</span> <span class="main">⟹</span> llength <span class="bound">e</span> <span class="main">=</span> <span class="numeral">2</span> <span class="main">*</span> <span class="free">N</span> <span class="main">⟹</span> <span class="bound">e</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">from</span></span> lprefix_llength_le<span class="main">[</span><span class="operator">OF</span> p'<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> lp'<span class="main">:</span><span class="quoted"><span class="quoted">"llength <span class="main">(</span>llist_of <span class="skolem">p'</span><span class="main">)</span> <span class="main">≤</span> <span class="numeral">2</span> <span class="main">*</span> <span class="free">N</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"length <span class="skolem">p'</span> <span class="main">≤</span> length <span class="free">p</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"llength <span class="main">(</span>llist_of <span class="skolem">p'</span><span class="main">)</span> <span class="main">≤</span> llength <span class="main">(</span>llist_of <span class="free">p</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> lprefix_llength_lprefix<span class="main">[</span><span class="operator">OF</span> p'<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> _ this<span class="main">]</span>
      induced_play_is_lprefix<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span>
      lprefix_trans
    <span class="keyword1"><span class="command">have</span></span> pref<span class="main">:</span><span class="quoted"><span class="quoted">"lprefix <span class="main">(</span>llist_of <span class="skolem">p'</span><span class="main">)</span> <span class="main">(</span>induced_play <span class="skolem">strat</span> <span class="free">p</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">strat</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">from</span></span> assms<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">rule_format</span><span class="main">,</span><span class="operator">of</span> <span class="quoted"><span class="main">0</span></span><span class="main">]</span> assms<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> strategy_winning_by_Even <span class="skolem">σ</span> <span class="free">p</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">σ</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> this<span class="main">[</span><span class="operator">unfolded</span> strategy_winning_by_Even_def<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">strat</span></span> <span class="keyword2"><span class="keyword">where</span></span>
      strat<span class="main">:</span><span class="quoted"><span class="quoted">"induced_play <span class="skolem">strat</span> <span class="free">p</span> <span class="main">∉</span> <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> strat p'<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> pref<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?n</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"length <span class="skolem">p'</span> <span class="main">-</span> length <span class="free">p</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?pos</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>augment_list <span class="free">σ</span> <span class="main">^^</span> <span class="var">?n</span><span class="main">)</span> <span class="free">p</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> False <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"length <span class="skolem">p'</span> <span class="main">≥</span> length <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span><span class="quoted"><span class="quoted">"length <span class="var">?pos</span> <span class="main">=</span> length <span class="skolem">p'</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>length_augment_list<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> pos<span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span><span class="quoted"><span class="quoted">"position <span class="var">?pos</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> False lp'<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> position_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"llist_of <span class="skolem">p'</span> <span class="main">=</span> llist_of <span class="var">?pos</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> p'<span class="main">(</span>1<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">intro</span> lprefix_antisym<span class="main"><span class="main">[</span></span><span class="operator">OF</span> lprefix_llength_lprefix lprefix_llength_lprefix<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">auto</span><span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> p'_pos<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="skolem">p'</span> <span class="main">=</span> <span class="var">?pos</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> assms<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">rule_format</span><span class="main">,</span><span class="operator">of</span> <span class="var"><span class="quoted"><span class="var">?n</span></span></span><span class="main">]</span> assms<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> strategy_winning_by_Even <span class="skolem">σ</span> <span class="var">?pos</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">σ</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> this<span class="main">[</span><span class="operator">unfolded</span> strategy_winning_by_Even_def<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">strat</span></span> <span class="keyword2"><span class="keyword">where</span></span>
      strat<span class="main">:</span><span class="quoted"><span class="quoted">"induced_play <span class="skolem">strat</span> <span class="var">?pos</span> <span class="main">∉</span> <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> p'_pos induced_play_is_lprefix<span class="main">[</span><span class="operator">OF</span> pos<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="skolem">strat</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> pref<span class="main">:</span><span class="quoted"><span class="quoted">"lprefix <span class="main">(</span>llist_of <span class="skolem">p'</span><span class="main">)</span> <span class="main">(</span>induced_play <span class="skolem">strat</span> <span class="var">?pos</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">with</span></span> p'<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> pref<span class="main">]</span> strat <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹ By proving that every position is determined, this proves that every game is determined
       (since a game is determined if its initial position [] is) ›</span></span>
<span class="keyword1" id="GaleStewartDeterminedGames-every_position_is_determined"><span class="command">lemma</span></span> every_position_is_determined<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"position <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"winning_position_Even <span class="free">p</span> <span class="main">∨</span> winning_position_Odd <span class="free">p</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?we</span> <span class="main">∨</span> <span class="var">?wo</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> impI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">¬</span></span> <span class="var"><span class="var">?we</span></span> <span class="main"><span class="main">⟶</span></span> <span class="main"><span class="main">¬</span></span> <span class="var"><span class="var">?wo</span></span> <span class="main"><span class="main">⟶</span></span> False"</span></span></span><span class="main"><span class="main">,</span></span><span class="operator">rule_format</span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">force</span><span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="var">?we</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> defensive_strategy_Odd<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> never_winning_is_losing_even<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> js_no<span class="main">:</span><span class="quoted"><span class="quoted">"induced_play
         <span class="main">(</span>joint_strategy <span class="skolem">s</span> defensive_strategy_Odd<span class="main">)</span> <span class="free">p</span> <span class="main">∉</span> <span class="free">A</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">s</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="var">?wo</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> this<span class="main">[</span><span class="operator">unfolded</span> strategy_winning_by_Odd_def<span class="main">]</span> assms
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">s</span><span class="main">.</span> induced_play
         <span class="main">(</span>joint_strategy <span class="bound">s</span> defensive_strategy_Odd<span class="main">)</span> <span class="free">p</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> js_no <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1" id="GaleStewartDeterminedGames-empty_position"><span class="command">lemma</span></span> empty_position<span class="main">:</span> <span class="quoted"><span class="quoted">"position <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> zero_enat_def position_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">lemmas</span></span> every_game_is_determined <span class="main">=</span> every_position_is_determined<span class="main">[</span><span class="operator">OF</span> empty_position<span class="main">]</span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹ We expect that this theorem can be easier to apply without the 'position p' requirement,
       so we present that theorem as well. ›</span></span>
<span class="keyword1" id="GaleStewartDeterminedGames-every_position_has_winning_strategy"><span class="command">lemma</span></span> every_position_has_winning_strategy<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∃</span> <span class="bound">σ</span><span class="main">.</span> strategy_winning_by_Even <span class="bound">σ</span> <span class="free">p</span><span class="main">)</span> <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span> <span class="bound">σ</span><span class="main">.</span> strategy_winning_by_Odd <span class="bound">σ</span> <span class="free">p</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?we</span> <span class="main">∨</span> <span class="var">?wo</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"position <span class="free">p</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> every_position_is_determined <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="numeral">2</span> <span class="main">*</span> <span class="free">N</span> <span class="main">≤</span> enat <span class="main">(</span>length <span class="free">p</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> position_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">from</span></span> induced_play_lprefix_non_positions<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> strategy_winning_by_Even_def strategy_winning_by_Odd_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div>