<div id="Definition">
<div class="head">
<h1>Theory Definition</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">chapter</span></span> <span class="quoted"><span class="plain_text">‹Definition›</span></span>

<span class="keyword1"><span class="command">theory</span></span> <span class="main">%</span>invisible Definition
<span class="keyword2"><span class="keyword">imports</span></span> <a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{chap:definition}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In stepwise refinement~\cite{DijkstraConstructive,WirthRefinement},
a program is derived from a specification
via a sequence of intermediate specifications.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Pop-refinement (where `pop' stands for `predicates over programs')
is an approach to stepwise refinement,
carried out inside an interactive theorem prover
(e.g.\ Isabelle/HOL, HOL4, Coq, PVS, ACL2)
as follows:
\begin{enumerate}
\item
Formalize the syntax and semantics
of (the needed subset of) the target programming language (and libraries),
as a deep embedding.
\item
Specify the requirements
by defining a predicate over programs
that characterizes the possible implementations.
\item
Refine the specification stepwise
by defining monotonically decreasing predicates over programs
(decreasing with respect to inclusion, i.e.\ logical implication),
according to decisions that narrow down the possible implementations.
\item
Conclude the derivation
with a predicate that characterizes a unique program in explicit syntactic form,
from which the program text is readily obtained.
\end{enumerate}›</span></span>


<span class="keyword2"><span class="keyword">end</span></span> <span class="main">%</span>invisible
</pre>
</div><div id="First_Example">
<div class="head">
<h1>Theory First_Example</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">chapter</span></span> <span class="quoted"><span class="plain_text">‹First Example›</span></span>

<span class="keyword1"><span class="command">theory</span></span> <span class="main">%</span>invisible First_Example
<span class="keyword2"><span class="keyword">imports</span></span> <a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{chap:exampleI}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Pop-refinement is illustrated via a simple derivation,
in Isabelle/HOL,
of a program that includes non-functional aspects.›</span></span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Target Programming Language›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:targetI}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In the target language used in this example,
a program consists of
a list of distinct variables (the parameters of the program)
and an arithmetic expression (the body of the program).
The body is built out of
parameters,
non-negative integer constants,
addition operations,
and doubling (i.e.\ multiplication by 2) operations.
The program is executed
by supplying non-negative integers to the parameters
and evaluating the body to obtain a non-negative integer result.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹For instance, executing the program
\begin{verbatim}
  prog (a,b) {3 + 2 * (a + b)}
\end{verbatim}
with 5 and 7 supplied to \verb|a| and \verb|b| yields 27.
The syntax and semantics of this language are formalized as follows.›</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Syntax›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:syntaxI}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Variables are identified by names.›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> name <span class="main">=</span> <span class="quoted">string</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Expressions are built out of
constants, variables, doubling operations, and addition operations.›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> expr <span class="main">=</span> Const <span class="quoted">nat</span> <span class="main">|</span> Var <span class="quoted">name</span> <span class="main">|</span> Double <span class="quoted">expr</span> <span class="main">|</span> Add <span class="quoted">expr</span> <span class="quoted">expr</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A program consists of
a list of parameter variables and a body expression.›</span></span>

<span class="keyword1"><span class="command">record</span></span> prog <span class="main">=</span>
 para <span class="main">::</span> <span class="quoted"><span class="quoted">"name list"</span></span>
 body <span class="main">::</span> <span class="quoted">expr</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Static Semantics›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:staticI}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A context is a set of variables.›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> ctxt <span class="main">=</span> <span class="quoted"><span class="quoted">"name set"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Given a context,
an expression is well-formed iff\
all its variables are in the context.›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">wfe</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"ctxt <span class="main">⇒</span> expr <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">wfe</span> <span class="free"><span class="bound"><span class="entity">Γ</span></span></span> <span class="main">(</span>Const <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">)</span> <span class="main">⟷</span> True"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">wfe</span> <span class="free"><span class="bound"><span class="entity">Γ</span></span></span> <span class="main">(</span>Var <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">Γ</span></span></span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">wfe</span> <span class="free"><span class="bound"><span class="entity">Γ</span></span></span> <span class="main">(</span>Double <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="free">wfe</span> <span class="free"><span class="bound"><span class="entity">Γ</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">wfe</span> <span class="free"><span class="bound"><span class="entity">Γ</span></span></span> <span class="main">(</span>Add <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>2</sub></span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="free">wfe</span> <span class="free"><span class="bound"><span class="entity">Γ</span></span></span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="main">∧</span> <span class="free">wfe</span> <span class="free"><span class="bound"><span class="entity">Γ</span></span></span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>2</sub></span></span></span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The context of a program consists of the parameters.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ctxt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"prog <span class="main">⇒</span> ctxt"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ctxt</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span> set <span class="main">(</span>para <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A program is well-formed iff\
the parameters are distinct
and the body is well-formed in the context of the program.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">wfp</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"prog <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">wfp</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span> distinct <span class="main">(</span>para <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="main">∧</span> wfe <span class="main">(</span>ctxt <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="main">(</span>body <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span>"</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Dynamic Semantics›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:dynamicI}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹An environment associates values (non-negative integers)
to variables.›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> env <span class="main">=</span> <span class="quoted"><span class="quoted">"name <span class="main">⇀</span> nat"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹An environment matches a context iff\
environment and context have the same variables.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">match</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"env <span class="main">⇒</span> ctxt <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">match</span> <span class="free"><span class="bound"><span class="entity">ℰ</span></span></span> <span class="free"><span class="bound"><span class="entity">Γ</span></span></span> <span class="main">≡</span> dom <span class="free"><span class="bound"><span class="entity">ℰ</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">Γ</span></span></span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Evaluating an expression in an environment yields a value,
or an error (<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> None<span class="antiquote"><span class="antiquote">}</span></span></span></span>)
if the expression contains a variable not in the environment.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">mul_opt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat option <span class="main">⇒</span> nat option <span class="main">⇒</span> nat option"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">⊗</span>"</span> 70<span class="main">)</span>
<span class="comment1">― ‹Lifting of multiplication to <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"nat option"</span><span class="antiquote">}</span></span>.›</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">U<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="main"><span class="free">⊗</span></span> <span class="free"><span class="bound"><span class="entity">U<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="main">≡</span>
  <span class="keyword1">case</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">U<span class="hidden">⇩</span><sub>1</sub></span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">U<span class="hidden">⇩</span><sub>2</sub></span></span></span><span class="main">)</span> <span class="keyword1">of</span> <span class="main">(</span>Some <span class="bound">u<span class="hidden">⇩</span><sub>1</sub></span><span class="main">,</span> Some <span class="bound">u<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span> <span class="main">⇒</span> Some <span class="main">(</span><span class="bound">u<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">*</span> <span class="bound">u<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span> <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> None"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">add_opt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat option <span class="main">⇒</span> nat option <span class="main">⇒</span> nat option"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">⊕</span>"</span> 65<span class="main">)</span>
<span class="comment1">― ‹Lifting of addition to <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"nat option"</span><span class="antiquote">}</span></span>.›</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">U<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="main"><span class="free">⊕</span></span> <span class="free"><span class="bound"><span class="entity">U<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="main">≡</span>
  <span class="keyword1">case</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">U<span class="hidden">⇩</span><sub>1</sub></span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">U<span class="hidden">⇩</span><sub>2</sub></span></span></span><span class="main">)</span> <span class="keyword1">of</span> <span class="main">(</span>Some <span class="bound">u<span class="hidden">⇩</span><sub>1</sub></span><span class="main">,</span> Some <span class="bound">u<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span> <span class="main">⇒</span> Some <span class="main">(</span><span class="bound">u<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">+</span> <span class="bound">u<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span> <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> None"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">eval</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"env <span class="main">⇒</span> expr <span class="main">⇒</span> nat option"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">eval</span> <span class="free"><span class="bound"><span class="entity">ℰ</span></span></span> <span class="main">(</span>Const <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">)</span> <span class="main">=</span> Some <span class="free"><span class="bound"><span class="entity">c</span></span></span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">eval</span> <span class="free"><span class="bound"><span class="entity">ℰ</span></span></span> <span class="main">(</span>Var <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">ℰ</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">eval</span> <span class="free"><span class="bound"><span class="entity">ℰ</span></span></span> <span class="main">(</span>Double <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span> <span class="main">=</span> Some <span class="numeral">2</span> <span class="main">⊗</span> <span class="free">eval</span> <span class="free"><span class="bound"><span class="entity">ℰ</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">eval</span> <span class="free"><span class="bound"><span class="entity">ℰ</span></span></span> <span class="main">(</span>Add <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>2</sub></span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">eval</span> <span class="free"><span class="bound"><span class="entity">ℰ</span></span></span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="main">⊕</span> <span class="free">eval</span> <span class="free"><span class="bound"><span class="entity">ℰ</span></span></span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>2</sub></span></span></span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Evaluating a well-formed expression never yields an error,
if the environment matches the context.›</span></span>

<span class="keyword1" id="First_Example-eval_wfe"><span class="command">lemma</span></span> eval_wfe<span class="main">:</span>
  <span class="quoted"><span class="quoted">"wfe <span class="free">Γ</span> <span class="free">e</span> <span class="main">⟹</span> match <span class="free">ℰ</span> <span class="free">Γ</span> <span class="main">⟹</span> eval <span class="free">ℰ</span> <span class="free">e</span> <span class="main">≠</span> None"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">e</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> match_def mul_opt_def add_opt_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The environments of a program
are the ones that match the context of the program.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">envs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"prog <span class="main">⇒</span> env set"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">envs</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span> <span class="main">{</span><span class="bound">ℰ</span><span class="main">.</span> match <span class="bound">ℰ</span> <span class="main">(</span>ctxt <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Evaluating the body of a well-formed program
in an environment of the program
never yields an error.›</span></span>

<span class="keyword1" id="First_Example-eval_wfp"><span class="command">lemma</span></span> eval_wfp<span class="main">:</span>
  <span class="quoted"><span class="quoted">"wfp <span class="free">p</span> <span class="main">⟹</span> <span class="free">ℰ</span> <span class="main">∈</span> envs <span class="free">p</span> <span class="main">⟹</span> eval <span class="free">ℰ</span> <span class="main">(</span>body <span class="free">p</span><span class="main">)</span> <span class="main">≠</span> None"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> envs_def eval_wfe mem_Collect_eq wfp_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Executing a program with values supplied to the parameters
yields a non-negative integer result,
or an error (<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> None<span class="antiquote"><span class="antiquote">}</span></span></span></span>)
if the parameters are not distinct,
the number of supplied values differs from the number of parameters,
or the evaluation of the body yields an error.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted">"<span class="entity">supply</span>"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"prog <span class="main">⇒</span> nat list <span class="main">⇒</span> env option"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">supply</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">us</span></span></span> <span class="main">≡</span>
  <span class="keyword1">let</span> <span class="bound">vs</span> <span class="main">=</span> para <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="keyword1">in</span>
  <span class="keyword1">if</span> distinct <span class="bound">vs</span> <span class="main">∧</span> length <span class="free"><span class="bound"><span class="entity">us</span></span></span> <span class="main">=</span> length <span class="bound">vs</span>
  <span class="keyword1">then</span> Some <span class="main">(</span>map_of <span class="main">(</span>zip <span class="bound">vs</span> <span class="free"><span class="bound"><span class="entity">us</span></span></span><span class="main">)</span><span class="main">)</span>
  <span class="keyword1">else</span> None"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">exec</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"prog <span class="main">⇒</span> nat list <span class="main">⇒</span> nat option"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">exec</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">us</span></span></span> <span class="main">≡</span>
  <span class="keyword1">case</span> supply <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">us</span></span></span> <span class="keyword1">of</span> Some <span class="bound">ℰ</span> <span class="main">⇒</span> eval <span class="bound">ℰ</span> <span class="main">(</span>body <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="main">|</span> None <span class="main">⇒</span> None"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Executing a well-formed program
with the same number of values as the number of parameters
never yields an error.›</span></span>

<span class="keyword1" id="First_Example-supply_wfp"><span class="command">lemma</span></span> supply_wfp<span class="main">:</span> <span class="quoted"><span class="quoted">"
  wfp <span class="free">p</span> <span class="main">⟹</span>
  length <span class="free">us</span> <span class="main">=</span> length <span class="main">(</span>para <span class="free">p</span><span class="main">)</span> <span class="main">⟹</span>
  <span class="main">∃</span><span class="bound">ℰ</span> <span class="main">∈</span> envs <span class="free">p</span><span class="main">.</span> supply <span class="free">p</span> <span class="free">us</span> <span class="main">=</span> Some <span class="bound">ℰ</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span>
 <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> wfp_def supply_def envs_def ctxt_def match_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

<span class="keyword1" id="First_Example-exec_wfp"><span class="command">lemma</span></span> exec_wfp<span class="main">:</span>
  <span class="quoted"><span class="quoted">"wfp <span class="free">p</span> <span class="main">⟹</span> length <span class="free">us</span> <span class="main">=</span> length <span class="main">(</span>para <span class="free">p</span><span class="main">)</span> <span class="main">⟹</span> exec <span class="free">p</span> <span class="free">us</span> <span class="main">≠</span> None"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> eval_wfp exec_def option.simps<span class="main"><span class="main">(</span></span>5<span class="main"><span class="main">)</span></span> supply_wfp<span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Performance›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:nonfunc}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹As a non-functional semantic aspect,
the cost (e.g.\ time and power) to execute a program
is modeled as the number of doubling and addition operations.›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">coste</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"expr <span class="main">⇒</span> nat"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">coste</span> <span class="main">(</span>Const <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">coste</span> <span class="main">(</span>Var <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">coste</span> <span class="main">(</span>Double <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span> <span class="main">+</span> <span class="free">coste</span> <span class="free"><span class="bound"><span class="entity">e</span></span></span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">coste</span> <span class="main">(</span>Add <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>2</sub></span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span> <span class="main">+</span> <span class="free">coste</span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="main">+</span> <span class="free">coste</span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>2</sub></span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">costp</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"prog <span class="main">⇒</span> nat"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">costp</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span> coste <span class="main">(</span>body <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span>"</span></span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Requirement Specification›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:specificationI}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The target program must:
\begin{enumerate}
\item
Be well-formed.
\item
Have exactly the two parameters <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="inner_quoted"><span class="inner_quoted">''x''</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="inner_quoted"><span class="inner_quoted">''y''</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>,
in this order.
\item
Produce the result <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">f</span></span> <span class="free"><span class="free">x</span></span> <span class="free"><span class="free">y</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
when <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">x</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">y</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
are supplied to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="inner_quoted"><span class="inner_quoted">''x''</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="inner_quoted"><span class="inner_quoted">''y''</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>,
where <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">f</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is defined below.
\item
Not exceed cost 3.
\end{enumerate}›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> nat <span class="main">⇒</span> nat"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">≡</span> <span class="numeral">3</span> <span class="main">*</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">+</span> <span class="numeral">2</span> <span class="main">*</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">spec<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"prog <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">spec<span class="hidden">⇩</span><sub>0</sub></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span>
  wfp <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∧</span>
  para <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">[</span><span class="inner_quoted">''x''</span><span class="main">,</span> <span class="inner_quoted">''y''</span><span class="main">]</span> <span class="main">∧</span>
  <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> exec <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">[</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">]</span> <span class="main">=</span> Some <span class="main">(</span>f <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
  costp <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≤</span> <span class="numeral">3</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> f<span class="antiquote"><span class="antiquote">}</span></span></span></span> is used by <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> spec<span class="hidden">⇩</span><sub>0</sub><span class="antiquote"><span class="antiquote">}</span></span></span></span>
to express a functional requirement on the execution of the program.
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> spec<span class="hidden">⇩</span><sub>0</sub><span class="antiquote"><span class="antiquote">}</span></span></span></span> includes
the non-functional requirement <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"costp<span class="main"><span class="main">(</span></span><span class="free"><span class="free">p</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">≤</span></span> <span class="numeral"><span class="numeral">3</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
and the syntactic interface requirement <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"para<span class="main"><span class="main">(</span></span><span class="free"><span class="free">p</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">=</span></span> <span class="main"><span class="main">[</span></span><span class="inner_quoted"><span class="inner_quoted">''x''</span></span><span class="main"><span class="main">,</span></span> <span class="inner_quoted"><span class="inner_quoted">''y''</span></span><span class="main"><span class="main">]</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>,
which are not expressed by <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> f<span class="antiquote"><span class="antiquote">}</span></span></span></span> alone
and are expressible only in terms of programs.
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> f<span class="antiquote"><span class="antiquote">}</span></span></span></span> can be computed by a program
with cost higher than 3
and with more or different parameters;
it can also be computed by programs in different target languages.›</span></span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Stepwise Refinement›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:refinementI}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹It is not difficult
to write a program that satisfies <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> spec<span class="hidden">⇩</span><sub>0</sub><span class="antiquote"><span class="antiquote">}</span></span></span></span> and to prove that it does.
But with more complex target languages and requirement specifications,
writing a program and proving that it satisfies the requirements
is notoriously difficult.
Stepwise refinement decomposes the proof into manageable pieces,
constructing the implementation along the way.
The following sequence of refinement steps
may be overkill for obtaining an implementation of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> spec<span class="hidden">⇩</span><sub>0</sub><span class="antiquote"><span class="antiquote">}</span></span></span></span>,
but illustrates concepts that should apply to more complex cases.›</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Step 1›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:refI:stepI}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The second conjunct in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> spec<span class="hidden">⇩</span><sub>0</sub><span class="antiquote"><span class="antiquote">}</span></span></span></span> determines the parameters,
leaving only the body to be determined.
That conjunct also reduces
the well-formedness of the program to the well-formedness of the body,
and the execution of the program to the evaluation of the body.›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">Γ<span class="hidden">⇩</span><sub>x</sub><span class="hidden">⇩</span><sub>y</sub></span> <span class="main">::</span> <span class="quoted">ctxt</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">Γ<span class="hidden">⇩</span><sub>x</sub><span class="hidden">⇩</span><sub>y</sub></span> <span class="main">≡</span> <span class="main">{</span><span class="inner_quoted">''x''</span><span class="main">,</span> <span class="inner_quoted">''y''</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">ℰ<span class="hidden">⇩</span><sub>x</sub><span class="hidden">⇩</span><sub>y</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> nat <span class="main">⇒</span> env"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ℰ<span class="hidden">⇩</span><sub>x</sub><span class="hidden">⇩</span><sub>y</sub></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">≡</span> <span class="main">[</span><span class="inner_quoted">''x''</span> <span class="main">↦</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">,</span> <span class="inner_quoted">''y''</span> <span class="main">↦</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">]</span>"</span></span>

<span class="keyword1" id="First_Example-reduce_prog_to_body"><span class="command">lemma</span></span> reduce_prog_to_body<span class="main">:</span> <span class="quoted"><span class="quoted">"
  para <span class="free">p</span> <span class="main">=</span> <span class="main">[</span><span class="inner_quoted">''x''</span><span class="main">,</span> <span class="inner_quoted">''y''</span><span class="main">]</span> <span class="main">⟹</span>
  wfp <span class="free">p</span> <span class="main">=</span> wfe Γ<span class="hidden">⇩</span><sub>x</sub><span class="hidden">⇩</span><sub>y</sub> <span class="main">(</span>body <span class="free">p</span><span class="main">)</span> <span class="main">∧</span>
  exec <span class="free">p</span> <span class="main">[</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">]</span> <span class="main">=</span> eval <span class="main">(</span>ℰ<span class="hidden">⇩</span><sub>x</sub><span class="hidden">⇩</span><sub>y</sub> <span class="free">x</span> <span class="free">y</span><span class="main">)</span> <span class="main">(</span>body <span class="free">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> wfp_def ctxt_def exec_def supply_def fun_upd_twist<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Using lemma <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>reduce_prog_to_body›</span></span></span></span>,
and using the definition of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> costp<span class="antiquote"><span class="antiquote">}</span></span></span></span>
to reduce the cost of the program to the cost of the body,
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> spec<span class="hidden">⇩</span><sub>0</sub><span class="antiquote"><span class="antiquote">}</span></span></span></span> is refined as follows.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">spec<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"prog <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">spec<span class="hidden">⇩</span><sub>1</sub></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span>
  wfe Γ<span class="hidden">⇩</span><sub>x</sub><span class="hidden">⇩</span><sub>y</sub> <span class="main">(</span>body <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="main">∧</span>
  para <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">[</span><span class="inner_quoted">''x''</span><span class="main">,</span> <span class="inner_quoted">''y''</span><span class="main">]</span> <span class="main">∧</span>
  <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> eval <span class="main">(</span>ℰ<span class="hidden">⇩</span><sub>x</sub><span class="hidden">⇩</span><sub>y</sub> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span> <span class="main">(</span>body <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="main">=</span> Some <span class="main">(</span>f <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
  coste <span class="main">(</span>body <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="main">≤</span> <span class="numeral">3</span>"</span></span>

<span class="keyword1" id="First_Example-step_1_correct"><span class="command">lemma</span></span> step_1_correct<span class="main">:</span>
 <span class="quoted"><span class="quoted">"spec<span class="hidden">⇩</span><sub>1</sub> <span class="free">p</span> <span class="main">⟹</span> spec<span class="hidden">⇩</span><sub>0</sub> <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> spec<span class="hidden">⇩</span><sub>1</sub>_def spec<span class="hidden">⇩</span><sub>0</sub>_def reduce_prog_to_body costp_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> spec<span class="hidden">⇩</span><sub>1</sub><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> spec<span class="hidden">⇩</span><sub>0</sub><span class="antiquote"><span class="antiquote">}</span></span></span></span> are actually equivalent,
but the definition of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> spec<span class="hidden">⇩</span><sub>1</sub><span class="antiquote"><span class="antiquote">}</span></span></span></span> is ``closer'' to the implementation
than the definition of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> spec<span class="hidden">⇩</span><sub>0</sub><span class="antiquote"><span class="antiquote">}</span></span></span></span>:
the latter states constraints on the whole program,
while the former states simpler constraints on the body,
given that the parameters are already determined.
The proof of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>step_1_correct›</span></span></span></span>
can also be used to prove the equivalence of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> spec<span class="hidden">⇩</span><sub>1</sub><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> spec<span class="hidden">⇩</span><sub>0</sub><span class="antiquote"><span class="antiquote">}</span></span></span></span>,
but in general proving inclusion is easier than proving equivalence.
Some of the following refinement steps yield non-equivalent predicates.›</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Step 2›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:refI:stepII}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The third conjunct in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> spec<span class="hidden">⇩</span><sub>1</sub><span class="antiquote"><span class="antiquote">}</span></span></span></span> says that
the body computes <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"f <span class="free"><span class="free">x</span></span> <span class="free"><span class="free">y</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>,
which depends on both <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">x</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">y</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>,
and which yields an odd result for some values of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">x</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">y</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
Thus the body cannot be a constant, a variable, or a double,
leaving a sum as the only option.
Adding <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">∃</span></span><span class="bound"><span class="bound">e<span class="hidden">⇩</span><sub>1</sub></span></span> <span class="bound"><span class="bound">e<span class="hidden">⇩</span><sub>2</sub></span></span><span class="main"><span class="main">.</span></span> body <span class="free"><span class="free">p</span></span> <span class="main"><span class="main">=</span></span> Add <span class="bound"><span class="bound">e<span class="hidden">⇩</span><sub>1</sub></span></span> <span class="bound"><span class="bound">e<span class="hidden">⇩</span><sub>2</sub></span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> as a conjunct to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> spec<span class="hidden">⇩</span><sub>1</sub><span class="antiquote"><span class="antiquote">}</span></span></span></span>
and re-arranging the other conjuncts,
moving some of them under the existential quantification
so that they can be simplified in the next refinement step,
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> spec<span class="hidden">⇩</span><sub>1</sub><span class="antiquote"><span class="antiquote">}</span></span></span></span> is refined as follows.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">spec<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"prog <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">spec<span class="hidden">⇩</span><sub>2</sub></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span>
  para <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">[</span><span class="inner_quoted">''x''</span><span class="main">,</span> <span class="inner_quoted">''y''</span><span class="main">]</span> <span class="main">∧</span>
  <span class="main">(</span><span class="main">∃</span><span class="bound">e<span class="hidden">⇩</span><sub>1</sub></span> <span class="bound">e<span class="hidden">⇩</span><sub>2</sub></span><span class="main">.</span>
    body <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> Add <span class="bound">e<span class="hidden">⇩</span><sub>1</sub></span> <span class="bound">e<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">∧</span>
    wfe Γ<span class="hidden">⇩</span><sub>x</sub><span class="hidden">⇩</span><sub>y</sub> <span class="main">(</span>body <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="main">∧</span>
    <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> eval <span class="main">(</span>ℰ<span class="hidden">⇩</span><sub>x</sub><span class="hidden">⇩</span><sub>y</sub> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span> <span class="main">(</span>body <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="main">=</span> Some <span class="main">(</span>f <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
    coste <span class="main">(</span>body <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="main">≤</span> <span class="numeral">3</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="First_Example-step_2_correct"><span class="command">lemma</span></span> step_2_correct<span class="main">:</span>
 <span class="quoted"><span class="quoted">"spec<span class="hidden">⇩</span><sub>2</sub> <span class="free">p</span> <span class="main">⟹</span> spec<span class="hidden">⇩</span><sub>1</sub> <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> spec<span class="hidden">⇩</span><sub>2</sub>_def spec<span class="hidden">⇩</span><sub>1</sub>_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This refinement step is guided by an analysis
of the constraints in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> spec<span class="hidden">⇩</span><sub>1</sub><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Step 3›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:refI:stepIII}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The fact that the body is a sum
reduces the well-formedness, evaluation, and cost of the body
to the well-formedness, evaluation, and cost of the addends.›</span></span>

<span class="keyword1" id="First_Example-reduce_body_to_addends"><span class="command">lemma</span></span> reduce_body_to_addends<span class="main">:</span> <span class="quoted"><span class="quoted">"
  body <span class="free">p</span> <span class="main">=</span> Add <span class="free">e<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">e<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">⟹</span>
  wfe Γ<span class="hidden">⇩</span><sub>x</sub><span class="hidden">⇩</span><sub>y</sub> <span class="main">(</span>body <span class="free">p</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>wfe Γ<span class="hidden">⇩</span><sub>x</sub><span class="hidden">⇩</span><sub>y</sub> <span class="free">e<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">∧</span> wfe Γ<span class="hidden">⇩</span><sub>x</sub><span class="hidden">⇩</span><sub>y</sub> <span class="free">e<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span> <span class="main">∧</span>
  eval <span class="main">(</span>ℰ<span class="hidden">⇩</span><sub>x</sub><span class="hidden">⇩</span><sub>y</sub> <span class="free">x</span> <span class="free">y</span><span class="main">)</span> <span class="main">(</span>body <span class="free">p</span><span class="main">)</span> <span class="main">=</span> eval <span class="main">(</span>ℰ<span class="hidden">⇩</span><sub>x</sub><span class="hidden">⇩</span><sub>y</sub> <span class="free">x</span> <span class="free">y</span><span class="main">)</span> <span class="free">e<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⊕</span> eval <span class="main">(</span>ℰ<span class="hidden">⇩</span><sub>x</sub><span class="hidden">⇩</span><sub>y</sub> <span class="free">x</span> <span class="free">y</span><span class="main">)</span> <span class="free">e<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">∧</span>
  coste <span class="main">(</span>body <span class="free">p</span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span> <span class="main">+</span> coste <span class="free">e<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">+</span> coste <span class="free">e<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Using <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>reduce_body_to_addends›</span></span></span></span>
and arithmetic simplification,
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> spec<span class="hidden">⇩</span><sub>2</sub><span class="antiquote"><span class="antiquote">}</span></span></span></span> is refined as follows.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">spec<span class="hidden">⇩</span><sub>3</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"prog <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">spec<span class="hidden">⇩</span><sub>3</sub></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span>
  para <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">[</span><span class="inner_quoted">''x''</span><span class="main">,</span> <span class="inner_quoted">''y''</span><span class="main">]</span> <span class="main">∧</span>
  <span class="main">(</span><span class="main">∃</span><span class="bound">e<span class="hidden">⇩</span><sub>1</sub></span> <span class="bound">e<span class="hidden">⇩</span><sub>2</sub></span><span class="main">.</span>
    body <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> Add <span class="bound">e<span class="hidden">⇩</span><sub>1</sub></span> <span class="bound">e<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">∧</span>
    wfe Γ<span class="hidden">⇩</span><sub>x</sub><span class="hidden">⇩</span><sub>y</sub> <span class="bound">e<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">∧</span>
    wfe Γ<span class="hidden">⇩</span><sub>x</sub><span class="hidden">⇩</span><sub>y</sub> <span class="bound">e<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">∧</span>
    <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> eval <span class="main">(</span>ℰ<span class="hidden">⇩</span><sub>x</sub><span class="hidden">⇩</span><sub>y</sub> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span> <span class="bound">e<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⊕</span> eval <span class="main">(</span>ℰ<span class="hidden">⇩</span><sub>x</sub><span class="hidden">⇩</span><sub>y</sub> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span> <span class="bound">e<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">=</span> Some <span class="main">(</span>f <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
    coste <span class="bound">e<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">+</span> coste <span class="bound">e<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">≤</span> <span class="numeral">2</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="First_Example-step_3_correct"><span class="command">lemma</span></span> step_3_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"spec<span class="hidden">⇩</span><sub>3</sub> <span class="free">p</span> <span class="main">⟹</span> spec<span class="hidden">⇩</span><sub>2</sub> <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> spec<span class="hidden">⇩</span><sub>3</sub>_def spec<span class="hidden">⇩</span><sub>2</sub>_def<span class="main">)</span>
<span class="comment1">― ‹No need to use <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">text</span> <span class="raw_text">reduce_body_to_addends</span><span class="antiquote">}</span></span> explicitly,›</span>
<span class="comment1">― ‹as the default rules that <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">text</span> <span class="raw_text">auto</span><span class="antiquote">}</span></span> uses to prove it apply here too.›</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This refinement step
defines the top-level structure of the body,
reducing the constraints on the body
to simpler constraints on its components.›</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Step 4›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:refI:stepIV}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The second-to-last conjunct in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> spec<span class="hidden">⇩</span><sub>3</sub><span class="antiquote"><span class="antiquote">}</span></span></span></span>
suggests to split <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"f <span class="free"><span class="free">x</span></span> <span class="free"><span class="free">y</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> into two addends
to be computed by <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">e<span class="hidden">⇩</span><sub>1</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">e<span class="hidden">⇩</span><sub>2</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The addends <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="numeral"><span class="numeral">3</span></span><span class="main"><span class="main">::</span></span>nat<span class="main"><span class="main">)</span></span> <span class="main"><span class="main">*</span></span> <span class="free"><span class="free">x</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="numeral"><span class="numeral">2</span></span><span class="main"><span class="main">::</span></span>nat<span class="main"><span class="main">)</span></span> <span class="main"><span class="main">*</span></span> <span class="free"><span class="free">y</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
suggested by the definition of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> f<span class="antiquote"><span class="antiquote">}</span></span></span></span>
would lead to a blind alley,
where the cost constraints could not be satisfied---%
the resulting <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">spec<span class="hidden">⇩</span><sub>4</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> would be always false.
The refinement step would be ``correct'' (by strict inclusion)
but the refinement sequence could never reach an implementation.
It would be necessary to backtrack to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> spec<span class="hidden">⇩</span><sub>3</sub><span class="antiquote"><span class="antiquote">}</span></span></span></span>
and split <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"f <span class="free"><span class="free">x</span></span> <span class="free"><span class="free">y</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> differently.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹To avoid the blind alley,
the definition of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> f<span class="antiquote"><span class="antiquote">}</span></span></span></span> is rephrased as follows.›</span></span>

<span class="keyword1" id="First_Example-f_rephrased"><span class="command">lemma</span></span> f_rephrased<span class="main">:</span>
  <span class="quoted"><span class="quoted">"f <span class="free">x</span> <span class="free">y</span> <span class="main">=</span> <span class="free">x</span> <span class="main">+</span> <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="free">x</span> <span class="main">+</span> <span class="numeral">2</span> <span class="main">*</span> <span class="free">y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> f_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This rephrased definition of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> f<span class="antiquote"><span class="antiquote">}</span></span></span></span>
does not use the multiplication by 3 of the original definition,
which is not (directly) supported by the target language;
it only uses operations supported by the language.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Using <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_rephrased›</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> spec<span class="hidden">⇩</span><sub>3</sub><span class="antiquote"><span class="antiquote">}</span></span></span></span> is refined as follows.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">spec<span class="hidden">⇩</span><sub>4</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"prog <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">spec<span class="hidden">⇩</span><sub>4</sub></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span>
  para <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">[</span><span class="inner_quoted">''x''</span><span class="main">,</span> <span class="inner_quoted">''y''</span><span class="main">]</span> <span class="main">∧</span>
  <span class="main">(</span><span class="main">∃</span><span class="bound">e<span class="hidden">⇩</span><sub>1</sub></span> <span class="bound">e<span class="hidden">⇩</span><sub>2</sub></span><span class="main">.</span>
    body <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> Add <span class="bound">e<span class="hidden">⇩</span><sub>1</sub></span> <span class="bound">e<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">∧</span>
    wfe Γ<span class="hidden">⇩</span><sub>x</sub><span class="hidden">⇩</span><sub>y</sub> <span class="bound">e<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">∧</span>
    wfe Γ<span class="hidden">⇩</span><sub>x</sub><span class="hidden">⇩</span><sub>y</sub> <span class="bound">e<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">∧</span>
    <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> eval <span class="main">(</span>ℰ<span class="hidden">⇩</span><sub>x</sub><span class="hidden">⇩</span><sub>y</sub> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span> <span class="bound">e<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">=</span> Some <span class="bound">x</span><span class="main">)</span> <span class="main">∧</span>
    <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> eval <span class="main">(</span>ℰ<span class="hidden">⇩</span><sub>x</sub><span class="hidden">⇩</span><sub>y</sub> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span> <span class="bound">e<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">=</span> Some <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="bound">x</span> <span class="main">+</span> <span class="numeral">2</span> <span class="main">*</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
    coste <span class="bound">e<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">+</span> coste <span class="bound">e<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">≤</span> <span class="numeral">2</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="First_Example-step_4_correct"><span class="command">lemma</span></span> step_4_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"spec<span class="hidden">⇩</span><sub>4</sub> <span class="free">p</span> <span class="main">⟹</span> spec<span class="hidden">⇩</span><sub>3</sub> <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> spec<span class="hidden">⇩</span><sub>4</sub>_def spec<span class="hidden">⇩</span><sub>3</sub>_def add_opt_def f_rephrased<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This refinement step reduces
the functional constraint on the body
to simpler functional constraints on the addends.
The functional constraint can be decomposed in different ways,
some of which are incompatible with the non-functional cost constraint:
blind alleys are avoided
by taking the non-functional constraint into account.›</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Step 5›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:refI:stepV}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The term <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">x</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
in the third-to-last conjunct in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> spec<span class="hidden">⇩</span><sub>4</sub><span class="antiquote"><span class="antiquote">}</span></span></span></span>
is a shallow embedding of the program expression \verb|x|,
whose deep embedding is the term <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"Var <span class="inner_quoted"><span class="inner_quoted">''x''</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
Using the latter as <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">e<span class="hidden">⇩</span><sub>1</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>,
the third-to-last conjunct in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> spec<span class="hidden">⇩</span><sub>4</sub><span class="antiquote"><span class="antiquote">}</span></span></span></span> is satisfied;
the expression is well-formed and has cost 0.›</span></span>

<span class="keyword1" id="First_Example-first_addend"><span class="command">lemma</span></span> first_addend<span class="main">:</span> <span class="quoted"><span class="quoted">"
  <span class="free">e<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">=</span> Var <span class="inner_quoted">''x''</span> <span class="main">⟹</span>
  eval <span class="main">(</span>ℰ<span class="hidden">⇩</span><sub>x</sub><span class="hidden">⇩</span><sub>y</sub> <span class="free">x</span> <span class="free">y</span><span class="main">)</span> <span class="free">e<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">=</span> Some <span class="free">x</span> <span class="main">∧</span>
  wfe Γ<span class="hidden">⇩</span><sub>x</sub><span class="hidden">⇩</span><sub>y</sub> <span class="free">e<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">∧</span>
  coste <span class="free">e<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">=</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Adding <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">e<span class="hidden">⇩</span><sub>1</sub></span></span> <span class="main"><span class="main">=</span></span> Var <span class="inner_quoted"><span class="inner_quoted">''x''</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> as a conjunct to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> spec<span class="hidden">⇩</span><sub>4</sub><span class="antiquote"><span class="antiquote">}</span></span></span></span>
and simplifying,
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> spec<span class="hidden">⇩</span><sub>4</sub><span class="antiquote"><span class="antiquote">}</span></span></span></span> is refined as follows.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">spec<span class="hidden">⇩</span><sub>5</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"prog <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">spec<span class="hidden">⇩</span><sub>5</sub></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span>
  para <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">[</span><span class="inner_quoted">''x''</span><span class="main">,</span> <span class="inner_quoted">''y''</span><span class="main">]</span> <span class="main">∧</span>
  <span class="main">(</span><span class="main">∃</span><span class="bound">e<span class="hidden">⇩</span><sub>2</sub></span><span class="main">.</span>
    body <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> Add <span class="main">(</span>Var <span class="inner_quoted">''x''</span><span class="main">)</span> <span class="bound">e<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">∧</span>
    wfe Γ<span class="hidden">⇩</span><sub>x</sub><span class="hidden">⇩</span><sub>y</sub> <span class="bound">e<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">∧</span>
    <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> eval <span class="main">(</span>ℰ<span class="hidden">⇩</span><sub>x</sub><span class="hidden">⇩</span><sub>y</sub> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span> <span class="bound">e<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">=</span> Some <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="bound">x</span> <span class="main">+</span> <span class="numeral">2</span> <span class="main">*</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
    coste <span class="bound">e<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">≤</span> <span class="numeral">2</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="First_Example-step_5_correct"><span class="command">lemma</span></span> step_5_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"spec<span class="hidden">⇩</span><sub>5</sub> <span class="free">p</span> <span class="main">⟹</span> spec<span class="hidden">⇩</span><sub>4</sub> <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> spec<span class="hidden">⇩</span><sub>5</sub>_def spec<span class="hidden">⇩</span><sub>4</sub>_def<span class="main">)</span>
<span class="comment1">― ‹No need to use <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">text</span> <span class="raw_text">first_addend</span><span class="antiquote">}</span></span> explicitly,›</span>
<span class="comment1">― ‹as the default rules that <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">text</span> <span class="raw_text">auto</span><span class="antiquote">}</span></span> uses to prove it apply here too.›</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This refinement step determines the first addend of the body,
leaving only the second addend to be determined.›</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Step 6›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:refI:stepVI}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The term <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="numeral"><span class="numeral">2</span></span><span class="main"><span class="main">::</span></span>nat<span class="main"><span class="main">)</span></span> <span class="main"><span class="main">*</span></span> <span class="free"><span class="free">x</span></span> <span class="main"><span class="main">+</span></span> <span class="numeral"><span class="numeral">2</span></span> <span class="main"><span class="main">*</span></span> <span class="free"><span class="free">y</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
in the second-to-last conjunct of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> spec<span class="hidden">⇩</span><sub>5</sub><span class="antiquote"><span class="antiquote">}</span></span></span></span>
is a shallow embedding of the program expression \verb|2 * x + 2 * y|,
whose deep embedding is the term
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"Add <span class="main"><span class="main">(</span></span>Double <span class="main"><span class="main">(</span></span>Var <span class="inner_quoted"><span class="inner_quoted">''x''</span></span><span class="main"><span class="main">)</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">(</span></span>Double <span class="main"><span class="main">(</span></span>Var <span class="inner_quoted"><span class="inner_quoted">''y''</span></span><span class="main"><span class="main">)</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
Using the latter as <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">e<span class="hidden">⇩</span><sub>2</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>,
the second-to-last conjunct in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> spec<span class="hidden">⇩</span><sub>5</sub><span class="antiquote"><span class="antiquote">}</span></span></span></span> is satisfied,
but the last conjunct is not.
The following factorization of the shallowly embedded expression
leads to a reduced cost of the corresponding deeply embedded expression.›</span></span>

<span class="keyword1" id="First_Example-factorization"><span class="command">lemma</span></span> factorization<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="numeral">2</span><span class="main">::</span>nat<span class="main">)</span> <span class="main">*</span> <span class="free">x</span> <span class="main">+</span> <span class="numeral">2</span> <span class="main">*</span> <span class="free">y</span> <span class="main">=</span> <span class="numeral">2</span> <span class="main">*</span> <span class="main">(</span><span class="free">x</span> <span class="main">+</span> <span class="free">y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The deeply embedded expression
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"Double <span class="main"><span class="main">(</span></span>Add <span class="main"><span class="main">(</span></span>Var <span class="inner_quoted"><span class="inner_quoted">''x''</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">(</span></span>Var <span class="inner_quoted"><span class="inner_quoted">''y''</span></span><span class="main"><span class="main">)</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>,
which corresponds to the shallowly embedded expression
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="numeral"><span class="numeral">2</span></span><span class="main"><span class="main">::</span></span>nat<span class="main"><span class="main">)</span></span> <span class="main"><span class="main">*</span></span> <span class="main"><span class="main">(</span></span><span class="free"><span class="free">x</span></span> <span class="main"><span class="main">+</span></span> <span class="free"><span class="free">y</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>,
satisfies the second-to-last conjunct of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> spec<span class="hidden">⇩</span><sub>5</sub><span class="antiquote"><span class="antiquote">}</span></span></span></span>,
is well-formed,
and has cost 2.›</span></span>

<span class="keyword1" id="First_Example-second_addend"><span class="command">lemma</span></span> second_addend<span class="main">:</span> <span class="quoted"><span class="quoted">"
  <span class="free">e<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">=</span> Double <span class="main">(</span>Add <span class="main">(</span>Var <span class="inner_quoted">''x''</span><span class="main">)</span> <span class="main">(</span>Var <span class="inner_quoted">''y''</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span>
  eval <span class="main">(</span>ℰ<span class="hidden">⇩</span><sub>x</sub><span class="hidden">⇩</span><sub>y</sub> <span class="free">x</span> <span class="free">y</span><span class="main">)</span> <span class="free">e<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">=</span> Some <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="free">x</span> <span class="main">+</span> <span class="numeral">2</span> <span class="main">*</span> <span class="free">y</span><span class="main">)</span> <span class="main">∧</span>
  wfe Γ<span class="hidden">⇩</span><sub>x</sub><span class="hidden">⇩</span><sub>y</sub> <span class="free">e<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">∧</span>
  coste <span class="free">e<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">=</span> <span class="numeral">2</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> add_opt_def mul_opt_def<span class="main">)</span>
<span class="comment1">― ‹No need to use <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">text</span> <span class="raw_text">factorization</span><span class="antiquote">}</span></span> explicitly,›</span>
<span class="comment1">― ‹as the default rules that <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">text</span> <span class="raw_text">auto</span><span class="antiquote">}</span></span> uses to prove it apply here too.›</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Adding <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">e<span class="hidden">⇩</span><sub>2</sub></span></span> <span class="main"><span class="main">=</span></span> Double <span class="main"><span class="main">(</span></span>Add <span class="main"><span class="main">(</span></span>Var <span class="inner_quoted"><span class="inner_quoted">''x''</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">(</span></span>Var <span class="inner_quoted"><span class="inner_quoted">''y''</span></span><span class="main"><span class="main">)</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
as a conjunct to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> spec<span class="hidden">⇩</span><sub>5</sub><span class="antiquote"><span class="antiquote">}</span></span></span></span>
and simplifying,
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> spec<span class="hidden">⇩</span><sub>5</sub><span class="antiquote"><span class="antiquote">}</span></span></span></span> is refined as follows.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">spec<span class="hidden">⇩</span><sub>6</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"prog <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">spec<span class="hidden">⇩</span><sub>6</sub></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span>
  para <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">[</span><span class="inner_quoted">''x''</span><span class="main">,</span> <span class="inner_quoted">''y''</span><span class="main">]</span> <span class="main">∧</span>
  body <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> Add <span class="main">(</span>Var <span class="inner_quoted">''x''</span><span class="main">)</span> <span class="main">(</span>Double <span class="main">(</span>Add <span class="main">(</span>Var <span class="inner_quoted">''x''</span><span class="main">)</span> <span class="main">(</span>Var <span class="inner_quoted">''y''</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="First_Example-step_6_correct"><span class="command">lemma</span></span> step_6_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"spec<span class="hidden">⇩</span><sub>6</sub> <span class="free">p</span> <span class="main">⟹</span> spec<span class="hidden">⇩</span><sub>5</sub> <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> spec<span class="hidden">⇩</span><sub>6</sub>_def spec<span class="hidden">⇩</span><sub>5</sub>_def second_addend <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> eval.simps<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This refinement step determines the second addend of the body,
leaving nothing else to be determined.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This and the previous refinement step
turn semantic constraints on the program components <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">e<span class="hidden">⇩</span><sub>1</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">e<span class="hidden">⇩</span><sub>2</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
into syntactic definitions of such components.›</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Step 7›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:refI:stepVII}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> spec<span class="hidden">⇩</span><sub>6</sub><span class="antiquote"><span class="antiquote">}</span></span></span></span>, which defines the parameters and body,
is refined to characterize a unique program in explicit syntactic form.›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">p<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">::</span> <span class="quoted">prog</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">p<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">≡</span>
  <span class="main">⦇</span>para <span class="main">=</span> <span class="main">[</span><span class="inner_quoted">''x''</span><span class="main">,</span> <span class="inner_quoted">''y''</span><span class="main">]</span><span class="main">,</span>
   body <span class="main">=</span> Add <span class="main">(</span>Var <span class="inner_quoted">''x''</span><span class="main">)</span> <span class="main">(</span>Double <span class="main">(</span>Add <span class="main">(</span>Var <span class="inner_quoted">''x''</span><span class="main">)</span> <span class="main">(</span>Var <span class="inner_quoted">''y''</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">⦈</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">spec<span class="hidden">⇩</span><sub>7</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"prog <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">spec<span class="hidden">⇩</span><sub>7</sub></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> p<span class="hidden">⇩</span><sub>0</sub>"</span></span>

<span class="keyword1" id="First_Example-step_7_correct"><span class="command">lemma</span></span> step_7_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"spec<span class="hidden">⇩</span><sub>7</sub> <span class="free">p</span> <span class="main">⟹</span> spec<span class="hidden">⇩</span><sub>6</sub> <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> spec<span class="hidden">⇩</span><sub>7</sub>_def spec<span class="hidden">⇩</span><sub>6</sub>_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The program satisfies <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> spec<span class="hidden">⇩</span><sub>0</sub><span class="antiquote"><span class="antiquote">}</span></span></span></span> by construction.
The program witnesses the consistency of the requirements,
i.e.\ the fact that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> spec<span class="hidden">⇩</span><sub>0</sub><span class="antiquote"><span class="antiquote">}</span></span></span></span> is not always false.›</span></span>

<span class="keyword1" id="First_Example-p"><span class="command">lemma</span></span> p<span class="hidden">⇩</span><sub>0</sub>_sat_spec<span class="hidden">⇩</span><sub>0</sub><span class="main">:</span>
  <span class="quoted"><span class="quoted">"spec<span class="hidden">⇩</span><sub>0</sub> p<span class="hidden">⇩</span><sub>0</sub>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span>
 step_1_correct
 step_2_correct
 step_3_correct
 step_4_correct
 step_5_correct
 step_6_correct
 step_7_correct
 spec<span class="hidden">⇩</span><sub>7</sub>_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹From <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> p<span class="hidden">⇩</span><sub>0</sub><span class="antiquote"><span class="antiquote">}</span></span></span></span>, the program text
\begin{verbatim}
  prog (x,y) {x + 2 * (x + y)}
\end{verbatim}
is easily obtained.›</span></span>


<span class="keyword2"><span class="keyword">end</span></span> <span class="main">%</span>invisible
</pre>
</div><div id="Second_Example">
<div class="head">
<h1>Theory Second_Example</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">chapter</span></span> <span class="quoted"><span class="plain_text">‹Second Example›</span></span>

<span class="keyword1"><span class="command">theory</span></span> <span class="main">%</span>invisible Second_Example
<span class="keyword2"><span class="keyword">imports</span></span> <a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{chap:exampleII}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Pop-refinement is illustrated via a simple derivation,
in Isabelle/HOL,
of a non-deterministic program that satisfies a hyperproperty.›</span></span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Hyperproperties›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:hyper}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Hyperproperties are predicates over sets of traces~%
\cite{ClarksonSchneiderHyperproperties}.
Hyperproperties capture security policies
like non-interference~\cite{GoguenMeseguerNonInterference},
which applies to deterministic systems,
and generalized non-interference (GNI)~\cite{McCulloughSpecificationsMLS},
which generalizes non-interference to non-deterministic systems.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The formulation of GNI in~\cite{ClarksonSchneiderHyperproperties},
which is derived from~\cite{McLeanPossibilisticProperties},
is based on:
\begin{itemize}
\item
A notion of traces as infinite streams of abstract states.
\item
Functions that map each state to low and high inputs and outputs,
where `low' and `high' have the usual security meaning
(e.g.\ `low' means `unclassified' and `high' means `classified').
These functions are homomorphically extended to map each trace
to infinite streams of low and high inputs and outputs.
\end{itemize}
The following formulation is slightly more general,
because the functions that return low and high inputs and outputs
operate directly on abstract traces.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹GNI says that for any two traces <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">τ<span class="hidden">⇩</span><sub>1</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">τ<span class="hidden">⇩</span><sub>2</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>,
there is always a trace <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">τ<span class="hidden">⇩</span><sub>3</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> with
the same high inputs as <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">τ<span class="hidden">⇩</span><sub>1</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
and the same low inputs and low outputs as <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">τ<span class="hidden">⇩</span><sub>2</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
Intuitively, this means that a low observer
(i.e.\ one that only observes low inputs and low outputs of traces)
cannot gain any information about high inputs
(i.e.\ high inputs cannot interfere with low outputs)
because observing a trace <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">τ<span class="hidden">⇩</span><sub>2</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
is indistinguishable from observing some other trace <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">τ<span class="hidden">⇩</span><sub>3</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
that has the same high inputs as an arbitrary trace <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">τ<span class="hidden">⇩</span><sub>1</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>

<span class="keyword1"><span class="command">locale</span></span> generalized_non_interference <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">low_in</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'τ</span> <span class="main">⇒</span> <span class="tfree">'i</span>"</span></span> <span class="comment1">― ‹low inputs›</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">low_out</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'τ</span> <span class="main">⇒</span> <span class="tfree">'o</span>"</span></span> <span class="comment1">― ‹low outputs›</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">high_in</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'τ</span> <span class="main">⇒</span> <span class="tfree">'i</span>"</span></span> <span class="comment1">― ‹high inputs›</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">high_out</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'τ</span> <span class="main">⇒</span> <span class="tfree">'o</span>"</span></span> <span class="comment1">― ‹high outputs›</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> generalized_non_interference<span class="main">)</span> <span class="entity">GNI</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'τ</span> set <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">GNI</span> <span class="free"><span class="bound"><span class="entity">𝒯</span></span></span> <span class="main">≡</span>
  <span class="main">∀</span><span class="bound">τ<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">𝒯</span></span></span><span class="main">.</span> <span class="main">∀</span><span class="bound">τ<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">𝒯</span></span></span><span class="main">.</span> <span class="main">∃</span><span class="bound">τ<span class="hidden">⇩</span><sub>3</sub></span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">𝒯</span></span></span><span class="main">.</span>
    <span class="free">high_in</span> <span class="bound">τ<span class="hidden">⇩</span><sub>3</sub></span> <span class="main">=</span> <span class="free">high_in</span> <span class="bound">τ<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">∧</span> <span class="free">low_in</span> <span class="bound">τ<span class="hidden">⇩</span><sub>3</sub></span> <span class="main">=</span> <span class="free">low_in</span> <span class="bound">τ<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">∧</span> <span class="free">low_out</span> <span class="bound">τ<span class="hidden">⇩</span><sub>3</sub></span> <span class="main">=</span> <span class="free">low_out</span> <span class="bound">τ<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Target Programming Language›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:targetII}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In the target language used in this example,%
\footnote{Even though this language has many similarities
with the language in \secref{sec:targetI},
the two languages are defined separately
to keep \chapref{chap:exampleI} simpler.}
a program consists of
a list of distinct state variables
and a body of statements.
The statements modify the variables
by deterministically assigning results of expressions
and by non-deterministically assigning random values.
Expressions are built out of
non-negative integer constants,
state variables,
and addition operations.
Statements are combined
via conditionals, whose tests compare expressions for equality,
and via sequencing.
Each variable stores a non-negative integer.
Executing the body in a state yields a new state.
Because of non-determinism, different new states are possible,
i.e.\ executing the body in the same state
may yield different new states at different times.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹For instance, executing the body of the program
\begin{verbatim}
  prog {
    vars {
      x
      y
    }
    body {
      if (x == y + 1) {
        x = 0;
      } else {
        x = y + 3;
      }
      randomize y;
      y = y + 2;
    }
  }
\end{verbatim}
in the state where \verb|x| contains 4 and \verb|y| contains 7,
yields a new state where
\verb|x| always contains 10
and \verb|y| may contain any number in $\{2,3,\ldots\}$.›</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Syntax›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:syntaxII}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Variables are identified by names.›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> name <span class="main">=</span> <span class="quoted">string</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Expressions are built out of
constants, variables, and addition operations.›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> expr <span class="main">=</span> Const <span class="quoted">nat</span> <span class="main">|</span> Var <span class="quoted">name</span> <span class="main">|</span> Add <span class="quoted">expr</span> <span class="quoted">expr</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Statements are built out of
deterministic assignments,
non-deterministic assignments,
conditionals,
and sequencing.›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> stmt <span class="main">=</span>
  Assign <span class="quoted">name</span> <span class="quoted">expr</span> <span class="main">|</span>
  Random <span class="quoted">name</span> <span class="main">|</span>
  IfEq <span class="quoted">expr</span> <span class="quoted">expr</span> <span class="quoted">stmt</span> <span class="quoted">stmt</span> <span class="main">|</span>
  Seq <span class="quoted">stmt</span> <span class="quoted">stmt</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A program consists of
a list of state variables
and a body statement.›</span></span>

<span class="keyword1"><span class="command">record</span></span> prog <span class="main">=</span>
  vars <span class="main">::</span> <span class="quoted"><span class="quoted">"name list"</span></span>
  body <span class="main">::</span> <span class="quoted">stmt</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Static Semantics›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:staticII}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A context is a set of variables.›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> ctxt <span class="main">=</span> <span class="quoted"><span class="quoted">"name set"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Given a context,
an expression is well-formed iff\
all its variables are in the context.›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">wfe</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"ctxt <span class="main">⇒</span> expr <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">wfe</span> <span class="free"><span class="bound"><span class="entity">Γ</span></span></span> <span class="main">(</span>Const <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">)</span> <span class="main">⟷</span> True"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">wfe</span> <span class="free"><span class="bound"><span class="entity">Γ</span></span></span> <span class="main">(</span>Var <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">Γ</span></span></span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">wfe</span> <span class="free"><span class="bound"><span class="entity">Γ</span></span></span> <span class="main">(</span>Add <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>2</sub></span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="free">wfe</span> <span class="free"><span class="bound"><span class="entity">Γ</span></span></span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="main">∧</span> <span class="free">wfe</span> <span class="free"><span class="bound"><span class="entity">Γ</span></span></span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>2</sub></span></span></span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Given a context,
a statement is well-formed iff\
its deterministic assignments
assign well-formed expressions to variables in the context,
its non-deterministic assignments operate on variables in the context,
and its conditional tests compare well-formed expressions.›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">wfs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"ctxt <span class="main">⇒</span> stmt <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">wfs</span> <span class="free"><span class="bound"><span class="entity">Γ</span></span></span> <span class="main">(</span>Assign <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">Γ</span></span></span> <span class="main">∧</span> wfe <span class="free"><span class="bound"><span class="entity">Γ</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">wfs</span> <span class="free"><span class="bound"><span class="entity">Γ</span></span></span> <span class="main">(</span>Random <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">Γ</span></span></span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">wfs</span> <span class="free"><span class="bound"><span class="entity">Γ</span></span></span> <span class="main">(</span>IfEq <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">s<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">s<span class="hidden">⇩</span><sub>2</sub></span></span></span><span class="main">)</span> <span class="main">⟷</span> wfe <span class="free"><span class="bound"><span class="entity">Γ</span></span></span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="main">∧</span> wfe <span class="free"><span class="bound"><span class="entity">Γ</span></span></span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="main">∧</span> <span class="free">wfs</span> <span class="free"><span class="bound"><span class="entity">Γ</span></span></span> <span class="free"><span class="bound"><span class="entity">s<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="main">∧</span> <span class="free">wfs</span> <span class="free"><span class="bound"><span class="entity">Γ</span></span></span> <span class="free"><span class="bound"><span class="entity">s<span class="hidden">⇩</span><sub>2</sub></span></span></span>"</span></span> <span class="main">|</span>
  <span class="quoted"><span class="quoted">"<span class="free">wfs</span> <span class="free"><span class="bound"><span class="entity">Γ</span></span></span> <span class="main">(</span>Seq <span class="free"><span class="bound"><span class="entity">s<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">s<span class="hidden">⇩</span><sub>2</sub></span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="free">wfs</span> <span class="free"><span class="bound"><span class="entity">Γ</span></span></span> <span class="free"><span class="bound"><span class="entity">s<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="main">∧</span> <span class="free">wfs</span> <span class="free"><span class="bound"><span class="entity">Γ</span></span></span> <span class="free"><span class="bound"><span class="entity">s<span class="hidden">⇩</span><sub>2</sub></span></span></span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The context of a program consists of the state variables.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ctxt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"prog <span class="main">⇒</span> ctxt"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ctxt</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span> set <span class="main">(</span>vars <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A program is well-formed iff\
the variables are distinct
and the body is well-formed in the context of the program.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">wfp</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"prog <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">wfp</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span> distinct <span class="main">(</span>vars <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="main">∧</span> wfs <span class="main">(</span>ctxt <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="main">(</span>body <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span>"</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Dynamic Semantics›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:dynamicII}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A state associates values (non-negative integers) to variables.›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> state <span class="main">=</span> <span class="quoted"><span class="quoted">"name <span class="main">⇀</span> nat"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A state matches a context iff\
state and context have the same variables.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">match</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"state <span class="main">⇒</span> ctxt <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">match</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="free"><span class="bound"><span class="entity">Γ</span></span></span> <span class="main">≡</span> dom <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">Γ</span></span></span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Evaluating an expression in a state yields a value,
or an error (<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> None<span class="antiquote"><span class="antiquote">}</span></span></span></span>)
if the expression contains a variable not in the state.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">add_opt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat option <span class="main">⇒</span> nat option <span class="main">⇒</span> nat option"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">⊕</span>"</span> 65<span class="main">)</span>
<span class="comment1">― ‹Lifting of addition to <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"nat option"</span><span class="antiquote">}</span></span>.›</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">U<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="main"><span class="free">⊕</span></span> <span class="free"><span class="bound"><span class="entity">U<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="main">≡</span>
  <span class="keyword1">case</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">U<span class="hidden">⇩</span><sub>1</sub></span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">U<span class="hidden">⇩</span><sub>2</sub></span></span></span><span class="main">)</span> <span class="keyword1">of</span> <span class="main">(</span>Some <span class="bound">u<span class="hidden">⇩</span><sub>1</sub></span><span class="main">,</span> Some <span class="bound">u<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span> <span class="main">⇒</span> Some <span class="main">(</span><span class="bound">u<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">+</span> <span class="bound">u<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span> <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> None"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">eval</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"state <span class="main">⇒</span> expr <span class="main">⇒</span> nat option"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
 <span class="quoted"><span class="quoted">"<span class="free">eval</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main">(</span>Const <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">)</span> <span class="main">=</span> Some <span class="free"><span class="bound"><span class="entity">c</span></span></span>"</span></span> <span class="main">|</span>
 <span class="quoted"><span class="quoted">"<span class="free">eval</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main">(</span>Var <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span>"</span></span> <span class="main">|</span>
 <span class="quoted"><span class="quoted">"<span class="free">eval</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main">(</span>Add <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>2</sub></span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">eval</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="main">⊕</span> <span class="free">eval</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>2</sub></span></span></span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Evaluating a well-formed expression never yields an error,
if the state matches the context.›</span></span>

<span class="keyword1" id="Second_Example-eval_wfe"><span class="command">lemma</span></span> eval_wfe<span class="main">:</span>
  <span class="quoted"><span class="quoted">"wfe <span class="free">Γ</span> <span class="free">e</span> <span class="main">⟹</span> match <span class="free">σ</span> <span class="free">Γ</span> <span class="main">⟹</span> eval <span class="free">σ</span> <span class="free">e</span> <span class="main">≠</span> None"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">e</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> match_def add_opt_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Executing a statement in a state yields a new state,
or an error (<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> None<span class="antiquote"><span class="antiquote">}</span></span></span></span>)
if the evaluation of an expression yields an error
or if an assignment operates on a variable not in the state.
Non-determinism is modeled via a relation
between old states and results,
where a result is either a new state or an error.›</span></span>

<span class="keyword1"><span class="command">inductive</span></span> <span class="entity">exec</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"stmt <span class="main">⇒</span> state <span class="main">⇒</span> state option <span class="main">⇒</span> bool"</span></span>
  <span class="main">(</span><span class="quoted">"_ <span class="keyword1">⊳</span> _ <span class="keyword1">↝</span> _"</span> <span class="main">[</span>50<span class="main">,</span> 50<span class="main">,</span> 50<span class="main">]</span> 50<span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span>
  ExecAssignNoVar<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">∉</span> dom <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main">⟹</span> Assign <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main"><span class="free">⊳</span></span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main"><span class="free">↝</span></span> None"</span></span> <span class="main">|</span>
  ExecAssignEvalError<span class="main">:</span>
    <span class="quoted"><span class="quoted">"eval <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">=</span> None <span class="main">⟹</span> Assign <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main"><span class="free">⊳</span></span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main"><span class="free">↝</span></span> None"</span></span> <span class="main">|</span>
  ExecAssignOK<span class="main">:</span> <span class="quoted"><span class="quoted">"
    <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">∈</span> dom <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main">⟹</span>
    eval <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">=</span> Some <span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">⟹</span>
    Assign <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main"><span class="free">⊳</span></span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main"><span class="free">↝</span></span> Some <span class="main">(</span><span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">↦</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">|</span>
  ExecRandomNoVar<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">∉</span> dom <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main">⟹</span> Random <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main"><span class="free">⊳</span></span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main"><span class="free">↝</span></span> None"</span></span> <span class="main">|</span>
  ExecRandomOK<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">∈</span> dom <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main">⟹</span> Random <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main"><span class="free">⊳</span></span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main"><span class="free">↝</span></span> Some <span class="main">(</span><span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">↦</span> <span class="free"><span class="bound"><span class="entity">u</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">|</span>
  ExecCondEvalError1<span class="main">:</span>
    <span class="quoted"><span class="quoted">"eval <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="main">=</span> None <span class="main">⟹</span> IfEq <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">s<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">s<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="main"><span class="free">⊳</span></span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main"><span class="free">↝</span></span> None"</span></span> <span class="main">|</span>
  ExecCondEvalError2<span class="main">:</span>
    <span class="quoted"><span class="quoted">"eval <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="main">=</span> None <span class="main">⟹</span> IfEq <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">s<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">s<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="main"><span class="free">⊳</span></span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main"><span class="free">↝</span></span> None"</span></span> <span class="main">|</span>
  ExecCondTrue<span class="main">:</span> <span class="quoted"><span class="quoted">"
    eval <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="main">=</span> Some <span class="free"><span class="bound"><span class="entity">u<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="main">⟹</span>
    eval <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="main">=</span> Some <span class="free"><span class="bound"><span class="entity">u<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="main">⟹</span>
    <span class="free"><span class="bound"><span class="entity">u<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">u<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="main">⟹</span>
    <span class="free"><span class="bound"><span class="entity">s<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="main"><span class="free">⊳</span></span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main"><span class="free">↝</span></span> <span class="free"><span class="bound"><span class="entity">ρ</span></span></span> <span class="main">⟹</span>
    IfEq <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">s<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">s<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="main"><span class="free">⊳</span></span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main"><span class="free">↝</span></span> <span class="free"><span class="bound"><span class="entity">ρ</span></span></span>"</span></span> <span class="main">|</span>
  ExecCondFalse<span class="main">:</span> <span class="quoted"><span class="quoted">"
    eval <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="main">=</span> Some <span class="free"><span class="bound"><span class="entity">u<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="main">⟹</span>
    eval <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="main">=</span> Some <span class="free"><span class="bound"><span class="entity">u<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="main">⟹</span>
    <span class="free"><span class="bound"><span class="entity">u<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="main">≠</span> <span class="free"><span class="bound"><span class="entity">u<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="main">⟹</span>
    <span class="free"><span class="bound"><span class="entity">s<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="main"><span class="free">⊳</span></span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main"><span class="free">↝</span></span> <span class="free"><span class="bound"><span class="entity">ρ</span></span></span> <span class="main">⟹</span>
    IfEq <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">e<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">s<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">s<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="main"><span class="free">⊳</span></span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main"><span class="free">↝</span></span> <span class="free"><span class="bound"><span class="entity">ρ</span></span></span>"</span></span> <span class="main">|</span>
  ExecSeqError<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">s<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="main"><span class="free">⊳</span></span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main"><span class="free">↝</span></span> None <span class="main">⟹</span> Seq <span class="free"><span class="bound"><span class="entity">s<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">s<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="main"><span class="free">⊳</span></span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main"><span class="free">↝</span></span> None"</span></span> <span class="main">|</span>
  ExecSeqOK<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">s<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="main"><span class="free">⊳</span></span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main"><span class="free">↝</span></span> Some <span class="free"><span class="bound"><span class="entity">σ'</span></span></span> <span class="main">⟹</span> <span class="free"><span class="bound"><span class="entity">s<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="main"><span class="free">⊳</span></span> <span class="free"><span class="bound"><span class="entity">σ'</span></span></span> <span class="main"><span class="free">↝</span></span> <span class="free"><span class="bound"><span class="entity">ρ</span></span></span> <span class="main">⟹</span> Seq <span class="free"><span class="bound"><span class="entity">s<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">s<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="main"><span class="free">⊳</span></span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main"><span class="free">↝</span></span> <span class="free"><span class="bound"><span class="entity">ρ</span></span></span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The execution of any statement in any state always yields a result.›</span></span>

<span class="keyword1" id="Second_Example-exec_always"><span class="command">lemma</span></span> exec_always<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">ρ</span><span class="main">.</span> <span class="free">s</span> <span class="main">⊳</span> <span class="free">σ</span> <span class="main">↝</span> <span class="bound">ρ</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">s</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">σ</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> Assign
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span>
    ExecAssignEvalError ExecAssignNoVar ExecAssignOK option.exhaust<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> Random
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> ExecRandomNoVar ExecRandomOK<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> IfEq
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span>
    ExecCondEvalError1 ExecCondEvalError2 ExecCondFalse ExecCondTrue
    option.exhaust<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> Seq
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> ExecSeqError ExecSeqOK option.exhaust<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Executing a well-formed statement in a state that matches the context
never yields an error and always yields states that match the context.›</span></span>

<span class="keyword1" id="Second_Example-exec_wfs_match"><span class="command">lemma</span></span> exec_wfs_match<span class="main">:</span>
  <span class="quoted"><span class="quoted">"wfs <span class="free">Γ</span> <span class="free">s</span> <span class="main">⟹</span> match <span class="free">σ</span> <span class="free">Γ</span> <span class="main">⟹</span> <span class="free">s</span> <span class="main">⊳</span> <span class="free">σ</span> <span class="main">↝</span> Some <span class="free">σ'</span> <span class="main">⟹</span> match <span class="free">σ'</span> <span class="free">Γ</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">s</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">σ</span></span> <span class="quoted"><span class="free">σ'</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Assign <span class="skolem">v</span> <span class="skolem">e</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">u</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"eval <span class="skolem">σ</span> <span class="skolem">e</span> <span class="main">=</span> Some <span class="skolem">u</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">σ'</span> <span class="main">=</span> <span class="skolem">σ</span><span class="main">(</span><span class="skolem">v</span> <span class="main">↦</span> <span class="skolem">u</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> exec.cases<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> Assign
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span>
    domIff dom_fun_upd fun_upd_triv match_def option.distinct<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> wfs.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Random <span class="skolem">v</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">u</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">σ'</span> <span class="main">=</span> <span class="skolem">σ</span><span class="main">(</span><span class="skolem">v</span> <span class="main">↦</span> <span class="skolem">u</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> exec.cases<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> Random
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span>
    domIff dom_fun_upd fun_upd_triv match_def option.distinct<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> wfs.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>IfEq <span class="skolem">e<span class="hidden">⇩</span><sub>1</sub></span> <span class="skolem">e<span class="hidden">⇩</span><sub>2</sub></span> <span class="skolem">s<span class="hidden">⇩</span><sub>1</sub></span> <span class="skolem">s<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⊳</span> <span class="skolem">σ</span> <span class="main">↝</span> Some <span class="skolem">σ'</span> <span class="main">∨</span> <span class="skolem">s<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">⊳</span> <span class="skolem">σ</span> <span class="main">↝</span> Some <span class="skolem">σ'</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> exec.cases<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> IfEq
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> wfs.simps<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Seq <span class="skolem">s<span class="hidden">⇩</span><sub>1</sub></span> <span class="skolem">s<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">σ<span class="hidden">⇩</span><sub>i</sub></span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⊳</span> <span class="skolem">σ</span> <span class="main">↝</span> Some <span class="skolem">σ<span class="hidden">⇩</span><sub>i</sub></span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">⊳</span> <span class="skolem">σ<span class="hidden">⇩</span><sub>i</sub></span> <span class="main">↝</span> Some <span class="skolem">σ'</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> exec.cases<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> Seq
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> wfs.simps<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Second_Example-exec_wfs_no_error"><span class="command">lemma</span></span> exec_wfs_no_error<span class="main">:</span>
  <span class="quoted"><span class="quoted">"wfs <span class="free">Γ</span> <span class="free">s</span> <span class="main">⟹</span> match <span class="free">σ</span> <span class="free">Γ</span> <span class="main">⟹</span> <span class="main">¬</span> <span class="main">(</span><span class="free">s</span> <span class="main">⊳</span> <span class="free">σ</span> <span class="main">↝</span> None<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">s</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">σ</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Assign <span class="skolem">v</span> <span class="skolem">e</span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> Var<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span> <span class="main">∈</span> dom <span class="skolem">σ</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> match_def<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> Assign
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"eval <span class="skolem">σ</span> <span class="skolem">e</span> <span class="main">≠</span> None"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> eval_wfe wfs.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> Var
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> exec.cases<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Random <span class="skolem">v</span><span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> match_def <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> exec.cases<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>IfEq <span class="skolem">e<span class="hidden">⇩</span><sub>1</sub></span> <span class="skolem">e<span class="hidden">⇩</span><sub>2</sub></span> <span class="skolem">s<span class="hidden">⇩</span><sub>1</sub></span> <span class="skolem">s<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">u<span class="hidden">⇩</span><sub>1</sub></span></span> <span class="skolem"><span class="skolem">u<span class="hidden">⇩</span><sub>2</sub></span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"eval <span class="skolem">σ</span> <span class="skolem">e<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">=</span> Some <span class="skolem">u<span class="hidden">⇩</span><sub>1</sub></span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"eval <span class="skolem">σ</span> <span class="skolem">e<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">=</span> Some <span class="skolem">u<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> eval_wfe not_Some_eq wfs.simps<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> IfEq
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> exec.cases<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Seq <span class="skolem">s<span class="hidden">⇩</span><sub>1</sub></span> <span class="skolem">s<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"Seq <span class="skolem">s<span class="hidden">⇩</span><sub>1</sub></span> <span class="skolem">s<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">⊳</span> <span class="skolem">σ</span> <span class="main">↝</span> None"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⊳</span> <span class="skolem">σ</span> <span class="main">↝</span> None <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">σ'</span><span class="main">.</span> <span class="skolem">s<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⊳</span> <span class="skolem">σ</span> <span class="main">↝</span> Some <span class="bound">σ'</span> <span class="main">∧</span> <span class="skolem">s<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">⊳</span> <span class="bound">σ'</span> <span class="main">↝</span> None<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> exec.cases<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> Seq exec_wfs_match
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> wfs.simps<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Second_Example-exec_wfs_always_match"><span class="command">lemma</span></span> exec_wfs_always_match<span class="main">:</span>
  <span class="quoted"><span class="quoted">"wfs <span class="free">Γ</span> <span class="free">s</span> <span class="main">⟹</span> match <span class="free">σ</span> <span class="free">Γ</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">σ'</span><span class="main">.</span> <span class="free">s</span> <span class="main">⊳</span> <span class="free">σ</span> <span class="main">↝</span> Some <span class="bound">σ'</span> <span class="main">∧</span> match <span class="bound">σ'</span> <span class="free">Γ</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> exec_always exec_wfs_match exec_wfs_no_error option.exhaust<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The states of a program
are the ones that match the context of the program.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">states</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"prog <span class="main">⇒</span> state set"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">states</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span> <span class="main">{</span><span class="bound">σ</span><span class="main">.</span> match <span class="bound">σ</span> <span class="main">(</span>ctxt <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Executing the body of a well-formed program in a state of the program
always yields some state of the program, and never an error.›</span></span>

<span class="keyword1" id="Second_Example-exec_wfp_no_error"><span class="command">lemma</span></span> exec_wfp_no_error<span class="main">:</span>
  <span class="quoted"><span class="quoted">"wfp <span class="free">p</span> <span class="main">⟹</span> <span class="free">σ</span> <span class="main">∈</span> states <span class="free">p</span> <span class="main">⟹</span> <span class="main">¬</span> <span class="main">(</span>body <span class="free">p</span> <span class="main">⊳</span> <span class="free">σ</span> <span class="main">↝</span> None<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> exec_wfs_no_error mem_Collect_eq states_def wfp_def<span class="main">)</span>

<span class="keyword1" id="Second_Example-exec_wfp_in_states"><span class="command">lemma</span></span> exec_wfp_in_states<span class="main">:</span>
  <span class="quoted"><span class="quoted">"wfp <span class="free">p</span> <span class="main">⟹</span> <span class="free">σ</span> <span class="main">∈</span> states <span class="free">p</span> <span class="main">⟹</span> body <span class="free">p</span> <span class="main">⊳</span> <span class="free">σ</span> <span class="main">↝</span> Some <span class="free">σ'</span> <span class="main">⟹</span> <span class="free">σ'</span> <span class="main">∈</span> states <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> exec_wfs_match mem_Collect_eq states_def wfp_def<span class="main">)</span>

<span class="keyword1" id="Second_Example-exec_wfp_always_in_states"><span class="command">lemma</span></span> exec_wfp_always_in_states<span class="main">:</span>
  <span class="quoted"><span class="quoted">"wfp <span class="free">p</span> <span class="main">⟹</span> <span class="free">σ</span> <span class="main">∈</span> states <span class="free">p</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">σ'</span><span class="main">.</span> body <span class="free">p</span> <span class="main">⊳</span> <span class="free">σ</span> <span class="main">↝</span> Some <span class="bound">σ'</span> <span class="main">∧</span> <span class="bound">σ'</span> <span class="main">∈</span> states <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> exec_always exec_wfp_in_states exec_wfp_no_error option.exhaust<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Program execution can be described
in terms of the trace formalism in~\cite{ClarksonSchneiderHyperproperties}.
Every possible (non-erroneous) execution of a program
can be described by a trace of two states---initial and final.
In this definition,
erroneous executions do not contribute to the traces of a program;
only well-formed programs are of interest,
which, as proved above, never execute erroneously.
Due to non-determinism, there may be traces
with the same initial state and different final states.›</span></span>

<span class="keyword1"><span class="command">record</span></span> trace <span class="main">=</span>
  initial <span class="main">::</span> <span class="quoted">state</span>
  final <span class="main">::</span> <span class="quoted">state</span>

<span class="keyword1"><span class="command">inductive_set</span></span> <span class="entity">traces</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"prog <span class="main">⇒</span> trace set"</span></span>
<span class="keyword2"><span class="keyword">for</span></span> <span class="entity">p</span><span class="main">::</span><span class="quoted">prog</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"
  <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main">∈</span> states <span class="free">p</span> <span class="main">⟹</span>
  body <span class="free">p</span> <span class="main">⊳</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span> <span class="main">↝</span> Some <span class="free"><span class="bound"><span class="entity">σ'</span></span></span> <span class="main">⟹</span>
  <span class="main">⦇</span>initial <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">σ</span></span></span><span class="main">,</span> final <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">σ'</span></span></span><span class="main">⦈</span> <span class="main">∈</span> <span class="free">traces</span> <span class="free">p</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The finite traces of a program could be turned into infinite traces
by infinitely stuttering the final state,
obtaining the `executions' defined in~\cite{ClarksonSchneiderHyperproperties}.
However, such infinite traces carry no additional information
compared to the finite traces from which they are derived:
for programs in this language,
the infinite executions of~\cite{ClarksonSchneiderHyperproperties}
are modeled as finite traces of type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">trace</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Requirement Specification›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:specificationII}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The target program
must process low and high inputs to yield low and high outputs,
according to constraints that involve
both non-determinism and under-specification,
with no information flowing from high inputs to low outputs.%
\footnote{As in \secref{sec:hyper},
`low' and `high' have the usual security meaning,
e.g.\ `low' means `unclassified' and `high' means `classified'.}›</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Input/Output Variables›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:specII:iovars}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Even though the language defined in \secref{sec:targetII}
has no explicit features for input and output,
an external agent could
write values into some variables,
execute the program body,
and read values from some variables.
Thus, variables may be regarded as holding
inputs (in the initial state) and outputs (in the final state).›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In the target program, four variables are required:
\begin{itemize}
\item
A variable <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="inner_quoted"><span class="inner_quoted">''lowIn''</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to hold low inputs.
\item
A variable <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="inner_quoted"><span class="inner_quoted">''lowOut''</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to hold low outputs.
\item
A variable <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="inner_quoted"><span class="inner_quoted">''highIn''</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to hold high inputs.
\item
A variable <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="inner_quoted"><span class="inner_quoted">''highOut''</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to hold high outputs.
\end{itemize}
Other variables are allowed but not required.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">io_vars</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"prog <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">io_vars</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span> ctxt <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">⊇</span> <span class="main">{</span><span class="inner_quoted">''lowIn''</span><span class="main">,</span> <span class="inner_quoted">''lowOut''</span><span class="main">,</span> <span class="inner_quoted">''highIn''</span><span class="main">,</span> <span class="inner_quoted">''highOut''</span><span class="main">}</span>"</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Low Processing›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:specII:lowproc}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹If the low input is not 0,
the low output must be 1 plus the low input.
That is,
for every possible execution of the program
where the initial state's low input is not 0,
the final state's low output must be 1 plus the low input.
If there are multiple possible final states for the same initial state
due to non-determinism,
all of them must have the same required low output.
Thus, processing of non-0 low inputs must be deterministic.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">low_proc_non0</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"prog <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">low_proc_non0</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span>
  <span class="main">∀</span><span class="bound">σ</span> <span class="main">∈</span> states <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">.</span> <span class="main">∀</span><span class="bound">σ'</span><span class="main">.</span>
    the <span class="main">(</span><span class="bound">σ</span> <span class="inner_quoted">''lowIn''</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">∧</span>
    body <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">⊳</span> <span class="bound">σ</span> <span class="main">↝</span> Some <span class="bound">σ'</span> <span class="main">⟶</span>
    the <span class="main">(</span><span class="bound">σ'</span> <span class="inner_quoted">''lowOut''</span><span class="main">)</span> <span class="main">=</span> the <span class="main">(</span><span class="bound">σ</span> <span class="inner_quoted">''lowIn''</span><span class="main">)</span> <span class="main">+</span> <span class="main">1</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹If the low input is 0, the low output must be a random value.
That is,
for every possible initial state of the program whose low input is 0,
and for every possible value,
there must exist an execution of the program
whose final state has that value as low output.
Executions corresponding to all possible values must be possible.
Thus, processing of the 0 low input must be non-deterministic.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">low_proc_0</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"prog <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">low_proc_0</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span>
  <span class="main">∀</span><span class="bound">σ</span> <span class="main">∈</span> states <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">.</span> <span class="main">∀</span><span class="bound">u</span><span class="main">.</span>
    the <span class="main">(</span><span class="bound">σ</span> <span class="inner_quoted">''lowIn''</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span> <span class="main">⟶</span>
    <span class="main">(</span><span class="main">∃</span><span class="bound">σ'</span><span class="main">.</span> body <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">⊳</span> <span class="bound">σ</span> <span class="main">↝</span> Some <span class="bound">σ'</span> <span class="main">∧</span> the <span class="main">(</span><span class="bound">σ'</span> <span class="inner_quoted">''lowOut''</span><span class="main">)</span> <span class="main">=</span> <span class="bound">u</span><span class="main">)</span>"</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹High Processing›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:specII:highproc}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The high output must be
at least as large as the sum of the low and high inputs.
That is,
for every possible execution of the program,
the final state's high output must satisfy the constraint.
If there are multiple possible final states for the same initial state
due to non-determinism,
all of them must contain a high output that satisfies the constraint.
Since different high outputs may satisfy the constraint given the same inputs,
not all the possible final states from a given initial state
must have the same high output.
Thus, processing of high inputs is under-specified;
it can be realized deterministically or non-deterministically.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">high_proc</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"prog <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">high_proc</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span>
  <span class="main">∀</span><span class="bound">σ</span> <span class="main">∈</span> states <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">.</span> <span class="main">∀</span><span class="bound">σ'</span><span class="main">.</span>
    body <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">⊳</span> <span class="bound">σ</span> <span class="main">↝</span> Some <span class="bound">σ'</span> <span class="main">⟶</span>
    the <span class="main">(</span><span class="bound">σ'</span> <span class="inner_quoted">''highOut''</span><span class="main">)</span> <span class="main">≥</span> the <span class="main">(</span><span class="bound">σ</span> <span class="inner_quoted">''lowIn''</span><span class="main">)</span> <span class="main">+</span> the <span class="main">(</span><span class="bound">σ</span> <span class="inner_quoted">''highIn''</span><span class="main">)</span>"</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹All Requirements›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:specII:all}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Besides satisfying the above requirements on
input/output variables, low processing, and high processing,
the target program must be well-formed.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">spec<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"prog <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">spec<span class="hidden">⇩</span><sub>0</sub></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span>
  wfp <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∧</span> io_vars <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∧</span> low_proc_non0 <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∧</span> low_proc_0 <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∧</span> high_proc <span class="free"><span class="bound"><span class="entity">p</span></span></span>"</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Generalized Non-Interference›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:specII:GNI}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The parameters of the GNI formulation in \secref{sec:hyper}
are instantiated according to the target program under consideration.
In an execution of the program:
\begin{itemize}
\item
The value of the variable <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="inner_quoted"><span class="inner_quoted">''lowIn''</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> in the initial state
is the low input.
\item
The value of the variable <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="inner_quoted"><span class="inner_quoted">''lowOut''</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> in the final state
is the low output.
\item
The value of the variable <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="inner_quoted"><span class="inner_quoted">''highIn''</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> in the initial state
is the high input.
\item
The value of the variable <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="inner_quoted"><span class="inner_quoted">''highOut''</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> in the final state
is the high output.
\end{itemize}›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">low_in</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"trace <span class="main">⇒</span> nat"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">low_in</span> <span class="free"><span class="bound"><span class="entity">τ</span></span></span> <span class="main">≡</span> the <span class="main">(</span>initial <span class="free"><span class="bound"><span class="entity">τ</span></span></span> <span class="inner_quoted">''lowIn''</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">low_out</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"trace <span class="main">⇒</span> nat"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">low_out</span> <span class="free"><span class="bound"><span class="entity">τ</span></span></span> <span class="main">≡</span> the <span class="main">(</span>final <span class="free"><span class="bound"><span class="entity">τ</span></span></span> <span class="inner_quoted">''lowOut''</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">high_in</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"trace <span class="main">⇒</span> nat"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">high_in</span> <span class="free"><span class="bound"><span class="entity">τ</span></span></span> <span class="main">≡</span> the <span class="main">(</span>initial <span class="free"><span class="bound"><span class="entity">τ</span></span></span> <span class="inner_quoted">''highIn''</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">high_out</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"trace <span class="main">⇒</span> nat"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">high_out</span> <span class="free"><span class="bound"><span class="entity">τ</span></span></span> <span class="main">≡</span> the <span class="main">(</span>final <span class="free"><span class="bound"><span class="entity">τ</span></span></span> <span class="inner_quoted">''highOut''</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">interpretation</span></span>
  Target<span class="main">:</span> generalized_non_interference <span class="quoted">low_in</span> <span class="quoted">low_out</span> <span class="quoted">high_in</span> <span class="quoted">high_out</span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">GNI</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"trace set <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">GNI</span> <span class="main">≡</span> Target.GNI"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The requirements in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> spec<span class="hidden">⇩</span><sub>0</sub><span class="antiquote"><span class="antiquote">}</span></span></span></span> imply that
the set of traces of the target program satisfies GNI.›</span></span>

<span class="keyword1" id="Second_Example-spec"><span class="command">lemma</span></span> spec<span class="hidden">⇩</span><sub>0</sub>_GNI<span class="main">:</span>
  <span class="quoted"><span class="quoted">"spec<span class="hidden">⇩</span><sub>0</sub> <span class="free">p</span> <span class="main">⟹</span> GNI <span class="main">(</span>traces <span class="free">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Target.GNI_def<span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> Spec<span class="main">:</span> <span class="quoted"><span class="quoted">"spec<span class="hidden">⇩</span><sub>0</sub> <span class="free">p</span>"</span></span>
  <span class="comment1">― ‹Consider a trace <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">text</span> <span class="raw_text">τ<span class="hidden">⇩</span><sub>1</sub></span><span class="antiquote">}</span></span> and its high input:›</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">τ<span class="hidden">⇩</span><sub>1</sub></span><span class="main">::</span><span class="quoted">trace</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">highIn</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">highIn</span> <span class="main">=</span> high_in <span class="skolem">τ<span class="hidden">⇩</span><sub>1</sub></span>"</span></span>
  <span class="comment1">― ‹Consider a trace <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">text</span> <span class="raw_text">τ<span class="hidden">⇩</span><sub>2</sub></span><span class="antiquote">}</span></span>,
        its low input and output,
        and its states:›</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">τ<span class="hidden">⇩</span><sub>2</sub></span><span class="main">::</span><span class="quoted">trace</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">lowIn</span></span> <span class="skolem"><span class="skolem">lowOut</span></span> <span class="skolem"><span class="skolem">σ<span class="hidden">⇩</span><sub>2</sub></span></span> <span class="skolem"><span class="skolem">σ<span class="hidden">⇩</span><sub>2</sub>'</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">lowIn</span> <span class="main">=</span> low_in <span class="skolem">τ<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">lowOut</span> <span class="main">=</span> low_out <span class="skolem">τ<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">σ<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">=</span> initial <span class="skolem">τ<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">σ<span class="hidden">⇩</span><sub>2</sub>'</span> <span class="main">=</span> final <span class="skolem">τ<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">τ<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">∈</span> traces <span class="free">p</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> Exec2<span class="main">:</span> <span class="quoted"><span class="quoted">"body <span class="free">p</span> <span class="main">⊳</span> <span class="skolem">σ<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">↝</span> Some <span class="skolem">σ<span class="hidden">⇩</span><sub>2</sub>'</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> State2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">σ<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">∈</span> states <span class="free">p</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> σ<span class="hidden">⇩</span><sub>2</sub>_def σ<span class="hidden">⇩</span><sub>2</sub>'_def <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> traces.cases<span class="main">)</span>
  <span class="comment1">― ‹Construct the initial state of the witness trace <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">text</span> <span class="raw_text">τ<span class="hidden">⇩</span><sub>3</sub></span><span class="antiquote">}</span></span>:›</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">σ<span class="hidden">⇩</span><sub>3</sub></span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">σ<span class="hidden">⇩</span><sub>3</sub></span> <span class="main">=</span> <span class="skolem">σ<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">(</span><span class="inner_quoted">''highIn''</span> <span class="main">↦</span> <span class="skolem">highIn</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> LowIn3<span class="main">:</span> <span class="quoted"><span class="quoted">"the <span class="main">(</span><span class="skolem">σ<span class="hidden">⇩</span><sub>3</sub></span> <span class="inner_quoted">''lowIn''</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">lowIn</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> HighIn3<span class="main">:</span> <span class="quoted"><span class="quoted">"the <span class="main">(</span><span class="skolem">σ<span class="hidden">⇩</span><sub>3</sub></span> <span class="inner_quoted">''highIn''</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">highIn</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> lowIn_def low_in_def σ<span class="hidden">⇩</span><sub>2</sub>_def<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> Spec State2
  <span class="keyword1"><span class="command">have</span></span> State3<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">σ<span class="hidden">⇩</span><sub>3</sub></span> <span class="main">∈</span> states <span class="free">p</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> σ<span class="hidden">⇩</span><sub>3</sub>_def states_def match_def spec<span class="hidden">⇩</span><sub>0</sub>_def io_vars_def<span class="main">)</span>
  <span class="comment1">― ‹Construct the final state of <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">text</span> <span class="raw_text">τ<span class="hidden">⇩</span><sub>3</sub></span><span class="antiquote">}</span></span>, and <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">text</span> <span class="raw_text">τ<span class="hidden">⇩</span><sub>3</sub></span><span class="antiquote">}</span></span>,
        by cases on <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted"><span class="skolem">lowIn</span></span><span class="antiquote">}</span></span>:›</span>
  <span class="keyword3"><span class="command">show</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">τ<span class="hidden">⇩</span><sub>3</sub></span> <span class="main">∈</span> traces <span class="free">p</span><span class="main">.</span>
      high_in <span class="bound">τ<span class="hidden">⇩</span><sub>3</sub></span> <span class="main">=</span> high_in <span class="skolem">τ<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">∧</span>
      low_in <span class="bound">τ<span class="hidden">⇩</span><sub>3</sub></span> <span class="main">=</span> low_in <span class="skolem">τ<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">∧</span>
      low_out <span class="bound">τ<span class="hidden">⇩</span><sub>3</sub></span> <span class="main">=</span> low_out <span class="skolem">τ<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">lowIn</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> 0
    <span class="comment1">― ‹Use as final state the one required by <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">low_proc_0</span><span class="antiquote">}</span></span>:›</span>
    <span class="keyword1"><span class="command">with</span></span> Spec State3 LowIn3
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">σ<span class="hidden">⇩</span><sub>3</sub>'</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> Exec3<span class="main">:</span> <span class="quoted"><span class="quoted">"body <span class="free">p</span> <span class="main">⊳</span> <span class="skolem">σ<span class="hidden">⇩</span><sub>3</sub></span> <span class="main">↝</span> Some <span class="skolem">σ<span class="hidden">⇩</span><sub>3</sub>'</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> LowOut3<span class="main">:</span> <span class="quoted"><span class="quoted">"the <span class="main">(</span><span class="skolem">σ<span class="hidden">⇩</span><sub>3</sub>'</span> <span class="inner_quoted">''lowOut''</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">lowOut</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> spec<span class="hidden">⇩</span><sub>0</sub>_def low_proc_0_def<span class="main">)</span>
    <span class="comment1">― ‹Construct <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">text</span> <span class="raw_text">τ<span class="hidden">⇩</span><sub>3</sub></span><span class="antiquote">}</span></span> from its initial and final states:›</span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">τ<span class="hidden">⇩</span><sub>3</sub></span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">τ<span class="hidden">⇩</span><sub>3</sub></span> <span class="main">=</span> <span class="main">⦇</span>initial <span class="main">=</span> <span class="skolem">σ<span class="hidden">⇩</span><sub>3</sub></span><span class="main">,</span> final <span class="main">=</span> <span class="skolem">σ<span class="hidden">⇩</span><sub>3</sub>'</span><span class="main">⦈</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> Exec3 State3
    <span class="keyword1"><span class="command">have</span></span> Trace3<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">τ<span class="hidden">⇩</span><sub>3</sub></span> <span class="main">∈</span> traces <span class="free">p</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"high_in <span class="skolem">τ<span class="hidden">⇩</span><sub>3</sub></span> <span class="main">=</span> high_in <span class="skolem">τ<span class="hidden">⇩</span><sub>1</sub></span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"low_in <span class="skolem">τ<span class="hidden">⇩</span><sub>3</sub></span> <span class="main">=</span> low_in <span class="skolem">τ<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"low_out <span class="skolem">τ<span class="hidden">⇩</span><sub>3</sub></span> <span class="main">=</span> low_out <span class="skolem">τ<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>
      high_in_def low_in_def low_out_def
      τ<span class="hidden">⇩</span><sub>3</sub>_def σ<span class="hidden">⇩</span><sub>2</sub>_def σ<span class="hidden">⇩</span><sub>2</sub>'_def
      highIn_def lowIn_def lowOut_def
      LowIn3 HighIn3 LowOut3<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> Trace3
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> Suc
    <span class="keyword1"><span class="command">hence</span></span> Not0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">lowIn</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="comment1">― ‹Derive <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted"><span class="skolem">τ<span class="hidden">⇩</span><sub>2</sub></span></span><span class="antiquote">}</span></span>'s low output from <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">low_proc_non0</span><span class="antiquote">}</span></span>:›</span>
    <span class="keyword1"><span class="command">with</span></span> Exec2 State2 Spec
    <span class="keyword1"><span class="command">have</span></span> LowOut2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">lowOut</span> <span class="main">=</span> <span class="skolem">lowIn</span> <span class="main">+</span> <span class="main">1</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>
      spec<span class="hidden">⇩</span><sub>0</sub>_def low_proc_non0_def σ<span class="hidden">⇩</span><sub>2</sub>_def σ<span class="hidden">⇩</span><sub>2</sub>'_def
      low_in_def low_out_def lowIn_def lowOut_def<span class="main">)</span>
    <span class="comment1">― ‹Use any final state for <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">text</span> <span class="raw_text">τ<span class="hidden">⇩</span><sub>3</sub></span><span class="antiquote">}</span></span>:›</span>
    <span class="keyword1"><span class="command">from</span></span> Spec
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"wfp <span class="free">p</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> spec<span class="hidden">⇩</span><sub>0</sub>_def<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> State3
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">σ<span class="hidden">⇩</span><sub>3</sub>'</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> Exec3<span class="main">:</span> <span class="quoted"><span class="quoted">"body <span class="free">p</span> <span class="main">⊳</span> <span class="skolem">σ<span class="hidden">⇩</span><sub>3</sub></span> <span class="main">↝</span> Some <span class="skolem">σ<span class="hidden">⇩</span><sub>3</sub>'</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> exec_always exec_wfp_no_error not_Some_eq<span class="main">)</span>
    <span class="comment1">― ‹Derive <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">text</span> <span class="raw_text">τ<span class="hidden">⇩</span><sub>3</sub></span><span class="antiquote">}</span></span>'s low output from <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">low_proc_non0</span><span class="antiquote">}</span></span>:›</span>
    <span class="keyword1"><span class="command">with</span></span> State3 Spec Not0
    <span class="keyword1"><span class="command">have</span></span> LowOut3<span class="main">:</span> <span class="quoted"><span class="quoted">"the <span class="main">(</span><span class="skolem">σ<span class="hidden">⇩</span><sub>3</sub>'</span> <span class="inner_quoted">''lowOut''</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">lowIn</span> <span class="main">+</span> <span class="main">1</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> spec<span class="hidden">⇩</span><sub>0</sub>_def low_proc_non0_def LowIn3<span class="main">)</span>
    <span class="comment1">― ‹Construct <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">text</span> <span class="raw_text">τ<span class="hidden">⇩</span><sub>3</sub></span><span class="antiquote">}</span></span> from its initial and final states:›</span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">τ<span class="hidden">⇩</span><sub>3</sub></span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">τ<span class="hidden">⇩</span><sub>3</sub></span> <span class="main">=</span> <span class="main">⦇</span>initial <span class="main">=</span> <span class="skolem">σ<span class="hidden">⇩</span><sub>3</sub></span><span class="main">,</span> final <span class="main">=</span> <span class="skolem">σ<span class="hidden">⇩</span><sub>3</sub>'</span><span class="main">⦈</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> Exec3 State3
    <span class="keyword1"><span class="command">have</span></span> Trace3<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">τ<span class="hidden">⇩</span><sub>3</sub></span> <span class="main">∈</span> traces <span class="free">p</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"high_in <span class="skolem">τ<span class="hidden">⇩</span><sub>3</sub></span> <span class="main">=</span> high_in <span class="skolem">τ<span class="hidden">⇩</span><sub>1</sub></span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"low_in <span class="skolem">τ<span class="hidden">⇩</span><sub>3</sub></span> <span class="main">=</span> low_in <span class="skolem">τ<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"low_out <span class="skolem">τ<span class="hidden">⇩</span><sub>3</sub></span> <span class="main">=</span> low_out <span class="skolem">τ<span class="hidden">⇩</span><sub>2</sub></span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>
      high_in_def low_in_def low_out_def
      τ<span class="hidden">⇩</span><sub>3</sub>_def σ<span class="hidden">⇩</span><sub>3</sub>_def σ<span class="hidden">⇩</span><sub>2</sub>_def
      LowOut2 LowOut3
      highIn_def lowOut_def<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> low_out_def<span class="main"><span class="main">,</span></span> <span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> Trace3
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Since GNI is implied by <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> spec<span class="hidden">⇩</span><sub>0</sub><span class="antiquote"><span class="antiquote">}</span></span></span></span>
and since every pop-refinement of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> spec<span class="hidden">⇩</span><sub>0</sub><span class="antiquote"><span class="antiquote">}</span></span></span></span> implies <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> spec<span class="hidden">⇩</span><sub>0</sub><span class="antiquote"><span class="antiquote">}</span></span></span></span>,
GNI is preserved through every pop-refinement of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> spec<span class="hidden">⇩</span><sub>0</sub><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
Pop-refinement differs from the popular notion of refinement
as inclusion of sets of traces (e.g.~\cite{AbadiLamportRefinement}),
which does not preserve GNI~\cite{ClarksonSchneiderHyperproperties}.›</span></span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Stepwise Refinement›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:refinementII}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The remark at the beginning of \secref{sec:refinementI}
applies here as well:
the following sequence of refinement steps
may be overkill for obtaining an implementation of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> spec<span class="hidden">⇩</span><sub>0</sub><span class="antiquote"><span class="antiquote">}</span></span></span></span>,
but illustrates concepts that should apply to more complex cases.›</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Step 1›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:refII:stepI}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The program needs no other variables
besides those prescribed by <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> io_vars<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
Thus, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> io_vars<span class="antiquote"><span class="antiquote">}</span></span></span></span> is refined to a stronger condition
that constrains the program to contain exactly those variables,
in a certain order.›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">vars<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"name list"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">vars<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">≡</span> <span class="main">[</span><span class="inner_quoted">''lowIn''</span><span class="main">,</span> <span class="inner_quoted">''lowOut''</span><span class="main">,</span> <span class="inner_quoted">''highIn''</span><span class="main">,</span> <span class="inner_quoted">''highOut''</span><span class="main">]</span>"</span></span>
<span class="comment1">― ‹The order of the variables in the list is arbitrary.›</span>

<span class="keyword1" id="Second_Example-vars"><span class="command">lemma</span></span> vars<span class="hidden">⇩</span><sub>0</sub>_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"vars <span class="free">p</span> <span class="main">=</span> vars<span class="hidden">⇩</span><sub>0</sub> <span class="main">⟹</span> io_vars <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> io_vars_def ctxt_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The refinement of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> io_vars<span class="antiquote"><span class="antiquote">}</span></span></span></span>
reduces the well-formedness of the program
to the well-formedness of the body.›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">Γ<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">::</span> <span class="quoted">ctxt</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">Γ<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">≡</span> <span class="main">{</span><span class="inner_quoted">''lowIn''</span><span class="main">,</span> <span class="inner_quoted">''lowOut''</span><span class="main">,</span> <span class="inner_quoted">''highIn''</span><span class="main">,</span> <span class="inner_quoted">''highOut''</span><span class="main">}</span>"</span></span>

<span class="keyword1" id="Second_Example-reduce_wf_prog_to_body"><span class="command">lemma</span></span> reduce_wf_prog_to_body<span class="main">:</span>
  <span class="quoted"><span class="quoted">"vars <span class="free">p</span> <span class="main">=</span> vars<span class="hidden">⇩</span><sub>0</sub> <span class="main">⟹</span> wfp <span class="free">p</span> <span class="main">⟷</span> wfs Γ<span class="hidden">⇩</span><sub>0</sub> <span class="main">(</span>body <span class="free">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> wfp_def ctxt_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The refinement of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> io_vars<span class="antiquote"><span class="antiquote">}</span></span></span></span>
induces a simplification of the processing constraints:
since the context of the program is now defined to be <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> Γ<span class="hidden">⇩</span><sub>0</sub><span class="antiquote"><span class="antiquote">}</span></span></span></span>,
the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">σ</span></span> <span class="main"><span class="main">∈</span></span> states <span class="free"><span class="free">p</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> conditions are replaced
with <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"match <span class="free"><span class="free">σ</span></span> Γ<span class="hidden">⇩</span><sub>0</sub>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> conditions.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">low_proc_non0<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"prog <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">low_proc_non0<span class="hidden">⇩</span><sub>1</sub></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span>
  <span class="main">∀</span><span class="bound">σ</span> <span class="bound">σ'</span><span class="main">.</span>
    match <span class="bound">σ</span> Γ<span class="hidden">⇩</span><sub>0</sub> <span class="main">∧</span>
    the <span class="main">(</span><span class="bound">σ</span> <span class="inner_quoted">''lowIn''</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">∧</span>
    body <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">⊳</span> <span class="bound">σ</span> <span class="main">↝</span> Some <span class="bound">σ'</span> <span class="main">⟶</span>
    the <span class="main">(</span><span class="bound">σ'</span> <span class="inner_quoted">''lowOut''</span><span class="main">)</span> <span class="main">=</span> the <span class="main">(</span><span class="bound">σ</span> <span class="inner_quoted">''lowIn''</span><span class="main">)</span> <span class="main">+</span> <span class="main">1</span>"</span></span>

<span class="keyword1" id="Second_Example-low_proc_non0"><span class="command">lemma</span></span> low_proc_non0<span class="hidden">⇩</span><sub>1</sub>_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"vars <span class="free">p</span> <span class="main">=</span> vars<span class="hidden">⇩</span><sub>0</sub> <span class="main">⟹</span> low_proc_non0<span class="hidden">⇩</span><sub>1</sub> <span class="free">p</span> <span class="main">⟷</span> low_proc_non0 <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> low_proc_non0<span class="hidden">⇩</span><sub>1</sub>_def low_proc_non0_def states_def ctxt_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">low_proc_0<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"prog <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">low_proc_0<span class="hidden">⇩</span><sub>1</sub></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span>
  <span class="main">∀</span><span class="bound">σ</span> <span class="bound">u</span><span class="main">.</span>
    match <span class="bound">σ</span> Γ<span class="hidden">⇩</span><sub>0</sub> <span class="main">∧</span>
    the <span class="main">(</span><span class="bound">σ</span> <span class="inner_quoted">''lowIn''</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span> <span class="main">⟶</span>
    <span class="main">(</span><span class="main">∃</span><span class="bound">σ'</span><span class="main">.</span> body <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">⊳</span> <span class="bound">σ</span> <span class="main">↝</span> Some <span class="bound">σ'</span> <span class="main">∧</span> the <span class="main">(</span><span class="bound">σ'</span> <span class="inner_quoted">''lowOut''</span><span class="main">)</span> <span class="main">=</span> <span class="bound">u</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Second_Example-low_proc_0"><span class="command">lemma</span></span> low_proc_0<span class="hidden">⇩</span><sub>1</sub>_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"vars <span class="free">p</span> <span class="main">=</span> vars<span class="hidden">⇩</span><sub>0</sub> <span class="main">⟹</span> low_proc_0<span class="hidden">⇩</span><sub>1</sub> <span class="free">p</span> <span class="main">⟷</span> low_proc_0 <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> low_proc_0<span class="hidden">⇩</span><sub>1</sub>_def low_proc_0_def states_def ctxt_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">high_proc<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"prog <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">high_proc<span class="hidden">⇩</span><sub>1</sub></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span>
  <span class="main">∀</span><span class="bound">σ</span> <span class="bound">σ'</span><span class="main">.</span>
    match <span class="bound">σ</span> Γ<span class="hidden">⇩</span><sub>0</sub> <span class="main">∧</span>
    body <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">⊳</span> <span class="bound">σ</span> <span class="main">↝</span> Some <span class="bound">σ'</span> <span class="main">⟶</span>
    the <span class="main">(</span><span class="bound">σ'</span> <span class="inner_quoted">''highOut''</span><span class="main">)</span> <span class="main">≥</span> the <span class="main">(</span><span class="bound">σ</span> <span class="inner_quoted">''lowIn''</span><span class="main">)</span> <span class="main">+</span> the <span class="main">(</span><span class="bound">σ</span> <span class="inner_quoted">''highIn''</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Second_Example-high_proc"><span class="command">lemma</span></span> high_proc<span class="hidden">⇩</span><sub>1</sub>_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"vars <span class="free">p</span> <span class="main">=</span> vars<span class="hidden">⇩</span><sub>0</sub> <span class="main">⟹</span> high_proc<span class="hidden">⇩</span><sub>1</sub> <span class="free">p</span> <span class="main">⟷</span> high_proc <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> high_proc<span class="hidden">⇩</span><sub>1</sub>_def high_proc_def states_def ctxt_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The refinement of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> spec<span class="hidden">⇩</span><sub>0</sub><span class="antiquote"><span class="antiquote">}</span></span></span></span> consists of
the refinement of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> io_vars<span class="antiquote"><span class="antiquote">}</span></span></span></span> and of the simplified constraints.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">spec<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"prog <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">spec<span class="hidden">⇩</span><sub>1</sub></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span>
  vars <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> vars<span class="hidden">⇩</span><sub>0</sub> <span class="main">∧</span>
  wfs Γ<span class="hidden">⇩</span><sub>0</sub> <span class="main">(</span>body <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="main">∧</span>
  low_proc_non0<span class="hidden">⇩</span><sub>1</sub> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∧</span>
  low_proc_0<span class="hidden">⇩</span><sub>1</sub> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">∧</span>
  high_proc<span class="hidden">⇩</span><sub>1</sub> <span class="free"><span class="bound"><span class="entity">p</span></span></span>"</span></span>

<span class="keyword1" id="Second_Example-step_1_correct"><span class="command">lemma</span></span> step_1_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"spec<span class="hidden">⇩</span><sub>1</sub> <span class="free">p</span> <span class="main">⟹</span> spec<span class="hidden">⇩</span><sub>0</sub> <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span>
  spec<span class="hidden">⇩</span><sub>1</sub>_def spec<span class="hidden">⇩</span><sub>0</sub>_def
  vars<span class="hidden">⇩</span><sub>0</sub>_correct
  reduce_wf_prog_to_body
  low_proc_non0<span class="hidden">⇩</span><sub>1</sub>_correct
  low_proc_0<span class="hidden">⇩</span><sub>1</sub>_correct
  high_proc<span class="hidden">⇩</span><sub>1</sub>_correct<span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Step 2›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:refII:stepII}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The body of the target program is split
into two sequential statements---%
one to compute the low output and one to compute the high output.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">body_split</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"prog <span class="main">⇒</span> stmt <span class="main">⇒</span> stmt <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">body_split</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">s<span class="hidden">⇩</span><sub>L</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">s<span class="hidden">⇩</span><sub>H</sub></span></span></span> <span class="main">≡</span> body <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> Seq <span class="free"><span class="bound"><span class="entity">s<span class="hidden">⇩</span><sub>L</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">s<span class="hidden">⇩</span><sub>H</sub></span></span></span>"</span></span>
<span class="comment1">― ‹The order of the two statements in the body is arbitrary.›</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The splitting reduces the well-formedness of the body
to the well-formedness of the two statements.›</span></span>

<span class="keyword1" id="Second_Example-reduce_wf_body_to_stmts"><span class="command">lemma</span></span> reduce_wf_body_to_stmts<span class="main">:</span>
  <span class="quoted"><span class="quoted">"body_split <span class="free">p</span> <span class="free">s<span class="hidden">⇩</span><sub>L</sub></span> <span class="free">s<span class="hidden">⇩</span><sub>H</sub></span> <span class="main">⟹</span> wfs Γ<span class="hidden">⇩</span><sub>0</sub> <span class="main">(</span>body <span class="free">p</span><span class="main">)</span> <span class="main">⟷</span> wfs Γ<span class="hidden">⇩</span><sub>0</sub> <span class="free">s<span class="hidden">⇩</span><sub>L</sub></span> <span class="main">∧</span> wfs Γ<span class="hidden">⇩</span><sub>0</sub> <span class="free">s<span class="hidden">⇩</span><sub>H</sub></span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> body_split_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The processing predicates over programs
are refined to predicates over the statements <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">s<span class="hidden">⇩</span><sub>L</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">s<span class="hidden">⇩</span><sub>H</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
Since <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">s<span class="hidden">⇩</span><sub>H</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> follows <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">s<span class="hidden">⇩</span><sub>L</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>:
\begin{itemize}
\item
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">s<span class="hidden">⇩</span><sub>H</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> must not change the low output, which is computed by <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">s<span class="hidden">⇩</span><sub>L</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
\item
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">s<span class="hidden">⇩</span><sub>L</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> must not change the low and high inputs, which are used by <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">s<span class="hidden">⇩</span><sub>H</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
\end{itemize}›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">low_proc_non0<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"stmt <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">low_proc_non0<span class="hidden">⇩</span><sub>2</sub></span> <span class="free"><span class="bound"><span class="entity">s<span class="hidden">⇩</span><sub>L</sub></span></span></span> <span class="main">≡</span>
  <span class="main">∀</span><span class="bound">σ</span> <span class="bound">σ'</span><span class="main">.</span>
    match <span class="bound">σ</span> Γ<span class="hidden">⇩</span><sub>0</sub> <span class="main">∧</span>
    the <span class="main">(</span><span class="bound">σ</span> <span class="inner_quoted">''lowIn''</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">∧</span>
    <span class="free"><span class="bound"><span class="entity">s<span class="hidden">⇩</span><sub>L</sub></span></span></span> <span class="main">⊳</span> <span class="bound">σ</span> <span class="main">↝</span> Some <span class="bound">σ'</span> <span class="main">⟶</span>
    the <span class="main">(</span><span class="bound">σ'</span> <span class="inner_quoted">''lowOut''</span><span class="main">)</span> <span class="main">=</span> the <span class="main">(</span><span class="bound">σ</span> <span class="inner_quoted">''lowIn''</span><span class="main">)</span> <span class="main">+</span> <span class="main">1</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">low_proc_0<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"stmt <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">low_proc_0<span class="hidden">⇩</span><sub>2</sub></span> <span class="free"><span class="bound"><span class="entity">s<span class="hidden">⇩</span><sub>L</sub></span></span></span> <span class="main">≡</span>
  <span class="main">∀</span><span class="bound">σ</span> <span class="bound">u</span><span class="main">.</span>
    match <span class="bound">σ</span> Γ<span class="hidden">⇩</span><sub>0</sub> <span class="main">∧</span>
    the <span class="main">(</span><span class="bound">σ</span> <span class="inner_quoted">''lowIn''</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span> <span class="main">⟶</span>
    <span class="main">(</span><span class="main">∃</span><span class="bound">σ'</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">s<span class="hidden">⇩</span><sub>L</sub></span></span></span> <span class="main">⊳</span> <span class="bound">σ</span> <span class="main">↝</span> Some <span class="bound">σ'</span> <span class="main">∧</span> the <span class="main">(</span><span class="bound">σ'</span> <span class="inner_quoted">''lowOut''</span><span class="main">)</span> <span class="main">=</span> <span class="bound">u</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">low_proc_no_input_change</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"stmt <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">low_proc_no_input_change</span> <span class="free"><span class="bound"><span class="entity">s<span class="hidden">⇩</span><sub>L</sub></span></span></span> <span class="main">≡</span>
  <span class="main">∀</span><span class="bound">σ</span> <span class="bound">σ'</span><span class="main">.</span>
    match <span class="bound">σ</span> Γ<span class="hidden">⇩</span><sub>0</sub> <span class="main">∧</span>
    <span class="free"><span class="bound"><span class="entity">s<span class="hidden">⇩</span><sub>L</sub></span></span></span> <span class="main">⊳</span> <span class="bound">σ</span> <span class="main">↝</span> Some <span class="bound">σ'</span> <span class="main">⟶</span>
    the <span class="main">(</span><span class="bound">σ'</span> <span class="inner_quoted">''lowIn''</span><span class="main">)</span> <span class="main">=</span> the <span class="main">(</span><span class="bound">σ</span> <span class="inner_quoted">''lowIn''</span><span class="main">)</span> <span class="main">∧</span>
    the <span class="main">(</span><span class="bound">σ'</span> <span class="inner_quoted">''highIn''</span><span class="main">)</span> <span class="main">=</span> the <span class="main">(</span><span class="bound">σ</span> <span class="inner_quoted">''highIn''</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">high_proc<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"stmt <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">high_proc<span class="hidden">⇩</span><sub>2</sub></span> <span class="free"><span class="bound"><span class="entity">s<span class="hidden">⇩</span><sub>H</sub></span></span></span> <span class="main">≡</span>
  <span class="main">∀</span><span class="bound">σ</span> <span class="bound">σ'</span><span class="main">.</span>
    match <span class="bound">σ</span> Γ<span class="hidden">⇩</span><sub>0</sub> <span class="main">∧</span>
    <span class="free"><span class="bound"><span class="entity">s<span class="hidden">⇩</span><sub>H</sub></span></span></span> <span class="main">⊳</span> <span class="bound">σ</span> <span class="main">↝</span> Some <span class="bound">σ'</span> <span class="main">⟶</span>
    the <span class="main">(</span><span class="bound">σ'</span> <span class="inner_quoted">''highOut''</span><span class="main">)</span> <span class="main">≥</span> the <span class="main">(</span><span class="bound">σ</span> <span class="inner_quoted">''lowIn''</span><span class="main">)</span> <span class="main">+</span> the <span class="main">(</span><span class="bound">σ</span> <span class="inner_quoted">''highIn''</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">high_proc_no_low_output_change</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"stmt <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">high_proc_no_low_output_change</span> <span class="free"><span class="bound"><span class="entity">s<span class="hidden">⇩</span><sub>H</sub></span></span></span> <span class="main">≡</span>
  <span class="main">∀</span><span class="bound">σ</span> <span class="bound">σ'</span><span class="main">.</span>
    match <span class="bound">σ</span> Γ<span class="hidden">⇩</span><sub>0</sub> <span class="main">∧</span>
    <span class="free"><span class="bound"><span class="entity">s<span class="hidden">⇩</span><sub>H</sub></span></span></span> <span class="main">⊳</span> <span class="bound">σ</span> <span class="main">↝</span> Some <span class="bound">σ'</span> <span class="main">⟶</span>
    the <span class="main">(</span><span class="bound">σ'</span> <span class="inner_quoted">''lowOut''</span><span class="main">)</span> <span class="main">=</span> the <span class="main">(</span><span class="bound">σ</span> <span class="inner_quoted">''lowOut''</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Second_Example-proc"><span class="command">lemma</span></span> proc<span class="hidden">⇩</span><sub>2</sub>_correct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> Body<span class="main">:</span> <span class="quoted"><span class="quoted">"body_split <span class="free">p</span> <span class="free">s<span class="hidden">⇩</span><sub>L</sub></span> <span class="free">s<span class="hidden">⇩</span><sub>H</sub></span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> WfLow<span class="main">:</span> <span class="quoted"><span class="quoted">"wfs Γ<span class="hidden">⇩</span><sub>0</sub> <span class="free">s<span class="hidden">⇩</span><sub>L</sub></span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> WfHigh<span class="main">:</span> <span class="quoted"><span class="quoted">"wfs Γ<span class="hidden">⇩</span><sub>0</sub> <span class="free">s<span class="hidden">⇩</span><sub>H</sub></span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> LowNon0<span class="main">:</span> <span class="quoted"><span class="quoted">"low_proc_non0<span class="hidden">⇩</span><sub>2</sub> <span class="free">s<span class="hidden">⇩</span><sub>L</sub></span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> Low0<span class="main">:</span> <span class="quoted"><span class="quoted">"low_proc_0<span class="hidden">⇩</span><sub>2</sub> <span class="free">s<span class="hidden">⇩</span><sub>L</sub></span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> LowSame<span class="main">:</span> <span class="quoted"><span class="quoted">"low_proc_no_input_change <span class="free">s<span class="hidden">⇩</span><sub>L</sub></span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> High<span class="main">:</span> <span class="quoted"><span class="quoted">"high_proc<span class="hidden">⇩</span><sub>2</sub> <span class="free">s<span class="hidden">⇩</span><sub>H</sub></span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> HighSame<span class="main">:</span> <span class="quoted"><span class="quoted">"high_proc_no_low_output_change <span class="free">s<span class="hidden">⇩</span><sub>H</sub></span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"low_proc_non0<span class="hidden">⇩</span><sub>1</sub> <span class="free">p</span> <span class="main">∧</span> low_proc_0<span class="hidden">⇩</span><sub>1</sub> <span class="free">p</span> <span class="main">∧</span> high_proc<span class="hidden">⇩</span><sub>1</sub> <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">goal_cases</span><span class="main">)</span>
  <span class="comment1">― ‹Processing of non-0 low input:›</span>
  <span class="keyword3"><span class="command">case</span></span> 1
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> low_proc_non0<span class="hidden">⇩</span><sub>1</sub>_def<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">σ</span> <span class="skolem">σ'</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"body <span class="free">p</span> <span class="main">⊳</span> <span class="skolem">σ</span> <span class="main">↝</span> Some <span class="skolem">σ'</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> Body
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">σ<span class="hidden">⇩</span><sub>i</sub></span></span>
    <span class="keyword2"><span class="keyword">where</span></span> ExecLow<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s<span class="hidden">⇩</span><sub>L</sub></span> <span class="main">⊳</span> <span class="skolem">σ</span> <span class="main">↝</span> Some <span class="skolem">σ<span class="hidden">⇩</span><sub>i</sub></span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> ExecHigh<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s<span class="hidden">⇩</span><sub>H</sub></span> <span class="main">⊳</span> <span class="skolem">σ<span class="hidden">⇩</span><sub>i</sub></span> <span class="main">↝</span> Some <span class="skolem">σ'</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> body_split_def <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> exec.cases<span class="main">)</span>
    <span class="keyword3"><span class="command">assume</span></span> Non0<span class="main">:</span> <span class="quoted"><span class="quoted">"the <span class="main">(</span><span class="skolem">σ</span> <span class="inner_quoted">''lowIn''</span><span class="main">)</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
    <span class="keyword3"><span class="command">assume</span></span> InitMatch<span class="main">:</span> <span class="quoted"><span class="quoted">"match <span class="skolem">σ</span> Γ<span class="hidden">⇩</span><sub>0</sub>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> ExecLow WfLow
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"match <span class="skolem">σ<span class="hidden">⇩</span><sub>i</sub></span> Γ<span class="hidden">⇩</span><sub>0</sub>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> exec_wfs_match<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> Non0 InitMatch ExecLow ExecHigh HighSame LowNon0
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"the <span class="main">(</span><span class="skolem">σ'</span> <span class="inner_quoted">''lowOut''</span><span class="main">)</span> <span class="main">=</span> Suc <span class="main">(</span>the <span class="main">(</span><span class="skolem">σ</span> <span class="inner_quoted">''lowIn''</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> high_proc_no_low_output_change_def low_proc_non0<span class="hidden">⇩</span><sub>2</sub>_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Suc_eq_plus1 gr_implies_not0<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="comment1">― ‹Processing of 0 low input:›</span>
  <span class="keyword3"><span class="command">case</span></span> 2
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> low_proc_0<span class="hidden">⇩</span><sub>1</sub>_def<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">σ</span> <span class="skolem">u</span>
    <span class="keyword3"><span class="command">assume</span></span> InitMatch<span class="main">:</span> <span class="quoted"><span class="quoted">"match <span class="skolem">σ</span> Γ<span class="hidden">⇩</span><sub>0</sub>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"the <span class="main">(</span><span class="skolem">σ</span> <span class="inner_quoted">''lowIn''</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> Low0
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">σ<span class="hidden">⇩</span><sub>i</sub></span></span>
    <span class="keyword2"><span class="keyword">where</span></span> ExecLow<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s<span class="hidden">⇩</span><sub>L</sub></span> <span class="main">⊳</span> <span class="skolem">σ</span> <span class="main">↝</span> Some <span class="skolem">σ<span class="hidden">⇩</span><sub>i</sub></span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> LowOut<span class="main">:</span> <span class="quoted"><span class="quoted">"the <span class="main">(</span><span class="skolem">σ<span class="hidden">⇩</span><sub>i</sub></span> <span class="inner_quoted">''lowOut''</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">u</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> low_proc_0<span class="hidden">⇩</span><sub>2</sub>_def<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> InitMatch ExecLow WfLow
    <span class="keyword1"><span class="command">have</span></span> MidMatch<span class="main">:</span> <span class="quoted"><span class="quoted">"match <span class="skolem">σ<span class="hidden">⇩</span><sub>i</sub></span> Γ<span class="hidden">⇩</span><sub>0</sub>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> exec_wfs_match<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> WfHigh
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">σ'</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> ExecHigh<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s<span class="hidden">⇩</span><sub>H</sub></span> <span class="main">⊳</span> <span class="skolem">σ<span class="hidden">⇩</span><sub>i</sub></span> <span class="main">↝</span> Some <span class="skolem">σ'</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> exec_wfs_always_match<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> HighSame MidMatch
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"the <span class="main">(</span><span class="skolem">σ'</span> <span class="inner_quoted">''lowOut''</span><span class="main">)</span> <span class="main">=</span> the <span class="main">(</span><span class="skolem">σ<span class="hidden">⇩</span><sub>i</sub></span> <span class="inner_quoted">''lowOut''</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> high_proc_no_low_output_change_def<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> ExecLow ExecHigh Body LowOut
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">σ'</span><span class="main">.</span> body <span class="free">p</span> <span class="main">⊳</span> <span class="skolem">σ</span> <span class="main">↝</span> Some <span class="bound">σ'</span> <span class="main">∧</span> the <span class="main">(</span><span class="bound">σ'</span> <span class="inner_quoted">''lowOut''</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">u</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> body_split_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> ExecSeqOK<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="comment1">― ‹Processing of high input:›</span>
  <span class="keyword3"><span class="command">case</span></span> 3
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> high_proc<span class="hidden">⇩</span><sub>1</sub>_def<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">σ</span> <span class="skolem">σ'</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"body <span class="free">p</span> <span class="main">⊳</span> <span class="skolem">σ</span> <span class="main">↝</span> Some <span class="skolem">σ'</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> Body
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">σ<span class="hidden">⇩</span><sub>i</sub></span></span>
    <span class="keyword2"><span class="keyword">where</span></span> ExecLow<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s<span class="hidden">⇩</span><sub>L</sub></span> <span class="main">⊳</span> <span class="skolem">σ</span> <span class="main">↝</span> Some <span class="skolem">σ<span class="hidden">⇩</span><sub>i</sub></span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> ExecHigh<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s<span class="hidden">⇩</span><sub>H</sub></span> <span class="main">⊳</span> <span class="skolem">σ<span class="hidden">⇩</span><sub>i</sub></span> <span class="main">↝</span> Some <span class="skolem">σ'</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> body_split_def <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> exec.cases<span class="main">)</span>
    <span class="keyword3"><span class="command">assume</span></span> InitMatch<span class="main">:</span> <span class="quoted"><span class="quoted">"match <span class="skolem">σ</span> Γ<span class="hidden">⇩</span><sub>0</sub>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> ExecLow WfLow
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"match <span class="skolem">σ<span class="hidden">⇩</span><sub>i</sub></span> Γ<span class="hidden">⇩</span><sub>0</sub>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> exec_wfs_match<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> InitMatch ExecLow ExecHigh LowSame High
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"the <span class="main">(</span><span class="skolem">σ'</span> <span class="inner_quoted">''highOut''</span><span class="main">)</span> <span class="main">≥</span> the <span class="main">(</span><span class="skolem">σ</span> <span class="inner_quoted">''lowIn''</span><span class="main">)</span> <span class="main">+</span> the <span class="main">(</span><span class="skolem">σ</span> <span class="inner_quoted">''highIn''</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> low_proc_no_input_change_def high_proc<span class="hidden">⇩</span><sub>2</sub>_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The refined specification consists of
the splitting of the body into the two sequential statements
and the refined well-formedness and processing constraints.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">spec<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"prog <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">spec<span class="hidden">⇩</span><sub>2</sub></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span>
  vars <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> vars<span class="hidden">⇩</span><sub>0</sub> <span class="main">∧</span>
  <span class="main">(</span><span class="main">∃</span><span class="bound">s<span class="hidden">⇩</span><sub>L</sub></span> <span class="bound">s<span class="hidden">⇩</span><sub>H</sub></span><span class="main">.</span>
    body_split <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="bound">s<span class="hidden">⇩</span><sub>L</sub></span> <span class="bound">s<span class="hidden">⇩</span><sub>H</sub></span> <span class="main">∧</span>
    wfs Γ<span class="hidden">⇩</span><sub>0</sub> <span class="bound">s<span class="hidden">⇩</span><sub>L</sub></span> <span class="main">∧</span>
    wfs Γ<span class="hidden">⇩</span><sub>0</sub> <span class="bound">s<span class="hidden">⇩</span><sub>H</sub></span> <span class="main">∧</span>
    low_proc_non0<span class="hidden">⇩</span><sub>2</sub> <span class="bound">s<span class="hidden">⇩</span><sub>L</sub></span> <span class="main">∧</span>
    low_proc_0<span class="hidden">⇩</span><sub>2</sub> <span class="bound">s<span class="hidden">⇩</span><sub>L</sub></span> <span class="main">∧</span>
    low_proc_no_input_change <span class="bound">s<span class="hidden">⇩</span><sub>L</sub></span> <span class="main">∧</span>
    high_proc<span class="hidden">⇩</span><sub>2</sub> <span class="bound">s<span class="hidden">⇩</span><sub>H</sub></span> <span class="main">∧</span>
    high_proc_no_low_output_change <span class="bound">s<span class="hidden">⇩</span><sub>H</sub></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Second_Example-step_2_correct"><span class="command">lemma</span></span> step_2_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"spec<span class="hidden">⇩</span><sub>2</sub> <span class="free">p</span> <span class="main">⟹</span> spec<span class="hidden">⇩</span><sub>1</sub> <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> spec<span class="hidden">⇩</span><sub>2</sub>_def spec<span class="hidden">⇩</span><sub>1</sub>_def reduce_wf_body_to_stmts proc<span class="hidden">⇩</span><sub>2</sub>_correct<span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Step 3›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:refII:stepIII}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The processing constraints
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> low_proc_non0<span class="hidden">⇩</span><sub>2</sub><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> low_proc_0<span class="hidden">⇩</span><sub>2</sub><span class="antiquote"><span class="antiquote">}</span></span></span></span> on <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">s<span class="hidden">⇩</span><sub>L</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
suggest the use of a conditional that
randomizes <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="inner_quoted"><span class="inner_quoted">''lowOut''</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> if <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="inner_quoted"><span class="inner_quoted">''lowIn''</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is 0,
and stores 1 plus <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="inner_quoted"><span class="inner_quoted">''lowIn''</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> into <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="inner_quoted"><span class="inner_quoted">''lowOut''</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> otherwise.›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">s<span class="hidden">⇩</span><sub>L</sub><span class="hidden">⇩</span><sub>0</sub></span> <span class="main">::</span> <span class="quoted">stmt</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">s<span class="hidden">⇩</span><sub>L</sub><span class="hidden">⇩</span><sub>0</sub></span> <span class="main">≡</span>
  IfEq
    <span class="main">(</span>Var <span class="inner_quoted">''lowIn''</span><span class="main">)</span>
    <span class="main">(</span>Const <span class="main">0</span><span class="main">)</span>
    <span class="main">(</span>Random <span class="inner_quoted">''lowOut''</span><span class="main">)</span>
    <span class="main">(</span>Assign <span class="inner_quoted">''lowOut''</span> <span class="main">(</span>Add <span class="main">(</span>Var <span class="inner_quoted">''lowIn''</span><span class="main">)</span> <span class="main">(</span>Const <span class="main">1</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Second_Example-wfs_s"><span class="command">lemma</span></span> wfs_s<span class="hidden">⇩</span><sub>L</sub><span class="hidden">⇩</span><sub>0</sub><span class="main">:</span>
  <span class="quoted"><span class="quoted">"wfs Γ<span class="hidden">⇩</span><sub>0</sub> s<span class="hidden">⇩</span><sub>L</sub><span class="hidden">⇩</span><sub>0</sub>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Second_Example-low_proc_non0_s"><span class="command">lemma</span></span> low_proc_non0_s<span class="hidden">⇩</span><sub>L</sub><span class="hidden">⇩</span><sub>0</sub><span class="main">:</span>
  <span class="quoted"><span class="quoted">"low_proc_non0<span class="hidden">⇩</span><sub>2</sub> s<span class="hidden">⇩</span><sub>L</sub><span class="hidden">⇩</span><sub>0</sub>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> low_proc_non0<span class="hidden">⇩</span><sub>2</sub>_def<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">σ</span> <span class="skolem">σ'</span>
  <span class="keyword3"><span class="command">assume</span></span> Match<span class="main">:</span> <span class="quoted"><span class="quoted">"match <span class="skolem">σ</span> Γ<span class="hidden">⇩</span><sub>0</sub>"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"s<span class="hidden">⇩</span><sub>L</sub><span class="hidden">⇩</span><sub>0</sub> <span class="main">⊳</span> <span class="skolem">σ</span> <span class="main">↝</span> Some <span class="skolem">σ'</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"the <span class="main">(</span><span class="skolem">σ</span> <span class="inner_quoted">''lowIn''</span><span class="main">)</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Assign <span class="inner_quoted">''lowOut''</span> <span class="main">(</span>Add <span class="main">(</span>Var <span class="inner_quoted">''lowIn''</span><span class="main">)</span> <span class="main">(</span>Const <span class="main">1</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">⊳</span> <span class="skolem">σ</span> <span class="main">↝</span> Some <span class="skolem">σ'</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> exec.cases<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">σ'</span> <span class="main">=</span> <span class="skolem">σ</span> <span class="main">(</span><span class="inner_quoted">''lowOut''</span> <span class="main">↦</span> the <span class="main">(</span>eval <span class="skolem">σ</span> <span class="main">(</span>Add <span class="main">(</span>Var <span class="inner_quoted">''lowIn''</span><span class="main">)</span> <span class="main">(</span>Const <span class="main">1</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> exec.cases<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> Match
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"the <span class="main">(</span><span class="skolem">σ'</span> <span class="inner_quoted">''lowOut''</span><span class="main">)</span> <span class="main">=</span> the <span class="main">(</span><span class="skolem">σ</span> <span class="inner_quoted">''lowIn''</span><span class="main">)</span> <span class="main">+</span> <span class="main">1</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> match_def add_opt_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Second_Example-low_proc_0_s"><span class="command">lemma</span></span> low_proc_0_s<span class="hidden">⇩</span><sub>L</sub><span class="hidden">⇩</span><sub>0</sub><span class="main">:</span>
  <span class="quoted"><span class="quoted">"low_proc_0<span class="hidden">⇩</span><sub>2</sub> s<span class="hidden">⇩</span><sub>L</sub><span class="hidden">⇩</span><sub>0</sub>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> low_proc_0<span class="hidden">⇩</span><sub>2</sub>_def<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">σ</span> <span class="skolem">u</span>
  <span class="keyword3"><span class="command">assume</span></span> Match<span class="main">:</span> <span class="quoted"><span class="quoted">"match <span class="skolem">σ</span> Γ<span class="hidden">⇩</span><sub>0</sub>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"the <span class="main">(</span><span class="skolem">σ</span> <span class="inner_quoted">''lowIn''</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> LowIn0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">σ</span> <span class="inner_quoted">''lowIn''</span> <span class="main">=</span> Some <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">σ</span> <span class="inner_quoted">''lowIn''</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> match_def<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> Match
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="inner_quoted">''lowOut''</span> <span class="main">∈</span> dom <span class="skolem">σ</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> match_def<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">σ'</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> ExecRand<span class="main">:</span> <span class="quoted"><span class="quoted">"Random <span class="inner_quoted">''lowOut''</span> <span class="main">⊳</span> <span class="skolem">σ</span> <span class="main">↝</span> Some <span class="skolem">σ'</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">σ'</span> <span class="main">=</span> <span class="skolem">σ</span> <span class="main">(</span><span class="inner_quoted">''lowOut''</span> <span class="main">↦</span> <span class="skolem">u</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> ExecRandomOK<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"the <span class="main">(</span><span class="skolem">σ'</span> <span class="inner_quoted">''lowOut''</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">u</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> ExecRand LowIn0
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">σ'</span><span class="main">.</span> s<span class="hidden">⇩</span><sub>L</sub><span class="hidden">⇩</span><sub>0</sub> <span class="main">⊳</span> <span class="skolem">σ</span> <span class="main">↝</span> Some <span class="bound">σ'</span> <span class="main">∧</span> the <span class="main">(</span><span class="bound">σ'</span> <span class="inner_quoted">''lowOut''</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">u</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> ExecCondTrue eval.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> eval.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Second_Example-low_proc_no_input_change_s"><span class="command">lemma</span></span> low_proc_no_input_change_s<span class="hidden">⇩</span><sub>L</sub><span class="hidden">⇩</span><sub>0</sub><span class="main">:</span>
  <span class="quoted"><span class="quoted">"low_proc_no_input_change s<span class="hidden">⇩</span><sub>L</sub><span class="hidden">⇩</span><sub>0</sub>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">unfold</span> low_proc_no_input_change_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">clarify</span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">σ</span> <span class="skolem">σ'</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"s<span class="hidden">⇩</span><sub>L</sub><span class="hidden">⇩</span><sub>0</sub> <span class="main">⊳</span> <span class="skolem">σ</span> <span class="main">↝</span> Some <span class="skolem">σ'</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"
    Random <span class="inner_quoted">''lowOut''</span> <span class="main">⊳</span> <span class="skolem">σ</span> <span class="main">↝</span> Some <span class="skolem">σ'</span> <span class="main">∨</span>
    Assign <span class="inner_quoted">''lowOut''</span> <span class="main">(</span>Add <span class="main">(</span>Var <span class="inner_quoted">''lowIn''</span><span class="main">)</span> <span class="main">(</span>Const <span class="main">1</span><span class="main">)</span><span class="main">)</span> <span class="main">⊳</span> <span class="skolem">σ</span> <span class="main">↝</span> Some <span class="skolem">σ'</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> exec.cases<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"
    the <span class="main">(</span><span class="skolem">σ'</span> <span class="inner_quoted">''lowIn''</span><span class="main">)</span> <span class="main">=</span> the <span class="main">(</span><span class="skolem">σ</span> <span class="inner_quoted">''lowIn''</span><span class="main">)</span> <span class="main">∧</span>
    the <span class="main">(</span><span class="skolem">σ'</span> <span class="inner_quoted">''highIn''</span><span class="main">)</span> <span class="main">=</span> the <span class="main">(</span><span class="skolem">σ</span> <span class="inner_quoted">''highIn''</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> exec.cases<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The refined specification is obtained
by simplification using the definition of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">s<span class="hidden">⇩</span><sub>L</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">spec<span class="hidden">⇩</span><sub>3</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"prog <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">spec<span class="hidden">⇩</span><sub>3</sub></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span>
  vars <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> vars<span class="hidden">⇩</span><sub>0</sub> <span class="main">∧</span>
  <span class="main">(</span><span class="main">∃</span><span class="bound">s<span class="hidden">⇩</span><sub>H</sub></span><span class="main">.</span>
    body_split <span class="free"><span class="bound"><span class="entity">p</span></span></span> s<span class="hidden">⇩</span><sub>L</sub><span class="hidden">⇩</span><sub>0</sub> <span class="bound">s<span class="hidden">⇩</span><sub>H</sub></span> <span class="main">∧</span>
    wfs Γ<span class="hidden">⇩</span><sub>0</sub> <span class="bound">s<span class="hidden">⇩</span><sub>H</sub></span> <span class="main">∧</span>
    high_proc<span class="hidden">⇩</span><sub>2</sub> <span class="bound">s<span class="hidden">⇩</span><sub>H</sub></span> <span class="main">∧</span>
    high_proc_no_low_output_change <span class="bound">s<span class="hidden">⇩</span><sub>H</sub></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Second_Example-step_3_correct"><span class="command">lemma</span></span> step_3_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"spec<span class="hidden">⇩</span><sub>3</sub> <span class="free">p</span> <span class="main">⟹</span> spec<span class="hidden">⇩</span><sub>2</sub> <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> spec<span class="hidden">⇩</span><sub>3</sub>_def spec<span class="hidden">⇩</span><sub>2</sub>_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span>
  wfs_s<span class="hidden">⇩</span><sub>L</sub><span class="hidden">⇩</span><sub>0</sub> low_proc_non0_s<span class="hidden">⇩</span><sub>L</sub><span class="hidden">⇩</span><sub>0</sub> low_proc_0_s<span class="hidden">⇩</span><sub>L</sub><span class="hidden">⇩</span><sub>0</sub> low_proc_no_input_change_s<span class="hidden">⇩</span><sub>L</sub><span class="hidden">⇩</span><sub>0</sub><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The non-determinism required by <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> low_proc_0<span class="antiquote"><span class="antiquote">}</span></span></span></span>
cannot be pop-refined away.
In particular, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">s<span class="hidden">⇩</span><sub>L</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> cannot be defined
to copy the high input to the low output when the low input is 0,
which would lead to a program that does not satisfy GNI.›</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Step 4›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:refII:stepIV}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The processing constraint <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> high_proc<span class="hidden">⇩</span><sub>2</sub><span class="antiquote"><span class="antiquote">}</span></span></span></span> on <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">s<span class="hidden">⇩</span><sub>H</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
can be satisfied in different ways.
A simple way is to pick the sum of the low and high inputs:
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> high_proc<span class="hidden">⇩</span><sub>2</sub><span class="antiquote"><span class="antiquote">}</span></span></span></span> is refined by replacing the inequality with an equality.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">high_proc<span class="hidden">⇩</span><sub>4</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"stmt <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">high_proc<span class="hidden">⇩</span><sub>4</sub></span> <span class="free"><span class="bound"><span class="entity">s<span class="hidden">⇩</span><sub>H</sub></span></span></span> <span class="main">≡</span>
  <span class="main">∀</span><span class="bound">σ</span> <span class="bound">σ'</span><span class="main">.</span>
    match <span class="bound">σ</span> Γ<span class="hidden">⇩</span><sub>0</sub> <span class="main">∧</span>
    <span class="free"><span class="bound"><span class="entity">s<span class="hidden">⇩</span><sub>H</sub></span></span></span> <span class="main">⊳</span> <span class="bound">σ</span> <span class="main">↝</span> Some <span class="bound">σ'</span> <span class="main">⟶</span>
    the <span class="main">(</span><span class="bound">σ'</span> <span class="inner_quoted">''highOut''</span><span class="main">)</span> <span class="main">=</span> the <span class="main">(</span><span class="bound">σ</span> <span class="inner_quoted">''lowIn''</span><span class="main">)</span> <span class="main">+</span> the <span class="main">(</span><span class="bound">σ</span> <span class="inner_quoted">''highIn''</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Second_Example-high_proc"><span class="command">lemma</span></span> high_proc<span class="hidden">⇩</span><sub>4</sub>_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"high_proc<span class="hidden">⇩</span><sub>4</sub> <span class="free">s<span class="hidden">⇩</span><sub>H</sub></span> <span class="main">⟹</span> high_proc<span class="hidden">⇩</span><sub>2</sub> <span class="free">s<span class="hidden">⇩</span><sub>H</sub></span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> high_proc<span class="hidden">⇩</span><sub>4</sub>_def high_proc<span class="hidden">⇩</span><sub>2</sub>_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The refined specification is obtained
by substituting the refined processing constraint on <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">s<span class="hidden">⇩</span><sub>H</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">spec<span class="hidden">⇩</span><sub>4</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"prog <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">spec<span class="hidden">⇩</span><sub>4</sub></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span>
  vars <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> vars<span class="hidden">⇩</span><sub>0</sub> <span class="main">∧</span>
  <span class="main">(</span><span class="main">∃</span><span class="bound">s<span class="hidden">⇩</span><sub>H</sub></span><span class="main">.</span>
    body_split <span class="free"><span class="bound"><span class="entity">p</span></span></span> s<span class="hidden">⇩</span><sub>L</sub><span class="hidden">⇩</span><sub>0</sub> <span class="bound">s<span class="hidden">⇩</span><sub>H</sub></span> <span class="main">∧</span>
    wfs Γ<span class="hidden">⇩</span><sub>0</sub> <span class="bound">s<span class="hidden">⇩</span><sub>H</sub></span> <span class="main">∧</span>
    high_proc<span class="hidden">⇩</span><sub>4</sub> <span class="bound">s<span class="hidden">⇩</span><sub>H</sub></span> <span class="main">∧</span>
    high_proc_no_low_output_change <span class="bound">s<span class="hidden">⇩</span><sub>H</sub></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Second_Example-step_4_correct"><span class="command">lemma</span></span> step_4_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"spec<span class="hidden">⇩</span><sub>4</sub> <span class="free">p</span> <span class="main">⟹</span> spec<span class="hidden">⇩</span><sub>3</sub> <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> spec<span class="hidden">⇩</span><sub>4</sub>_def spec<span class="hidden">⇩</span><sub>3</sub>_def high_proc<span class="hidden">⇩</span><sub>4</sub>_correct<span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Step 5›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:refII:stepV}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The refined processing constraint <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> high_proc<span class="hidden">⇩</span><sub>4</sub><span class="antiquote"><span class="antiquote">}</span></span></span></span> on <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">s<span class="hidden">⇩</span><sub>H</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
suggest the use of an assignment that
stores the sum of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="inner_quoted"><span class="inner_quoted">''lowIn''</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="inner_quoted"><span class="inner_quoted">''highIn''</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
into <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="inner_quoted"><span class="inner_quoted">''highOut''</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">s<span class="hidden">⇩</span><sub>H</sub><span class="hidden">⇩</span><sub>0</sub></span> <span class="main">::</span> <span class="quoted">stmt</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">s<span class="hidden">⇩</span><sub>H</sub><span class="hidden">⇩</span><sub>0</sub></span> <span class="main">≡</span> Assign <span class="inner_quoted">''highOut''</span> <span class="main">(</span>Add <span class="main">(</span>Var <span class="inner_quoted">''lowIn''</span><span class="main">)</span> <span class="main">(</span>Var <span class="inner_quoted">''highIn''</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Second_Example-wfs_s"><span class="command">lemma</span></span> wfs_s<span class="hidden">⇩</span><sub>H</sub><span class="hidden">⇩</span><sub>0</sub><span class="main">:</span>
  <span class="quoted"><span class="quoted">"wfs Γ<span class="hidden">⇩</span><sub>0</sub> s<span class="hidden">⇩</span><sub>H</sub><span class="hidden">⇩</span><sub>0</sub>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Second_Example-high_proc"><span class="command">lemma</span></span> high_proc<span class="hidden">⇩</span><sub>4</sub>_s<span class="hidden">⇩</span><sub>H</sub><span class="hidden">⇩</span><sub>0</sub><span class="main">:</span>
  <span class="quoted"><span class="quoted">"high_proc<span class="hidden">⇩</span><sub>4</sub> s<span class="hidden">⇩</span><sub>H</sub><span class="hidden">⇩</span><sub>0</sub>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> high_proc<span class="hidden">⇩</span><sub>4</sub>_def<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">σ</span> <span class="skolem">σ'</span>
  <span class="keyword3"><span class="command">assume</span></span> Match<span class="main">:</span> <span class="quoted"><span class="quoted">"match <span class="skolem">σ</span> Γ<span class="hidden">⇩</span><sub>0</sub>"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"s<span class="hidden">⇩</span><sub>H</sub><span class="hidden">⇩</span><sub>0</sub> <span class="main">⊳</span> <span class="skolem">σ</span> <span class="main">↝</span> Some <span class="skolem">σ'</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"
    <span class="skolem">σ'</span> <span class="main">=</span> <span class="skolem">σ</span> <span class="main">(</span><span class="inner_quoted">''highOut''</span> <span class="main">↦</span> the <span class="main">(</span>eval <span class="skolem">σ</span> <span class="main">(</span>Add <span class="main">(</span>Var <span class="inner_quoted">''lowIn''</span><span class="main">)</span> <span class="main">(</span>Var <span class="inner_quoted">''highIn''</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> exec.cases<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> Match
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"the <span class="main">(</span><span class="skolem">σ'</span> <span class="inner_quoted">''highOut''</span><span class="main">)</span> <span class="main">=</span> the <span class="main">(</span><span class="skolem">σ</span> <span class="inner_quoted">''lowIn''</span><span class="main">)</span> <span class="main">+</span> the <span class="main">(</span><span class="skolem">σ</span> <span class="inner_quoted">''highIn''</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> match_def add_opt_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Second_Example-high_proc_no_low_output_change_s"><span class="command">lemma</span></span> high_proc_no_low_output_change_s<span class="hidden">⇩</span><sub>H</sub><span class="hidden">⇩</span><sub>0</sub><span class="main">:</span>
  <span class="quoted"><span class="quoted">"high_proc_no_low_output_change s<span class="hidden">⇩</span><sub>H</sub><span class="hidden">⇩</span><sub>0</sub>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> high_proc_no_low_output_change_def <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> exec.cases<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The refined specification is obtained
by simplification using the definition of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">s<span class="hidden">⇩</span><sub>H</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">spec<span class="hidden">⇩</span><sub>5</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"prog <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">spec<span class="hidden">⇩</span><sub>5</sub></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span> vars <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> vars<span class="hidden">⇩</span><sub>0</sub> <span class="main">∧</span> body_split <span class="free"><span class="bound"><span class="entity">p</span></span></span> s<span class="hidden">⇩</span><sub>L</sub><span class="hidden">⇩</span><sub>0</sub> s<span class="hidden">⇩</span><sub>H</sub><span class="hidden">⇩</span><sub>0</sub>"</span></span>

<span class="keyword1" id="Second_Example-step_5_correct"><span class="command">lemma</span></span> step_5_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"spec<span class="hidden">⇩</span><sub>5</sub> <span class="free">p</span> <span class="main">⟹</span> spec<span class="hidden">⇩</span><sub>4</sub> <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> spec<span class="hidden">⇩</span><sub>5</sub>_def spec<span class="hidden">⇩</span><sub>4</sub>_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> wfs_s<span class="hidden">⇩</span><sub>H</sub><span class="hidden">⇩</span><sub>0</sub> high_proc<span class="hidden">⇩</span><sub>4</sub>_s<span class="hidden">⇩</span><sub>H</sub><span class="hidden">⇩</span><sub>0</sub> high_proc_no_low_output_change_s<span class="hidden">⇩</span><sub>H</sub><span class="hidden">⇩</span><sub>0</sub><span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Step 6›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:refII:stepVI}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> spec<span class="hidden">⇩</span><sub>5</sub><span class="antiquote"><span class="antiquote">}</span></span></span></span>, which defines the variables and the body,
is refined to characterize a unique program in explicit syntactic form.›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">p<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">::</span> <span class="quoted">prog</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">p<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">≡</span> <span class="main">⦇</span>vars <span class="main">=</span> vars<span class="hidden">⇩</span><sub>0</sub><span class="main">,</span> body <span class="main">=</span> Seq s<span class="hidden">⇩</span><sub>L</sub><span class="hidden">⇩</span><sub>0</sub> s<span class="hidden">⇩</span><sub>H</sub><span class="hidden">⇩</span><sub>0</sub><span class="main">⦈</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">spec<span class="hidden">⇩</span><sub>6</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"prog <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">spec<span class="hidden">⇩</span><sub>6</sub></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> p<span class="hidden">⇩</span><sub>0</sub>"</span></span>

<span class="keyword1" id="Second_Example-step_6_correct"><span class="command">lemma</span></span> step_6_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"spec<span class="hidden">⇩</span><sub>6</sub> <span class="free">p</span> <span class="main">⟹</span> spec<span class="hidden">⇩</span><sub>5</sub> <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> spec<span class="hidden">⇩</span><sub>6</sub>_def spec<span class="hidden">⇩</span><sub>5</sub>_def body_split_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The program satisfies <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> spec<span class="hidden">⇩</span><sub>0</sub><span class="antiquote"><span class="antiquote">}</span></span></span></span> by construction.
The program witnesses the consistency of the requirements,
i.e.\ the fact that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> spec<span class="hidden">⇩</span><sub>0</sub><span class="antiquote"><span class="antiquote">}</span></span></span></span> is not always false.›</span></span>

<span class="keyword1" id="Second_Example-p"><span class="command">lemma</span></span> p<span class="hidden">⇩</span><sub>0</sub>_sat_spec<span class="hidden">⇩</span><sub>0</sub><span class="main">:</span>
  <span class="quoted"><span class="quoted">"spec<span class="hidden">⇩</span><sub>0</sub> p<span class="hidden">⇩</span><sub>0</sub>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span>
 step_1_correct
 step_2_correct
 step_3_correct
 step_4_correct
 step_5_correct
 step_6_correct
 spec<span class="hidden">⇩</span><sub>6</sub>_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹From <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> p<span class="hidden">⇩</span><sub>0</sub><span class="antiquote"><span class="antiquote">}</span></span></span></span>, the program text
\begin{verbatim}
  prog {
    vars {
      lowIn
      lowOut
      highIn
      highOut
    }
    body {
      if (lowIn == 0) {
        randomize lowOut;
      } else {
        lowOut = lowIn + 1;
      }
      highOut = lowIn + highIn;
    }
  }
\end{verbatim}
is easily obtained.›</span></span>


<span class="keyword2"><span class="keyword">end</span></span> <span class="main">%</span>invisible
</pre>
</div><div id="General_Remarks">
<div class="head">
<h1>Theory General_Remarks</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">chapter</span></span> <span class="quoted"><span class="plain_text">‹General Remarks›</span></span>

<span class="keyword1"><span class="command">theory</span></span> <span class="main">%</span>invisible General_Remarks
<span class="keyword2"><span class="keyword">imports</span></span> <a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{chap:general}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The following remarks apply to pop-refinement in general,
beyond the examples in \chapref{chap:exampleI} and \chapref{chap:exampleII}.›</span></span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Program-Level Requirements›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:progreq}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹By predicating directly over programs,
a pop-refinement specification
(like <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">spec<span class="hidden">⇩</span><sub>0</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
in \secref{sec:specificationI} and \secref{sec:specificationII})
can express program-level requirements
that are defined in terms of the vocabulary of the target language,
e.g.\
constraints on memory footprint
(important for embedded software),
restrictions on calls to system libraries to avoid or limit information leaks
(important for security),
conformance to coding standards
(important for certain certifications),
and use or provision of interfaces
(important for integration with existing code).
Simple examples are
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">wfp</span></span> <span class="free"><span class="free">p</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> in \secref{sec:specificationI} and \secref{sec:specificationII},
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">para</span></span> <span class="free"><span class="free">p</span></span> <span class="main"><span class="main">=</span></span> <span class="main"><span class="main">[</span></span><span class="inner_quoted"><span class="inner_quoted">''x''</span></span><span class="main"><span class="main">,</span></span> <span class="inner_quoted"><span class="inner_quoted">''y''</span></span><span class="main"><span class="main">]</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> in \secref{sec:specificationI},
and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">iovars</span></span> <span class="free"><span class="free">p</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> in \secref{sec:specificationII}.›</span></span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Non-Functional Requirements›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:nonfuncreq}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Besides functional requirements,
a pop-refinement specification can express non-functional requirements,
e.g.\ constraints on
computational complexity,
timing,
power consumption,
etc.%
\footnote{In order to express these requirements,
the formalized semantics of the target language
must suitably include non-functional aspects,
as in the simple model in \secref{sec:nonfunc}.}
A simple example is
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">costp</span></span> <span class="free"><span class="free">p</span></span> <span class="main"><span class="main">≤</span></span> <span class="main"><span class="main">(</span></span><span class="numeral"><span class="numeral">3</span></span><span class="main"><span class="main">::</span></span>nat<span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> in \secref{sec:specificationI}.›</span></span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Links with High-Level Requirements›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:hilevreq}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A pop-refinement specification can explicate links
between high-level requirements and target programs.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹For example,
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">∀</span></span><span class="bound"><span class="bound">x</span></span> <span class="bound"><span class="bound">y</span></span><span class="main"><span class="main">.</span></span> <span class="free"><span class="free">exec</span></span> <span class="free"><span class="free">p</span></span> <span class="main"><span class="main">[</span></span><span class="bound"><span class="bound">x</span></span><span class="main"><span class="main">,</span></span> <span class="bound"><span class="bound">y</span></span><span class="main"><span class="main">]</span></span> <span class="main"><span class="main">=</span></span> Some <span class="main"><span class="main">(</span></span><span class="free"><span class="free">f</span></span> <span class="bound"><span class="bound">x</span></span> <span class="bound"><span class="bound">y</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">spec<span class="hidden">⇩</span><sub>0</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> in \secref{sec:specificationI}
links the high-level functional requirement expressed by <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">f</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
to the target program <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">p</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.%
\footnote{Similarly, the functional requirements in \secref{sec:specificationII}
could be expressed abstractly
in terms of mappings between low and high inputs and outputs
(without reference to program variables and executions)
and linked to program variables and executions.
But \secref{sec:specificationII} expresses such functional requirements
directly in terms of programs
to keep the example (whose focus is on hyperproperties) simpler.}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹As another example,
a function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>sort :: nat list ⇒ nat list›</span></span></span></span>,
defined to map each list of natural numbers to its sorted permutation,
expresses a high-level functional requirement
that can be realized in different ways.
An option is a procedure that destructively sorts an array in place.
Another option is a procedure that returns a newly created sorted linked list
from a linked list passed as argument and left unmodified.
A pop-refinement specification can pin down the choice,
which matters to external code that uses the procedure.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹As a third example,
a high-level model of a video game or physical simulator
could use real numbers and differential equations.
A pop-refinement specification could
state required bounds on how
the idealized model is approximated by an implementation
that uses floating point numbers and difference equations.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Different pop-refinement specifications
could use the same high-level requirements
to constrain programs in different target languages or in different ways,
as in the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">sort</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> example above.
As another example,
the high-level behavior of an operating system
could be described by a state transition system
that abstractly models internal states and system calls;
the same state transition system could be used
in a pop-refinement specification of a Haskell simulator that runs on a desktop,
as well as in a pop-refinement specification of a C/Assembly implementation
that runs on a specific hardware platform.›</span></span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Non-Determinism and Under-Specification›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:nondet}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The interaction of refinement
with non-determinism and under-specification
is delicate in general.
The one-to-many associations of a relational specification
(e.g.\ a state transition system
where the next-state relation may associate
multiple new states to each old state)
could be interpreted as
non-determinism
(i.e.\ different outcomes at different times, from the same state)
or under-specification
(i.e.\ any outcome is allowed, deterministically or non-deterministically).
Hyperproperties like GNI
are consistent with the interpretation as non-determinism,
because security depends on the ability to yield different outcomes,
e.g.\ generating a nonce in a cryptographic protocol.
The popular notion of refinement as inclusion of sets of traces
(e.g.~\cite{AbadiLamportRefinement})
is consistent  with the interpretation as under-specification,
because a refined specification is allowed to reduce the possible outcomes.
Thus, hyperproperties are not always preserved by
refinement as trace set inclusion~\cite{ClarksonSchneiderHyperproperties}.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹As exemplified in \secref{sec:specificationII},
a pop-refinement specification can explicitly distinguish
non-determinism and under-specification.
Each pop-refinement step preserves all the hyperproperties
expressed or implied by the requirement specification.%
\footnote{Besides security hyperproperties expressed in terms of non-determinism,
pop-refinement can handle more explicit security randomness properties.
The formalized semantics of a target language could
manipulate probability distributions over values (instead of just values),
with random number generation libraries
that return known distributions (e.g.\ uniform),
and with language operators that transform distributions.
A pop-refinement specification could include
randomness requirements on program outcomes expressed in terms of distributions,
and each pop-refinement step would preserve such requirements.}›</span></span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Specialized Formalisms›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:specform}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Specialized formalisms (e.g.\ state machines, temporal logic),
shallowly or deeply embedded into the logic of the theorem prover
(e.g.~\cite{AFP-Statecharts,AFP_TLA}),
can be used to express some of the requirements
of a pop-refinement specification.
The logic of the theorem prover provides semantic integration
of different specialized formalisms.›</span></span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Strict and Non-Strict Refinement Steps›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:strictref}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In a pop-refinement step from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">spec<span class="hidden">⇩</span><sub>i</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>spec<span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>+</sub><span class="hidden">⇩</span><sub>1</sub>›</span></span></span></span>,
the two predicates may be equivalent, i.e.\ <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>spec<span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>+</sub><span class="hidden">⇩</span><sub>1</sub> = spec<span class="hidden">⇩</span><sub>i</sub>›</span></span></span></span>.
But the formulation of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>spec<span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>+</sub><span class="hidden">⇩</span><sub>1</sub>›</span></span></span></span> should be ``closer''
to the implementation than the formulation of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">spec<span class="hidden">⇩</span><sub>i</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
An example is in \secref{sec:refI:stepI}.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹When the implication <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>spec<span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>+</sub><span class="hidden">⇩</span><sub>1</sub> p ⟹ spec<span class="hidden">⇩</span><sub>i</sub> p›</span></span></span></span> is strict,
potential implementations are eliminated.
Since the final predicate of a pop-refinement derivation
must characterize a unique program,
some refinement steps must be strict---%
unless the initial predicate <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">spec<span class="hidden">⇩</span><sub>0</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
is satisfiable by a unique program,
which is unlikely.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A strict refinement step may lead to a blind alley
where <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>spec<span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>+</sub><span class="hidden">⇩</span><sub>1</sub> = λp. False›</span></span></span></span>,
which cannot lead to a final predicate that characterizes a unique program.
An example is discussed in \secref{sec:refI:stepIV}.›</span></span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Final Predicate›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:lastpred}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The predicate that concludes a pop-refinement derivation
must have the form <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">spec<span class="hidden">⇩</span><sub>n</sub></span></span> <span class="free"><span class="free">p</span></span> <span class="main"><span class="main">≡</span></span> <span class="free"><span class="free">p</span></span> <span class="main"><span class="main">=</span></span> <span class="free"><span class="free">p<span class="hidden">⇩</span><sub>0</sub></span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>,
where <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">p<span class="hidden">⇩</span><sub>0</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is the representation of a program's abstract syntax
in the theorem prover,
as in \secref{sec:refI:stepVII} and \secref{sec:refII:stepVI}.
This form guarantees that
the predicate characterizes exactly one program
and that the program is explicitly determined.
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">p<span class="hidden">⇩</span><sub>0</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> witnesses the consistency of the requirements,
i.e.\ the fact that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">spec<span class="hidden">⇩</span><sub>0</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is not always false;
inconsistent requirements cannot lead to a predicate of this form.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A predicate of the form <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">spec<span class="hidden">⇩</span><sub>i</sub></span></span> <span class="main"><span class="main">≡</span></span> <span class="free"><span class="free">p</span></span> <span class="main"><span class="main">=</span></span> <span class="free"><span class="free">p<span class="hidden">⇩</span><sub>0</sub></span></span> <span class="main"><span class="main">∧</span></span> <span class="free"><span class="free">Φ</span></span> <span class="free"><span class="free">p</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
may not characterize a unique program:
if <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">Φ</span></span> <span class="free"><span class="free">p<span class="hidden">⇩</span><sub>0</sub></span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is false, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">spec<span class="hidden">⇩</span><sub>i</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is always false.
To conclude the derivation, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">Φ</span></span> <span class="free"><span class="free">p<span class="hidden">⇩</span><sub>0</sub></span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> must be proved.
But it may be easier to prove the constraints expressed by <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">Φ</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
as <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">p<span class="hidden">⇩</span><sub>0</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is constructed in the derivation.
For example,
deriving a program from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">spec<span class="hidden">⇩</span><sub>0</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> in \secref{sec:specificationI}
based on the functional constraint and ignoring the cost constraint
would lead to a predicate <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">spec<span class="hidden">⇩</span><sub>i</sub></span></span> <span class="main"><span class="main">≡</span></span> <span class="free"><span class="free">p</span></span> <span class="main"><span class="main">=</span></span> <span class="free"><span class="free">p<span class="hidden">⇩</span><sub>0</sub></span></span> <span class="main"><span class="main">∧</span></span> <span class="free"><span class="free">costp</span></span> <span class="free"><span class="free">p</span></span> <span class="main"><span class="main">≤</span></span> <span class="main"><span class="main">(</span></span><span class="numeral"><span class="numeral">3</span></span><span class="main"><span class="main">::</span></span>nat<span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>,
where <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">costp</span></span> <span class="free"><span class="free">p<span class="hidden">⇩</span><sub>0</sub></span></span> <span class="main"><span class="main">≤</span></span> <span class="main"><span class="main">(</span></span><span class="numeral"><span class="numeral">3</span></span><span class="main"><span class="main">::</span></span>nat<span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> must be proved to conclude the derivation;
instead, the derivation in \secref{sec:refinementI}
proves the cost constraint as <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">p<span class="hidden">⇩</span><sub>0</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is constructed.
Taking all constraints into account at each stage of the derivation can help
choose the next refinement step
and reduce the chance of blind alleys
(cf.\ \secref{sec:refI:stepIV}).›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The final predicate <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">spec<span class="hidden">⇩</span><sub>n</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> expresses
a purely syntactic requirement,
while the initial predicate <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">spec<span class="hidden">⇩</span><sub>0</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> usually includes
semantic requirements.
A pop-refinement derivation progressively turns
semantic requirements into syntactic requirements.
This may involve
rephrasing functional requirements
to use only operations supported by the target language
(e.g.\ lemma <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f_rephrased›</span></span></span></span> in \secref{sec:refI:stepIV}),
obtaining shallowly embedded program fragments,
and turning them into their deeply embedded counterparts
(e.g.\ \secref{sec:refI:stepV} and \secref{sec:refI:stepVI}).%
\footnote{In \secref{sec:refinementII},
program fragments are introduced directly,
without going through shallow embeddings.}›</span></span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Proof Coverage›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label {sec:allproved}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In a chain of predicate inclusions
as in \secref{sec:refinementI} and \secref{sec:refinementII},
the proofs checked by the theorem prover encompass the range
from the specified requirements to the implementation code.
No separate code generator is needed
to turn low-level specifications into code:
pop-refinement folds code generation into the refinement sequence,
providing fine-grained control on the implementation code.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A purely syntactic pretty-printer is needed
to turn program abstract syntax,
as in \secref{sec:refI:stepVII} and \secref{sec:refII:stepVI},
to concrete syntax.
This pretty-printer can be eliminated
by formalizing in the theorem prover
the concrete syntax of the target language
and its relation to the abstract syntax,
and by defining the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">spec<span class="hidden">⇩</span><sub>i</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> predicates over program concrete syntax---%
thus, folding pretty-printing into the refinement sequence.›</span></span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Generality and Flexibility›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:genflex}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Inclusion of predicates over programs
is a general and flexible notion of refinement.
More specialized notions of refinement
(e.g.~\cite{HoareData,MilnerSimulation})
can be used for any auxiliary types, functions, etc.\
out of which the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">spec<span class="hidden">⇩</span><sub>i</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> predicates may be constructed,
as long as the top-level implication
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>spec<span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>+</sub><span class="hidden">⇩</span><sub>1</sub> p ⟹ spec<span class="hidden">⇩</span><sub>i</sub> p›</span></span></span></span> holds at every step.›</span></span>


<span class="keyword2"><span class="keyword">end</span></span> <span class="main">%</span>invisible
</pre>
</div><div id="Related_Work">
<div class="head">
<h1>Theory Related_Work</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">chapter</span></span> <span class="quoted"><span class="plain_text">‹Related Work›</span></span>

<span class="keyword1"><span class="command">theory</span></span> <span class="main">%</span>invisible Related_Work
<span class="keyword2"><span class="keyword">imports</span></span> <a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{chap:related}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In existing approaches to stepwise refinement
(e.g.~\cite{BBook,ZReference,SystematicVDM,RefinementCalculus}),
specifications express requirements less directly than pop-refinement:
a specification implicitly characterizes its possible implementations
as the set of programs that can be derived from the specification
via refinement (and code generation).
This is a more restrictive way to characterize a set of programs
than defining a predicate over deeply embedded programs
in a theorem prover's general-purpose logic
(as in pop-refinement).›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This restrictiveness precludes
some of the abilities discussed in \chapref{chap:general},
e.g.\ the ability to express, and guarantee through refinement,
certain program-level requirements like constraints on memory footprint.
A derivation may be steered to produce a program
that satisfies desired requirements not expressed by the specification,
but the derivation or program must be examined in order to assess that,
instead of just examining the specification
and letting the theorem prover automatically check
the sequence of refinement steps
(as with pop-refinement).
Existing refinement approaches could be extended
to handle additional kinds of requirements (e.g.\ non-functional),
but for pop-refinement no theorem prover extensions are necessary.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In existing refinement approaches,
each refinement step yields a new specification that characterizes
a (strict or non-strict) subset of the implementations
characterized by the old specification,
analogously to pop-refinement.
However, the restrictiveness explained above,
together with any inherent constraints
imposed by the refinement relation over specifications,
limits the choice of the subset,
providing less fine-grained control than pop-refinement.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In existing refinement approaches,
the ``indirection'' between a specification and its set of implementations
may create a disconnect between
properties of a specification and properties of its implementations.
For example, along the lines discussed in \secref{sec:nondet},
a relational specification may satisfy a hyperproperty
but some of its implementations may not,
because the refinement relation may reduce the possible behaviors.
Since a pop-refinement specification directly makes statements
about the possible implementations of the requirements,
this kind of disconnect is avoided.›</span></span>


<span class="keyword2"><span class="keyword">end</span></span> <span class="main">%</span>invisible
</pre>
</div><div id="Future_Work">
<div class="head">
<h1>Theory Future_Work</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">chapter</span></span> <span class="quoted"><span class="plain_text">‹Future Work›</span></span>

<span class="keyword1"><span class="command">theory</span></span> <span class="main">%</span>invisible Future_Work
<span class="keyword2"><span class="keyword">imports</span></span> <a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{chap:future}›</span></span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Populating the Framework›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:populate}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Pop-refinement provides a framework,
which must be populated with re-usable
concepts, methodologies, and theorem prover libraries
for full fruition.
The simple examples in \chapref{chap:exampleI} and \chapref{chap:exampleII},
and the discussion in \chapref{chap:general},
suggests a few initial ideas.
Working out examples of increasing complexity should suggest more ideas.›</span></span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Automated Transformations›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:xform}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A pop-refinement step from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">spec<span class="hidden">⇩</span><sub>i</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> can be performed manually,
by writing down <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>spec<span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>+</sub><span class="hidden">⇩</span><sub>1</sub>›</span></span></span></span> and proving <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>spec<span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>+</sub><span class="hidden">⇩</span><sub>1</sub> p ⟹ spec<span class="hidden">⇩</span><sub>i</sub> p›</span></span></span></span>.
It is sometimes possible to generate <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>spec<span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>+</sub><span class="hidden">⇩</span><sub>1</sub>›</span></span></span></span> from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">spec<span class="hidden">⇩</span><sub>i</sub></span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>,
along with a proof of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>spec<span class="hidden">⇩</span><sub>i</sub><span class="hidden">⇩</span><sub>+</sub><span class="hidden">⇩</span><sub>1</sub> p ⟹ spec<span class="hidden">⇩</span><sub>i</sub> p›</span></span></span></span>,
using automated transformation techniques like
term rewriting,
application of algorithmic templates,
and term construction by witness finding,
e.g.\ \cite{SmithMarktoberdorf,SpecwareWebSite}.
Automated transformations may require
parameters to be provided and applicability conditions to be proved,
but should generally save effort
and make derivations more robust against changes in requirement specifications.
Extending existing theorem provers with automated transformation capabilities
would be advantageous for pop-refinement.›</span></span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Other Kinds of Design Objects›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:otherdesign}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹It has been suggested~\cite{LambertPrivate}
that pop-refinement could be used
to develop other kinds of design objects than programs,
e.g.\ protocols, digital circuits, and hybrid systems.
Perhaps pop-refinement could be used to develop
engines, cars, buildings, etc.
So long as these design objects can be described
by languages amenable to formalization,
pop-refinement should be applicable.›</span></span>


<span class="keyword2"><span class="keyword">end</span></span> <span class="main">%</span>invisible
</pre>
</div>