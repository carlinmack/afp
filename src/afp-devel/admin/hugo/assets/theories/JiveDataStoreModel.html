<div id="TypeIds">
<div class="head">
<h1>Theory TypeIds</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Jive Data and Store Model
    Author:      Nicole Rauch &lt;rauch at informatik.uni-kl.de&gt;, 2005
    Maintainer:  Nicole Rauch &lt;rauch at informatik.uni-kl.de&gt;
    License:     LGPL
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹TypeIds›</span></span>

<span class="keyword1"><span class="command">theory</span></span> TypeIds <span class="keyword2"><span class="keyword">imports</span></span> <a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL/Main.html">Main</a> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{java_typeid_definitions}
This theory contains the program specific names of abstract and concrete classes and 
interfaces. It has to 
be generated for each program we want to verify. 
The following classes are an example taken from the program given in Sect. 
\ref{example-program}.
They are complemented by the classes that are known to exist in each Java program 
implicitly,
namely \texttt{Object}, \texttt{Exception}, \texttt{ClassCastException} and 
\texttt{NullPointerException}.
The example program does not contain any abstract classes, but since we cannot 
formalize datatypes without
constructors, we have to insert a dummy class which we call \texttt{Dummy}.

The datatype CTypeId must contain a constructor called \texttt{Object} because subsequent
proofs in the Subtype theory rely on it.
›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> CTypeId <span class="main">=</span> CounterImpl <span class="main">|</span> UndoCounter 
                 <span class="main">|</span> Object <span class="main">|</span> Exception <span class="main">|</span> ClassCastException <span class="main">|</span> NullPointerException
  <span class="comment1">― ‹The last line contains the classes that exist in every program by default.›</span>
<span class="keyword1"><span class="command">datatype</span></span> ITypeId <span class="main">=</span> Counter
<span class="keyword1"><span class="command">datatype</span></span> ATypeId <span class="main">=</span> Dummy
  <span class="comment1">― ‹we cannot have an empty type.›</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
Why do we need different datatypes for the different type identifiers?
Because we want to be able to distinguish the different identifier kinds.
This has a practical reason: If we formalize objects as "ObjectId $\times$ TypeId"
and if we quantify over all objects, we get a lot of objects that do not
exist, namely all objects that bear an interface type identifier or 
abstract class identifier. This is not very helpful. Therefore, we separate
the three identifier kinds from each other.
›</span></span>




<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="JavaType">
<div class="head">
<h1>Theory JavaType</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Jive Data and Store Model
    Author:      Norbert Schirmer &lt;schirmer at informatik.tu-muenchen.de&gt;, 2003
    Maintainer:  Nicole Rauch &lt;rauch at informatik.uni-kl.de&gt;
    License:     LGPL
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Java-Type›</span></span>
 
<span class="keyword1"><span class="command">theory</span></span> JavaType <span class="keyword2"><span class="keyword">imports</span></span> <span class="quoted">"<a href="#TypeIds">../Isa_Counter/TypeIds</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This theory formalizes the types that appear in a Java program. Note that
the types defined by the classes and interfaces are formalized via their identifiers.
This way, this theory is program-independent.
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We only want to formalize one-dimensional arrays. Therefore, we 
describe the types that can be used as element types of arrays. This excludes
the \texttt{null} type and array types themselves. This way, we get a finite 
number
of types in our type hierarchy, and the subtype relations can be given
explicitly (see Sec. \ref{direct_subtype_relations}). 
If desired, this can be extended in the future by using Javatype as argument
type of the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>ArrT›</span></span></span></span> type constructor. This will yield infinitely many
types.
›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> Arraytype <span class="main">=</span> BoolAT <span class="main">|</span> IntgAT <span class="main">|</span> ShortAT <span class="main">|</span> ByteAT
                  <span class="main">|</span> CClassAT <span class="quoted">CTypeId</span> <span class="main">|</span> AClassAT <span class="quoted">ATypeId</span>
                  <span class="main">|</span> InterfaceAT <span class="quoted">ITypeId</span>

<span class="keyword1"><span class="command">datatype</span></span> Javatype <span class="main">=</span> BoolT <span class="main">|</span> IntgT <span class="main">|</span> ShortT <span class="main">|</span> ByteT <span class="main">|</span> NullT <span class="main">|</span> ArrT <span class="quoted">Arraytype</span>
                  <span class="main">|</span> CClassT <span class="quoted">CTypeId</span> <span class="main">|</span> AClassT <span class="quoted">ATypeId</span>
                  <span class="main">|</span> InterfaceT <span class="quoted">ITypeId</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We need a function that widens <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">Arraytype</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">Javatype</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">at2jt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Arraytype <span class="main">⇒</span> Javatype"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">at2jt</span> <span class="free"><span class="bound"><span class="entity">at</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">at</span></span></span> <span class="keyword1">of</span> 
         BoolAT               <span class="main">⇒</span> BoolT
       <span class="main">|</span> IntgAT               <span class="main">⇒</span> IntgT
       <span class="main">|</span> ShortAT              <span class="main">⇒</span> ShortT
       <span class="main">|</span> ByteAT               <span class="main">⇒</span> ByteT
       <span class="main">|</span> CClassAT <span class="bound">CTypeId</span>     <span class="main">⇒</span> CClassT <span class="bound">CTypeId</span>
       <span class="main">|</span> AClassAT <span class="bound">ATypeId</span>     <span class="main">⇒</span> AClassT <span class="bound">ATypeId</span>
       <span class="main">|</span> InterfaceAT <span class="bound">ITypeId</span>  <span class="main">⇒</span> InterfaceT <span class="bound">ITypeId</span><span class="main">)</span>"</span></span>
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We define two predicates that separate the primitive types and the 
class types.
›</span></span>
                             
<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">isprimitive</span><span class="main">::</span> <span class="quoted"><span class="quoted">"Javatype <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">isprimitive</span> BoolT <span class="main">=</span> True"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">isprimitive</span> IntgT <span class="main">=</span> True"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">isprimitive</span> ShortT <span class="main">=</span> True"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">isprimitive</span> ByteT <span class="main">=</span> True"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">isprimitive</span> NullT <span class="main">=</span> False"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">isprimitive</span> <span class="main">(</span>ArrT <span class="free"><span class="bound"><span class="entity">T</span></span></span><span class="main">)</span> <span class="main">=</span> False"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">isprimitive</span> <span class="main">(</span>CClassT <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">)</span> <span class="main">=</span> False"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">isprimitive</span> <span class="main">(</span>AClassT <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">)</span> <span class="main">=</span> False"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">isprimitive</span> <span class="main">(</span>InterfaceT <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> <span class="main">=</span> False"</span></span> 

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">isclass</span><span class="main">::</span> <span class="quoted"><span class="quoted">"Javatype <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">isclass</span> BoolT <span class="main">=</span> False"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">isclass</span> IntgT <span class="main">=</span> False"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">isclass</span> ShortT <span class="main">=</span> False"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">isclass</span> ByteT <span class="main">=</span> False"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">isclass</span> NullT <span class="main">=</span> False"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">isclass</span> <span class="main">(</span>ArrT <span class="free"><span class="bound"><span class="entity">T</span></span></span><span class="main">)</span> <span class="main">=</span> False"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">isclass</span> <span class="main">(</span>CClassT <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">)</span> <span class="main">=</span> True"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">isclass</span> <span class="main">(</span>AClassT <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">)</span> <span class="main">=</span> True"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">isclass</span> <span class="main">(</span>InterfaceT <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> <span class="main">=</span> False"</span></span> 

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="DirectSubtypes">
<div class="head">
<h1>Theory DirectSubtypes</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Jive Data and Store Model
    Author:      Norbert Schirmer &lt;schirmer at informatik.tu-muenchen.de&gt;  and  
                 Nicole Rauch &lt;rauch at informatik.uni-kl.de&gt;, 2005
    Maintainer:  Nicole Rauch &lt;rauch at informatik.uni-kl.de&gt;
    License:     LGPL
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹The Direct Subtype Relation of Java Types›</span></span>

<span class="keyword1"><span class="command">theory</span></span> DirectSubtypes
<span class="keyword2"><span class="keyword">imports</span></span> <span class="quoted">"<a href="#JavaType">../Isabelle/JavaType</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
In this theory, we formalize the direct subtype relations of the Java types (as defined
in Sec. \ref{java_typeid_definitions}) that appear in the program to be verified. Thus, this
theory has to be generated for each program.
\label{direct_subtype_relations}
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We have the following type hierarchy:
\begin{center}
\includegraphics[width=13cm]{TypeHierarchy}
\end{center}
We need to describe all direct subtype relations of this  type hierarchy.
As you can see in the picture, all unnecessary direct subtype relations can be
ignored, e.g. the subclass relation between CounterImpl and Object, because it is 
added
transitively by the widening relation of types (see Sec. \ref{widening_subtypes}).
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
We have to specify the direct subtype relation between
\begin{itemize}
\item each ``leaf'' class or interface and its subtype \texttt{NullT}
\item each ``root'' class or interface and its supertype \texttt{Object}
\item each two types that are direct subtypes as specified in the code by
\texttt{extends} or \texttt{implements}
\item each array type of a primitive type and its subtype \texttt{NullT}
\item each array type of a primitive type and its supertype \texttt{Object}
\item each array type of a ``leaf'' class or interface and its subtype \texttt{NullT}
\item the array type \texttt{Object[]} and its supertype \texttt{Object}
\item two array types if their element types are in a subtype hierarchy
\end{itemize}
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">direct_subtype</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Javatype <span class="main">*</span> Javatype<span class="main">)</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">direct_subtype</span> <span class="main">=</span>
<span class="main">{</span> <span class="main">(</span>NullT<span class="main">,</span> AClassT Dummy<span class="main">)</span><span class="main">,</span>
  <span class="main">(</span>NullT<span class="main">,</span> CClassT UndoCounter<span class="main">)</span><span class="main">,</span> 
  <span class="main">(</span>NullT<span class="main">,</span> CClassT NullPointerException<span class="main">)</span><span class="main">,</span>
  <span class="main">(</span>NullT<span class="main">,</span> CClassT ClassCastException<span class="main">)</span><span class="main">,</span>

  <span class="main">(</span>AClassT Dummy<span class="main">,</span> CClassT Object<span class="main">)</span><span class="main">,</span>
  <span class="main">(</span>InterfaceT Counter<span class="main">,</span> CClassT Object<span class="main">)</span><span class="main">,</span>
  <span class="main">(</span>CClassT Exception<span class="main">,</span> CClassT Object<span class="main">)</span><span class="main">,</span> 

  <span class="main">(</span>CClassT UndoCounter<span class="main">,</span> CClassT CounterImpl<span class="main">)</span><span class="main">,</span> 
  <span class="main">(</span>CClassT CounterImpl<span class="main">,</span> InterfaceT Counter<span class="main">)</span><span class="main">,</span>
  <span class="main">(</span>CClassT NullPointerException<span class="main">,</span> CClassT Exception<span class="main">)</span><span class="main">,</span>
  <span class="main">(</span>CClassT ClassCastException<span class="main">,</span> CClassT Exception<span class="main">)</span><span class="main">,</span>

  <span class="main">(</span>NullT<span class="main">,</span> ArrT BoolAT<span class="main">)</span><span class="main">,</span>
  <span class="main">(</span>NullT<span class="main">,</span> ArrT IntgAT<span class="main">)</span><span class="main">,</span>
  <span class="main">(</span>NullT<span class="main">,</span> ArrT ShortAT<span class="main">)</span><span class="main">,</span>
  <span class="main">(</span>NullT<span class="main">,</span> ArrT ByteAT<span class="main">)</span><span class="main">,</span>
  <span class="main">(</span>ArrT BoolAT<span class="main">,</span>  CClassT Object<span class="main">)</span><span class="main">,</span>
  <span class="main">(</span>ArrT IntgAT<span class="main">,</span>  CClassT Object<span class="main">)</span><span class="main">,</span>
  <span class="main">(</span>ArrT ShortAT<span class="main">,</span> CClassT Object<span class="main">)</span><span class="main">,</span>
  <span class="main">(</span>ArrT ByteAT<span class="main">,</span>  CClassT Object<span class="main">)</span><span class="main">,</span>

  <span class="main">(</span>NullT<span class="main">,</span> ArrT <span class="main">(</span>AClassAT Dummy<span class="main">)</span><span class="main">)</span><span class="main">,</span>
  <span class="main">(</span>NullT<span class="main">,</span> ArrT <span class="main">(</span>CClassAT UndoCounter<span class="main">)</span><span class="main">)</span><span class="main">,</span>
  <span class="main">(</span>NullT<span class="main">,</span> ArrT <span class="main">(</span>CClassAT NullPointerException<span class="main">)</span><span class="main">)</span><span class="main">,</span>
  <span class="main">(</span>NullT<span class="main">,</span> ArrT <span class="main">(</span>CClassAT ClassCastException<span class="main">)</span><span class="main">)</span><span class="main">,</span>

  <span class="main">(</span>ArrT <span class="main">(</span>CClassAT Object<span class="main">)</span><span class="main">,</span>      CClassT Object<span class="main">)</span><span class="main">,</span>

  <span class="main">(</span>ArrT <span class="main">(</span>AClassAT Dummy<span class="main">)</span><span class="main">,</span>       ArrT <span class="main">(</span>CClassAT Object<span class="main">)</span><span class="main">)</span><span class="main">,</span>
  <span class="main">(</span>ArrT <span class="main">(</span>CClassAT CounterImpl<span class="main">)</span><span class="main">,</span> ArrT <span class="main">(</span>InterfaceAT Counter<span class="main">)</span><span class="main">)</span><span class="main">,</span> 
  <span class="main">(</span>ArrT <span class="main">(</span>InterfaceAT Counter<span class="main">)</span><span class="main">,</span>  ArrT <span class="main">(</span>CClassAT Object<span class="main">)</span><span class="main">)</span><span class="main">,</span>
  <span class="main">(</span>ArrT <span class="main">(</span>CClassAT Exception<span class="main">)</span><span class="main">,</span>   ArrT <span class="main">(</span>CClassAT Object<span class="main">)</span><span class="main">)</span><span class="main">,</span> 
  <span class="main">(</span>ArrT <span class="main">(</span>CClassAT UndoCounter<span class="main">)</span><span class="main">,</span> ArrT <span class="main">(</span>CClassAT CounterImpl<span class="main">)</span><span class="main">)</span><span class="main">,</span> 
  <span class="main">(</span>ArrT <span class="main">(</span>CClassAT NullPointerException<span class="main">)</span><span class="main">,</span> ArrT <span class="main">(</span>CClassAT Exception<span class="main">)</span><span class="main">)</span><span class="main">,</span>
  <span class="main">(</span>ArrT <span class="main">(</span>CClassAT ClassCastException<span class="main">)</span><span class="main">,</span>   ArrT <span class="main">(</span>CClassAT Exception<span class="main">)</span><span class="main">)</span>
<span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This lemma is used later in the Simplifier.›</span></span>

<span class="keyword1" id="DirectSubtypes-direct_subtype"><span class="command">lemma</span></span> direct_subtype<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>NullT<span class="main">,</span> AClassT Dummy<span class="main">)</span> <span class="main">∈</span> direct_subtype"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>NullT<span class="main">,</span> CClassT UndoCounter<span class="main">)</span> <span class="main">∈</span> direct_subtype"</span></span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span>NullT<span class="main">,</span> CClassT NullPointerException<span class="main">)</span> <span class="main">∈</span> direct_subtype"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>NullT<span class="main">,</span> CClassT ClassCastException<span class="main">)</span> <span class="main">∈</span> direct_subtype"</span></span>

  <span class="quoted"><span class="quoted">"<span class="main">(</span>AClassT Dummy<span class="main">,</span> CClassT Object<span class="main">)</span> <span class="main">∈</span> direct_subtype"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>InterfaceT Counter<span class="main">,</span> CClassT Object<span class="main">)</span> <span class="main">∈</span> direct_subtype"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>CClassT Exception<span class="main">,</span> CClassT Object<span class="main">)</span> <span class="main">∈</span> direct_subtype"</span></span> 

  <span class="quoted"><span class="quoted">"<span class="main">(</span>CClassT UndoCounter<span class="main">,</span> CClassT CounterImpl<span class="main">)</span> <span class="main">∈</span> direct_subtype"</span></span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span>CClassT CounterImpl<span class="main">,</span> InterfaceT Counter<span class="main">)</span> <span class="main">∈</span> direct_subtype"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>CClassT NullPointerException<span class="main">,</span> CClassT Exception<span class="main">)</span> <span class="main">∈</span> direct_subtype"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>CClassT ClassCastException<span class="main">,</span> CClassT Exception<span class="main">)</span> <span class="main">∈</span> direct_subtype"</span></span>

  <span class="quoted"><span class="quoted">"<span class="main">(</span>NullT<span class="main">,</span> ArrT BoolAT<span class="main">)</span> <span class="main">∈</span> direct_subtype"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>NullT<span class="main">,</span> ArrT IntgAT<span class="main">)</span> <span class="main">∈</span> direct_subtype"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>NullT<span class="main">,</span> ArrT ShortAT<span class="main">)</span> <span class="main">∈</span> direct_subtype"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>NullT<span class="main">,</span> ArrT ByteAT<span class="main">)</span> <span class="main">∈</span> direct_subtype"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>ArrT BoolAT<span class="main">,</span>  CClassT Object<span class="main">)</span> <span class="main">∈</span> direct_subtype"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>ArrT IntgAT<span class="main">,</span>  CClassT Object<span class="main">)</span> <span class="main">∈</span> direct_subtype"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>ArrT ShortAT<span class="main">,</span> CClassT Object<span class="main">)</span> <span class="main">∈</span> direct_subtype"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>ArrT ByteAT<span class="main">,</span>  CClassT Object<span class="main">)</span> <span class="main">∈</span> direct_subtype"</span></span>

  <span class="quoted"><span class="quoted">"<span class="main">(</span>NullT<span class="main">,</span> ArrT <span class="main">(</span>AClassAT Dummy<span class="main">)</span><span class="main">)</span> <span class="main">∈</span> direct_subtype"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>NullT<span class="main">,</span> ArrT <span class="main">(</span>CClassAT UndoCounter<span class="main">)</span><span class="main">)</span> <span class="main">∈</span> direct_subtype"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>NullT<span class="main">,</span> ArrT <span class="main">(</span>CClassAT NullPointerException<span class="main">)</span><span class="main">)</span> <span class="main">∈</span> direct_subtype"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>NullT<span class="main">,</span> ArrT <span class="main">(</span>CClassAT ClassCastException<span class="main">)</span><span class="main">)</span> <span class="main">∈</span> direct_subtype"</span></span>

  <span class="quoted"><span class="quoted">"<span class="main">(</span>ArrT <span class="main">(</span>CClassAT Object<span class="main">)</span><span class="main">,</span>      CClassT Object<span class="main">)</span> <span class="main">∈</span> direct_subtype"</span></span>

  <span class="quoted"><span class="quoted">"<span class="main">(</span>ArrT <span class="main">(</span>AClassAT Dummy<span class="main">)</span><span class="main">,</span>       ArrT <span class="main">(</span>CClassAT Object<span class="main">)</span><span class="main">)</span> <span class="main">∈</span> direct_subtype"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>ArrT <span class="main">(</span>CClassAT CounterImpl<span class="main">)</span><span class="main">,</span> ArrT <span class="main">(</span>InterfaceAT Counter<span class="main">)</span><span class="main">)</span> <span class="main">∈</span> direct_subtype"</span></span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span>ArrT <span class="main">(</span>InterfaceAT Counter<span class="main">)</span><span class="main">,</span>  ArrT <span class="main">(</span>CClassAT Object<span class="main">)</span><span class="main">)</span> <span class="main">∈</span> direct_subtype"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>ArrT <span class="main">(</span>CClassAT Exception<span class="main">)</span><span class="main">,</span>   ArrT <span class="main">(</span>CClassAT Object<span class="main">)</span><span class="main">)</span> <span class="main">∈</span> direct_subtype"</span></span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span>ArrT <span class="main">(</span>CClassAT UndoCounter<span class="main">)</span><span class="main">,</span> ArrT <span class="main">(</span>CClassAT CounterImpl<span class="main">)</span><span class="main">)</span> <span class="main">∈</span> direct_subtype"</span></span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span>ArrT <span class="main">(</span>CClassAT NullPointerException<span class="main">)</span><span class="main">,</span> ArrT <span class="main">(</span>CClassAT Exception<span class="main">)</span><span class="main">)</span> <span class="main">∈</span> direct_subtype"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>ArrT <span class="main">(</span>CClassAT ClassCastException<span class="main">)</span><span class="main">,</span>   ArrT <span class="main">(</span>CClassAT Exception<span class="main">)</span><span class="main">)</span> <span class="main">∈</span> direct_subtype"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> direct_subtype_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Subtype">
<div class="head">
<h1>Theory Subtype</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Jive Data and Store Model
    Author:      Norbert Schirmer &lt;schirmer at informatik.tu-muenchen.de&gt;, 2003
    Maintainer:  Nicole Rauch &lt;rauch at informatik.uni-kl.de&gt;
    License:     LGPL
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Widening the Direct Subtype Relation›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Subtype
<span class="keyword2"><span class="keyword">imports</span></span> <span class="quoted">"<a href="#DirectSubtypes">../Isa_Counter/DirectSubtypes</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
In this theory, we define the widening subtype relation of types and prove 
that it is a partial order.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Auxiliary lemmas›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹These general lemmas are not especially related to Jive. 
They capture
some useful properties of general relations. 
›</span></span>
<span class="keyword1" id="Subtype-distinct_rtrancl_into_trancl"><span class="command">lemma</span></span> distinct_rtrancl_into_trancl<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> neq_x_y<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span><span class="main">≠</span><span class="free">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> x_y_rtrancl<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> x_y_rtrancl neq_x_y
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span><span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span><span class="main">≠</span><span class="free">x</span>"</span></span> <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">x</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">y</span> <span class="skolem">z</span>
  <span class="keyword3"><span class="command">assume</span></span> x_y_rtrancl<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> 
  <span class="keyword3"><span class="command">assume</span></span> y_z_r<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>"</span></span> 
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≠</span> <span class="skolem">y</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span> 
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≠</span> <span class="skolem">z</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> x_y_rtrancl
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span><span class="main">)</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span><span class="main">=</span><span class="skolem">y</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> y_z_r <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span>  <span class="free">r</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span><span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">w</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="skolem">w</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">w</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span>"</span></span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> rtrancl_into_trancl1<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> this y_z_r
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span><span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Subtype-acyclic_imp_antisym_rtrancl"><span class="command">lemma</span></span> acyclic_imp_antisym_rtrancl<span class="main">:</span> <span class="quoted"><span class="quoted">"acyclic <span class="free">r</span> <span class="main">⟹</span> antisym <span class="main">(</span><span class="free">r</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> acyclic_def antisym_def<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span>
  <span class="keyword3"><span class="command">assume</span></span> acyclic<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">x</span><span class="main">)</span> <span class="main">∉</span> <span class="free">r</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> x_y<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span> 
  <span class="keyword3"><span class="command">assume</span></span> y_x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span><span class="main">=</span><span class="skolem">y</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span><span class="main">=</span><span class="skolem">y</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">from</span></span> False x_y <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> distinct_rtrancl_into_trancl<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span>
    <span class="keyword1"><span class="command">from</span></span> False y_x <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> distinct_rtrancl_into_trancl<span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">x</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span><span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">with</span></span> acyclic <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Subtype-acyclic_trancl_rtrancl"><span class="command">lemma</span></span> acyclic_trancl_rtrancl<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> acyclic<span class="main">:</span> <span class="quoted"><span class="quoted">"acyclic <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">∧</span> <span class="free">x</span><span class="main">≠</span><span class="free">y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> x_y_trancl<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">∧</span> <span class="free">x</span><span class="main">≠</span><span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword1"><span class="command">from</span></span> x_y_trancl <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span><span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword1"><span class="command">from</span></span> x_y_trancl acyclic <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span><span class="main">≠</span><span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> acyclic_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">∧</span> <span class="free">x</span><span class="main">≠</span><span class="free">y</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">)</span> <span class="main">∈</span> <span class="free">r</span><span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> distinct_rtrancl_into_trancl<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹The Widening (Subtype) Relation of Javatypes›</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{widening_subtypes}
In this section we widen the direct subtype relations specified in Sec. 
\ref{direct_subtype_relations}.
It is done by a calculation of the transitive closure of the 
direct subtype relation. 
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This is the concrete syntax that expresses the subtype relations 
between all types. 
\label{subtype_relations_concrete_syntax}›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span>
  <span class="entity">direct_subtype_syntax</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Javatype <span class="main">⇒</span> Javatype <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="quoted">"_ <span class="keyword1">≺1</span> _"</span> <span class="main">[</span>71<span class="main">,</span>71<span class="main">]</span> 70<span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="comment1">― ‹direct subtype relation›</span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main"><span class="free">≺1</span></span> <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="main">==</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">B</span></span></span><span class="main">)</span> <span class="main">∈</span> direct_subtype"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span>
  <span class="entity">widen_syntax</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Javatype <span class="main">⇒</span> Javatype <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="quoted">"_ <span class="keyword1">≼</span> _"</span> <span class="main">[</span>71<span class="main">,</span>71<span class="main">]</span> 70<span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="comment1">― ‹reflexive transitive closure of direct subtype relation›</span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main"><span class="free">≼</span></span> <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="main">==</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">B</span></span></span><span class="main">)</span> <span class="main">∈</span> direct_subtype<span class="main"><span class="hidden">⇧</span><sup>*</sup></span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span>
  <span class="entity">widen_strict_syntax</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Javatype <span class="main">⇒</span> Javatype <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="quoted">"_ <span class="keyword1">≺</span> _"</span> <span class="main">[</span>71<span class="main">,</span>71<span class="main">]</span> 70<span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="comment1">― ‹transitive closure of direct subtype relation›</span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main"><span class="free">≺</span></span> <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="main">==</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">B</span></span></span><span class="main">)</span> <span class="main">∈</span> direct_subtype<span class="main"><span class="hidden">⇧</span><sup>+</sup></span>"</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹The Subtype Relation as Partial Order›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We prove the axioms required for partial orders, i.e.\ 
reflexivity, transitivity and antisymmetry, for the widened subtype
relation. The direct subtype relation has been
defined in Sec. \ref{direct_subtype_relations}.
The reflexivity lemma is
added to the Simplifier and to the Classical reasoner (via the
attribute iff), and the transitivity and antisymmetry lemmas
are made known as transitivity rules (via the attribute trans).
This way, these lemmas will be automatically used in subsequent proofs.
›</span></span>

<span class="keyword1" id="Subtype-acyclic_direct_subtype"><span class="command">lemma</span></span> acyclic_direct_subtype<span class="main">:</span> <span class="quoted"><span class="quoted">"acyclic direct_subtype"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> acyclic_def<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≺</span> <span class="skolem">x</span> <span class="main">⟹</span> False"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> tranclE <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> direct_subtype_def<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
     <span class="comment1">(* takes a very long time to calculate *)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Subtype-antisym_rtrancl_direct_subtype"><span class="command">lemma</span></span> antisym_rtrancl_direct_subtype<span class="main">:</span> <span class="quoted"><span class="quoted">"antisym <span class="main">(</span>direct_subtype<span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> acyclic_direct_subtype <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> acyclic_imp_antisym_rtrancl<span class="main">)</span>

<span class="keyword1" id="Subtype-widen_strict_to_widen"><span class="command">lemma</span></span> widen_strict_to_widen<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">C</span> <span class="main">≺</span> <span class="free">D</span> <span class="main">=</span> <span class="main">(</span><span class="free">C</span> <span class="main">≼</span> <span class="free">D</span> <span class="main">∧</span> <span class="free">C</span><span class="main">≠</span><span class="free">D</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> acyclic_direct_subtype <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> acyclic_trancl_rtrancl<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The widening relation on Javatype is reflexive.›</span></span>

<span class="keyword1" id="Subtype-widen_refl"><span class="command">lemma</span></span> widen_refl <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">≼</span> <span class="free">X</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The widening relation on Javatype is transitive.›</span></span>

<span class="keyword1" id="Subtype-widen_trans"><span class="command">lemma</span></span> widen_trans <span class="main">[</span><span class="operator">trans</span><span class="main">]</span> <span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> a_b<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">≼</span> <span class="free">b</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">c</span><span class="main">.</span> <span class="free">b</span> <span class="main">≼</span> <span class="bound">c</span> <span class="main">⟹</span> <span class="free">a</span> <span class="main">≼</span> <span class="bound">c</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">insert</span> a_b<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> rtrancl_trans<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The widening relation on Javatype is antisymmetric.›</span></span>

<span class="keyword1" id="Subtype-widen_antisym"><span class="command">lemma</span></span> widen_antisym <span class="main">[</span><span class="operator">trans</span><span class="main">]</span><span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> a_b<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">≼</span> <span class="free">b</span>"</span></span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> b_c<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">≼</span> <span class="free">a</span>"</span></span>  
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">=</span> <span class="free">b</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> a_b b_c antisym_rtrancl_direct_subtype
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> antisym_def<span class="main">)</span> <span class="operator">blast</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Javatype Ordering Properties›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The type class <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">ord</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> allows us to overwrite the two comparison 
operators $&lt;$ and $\leq$.
  These are  the two comparison operators on <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">Javatype</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> that we want
to use subsequently.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We can also prove that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">Javatype</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is in the type class <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">order</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>. 
For this we
  have to prove reflexivity, transitivity, antisymmetry and that $&lt;$ and $\leq$ are 
defined in such
  a way that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> Orderings.order_less_le <span class="main"><span class="main">[</span></span><span class="operator"><span class="operator">no_vars</span></span><span class="main"><span class="main">]</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> holds. This proof can easily 
be achieved by using the
  lemmas proved above and the definition of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">less_Javatype_def</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> Javatype<span class="main">::</span> <span class="quoted">order</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  le_Javatype_def<span class="main">:</span>   <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">≼</span> <span class="free"><span class="bound"><span class="entity">B</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  less_Javatype_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="main">∧</span> <span class="main">¬</span> <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="main">≤</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">::</span>Javatype<span class="main">)</span>"</span></span>
  
<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="skolem">z</span><span class="main">::</span> <span class="quoted"><span class="quoted">"Javatype"</span></span>
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">x</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> le_Javatype_def <span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">y</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">≤</span> <span class="skolem">z</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">z</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> le_Javatype_def<span class="main">)</span> <span class="main">(</span><span class="operator">rule</span> rtrancl_trans<span class="main">)</span> 
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">y</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">≤</span> <span class="skolem">x</span>"</span></span> 
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> le_Javatype_def<span class="main">)</span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> widen_antisym<span class="main">)</span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span> <span class="main"><span class="keyword3">+</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">x</span> <span class="main">&lt;</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">y</span> <span class="main">∧</span> <span class="main">¬</span> <span class="skolem">y</span> <span class="main">≤</span> <span class="skolem">x</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_Javatype_def<span class="main">)</span>
  <span class="keyword1"><span class="command">}</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Enhancing the Simplifier›</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> subtype_defs <span class="main">=</span> le_Javatype_def less_Javatype_def
                      direct_subtype_def 
<span class="comment1">(*
                      direct_subtype
                      direct_subtype[THEN r_into_rtrancl]
*)</span>
<span class="keyword1"><span class="command">lemmas</span></span> subtype_ok_simps <span class="main">=</span> subtype_defs 
<span class="keyword1"><span class="command">lemmas</span></span> subtype_wrong_elims <span class="main">=</span> rtranclE

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹During verification we will often have to solve the goal that one type
widens to the other. So we equip the simplifier with a special solver-tactic.
›</span></span>

<span class="keyword1" id="Subtype-widen_asm"><span class="command">lemma</span></span> widen_asm<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span><span class="main">::</span>Javatype<span class="main">)</span> <span class="main">≤</span> <span class="free">b</span> <span class="main">⟹</span> <span class="free">a</span> <span class="main">≤</span> <span class="free">b</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemmas</span></span> direct_subtype_widened <span class="main">=</span> direct_subtype<span class="main">[</span><span class="operator">THEN</span> r_into_rtrancl<span class="main">]</span>

<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹
<span class="keyword2"><span class="keyword">local</span></span> <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ss</span> <span class="main">=</span> simpset_of <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="keyword2"><span class="keyword">in</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">widen_tac</span> <span class="entity">ctxt</span> <span class="main">=</span>
  resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> widen_asm<span class="antiquote">}</span></span></span> THEN'
  <span class="entity">simp_tac</span> <span class="main">(</span>put_simpset <span class="entity">ss</span> <span class="entity">ctxt</span> addsimps <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> le_Javatype_def<span class="antiquote">}</span></span></span><span class="main">)</span> THEN'
  <span class="entity">Method.insert_tac</span> <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> direct_subtype_widened<span class="antiquote">}</span></span></span> THEN'
  <span class="entity">simp_tac</span> <span class="main">(</span>put_simpset <span class="main">(</span>simpset_of <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">theory_context</span> <a href="../../HOL/HOL/Transitive_Closure.html">Transitive_Closure</a><span class="antiquote">}</span></span></span><span class="main">)</span> <span class="entity">ctxt</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
›</span>

<span class="keyword1"><span class="command">declaration</span></span> <span class="quoted">‹<span class="keyword1"><span class="keyword">fn</span></span> <span class="main">_</span> <span class="main">=&gt;</span>
  <span class="entity">Simplifier.map_ss</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ss</span> <span class="main">=&gt;</span> <span class="entity">ss</span> addSolver <span class="main">(</span>mk_solver <span class="inner_quoted">"widen"</span> <span class="entity">widen_tac</span><span class="main">)</span><span class="main">)</span>
›</span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In this solver-tactic, we first try the trivial resolution with <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>widen_asm›</span></span></span></span> to
check if the actual subgaol really is a request to solve a subtyping problem.
If so, we unfold the comparison operator, insert the direct subtype
relations and call the simplifier.
›</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Properties of the Subtype Relation›</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The class <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Object›</span></span></span></span> has to be the root of the class hierarchy, 
i.e.~it is supertype of each concrete class, abstract class, interface
and array type.
  The proof scripts should run on every correctly generated type hierarchy.
›</span></span>


<span class="keyword1" id="Subtype-Object_root"><span class="command">lemma</span></span> Object_root<span class="main">:</span> <span class="quoted"><span class="quoted">"CClassT <span class="free">C</span> <span class="main">≤</span> CClassT Object"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">C</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1" id="Subtype-Object_root_abs"><span class="command">lemma</span></span> Object_root_abs<span class="main">:</span> <span class="quoted"><span class="quoted">"AClassT <span class="free">C</span> <span class="main">≤</span> CClassT Object"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">C</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1" id="Subtype-Object_root_int"><span class="command">lemma</span></span> Object_root_int<span class="main">:</span> <span class="quoted"><span class="quoted">"InterfaceT <span class="free">C</span> <span class="main">≤</span> CClassT Object"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">C</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1" id="Subtype-Object_root_array"><span class="command">lemma</span></span> Object_root_array<span class="main">:</span> <span class="quoted"><span class="quoted">"ArrT <span class="free">C</span> <span class="main">≤</span> CClassT Object"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">C</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
    <span class="keyword3"><span class="command">assume</span></span> c<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">C</span> <span class="main">=</span> CClassAT <span class="skolem">x</span>"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"ArrT <span class="free">C</span> <span class="main">≤</span> CClassT Object"</span></span>
      <span class="keyword1"><span class="command">using</span></span> c <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
    <span class="keyword3"><span class="command">assume</span></span> c<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">C</span> <span class="main">=</span> AClassAT <span class="skolem">x</span>"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"ArrT <span class="free">C</span> <span class="main">≤</span> CClassT Object"</span></span>
      <span class="keyword1"><span class="command">using</span></span> c <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
    <span class="keyword3"><span class="command">assume</span></span> c<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">C</span> <span class="main">=</span> InterfaceAT <span class="skolem">x</span>"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"ArrT <span class="free">C</span> <span class="main">≤</span> CClassT Object"</span></span>
      <span class="keyword1"><span class="command">using</span></span> c <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> c<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">C</span> <span class="main">=</span> BoolAT"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"ArrT <span class="free">C</span> <span class="main">≤</span> CClassT Object"</span></span>
      <span class="keyword1"><span class="command">using</span></span> c <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> c<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">C</span> <span class="main">=</span> IntgAT"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"ArrT <span class="free">C</span> <span class="main">≤</span> CClassT Object"</span></span>
      <span class="keyword1"><span class="command">using</span></span> c <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> c<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">C</span> <span class="main">=</span> ShortAT"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"ArrT <span class="free">C</span> <span class="main">≤</span> CClassT Object"</span></span>
      <span class="keyword1"><span class="command">using</span></span> c <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> c<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">C</span> <span class="main">=</span> ByteAT"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"ArrT <span class="free">C</span> <span class="main">≤</span> CClassT Object"</span></span>
      <span class="keyword1"><span class="command">using</span></span> c <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹If another type is (non-strict) supertype of Object, 
then it must be the type Object itself.›</span></span>

<span class="keyword1" id="Subtype-Object_rootD"><span class="command">lemma</span></span> Object_rootD<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> p<span class="main">:</span> <span class="quoted"><span class="quoted">"CClassT Object <span class="main">≤</span> <span class="free">c</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"CClassT Object <span class="main">=</span> <span class="free">c</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> p
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">c</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> subtype_wrong_elims <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> subtype_defs<span class="main">)</span> <span class="main"><span class="keyword3">+</span></span>
  <span class="comment1">― ‹In this lemma, we only get contradictory cases except for Object itself.›</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The type NullT has to be the leaf of each branch of the class
hierarchy, i.e.~it is subtype of each type.›</span></span>

<span class="keyword1" id="Subtype-NullT_leaf"><span class="command">lemma</span></span> NullT_leaf <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"NullT <span class="main">≤</span> CClassT <span class="free">C</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">C</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1" id="Subtype-NullT_leaf_abs"><span class="command">lemma</span></span> NullT_leaf_abs <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"NullT <span class="main">≤</span> AClassT <span class="free">C</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">C</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1" id="Subtype-NullT_leaf_int"><span class="command">lemma</span></span> NullT_leaf_int <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"NullT <span class="main">≤</span> InterfaceT <span class="free">C</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">C</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1" id="Subtype-NullT_leaf_array"><span class="command">lemma</span></span> NullT_leaf_array<span class="main">:</span> <span class="quoted"><span class="quoted">"NullT <span class="main">≤</span> ArrT <span class="free">C</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">C</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
    <span class="keyword3"><span class="command">assume</span></span> c<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">C</span> <span class="main">=</span> CClassAT <span class="skolem">x</span>"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"NullT <span class="main">≤</span> ArrT <span class="free">C</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> c <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
    <span class="keyword3"><span class="command">assume</span></span> c<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">C</span> <span class="main">=</span> AClassAT <span class="skolem">x</span>"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"NullT <span class="main">≤</span> ArrT <span class="free">C</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> c <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
    <span class="keyword3"><span class="command">assume</span></span> c<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">C</span> <span class="main">=</span> InterfaceAT <span class="skolem">x</span>"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"NullT <span class="main">≤</span> ArrT <span class="free">C</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> c <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> c<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">C</span> <span class="main">=</span> BoolAT"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"NullT <span class="main">≤</span> ArrT <span class="free">C</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> c <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> c<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">C</span> <span class="main">=</span> IntgAT"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"NullT <span class="main">≤</span> ArrT <span class="free">C</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> c <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> c<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">C</span> <span class="main">=</span> ShortAT"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"NullT <span class="main">≤</span> ArrT <span class="free">C</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> c <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> c<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">C</span> <span class="main">=</span> ByteAT"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"NullT <span class="main">≤</span> ArrT <span class="free">C</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> c <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Attributes">
<div class="head">
<h1>Theory Attributes</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Jive Data and Store Model
    Author:      Norbert Schirmer &lt;schirmer at informatik.tu-muenchen.de&gt;, 2003
    Maintainer:  Nicole Rauch &lt;rauch at informatik.uni-kl.de&gt;
    License:     LGPL
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Attributes›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Attributes
<span class="keyword2"><span class="keyword">imports</span></span> <span class="quoted">"<a href="#Subtype">../Isabelle/Subtype</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This theory has to be generated as well for each program under 
verification. It defines the attributes of the classes and various functions
on them.
›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> AttId <span class="main">=</span> CounterImpl'value <span class="main">|</span> UndoCounter'save
  <span class="main">|</span> Dummy'dummy <span class="main">|</span> Counter'dummy

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The last two entries are only added to demonstrate what is to happen with attributes of
abstract classes and interfaces.›</span></span>

<span class="keyword1"><span class="command">text</span></span>  <span class="quoted"><span class="plain_text">‹It would be nice if attribute names were generated in a way that keeps them short, so that the proof
state does not get unreadable because of fancy long names. The generation of 
attribute names that is performed by the
Jive tool should only add the definition class if necessary, i.e.~if there 
 would be a name clash otherwise. For the example above, the class names are not 
necessary. One must be careful, though, not to generate names that might clash with names of free variables
that are used subsequently.
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The domain type of an attribute is the definition class (or interface)
of the attribute.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">dtype</span><span class="main">::</span> <span class="quoted"><span class="quoted">"AttId <span class="main">⇒</span> Javatype"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">dtype</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="keyword1">of</span> 
              CounterImpl'value <span class="main">⇒</span> CClassT CounterImpl
            <span class="main">|</span> UndoCounter'save <span class="main">⇒</span> CClassT UndoCounter
            <span class="main">|</span> Dummy'dummy <span class="main">⇒</span> AClassT Dummy
            <span class="main">|</span> Counter'dummy <span class="main">⇒</span> InterfaceT Counter<span class="main">)</span>"</span></span>

<span class="keyword1" id="Attributes-dtype_simps"><span class="command">lemma</span></span> dtype_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
<span class="quoted"><span class="quoted">"dtype CounterImpl'value <span class="main">=</span> CClassT CounterImpl"</span></span> 
<span class="quoted"><span class="quoted">"dtype UndoCounter'save <span class="main">=</span> CClassT UndoCounter"</span></span>
<span class="quoted"><span class="quoted">"dtype Dummy'dummy <span class="main">=</span> AClassT Dummy"</span></span>
<span class="quoted"><span class="quoted">"dtype Counter'dummy <span class="main">=</span> InterfaceT Counter"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dtype_def dtype_def dtype_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹For convenience, we add some functions that directly apply the selectors of 
  the datatype <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">Javatype</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>
  
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">cDTypeId</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"AttId <span class="main">⇒</span> CTypeId"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">cDTypeId</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="keyword1">of</span> 
              CounterImpl'value <span class="main">⇒</span> CounterImpl
            <span class="main">|</span> UndoCounter'save <span class="main">⇒</span> UndoCounter
            <span class="main">|</span> Dummy'dummy <span class="main">⇒</span> undefined
            <span class="main">|</span> Counter'dummy <span class="main">⇒</span> undefined <span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">aDTypeId</span><span class="main">::</span> <span class="quoted"><span class="quoted">"AttId <span class="main">⇒</span> ATypeId"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">aDTypeId</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="keyword1">of</span> 
              CounterImpl'value <span class="main">⇒</span> undefined
            <span class="main">|</span> UndoCounter'save <span class="main">⇒</span> undefined
            <span class="main">|</span> Dummy'dummy <span class="main">⇒</span> Dummy
            <span class="main">|</span> Counter'dummy <span class="main">⇒</span> undefined <span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">iDTypeId</span><span class="main">::</span> <span class="quoted"><span class="quoted">"AttId <span class="main">⇒</span> ITypeId"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">iDTypeId</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="keyword1">of</span> 
              CounterImpl'value <span class="main">⇒</span> undefined
            <span class="main">|</span> UndoCounter'save <span class="main">⇒</span> undefined
            <span class="main">|</span> Dummy'dummy <span class="main">⇒</span> undefined
            <span class="main">|</span> Counter'dummy <span class="main">⇒</span> Counter <span class="main">)</span>"</span></span>

<span class="keyword1" id="Attributes-DTypeId_simps"><span class="command">lemma</span></span> DTypeId_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
<span class="quoted"><span class="quoted">"cDTypeId CounterImpl'value <span class="main">=</span> CounterImpl"</span></span> 
<span class="quoted"><span class="quoted">"cDTypeId UndoCounter'save <span class="main">=</span> UndoCounter"</span></span>
<span class="quoted"><span class="quoted">"aDTypeId Dummy'dummy <span class="main">=</span> Dummy"</span></span>
<span class="quoted"><span class="quoted">"iDTypeId Counter'dummy <span class="main">=</span> Counter"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cDTypeId_def aDTypeId_def iDTypeId_def<span class="main">)</span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The range type of an attribute is the type of the value stored in that
attribute.
›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">rtype</span><span class="main">::</span> <span class="quoted"><span class="quoted">"AttId <span class="main">⇒</span> Javatype"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">rtype</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="keyword1">of</span> 
              CounterImpl'value <span class="main">⇒</span> IntgT
            <span class="main">|</span> UndoCounter'save <span class="main">⇒</span> IntgT
            <span class="main">|</span> Dummy'dummy <span class="main">⇒</span> NullT
            <span class="main">|</span> Counter'dummy <span class="main">⇒</span> NullT<span class="main">)</span>"</span></span>

<span class="keyword1" id="Attributes-rtype_simps"><span class="command">lemma</span></span> rtype_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
<span class="quoted"><span class="quoted">"rtype CounterImpl'value  <span class="main">=</span> IntgT"</span></span>
<span class="quoted"><span class="quoted">"rtype UndoCounter'save  <span class="main">=</span> IntgT"</span></span>
<span class="quoted"><span class="quoted">"rtype Dummy'dummy <span class="main">=</span> NullT"</span></span>
<span class="quoted"><span class="quoted">"rtype Counter'dummy <span class="main">=</span> NullT"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rtype_def rtype_def rtype_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹With the datatype <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>CAttId›</span></span></span></span> we describe the possible locations 
in memory for
instance fields. We rule out the impossible combinations of class names and
field names. For example, a <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>CounterImpl›</span></span></span></span> cannot have a <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>save›</span></span></span></span> 
field. A store model which provides locations for all possible combinations
of the Cartesian product of class name and field name works out fine as 
well, because we cannot express modification of such ``wrong'' 
locations in a Java program. So we can only prove useful properties about 
reasonable combinations.
The only drawback in such a model is that we cannot prove a property like 
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>not_treach_ref_impl_not_reach›</span></span></span></span> in theory StoreProperties. 
If the store provides locations for
every combination of class name and field name, we cannot rule out 
reachability of certain pointer chains that go through ``wrong'' locations. 
That is why we decided to introduce the new type <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>CAttId›</span></span></span></span>.

  While <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>AttId›</span></span></span></span> describes which fields 
are declared in which classes and interfaces,
  <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>CAttId›</span></span></span></span> describes which objects of which classes may contain which 
fields at run-time. Thus,
  <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>CAttId›</span></span></span></span> makes the inheritance of fields visible in the formalization.

There is only one such datatype because only objects of concrete classes can be 
created at run-time,
thus only instance fields of concrete classes can occupy memory.›</span></span>

  <span class="keyword1"><span class="command">datatype</span></span> CAttId <span class="main">=</span> CounterImpl'CounterImpl'value <span class="main">|</span> UndoCounter'CounterImpl'value
  <span class="main">|</span> UndoCounter'UndoCounter'save 
  <span class="main">|</span> CounterImpl'Counter'dummy <span class="main">|</span> UndoCounter'Counter'dummy


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>catt›</span></span></span></span> builds a <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>CAttId›</span></span></span></span> from a class name
and a field name. In case of the illegal combinations we just return
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>undefined›</span></span></span></span>. We can also filter out static fields in 
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>catt›</span></span></span></span>.›</span></span>
  
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">catt</span><span class="main">::</span> <span class="quoted"><span class="quoted">"CTypeId <span class="main">⇒</span> AttId <span class="main">⇒</span> CAttId"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">catt</span> <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="keyword1">of</span>
     CounterImpl <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="keyword1">of</span> 
                CounterImpl'value <span class="main">⇒</span> CounterImpl'CounterImpl'value
              <span class="main">|</span> UndoCounter'save <span class="main">⇒</span> undefined
              <span class="main">|</span> Dummy'dummy <span class="main">⇒</span> undefined
              <span class="main">|</span> Counter'dummy <span class="main">⇒</span> CounterImpl'Counter'dummy<span class="main">)</span>
   <span class="main">|</span> UndoCounter <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="keyword1">of</span> 
                     CounterImpl'value <span class="main">⇒</span> UndoCounter'CounterImpl'value
                   <span class="main">|</span> UndoCounter'save <span class="main">⇒</span> UndoCounter'UndoCounter'save
                   <span class="main">|</span> Dummy'dummy <span class="main">⇒</span> undefined
                   <span class="main">|</span> Counter'dummy <span class="main">⇒</span> UndoCounter'Counter'dummy<span class="main">)</span>
   <span class="main">|</span> Object <span class="main">⇒</span> undefined
   <span class="main">|</span> Exception <span class="main">⇒</span> undefined
   <span class="main">|</span> ClassCastException <span class="main">⇒</span> undefined
   <span class="main">|</span> NullPointerException <span class="main">⇒</span> undefined
<span class="main">)</span>"</span></span>


<span class="keyword1" id="Attributes-catt_simps"><span class="command">lemma</span></span> catt_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
<span class="quoted"><span class="quoted">"catt CounterImpl CounterImpl'value <span class="main">=</span> CounterImpl'CounterImpl'value"</span></span>
<span class="quoted"><span class="quoted">"catt UndoCounter CounterImpl'value <span class="main">=</span> UndoCounter'CounterImpl'value"</span></span>
<span class="quoted"><span class="quoted">"catt UndoCounter UndoCounter'save <span class="main">=</span> UndoCounter'UndoCounter'save"</span></span>
<span class="quoted"><span class="quoted">"catt CounterImpl Counter'dummy <span class="main">=</span> CounterImpl'Counter'dummy"</span></span>
<span class="quoted"><span class="quoted">"catt UndoCounter Counter'dummy <span class="main">=</span> UndoCounter'Counter'dummy"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> catt_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Selection of the class name of the type of the object in which the field lives.
  The field can only be located in a concrete class.›</span></span>
  
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">cls</span><span class="main">::</span> <span class="quoted"><span class="quoted">"CAttId <span class="main">⇒</span> CTypeId"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">cls</span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="keyword1">of</span>
             CounterImpl'CounterImpl'value  <span class="main">⇒</span> CounterImpl
           <span class="main">|</span> UndoCounter'CounterImpl'value  <span class="main">⇒</span> UndoCounter
           <span class="main">|</span> UndoCounter'UndoCounter'save  <span class="main">⇒</span> UndoCounter
  <span class="main">|</span> CounterImpl'Counter'dummy <span class="main">⇒</span> CounterImpl
  <span class="main">|</span> UndoCounter'Counter'dummy <span class="main">⇒</span> UndoCounter
<span class="main">)</span>"</span></span>

<span class="keyword1" id="Attributes-cls_simps"><span class="command">lemma</span></span> cls_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
<span class="quoted"><span class="quoted">"cls CounterImpl'CounterImpl'value <span class="main">=</span> CounterImpl"</span></span>
<span class="quoted"><span class="quoted">"cls UndoCounter'CounterImpl'value <span class="main">=</span> UndoCounter"</span></span>
<span class="quoted"><span class="quoted">"cls UndoCounter'UndoCounter'save <span class="main">=</span> UndoCounter"</span></span>
<span class="quoted"><span class="quoted">"cls CounterImpl'Counter'dummy <span class="main">=</span> CounterImpl"</span></span>
<span class="quoted"><span class="quoted">"cls UndoCounter'Counter'dummy <span class="main">=</span> UndoCounter"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cls_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Selection of the field name.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">att</span><span class="main">::</span> <span class="quoted"><span class="quoted">"CAttId <span class="main">⇒</span> AttId"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">att</span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">cf</span></span></span> <span class="keyword1">of</span>
             CounterImpl'CounterImpl'value  <span class="main">⇒</span> CounterImpl'value
           <span class="main">|</span> UndoCounter'CounterImpl'value  <span class="main">⇒</span> CounterImpl'value
           <span class="main">|</span> UndoCounter'UndoCounter'save  <span class="main">⇒</span> UndoCounter'save
           <span class="main">|</span> CounterImpl'Counter'dummy <span class="main">⇒</span> Counter'dummy
           <span class="main">|</span> UndoCounter'Counter'dummy <span class="main">⇒</span> Counter'dummy
<span class="main">)</span>"</span></span>

<span class="keyword1" id="Attributes-att_simps"><span class="command">lemma</span></span> att_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
<span class="quoted"><span class="quoted">"att CounterImpl'CounterImpl'value <span class="main">=</span> CounterImpl'value"</span></span>
<span class="quoted"><span class="quoted">"att UndoCounter'CounterImpl'value <span class="main">=</span> CounterImpl'value"</span></span>
<span class="quoted"><span class="quoted">"att UndoCounter'UndoCounter'save <span class="main">=</span> UndoCounter'save"</span></span>
<span class="quoted"><span class="quoted">"att CounterImpl'Counter'dummy <span class="main">=</span> Counter'dummy"</span></span>
<span class="quoted"><span class="quoted">"att UndoCounter'Counter'dummy <span class="main">=</span> Counter'dummy"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> att_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="AttributesIndep">
<div class="head">
<h1>Theory AttributesIndep</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Jive Data and Store Model
    Author:      Norbert Schirmer &lt;schirmer at informatik.tu-muenchen.de&gt;  and  
                 Nicole Rauch &lt;rauch at informatik.uni-kl.de&gt;, 2005
    Maintainer:  Nicole Rauch &lt;rauch at informatik.uni-kl.de&gt;
    License:     LGPL
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Program-Independent Lemmas on Attributes›</span></span>

<span class="keyword1"><span class="command">theory</span></span> AttributesIndep
<span class="keyword2"><span class="keyword">imports</span></span> <span class="quoted">"<a href="#Attributes">../Isa_Counter_Store/Attributes</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The following lemmas validate the functions defined in the Attributes theory.
They also aid in subsequent proving tasks. Since they are
program-independent, it is of no use to add them to the generation process of
Attributes.thy. Therefore, they have been extracted to this theory.
›</span></span>

<span class="keyword1" id="AttributesIndep-cls_catt"><span class="command">lemma</span></span> cls_catt <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"CClassT <span class="free">c</span> <span class="main">≤</span> dtype <span class="free">f</span> <span class="main">⟹</span> cls <span class="main">(</span>catt <span class="free">c</span> <span class="free">f</span><span class="main">)</span> <span class="main">=</span> <span class="free">c</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="free">c</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">f</span></span></span></span></span></span></span></span></span></span></span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
   <span class="comment1">― ‹solves all goals where <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">text</span> <span class="raw_text">"CClassT c ≤ dtype f"</span><span class="antiquote">}</span></span>›</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> subtype_wrong_elims <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> subtype_defs<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
   <span class="comment1">― ‹solves all the rest where <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">text</span> <span class="raw_text">"¬ CClassT c ≤ dtype f"</span><span class="antiquote">}</span></span> can be derived›</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="AttributesIndep-att_catt"><span class="command">lemma</span></span> att_catt <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"CClassT <span class="free">c</span> <span class="main">≤</span> dtype <span class="free">f</span> <span class="main">⟹</span> att <span class="main">(</span>catt <span class="free">c</span> <span class="free">f</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="free">c</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">f</span></span></span></span></span></span></span></span></span></span></span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
   <span class="comment1">― ‹solves all goals where <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">text</span> <span class="raw_text">"CClassT c ≤ dtype f"</span><span class="antiquote">}</span></span>›</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> subtype_wrong_elims <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> subtype_defs<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
   <span class="comment1">― ‹solves all the rest where <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">text</span> <span class="raw_text">"¬ CClassT c ≤ dtype f"</span><span class="antiquote">}</span></span> can be 
        derived›</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The following lemmas are just a demonstration of simplification.›</span></span>

<span class="keyword1" id="AttributesIndep-rtype_att_catt"><span class="command">lemma</span></span> rtype_att_catt<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"CClassT <span class="free">c</span> <span class="main">≤</span> dtype <span class="free">f</span> <span class="main">⟹</span> rtype <span class="main">(</span>att <span class="main">(</span>catt <span class="free">c</span> <span class="free">f</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> rtype <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="AttributesIndep-widen_cls_dtype_att"><span class="command">lemma</span></span> widen_cls_dtype_att <span class="main">[</span><span class="operator">simp</span><span class="main">,</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span>CClassT <span class="main">(</span>cls <span class="free">cf</span><span class="main">)</span> <span class="main">≤</span> dtype <span class="main">(</span>att <span class="free">cf</span><span class="main">)</span><span class="main">)</span> "</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">cf</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Value">
<div class="head">
<h1>Theory Value</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Jive Data and Store Model
    Author:      Norbert Schirmer &lt;schirmer at informatik.tu-muenchen.de&gt;  and  
                 Nicole Rauch &lt;rauch at informatik.uni-kl.de&gt;, 2003
    Maintainer:  Nicole Rauch &lt;rauch at informatik.uni-kl.de&gt;
    License:     LGPL
*)</span>
 
<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Value›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Value <span class="keyword2"><span class="keyword">imports</span></span> <a href="#Subtype">Subtype</a> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This theory contains our model of the values in the store. The store is untyped, therefore all
  types that exist in Java are wrapped into one type <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Value›</span></span></span></span>.

  In a first approach, the primitive Java types supported in this formalization are 
  mapped to similar Isabelle
  types. Later, we will have
  proper formalizations of the Java types in Isabelle, which will then be used here.
›</span></span>
  
<span class="keyword1"><span class="command">type_synonym</span></span> JavaInt <span class="main">=</span> <span class="quoted">int</span>
<span class="keyword1"><span class="command">type_synonym</span></span> JavaShort <span class="main">=</span> <span class="quoted">int</span>
<span class="keyword1"><span class="command">type_synonym</span></span> JavaByte <span class="main">=</span> <span class="quoted">int</span>
<span class="keyword1"><span class="command">type_synonym</span></span> JavaBoolean <span class="main">=</span> <span class="quoted">bool</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The objects of each class are identified by a unique ID.
We use elements of type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">nat</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> here, but in general it is sufficient to use
an infinite type with a successor function and a comparison predicate.
›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> ObjectId <span class="main">=</span> <span class="quoted">nat</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The definition of the datatype <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Value›</span></span></span></span>. Values can be of the Java types 
boolean, int, short and byte. Additionally, they can be an object reference,
an array reference or the value null.›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> Value <span class="main">=</span> boolV  <span class="quoted">JavaBoolean</span>
               <span class="main">|</span> intgV  <span class="quoted">JavaInt</span>  
               <span class="main">|</span> shortV <span class="quoted">JavaShort</span>
               <span class="main">|</span> byteV  <span class="quoted">JavaByte</span>
               <span class="main">|</span> objV   <span class="quoted">CTypeId</span> <span class="quoted">ObjectId</span>   <span class="comment1">― ‹typed object reference›</span>
               <span class="main">|</span> arrV   <span class="quoted">Arraytype</span> <span class="quoted">ObjectId</span> <span class="comment1">― ‹typed array reference›</span>
               <span class="main">|</span> nullV
               

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Arrays are modeled as references just like objects. So they
can be viewed as special kinds of objects, like in Java.›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Discriminator Functions›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹To test values, we define the following discriminator functions.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">isBoolV</span>  <span class="main">::</span> <span class="quoted"><span class="quoted">"Value <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">isBoolV</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="keyword1">of</span>
               boolV <span class="bound">b</span>  <span class="main">⇒</span> True 
             <span class="main">|</span> intgV <span class="bound">i</span>  <span class="main">⇒</span> False
             <span class="main">|</span> shortV <span class="bound">s</span> <span class="main">⇒</span> False
             <span class="main">|</span> byteV  <span class="bound">by</span> <span class="main">⇒</span> False
             <span class="main">|</span> objV <span class="bound">C</span> <span class="bound">a</span> <span class="main">⇒</span> False
             <span class="main">|</span> arrV <span class="bound">T</span> <span class="bound">a</span> <span class="main">⇒</span> False
             <span class="main">|</span> nullV    <span class="main">⇒</span> False<span class="main">)</span>"</span></span>

<span class="keyword1" id="Value-isBoolV_simps"><span class="command">lemma</span></span> isBoolV_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
<span class="quoted"><span class="quoted">"isBoolV <span class="main">(</span>boolV <span class="free">b</span><span class="main">)</span>       <span class="main">=</span> True"</span></span> 
<span class="quoted"><span class="quoted">"isBoolV <span class="main">(</span>intgV <span class="free">i</span><span class="main">)</span>       <span class="main">=</span> False"</span></span>
<span class="quoted"><span class="quoted">"isBoolV <span class="main">(</span>shortV <span class="free">s</span><span class="main">)</span>      <span class="main">=</span> False"</span></span>
<span class="quoted"><span class="quoted">"isBoolV <span class="main">(</span>byteV <span class="free">by</span><span class="main">)</span>       <span class="main">=</span> False"</span></span>
<span class="quoted"><span class="quoted">"isBoolV <span class="main">(</span>objV <span class="free">C</span> <span class="free">a</span><span class="main">)</span>      <span class="main">=</span> False"</span></span>
<span class="quoted"><span class="quoted">"isBoolV <span class="main">(</span>arrV <span class="free">T</span> <span class="free">a</span><span class="main">)</span>      <span class="main">=</span> False"</span></span>
<span class="quoted"><span class="quoted">"isBoolV <span class="main">(</span>nullV<span class="main">)</span>         <span class="main">=</span> False"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> isBoolV_def<span class="main">)</span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">isIntgV</span>  <span class="main">::</span> <span class="quoted"><span class="quoted">"Value <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">isIntgV</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="keyword1">of</span>
               boolV <span class="bound">b</span>  <span class="main">⇒</span> False 
             <span class="main">|</span> intgV <span class="bound">i</span>  <span class="main">⇒</span> True
             <span class="main">|</span> shortV <span class="bound">s</span> <span class="main">⇒</span> False
             <span class="main">|</span> byteV <span class="bound">by</span>  <span class="main">⇒</span> False
             <span class="main">|</span> objV <span class="bound">C</span> <span class="bound">a</span> <span class="main">⇒</span> False
             <span class="main">|</span> arrV <span class="bound">T</span> <span class="bound">a</span> <span class="main">⇒</span> False
             <span class="main">|</span> nullV    <span class="main">⇒</span> False<span class="main">)</span>"</span></span> 

<span class="keyword1" id="Value-isIntgV_simps"><span class="command">lemma</span></span> isIntgV_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
<span class="quoted"><span class="quoted">"isIntgV <span class="main">(</span>boolV <span class="free">b</span><span class="main">)</span>       <span class="main">=</span> False"</span></span> 
<span class="quoted"><span class="quoted">"isIntgV <span class="main">(</span>intgV <span class="free">i</span><span class="main">)</span>       <span class="main">=</span> True"</span></span>
<span class="quoted"><span class="quoted">"isIntgV <span class="main">(</span>shortV <span class="free">s</span><span class="main">)</span>       <span class="main">=</span> False"</span></span>
<span class="quoted"><span class="quoted">"isIntgV <span class="main">(</span>byteV <span class="free">by</span><span class="main">)</span>       <span class="main">=</span> False"</span></span>
<span class="quoted"><span class="quoted">"isIntgV <span class="main">(</span>objV <span class="free">C</span> <span class="free">a</span><span class="main">)</span>      <span class="main">=</span> False"</span></span>
<span class="quoted"><span class="quoted">"isIntgV <span class="main">(</span>arrV <span class="free">T</span> <span class="free">a</span><span class="main">)</span>      <span class="main">=</span> False"</span></span>
<span class="quoted"><span class="quoted">"isIntgV <span class="main">(</span>nullV<span class="main">)</span>         <span class="main">=</span> False"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> isIntgV_def<span class="main">)</span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">isShortV</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Value <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">isShortV</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="keyword1">of</span>
               boolV <span class="bound">b</span>  <span class="main">⇒</span> False 
             <span class="main">|</span> intgV <span class="bound">i</span>  <span class="main">⇒</span> False
             <span class="main">|</span> shortV <span class="bound">s</span> <span class="main">⇒</span> True
             <span class="main">|</span> byteV <span class="bound">by</span>  <span class="main">⇒</span> False
             <span class="main">|</span> objV <span class="bound">C</span> <span class="bound">a</span> <span class="main">⇒</span> False
             <span class="main">|</span> arrV <span class="bound">T</span> <span class="bound">a</span> <span class="main">⇒</span> False
             <span class="main">|</span> nullV    <span class="main">⇒</span> False<span class="main">)</span>"</span></span> 

<span class="keyword1" id="Value-isShortV_simps"><span class="command">lemma</span></span> isShortV_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
<span class="quoted"><span class="quoted">"isShortV <span class="main">(</span>boolV <span class="free">b</span><span class="main">)</span>     <span class="main">=</span> False"</span></span> 
<span class="quoted"><span class="quoted">"isShortV <span class="main">(</span>intgV <span class="free">i</span><span class="main">)</span>     <span class="main">=</span> False"</span></span>
<span class="quoted"><span class="quoted">"isShortV <span class="main">(</span>shortV <span class="free">s</span><span class="main">)</span>    <span class="main">=</span> True"</span></span>
<span class="quoted"><span class="quoted">"isShortV <span class="main">(</span>byteV <span class="free">by</span><span class="main">)</span>     <span class="main">=</span> False"</span></span>
<span class="quoted"><span class="quoted">"isShortV <span class="main">(</span>objV <span class="free">C</span> <span class="free">a</span><span class="main">)</span>    <span class="main">=</span> False"</span></span>
<span class="quoted"><span class="quoted">"isShortV <span class="main">(</span>arrV <span class="free">T</span> <span class="free">a</span><span class="main">)</span>    <span class="main">=</span> False"</span></span>
<span class="quoted"><span class="quoted">"isShortV <span class="main">(</span>nullV<span class="main">)</span>       <span class="main">=</span> False"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> isShortV_def<span class="main">)</span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">isByteV</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Value <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">isByteV</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="keyword1">of</span>
               boolV <span class="bound">b</span>  <span class="main">⇒</span> False 
             <span class="main">|</span> intgV <span class="bound">i</span>  <span class="main">⇒</span> False
             <span class="main">|</span> shortV <span class="bound">s</span> <span class="main">⇒</span> False
             <span class="main">|</span> byteV <span class="bound">by</span>  <span class="main">⇒</span> True
             <span class="main">|</span> objV <span class="bound">C</span> <span class="bound">a</span> <span class="main">⇒</span> False
             <span class="main">|</span> arrV <span class="bound">T</span> <span class="bound">a</span> <span class="main">⇒</span> False
             <span class="main">|</span> nullV    <span class="main">⇒</span> False<span class="main">)</span>"</span></span> 

<span class="keyword1" id="Value-isByteV_simps"><span class="command">lemma</span></span> isByteV_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
<span class="quoted"><span class="quoted">"isByteV <span class="main">(</span>boolV <span class="free">b</span><span class="main">)</span>      <span class="main">=</span> False"</span></span> 
<span class="quoted"><span class="quoted">"isByteV <span class="main">(</span>intgV <span class="free">i</span><span class="main">)</span>      <span class="main">=</span> False"</span></span>
<span class="quoted"><span class="quoted">"isByteV <span class="main">(</span>shortV <span class="free">s</span><span class="main">)</span>     <span class="main">=</span> False"</span></span>
<span class="quoted"><span class="quoted">"isByteV <span class="main">(</span>byteV <span class="free">by</span><span class="main">)</span>      <span class="main">=</span> True"</span></span>
<span class="quoted"><span class="quoted">"isByteV <span class="main">(</span>objV <span class="free">C</span> <span class="free">a</span><span class="main">)</span>     <span class="main">=</span> False"</span></span>
<span class="quoted"><span class="quoted">"isByteV <span class="main">(</span>arrV <span class="free">T</span> <span class="free">a</span><span class="main">)</span>     <span class="main">=</span> False"</span></span>
<span class="quoted"><span class="quoted">"isByteV <span class="main">(</span>nullV<span class="main">)</span>        <span class="main">=</span> False"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> isByteV_def<span class="main">)</span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">isRefV</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Value <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">isRefV</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="keyword1">of</span>
               boolV <span class="bound">b</span>  <span class="main">⇒</span> False 
             <span class="main">|</span> intgV <span class="bound">i</span>  <span class="main">⇒</span> False
             <span class="main">|</span> shortV <span class="bound">s</span> <span class="main">⇒</span> False
             <span class="main">|</span> byteV <span class="bound">by</span> <span class="main">⇒</span> False
             <span class="main">|</span> objV <span class="bound">C</span> <span class="bound">a</span>  <span class="main">⇒</span> True
             <span class="main">|</span> arrV <span class="bound">T</span> <span class="bound">a</span>  <span class="main">⇒</span> True
             <span class="main">|</span> nullV     <span class="main">⇒</span> True<span class="main">)</span>"</span></span>

<span class="keyword1" id="Value-isRefV_simps"><span class="command">lemma</span></span> isRefV_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
<span class="quoted"><span class="quoted">"isRefV <span class="main">(</span>boolV <span class="free">b</span><span class="main">)</span>       <span class="main">=</span> False"</span></span> 
<span class="quoted"><span class="quoted">"isRefV <span class="main">(</span>intgV <span class="free">i</span><span class="main">)</span>       <span class="main">=</span> False"</span></span>
<span class="quoted"><span class="quoted">"isRefV <span class="main">(</span>shortV <span class="free">s</span><span class="main">)</span>      <span class="main">=</span> False"</span></span>
<span class="quoted"><span class="quoted">"isRefV <span class="main">(</span>byteV <span class="free">by</span><span class="main">)</span>      <span class="main">=</span> False"</span></span>
<span class="quoted"><span class="quoted">"isRefV <span class="main">(</span>objV <span class="free">C</span> <span class="free">a</span><span class="main">)</span>      <span class="main">=</span> True"</span></span>
<span class="quoted"><span class="quoted">"isRefV <span class="main">(</span>arrV <span class="free">T</span> <span class="free">a</span><span class="main">)</span>      <span class="main">=</span> True"</span></span>
<span class="quoted"><span class="quoted">"isRefV <span class="main">(</span>nullV<span class="main">)</span>         <span class="main">=</span> True"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> isRefV_def<span class="main">)</span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">isObjV</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Value <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">isObjV</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="keyword1">of</span>
               boolV <span class="bound">b</span>  <span class="main">⇒</span> False 
             <span class="main">|</span> intgV <span class="bound">i</span>  <span class="main">⇒</span> False
             <span class="main">|</span> shortV <span class="bound">s</span>  <span class="main">⇒</span> False
             <span class="main">|</span> byteV <span class="bound">by</span>  <span class="main">⇒</span> False
             <span class="main">|</span> objV <span class="bound">C</span> <span class="bound">a</span> <span class="main">⇒</span> True
             <span class="main">|</span> arrV <span class="bound">T</span> <span class="bound">a</span> <span class="main">⇒</span> False
             <span class="main">|</span> nullV    <span class="main">⇒</span> False<span class="main">)</span>"</span></span>

<span class="keyword1" id="Value-isObjV_simps"><span class="command">lemma</span></span> isObjV_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
<span class="quoted"><span class="quoted">"isObjV <span class="main">(</span>boolV <span class="free">b</span><span class="main">)</span>  <span class="main">=</span> False"</span></span> 
<span class="quoted"><span class="quoted">"isObjV <span class="main">(</span>intgV <span class="free">i</span><span class="main">)</span>  <span class="main">=</span> False"</span></span>
<span class="quoted"><span class="quoted">"isObjV <span class="main">(</span>shortV <span class="free">s</span><span class="main">)</span>  <span class="main">=</span> False"</span></span>
<span class="quoted"><span class="quoted">"isObjV <span class="main">(</span>byteV <span class="free">by</span><span class="main">)</span>  <span class="main">=</span> False"</span></span>
<span class="quoted"><span class="quoted">"isObjV <span class="main">(</span>objV <span class="free">c</span> <span class="free">a</span><span class="main">)</span> <span class="main">=</span> True"</span></span> 
<span class="quoted"><span class="quoted">"isObjV <span class="main">(</span>arrV <span class="free">T</span> <span class="free">a</span><span class="main">)</span> <span class="main">=</span> False"</span></span>
<span class="quoted"><span class="quoted">"isObjV nullV      <span class="main">=</span> False"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> isObjV_def<span class="main">)</span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">isArrV</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Value <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">isArrV</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="keyword1">of</span>
               boolV <span class="bound">b</span>  <span class="main">⇒</span> False 
             <span class="main">|</span> intgV <span class="bound">i</span>  <span class="main">⇒</span> False
             <span class="main">|</span> shortV <span class="bound">s</span>  <span class="main">⇒</span> False
             <span class="main">|</span> byteV <span class="bound">by</span>  <span class="main">⇒</span> False
             <span class="main">|</span> objV <span class="bound">C</span> <span class="bound">a</span> <span class="main">⇒</span> False
             <span class="main">|</span> arrV <span class="bound">T</span> <span class="bound">a</span> <span class="main">⇒</span> True
             <span class="main">|</span> nullV    <span class="main">⇒</span> False<span class="main">)</span>"</span></span>

<span class="keyword1" id="Value-isArrV_simps"><span class="command">lemma</span></span> isArrV_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
<span class="quoted"><span class="quoted">"isArrV <span class="main">(</span>boolV <span class="free">b</span><span class="main">)</span>  <span class="main">=</span> False"</span></span> 
<span class="quoted"><span class="quoted">"isArrV <span class="main">(</span>intgV <span class="free">i</span><span class="main">)</span>  <span class="main">=</span> False"</span></span>
<span class="quoted"><span class="quoted">"isArrV <span class="main">(</span>shortV <span class="free">s</span><span class="main">)</span>  <span class="main">=</span> False"</span></span>
<span class="quoted"><span class="quoted">"isArrV <span class="main">(</span>byteV <span class="free">by</span><span class="main">)</span>  <span class="main">=</span> False"</span></span>
<span class="quoted"><span class="quoted">"isArrV <span class="main">(</span>objV <span class="free">c</span> <span class="free">a</span><span class="main">)</span> <span class="main">=</span> False"</span></span> 
<span class="quoted"><span class="quoted">"isArrV <span class="main">(</span>arrV <span class="free">T</span> <span class="free">a</span><span class="main">)</span> <span class="main">=</span> True"</span></span>
<span class="quoted"><span class="quoted">"isArrV nullV      <span class="main">=</span> False"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> isArrV_def<span class="main">)</span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">isNullV</span>  <span class="main">::</span> <span class="quoted"><span class="quoted">"Value <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">isNullV</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="keyword1">of</span>
               boolV <span class="bound">b</span>  <span class="main">⇒</span> False 
             <span class="main">|</span> intgV <span class="bound">i</span>  <span class="main">⇒</span> False
             <span class="main">|</span> shortV <span class="bound">s</span>  <span class="main">⇒</span> False
             <span class="main">|</span> byteV <span class="bound">by</span>  <span class="main">⇒</span> False
             <span class="main">|</span> objV <span class="bound">C</span> <span class="bound">a</span> <span class="main">⇒</span> False
             <span class="main">|</span> arrV <span class="bound">T</span> <span class="bound">a</span> <span class="main">⇒</span> False
             <span class="main">|</span> nullV    <span class="main">⇒</span> True<span class="main">)</span>"</span></span>

<span class="keyword1" id="Value-isNullV_simps"><span class="command">lemma</span></span> isNullV_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
<span class="quoted"><span class="quoted">"isNullV <span class="main">(</span>boolV <span class="free">b</span><span class="main">)</span>   <span class="main">=</span> False"</span></span> 
<span class="quoted"><span class="quoted">"isNullV <span class="main">(</span>intgV <span class="free">i</span><span class="main">)</span>   <span class="main">=</span> False"</span></span>
<span class="quoted"><span class="quoted">"isNullV <span class="main">(</span>shortV <span class="free">s</span><span class="main">)</span>   <span class="main">=</span> False"</span></span>
<span class="quoted"><span class="quoted">"isNullV <span class="main">(</span>byteV <span class="free">by</span><span class="main">)</span>   <span class="main">=</span> False"</span></span>
<span class="quoted"><span class="quoted">"isNullV <span class="main">(</span>objV <span class="free">c</span> <span class="free">a</span><span class="main">)</span> <span class="main">=</span> False"</span></span> 
<span class="quoted"><span class="quoted">"isNullV <span class="main">(</span>arrV <span class="free">T</span> <span class="free">a</span><span class="main">)</span> <span class="main">=</span> False"</span></span>
<span class="quoted"><span class="quoted">"isNullV nullV      <span class="main">=</span> True"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> isNullV_def<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Selector Functions›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">aI</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Value <span class="main">⇒</span> JavaInt"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">aI</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="keyword1">of</span>  
            boolV  <span class="bound">b</span>   <span class="main">⇒</span> undefined
          <span class="main">|</span> intgV  <span class="bound">i</span>   <span class="main">⇒</span> <span class="bound">i</span>
          <span class="main">|</span> shortV <span class="bound">sh</span>  <span class="main">⇒</span> undefined
          <span class="main">|</span> byteV  <span class="bound">by</span>  <span class="main">⇒</span> undefined
          <span class="main">|</span> objV   <span class="bound">C</span> <span class="bound">a</span> <span class="main">⇒</span> undefined
          <span class="main">|</span> arrV  <span class="bound">T</span> <span class="bound">a</span>  <span class="main">⇒</span> undefined
          <span class="main">|</span> nullV      <span class="main">⇒</span> undefined<span class="main">)</span>"</span></span>
<span class="keyword1" id="Value-aI_simps"><span class="command">lemma</span></span> aI_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
<span class="quoted"><span class="quoted">"aI <span class="main">(</span>intgV <span class="free">i</span><span class="main">)</span> <span class="main">=</span> <span class="free">i</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> aI_def<span class="main">)</span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">aB</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Value <span class="main">⇒</span> JavaBoolean"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">aB</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="keyword1">of</span>  
            boolV  <span class="bound">b</span>   <span class="main">⇒</span> <span class="bound">b</span>
          <span class="main">|</span> intgV  <span class="bound">i</span>   <span class="main">⇒</span> undefined
          <span class="main">|</span> shortV <span class="bound">sh</span>  <span class="main">⇒</span> undefined
          <span class="main">|</span> byteV  <span class="bound">by</span>  <span class="main">⇒</span> undefined
          <span class="main">|</span> objV   <span class="bound">C</span> <span class="bound">a</span> <span class="main">⇒</span> undefined
          <span class="main">|</span> arrV  <span class="bound">T</span> <span class="bound">a</span>  <span class="main">⇒</span> undefined
          <span class="main">|</span> nullV      <span class="main">⇒</span> undefined<span class="main">)</span>"</span></span>
<span class="keyword1" id="Value-aB_simps"><span class="command">lemma</span></span> aB_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
<span class="quoted"><span class="quoted">"aB <span class="main">(</span>boolV <span class="free">b</span><span class="main">)</span> <span class="main">=</span> <span class="free">b</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> aB_def<span class="main">)</span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">aSh</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Value <span class="main">⇒</span> JavaShort"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">aSh</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="keyword1">of</span>  
            boolV  <span class="bound">b</span>   <span class="main">⇒</span> undefined
          <span class="main">|</span> intgV  <span class="bound">i</span>   <span class="main">⇒</span> undefined
          <span class="main">|</span> shortV <span class="bound">sh</span>  <span class="main">⇒</span> <span class="bound">sh</span>
          <span class="main">|</span> byteV  <span class="bound">by</span>  <span class="main">⇒</span> undefined
          <span class="main">|</span> objV   <span class="bound">C</span> <span class="bound">a</span> <span class="main">⇒</span> undefined
          <span class="main">|</span> arrV  <span class="bound">T</span> <span class="bound">a</span>  <span class="main">⇒</span> undefined
          <span class="main">|</span> nullV      <span class="main">⇒</span> undefined<span class="main">)</span>"</span></span>
<span class="keyword1" id="Value-aSh_simps"><span class="command">lemma</span></span> aSh_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
<span class="quoted"><span class="quoted">"aSh <span class="main">(</span>shortV <span class="free">sh</span><span class="main">)</span> <span class="main">=</span> <span class="free">sh</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> aSh_def<span class="main">)</span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">aBy</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Value <span class="main">⇒</span> JavaByte"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">aBy</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="keyword1">of</span>  
            boolV  <span class="bound">b</span>   <span class="main">⇒</span> undefined
          <span class="main">|</span> intgV  <span class="bound">i</span>   <span class="main">⇒</span> undefined
          <span class="main">|</span> shortV <span class="bound">s</span>   <span class="main">⇒</span> undefined
          <span class="main">|</span> byteV  <span class="bound">by</span>  <span class="main">⇒</span> <span class="bound">by</span>
          <span class="main">|</span> objV   <span class="bound">C</span> <span class="bound">a</span> <span class="main">⇒</span> undefined
          <span class="main">|</span> arrV  <span class="bound">T</span> <span class="bound">a</span>  <span class="main">⇒</span> undefined
          <span class="main">|</span> nullV      <span class="main">⇒</span> undefined<span class="main">)</span>"</span></span>
<span class="keyword1" id="Value-aBy_simps"><span class="command">lemma</span></span> aBy_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
<span class="quoted"><span class="quoted">"aBy <span class="main">(</span>byteV <span class="free">by</span><span class="main">)</span> <span class="main">=</span> <span class="free">by</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> aBy_def<span class="main">)</span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">tid</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Value <span class="main">⇒</span> CTypeId"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">tid</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="keyword1">of</span>
            boolV  <span class="bound">b</span>   <span class="main">⇒</span> undefined
          <span class="main">|</span> intgV  <span class="bound">i</span>   <span class="main">⇒</span> undefined
          <span class="main">|</span> shortV <span class="bound">s</span>   <span class="main">⇒</span> undefined
          <span class="main">|</span> byteV  <span class="bound">by</span>  <span class="main">⇒</span> undefined
          <span class="main">|</span> objV   <span class="bound">C</span> <span class="bound">a</span> <span class="main">⇒</span> <span class="bound">C</span>
          <span class="main">|</span> arrV  <span class="bound">T</span> <span class="bound">a</span>  <span class="main">⇒</span> undefined
          <span class="main">|</span> nullV      <span class="main">⇒</span> undefined<span class="main">)</span>"</span></span>

<span class="keyword1" id="Value-tid_simps"><span class="command">lemma</span></span> tid_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
<span class="quoted"><span class="quoted">"tid <span class="main">(</span>objV <span class="free">C</span> <span class="free">a</span><span class="main">)</span> <span class="main">=</span> <span class="free">C</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tid_def<span class="main">)</span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">oid</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Value <span class="main">⇒</span> ObjectId"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">oid</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="keyword1">of</span>
            boolV  <span class="bound">b</span>   <span class="main">⇒</span> undefined
          <span class="main">|</span> intgV  <span class="bound">i</span>   <span class="main">⇒</span> undefined
          <span class="main">|</span> shortV <span class="bound">s</span>   <span class="main">⇒</span> undefined
          <span class="main">|</span> byteV  <span class="bound">by</span>  <span class="main">⇒</span> undefined
          <span class="main">|</span> objV   <span class="bound">C</span> <span class="bound">a</span> <span class="main">⇒</span> <span class="bound">a</span>
          <span class="main">|</span> arrV  <span class="bound">T</span> <span class="bound">a</span>  <span class="main">⇒</span> undefined
          <span class="main">|</span> nullV      <span class="main">⇒</span> undefined<span class="main">)</span>"</span></span>

<span class="keyword1" id="Value-oid_simps"><span class="command">lemma</span></span> oid_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
<span class="quoted"><span class="quoted">"oid <span class="main">(</span>objV <span class="free">C</span> <span class="free">a</span><span class="main">)</span> <span class="main">=</span> <span class="free">a</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> oid_def<span class="main">)</span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">jt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Value <span class="main">⇒</span> Javatype"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">jt</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="keyword1">of</span>
            boolV  <span class="bound">b</span>   <span class="main">⇒</span> undefined
          <span class="main">|</span> intgV  <span class="bound">i</span>   <span class="main">⇒</span> undefined
          <span class="main">|</span> shortV <span class="bound">s</span>   <span class="main">⇒</span> undefined
          <span class="main">|</span> byteV  <span class="bound">by</span>  <span class="main">⇒</span> undefined
          <span class="main">|</span> objV   <span class="bound">C</span> <span class="bound">a</span> <span class="main">⇒</span> undefined
          <span class="main">|</span> arrV  <span class="bound">T</span> <span class="bound">a</span>  <span class="main">⇒</span> at2jt <span class="bound">T</span>
          <span class="main">|</span> nullV      <span class="main">⇒</span> undefined<span class="main">)</span>"</span></span>

<span class="keyword1" id="Value-jt_simps"><span class="command">lemma</span></span> jt_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
<span class="quoted"><span class="quoted">"jt <span class="main">(</span>arrV <span class="free">T</span> <span class="free">a</span><span class="main">)</span> <span class="main">=</span> at2jt <span class="free">T</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> jt_def<span class="main">)</span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">aid</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Value <span class="main">⇒</span> ObjectId"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">aid</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="keyword1">of</span>
            boolV  <span class="bound">b</span>   <span class="main">⇒</span> undefined
          <span class="main">|</span> intgV  <span class="bound">i</span>   <span class="main">⇒</span> undefined
          <span class="main">|</span> shortV <span class="bound">s</span>   <span class="main">⇒</span> undefined
          <span class="main">|</span> byteV  <span class="bound">by</span>  <span class="main">⇒</span> undefined
          <span class="main">|</span> objV   <span class="bound">C</span> <span class="bound">a</span> <span class="main">⇒</span> undefined
          <span class="main">|</span> arrV  <span class="bound">T</span> <span class="bound">a</span>  <span class="main">⇒</span> <span class="bound">a</span>
          <span class="main">|</span> nullV      <span class="main">⇒</span> undefined<span class="main">)</span>"</span></span>

<span class="keyword1" id="Value-aid_simps"><span class="command">lemma</span></span> aid_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
<span class="quoted"><span class="quoted">"aid <span class="main">(</span>arrV <span class="free">T</span> <span class="free">a</span><span class="main">)</span> <span class="main">=</span> <span class="free">a</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> aid_def<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Determining the Type of a Value›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹To determine the type of a value, we define the function
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>typeof›</span></span></span></span>. This function is
often written as $\tau$ in theoretical texts, therefore we add
the appropriate syntax support.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">typeof</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Value <span class="main">⇒</span> Javatype"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">typeof</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="keyword1">of</span>
               boolV <span class="bound">b</span>  <span class="main">⇒</span> BoolT 
             <span class="main">|</span> intgV <span class="bound">i</span>  <span class="main">⇒</span> IntgT
             <span class="main">|</span> shortV <span class="bound">sh</span>  <span class="main">⇒</span> ShortT
             <span class="main">|</span> byteV <span class="bound">by</span>  <span class="main">⇒</span> ByteT
             <span class="main">|</span> objV <span class="bound">C</span> <span class="bound">a</span> <span class="main">⇒</span> CClassT <span class="bound">C</span>
             <span class="main">|</span> arrV <span class="bound">T</span> <span class="bound">a</span> <span class="main">⇒</span> ArrT <span class="bound">T</span>
             <span class="main">|</span> nullV    <span class="main">⇒</span> NullT<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">tau_syntax</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Value <span class="main">⇒</span> Javatype"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">τ</span> _"</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="free">τ</span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">==</span> typeof <span class="free"><span class="bound"><span class="entity">v</span></span></span>"</span></span>

<span class="keyword1" id="Value-typeof_simps"><span class="command">lemma</span></span> typeof_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
<span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">τ</span> <span class="main">(</span>boolV <span class="free">b</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> BoolT"</span></span>
<span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">τ</span> <span class="main">(</span>intgV <span class="free">i</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> IntgT"</span></span>
<span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">τ</span> <span class="main">(</span>shortV <span class="free">sh</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> ShortT"</span></span>
<span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">τ</span> <span class="main">(</span>byteV <span class="free">by</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> ByteT"</span></span>
<span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">τ</span> <span class="main">(</span>objV <span class="free">c</span> <span class="free">a</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> CClassT <span class="free">c</span>"</span></span>
<span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">τ</span> <span class="main">(</span>arrV <span class="free">t</span> <span class="free">a</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> ArrT <span class="free">t</span>"</span></span>
<span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">τ</span> <span class="main">(</span>nullV<span class="main">)</span><span class="main">)</span>   <span class="main">=</span> NullT"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> typeof_def<span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Default Initialization Values for Types›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>init›</span></span></span></span> yields the default initialization values for each 
type. For boolean, the
default value is False, for the integral types, it is 0, and for the reference
types, it is nullV.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">init</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Javatype <span class="main">⇒</span> Value"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">init</span> <span class="free"><span class="bound"><span class="entity">T</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">T</span></span></span> <span class="keyword1">of</span>
             BoolT        <span class="main">⇒</span> boolV  False
           <span class="main">|</span> IntgT        <span class="main">⇒</span> intgV  <span class="main">0</span>
           <span class="main">|</span> ShortT        <span class="main">⇒</span> shortV <span class="main">0</span>
           <span class="main">|</span> ByteT        <span class="main">⇒</span> byteV  <span class="main">0</span>
           <span class="main">|</span> NullT        <span class="main">⇒</span> nullV
           <span class="main">|</span> ArrT <span class="bound">T</span>       <span class="main">⇒</span> nullV
           <span class="main">|</span> CClassT <span class="bound">C</span>     <span class="main">⇒</span> nullV
           <span class="main">|</span> AClassT <span class="bound">C</span>     <span class="main">⇒</span> nullV
           <span class="main">|</span> InterfaceT <span class="bound">I</span> <span class="main">⇒</span> nullV<span class="main">)</span>"</span></span> 

<span class="keyword1" id="Value-init_simps"><span class="command">lemma</span></span> init_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
<span class="quoted"><span class="quoted">"init BoolT          <span class="main">=</span> boolV False"</span></span>
<span class="quoted"><span class="quoted">"init IntgT          <span class="main">=</span> intgV <span class="main">0</span>"</span></span>
<span class="quoted"><span class="quoted">"init ShortT         <span class="main">=</span> shortV <span class="main">0</span>"</span></span>
<span class="quoted"><span class="quoted">"init ByteT          <span class="main">=</span> byteV <span class="main">0</span>"</span></span>
<span class="quoted"><span class="quoted">"init NullT          <span class="main">=</span> nullV"</span></span>
<span class="quoted"><span class="quoted">"init <span class="main">(</span>ArrT <span class="free">T</span><span class="main">)</span>       <span class="main">=</span> nullV"</span></span>
<span class="quoted"><span class="quoted">"init <span class="main">(</span>CClassT <span class="free">c</span><span class="main">)</span>     <span class="main">=</span> nullV"</span></span>
<span class="quoted"><span class="quoted">"init <span class="main">(</span>AClassT <span class="free">a</span><span class="main">)</span>     <span class="main">=</span> nullV"</span></span>
<span class="quoted"><span class="quoted">"init <span class="main">(</span>InterfaceT <span class="free">i</span><span class="main">)</span> <span class="main">=</span> nullV"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> init_def<span class="main">)</span>

<span class="keyword1" id="Value-typeof_init_widen"><span class="command">lemma</span></span> typeof_init_widen <span class="main">[</span><span class="operator">simp</span><span class="main">,</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"typeof <span class="main">(</span>init <span class="free">T</span><span class="main">)</span> <span class="main">≤</span> <span class="free">T</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">T</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> c<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">T</span> <span class="main">=</span> BoolT"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">τ</span> <span class="main">(</span>init <span class="free">T</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span> <span class="free">T</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> c <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> c<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">T</span> <span class="main">=</span> IntgT"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">τ</span> <span class="main">(</span>init <span class="free">T</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span> <span class="free">T</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> c <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> c<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">T</span> <span class="main">=</span> ShortT"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">τ</span> <span class="main">(</span>init <span class="free">T</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span> <span class="free">T</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> c <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> c<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">T</span> <span class="main">=</span> ByteT"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">τ</span> <span class="main">(</span>init <span class="free">T</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span> <span class="free">T</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> c <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> c<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">T</span> <span class="main">=</span> NullT"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">τ</span> <span class="main">(</span>init <span class="free">T</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span> <span class="free">T</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> c <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
  <span class="keyword3"><span class="command">assume</span></span> c<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">T</span> <span class="main">=</span> CClassT <span class="skolem">x</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">τ</span> <span class="main">(</span>init <span class="free">T</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span> <span class="free">T</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> c <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
  <span class="keyword3"><span class="command">assume</span></span> c<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">T</span> <span class="main">=</span> AClassT <span class="skolem">x</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">τ</span> <span class="main">(</span>init <span class="free">T</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span> <span class="free">T</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> c <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
  <span class="keyword3"><span class="command">assume</span></span> c<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">T</span> <span class="main">=</span> InterfaceT <span class="skolem">x</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">τ</span> <span class="main">(</span>init <span class="free">T</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span> <span class="free">T</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> c <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
  <span class="keyword3"><span class="command">assume</span></span> c<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">T</span> <span class="main">=</span> ArrT <span class="skolem">x</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">τ</span> <span class="main">(</span>init <span class="free">T</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span> <span class="free">T</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> c 
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">y</span>
    <span class="keyword3"><span class="command">assume</span></span> c2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> CClassAT <span class="skolem">y</span>"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">τ</span> <span class="main">(</span>init <span class="free">T</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span> <span class="free">T</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> c c2 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">y</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">y</span>
    <span class="keyword3"><span class="command">assume</span></span> c2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> AClassAT <span class="skolem">y</span>"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">τ</span> <span class="main">(</span>init <span class="free">T</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span> <span class="free">T</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> c c2 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">y</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">y</span>
    <span class="keyword3"><span class="command">assume</span></span> c2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> InterfaceAT <span class="skolem">y</span>"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">τ</span> <span class="main">(</span>init <span class="free">T</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span> <span class="free">T</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> c c2 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">y</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> c2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> BoolAT"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">τ</span> <span class="main">(</span>init <span class="free">T</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span> <span class="free">T</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> c c2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> c2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> IntgAT"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">τ</span> <span class="main">(</span>init <span class="free">T</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span> <span class="free">T</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> c c2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> c2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> ShortAT"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">τ</span> <span class="main">(</span>init <span class="free">T</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span> <span class="free">T</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> c c2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> c2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> ByteAT"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">τ</span> <span class="main">(</span>init <span class="free">T</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span> <span class="free">T</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> c c2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Location">
<div class="head">
<h1>Theory Location</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Jive Data and Store Model
    Author:      Norbert Schirmer &lt;schirmer at informatik.tu-muenchen.de&gt;, 2003
    Maintainer:  Nicole Rauch &lt;rauch at informatik.uni-kl.de&gt;
    License:     LGPL
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Location›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Location
<span class="keyword2"><span class="keyword">imports</span></span> <a href="#AttributesIndep">AttributesIndep</a> <span class="quoted">"<a href="#Value">../Isabelle/Value</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span> 

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A storage location can be a field of an object, a static field,
 the length of an array, or the contents of an array.  
›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> Location <span class="main">=</span> objLoc    <span class="quoted">CAttId</span> <span class="quoted">ObjectId</span>     <span class="comment1">― ‹field in object›</span> 
                  <span class="main">|</span> staticLoc <span class="quoted">AttId</span>               <span class="comment1">― ‹static field in concrete class›</span>
                  <span class="main">|</span> arrLenLoc <span class="quoted">Arraytype</span> <span class="quoted">ObjectId</span>   <span class="comment1">― ‹length of an array›</span>
                  <span class="main">|</span> arrLoc    <span class="quoted">Arraytype</span> <span class="quoted">ObjectId</span> <span class="quoted">nat</span> <span class="comment1">― ‹contents of an array›</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We only directly support one-dimensional arrays. Multidimensional
arrays can be simulated by arrays of references to arrays.
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>ltype›</span></span></span></span> yields the content type of a location.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ltype</span><span class="main">::</span> <span class="quoted"><span class="quoted">"Location <span class="main">⇒</span> Javatype"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">ltype</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="keyword1">of</span>
              objLoc <span class="bound">cf</span> <span class="bound">a</span>  <span class="main">⇒</span> rtype <span class="main">(</span>att <span class="bound">cf</span><span class="main">)</span>
            <span class="main">|</span> staticLoc <span class="bound">f</span>     <span class="main">⇒</span> rtype <span class="bound">f</span>
            <span class="main">|</span> arrLenLoc <span class="bound">T</span> <span class="bound">a</span>   <span class="main">⇒</span> IntgT
            <span class="main">|</span> arrLoc <span class="bound">T</span> <span class="bound">a</span> <span class="bound">i</span> <span class="main">⇒</span> at2jt <span class="bound">T</span><span class="main">)</span>"</span></span> 

<span class="keyword1" id="Location-ltype_simps"><span class="command">lemma</span></span> ltype_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
<span class="quoted"><span class="quoted">"ltype <span class="main">(</span>objLoc <span class="free">cf</span> <span class="free">a</span><span class="main">)</span>  <span class="main">=</span> rtype <span class="main">(</span>att <span class="free">cf</span><span class="main">)</span>"</span></span>
<span class="quoted"><span class="quoted">"ltype <span class="main">(</span>staticLoc <span class="free">f</span><span class="main">)</span>     <span class="main">=</span> rtype <span class="free">f</span>"</span></span>
<span class="quoted"><span class="quoted">"ltype <span class="main">(</span>arrLenLoc <span class="free">T</span> <span class="free">a</span><span class="main">)</span>   <span class="main">=</span> IntgT"</span></span>
<span class="quoted"><span class="quoted">"ltype <span class="main">(</span>arrLoc <span class="free">T</span> <span class="free">a</span> <span class="free">i</span><span class="main">)</span> <span class="main">=</span> at2jt <span class="free">T</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ltype_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Discriminator functions to test whether a location denotes an array length
or whether it denotes a static object. Currently, the discriminator functions for
object and array locations are not specified. They can be added if they are needed.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">isArrLenLoc</span><span class="main">::</span> <span class="quoted"><span class="quoted">"Location <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">isArrLenLoc</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="keyword1">of</span>
                 objLoc <span class="bound">cf</span> <span class="bound">a</span>  <span class="main">⇒</span> False 
               <span class="main">|</span> staticLoc <span class="bound">f</span>     <span class="main">⇒</span> False
               <span class="main">|</span> arrLenLoc <span class="bound">T</span> <span class="bound">a</span>   <span class="main">⇒</span> True
               <span class="main">|</span> arrLoc <span class="bound">T</span> <span class="bound">a</span> <span class="bound">i</span> <span class="main">⇒</span> False<span class="main">)</span>"</span></span>

<span class="keyword1" id="Location-isArrLenLoc_simps"><span class="command">lemma</span></span> isArrLenLoc_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
<span class="quoted"><span class="quoted">"isArrLenLoc <span class="main">(</span>objLoc <span class="free">cf</span> <span class="free">a</span><span class="main">)</span> <span class="main">=</span> False"</span></span> 
<span class="quoted"><span class="quoted">"isArrLenLoc <span class="main">(</span>staticLoc <span class="free">f</span><span class="main">)</span> <span class="main">=</span> False"</span></span>
<span class="quoted"><span class="quoted">"isArrLenLoc <span class="main">(</span>arrLenLoc <span class="free">T</span> <span class="free">a</span><span class="main">)</span> <span class="main">=</span> True"</span></span>
<span class="quoted"><span class="quoted">"isArrLenLoc <span class="main">(</span>arrLoc <span class="free">T</span> <span class="free">a</span> <span class="free">i</span><span class="main">)</span> <span class="main">=</span> False"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> isArrLenLoc_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">isStaticLoc</span><span class="main">::</span> <span class="quoted"><span class="quoted">"Location <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">isStaticLoc</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="keyword1">of</span>
                 objLoc <span class="bound">cff</span> <span class="bound">a</span> <span class="main">⇒</span> False
               <span class="main">|</span> staticLoc <span class="bound">f</span>     <span class="main">⇒</span> True
               <span class="main">|</span> arrLenLoc <span class="bound">T</span> <span class="bound">a</span>   <span class="main">⇒</span> False
               <span class="main">|</span> arrLoc <span class="bound">T</span> <span class="bound">a</span> <span class="bound">i</span> <span class="main">⇒</span> False<span class="main">)</span>"</span></span>
<span class="keyword1" id="Location-isStaticLoc_simps"><span class="command">lemma</span></span> isStaticLoc_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
<span class="quoted"><span class="quoted">"isStaticLoc <span class="main">(</span>objLoc <span class="free">cf</span> <span class="free">a</span><span class="main">)</span> <span class="main">=</span> False"</span></span>
<span class="quoted"><span class="quoted">"isStaticLoc <span class="main">(</span>staticLoc <span class="free">f</span><span class="main">)</span>     <span class="main">=</span> True"</span></span>
<span class="quoted"><span class="quoted">"isStaticLoc <span class="main">(</span>arrLenLoc <span class="free">T</span> <span class="free">a</span><span class="main">)</span>   <span class="main">=</span> False"</span></span>
<span class="quoted"><span class="quoted">"isStaticLoc <span class="main">(</span>arrLoc <span class="free">T</span> <span class="free">a</span> <span class="free">i</span><span class="main">)</span> <span class="main">=</span> False"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> isStaticLoc_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>ref›</span></span></span></span> yields the
object or array containing the location that is passed
as argument (see the function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>obj›</span></span></span></span> in 
\cite[p. 43 f.]{Poetzsch-Heffter97specification}).
Note that for static locations
the result is <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>nullV›</span></span></span></span> since static locations 
are not associated to any object.
\label{ref_def}
›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ref</span><span class="main">::</span> <span class="quoted"><span class="quoted">"Location <span class="main">⇒</span> Value"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">ref</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="keyword1">of</span>
            objLoc <span class="bound">cf</span> <span class="bound">a</span>  <span class="main">⇒</span> objV <span class="main">(</span>cls <span class="bound">cf</span><span class="main">)</span> <span class="bound">a</span>
          <span class="main">|</span> staticLoc <span class="bound">f</span>     <span class="main">⇒</span> nullV
          <span class="main">|</span> arrLenLoc <span class="bound">T</span> <span class="bound">a</span>   <span class="main">⇒</span> arrV <span class="bound">T</span> <span class="bound">a</span>
          <span class="main">|</span> arrLoc <span class="bound">T</span> <span class="bound">a</span> <span class="bound">i</span> <span class="main">⇒</span> arrV <span class="bound">T</span> <span class="bound">a</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Location-ref_simps"><span class="command">lemma</span></span> ref_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
<span class="quoted"><span class="quoted">"ref <span class="main">(</span>objLoc <span class="free">cf</span> <span class="free">a</span><span class="main">)</span>  <span class="main">=</span> objV <span class="main">(</span>cls <span class="free">cf</span><span class="main">)</span> <span class="free">a</span>"</span></span>
<span class="quoted"><span class="quoted">"ref <span class="main">(</span>staticLoc <span class="free">f</span><span class="main">)</span>     <span class="main">=</span> nullV"</span></span>
<span class="quoted"><span class="quoted">"ref <span class="main">(</span>arrLenLoc <span class="free">T</span> <span class="free">a</span><span class="main">)</span>   <span class="main">=</span> arrV <span class="free">T</span> <span class="free">a</span>"</span></span>
<span class="quoted"><span class="quoted">"ref <span class="main">(</span>arrLoc <span class="free">T</span> <span class="free">a</span> <span class="free">i</span><span class="main">)</span> <span class="main">=</span> arrV <span class="free">T</span> <span class="free">a</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ref_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>loc›</span></span></span></span> denotes the subscription of an object 
reference with an attribute.›</span></span>
<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">loc</span><span class="main">::</span> <span class="quoted"><span class="quoted">"Value <span class="main">⇒</span> AttId <span class="main">⇒</span> Location"</span></span>  <span class="main">(</span><span class="quoted">"_<span class="keyword1">..</span>_"</span> <span class="main">[</span>80<span class="main">,</span>80<span class="main">]</span> 80<span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">loc</span> <span class="main">(</span>objV <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> objLoc <span class="main">(</span>catt <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span>"</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Note that we only define subscription properly for object references.
For all other values we do not provide any defining equation, so they will 
internally be mapped to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>arbitrary›</span></span></span></span>.
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The length of an array can be selected with the function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>arr_len›</span></span></span></span>.›</span></span>
<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">arr_len</span><span class="main">::</span> <span class="quoted"><span class="quoted">"Value <span class="main">⇒</span> Location"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">arr_len</span> <span class="main">(</span>arrV <span class="free"><span class="bound"><span class="entity">T</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span> <span class="main">=</span> arrLenLoc <span class="free"><span class="bound"><span class="entity">T</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Arrays can be indexed by the function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>arr_loc›</span></span></span></span>.›</span></span>
<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">arr_loc</span><span class="main">::</span> <span class="quoted"><span class="quoted">"Value <span class="main">⇒</span> nat <span class="main">⇒</span> Location"</span></span> <span class="main">(</span><span class="quoted">"_<span class="keyword1">.[</span>_<span class="keyword1">]</span>"</span> <span class="main">[</span>80<span class="main">,</span>80<span class="main">]</span> 80<span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">arr_loc</span> <span class="main">(</span>arrV <span class="free"><span class="bound"><span class="entity">T</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">=</span> arrLoc <span class="free"><span class="bound"><span class="entity">T</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span>"</span></span> 

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The functions <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"loc"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"arr_len"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"arr_loc"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
define the interface between the basic store model (based on locations) and
the programming language Java. Instance field access {\tt obj.x} is modelled as 
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">obj</span></span><span class="main"><span class="main">..</span></span><span class="free"><span class="free">x</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> or <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>loc obj x›</span></span></span></span> (without the syntactic sugar), 
array length {\tt a.length} with <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"arr_len <span class="free"><span class="free">a</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>,
array indexing {\tt a[i]} with <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">a</span></span><span class="main"><span class="main">.[</span></span><span class="free"><span class="free">i</span></span><span class="main"><span class="main">]</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> or <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>arr_loc a i›</span></span></span></span>. 
The accessing of a static field 
{\tt C.f} can be expressed by the location itself <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>staticLoc C'f›</span></span></span></span>.
Of course one can build more infrastructure to make access to instance fields
and static fields more uniform. We could for example define a 
function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>static›</span></span></span></span> which indicates whether a field is static or not and
based on that create an <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"objLoc"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> location or a <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"staticLoc"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> location. But 
this will only complicate the actual proofs and we can already easily 
perform the distinction whether a field is static or not in the \jive-frontend and 
therefore keep the verification simpler.
›</span></span> 

<span class="keyword1" id="Location-ref_loc"><span class="command">lemma</span></span> ref_loc <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>isObjV <span class="free">r</span><span class="main">;</span> typeof <span class="free">r</span> <span class="main">≤</span> dtype <span class="free">f</span><span class="main">⟧</span> <span class="main">⟹</span> ref <span class="main">(</span><span class="free">r</span><span class="main">..</span><span class="free">f</span><span class="main">)</span> <span class="main">=</span> <span class="free">r</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="free">r</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">f</span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Location-obj_arr_loc"><span class="command">lemma</span></span> obj_arr_loc <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"isArrV <span class="free">r</span> <span class="main">⟹</span> ref <span class="main">(</span><span class="free">r</span><span class="main">.[</span><span class="free">i</span><span class="main">]</span><span class="main">)</span> <span class="main">=</span> <span class="free">r</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">r</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Location-obj_arr_len"><span class="command">lemma</span></span> obj_arr_len <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"isArrV <span class="free">r</span> <span class="main">⟹</span> ref <span class="main">(</span>arr_len <span class="free">r</span><span class="main">)</span> <span class="main">=</span> <span class="free">r</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">r</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Store">
<div class="head">
<h1>Theory Store</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Jive Data and Store Model
    Author:      Norbert Schirmer &lt;schirmer at informatik.tu-muenchen.de&gt;, 2003
    Maintainer:  Nicole Rauch &lt;rauch at informatik.uni-kl.de&gt;
    License:     LGPL
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Store›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Store
<span class="keyword2"><span class="keyword">imports</span></span> <a href="#Location">Location</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹New›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The store provides a uniform interface to allocate new objects and
new arrays. The constructors of this datatype distinguish both cases.
›</span></span>
<span class="keyword1"><span class="command">datatype</span></span> New <span class="main">=</span> new_instance <span class="quoted">CTypeId</span>    <span class="comment1">― ‹New object, can only be of a concrete class type›</span> 
             <span class="main">|</span> new_array <span class="quoted">Arraytype</span> <span class="quoted">nat</span> <span class="comment1">― ‹New array with given size›</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The discriminator <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>isNewArr›</span></span></span></span> can be used to distinguish both 
kinds of newly created elements.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">isNewArr</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"New <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">isNewArr</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="keyword1">of</span> 
                 new_instance <span class="bound">C</span> <span class="main">⇒</span> False     
               <span class="main">|</span> new_array <span class="bound">T</span> <span class="bound">l</span> <span class="main">⇒</span> True<span class="main">)</span>"</span></span>   

<span class="keyword1" id="Store-isNewArr_simps"><span class="command">lemma</span></span> isNewArr_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
<span class="quoted"><span class="quoted">"isNewArr <span class="main">(</span>new_instance <span class="free">C</span><span class="main">)</span> <span class="main">=</span> False"</span></span>
<span class="quoted"><span class="quoted">"isNewArr <span class="main">(</span>new_array <span class="free">T</span> <span class="free">l</span><span class="main">)</span>  <span class="main">=</span> True"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> isNewArr_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>typeofNew›</span></span></span></span> yields the type of the newly created
element.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">typeofNew</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"New <span class="main">⇒</span> Javatype"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">typeofNew</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">of</span>
                  new_instance <span class="bound">C</span> <span class="main">⇒</span> CClassT <span class="bound">C</span>
                <span class="main">|</span> new_array <span class="bound">T</span> <span class="bound">l</span>  <span class="main">⇒</span> ArrT <span class="bound">T</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Store-typeofNew_simps"><span class="command">lemma</span></span> typeofNew_simps<span class="main">:</span>
<span class="quoted"><span class="quoted">"typeofNew <span class="main">(</span>new_instance <span class="free">C</span><span class="main">)</span> <span class="main">=</span> CClassT <span class="free">C</span>"</span></span>
<span class="quoted"><span class="quoted">"typeofNew <span class="main">(</span>new_array <span class="free">T</span> <span class="free">l</span><span class="main">)</span>  <span class="main">=</span> ArrT <span class="free">T</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> typeofNew_def<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹The Definition of the Store›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In our store model, all objects\footnote{In the following, the term ``objects'' 
includes arrays. This keeps the explanations compact.}
of all classes exist at all times, but only those objects that have already been allocated
are alive. Objects cannot be deallocated, thus an object that once gained
the aliveness status cannot lose it later on.
\\[12pt]
 To model the store, we need two functions that give us fresh object Id's for 
the allocation of new objects (function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>newOID›</span></span></span></span>) and arrays
(function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>newAID›</span></span></span></span>) as well as a function that maps locations to
their contents (function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>vals›</span></span></span></span>).›</span></span>

<span class="keyword1"><span class="command">record</span></span> StoreImpl <span class="main">=</span> newOID <span class="main">::</span> <span class="quoted"><span class="quoted">"CTypeId <span class="main">⇒</span> ObjectId"</span></span>
                   newAID <span class="main">::</span> <span class="quoted"><span class="quoted">"Arraytype <span class="main">⇒</span> ObjectId"</span></span>
                   vals   <span class="main">::</span> <span class="quoted"><span class="quoted">"Location <span class="main">⇒</span> Value"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>aliveImpl›</span></span></span></span> determines for a given value whether
it is alive in a given store.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">aliveImpl</span><span class="main">::</span><span class="quoted"><span class="quoted">"Value <span class="main">⇒</span> StoreImpl <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">aliveImpl</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">of</span>
                    boolV <span class="bound">b</span>  <span class="main">⇒</span> True
                  <span class="main">|</span> intgV <span class="bound">i</span>  <span class="main">⇒</span> True
                  <span class="main">|</span> shortV <span class="bound">s</span>  <span class="main">⇒</span> True
                  <span class="main">|</span> byteV <span class="bound">by</span>  <span class="main">⇒</span> True
                  <span class="main">|</span> objV <span class="bound">C</span> <span class="bound">a</span> <span class="main">⇒</span> <span class="main">(</span><span class="bound">a</span> <span class="main">&lt;</span> newOID <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="bound">C</span><span class="main">)</span>
                  <span class="main">|</span> arrV <span class="bound">T</span> <span class="bound">a</span> <span class="main">⇒</span> <span class="main">(</span><span class="bound">a</span> <span class="main">&lt;</span> newAID <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="bound">T</span><span class="main">)</span>
                  <span class="main">|</span> nullV    <span class="main">⇒</span> True<span class="main">)</span>"</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The store itself is defined as new type. The store ensures
and maintains the following 
properties: All stored values are alive; for all locations whose values are
not alive, the store yields the location type's init value; and
all stored values are of the correct type (i.e.~of the type of the location
they are stored in).
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">Store</span> <span class="main">=</span> <span class="main">{</span><span class="bound">s</span><span class="main">.</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">l</span><span class="main">.</span> aliveImpl <span class="main">(</span>vals <span class="bound">s</span> <span class="bound">l</span><span class="main">)</span> <span class="bound">s</span><span class="main">)</span> <span class="main">∧</span> 
                  <span class="main">(</span><span class="main">∀</span> <span class="bound">l</span><span class="main">.</span> <span class="main">¬</span> aliveImpl <span class="main">(</span>ref <span class="bound">l</span><span class="main">)</span> <span class="bound">s</span> <span class="main">⟶</span> vals <span class="bound">s</span> <span class="bound">l</span> <span class="main">=</span> init <span class="main">(</span>ltype <span class="bound">l</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
                  <span class="main">(</span><span class="main">∀</span> <span class="bound">l</span><span class="main">.</span> typeof <span class="main">(</span>vals <span class="bound">s</span> <span class="bound">l</span><span class="main">)</span> <span class="main">≤</span> ltype <span class="bound">l</span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">typedef</span></span> Store <span class="main">=</span> <span class="quoted">Store</span>
  <span class="keyword1"><span class="command">unfolding</span></span> Store_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> exI <span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="var">?x</span><span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">⦇</span></span> newOID <span class="main"><span class="main">=</span></span> <span class="main"><span class="main">(</span></span><span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">C</span></span><span class="main"><span class="main">.</span></span> <span class="main"><span class="main">0</span></span><span class="main"><span class="main">)</span></span><span class="main"><span class="main">,</span></span>
                          newAID <span class="main"><span class="main">=</span></span> <span class="main"><span class="main">(</span></span><span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">T</span></span><span class="main"><span class="main">.</span></span> <span class="main"><span class="main">0</span></span><span class="main"><span class="main">)</span></span><span class="main"><span class="main">,</span></span>
                          vals <span class="main"><span class="main">=</span></span> <span class="main"><span class="main">(</span></span><span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">l</span></span><span class="main"><span class="main">.</span></span> init <span class="main"><span class="main">(</span></span>ltype <span class="bound"><span class="bound">l</span></span><span class="main"><span class="main">)</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">⦈</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> aliveImpl_def init_def NullT_leaf_array <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> Javatype.splits<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹One might also model the Store as axiomatic type class and prove that the type StoreImpl belongs
to this type class. This way, a clearer separation between the axiomatic description of the store and its
properties on the one hand and the realization that has been chosen in this formalization on the other hand
could be achieved. Additionally, it would be easier to make use of  different store implementations that
might have different additional features. This separation remains to be performed as future work.
›</span></span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹The Store Interface›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The Store interface consists of five functions:
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>access›</span></span></span></span> to read the value that is stored at a location;
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>alive›</span></span></span></span> to test whether a value is alive in the store;
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>alloc›</span></span></span></span> to allocate a new element in the store;
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>new›</span></span></span></span> to read the value of a newly allocated element;
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>update›</span></span></span></span> to change the value that is stored at a location.
›</span></span>

<span class="keyword1"><span class="command">consts</span></span> access<span class="main">::</span> <span class="quoted"><span class="quoted">"Store <span class="main">⇒</span> Location <span class="main">⇒</span> Value"</span></span>  <span class="main">(</span><span class="quoted">"_<span class="keyword1">@@</span>_"</span> <span class="main">[</span>71<span class="main">,</span>71<span class="main">]</span> 70<span class="main">)</span>     
       alive<span class="main">::</span> <span class="quoted"><span class="quoted">"Value <span class="main">⇒</span> Store <span class="main">⇒</span> bool"</span></span>
       alloc<span class="main">::</span> <span class="quoted"><span class="quoted">"Store <span class="main">⇒</span> New <span class="main">⇒</span> Store"</span></span> 
       new<span class="main">::</span> <span class="quoted"><span class="quoted">"Store <span class="main">⇒</span> New <span class="main">⇒</span> Value"</span></span>
       update<span class="main">::</span> <span class="quoted"><span class="quoted">"Store <span class="main">⇒</span> Location <span class="main">⇒</span> Value <span class="main">⇒</span> Store"</span></span>
       
<span class="keyword1"><span class="command">nonterminal</span></span> smodifybinds <span class="keyword2"><span class="keyword">and</span></span> smodifybind
<span class="keyword1"><span class="command">syntax</span></span>
  <span class="quoted">"_smodifybind"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">]</span>     <span class="main">⇒</span> smodifybind"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword3">(2</span>_ <span class="keyword1">:=</span><span class="keyword3">/ </span>_<span class="keyword3">)</span>"</span><span class="main">)</span>
  <span class="quoted">""</span>         <span class="main">::</span> <span class="quoted"><span class="quoted">"smodifybind <span class="main">⇒</span> smodifybinds"</span></span>     <span class="main">(</span><span class="quoted">"_"</span><span class="main">)</span>
  <span class="quoted">""</span>         <span class="main">::</span> <span class="quoted"><span class="quoted">"CTypeId <span class="main">⇒</span> smodifybind"</span></span>          <span class="main">(</span><span class="quoted">"_"</span><span class="main">)</span>
  <span class="quoted">"_smodifybinds"</span><span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[</span>smodifybind<span class="main">,</span> smodifybinds<span class="main">]</span> <span class="main">=&gt;</span> smodifybinds"</span></span> <span class="main">(</span><span class="quoted">"_<span class="keyword1">,</span><span class="keyword3">/ </span>_"</span><span class="main">)</span>
  <span class="quoted">"_sModify"</span>  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="tfree">'a</span><span class="main">,</span> smodifybinds<span class="main">]</span> <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span>       <span class="main">(</span><span class="quoted">"_<span class="keyword3">/</span><span class="keyword1">⟨</span><span class="keyword3">(</span>_<span class="keyword3">)</span><span class="keyword1">⟩</span>"</span> <span class="main">[</span>900<span class="main">,</span>0<span class="main">]</span> 900<span class="main">)</span>
<span class="keyword1"><span class="command">translations</span></span>
  <span class="quoted">"_sModify <span class="free">s</span> <span class="main">(</span>_smodifybinds <span class="free">b</span> <span class="free">bs</span><span class="main">)</span>"</span>  <span class="main">==</span> <span class="quoted">"_sModify <span class="main">(</span>_sModify <span class="free">s</span> <span class="free">b</span><span class="main">)</span> <span class="free">bs</span>"</span>
  <span class="quoted">"<span class="free">s</span><span class="main">⟨</span><span class="free">x</span><span class="main">:=</span><span class="free">y</span><span class="main">⟩</span>"</span>                          <span class="main">==</span> <span class="quoted">"<span class="keyword1">CONST</span> update <span class="free">s</span> <span class="free">x</span> <span class="free">y</span>"</span>
  <span class="quoted">"<span class="free">s</span><span class="main">⟨</span><span class="free">c</span><span class="main">⟩</span>"</span>                             <span class="main">==</span> <span class="quoted">"<span class="keyword1">CONST</span> alloc <span class="free">s</span> <span class="free">c</span>"</span> 
 

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹With this syntactic setup we can write chains of (array) updates and 
allocations like in the
following term  
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">s</span></span><span class="main"><span class="main">⟨</span></span>new_instance <span class="free"><span class="free">Node</span></span><span class="main"><span class="main">,</span></span><span class="free"><span class="free">x</span></span><span class="main"><span class="main">:=</span></span><span class="free"><span class="free">y</span></span><span class="main"><span class="main">,</span></span><span class="free"><span class="free">z</span></span><span class="main"><span class="main">:=</span></span>intgV <span class="numeral"><span class="numeral">3</span></span><span class="main"><span class="main">,</span></span>new_array IntgAT <span class="numeral"><span class="numeral">3</span></span><span class="main"><span class="main">,</span></span><span class="free"><span class="free">a</span></span><span class="main"><span class="main">.[</span></span><span class="free"><span class="free">i</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="main">:=</span></span>intgV <span class="numeral"><span class="numeral">4</span></span><span class="main"><span class="main">,</span></span><span class="free"><span class="free">k</span></span><span class="main"><span class="main">:=</span></span>boolV True<span class="main"><span class="main">⟩</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>. 
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In the following, the definitions of the five store interface functions and some lemmas 
about them are given.›</span></span>

<span class="keyword1"><span class="command">overloading</span></span> alive <span class="main">≡</span> <span class="quoted">alive</span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">alive</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">alive</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> aliveImpl <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span>Rep_Store <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Store-alive_trivial_simps"><span class="command">lemma</span></span> alive_trivial_simps <span class="main">[</span><span class="operator">simp</span><span class="main">,</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
<span class="quoted"><span class="quoted">"alive <span class="main">(</span>boolV <span class="free">b</span><span class="main">)</span> <span class="free">s</span>"</span></span>
<span class="quoted"><span class="quoted">"alive <span class="main">(</span>intgV <span class="free">i</span><span class="main">)</span> <span class="free">s</span>"</span></span>
<span class="quoted"><span class="quoted">"alive <span class="main">(</span>shortV <span class="free">sh</span><span class="main">)</span> <span class="free">s</span>"</span></span>
<span class="quoted"><span class="quoted">"alive <span class="main">(</span>byteV <span class="free">by</span><span class="main">)</span> <span class="free">s</span>"</span></span>
<span class="quoted"><span class="quoted">"alive nullV     <span class="free">s</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alive_def aliveImpl_def<span class="main">)</span>

<span class="keyword1"><span class="command">overloading</span></span>
  access <span class="main">≡</span> <span class="quoted">access</span>
  update <span class="main">≡</span> <span class="quoted">update</span>
  alloc <span class="main">≡</span> <span class="quoted">alloc</span>
  new <span class="main">≡</span> <span class="quoted">new</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">access</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">access</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">≡</span> vals <span class="main">(</span>Rep_Store <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">update</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">update</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≡</span>
    <span class="keyword1">if</span> alive <span class="main">(</span>ref <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">∧</span> alive <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">∧</span> typeof <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≤</span> ltype <span class="free"><span class="bound"><span class="entity">l</span></span></span> 
    <span class="keyword1">then</span> Abs_Store <span class="main">(</span><span class="main">(</span>Rep_Store <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">⦇</span>vals<span class="main">:=</span><span class="main">(</span>vals <span class="main">(</span>Rep_Store <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">:=</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span>
    <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">alloc</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">alloc</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">≡</span>
    <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="keyword1">of</span> 
       new_instance <span class="bound">C</span> 
        <span class="main">⇒</span> Abs_Store 
            <span class="main">(</span><span class="main">(</span>Rep_Store <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">⦇</span>newOID <span class="main">:=</span> <span class="main">λ</span> <span class="bound">D</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">C</span><span class="main">=</span><span class="bound">D</span> 
                              <span class="keyword1">then</span> Suc <span class="main">(</span>newOID <span class="main">(</span>Rep_Store <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="bound">C</span><span class="main">)</span> 
                              <span class="keyword1">else</span> newOID <span class="main">(</span>Rep_Store <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="bound">D</span><span class="main">⦈</span><span class="main">)</span>
     <span class="main">|</span> new_array <span class="bound">T</span> <span class="bound">l</span>
        <span class="main">⇒</span> Abs_Store
            <span class="main">(</span><span class="main">(</span>Rep_Store <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">⦇</span>newAID <span class="main">:=</span> <span class="main">λ</span> <span class="bound">S</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">T</span><span class="main">=</span><span class="bound">S</span> 
                             <span class="keyword1">then</span> Suc <span class="main">(</span>newAID <span class="main">(</span>Rep_Store <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="bound">T</span><span class="main">)</span>
                             <span class="keyword1">else</span> newAID <span class="main">(</span>Rep_Store <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="bound">S</span><span class="main">,</span>
                           vals <span class="main">:=</span>  <span class="main">(</span>vals <span class="main">(</span>Rep_Store <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span><span class="main">)</span>
                                      <span class="main">(</span>arrLenLoc <span class="bound">T</span> <span class="main">(</span>newAID <span class="main">(</span>Rep_Store <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="bound">T</span><span class="main">)</span> 
                                        <span class="main">:=</span> intgV <span class="main">(</span>int <span class="bound">l</span><span class="main">)</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">new</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">new</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">≡</span>
    <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="keyword1">of</span>
      new_instance <span class="bound">C</span> <span class="main">⇒</span> objV <span class="bound">C</span> <span class="main">(</span>newOID <span class="main">(</span>Rep_Store <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="bound">C</span><span class="main">)</span>
    <span class="main">|</span> new_array <span class="bound">T</span> <span class="bound">l</span>  <span class="main">⇒</span> arrV <span class="bound">T</span> <span class="main">(</span>newAID <span class="main">(</span>Rep_Store <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="bound">T</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The predicate <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>wts›</span></span></span></span> tests whether the store is well-typed.›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
<span class="entity">wts</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Store <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">wts</span> <span class="free"><span class="bound"><span class="entity">OS</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span> <span class="main">(</span><span class="bound">l</span><span class="main">::</span>Location<span class="main">)</span> <span class="main">.</span> <span class="main">(</span>typeof <span class="main">(</span><span class="free"><span class="bound"><span class="entity">OS</span></span></span><span class="main">@@</span><span class="bound">l</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span> <span class="main">(</span>ltype <span class="bound">l</span><span class="main">)</span><span class="main">)</span>"</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Derived Properties of the Store›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In this subsection, a number of lemmas formalize various properties of the Store.
Especially the 13 axioms are proven that must hold for a modelling of a Store 
(see \cite[p. 45]{Poetzsch-Heffter97specification}). They are labeled with
Store1 to Store13.›</span></span>

<span class="keyword1" id="Store-alive_init"><span class="command">lemma</span></span> alive_init <span class="main">[</span><span class="operator">simp</span><span class="main">,</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"alive <span class="main">(</span>init <span class="free">T</span><span class="main">)</span> <span class="free">s</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">T</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alive_def aliveImpl_def<span class="main">)</span> 

<span class="keyword1" id="Store-alive_loc"><span class="command">lemma</span></span> alive_loc <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>isObjV <span class="free">x</span><span class="main">;</span> typeof <span class="free">x</span> <span class="main">≤</span> dtype <span class="free">f</span><span class="main">⟧</span> <span class="main">⟹</span> alive <span class="main">(</span>ref <span class="main">(</span><span class="free">x</span><span class="main">..</span><span class="free">f</span><span class="main">)</span><span class="main">)</span> <span class="free">s</span> <span class="main">=</span> alive <span class="free">x</span> <span class="free">s</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1" id="Store-alive_arr_loc"><span class="command">lemma</span></span> alive_arr_loc <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"isArrV <span class="free">x</span> <span class="main">⟹</span> alive <span class="main">(</span>ref <span class="main">(</span><span class="free">x</span><span class="main">.[</span><span class="free">i</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="free">s</span> <span class="main">=</span> alive <span class="free">x</span> <span class="free">s</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1" id="Store-alive_arr_len"><span class="command">lemma</span></span> alive_arr_len <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"isArrV <span class="free">x</span> <span class="main">⟹</span> alive <span class="main">(</span>ref <span class="main">(</span>arr_len <span class="free">x</span><span class="main">)</span><span class="main">)</span> <span class="free">s</span> <span class="main">=</span> alive <span class="free">x</span> <span class="free">s</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1" id="Store-ref_arr_len_new"><span class="command">lemma</span></span> ref_arr_len_new <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"ref <span class="main">(</span>arr_len <span class="main">(</span>new <span class="free">s</span> <span class="main">(</span>new_array <span class="free">T</span> <span class="free">n</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> new <span class="free">s</span> <span class="main">(</span>new_array <span class="free">T</span> <span class="free">n</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> new_def<span class="main">)</span>

<span class="keyword1" id="Store-ref_arr_loc_new"><span class="command">lemma</span></span> ref_arr_loc_new <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"ref <span class="main">(</span><span class="main">(</span>new <span class="free">s</span> <span class="main">(</span>new_array <span class="free">T</span> <span class="free">n</span><span class="main">)</span><span class="main">)</span><span class="main">.[</span><span class="free">i</span><span class="main">]</span><span class="main">)</span> <span class="main">=</span> new <span class="free">s</span> <span class="main">(</span>new_array <span class="free">T</span> <span class="free">n</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> new_def<span class="main">)</span>

<span class="keyword1" id="Store-ref_loc_new"><span class="command">lemma</span></span> ref_loc_new <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"CClassT <span class="free">C</span> <span class="main">≤</span> dtype <span class="free">f</span> 
  <span class="main">⟹</span> ref <span class="main">(</span><span class="main">(</span>new <span class="free">s</span> <span class="main">(</span>new_instance <span class="free">C</span><span class="main">)</span><span class="main">)</span><span class="main">..</span><span class="free">f</span><span class="main">)</span> <span class="main">=</span> new <span class="free">s</span> <span class="main">(</span>new_instance <span class="free">C</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> new_def<span class="main">)</span>

<span class="keyword1" id="Store-access_type_safe"><span class="command">lemma</span></span> access_type_safe <span class="main">[</span><span class="operator">simp</span><span class="main">,</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"typeof <span class="main">(</span><span class="free">s</span><span class="main">@@</span><span class="free">l</span><span class="main">)</span> <span class="main">≤</span> ltype <span class="free">l</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Rep_Store <span class="free">s</span> <span class="main">∈</span> Store"</span></span>    
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> Rep_Store<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> access_def Store_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The store is well-typed by construction.›</span></span>
<span class="keyword1" id="Store-always_welltyped_store"><span class="command">lemma</span></span> always_welltyped_store<span class="main">:</span> <span class="quoted"><span class="quoted">"wts <span class="free">OS</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> wts_def access_type_safe<span class="main">)</span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Store8›</span></span>
<span class="keyword1" id="Store-alive_access"><span class="command">lemma</span></span> alive_access <span class="main">[</span><span class="operator">simp</span><span class="main">,</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"alive <span class="main">(</span><span class="free">s</span><span class="main">@@</span><span class="free">l</span><span class="main">)</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Rep_Store <span class="free">s</span> <span class="main">∈</span> Store"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> Rep_Store<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> access_def Store_def alive_def aliveImpl_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Store3›</span></span>
<span class="keyword1" id="Store-access_unalive"><span class="command">lemma</span></span> access_unalive <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> unalive<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> alive <span class="main">(</span>ref <span class="free">l</span><span class="main">)</span> <span class="free">s</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">@@</span><span class="free">l</span> <span class="main">=</span> init <span class="main">(</span>ltype <span class="free">l</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Rep_Store <span class="free">s</span> <span class="main">∈</span> Store"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> Rep_Store<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> unalive <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> access_def Store_def alive_def aliveImpl_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1" id="Store-update_induct"><span class="command">lemma</span></span> update_induct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> skip<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> update<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>alive <span class="main">(</span>ref <span class="free">l</span><span class="main">)</span> <span class="free">s</span><span class="main">;</span> alive <span class="free">v</span> <span class="free">s</span><span class="main">;</span> typeof <span class="free">v</span> <span class="main">≤</span> ltype <span class="free">l</span><span class="main">⟧</span> <span class="main">⟹</span>
               <span class="free">P</span> <span class="main">(</span>Abs_Store <span class="main">(</span><span class="main">(</span>Rep_Store <span class="free">s</span><span class="main">)</span><span class="main">⦇</span>vals<span class="main">:=</span><span class="main">(</span>vals <span class="main">(</span>Rep_Store <span class="free">s</span><span class="main">)</span><span class="main">)</span><span class="main">(</span><span class="free">l</span><span class="main">:=</span><span class="free">v</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">(</span><span class="free">s</span><span class="main">⟨</span><span class="free">l</span><span class="main">:=</span><span class="free">v</span><span class="main">⟩</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> update skip 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> update_def<span class="main">)</span>

<span class="keyword1" id="Store-vals_update_in_Store"><span class="command">lemma</span></span> vals_update_in_Store<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> alive_l<span class="main">:</span> <span class="quoted"><span class="quoted">"alive <span class="main">(</span>ref <span class="free">l</span><span class="main">)</span> <span class="free">s</span>"</span></span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> alive_y<span class="main">:</span> <span class="quoted"><span class="quoted">"alive <span class="free">y</span> <span class="free">s</span>"</span></span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> type_conform<span class="main">:</span> <span class="quoted"><span class="quoted">"typeof <span class="free">y</span> <span class="main">≤</span> ltype <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Rep_Store <span class="free">s</span><span class="main">⦇</span>vals <span class="main">:=</span> <span class="main">(</span>vals <span class="main">(</span>Rep_Store <span class="free">s</span><span class="main">)</span><span class="main">)</span><span class="main">(</span><span class="free">l</span> <span class="main">:=</span> <span class="free">y</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span> <span class="main">∈</span> Store"</span></span> 
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?s_upd</span> <span class="main">∈</span> Store"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> s<span class="main">:</span> <span class="quoted"><span class="quoted">"Rep_Store <span class="free">s</span> <span class="main">∈</span> Store"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> Rep_Store<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> alloc_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"newOID <span class="var">?s_upd</span> <span class="main">=</span> newOID <span class="main">(</span>Rep_Store <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">l</span><span class="main">.</span> aliveImpl <span class="main">(</span>vals <span class="var">?s_upd</span> <span class="bound">l</span><span class="main">)</span> <span class="var">?s_upd</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> 
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">k</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"aliveImpl <span class="main">(</span>vals <span class="var">?s_upd</span> <span class="skolem">k</span><span class="main">)</span> <span class="var">?s_upd</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span><span class="main">=</span><span class="free">l</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True
      <span class="keyword1"><span class="command">with</span></span> alive_y <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alloc_eq alive_def aliveImpl_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> Value.splits<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> False
      <span class="keyword1"><span class="command">from</span></span> s <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">l</span><span class="main">.</span> aliveImpl <span class="main">(</span>vals <span class="main">(</span>Rep_Store <span class="free">s</span><span class="main">)</span> <span class="bound">l</span><span class="main">)</span> <span class="main">(</span>Rep_Store <span class="free">s</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Store_def<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> False <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> aliveImpl_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> Value.splits<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">l</span><span class="main">.</span> <span class="main">¬</span> aliveImpl <span class="main">(</span>ref <span class="bound">l</span><span class="main">)</span> <span class="var">?s_upd</span> <span class="main">⟶</span> vals <span class="var">?s_upd</span> <span class="bound">l</span> <span class="main">=</span> init <span class="main">(</span>ltype <span class="bound">l</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> allI impI<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">k</span>
    <span class="keyword3"><span class="command">assume</span></span> unalive<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> aliveImpl <span class="main">(</span>ref <span class="skolem">k</span><span class="main">)</span> <span class="var">?s_upd</span>"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"vals <span class="var">?s_upd</span> <span class="skolem">k</span> <span class="main">=</span> init <span class="main">(</span>ltype <span class="skolem">k</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command">from</span></span> unalive alive_l
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span><span class="main">≠</span><span class="free">l</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alive_def aliveImpl_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> Value.splits<span class="main">)</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"vals <span class="var">?s_upd</span> <span class="skolem">k</span> <span class="main">=</span> vals <span class="main">(</span>Rep_Store <span class="free">s</span><span class="main">)</span> <span class="skolem">k</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> unalive 
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> aliveImpl <span class="main">(</span>ref <span class="skolem">k</span><span class="main">)</span> <span class="main">(</span>Rep_Store <span class="free">s</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> aliveImpl_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> Value.splits<span class="main">)</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">using</span></span> s <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Store_def<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">l</span><span class="main">.</span> typeof <span class="main">(</span>vals <span class="var">?s_upd</span> <span class="bound">l</span><span class="main">)</span> <span class="main">≤</span> ltype <span class="bound">l</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">k</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"typeof <span class="main">(</span>vals <span class="var">?s_upd</span> <span class="skolem">k</span><span class="main">)</span> <span class="main">≤</span> ltype <span class="skolem">k</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span><span class="main">=</span><span class="free">l</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True
      <span class="keyword1"><span class="command">with</span></span> type_conform <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> False
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"vals <span class="var">?s_upd</span> <span class="skolem">k</span> <span class="main">=</span> vals <span class="main">(</span>Rep_Store <span class="free">s</span><span class="main">)</span> <span class="skolem">k</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">with</span></span> s <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Store_def<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Store_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Store6›</span></span>
<span class="keyword1" id="Store-alive_update_invariant"><span class="command">lemma</span></span> alive_update_invariant <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"alive <span class="free">x</span> <span class="main">(</span><span class="free">s</span><span class="main">⟨</span><span class="free">l</span><span class="main">:=</span><span class="free">y</span><span class="main">⟩</span><span class="main">)</span> <span class="main">=</span> alive <span class="free">x</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> update_induct<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"alive <span class="free">x</span> <span class="free">s</span> <span class="main">=</span> alive <span class="free">x</span> <span class="free">s</span>"</span></span><span class="keyword1"><span class="command">..</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"alive <span class="main">(</span>ref <span class="free">l</span><span class="main">)</span> <span class="free">s</span>"</span></span> <span class="quoted"><span class="quoted">"alive <span class="free">y</span> <span class="free">s</span>"</span></span> <span class="quoted"><span class="quoted">"typeof <span class="free">y</span> <span class="main">≤</span> ltype <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"Rep_Store 
          <span class="main">(</span>Abs_Store <span class="main">(</span>Rep_Store <span class="free">s</span><span class="main">⦇</span>vals <span class="main">:=</span> <span class="main">(</span>vals <span class="main">(</span>Rep_Store <span class="free">s</span><span class="main">)</span><span class="main">)</span><span class="main">(</span><span class="free">l</span> <span class="main">:=</span> <span class="free">y</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>
         <span class="main">=</span> Rep_Store <span class="free">s</span><span class="main">⦇</span>vals <span class="main">:=</span> <span class="main">(</span>vals <span class="main">(</span>Rep_Store <span class="free">s</span><span class="main">)</span><span class="main">)</span><span class="main">(</span><span class="free">l</span> <span class="main">:=</span> <span class="free">y</span><span class="main">)</span><span class="main">⦈</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> vals_update_in_Store <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> Abs_Store_inverse<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"alive <span class="free">x</span>
         <span class="main">(</span>Abs_Store <span class="main">(</span>Rep_Store <span class="free">s</span><span class="main">⦇</span>vals <span class="main">:=</span> <span class="main">(</span>vals <span class="main">(</span>Rep_Store <span class="free">s</span><span class="main">)</span><span class="main">)</span><span class="main">(</span><span class="free">l</span> <span class="main">:=</span> <span class="free">y</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
        alive <span class="free">x</span> <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alive_def aliveImpl_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> Value.split<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Store1›</span></span>
<span class="keyword1" id="Store-access_update_other"><span class="command">lemma</span></span> access_update_other <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> neq_l_m<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">l</span> <span class="main">≠</span> <span class="free">m</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⟨</span><span class="free">l</span><span class="main">:=</span><span class="free">x</span><span class="main">⟩</span><span class="main">@@</span><span class="free">m</span> <span class="main">=</span> <span class="free">s</span><span class="main">@@</span><span class="free">m</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> update_induct<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">@@</span><span class="free">m</span> <span class="main">=</span> <span class="free">s</span><span class="main">@@</span><span class="free">m</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"alive <span class="main">(</span>ref <span class="free">l</span><span class="main">)</span> <span class="free">s</span>"</span></span> <span class="quoted"><span class="quoted">"alive <span class="free">x</span> <span class="free">s</span>"</span></span> <span class="quoted"><span class="quoted">"typeof <span class="free">x</span> <span class="main">≤</span> ltype <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"Rep_Store 
          <span class="main">(</span>Abs_Store <span class="main">(</span>Rep_Store <span class="free">s</span><span class="main">⦇</span>vals <span class="main">:=</span> <span class="main">(</span>vals <span class="main">(</span>Rep_Store <span class="free">s</span><span class="main">)</span><span class="main">)</span><span class="main">(</span><span class="free">l</span> <span class="main">:=</span> <span class="free">x</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>
         <span class="main">=</span> Rep_Store <span class="free">s</span><span class="main">⦇</span>vals <span class="main">:=</span> <span class="main">(</span>vals <span class="main">(</span>Rep_Store <span class="free">s</span><span class="main">)</span><span class="main">)</span><span class="main">(</span><span class="free">l</span> <span class="main">:=</span> <span class="free">x</span><span class="main">)</span><span class="main">⦈</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> vals_update_in_Store <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> Abs_Store_inverse<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> neq_l_m 
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Abs_Store <span class="main">(</span>Rep_Store <span class="free">s</span><span class="main">⦇</span>vals <span class="main">:=</span> <span class="main">(</span>vals <span class="main">(</span>Rep_Store <span class="free">s</span><span class="main">)</span><span class="main">)</span><span class="main">(</span><span class="free">l</span> <span class="main">:=</span> <span class="free">x</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">@@</span><span class="free">m</span> <span class="main">=</span> <span class="free">s</span><span class="main">@@</span><span class="free">m</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> access_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Store2›</span></span>
<span class="keyword1" id="Store-update_access_same"><span class="command">lemma</span></span> update_access_same <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> alive_l<span class="main">:</span> <span class="quoted"><span class="quoted">"alive <span class="main">(</span>ref <span class="free">l</span><span class="main">)</span> <span class="free">s</span>"</span></span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> alive_x<span class="main">:</span> <span class="quoted"><span class="quoted">"alive <span class="free">x</span> <span class="free">s</span>"</span></span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> widen_x_l<span class="main">:</span> <span class="quoted"><span class="quoted">"typeof <span class="free">x</span> <span class="main">≤</span> ltype <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⟨</span><span class="free">l</span><span class="main">:=</span><span class="free">x</span><span class="main">⟩</span><span class="main">@@</span><span class="free">l</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> alive_l alive_x widen_x_l
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Rep_Store 
          <span class="main">(</span>Abs_Store <span class="main">(</span>Rep_Store <span class="free">s</span><span class="main">⦇</span>vals <span class="main">:=</span> <span class="main">(</span>vals <span class="main">(</span>Rep_Store <span class="free">s</span><span class="main">)</span><span class="main">)</span><span class="main">(</span><span class="free">l</span> <span class="main">:=</span> <span class="free">x</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">)</span>
         <span class="main">=</span> Rep_Store <span class="free">s</span><span class="main">⦇</span>vals <span class="main">:=</span> <span class="main">(</span>vals <span class="main">(</span>Rep_Store <span class="free">s</span><span class="main">)</span><span class="main">)</span><span class="main">(</span><span class="free">l</span> <span class="main">:=</span> <span class="free">x</span><span class="main">)</span><span class="main">⦈</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> vals_update_in_Store <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> Abs_Store_inverse<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"Abs_Store <span class="main">(</span>Rep_Store <span class="free">s</span><span class="main">⦇</span>vals <span class="main">:=</span> <span class="main">(</span>vals <span class="main">(</span>Rep_Store <span class="free">s</span><span class="main">)</span><span class="main">)</span><span class="main">(</span><span class="free">l</span> <span class="main">:=</span> <span class="free">x</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span><span class="main">@@</span><span class="free">l</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> access_def<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> alive_l alive_x widen_x_l 
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> update_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Store4›</span></span>
<span class="keyword1" id="Store-update_unalive_val"><span class="command">lemma</span></span> update_unalive_val <span class="main">[</span><span class="operator">simp</span><span class="main">,</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> alive <span class="free">x</span> <span class="free">s</span> <span class="main">⟹</span> <span class="free">s</span><span class="main">⟨</span><span class="free">l</span><span class="main">:=</span><span class="free">x</span><span class="main">⟩</span> <span class="main">=</span> <span class="free">s</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> update_def<span class="main">)</span>

<span class="keyword1" id="Store-update_unalive_loc"><span class="command">lemma</span></span> update_unalive_loc <span class="main">[</span><span class="operator">simp</span><span class="main">,</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> alive <span class="main">(</span>ref <span class="free">l</span><span class="main">)</span> <span class="free">s</span> <span class="main">⟹</span> <span class="free">s</span><span class="main">⟨</span><span class="free">l</span><span class="main">:=</span><span class="free">x</span><span class="main">⟩</span> <span class="main">=</span> <span class="free">s</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> update_def<span class="main">)</span>

<span class="keyword1" id="Store-update_type_mismatch"><span class="command">lemma</span></span> update_type_mismatch <span class="main">[</span><span class="operator">simp</span><span class="main">,</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> typeof <span class="free">x</span> <span class="main">≤</span> ltype <span class="free">l</span> <span class="main">⟹</span> <span class="free">s</span><span class="main">⟨</span><span class="free">l</span><span class="main">:=</span><span class="free">x</span><span class="main">⟩</span> <span class="main">=</span> <span class="free">s</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> update_def<span class="main">)</span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Store9›</span></span>
<span class="keyword1" id="Store-alive_primitive"><span class="command">lemma</span></span> alive_primitive <span class="main">[</span><span class="operator">simp</span><span class="main">,</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"isprimitive <span class="main">(</span>typeof <span class="free">x</span><span class="main">)</span> <span class="main">⟹</span> alive <span class="free">x</span> <span class="free">s</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Store10›</span></span>
<span class="keyword1" id="Store-new_unalive_old_Store"><span class="command">lemma</span></span> new_unalive_old_Store <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> alive <span class="main">(</span>new <span class="free">s</span> <span class="free">t</span><span class="main">)</span> <span class="free">s</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alive_def aliveImpl_def new_def<span class="main">)</span>

<span class="keyword1" id="Store-alloc_new_instance_in_Store"><span class="command">lemma</span></span> alloc_new_instance_in_Store<span class="main">:</span>
<span class="quoted"><span class="quoted">"<span class="main">(</span>Rep_Store <span class="free">s</span><span class="main">⦇</span>newOID <span class="main">:=</span> <span class="main">λ</span><span class="bound">D</span><span class="main">.</span> <span class="keyword1">if</span> <span class="free">C</span> <span class="main">=</span> <span class="bound">D</span>
                                   <span class="keyword1">then</span> Suc <span class="main">(</span>newOID <span class="main">(</span>Rep_Store <span class="free">s</span><span class="main">)</span> <span class="free">C</span><span class="main">)</span>
                                   <span class="keyword1">else</span> newOID <span class="main">(</span>Rep_Store <span class="free">s</span><span class="main">)</span> <span class="bound">D</span><span class="main">⦈</span><span class="main">)</span> <span class="main">∈</span> Store"</span></span>
<span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?s_alloc</span> <span class="main">∈</span> Store"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> s<span class="main">:</span> <span class="quoted"><span class="quoted">"Rep_Store <span class="free">s</span> <span class="main">∈</span> Store"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> Rep_Store<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">l</span><span class="main">.</span> aliveImpl <span class="main">(</span>vals <span class="main">(</span>Rep_Store <span class="free">s</span><span class="main">)</span> <span class="bound">l</span><span class="main">)</span> <span class="main">(</span>Rep_Store <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Store_def<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">l</span><span class="main">.</span> aliveImpl <span class="main">(</span>vals <span class="var">?s_alloc</span> <span class="bound">l</span><span class="main">)</span> <span class="var">?s_alloc</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> less_SucI <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> aliveImpl_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> Value.splits<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">l</span><span class="main">.</span> <span class="main">¬</span> aliveImpl <span class="main">(</span>ref <span class="bound">l</span><span class="main">)</span> <span class="var">?s_alloc</span> <span class="main">⟶</span> vals <span class="var">?s_alloc</span> <span class="bound">l</span> <span class="main">=</span> init <span class="main">(</span>ltype <span class="bound">l</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> allI impI<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">l</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> aliveImpl <span class="main">(</span>ref <span class="skolem">l</span><span class="main">)</span> <span class="var">?s_alloc</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> aliveImpl <span class="main">(</span>ref <span class="skolem">l</span><span class="main">)</span> <span class="main">(</span>Rep_Store <span class="free">s</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> aliveImpl_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> Value.splits if_split_asm<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> s <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"vals <span class="main">(</span>Rep_Store <span class="free">s</span><span class="main">)</span> <span class="skolem">l</span> <span class="main">=</span> init <span class="main">(</span>ltype <span class="skolem">l</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Store_def<span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"vals <span class="var">?s_alloc</span> <span class="skolem">l</span> <span class="main">=</span> init <span class="main">(</span>ltype <span class="skolem">l</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">moreover</span></span> 
  <span class="keyword1"><span class="command">from</span></span> s <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">l</span><span class="main">.</span> typeof <span class="main">(</span>vals <span class="var">?s_alloc</span> <span class="bound">l</span><span class="main">)</span> <span class="main">≤</span> ltype <span class="bound">l</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Store_def<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Store_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Store-alloc_new_array_in_Store"><span class="command">lemma</span></span> alloc_new_array_in_Store<span class="main">:</span>
<span class="quoted"><span class="quoted">"<span class="main">(</span>Rep_Store <span class="free">s</span> <span class="main">⦇</span>newAID <span class="main">:=</span>
                  <span class="main">λ</span><span class="bound">S</span><span class="main">.</span> <span class="keyword1">if</span> <span class="free">T</span> <span class="main">=</span> <span class="bound">S</span>
                      <span class="keyword1">then</span> Suc <span class="main">(</span>newAID <span class="main">(</span>Rep_Store <span class="free">s</span><span class="main">)</span> <span class="free">T</span><span class="main">)</span>
                      <span class="keyword1">else</span> newAID <span class="main">(</span>Rep_Store <span class="free">s</span><span class="main">)</span> <span class="bound">S</span><span class="main">,</span>
               vals <span class="main">:=</span> <span class="main">(</span>vals <span class="main">(</span>Rep_Store <span class="free">s</span><span class="main">)</span><span class="main">)</span>
                         <span class="main">(</span>arrLenLoc <span class="free">T</span>
                           <span class="main">(</span>newAID <span class="main">(</span>Rep_Store <span class="free">s</span><span class="main">)</span> <span class="free">T</span><span class="main">)</span> <span class="main">:=</span>
                           intgV <span class="main">(</span>int <span class="free">n</span><span class="main">)</span><span class="main">)</span><span class="main">⦈</span><span class="main">)</span> <span class="main">∈</span> Store"</span></span>
<span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?s_alloc</span> <span class="main">∈</span> Store"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> s<span class="main">:</span> <span class="quoted"><span class="quoted">"Rep_Store <span class="free">s</span> <span class="main">∈</span> Store"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> Rep_Store<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">l</span><span class="main">.</span> aliveImpl <span class="main">(</span>vals <span class="var">?s_alloc</span> <span class="bound">l</span><span class="main">)</span> <span class="var">?s_alloc</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> 
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">l</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"aliveImpl <span class="main">(</span>vals <span class="var">?s_alloc</span> <span class="skolem">l</span><span class="main">)</span> <span class="var">?s_alloc</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">l</span> <span class="main">=</span> arrLenLoc <span class="free">T</span> <span class="main">(</span>newAID <span class="main">(</span>Rep_Store <span class="free">s</span><span class="main">)</span> <span class="free">T</span><span class="main">)</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> aliveImpl_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> Value.splits<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> False
      <span class="keyword1"><span class="command">from</span></span> s <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">l</span><span class="main">.</span> aliveImpl <span class="main">(</span>vals <span class="main">(</span>Rep_Store <span class="free">s</span><span class="main">)</span> <span class="bound">l</span><span class="main">)</span> <span class="main">(</span>Rep_Store <span class="free">s</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Store_def<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> False <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> less_SucI <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> aliveImpl_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> Value.splits<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">l</span><span class="main">.</span> <span class="main">¬</span> aliveImpl <span class="main">(</span>ref <span class="bound">l</span><span class="main">)</span> <span class="var">?s_alloc</span> <span class="main">⟶</span> vals <span class="var">?s_alloc</span> <span class="bound">l</span> <span class="main">=</span> init <span class="main">(</span>ltype <span class="bound">l</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> allI impI<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">l</span>
    <span class="keyword3"><span class="command">assume</span></span> unalive<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> aliveImpl <span class="main">(</span>ref <span class="skolem">l</span><span class="main">)</span> <span class="var">?s_alloc</span>"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"vals <span class="var">?s_alloc</span> <span class="skolem">l</span> <span class="main">=</span> init <span class="main">(</span>ltype <span class="skolem">l</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">l</span> <span class="main">=</span> arrLenLoc <span class="free">T</span> <span class="main">(</span>newAID <span class="main">(</span>Rep_Store <span class="free">s</span><span class="main">)</span> <span class="free">T</span><span class="main">)</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True
      <span class="keyword1"><span class="command">with</span></span> unalive <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> aliveImpl_def<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> False
      <span class="keyword1"><span class="command">from</span></span> unalive
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> aliveImpl <span class="main">(</span>ref <span class="skolem">l</span><span class="main">)</span> <span class="main">(</span>Rep_Store <span class="free">s</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> aliveImpl_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> Value.splits if_split_asm<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> s <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"vals <span class="main">(</span>Rep_Store <span class="free">s</span><span class="main">)</span> <span class="skolem">l</span> <span class="main">=</span> init <span class="main">(</span>ltype <span class="skolem">l</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Store_def<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> False <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">moreover</span></span> 
  <span class="keyword1"><span class="command">from</span></span> s <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">l</span><span class="main">.</span> typeof <span class="main">(</span>vals <span class="var">?s_alloc</span> <span class="bound">l</span><span class="main">)</span> <span class="main">≤</span> ltype <span class="bound">l</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Store_def<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Store_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1" id="Store-new_alive_alloc"><span class="command">lemma</span></span> new_alive_alloc <span class="main">[</span><span class="operator">simp</span><span class="main">,</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"alive <span class="main">(</span>new <span class="free">s</span> <span class="free">t</span><span class="main">)</span> <span class="main">(</span><span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> new_instance <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alive_def aliveImpl_def new_def alloc_def
                  alloc_new_instance_in_Store <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> Abs_Store_inverse<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> new_array <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alive_def aliveImpl_def new_def alloc_def
                  alloc_new_array_in_Store <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> Abs_Store_inverse<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>
 
<span class="keyword1" id="Store-value_class_inhabitants"><span class="command">lemma</span></span> value_class_inhabitants<span class="main">:</span> 
<span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">.</span> typeof <span class="bound">x</span> <span class="main">=</span> CClassT <span class="free">typeId</span> <span class="main">⟶</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">a</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span>objV <span class="free">typeId</span> <span class="bound">a</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span> <span class="bound">x</span><span class="main">.</span> <span class="var">?A</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="var">?B</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> 
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">x</span><span class="main">.</span> <span class="var">?A</span> <span class="bound">x</span>"</span></span> <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="var">?B</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> B<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?B</span>"</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">x</span><span class="main">.</span> <span class="var">?A</span> <span class="bound">x</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="keyword1"><span class="command">from</span></span> B <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?A</span> <span class="skolem">x</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>
   
<span class="keyword1" id="Store-value_array_inhabitants"><span class="command">lemma</span></span> value_array_inhabitants<span class="main">:</span> 
<span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">.</span> typeof <span class="bound">x</span> <span class="main">=</span> ArrT <span class="free">typeId</span> <span class="main">⟶</span> <span class="free">P</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">a</span><span class="main">.</span> <span class="free">P</span> <span class="main">(</span>arrV <span class="free">typeId</span> <span class="bound">a</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span> <span class="bound">x</span><span class="main">.</span> <span class="var">?A</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="var">?B</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> 
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">x</span><span class="main">.</span> <span class="var">?A</span> <span class="bound">x</span>"</span></span> <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="var">?B</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> B<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?B</span>"</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">x</span><span class="main">.</span> <span class="var">?A</span> <span class="bound">x</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="keyword1"><span class="command">from</span></span> B <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?A</span> <span class="skolem">x</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The following three lemmas are helper lemmas that are not related to the store theory.
They might as well be stored in a separate helper theory.
›</span></span>

<span class="keyword1" id="Store-le_Suc_eq"><span class="command">lemma</span></span> le_Suc_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">a</span><span class="main">.</span> <span class="main">(</span><span class="bound">a</span> <span class="main">&lt;</span> Suc <span class="free">n</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="bound">a</span> <span class="main">&lt;</span> Suc <span class="free">m</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">a</span><span class="main">.</span> <span class="main">(</span><span class="bound">a</span> <span class="main">&lt;</span> <span class="free">n</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="bound">a</span> <span class="main">&lt;</span> <span class="free">m</span><span class="main">)</span><span class="main">)</span>"</span></span>
 <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">a</span><span class="main">.</span> <span class="var">?A</span> <span class="bound">a</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">a</span><span class="main">.</span> <span class="var">?B</span> <span class="bound">a</span><span class="main">)</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">a</span><span class="main">.</span> <span class="var">?A</span> <span class="bound">a</span>"</span></span> <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">a</span><span class="main">.</span> <span class="var">?B</span> <span class="bound">a</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> B<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">a</span><span class="main">.</span> <span class="var">?B</span> <span class="bound">a</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">a</span><span class="main">.</span> <span class="var">?A</span> <span class="bound">a</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> 
    <span class="keyword1"><span class="command">from</span></span> B <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?A</span> <span class="skolem">a</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">a</span></span><span class="main">)</span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Store-all_le_eq_imp_eq"><span class="command">lemma</span></span> all_le_eq_imp_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">c</span><span class="main">::</span>nat<span class="main">.</span> <span class="main">(</span><span class="main">∀</span><span class="bound">a</span><span class="main">.</span> <span class="main">(</span><span class="bound">a</span> <span class="main">&lt;</span> <span class="free">d</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="bound">a</span> <span class="main">&lt;</span> <span class="bound">c</span><span class="main">)</span><span class="main">)</span> <span class="main">⟶</span> <span class="main">(</span><span class="free">d</span> <span class="main">=</span> <span class="bound">c</span><span class="main">)</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">d</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 0 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span> <span class="skolem">c</span><span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">c</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> le_Suc_eq<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>
 
<span class="keyword1" id="Store-all_le_eq"><span class="command">lemma</span></span> all_le_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span> <span class="bound">a</span><span class="main">::</span>nat<span class="main">.</span> <span class="main">(</span><span class="bound">a</span> <span class="main">&lt;</span> <span class="free">d</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="bound">a</span> <span class="main">&lt;</span> <span class="free">c</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">d</span> <span class="main">=</span> <span class="free">c</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> all_le_eq_imp_eq <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Store11›</span></span>
<span class="keyword1" id="Store-typeof_new"><span class="command">lemma</span></span> typeof_new<span class="main">:</span> <span class="quoted"><span class="quoted">"typeof <span class="main">(</span>new <span class="free">s</span> <span class="free">t</span><span class="main">)</span> <span class="main">=</span> typeofNew <span class="free">t</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> new_def typeofNew_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Store12›</span></span>
<span class="keyword1" id="Store-new_eq"><span class="command">lemma</span></span> new_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>new <span class="free">s1</span> <span class="free">t</span> <span class="main">=</span> new <span class="free">s2</span> <span class="free">t</span><span class="main">)</span> <span class="main">=</span> 
                 <span class="main">(</span><span class="main">∀</span> <span class="bound">x</span><span class="main">.</span> typeof <span class="bound">x</span> <span class="main">=</span> typeofNew <span class="free">t</span> <span class="main">⟶</span> alive <span class="bound">x</span> <span class="free">s1</span> <span class="main">=</span> alive <span class="bound">x</span> <span class="free">s2</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span>
   <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> new_def typeofNew_def alive_def aliveImpl_def
                   value_class_inhabitants value_array_inhabitants all_le_eq<span class="main">)</span>

<span class="keyword1" id="Store-new_update"><span class="command">lemma</span></span> new_update <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"new <span class="main">(</span><span class="free">s</span><span class="main">⟨</span><span class="free">l</span><span class="main">:=</span><span class="free">x</span><span class="main">⟩</span><span class="main">)</span> <span class="free">t</span> <span class="main">=</span> new <span class="free">s</span> <span class="free">t</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> new_eq<span class="main">)</span>

<span class="keyword1" id="Store-alive_alloc_propagation"><span class="command">lemma</span></span> alive_alloc_propagation<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> alive_s<span class="main">:</span> <span class="quoted"><span class="quoted">"alive <span class="free">x</span> <span class="free">s</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>  <span class="quoted"><span class="quoted">"alive <span class="free">x</span> <span class="main">(</span><span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> new_instance <span class="keyword1"><span class="command">with</span></span> alive_s <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> 
       <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alive_def aliveImpl_def alloc_def 
                      alloc_new_instance_in_Store <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> Abs_Store_inverse<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> new_array <span class="keyword1"><span class="command">with</span></span> alive_s <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> 
       <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alive_def aliveImpl_def alloc_def 
                      alloc_new_array_in_Store <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> Abs_Store_inverse<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>
  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Store7›</span></span> 
<span class="keyword1" id="Store-alive_alloc_exhaust"><span class="command">lemma</span></span> alive_alloc_exhaust<span class="main">:</span> <span class="quoted"><span class="quoted">"alive <span class="free">x</span> <span class="main">(</span><span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>alive <span class="free">x</span> <span class="free">s</span> <span class="main">∨</span> <span class="main">(</span><span class="free">x</span> <span class="main">=</span> new <span class="free">s</span> <span class="free">t</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> 
  <span class="keyword3"><span class="command">assume</span></span> alive_alloc<span class="main">:</span> <span class="quoted"><span class="quoted">"alive <span class="free">x</span> <span class="main">(</span><span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"alive <span class="free">x</span> <span class="free">s</span> <span class="main">∨</span> <span class="free">x</span> <span class="main">=</span> new <span class="free">s</span> <span class="free">t</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>new_instance <span class="skolem">C</span><span class="main">)</span> 
    <span class="keyword1"><span class="command">with</span></span> alive_alloc <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm 
                         <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alive_def new_def alloc_def aliveImpl_def
                              alloc_new_instance_in_Store <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> Abs_Store_inverse<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>new_array <span class="skolem">T</span> <span class="skolem">l</span><span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> alive_alloc <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_split_asm
                         <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alive_def new_def alloc_def aliveImpl_def
                         alloc_new_array_in_Store <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> Abs_Store_inverse<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"alive <span class="free">x</span> <span class="free">s</span> <span class="main">∨</span> <span class="free">x</span> <span class="main">=</span> new <span class="free">s</span> <span class="free">t</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"alive <span class="free">x</span> <span class="main">(</span><span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> 
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"alive <span class="free">x</span> <span class="free">s</span>"</span></span> <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> alive_alloc_propagation<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> new<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span><span class="main">=</span>new <span class="free">s</span> <span class="free">t</span>"</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> new_instance <span class="keyword1"><span class="command">with</span></span> new <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alive_def aliveImpl_def new_def alloc_def
                      alloc_new_instance_in_Store <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> Abs_Store_inverse<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> new_array <span class="keyword1"><span class="command">with</span></span> new <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alive_def aliveImpl_def new_def alloc_def
                      alloc_new_array_in_Store <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> Abs_Store_inverse<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Store-alive_alloc_cases"><span class="command">lemma</span></span> alive_alloc_cases <span class="main">[</span><span class="operator">consumes</span> 1<span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>alive <span class="free">x</span> <span class="main">(</span><span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">)</span><span class="main">;</span> alive <span class="free">x</span> <span class="free">s</span> <span class="main">⟹</span> <span class="free">P</span><span class="main">;</span> <span class="free">x</span><span class="main">=</span>new <span class="free">s</span> <span class="free">t</span> <span class="main">⟹</span> <span class="free">P</span><span class="main">⟧</span>
   <span class="main">⟹</span> <span class="free">P</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alive_alloc_exhaust<span class="main">)</span>

<span class="keyword1" id="Store-aliveImpl_vals_independent"><span class="command">lemma</span></span> aliveImpl_vals_independent<span class="main">:</span> <span class="quoted"><span class="quoted">"aliveImpl <span class="free">x</span> <span class="main">(</span><span class="free">s</span><span class="main">⦇</span>vals <span class="main">:=</span> <span class="free">z</span><span class="main">⦈</span><span class="main">)</span> <span class="main">=</span> aliveImpl <span class="free">x</span> <span class="free">s</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> aliveImpl_def<span class="main">)</span>

<span class="keyword1" id="Store-access_arr_len_new_alloc"><span class="command">lemma</span></span> access_arr_len_new_alloc <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⟨</span>new_array <span class="free">T</span> <span class="free">l</span><span class="main">⟩</span><span class="main">@@</span>arr_len <span class="main">(</span>new <span class="free">s</span> <span class="main">(</span>new_array <span class="free">T</span> <span class="free">l</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> intgV <span class="main">(</span>int <span class="free">l</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> access_def<span class="main">)</span> 
     <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> new_def alloc_def alive_def 
                alloc_new_array_in_Store <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> Abs_Store_inverse<span class="main"><span class="main">]</span></span> access_def<span class="main">)</span>

<span class="keyword1" id="Store-access_new"><span class="command">lemma</span></span> access_new <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> ref_new<span class="main">:</span> <span class="quoted"><span class="quoted">"ref <span class="free">l</span> <span class="main">=</span> new <span class="free">s</span> <span class="free">t</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> no_arr_len<span class="main">:</span> <span class="quoted"><span class="quoted">"isNewArr <span class="free">t</span> <span class="main">⟶</span> <span class="free">l</span> <span class="main">≠</span> arr_len <span class="main">(</span>new <span class="free">s</span> <span class="free">t</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">@@</span><span class="free">l</span> <span class="main">=</span> init <span class="main">(</span>ltype <span class="free">l</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> ref_new 
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> alive <span class="main">(</span>ref <span class="free">l</span><span class="main">)</span> <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">@@</span><span class="free">l</span> <span class="main">=</span> init <span class="main">(</span>ltype <span class="free">l</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">from</span></span> ref_new
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"alive <span class="main">(</span>ref <span class="free">l</span><span class="main">)</span> <span class="main">(</span><span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">from</span></span> no_arr_len
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"vals <span class="main">(</span>Rep_Store <span class="main">(</span><span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">)</span><span class="main">)</span> <span class="free">l</span> <span class="main">=</span> <span class="free">s</span><span class="main">@@</span><span class="free">l</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span>
       <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alloc_def new_def access_def
                  alloc_new_instance_in_Store <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> Abs_Store_inverse<span class="main"><span class="main">]</span></span> 
                  alloc_new_array_in_Store <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> Abs_Store_inverse<span class="main"><span class="main">]</span></span> <span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">@@</span><span class="free">l</span> <span class="main">=</span> init <span class="main">(</span>ltype <span class="free">l</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> access_def<span class="main">)</span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Store5. We have to take into account that the length of an array
is changed during allocation.›</span></span>
<span class="keyword1" id="Store-access_alloc"><span class="command">lemma</span></span> access_alloc <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> no_arr_len_new<span class="main">:</span> <span class="quoted"><span class="quoted">"isNewArr <span class="free">t</span> <span class="main">⟶</span> <span class="free">l</span> <span class="main">≠</span> arr_len <span class="main">(</span>new <span class="free">s</span> <span class="free">t</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">@@</span><span class="free">l</span> <span class="main">=</span> <span class="free">s</span><span class="main">@@</span><span class="free">l</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"alive <span class="main">(</span>ref <span class="free">l</span><span class="main">)</span> <span class="main">(</span><span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">)</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword1"><span class="command">then</span></span>
    <span class="keyword1"><span class="command">have</span></span> access_alloc_vals<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">@@</span><span class="free">l</span> <span class="main">=</span> vals <span class="main">(</span>Rep_Store <span class="main">(</span><span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">)</span><span class="main">)</span> <span class="free">l</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> access_def alloc_def<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> True <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> alive_alloc_cases<span class="main">)</span>
      <span class="keyword3"><span class="command">assume</span></span> alive_l_s<span class="main">:</span> <span class="quoted"><span class="quoted">"alive <span class="main">(</span>ref <span class="free">l</span><span class="main">)</span> <span class="free">s</span>"</span></span>
      <span class="keyword1"><span class="command">with</span></span> new_unalive_old_Store
      <span class="keyword1"><span class="command">have</span></span> l_not_new<span class="main">:</span> <span class="quoted"><span class="quoted">"ref <span class="free">l</span> <span class="main">≠</span> new <span class="free">s</span> <span class="free">t</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"vals <span class="main">(</span>Rep_Store <span class="main">(</span><span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">)</span><span class="main">)</span> <span class="free">l</span> <span class="main">=</span> <span class="free">s</span><span class="main">@@</span><span class="free">l</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span> 
           <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alloc_def new_def access_def 
                 alloc_new_instance_in_Store <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> Abs_Store_inverse<span class="main"><span class="main">]</span></span> 
                 alloc_new_array_in_Store <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> Abs_Store_inverse<span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> access_alloc_vals 
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">assume</span></span> ref_new<span class="main">:</span> <span class="quoted"><span class="quoted">"ref <span class="free">l</span> <span class="main">=</span> new <span class="free">s</span> <span class="free">t</span>"</span></span>
      <span class="keyword1"><span class="command">with</span></span> no_arr_len_new
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">@@</span><span class="free">l</span> <span class="main">=</span> init <span class="main">(</span>ltype <span class="free">l</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> access_new<span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span>
      <span class="keyword1"><span class="command">from</span></span> ref_new <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">@@</span><span class="free">l</span> <span class="main">=</span> init <span class="main">(</span>ltype <span class="free">l</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">ultimately</span></span>
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">@@</span><span class="free">l</span> <span class="main">=</span> init <span class="main">(</span>ltype <span class="free">l</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">from</span></span> False <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> alive <span class="main">(</span>ref <span class="free">l</span><span class="main">)</span> <span class="free">s</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alive_alloc_propagation<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">@@</span><span class="free">l</span> <span class="main">=</span> init <span class="main">(</span>ltype <span class="free">l</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>
   
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Store13›</span></span>
<span class="keyword1" id="Store-Store_eqI"><span class="command">lemma</span></span> Store_eqI<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> eq_alive<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">x</span><span class="main">.</span> alive <span class="bound">x</span> <span class="free">s1</span> <span class="main">=</span> alive <span class="bound">x</span> <span class="free">s2</span>"</span></span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> eq_access<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">l</span><span class="main">.</span> <span class="free">s1</span><span class="main">@@</span><span class="bound">l</span> <span class="main">=</span> <span class="free">s2</span><span class="main">@@</span><span class="bound">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">s1</span><span class="main">=</span><span class="free">s2</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">s1</span><span class="main">=</span><span class="free">s2</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">note</span></span> neq_s1_s2 <span class="main">=</span> this
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"newOID <span class="main">(</span>Rep_Store <span class="free">s1</span><span class="main">)</span> <span class="main">=</span> newOID <span class="main">(</span>Rep_Store <span class="free">s2</span><span class="main">)</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">C</span><span class="main">.</span> newOID <span class="main">(</span>Rep_Store <span class="free">s1</span><span class="main">)</span> <span class="bound">C</span> <span class="main">≠</span> newOID <span class="main">(</span>Rep_Store <span class="free">s2</span><span class="main">)</span> <span class="bound">C</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="main">(</span><span class="main">∃</span><span class="bound">C</span><span class="main">.</span> newOID <span class="main">(</span>Rep_Store <span class="free">s1</span><span class="main">)</span> <span class="bound">C</span> <span class="main">≠</span> newOID <span class="main">(</span>Rep_Store <span class="free">s2</span><span class="main">)</span> <span class="bound">C</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"newOID <span class="main">(</span>Rep_Store <span class="free">s1</span><span class="main">)</span> <span class="main">=</span> newOID <span class="main">(</span>Rep_Store <span class="free">s2</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> ext<span class="main">)</span>
      <span class="keyword1"><span class="command">with</span></span> False <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">..</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">with</span></span> eq_alive <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">C</span></span> 
      <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"newOID <span class="main">(</span>Rep_Store <span class="free">s1</span><span class="main">)</span> <span class="skolem">C</span> <span class="main">≠</span> newOID <span class="main">(</span>Rep_Store <span class="free">s2</span><span class="main">)</span> <span class="skolem">C</span>"</span></span>
            <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">a</span><span class="main">.</span> alive <span class="main">(</span>objV <span class="skolem">C</span> <span class="bound">a</span><span class="main">)</span> <span class="free">s1</span> <span class="main">=</span> alive <span class="main">(</span>objV <span class="skolem">C</span> <span class="bound">a</span><span class="main">)</span> <span class="free">s2</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> all_le_eq alive_def aliveImpl_def<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">note</span></span> eq_newOID <span class="main">=</span> this
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"newAID <span class="main">(</span>Rep_Store <span class="free">s1</span><span class="main">)</span> <span class="main">=</span> newAID <span class="main">(</span>Rep_Store <span class="free">s2</span><span class="main">)</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> False
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">T</span><span class="main">.</span> newAID <span class="main">(</span>Rep_Store <span class="free">s1</span><span class="main">)</span> <span class="bound">T</span> <span class="main">≠</span> newAID <span class="main">(</span>Rep_Store <span class="free">s2</span><span class="main">)</span> <span class="bound">T</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="main">(</span><span class="main">∃</span><span class="bound">T</span><span class="main">.</span> newAID <span class="main">(</span>Rep_Store <span class="free">s1</span><span class="main">)</span> <span class="bound">T</span> <span class="main">≠</span> newAID <span class="main">(</span>Rep_Store <span class="free">s2</span><span class="main">)</span> <span class="bound">T</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"newAID <span class="main">(</span>Rep_Store <span class="free">s1</span><span class="main">)</span> <span class="main">=</span> newAID <span class="main">(</span>Rep_Store <span class="free">s2</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> ext<span class="main">)</span>
        <span class="keyword1"><span class="command">with</span></span> False <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">..</span></span>
      <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">with</span></span> eq_alive <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">T</span></span> 
        <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"newAID <span class="main">(</span>Rep_Store <span class="free">s1</span><span class="main">)</span> <span class="skolem">T</span> <span class="main">≠</span> newAID <span class="main">(</span>Rep_Store <span class="free">s2</span><span class="main">)</span> <span class="skolem">T</span>"</span></span>
              <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">a</span><span class="main">.</span> alive <span class="main">(</span>arrV <span class="skolem">T</span> <span class="bound">a</span><span class="main">)</span> <span class="free">s1</span> <span class="main">=</span> alive <span class="main">(</span>arrV <span class="skolem">T</span> <span class="bound">a</span><span class="main">)</span> <span class="free">s2</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> all_le_eq alive_def aliveImpl_def<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">note</span></span> eq_newAID <span class="main">=</span> this
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"vals <span class="main">(</span>Rep_Store <span class="free">s1</span><span class="main">)</span> <span class="main">=</span> vals <span class="main">(</span>Rep_Store <span class="free">s2</span><span class="main">)</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> True
        <span class="keyword1"><span class="command">with</span></span> eq_newOID eq_newAID 
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Rep_Store <span class="free">s1</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Rep_Store <span class="free">s2</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"Rep_Store <span class="free">s1</span>"</span></span><span class="main"><span class="keyword3">,</span></span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"Rep_Store <span class="free">s2</span>"</span></span><span class="main">)</span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">s1</span><span class="main">=</span><span class="free">s2</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Rep_Store_inject<span class="main">)</span>
        <span class="keyword1"><span class="command">with</span></span> neq_s1_s2 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> False
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">l</span><span class="main">.</span> vals <span class="main">(</span>Rep_Store <span class="free">s1</span><span class="main">)</span> <span class="bound">l</span> <span class="main">≠</span> vals <span class="main">(</span>Rep_Store <span class="free">s2</span><span class="main">)</span> <span class="bound">l</span>"</span></span>
        <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="main">(</span><span class="main">∃</span><span class="bound">l</span><span class="main">.</span> vals <span class="main">(</span>Rep_Store <span class="free">s1</span><span class="main">)</span> <span class="bound">l</span> <span class="main">≠</span> vals <span class="main">(</span>Rep_Store <span class="free">s2</span><span class="main">)</span> <span class="bound">l</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"vals <span class="main">(</span>Rep_Store <span class="free">s1</span><span class="main">)</span> <span class="main">=</span> vals <span class="main">(</span>Rep_Store <span class="free">s2</span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> ext<span class="main">)</span>
          <span class="keyword1"><span class="command">with</span></span> False <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">..</span></span>
        <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">l</span></span>
          <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"vals <span class="main">(</span>Rep_Store <span class="free">s1</span><span class="main">)</span> <span class="skolem">l</span> <span class="main">≠</span> vals <span class="main">(</span>Rep_Store <span class="free">s2</span><span class="main">)</span> <span class="skolem">l</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">with</span></span> eq_access <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"False"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> access_def<span class="main">)</span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Lemma 3.1 in [Poetzsch-Heffter97]. The proof of this lemma is quite an
impressive demostration of readable Isar proofs since it closely follows the
textual proof.›</span></span>
<span class="keyword1" id="Store-comm"><span class="command">lemma</span></span> comm<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> neq_l_new<span class="main">:</span> <span class="quoted"><span class="quoted">"ref <span class="free">l</span> <span class="main">≠</span> new <span class="free">s</span> <span class="free">t</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> neq_x_new<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≠</span> new <span class="free">s</span> <span class="free">t</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">⟨</span><span class="free">l</span><span class="main">:=</span><span class="free">x</span><span class="main">⟩</span> <span class="main">=</span> <span class="free">s</span><span class="main">⟨</span><span class="free">l</span><span class="main">:=</span><span class="free">x</span><span class="main">⟩</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> Store_eqI <span class="main"><span class="main">[</span></span><span class="operator">rule_format</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">y</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"alive <span class="skolem">y</span> <span class="main">(</span><span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">⟨</span><span class="free">l</span><span class="main">:=</span><span class="free">x</span><span class="main">⟩</span><span class="main">)</span> <span class="main">=</span> alive <span class="skolem">y</span> <span class="main">(</span><span class="free">s</span><span class="main">⟨</span><span class="free">l</span><span class="main">:=</span><span class="free">x</span><span class="main">⟩</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">)</span>"</span></span>                          
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"alive <span class="skolem">y</span> <span class="main">(</span><span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">⟨</span><span class="free">l</span><span class="main">:=</span><span class="free">x</span><span class="main">⟩</span><span class="main">)</span> <span class="main">=</span> alive <span class="skolem">y</span> <span class="main">(</span><span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> alive_update_invariant<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span>alive <span class="skolem">y</span> <span class="free">s</span> <span class="main">∨</span> <span class="main">(</span><span class="skolem">y</span> <span class="main">=</span> new <span class="free">s</span> <span class="free">t</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> alive_alloc_exhaust<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span>alive <span class="skolem">y</span> <span class="main">(</span><span class="free">s</span><span class="main">⟨</span><span class="free">l</span><span class="main">:=</span><span class="free">x</span><span class="main">⟩</span><span class="main">)</span> <span class="main">∨</span> <span class="skolem">y</span> <span class="main">=</span> new <span class="free">s</span> <span class="free">t</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> alive_update_invariant<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span>alive <span class="skolem">y</span> <span class="main">(</span><span class="free">s</span><span class="main">⟨</span><span class="free">l</span><span class="main">:=</span><span class="free">x</span><span class="main">⟩</span><span class="main">)</span> <span class="main">∨</span> <span class="skolem">y</span> <span class="main">=</span> new <span class="main">(</span><span class="free">s</span><span class="main">⟨</span><span class="free">l</span><span class="main">:=</span><span class="free">x</span><span class="main">⟩</span><span class="main">)</span> <span class="free">t</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"new <span class="free">s</span> <span class="free">t</span> <span class="main">=</span> new <span class="main">(</span><span class="free">s</span><span class="main">⟨</span><span class="free">l</span><span class="main">:=</span><span class="free">x</span><span class="main">⟩</span><span class="main">)</span> <span class="free">t</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> alive <span class="skolem">y</span> <span class="main">(</span><span class="free">s</span><span class="main">⟨</span><span class="free">l</span><span class="main">:=</span><span class="free">x</span><span class="main">⟩</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alive_alloc_exhaust<span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">k</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">⟨</span><span class="free">l</span> <span class="main">:=</span> <span class="free">x</span><span class="main">⟩</span><span class="main">@@</span><span class="skolem">k</span> <span class="main">=</span> <span class="free">s</span><span class="main">⟨</span><span class="free">l</span> <span class="main">:=</span> <span class="free">x</span><span class="main">⟩</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">@@</span><span class="skolem">k</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">l</span><span class="main">=</span><span class="skolem">k</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">note</span></span> neq_l_k <span class="main">=</span> this
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"isNewArr <span class="free">t</span> <span class="main">⟶</span> <span class="skolem">k</span> <span class="main">≠</span> arr_len <span class="main">(</span>new <span class="free">s</span> <span class="free">t</span><span class="main">)</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True
      <span class="keyword1"><span class="command">from</span></span> neq_l_k 
      <span class="keyword1"><span class="command">have</span></span>  <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">⟨</span><span class="free">l</span> <span class="main">:=</span> <span class="free">x</span><span class="main">⟩</span><span class="main">@@</span><span class="skolem">k</span> <span class="main">=</span> <span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">@@</span><span class="skolem">k</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> True 
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="free">s</span><span class="main">@@</span><span class="skolem">k</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> neq_l_k 
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="free">s</span><span class="main">⟨</span><span class="free">l</span><span class="main">:=</span><span class="free">x</span><span class="main">⟩</span><span class="main">@@</span><span class="skolem">k</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> True
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="free">s</span><span class="main">⟨</span><span class="free">l</span> <span class="main">:=</span> <span class="free">x</span><span class="main">⟩</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">@@</span><span class="skolem">k</span>"</span></span>  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> False
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">T</span></span> <span class="skolem"><span class="skolem">n</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
        t<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">t</span><span class="main">=</span>new_array <span class="skolem">T</span> <span class="skolem">n</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> k<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span><span class="main">=</span>arr_len <span class="main">(</span>new <span class="free">s</span> <span class="main">(</span>new_array <span class="skolem">T</span> <span class="skolem">n</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">from</span></span> k <span class="keyword1"><span class="command">have</span></span> k'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span><span class="main">=</span>arr_len <span class="main">(</span>new <span class="main">(</span><span class="free">s</span><span class="main">⟨</span><span class="free">l</span> <span class="main">:=</span> <span class="free">x</span><span class="main">⟩</span><span class="main">)</span> <span class="main">(</span>new_array <span class="skolem">T</span> <span class="skolem">n</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">from</span></span> neq_l_k 
      <span class="keyword1"><span class="command">have</span></span>  <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">⟨</span><span class="free">l</span> <span class="main">:=</span> <span class="free">x</span><span class="main">⟩</span><span class="main">@@</span><span class="skolem">k</span> <span class="main">=</span> <span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">@@</span><span class="skolem">k</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> t k 
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> intgV <span class="main">(</span>int <span class="skolem">n</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> t k'
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="free">s</span><span class="main">⟨</span><span class="free">l</span> <span class="main">:=</span> <span class="free">x</span><span class="main">⟩</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">@@</span><span class="skolem">k</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> new_update<span class="main">)</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">note</span></span> eq_l_k <span class="main">=</span> this
    <span class="keyword1"><span class="command">have</span></span> lemma_3_1<span class="main">:</span> 
      <span class="quoted"><span class="quoted">"ref <span class="free">l</span> <span class="main">≠</span> new <span class="free">s</span> <span class="free">t</span> <span class="main">⟹</span> alive <span class="main">(</span>ref <span class="free">l</span><span class="main">)</span> <span class="main">(</span><span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">)</span> <span class="main">=</span> alive <span class="main">(</span>ref <span class="free">l</span><span class="main">)</span> <span class="free">s</span>"</span></span>         
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alive_alloc_exhaust<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> lemma_3_2<span class="main">:</span> 
      <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≠</span> new <span class="free">s</span> <span class="free">t</span> <span class="main">⟹</span> alive <span class="free">x</span> <span class="main">(</span><span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">)</span> <span class="main">=</span> alive <span class="free">x</span> <span class="free">s</span>"</span></span>    
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alive_alloc_exhaust<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> lemma_3_3<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⟨</span><span class="free">l</span><span class="main">:=</span><span class="free">x</span><span class="main">,</span><span class="free">t</span><span class="main">⟩</span><span class="main">@@</span><span class="free">l</span> <span class="main">=</span> <span class="free">s</span><span class="main">⟨</span><span class="free">l</span><span class="main">:=</span><span class="free">x</span><span class="main">⟩</span><span class="main">@@</span><span class="free">l</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command">from</span></span> neq_l_new <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ref <span class="free">l</span> <span class="main">≠</span> new <span class="main">(</span><span class="free">s</span><span class="main">⟨</span><span class="free">l</span><span class="main">:=</span><span class="free">x</span><span class="main">⟩</span><span class="main">)</span> <span class="free">t</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"isNewArr <span class="free">t</span> <span class="main">⟶</span> <span class="free">l</span> <span class="main">≠</span> arr_len <span class="main">(</span>new <span class="main">(</span><span class="free">s</span><span class="main">⟨</span><span class="free">l</span><span class="main">:=</span><span class="free">x</span><span class="main">⟩</span><span class="main">)</span> <span class="free">t</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span> <span class="operator">auto</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"alive <span class="free">x</span> <span class="free">s</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">note</span></span> alive_x <span class="main">=</span> this
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"alive <span class="main">(</span>ref <span class="free">l</span><span class="main">)</span> <span class="free">s</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">note</span></span> alive_l <span class="main">=</span> this
        <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"typeof <span class="free">x</span> <span class="main">≤</span> ltype <span class="free">l</span>"</span></span><span class="main">)</span>
          <span class="keyword3"><span class="command">case</span></span> True 
          <span class="keyword1"><span class="command">with</span></span> alive_l alive_x
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⟨</span><span class="free">l</span><span class="main">:=</span><span class="free">x</span><span class="main">⟩</span><span class="main">@@</span><span class="free">l</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> update_access_same<span class="main">)</span>
          <span class="keyword1"><span class="command">moreover</span></span>
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">⟨</span><span class="free">l</span><span class="main">:=</span><span class="free">x</span><span class="main">⟩</span><span class="main">@@</span><span class="free">l</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
          <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
            <span class="keyword1"><span class="command">from</span></span> alive_l neq_l_new <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"alive <span class="main">(</span>ref <span class="free">l</span><span class="main">)</span> <span class="main">(</span><span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">)</span>"</span></span>
              <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lemma_3_1<span class="main">)</span>
            <span class="keyword1"><span class="command">moreover</span></span>
            <span class="keyword1"><span class="command">from</span></span> alive_x neq_x_new <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"alive <span class="free">x</span> <span class="main">(</span><span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">)</span>"</span></span>
              <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lemma_3_2<span class="main">)</span>
            <span class="keyword1"><span class="command">ultimately</span></span>
            <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">⟨</span><span class="free">l</span><span class="main">:=</span><span class="free">x</span><span class="main">⟩</span><span class="main">@@</span><span class="free">l</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
              <span class="keyword1"><span class="command">using</span></span> True <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> update_access_same<span class="main">)</span>
          <span class="keyword1"><span class="command">qed</span></span>
          <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
            <span class="keyword1"><span class="command">using</span></span> eq_l_k lemma_3_3 <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> False
          <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">note</span></span> not_alive_l <span class="main">=</span> this
        <span class="keyword1"><span class="command">from</span></span> not_alive_l neq_l_new <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> alive <span class="main">(</span>ref <span class="free">l</span><span class="main">)</span> <span class="main">(</span><span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lemma_3_1<span class="main">)</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">⟨</span><span class="free">l</span><span class="main">:=</span><span class="free">x</span><span class="main">⟩</span><span class="main">@@</span><span class="free">l</span> <span class="main">=</span> init <span class="main">(</span>ltype <span class="free">l</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> not_alive_l <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="free">s</span><span class="main">⟨</span><span class="free">l</span><span class="main">:=</span><span class="free">x</span><span class="main">⟩</span><span class="main">@@</span><span class="free">l</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="free">s</span><span class="main">⟨</span><span class="free">l</span><span class="main">:=</span><span class="free">x</span><span class="main">⟩</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">@@</span><span class="free">l</span>"</span></span> 
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lemma_3_3<span class="main">)</span>
        <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq_l_k<span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">note</span></span> not_alive_x <span class="main">=</span> this
      <span class="keyword1"><span class="command">from</span></span> not_alive_x neq_x_new <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> alive <span class="free">x</span> <span class="main">(</span><span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lemma_3_2<span class="main">)</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">⟨</span><span class="free">l</span><span class="main">:=</span><span class="free">x</span><span class="main">⟩</span><span class="main">@@</span><span class="free">l</span> <span class="main">=</span> <span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">@@</span><span class="free">l</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="free">s</span><span class="main">@@</span><span class="free">l</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
        <span class="keyword1"><span class="command">from</span></span> neq_l_new 
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"isNewArr <span class="free">t</span> <span class="main">⟶</span> <span class="free">l</span> <span class="main">≠</span> arr_len <span class="main">(</span>new <span class="free">s</span> <span class="free">t</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span> <span class="operator">auto</span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> not_alive_x <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="free">s</span><span class="main">⟨</span><span class="free">l</span><span class="main">:=</span><span class="free">x</span><span class="main">⟩</span><span class="main">@@</span><span class="free">l</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="free">s</span><span class="main">⟨</span><span class="free">l</span><span class="main">:=</span><span class="free">x</span><span class="main">⟩</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">@@</span><span class="free">l</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lemma_3_3<span class="main">)</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq_l_k<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword2"><span class="keyword">end</span></span> 
</pre>
</div><div id="StoreProperties">
<div class="head">
<h1>Theory StoreProperties</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Jive Data and Store Model
    Author:      Norbert Schirmer &lt;schirmer at informatik.tu-muenchen.de&gt;, 2003
    Maintainer:  Nicole Rauch &lt;rauch at informatik.uni-kl.de&gt;
    License:     LGPL
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Store Properties›</span></span>

<span class="keyword1"><span class="command">theory</span></span> StoreProperties
<span class="keyword2"><span class="keyword">imports</span></span> <a href="#Store">Store</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This theory formalizes advanced concepts and properties of stores.›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Reachability of a Location from a Reference›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹For a given store, the function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>reachS›</span></span></span></span> yields the set of all pairs 
$(l,v)$ where $l$ is a location that is reachable from the value $v$ (which must be a reference)
in the given store.
The predicate <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>reach›</span></span></span></span> decides whether a location is reachable from a value in a store.
›</span></span>

<span class="keyword1"><span class="command">inductive</span></span>
  <span class="entity">reach</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Store <span class="main">⇒</span> Location <span class="main">⇒</span> Value <span class="main">⇒</span> bool"</span></span> 
    <span class="main">(</span><span class="quoted">"_<span class="keyword1">⊢</span> _ <span class="keyword1">reachable'_from</span> _"</span> <span class="main">[</span>91<span class="main">,</span>91<span class="main">,</span>91<span class="main">]</span>90<span class="main">)</span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="entity">s</span> <span class="main">::</span> <span class="quoted">Store</span>
<span class="keyword2"><span class="keyword">where</span></span>
  Immediate<span class="main">:</span> <span class="quoted"><span class="quoted">"ref <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">≠</span> nullV <span class="main">⟹</span> <span class="free">s</span><span class="main"><span class="free">⊢</span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="keyword1"><span class="free">reachable_from</span></span> <span class="main">(</span>ref <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> Indirect<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">s</span><span class="main"><span class="free">⊢</span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="keyword1"><span class="free">reachable_from</span></span> <span class="main">(</span><span class="free">s</span><span class="main">@@</span><span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">)</span><span class="main">;</span> ref <span class="free"><span class="bound"><span class="entity">k</span></span></span> <span class="main">≠</span> nullV<span class="main">⟧</span> 
             <span class="main">⟹</span> <span class="free">s</span><span class="main"><span class="free">⊢</span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="keyword1"><span class="free">reachable_from</span></span> <span class="main">(</span>ref <span class="free"><span class="bound"><span class="entity">k</span></span></span><span class="main">)</span>"</span></span> 

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Note that we explicitly exclude <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>nullV›</span></span></span></span> as legal reference
for reachability. 
Keep in mind that static fields are not associated to any object,
therefore <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>ref›</span></span></span></span> yields <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>nullV›</span></span></span></span> if invoked on static fields 
(see the
definition of the function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>ref›</span></span></span></span>, Sect. \ref{ref_def}).
Reachability only describes the locations directly 
reachable from the object or array by following the pointers and should not include 
the static fields if we encounter a <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>nullV›</span></span></span></span> reference in the pointer 
chain.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We formalize some properties of reachability. 
Especially, Lemma 3.2 as given in \cite[p. 53]{Poetzsch-Heffter97specification} is proven.›</span></span>

<span class="keyword1" id="StoreProperties-unreachable_Null"><span class="command">lemma</span></span> unreachable_Null<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> reach<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⊢</span> <span class="free">l</span> <span class="keyword1">reachable_from</span> <span class="free">x</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span><span class="main">≠</span>nullV"</span></span>
  <span class="keyword1"><span class="command">using</span></span> reach <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">corollary</span></span> unreachable_Null_simp <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">s</span><span class="main">⊢</span> <span class="free">l</span> <span class="keyword1">reachable_from</span> nullV"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">iprover</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> unreachable_Null<span class="main">)</span>

<span class="keyword1"><span class="command">corollary</span></span> unreachable_NullE <span class="main">[</span><span class="operator">elim</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⊢</span> <span class="free">l</span> <span class="keyword1">reachable_from</span> nullV <span class="main">⟹</span> <span class="free">P</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="StoreProperties-reachObjLoc"><span class="command">lemma</span></span> reachObjLoc <span class="main">[</span><span class="operator">simp</span><span class="main">,</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="free">C</span><span class="main">=</span>cls <span class="free">cf</span> <span class="main">⟹</span> <span class="free">s</span><span class="main">⊢</span> objLoc <span class="free">cf</span> <span class="free">a</span> <span class="keyword1">reachable_from</span> objV <span class="free">C</span> <span class="free">a</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">iprover</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> reach.Immediate <span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted">"objLoc <span class="free">cf</span> <span class="free">a</span>"</span></span><span class="main"><span class="main">,</span></span><span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="StoreProperties-reachArrLoc"><span class="command">lemma</span></span> reachArrLoc <span class="main">[</span><span class="operator">simp</span><span class="main">,</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⊢</span> arrLoc <span class="free">T</span> <span class="free">a</span> <span class="free">i</span> <span class="keyword1">reachable_from</span> arrV <span class="free">T</span> <span class="free">a</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> reach.Immediate <span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"arrLoc <span class="free"><span class="free"><span class="free">T</span></span></span> <span class="free"><span class="free"><span class="free">a</span></span></span> <span class="free"><span class="free"><span class="free">i</span></span></span>"</span></span></span></span><span class="main"><span class="main">,</span></span><span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="StoreProperties-reachArrLen"><span class="command">lemma</span></span> reachArrLen <span class="main">[</span><span class="operator">simp</span><span class="main">,</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⊢</span> arrLenLoc <span class="free">T</span> <span class="free">a</span> <span class="keyword1">reachable_from</span> arrV <span class="free">T</span> <span class="free">a</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> reach.Immediate <span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"arrLenLoc <span class="free"><span class="free"><span class="free">T</span></span></span> <span class="free"><span class="free"><span class="free">a</span></span></span>"</span></span></span></span><span class="main"><span class="main">,</span></span><span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="StoreProperties-unreachStatic"><span class="command">lemma</span></span> unreachStatic <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">s</span><span class="main">⊢</span> staticLoc <span class="free">f</span> <span class="keyword1">reachable_from</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">y</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⊢</span> <span class="skolem">y</span> <span class="keyword1">reachable_from</span> <span class="free">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span><span class="main">=</span>staticLoc <span class="free">f</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">induct</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="StoreProperties-unreachStaticE"><span class="command">lemma</span></span> unreachStaticE <span class="main">[</span><span class="operator">elim</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⊢</span> staticLoc <span class="free">f</span> <span class="keyword1">reachable_from</span> <span class="free">x</span> <span class="main">⟹</span> <span class="free">P</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> unreachStatic<span class="main">)</span>

<span class="keyword1" id="StoreProperties-reachable_from_ArrLoc_impl_Arr"><span class="command">lemma</span></span> reachable_from_ArrLoc_impl_Arr <span class="main">[</span><span class="operator">simp</span><span class="main">,</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> reach_loc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⊢</span> <span class="free">l</span> <span class="keyword1">reachable_from</span> <span class="main">(</span><span class="free">s</span><span class="main">@@</span>arrLoc <span class="free">T</span> <span class="free">a</span> <span class="free">i</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⊢</span> <span class="free">l</span> <span class="keyword1">reachable_from</span> <span class="main">(</span>arrV <span class="free">T</span> <span class="free">a</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> reach.Indirect <span class="main">[</span><span class="operator">OF</span> reach_loc<span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="StoreProperties-reachable_from_ObjLoc_impl_Obj"><span class="command">lemma</span></span> reachable_from_ObjLoc_impl_Obj <span class="main">[</span><span class="operator">simp</span><span class="main">,</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> reach_loc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⊢</span> <span class="free">l</span> <span class="keyword1">reachable_from</span> <span class="main">(</span><span class="free">s</span><span class="main">@@</span>objLoc <span class="free">cf</span> <span class="free">a</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> C<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">C</span><span class="main">=</span>cls <span class="free">cf</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⊢</span> <span class="free">l</span> <span class="keyword1">reachable_from</span> <span class="main">(</span>objV <span class="free">C</span> <span class="free">a</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> C reach.Indirect <span class="main">[</span><span class="operator">OF</span> reach_loc<span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Lemma 3.2 (i)›</span></span>
<span class="keyword1" id="StoreProperties-reach_update"><span class="command">lemma</span></span> reach_update <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> unreachable_l_x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">s</span><span class="main">⊢</span> <span class="free">l</span> <span class="keyword1">reachable_from</span> <span class="free">x</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⟨</span><span class="free">l</span><span class="main">:=</span><span class="free">y</span><span class="main">⟩</span><span class="main">⊢</span> <span class="free">k</span> <span class="keyword1">reachable_from</span>  <span class="free">x</span> <span class="main">=</span> <span class="free">s</span><span class="main">⊢</span> <span class="free">k</span> <span class="keyword1">reachable_from</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⊢</span> <span class="free">k</span> <span class="keyword1">reachable_from</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> this unreachable_l_x
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⟨</span><span class="free">l</span> <span class="main">:=</span> <span class="free">y</span><span class="main">⟩</span><span class="main">⊢</span> <span class="free">k</span> <span class="keyword1">reachable_from</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Immediate <span class="skolem">k</span><span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ref <span class="skolem">k</span> <span class="main">≠</span> nullV"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⟨</span><span class="free">l</span> <span class="main">:=</span> <span class="free">y</span><span class="main">⟩</span><span class="main">⊢</span> <span class="skolem">k</span> <span class="keyword1">reachable_from</span> <span class="main">(</span>ref <span class="skolem">k</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> reach.Immediate<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Indirect <span class="skolem">k</span> <span class="skolem">m</span><span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> hyp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">s</span><span class="main">⊢</span> <span class="free">l</span> <span class="keyword1">reachable_from</span> <span class="main">(</span><span class="free">s</span><span class="main">@@</span><span class="skolem">m</span><span class="main">)</span> 
               <span class="main">⟹</span> <span class="free">s</span><span class="main">⟨</span><span class="free">l</span><span class="main">:=</span><span class="free">y</span><span class="main">⟩</span> <span class="main">⊢</span> <span class="skolem">k</span> <span class="keyword1">reachable_from</span> <span class="main">(</span><span class="free">s</span><span class="main">@@</span><span class="skolem">m</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ref <span class="skolem">m</span> <span class="main">≠</span> nullV"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">s</span><span class="main">⊢</span> <span class="free">l</span> <span class="keyword1">reachable_from</span> <span class="main">(</span>ref <span class="skolem">m</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">l</span><span class="main">≠</span><span class="skolem">m</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">s</span><span class="main">⊢</span> <span class="free">l</span> <span class="keyword1">reachable_from</span> <span class="main">(</span><span class="free">s</span><span class="main">@@</span><span class="skolem">m</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> reach.intros<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> hyp <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⟨</span><span class="free">l</span> <span class="main">:=</span> <span class="free">y</span><span class="main">⟩</span> <span class="main">⊢</span> <span class="skolem">k</span> <span class="keyword1">reachable_from</span> <span class="main">(</span><span class="free">s</span><span class="main">⟨</span><span class="free">l</span> <span class="main">:=</span> <span class="free">y</span><span class="main">⟩</span><span class="main">@@</span><span class="skolem">m</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⟨</span><span class="free">l</span> <span class="main">:=</span> <span class="free">y</span><span class="main">⟩</span><span class="main">⊢</span> <span class="skolem">k</span> <span class="keyword1">reachable_from</span> <span class="main">(</span>ref <span class="skolem">m</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> reach.Indirect<span class="main">)</span> <span class="main">(</span><span class="operator">rule</span> Indirect.hyps<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⟨</span><span class="free">l</span> <span class="main">:=</span> <span class="free">y</span><span class="main">⟩</span><span class="main">⊢</span> <span class="free">k</span> <span class="keyword1">reachable_from</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> this unreachable_l_x
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⊢</span> <span class="free">k</span> <span class="keyword1">reachable_from</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Immediate <span class="skolem">k</span><span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ref <span class="skolem">k</span> <span class="main">≠</span> nullV"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">⊢</span> <span class="skolem">k</span> <span class="keyword1">reachable_from</span> <span class="main">(</span>ref <span class="skolem">k</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> reach.Immediate<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Indirect <span class="skolem">k</span> <span class="skolem">m</span><span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> Indirect.hyps 
    <span class="keyword1"><span class="command">have</span></span> hyp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">s</span><span class="main">⊢</span> <span class="free">l</span> <span class="keyword1">reachable_from</span> <span class="main">(</span><span class="free">s</span><span class="main">⟨</span><span class="free">l</span> <span class="main">:=</span> <span class="free">y</span><span class="main">⟩</span><span class="main">@@</span><span class="skolem">m</span><span class="main">)</span>  
               <span class="main">⟹</span> <span class="free">s</span><span class="main">⊢</span> <span class="skolem">k</span> <span class="keyword1">reachable_from</span> <span class="main">(</span><span class="free">s</span><span class="main">⟨</span><span class="free">l</span> <span class="main">:=</span> <span class="free">y</span><span class="main">⟩</span><span class="main">@@</span><span class="skolem">m</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ref <span class="skolem">m</span> <span class="main">≠</span> nullV"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">s</span><span class="main">⊢</span> <span class="free">l</span> <span class="keyword1">reachable_from</span> <span class="main">(</span>ref <span class="skolem">m</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">l</span><span class="main">≠</span><span class="skolem">m</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">s</span> <span class="main">⊢</span> <span class="free">l</span> <span class="keyword1">reachable_from</span> <span class="main">(</span><span class="free">s</span><span class="main">@@</span><span class="skolem">m</span><span class="main">)</span>"</span></span>  
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> reach.intros<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> hyp <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">⊢</span> <span class="skolem">k</span> <span class="keyword1">reachable_from</span> <span class="main">(</span><span class="free">s</span><span class="main">@@</span><span class="skolem">m</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⊢</span> <span class="skolem">k</span> <span class="keyword1">reachable_from</span> <span class="main">(</span>ref <span class="skolem">m</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> reach.Indirect<span class="main">)</span> <span class="main">(</span><span class="operator">rule</span> Indirect.hyps<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Lemma 3.2 (ii)›</span></span>
<span class="keyword1" id="StoreProperties-reach2"><span class="command">lemma</span></span> reach2<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">s</span><span class="main">⊢</span> <span class="free">l</span> <span class="keyword1">reachable_from</span> <span class="free">x</span> <span class="main">⟹</span> <span class="main">¬</span> <span class="free">s</span><span class="main">⟨</span><span class="free">l</span><span class="main">:=</span><span class="free">y</span><span class="main">⟩</span><span class="main">⊢</span> <span class="free">l</span> <span class="keyword1">reachable_from</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Lemma 3.2 (iv)›</span></span>
<span class="keyword1" id="StoreProperties-reach4"><span class="command">lemma</span></span> reach4<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">s</span> <span class="main">⊢</span> <span class="free">l</span> <span class="keyword1">reachable_from</span> <span class="main">(</span>ref <span class="free">k</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">k</span> <span class="main">≠</span> <span class="free">l</span> <span class="main">∨</span> <span class="main">(</span>ref <span class="free">k</span><span class="main">)</span> <span class="main">=</span> nullV"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> reach.intros<span class="main">)</span>

<span class="keyword1" id="StoreProperties-reachable_isRef"><span class="command">lemma</span></span> reachable_isRef<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> reach<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⊢</span><span class="free">l</span> <span class="keyword1">reachable_from</span> <span class="free">x</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"isRefV <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> reach 
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Immediate <span class="skolem">l</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"isRefV <span class="main">(</span>ref <span class="skolem">l</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">l</span></span><span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Indirect <span class="skolem">l</span> <span class="skolem">k</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"isRefV <span class="main">(</span>ref <span class="skolem">k</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">k</span></span><span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1" id="StoreProperties-val_ArrLen_IntgT"><span class="command">lemma</span></span> val_ArrLen_IntgT<span class="main">:</span> <span class="quoted"><span class="quoted">"isArrLenLoc <span class="free">l</span> <span class="main">⟹</span> typeof <span class="main">(</span><span class="free">s</span><span class="main">@@</span><span class="free">l</span><span class="main">)</span> <span class="main">=</span> IntgT"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">assume</span></span> isArrLen<span class="main">:</span> <span class="quoted"><span class="quoted">"isArrLenLoc <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> T<span class="main">:</span> <span class="quoted"><span class="quoted">"typeof <span class="main">(</span><span class="free">s</span><span class="main">@@</span><span class="free">l</span><span class="main">)</span> <span class="main">≤</span> ltype <span class="free">l</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> isArrLen <span class="keyword1"><span class="command">have</span></span> I<span class="main">:</span> <span class="quoted"><span class="quoted">"ltype <span class="free">l</span> <span class="main">=</span> IntgT"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">l</span></span><span class="main">)</span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> rtranclE <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> le_Javatype_def subtype_defs<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="StoreProperties-access_alloc'"><span class="command">lemma</span></span> access_alloc' <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> no_arr_len<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> isArrLenLoc <span class="free">l</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">@@</span><span class="free">l</span> <span class="main">=</span> <span class="free">s</span><span class="main">@@</span><span class="free">l</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> no_arr_len 
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"isNewArr <span class="free">t</span> <span class="main">⟶</span> <span class="free">l</span> <span class="main">≠</span> arr_len <span class="main">(</span>new <span class="free">s</span> <span class="free">t</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> new_def isArrLenLoc_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> Location.splits<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> access_alloc<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>
 
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Lemma 3.2 (v)›</span></span>
<span class="keyword1" id="StoreProperties-reach_alloc"><span class="command">lemma</span></span> reach_alloc <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">⊢</span> <span class="free">l</span> <span class="keyword1">reachable_from</span> <span class="free">x</span> <span class="main">=</span> <span class="free">s</span><span class="main">⊢</span> <span class="free">l</span> <span class="keyword1">reachable_from</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> 
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">⊢</span> <span class="free">l</span> <span class="keyword1">reachable_from</span> <span class="free">x</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⊢</span> <span class="free">l</span> <span class="keyword1">reachable_from</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Immediate <span class="skolem">l</span><span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⊢</span> <span class="skolem">l</span> <span class="keyword1">reachable_from</span> ref <span class="skolem">l</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> reach.intros<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Indirect <span class="skolem">l</span> <span class="skolem">k</span><span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> reach_k<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⊢</span> <span class="skolem">l</span> <span class="keyword1">reachable_from</span> <span class="main">(</span><span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">@@</span><span class="skolem">k</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">@@</span><span class="skolem">k</span> <span class="main">=</span> <span class="free">s</span><span class="main">@@</span><span class="skolem">k</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command">from</span></span> reach_k <span class="keyword1"><span class="command">have</span></span> isRef<span class="main">:</span> <span class="quoted"><span class="quoted">"isRefV <span class="main">(</span><span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">@@</span><span class="skolem">k</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> reachable_isRef<span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> isArrLenLoc <span class="skolem">k</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main"><span class="keyword3">,</span></span><span class="operator">simp</span><span class="main">)</span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"isArrLenLoc <span class="skolem">k</span>"</span></span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"typeof <span class="main">(</span><span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">@@</span><span class="skolem">k</span><span class="main">)</span> <span class="main">=</span> IntgT"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> val_ArrLen_IntgT<span class="main">)</span>
        <span class="keyword1"><span class="command">with</span></span> isRef 
        <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"False"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">@@</span><span class="skolem">k</span><span class="main">)</span>"</span></span><span class="main">)</span> <span class="operator">simp_all</span>
      <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> access_alloc'<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⊢</span> <span class="skolem">l</span> <span class="keyword1">reachable_from</span> <span class="main">(</span><span class="free">s</span><span class="main">@@</span><span class="skolem">k</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⊢</span> <span class="skolem">l</span> <span class="keyword1">reachable_from</span> ref <span class="skolem">k</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> reach.intros<span class="main">)</span> <span class="main">(</span><span class="operator">rule</span> Indirect.hyps<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⊢</span> <span class="free">l</span> <span class="keyword1">reachable_from</span> <span class="free">x</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">⊢</span> <span class="free">l</span> <span class="keyword1">reachable_from</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Immediate <span class="skolem">l</span><span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">⊢</span> <span class="skolem">l</span> <span class="keyword1">reachable_from</span> ref <span class="skolem">l</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> reach.intros<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Indirect <span class="skolem">l</span> <span class="skolem">k</span><span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> reach_k<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">⊢</span> <span class="skolem">l</span> <span class="keyword1">reachable_from</span> <span class="main">(</span><span class="free">s</span><span class="main">@@</span><span class="skolem">k</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">@@</span><span class="skolem">k</span> <span class="main">=</span> <span class="free">s</span><span class="main">@@</span><span class="skolem">k</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command">from</span></span> reach_k <span class="keyword1"><span class="command">have</span></span> isRef<span class="main">:</span> <span class="quoted"><span class="quoted">"isRefV <span class="main">(</span><span class="free">s</span><span class="main">@@</span><span class="skolem">k</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> reachable_isRef<span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> isArrLenLoc <span class="skolem">k</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main"><span class="keyword3">,</span></span><span class="operator">simp</span><span class="main">)</span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"isArrLenLoc <span class="skolem">k</span>"</span></span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"typeof <span class="main">(</span><span class="free">s</span><span class="main">@@</span><span class="skolem">k</span><span class="main">)</span> <span class="main">=</span> IntgT"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> val_ArrLen_IntgT<span class="main">)</span>
        <span class="keyword1"><span class="command">with</span></span> isRef 
        <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"False"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">s</span><span class="main">@@</span><span class="skolem">k</span><span class="main">)</span>"</span></span><span class="main">)</span> <span class="operator">simp_all</span>
      <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> access_alloc'<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">⊢</span> <span class="skolem">l</span> <span class="keyword1">reachable_from</span> <span class="main">(</span><span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">@@</span><span class="skolem">k</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">⊢</span> <span class="skolem">l</span> <span class="keyword1">reachable_from</span> ref <span class="skolem">k</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> reach.intros<span class="main">)</span> <span class="main">(</span><span class="operator">rule</span> Indirect.hyps<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>
       

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Lemma 3.2 (vi)›</span></span>
<span class="keyword1" id="StoreProperties-reach6"><span class="command">lemma</span></span> reach6<span class="main">:</span> <span class="quoted"><span class="quoted">"isprimitive<span class="main">(</span>typeof <span class="free">x</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">¬</span> <span class="free">s</span> <span class="main">⊢</span> <span class="free">l</span> <span class="keyword1">reachable_from</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> 
  <span class="keyword3"><span class="command">assume</span></span> prim<span class="main">:</span> <span class="quoted"><span class="quoted">"isprimitive<span class="main">(</span>typeof <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">⊢</span> <span class="free">l</span> <span class="keyword1">reachable_from</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"isRefV <span class="free">x</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> reachable_isRef<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> prim <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Lemma 3.2 (iii)›</span></span>
<span class="keyword1" id="StoreProperties-reach3"><span class="command">lemma</span></span> reach3<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> k_y<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">s</span><span class="main">⊢</span> <span class="free">k</span> <span class="keyword1">reachable_from</span> <span class="free">y</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> k_x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">s</span><span class="main">⊢</span> <span class="free">k</span> <span class="keyword1">reachable_from</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">s</span><span class="main">⟨</span><span class="free">l</span><span class="main">:=</span><span class="free">y</span><span class="main">⟩</span><span class="main">⊢</span> <span class="free">k</span> <span class="keyword1">reachable_from</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⟨</span><span class="free">l</span><span class="main">:=</span><span class="free">y</span><span class="main">⟩</span><span class="main">⊢</span> <span class="free">k</span> <span class="keyword1">reachable_from</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> this k_y k_x
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Immediate <span class="skolem">l</span><span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">s</span><span class="main">⊢</span> <span class="skolem">l</span> <span class="keyword1">reachable_from</span> ref <span class="skolem">l</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"ref <span class="skolem">l</span> <span class="main">≠</span> nullV"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted">False</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">iprover</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> reach.intros<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Indirect <span class="skolem">m</span> <span class="skolem">k</span><span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> k_not_Null<span class="main">:</span> <span class="quoted"><span class="quoted">"ref <span class="skolem">k</span> <span class="main">≠</span> nullV"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
    <span class="keyword1"><span class="command">have</span></span> not_m_y<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">s</span><span class="main">⊢</span> <span class="skolem">m</span> <span class="keyword1">reachable_from</span> <span class="free">y</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
    <span class="keyword1"><span class="command">have</span></span> not_m_k<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">s</span><span class="main">⊢</span> <span class="skolem">m</span> <span class="keyword1">reachable_from</span> ref <span class="skolem">k</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
    <span class="keyword1"><span class="command">have</span></span> hyp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">¬</span> <span class="free">s</span><span class="main">⊢</span> <span class="skolem">m</span> <span class="keyword1">reachable_from</span> <span class="free">y</span><span class="main">;</span> <span class="main">¬</span> <span class="free">s</span><span class="main">⊢</span> <span class="skolem">m</span> <span class="keyword1">reachable_from</span> <span class="main">(</span><span class="free">s</span><span class="main">⟨</span><span class="free">l</span> <span class="main">:=</span> <span class="free">y</span><span class="main">⟩</span><span class="main">@@</span><span class="skolem">k</span><span class="main">)</span><span class="main">⟧</span>
               <span class="main">⟹</span> False"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
    <span class="keyword1"><span class="command">have</span></span> m_upd_k<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⟨</span><span class="free">l</span> <span class="main">:=</span> <span class="free">y</span><span class="main">⟩</span><span class="main">⊢</span> <span class="skolem">m</span> <span class="keyword1">reachable_from</span> <span class="main">(</span><span class="free">s</span><span class="main">⟨</span><span class="free">l</span> <span class="main">:=</span> <span class="free">y</span><span class="main">⟩</span><span class="main">@@</span><span class="skolem">k</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">l</span><span class="main">=</span><span class="skolem">k</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> False
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⟨</span><span class="free">l</span> <span class="main">:=</span> <span class="free">y</span><span class="main">⟩</span><span class="main">@@</span><span class="skolem">k</span> <span class="main">=</span> <span class="free">s</span><span class="main">@@</span><span class="skolem">k</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">moreover</span></span> 
      <span class="keyword1"><span class="command">from</span></span> not_m_k k_not_Null <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">s</span><span class="main">⊢</span> <span class="skolem">m</span> <span class="keyword1">reachable_from</span> <span class="main">(</span><span class="free">s</span><span class="main">@@</span><span class="skolem">k</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">iprover</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> reach.intros<span class="main">)</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
        <span class="keyword1"><span class="command">using</span></span> not_m_y hyp <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">note</span></span> eq_l_k <span class="main">=</span> this
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"alive <span class="main">(</span>ref <span class="free">l</span><span class="main">)</span> <span class="free">s</span> <span class="main">∧</span> alive <span class="free">y</span> <span class="free">s</span> <span class="main">∧</span> typeof <span class="free">y</span> <span class="main">≤</span> ltype <span class="free">l</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> True
        <span class="keyword1"><span class="command">with</span></span> eq_l_k <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⟨</span><span class="free">l</span> <span class="main">:=</span> <span class="free">y</span><span class="main">⟩</span><span class="main">@@</span><span class="skolem">k</span> <span class="main">=</span> <span class="free">y</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">with</span></span> not_m_y hyp <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> False
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⟨</span><span class="free">l</span> <span class="main">:=</span> <span class="free">y</span><span class="main">⟩</span> <span class="main">=</span> <span class="free">s</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">moreover</span></span> 
        <span class="keyword1"><span class="command">from</span></span> not_m_k k_not_Null <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">s</span><span class="main">⊢</span> <span class="skolem">m</span> <span class="keyword1">reachable_from</span> <span class="main">(</span><span class="free">s</span><span class="main">@@</span><span class="skolem">k</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">iprover</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> reach.intros<span class="main">)</span>
        <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
          <span class="keyword1"><span class="command">using</span></span> not_m_y hyp <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>



<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Lemma 3.2 (vii).›</span></span>

<span class="keyword1" id="StoreProperties-unreachable_from_init"><span class="command">lemma</span></span> unreachable_from_init <span class="main">[</span><span class="operator">simp</span><span class="main">,</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">s</span><span class="main">⊢</span> <span class="free">l</span> <span class="keyword1">reachable_from</span> <span class="main">(</span>init <span class="free">T</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> reach6 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">T</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="StoreProperties-ref_reach_unalive"><span class="command">lemma</span></span> ref_reach_unalive<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> unalive_x<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">¬</span> alive <span class="free">x</span> <span class="free">s</span>"</span></span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> l_x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⊢</span> <span class="free">l</span> <span class="keyword1">reachable_from</span> <span class="free">x</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> ref <span class="free">l</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> l_x unalive_x
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">induct</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Immediate <span class="skolem">l</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"ref <span class="skolem">l</span> <span class="main">=</span> ref <span class="skolem">l</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Indirect <span class="skolem">l</span> <span class="skolem">k</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ref <span class="skolem">k</span> <span class="main">≠</span> nullV"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> alive <span class="main">(</span>ref <span class="skolem">k</span><span class="main">)</span> <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">@@</span><span class="skolem">k</span> <span class="main">=</span> init <span class="main">(</span>ltype <span class="skolem">k</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⊢</span> <span class="skolem">l</span> <span class="keyword1">reachable_from</span> <span class="main">(</span><span class="free">s</span><span class="main">@@</span><span class="skolem">k</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="StoreProperties-loc_new_reach"><span class="command">lemma</span></span> loc_new_reach<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> l<span class="main">:</span> <span class="quoted"><span class="quoted">"ref <span class="free">l</span> <span class="main">=</span> new <span class="free">s</span> <span class="free">t</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> l_x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⊢</span> <span class="free">l</span> <span class="keyword1">reachable_from</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> new <span class="free">s</span> <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> l_x l
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">induct</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Immediate <span class="skolem">l</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"ref <span class="skolem">l</span> <span class="main">=</span> new <span class="free">s</span> <span class="free">t</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Indirect <span class="skolem">l</span> <span class="skolem">k</span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">@@</span><span class="skolem">k</span> <span class="main">=</span> new <span class="free">s</span> <span class="free">t</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">iprover</span>
  <span class="keyword1"><span class="command">moreover</span></span> 
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> alive <span class="main">(</span>new <span class="free">s</span> <span class="free">t</span><span class="main">)</span> <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">moreover</span></span> 
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"alive <span class="main">(</span><span class="free">s</span><span class="main">@@</span><span class="skolem">k</span><span class="main">)</span> <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword1"><span class="command">qed</span></span>
 

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Lemma 3.2 (viii)›</span></span>
<span class="keyword1" id="StoreProperties-alive_reach_alive"><span class="command">lemma</span></span> alive_reach_alive<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> alive_x<span class="main">:</span> <span class="quoted"><span class="quoted">"alive <span class="free">x</span> <span class="free">s</span>"</span></span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> reach_l<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">⊢</span> <span class="free">l</span> <span class="keyword1">reachable_from</span> <span class="free">x</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"alive <span class="main">(</span>ref <span class="free">l</span><span class="main">)</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> reach_l alive_x
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Immediate <span class="skolem">l</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Indirect <span class="skolem">l</span> <span class="skolem">k</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> hyp<span class="main">:</span> <span class="quoted"><span class="quoted">"alive <span class="main">(</span><span class="free">s</span><span class="main">@@</span><span class="skolem">k</span><span class="main">)</span> <span class="free">s</span> <span class="main">⟹</span> alive <span class="main">(</span>ref <span class="skolem">l</span><span class="main">)</span> <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"alive <span class="main">(</span><span class="free">s</span><span class="main">@@</span><span class="skolem">k</span><span class="main">)</span> <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">ultimately</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"alive <span class="main">(</span>ref <span class="skolem">l</span><span class="main">)</span> <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">iprover</span>
<span class="keyword1"><span class="command">qed</span></span>
 
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Lemma 3.2 (ix)›</span></span>
<span class="keyword1" id="StoreProperties-reach9"><span class="command">lemma</span></span> reach9<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> reach_impl_access_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">l</span><span class="main">.</span> <span class="free">s1</span><span class="main">⊢</span><span class="bound">l</span> <span class="keyword1">reachable_from</span> <span class="free">x</span> <span class="main">⟶</span> <span class="main">(</span><span class="free">s1</span><span class="main">@@</span><span class="bound">l</span> <span class="main">=</span> <span class="free">s2</span><span class="main">@@</span><span class="bound">l</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">s1</span><span class="main">⊢</span> <span class="free">l</span> <span class="keyword1">reachable_from</span> <span class="free">x</span> <span class="main">=</span> <span class="free">s2</span><span class="main">⊢</span> <span class="free">l</span> <span class="keyword1">reachable_from</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> 
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">s1</span><span class="main">⊢</span> <span class="free">l</span> <span class="keyword1">reachable_from</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> this reach_impl_access_eq 
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">s2</span><span class="main">⊢</span> <span class="free">l</span> <span class="keyword1">reachable_from</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Immediate <span class="skolem">l</span><span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">s2</span><span class="main">⊢</span> <span class="skolem">l</span> <span class="keyword1">reachable_from</span> ref <span class="skolem">l</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> reach.intros<span class="main">)</span> <span class="main">(</span><span class="operator">rule</span> Immediate.hyps<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Indirect <span class="skolem">l</span> <span class="skolem">k</span><span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> hyp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">l</span><span class="main">.</span> <span class="free">s1</span><span class="main">⊢</span> <span class="bound">l</span> <span class="keyword1">reachable_from</span> <span class="main">(</span><span class="free">s1</span><span class="main">@@</span><span class="skolem">k</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">s1</span><span class="main">@@</span><span class="bound">l</span> <span class="main">=</span> <span class="free">s2</span><span class="main">@@</span><span class="bound">l</span> 
               <span class="main">⟹</span> <span class="free">s2</span><span class="main">⊢</span> <span class="skolem">l</span> <span class="keyword1">reachable_from</span> <span class="main">(</span><span class="free">s1</span><span class="main">@@</span><span class="skolem">k</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
    <span class="keyword1"><span class="command">have</span></span> k_not_Null<span class="main">:</span> <span class="quoted"><span class="quoted">"ref <span class="skolem">k</span> <span class="main">≠</span> nullV"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
    <span class="keyword1"><span class="command">have</span></span> reach_impl_access_eq<span class="main">:</span> 
      <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">l</span><span class="main">.</span> <span class="free">s1</span><span class="main">⊢</span> <span class="bound">l</span> <span class="keyword1">reachable_from</span> ref <span class="skolem">k</span> <span class="main">⟶</span> <span class="free">s1</span><span class="main">@@</span><span class="bound">l</span> <span class="main">=</span> <span class="free">s2</span><span class="main">@@</span><span class="bound">l</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">s1</span><span class="main">⊢</span> <span class="skolem">l</span> <span class="keyword1">reachable_from</span> <span class="main">(</span><span class="free">s1</span><span class="main">@@</span><span class="skolem">k</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
    <span class="keyword1"><span class="command">with</span></span> k_not_Null
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">s1</span><span class="main">@@</span><span class="skolem">k</span> <span class="main">=</span> <span class="free">s2</span><span class="main">@@</span><span class="skolem">k</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">iprover</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> reach_impl_access_eq <span class="main"><span class="main">[</span></span><span class="operator">rule_format</span><span class="main"><span class="main">]</span></span> reach.intros<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> reach_impl_access_eq k_not_Null
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">l</span><span class="main">.</span> <span class="free">s1</span><span class="main">⊢</span> <span class="bound">l</span> <span class="keyword1">reachable_from</span> <span class="main">(</span><span class="free">s1</span><span class="main">@@</span><span class="skolem">k</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">s1</span><span class="main">@@</span><span class="bound">l</span> <span class="main">=</span> <span class="free">s2</span><span class="main">@@</span><span class="bound">l</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">iprover</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> reach.intros<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">s2</span><span class="main">⊢</span> <span class="skolem">l</span> <span class="keyword1">reachable_from</span> <span class="main">(</span><span class="free">s1</span><span class="main">@@</span><span class="skolem">k</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> hyp<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">s2</span><span class="main">⊢</span> <span class="skolem">l</span> <span class="keyword1">reachable_from</span> <span class="main">(</span><span class="free">s2</span><span class="main">@@</span><span class="skolem">k</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">s2</span><span class="main">⊢</span> <span class="skolem">l</span> <span class="keyword1">reachable_from</span> ref <span class="skolem">k</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> reach.intros<span class="main">)</span> <span class="main">(</span><span class="operator">rule</span> Indirect.hyps<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">s2</span><span class="main">⊢</span> <span class="free">l</span> <span class="keyword1">reachable_from</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> this reach_impl_access_eq 
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">s1</span><span class="main">⊢</span> <span class="free">l</span> <span class="keyword1">reachable_from</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Immediate <span class="skolem">l</span><span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">s1</span><span class="main">⊢</span> <span class="skolem">l</span> <span class="keyword1">reachable_from</span> ref <span class="skolem">l</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> reach.intros<span class="main">)</span> <span class="main">(</span><span class="operator">rule</span> Immediate.hyps<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Indirect <span class="skolem">l</span> <span class="skolem">k</span><span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> hyp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">l</span><span class="main">.</span> <span class="free">s1</span><span class="main">⊢</span> <span class="bound">l</span> <span class="keyword1">reachable_from</span> <span class="main">(</span><span class="free">s2</span><span class="main">@@</span><span class="skolem">k</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">s1</span><span class="main">@@</span><span class="bound">l</span> <span class="main">=</span> <span class="free">s2</span><span class="main">@@</span><span class="bound">l</span> 
               <span class="main">⟹</span> <span class="free">s1</span><span class="main">⊢</span> <span class="skolem">l</span> <span class="keyword1">reachable_from</span> <span class="main">(</span><span class="free">s2</span><span class="main">@@</span><span class="skolem">k</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
    <span class="keyword1"><span class="command">have</span></span> k_not_Null<span class="main">:</span> <span class="quoted"><span class="quoted">"ref <span class="skolem">k</span> <span class="main">≠</span> nullV"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
    <span class="keyword1"><span class="command">have</span></span> reach_impl_access_eq<span class="main">:</span> 
      <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">l</span><span class="main">.</span> <span class="free">s1</span><span class="main">⊢</span> <span class="bound">l</span> <span class="keyword1">reachable_from</span> ref <span class="skolem">k</span> <span class="main">⟶</span> <span class="free">s1</span><span class="main">@@</span><span class="bound">l</span> <span class="main">=</span> <span class="free">s2</span><span class="main">@@</span><span class="bound">l</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">s1</span><span class="main">⊢</span> <span class="skolem">k</span> <span class="keyword1">reachable_from</span> ref <span class="skolem">k</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> reach.intros<span class="main">)</span> <span class="main">(</span><span class="operator">rule</span> Indirect.hyps<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> reach_impl_access_eq
    <span class="keyword1"><span class="command">have</span></span> eq_k<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s1</span><span class="main">@@</span><span class="skolem">k</span> <span class="main">=</span> <span class="free">s2</span><span class="main">@@</span><span class="skolem">k</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> reach_impl_access_eq k_not_Null
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">l</span><span class="main">.</span> <span class="free">s1</span><span class="main">⊢</span> <span class="bound">l</span> <span class="keyword1">reachable_from</span> <span class="main">(</span><span class="free">s1</span><span class="main">@@</span><span class="skolem">k</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">s1</span><span class="main">@@</span><span class="bound">l</span> <span class="main">=</span> <span class="free">s2</span><span class="main">@@</span><span class="bound">l</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">iprover</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> reach.intros<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> 
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">l</span><span class="main">.</span> <span class="free">s1</span><span class="main">⊢</span> <span class="bound">l</span> <span class="keyword1">reachable_from</span> <span class="main">(</span><span class="free">s2</span><span class="main">@@</span><span class="skolem">k</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">s1</span><span class="main">@@</span><span class="bound">l</span> <span class="main">=</span> <span class="free">s2</span><span class="main">@@</span><span class="bound">l</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq_k<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> eq_k hyp <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">s1</span><span class="main">⊢</span> <span class="skolem">l</span> <span class="keyword1">reachable_from</span> <span class="main">(</span><span class="free">s1</span><span class="main">@@</span><span class="skolem">k</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">s1</span><span class="main">⊢</span> <span class="skolem">l</span> <span class="keyword1">reachable_from</span> ref <span class="skolem">k</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> reach.intros<span class="main">)</span> <span class="main">(</span><span class="operator">rule</span> Indirect.hyps<span class="main">)</span>
   <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Reachability of a Reference from a Reference›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The predicate <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>rreach›</span></span></span></span> tests whether a value is reachable from
another value. This is an extension of the predicate <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>oreach›</span></span></span></span> as described
in \cite[p. 54]{Poetzsch-Heffter97specification} because now arrays are handled as well.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">rreach</span><span class="main">::</span> <span class="quoted"><span class="quoted">"Store <span class="main">⇒</span> Value <span class="main">⇒</span> Value <span class="main">⇒</span> bool"</span></span> 
  <span class="main">(</span><span class="quoted">"_<span class="keyword1">⊢Ref</span> _ <span class="keyword1">reachable'_from</span> _"</span> <span class="main">[</span>91<span class="main">,</span>91<span class="main">,</span>91<span class="main">]</span>90<span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="keyword1"><span class="free">⊢Ref</span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="keyword1"><span class="free">reachable_from</span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">∃</span> <span class="bound">l</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">⊢</span> <span class="bound">l</span> <span class="keyword1">reachable_from</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> ref <span class="bound">l</span><span class="main">)</span>"</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Disjointness of Reachable Locations›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The predicate <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>disj›</span></span></span></span> tests whether two values are disjoint
in a given store. Its properties as given in 
\cite[Lemma 3.3, p. 54]{Poetzsch-Heffter97specification} are then proven.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">disj</span><span class="main">::</span> <span class="quoted"><span class="quoted">"Value <span class="main">⇒</span> Value <span class="main">⇒</span> Store <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">disj</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">l</span><span class="main">.</span> <span class="main">¬</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">⊢</span> <span class="bound">l</span> <span class="keyword1">reachable_from</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">∨</span> <span class="main">¬</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">⊢</span> <span class="bound">l</span> <span class="keyword1">reachable_from</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span>"</span></span>


<span class="keyword1" id="StoreProperties-disjI1"><span class="command">lemma</span></span> disjI1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">⋀</span> <span class="bound">l</span><span class="main">.</span> <span class="free">s</span><span class="main">⊢</span> <span class="bound">l</span> <span class="keyword1">reachable_from</span> <span class="free">x</span> <span class="main">⟹</span> <span class="main">¬</span> <span class="free">s</span><span class="main">⊢</span> <span class="bound">l</span> <span class="keyword1">reachable_from</span> <span class="free">y</span><span class="main">⟧</span> 
 <span class="main">⟹</span> disj <span class="free">x</span> <span class="free">y</span> <span class="free">s</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> disj_def<span class="main">)</span>

<span class="keyword1" id="StoreProperties-disjI2"><span class="command">lemma</span></span> disjI2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">⋀</span> <span class="bound">l</span><span class="main">.</span> <span class="free">s</span><span class="main">⊢</span> <span class="bound">l</span> <span class="keyword1">reachable_from</span> <span class="free">y</span> <span class="main">⟹</span> <span class="main">¬</span> <span class="free">s</span><span class="main">⊢</span> <span class="bound">l</span> <span class="keyword1">reachable_from</span> <span class="free">x</span><span class="main">⟧</span> 
 <span class="main">⟹</span> disj <span class="free">x</span> <span class="free">y</span> <span class="free">s</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> disj_def<span class="main">)</span>

<span class="keyword1" id="StoreProperties-disj_cases"><span class="command">lemma</span></span> disj_cases <span class="main">[</span><span class="operator">consumes</span> 1<span class="main">]</span><span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"disj <span class="free">x</span> <span class="free">y</span> <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">l</span><span class="main">.</span>  <span class="main">¬</span> <span class="free">s</span><span class="main">⊢</span> <span class="bound">l</span> <span class="keyword1">reachable_from</span> <span class="free">x</span> <span class="main">⟹</span> <span class="free">P</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">l</span><span class="main">.</span>  <span class="main">¬</span> <span class="free">s</span><span class="main">⊢</span> <span class="bound">l</span> <span class="keyword1">reachable_from</span> <span class="free">y</span> <span class="main">⟹</span> <span class="free">P</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> disj_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Lemma 3.3 (i) in \cite{Poetzsch-Heffter97specification}›</span></span>
<span class="keyword1" id="StoreProperties-disj1"><span class="command">lemma</span></span> disj1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>disj <span class="free">x</span> <span class="free">y</span> <span class="free">s</span><span class="main">;</span> <span class="main">¬</span> <span class="free">s</span><span class="main">⊢</span> <span class="free">l</span> <span class="keyword1">reachable_from</span> <span class="free">x</span><span class="main">;</span> <span class="main">¬</span> <span class="free">s</span><span class="main">⊢</span> <span class="free">l</span> <span class="keyword1">reachable_from</span> <span class="free">y</span><span class="main">⟧</span> 
              <span class="main">⟹</span> disj <span class="free">x</span> <span class="free">y</span> <span class="main">(</span><span class="free">s</span><span class="main">⟨</span><span class="free">l</span><span class="main">:=</span><span class="free">z</span><span class="main">⟩</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> disj_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Lemma 3.3 (ii)›</span></span>
<span class="keyword1" id="StoreProperties-disj2"><span class="command">lemma</span></span> disj2<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> disj_x_y<span class="main">:</span> <span class="quoted"><span class="quoted">"disj <span class="free">x</span> <span class="free">y</span> <span class="free">s</span>"</span></span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> disj_x_z<span class="main">:</span> <span class="quoted"><span class="quoted">"disj <span class="free">x</span> <span class="free">z</span> <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> unreach_l_x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">s</span><span class="main">⊢</span> <span class="free">l</span> <span class="keyword1">reachable_from</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"disj <span class="free">x</span> <span class="free">y</span> <span class="main">(</span><span class="free">s</span><span class="main">⟨</span><span class="free">l</span><span class="main">:=</span><span class="free">z</span><span class="main">⟩</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> disjI1<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">k</span> 
  <span class="keyword3"><span class="command">assume</span></span> reach_k_x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⟨</span><span class="free">l</span> <span class="main">:=</span> <span class="free">z</span><span class="main">⟩</span><span class="main">⊢</span> <span class="skolem">k</span> <span class="keyword1">reachable_from</span> <span class="free">x</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">s</span><span class="main">⟨</span><span class="free">l</span> <span class="main">:=</span> <span class="free">z</span><span class="main">⟩</span><span class="main">⊢</span> <span class="skolem">k</span> <span class="keyword1">reachable_from</span> <span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span> 
    <span class="keyword1"><span class="command">from</span></span> unreach_l_x reach_k_x 
    <span class="keyword1"><span class="command">have</span></span> reach_s_k_x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⊢</span> <span class="skolem">k</span> <span class="keyword1">reachable_from</span> <span class="free">x</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">with</span></span> disj_x_z 
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">s</span><span class="main">⊢</span> <span class="skolem">k</span> <span class="keyword1">reachable_from</span> <span class="free">z</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> disj_def<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> reach_s_k_x disj_x_y
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">s</span><span class="main">⊢</span> <span class="skolem">k</span> <span class="keyword1">reachable_from</span> <span class="free">y</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> disj_def<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> reach3<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

   

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Lemma 3.3 (iii)›</span></span>
<span class="keyword1" id="StoreProperties-disj3"><span class="command">lemma</span></span> disj3<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> alive_x_s<span class="main">:</span> <span class="quoted"><span class="quoted">"alive <span class="free">x</span> <span class="free">s</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"disj <span class="free">x</span> <span class="main">(</span>new <span class="free">s</span> <span class="free">t</span><span class="main">)</span> <span class="main">(</span><span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> disjI1<span class="main"><span class="keyword3">,</span></span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> reach_alloc<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">l</span>
  <span class="keyword3"><span class="command">assume</span></span> reach_l_x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⊢</span> <span class="skolem">l</span> <span class="keyword1">reachable_from</span> <span class="free">x</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">s</span><span class="main">⊢</span> <span class="skolem">l</span> <span class="keyword1">reachable_from</span> new <span class="free">s</span> <span class="free">t</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> 
    <span class="keyword3"><span class="command">assume</span></span> reach_l_new<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⊢</span> <span class="skolem">l</span> <span class="keyword1">reachable_from</span> new <span class="free">s</span> <span class="free">t</span>"</span></span> 
    <span class="keyword1"><span class="command">have</span></span> unalive_new<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> alive <span class="main">(</span>new <span class="free">s</span> <span class="free">t</span><span class="main">)</span> <span class="free">s</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> this reach_l_new
    <span class="keyword1"><span class="command">have</span></span>  <span class="quoted"><span class="quoted">"new <span class="free">s</span> <span class="free">t</span> <span class="main">=</span> ref <span class="skolem">l</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> ref_reach_unalive<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> alive_x_s reach_l_x 
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"alive <span class="main">(</span>ref <span class="skolem">l</span><span class="main">)</span> <span class="free">s</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> alive_reach_alive<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
      <span class="keyword1"><span class="command">using</span></span> unalive_new
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Lemma 3.3 (iv)›</span></span>
<span class="keyword1" id="StoreProperties-disj4"><span class="command">lemma</span></span> disj4<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>disj <span class="main">(</span>objV <span class="free">C</span> <span class="free">a</span><span class="main">)</span> <span class="free">y</span> <span class="free">s</span><span class="main">;</span> CClassT <span class="free">C</span> <span class="main">≤</span> dtype <span class="free">f</span> <span class="main">⟧</span>  
              <span class="main">⟹</span> disj <span class="main">(</span><span class="free">s</span><span class="main">@@</span><span class="main">(</span>objV <span class="free">C</span> <span class="free">a</span><span class="main">)</span><span class="main">..</span><span class="free">f</span><span class="main">)</span> <span class="free">y</span> <span class="free">s</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> disj_def<span class="main">)</span>
  
<span class="keyword1" id="StoreProperties-disj4'"><span class="command">lemma</span></span> disj4'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>disj <span class="main">(</span>arrV <span class="free">T</span> <span class="free">a</span><span class="main">)</span> <span class="free">y</span> <span class="free">s</span> <span class="main">⟧</span>  
              <span class="main">⟹</span> disj <span class="main">(</span><span class="free">s</span><span class="main">@@</span><span class="main">(</span>arrV <span class="free">T</span> <span class="free">a</span><span class="main">)</span><span class="main">.[</span><span class="free">i</span><span class="main">]</span><span class="main">)</span> <span class="free">y</span> <span class="free">s</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> disj_def<span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹X-Equivalence›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We call two stores $s_1$ and $s_2$ equivalent wrt. a given value $X$
(which is called X-equivalence)
 iff $X$ and all values
reachable from $X$ in $s_1$ or $s_2$ have the same state \cite[p. 55]{Poetzsch-Heffter97specification}. 
This is tested by  the predicate
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>xeq›</span></span></span></span>. Lemma 3.4 of  \cite{Poetzsch-Heffter97specification} is then proven for <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>xeq›</span></span></span></span>.
›</span></span> 

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">xeq</span><span class="main">::</span> <span class="quoted"><span class="quoted">"Value <span class="main">⇒</span> Store <span class="main">⇒</span> Store <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">xeq</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">=</span> <span class="main">(</span>alive <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> alive <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">∧</span> 
             <span class="main">(</span><span class="main">∀</span> <span class="bound">l</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">⊢</span> <span class="bound">l</span> <span class="keyword1">reachable_from</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">⟶</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">@@</span><span class="bound">l</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">@@</span><span class="bound">l</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">xeq_syntax</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Store <span class="main">⇒</span> Value <span class="main">⇒</span> Store <span class="main">⇒</span> bool"</span></span>
  <span class="main">(</span><span class="quoted">"_<span class="keyword3">/ </span><span class="keyword3">(</span><span class="keyword1">≡[</span>_<span class="keyword1">]</span><span class="keyword3">)</span><span class="keyword3">/ </span>_"</span> <span class="main">[</span>900<span class="main">,</span>0<span class="main">,</span>900<span class="main">]</span> 900<span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main"><span class="free">≡[</span></span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main"><span class="free">]</span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">==</span> xeq <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span>"</span></span>


<span class="keyword1" id="StoreProperties-xeqI"><span class="command">lemma</span></span> xeqI<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>alive <span class="free">x</span> <span class="free">s</span> <span class="main">=</span> alive <span class="free">x</span> <span class="free">t</span><span class="main">;</span>  
             <span class="main">⋀</span> <span class="bound">l</span><span class="main">.</span> <span class="free">s</span><span class="main">⊢</span> <span class="bound">l</span> <span class="keyword1">reachable_from</span> <span class="free">x</span> <span class="main">⟹</span> <span class="free">s</span><span class="main">@@</span><span class="bound">l</span> <span class="main">=</span> <span class="free">t</span><span class="main">@@</span><span class="bound">l</span>
             <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">s</span> <span class="main">≡[</span><span class="free">x</span><span class="main">]</span> <span class="free">t</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> xeq_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Lemma 3.4 (i) in  \cite{Poetzsch-Heffter97specification}.›</span></span>
<span class="keyword1" id="StoreProperties-xeq1_refl"><span class="command">lemma</span></span> xeq1_refl<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">≡[</span><span class="free">x</span><span class="main">]</span> <span class="free">s</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> xeq_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Lemma 3.4 (i)›</span></span>
<span class="keyword1" id="StoreProperties-xeq1_sym'"><span class="command">lemma</span></span> xeq1_sym'<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> s_t<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">≡[</span><span class="free">x</span><span class="main">]</span> <span class="free">t</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">≡[</span><span class="free">x</span><span class="main">]</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> s_t <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"alive <span class="free">x</span> <span class="free">s</span> <span class="main">=</span> alive <span class="free">x</span> <span class="free">t</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> xeq_def<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">from</span></span> s_t <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">l</span><span class="main">.</span> <span class="free">s</span><span class="main">⊢</span> <span class="bound">l</span> <span class="keyword1">reachable_from</span> <span class="free">x</span> <span class="main">⟶</span> <span class="free">s</span><span class="main">@@</span><span class="bound">l</span> <span class="main">=</span> <span class="free">t</span><span class="main">@@</span><span class="bound">l</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> xeq_def<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> reach9 <span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">l</span><span class="main">.</span> <span class="free">t</span><span class="main">⊢</span> <span class="bound">l</span> <span class="keyword1">reachable_from</span> <span class="free">x</span> <span class="main">⟶</span> <span class="free">t</span><span class="main">@@</span><span class="bound">l</span> <span class="main">=</span> <span class="free">s</span><span class="main">@@</span><span class="bound">l</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> xeq_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>
 
<span class="keyword1" id="StoreProperties-xeq1_sym"><span class="command">lemma</span></span> xeq1_sym<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">≡[</span><span class="free">x</span><span class="main">]</span> <span class="free">t</span> <span class="main">=</span> <span class="free">t</span> <span class="main">≡[</span><span class="free">x</span><span class="main">]</span> <span class="free">s</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> xeq1_sym'<span class="main">)</span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Lemma 3.4 (i)›</span></span>
<span class="keyword1" id="StoreProperties-xeq1_trans"><span class="command">lemma</span></span> xeq1_trans <span class="main">[</span><span class="operator">trans</span><span class="main">]</span><span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> s_t<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">≡[</span><span class="free">x</span><span class="main">]</span> <span class="free">t</span>"</span></span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> t_r<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">≡[</span><span class="free">x</span><span class="main">]</span> <span class="free">r</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">≡[</span><span class="free">x</span><span class="main">]</span> <span class="free">r</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> s_t t_r
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"alive <span class="free">x</span> <span class="free">s</span> <span class="main">=</span> alive <span class="free">x</span> <span class="free">r</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> xeq_def<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">l</span><span class="main">.</span> <span class="free">s</span><span class="main">⊢</span> <span class="bound">l</span> <span class="keyword1">reachable_from</span> <span class="free">x</span> <span class="main">⟶</span> <span class="free">s</span><span class="main">@@</span><span class="bound">l</span> <span class="main">=</span> <span class="free">r</span><span class="main">@@</span><span class="bound">l</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> allI impI<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">l</span>
    <span class="keyword3"><span class="command">assume</span></span> reach_l<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⊢</span> <span class="skolem">l</span> <span class="keyword1">reachable_from</span> <span class="free">x</span>"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">@@</span><span class="skolem">l</span> <span class="main">=</span> <span class="free">r</span><span class="main">@@</span><span class="skolem">l</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command">from</span></span> reach_l s_t <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">@@</span><span class="skolem">l</span><span class="main">=</span><span class="free">t</span><span class="main">@@</span><span class="skolem">l</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> xeq_def<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">t</span><span class="main">@@</span><span class="skolem">l</span> <span class="main">=</span> <span class="free">r</span><span class="main">@@</span><span class="skolem">l</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
        <span class="keyword1"><span class="command">from</span></span> s_t <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">l</span><span class="main">.</span> <span class="free">s</span><span class="main">⊢</span> <span class="bound">l</span> <span class="keyword1">reachable_from</span> <span class="free">x</span> <span class="main">⟶</span> <span class="free">s</span><span class="main">@@</span><span class="bound">l</span> <span class="main">=</span> <span class="free">t</span><span class="main">@@</span><span class="bound">l</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> xeq_def<span class="main">)</span>
        <span class="keyword1"><span class="command">from</span></span> reach9 <span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> reach_l <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">t</span><span class="main">⊢</span> <span class="skolem">l</span> <span class="keyword1">reachable_from</span> <span class="free">x</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">with</span></span> t_r <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> xeq_def<span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> xeq_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>
   

  
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Lemma 3.4 (ii)›</span></span>
<span class="keyword1" id="StoreProperties-xeq2"><span class="command">lemma</span></span> xeq2<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> xeq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">x</span><span class="main">.</span> <span class="free">s</span> <span class="main">≡[</span><span class="bound">x</span><span class="main">]</span> <span class="free">t</span>"</span></span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> static_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">f</span><span class="main">.</span> <span class="free">s</span><span class="main">@@</span><span class="main">(</span>staticLoc <span class="bound">f</span><span class="main">)</span> <span class="main">=</span> <span class="free">t</span><span class="main">@@</span><span class="main">(</span>staticLoc <span class="bound">f</span><span class="main">)</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">=</span> <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> Store_eqI<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> xeq 
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">.</span> alive <span class="bound">x</span> <span class="free">s</span> <span class="main">=</span> alive <span class="bound">x</span> <span class="free">t</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> xeq_def<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">l</span><span class="main">.</span> <span class="free">s</span><span class="main">@@</span><span class="bound">l</span> <span class="main">=</span> <span class="free">t</span><span class="main">@@</span><span class="bound">l</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> 
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">l</span> 
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">@@</span><span class="skolem">l</span> <span class="main">=</span> <span class="free">t</span><span class="main">@@</span><span class="skolem">l</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">l</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>objLoc <span class="skolem">cf</span> <span class="skolem">a</span><span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">l</span> <span class="main">=</span> objLoc <span class="skolem">cf</span> <span class="skolem">a</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⊢</span> <span class="skolem">l</span> <span class="keyword1">reachable_from</span> <span class="main">(</span>objV <span class="main">(</span>cls <span class="skolem">cf</span><span class="main">)</span> <span class="skolem">a</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">with</span></span> xeq <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> xeq_def<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>staticLoc <span class="skolem">f</span><span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">l</span> <span class="main">=</span> staticLoc <span class="skolem">f</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
      <span class="keyword1"><span class="command">with</span></span> static_eq <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> xeq_def<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>arrLenLoc <span class="skolem">T</span> <span class="skolem">a</span><span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">l</span> <span class="main">=</span> arrLenLoc <span class="skolem">T</span> <span class="skolem">a</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⊢</span> <span class="skolem">l</span> <span class="keyword1">reachable_from</span> <span class="main">(</span>arrV <span class="skolem">T</span> <span class="skolem">a</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">with</span></span> xeq <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> xeq_def<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>arrLoc <span class="skolem">T</span> <span class="skolem">a</span> <span class="skolem">i</span><span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">l</span> <span class="main">=</span> arrLoc <span class="skolem">T</span> <span class="skolem">a</span> <span class="skolem">i</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⊢</span> <span class="skolem">l</span> <span class="keyword1">reachable_from</span> <span class="main">(</span>arrV <span class="skolem">T</span> <span class="skolem">a</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">with</span></span> xeq <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> xeq_def<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Lemma 3.4 (iii)›</span></span>
<span class="keyword1" id="StoreProperties-xeq3"><span class="command">lemma</span></span> xeq3<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> unreach_l<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">s</span><span class="main">⊢</span> <span class="free">l</span> <span class="keyword1">reachable_from</span> <span class="free">x</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">≡[</span><span class="free">x</span><span class="main">]</span> <span class="free">s</span><span class="main">⟨</span><span class="free">l</span><span class="main">:=</span><span class="free">y</span><span class="main">⟩</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> xeqI<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"alive <span class="free">x</span> <span class="free">s</span> <span class="main">=</span> alive <span class="free">x</span> <span class="main">(</span><span class="free">s</span><span class="main">⟨</span><span class="free">l</span> <span class="main">:=</span> <span class="free">y</span><span class="main">⟩</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">k</span> 
  <span class="keyword3"><span class="command">assume</span></span> reach_k<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⊢</span> <span class="skolem">k</span> <span class="keyword1">reachable_from</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">with</span></span> unreach_l <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">l</span><span class="main">≠</span><span class="skolem">k</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">@@</span><span class="skolem">k</span> <span class="main">=</span> <span class="free">s</span><span class="main">⟨</span><span class="free">l</span> <span class="main">:=</span> <span class="free">y</span><span class="main">⟩</span><span class="main">@@</span><span class="skolem">k</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>



<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Lemma 3.4 (iv)›</span></span>
<span class="keyword1" id="StoreProperties-xeq4"><span class="command">lemma</span></span> xeq4<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> not_new<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≠</span> new <span class="free">s</span> <span class="free">t</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">≡[</span><span class="free">x</span><span class="main">]</span> <span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> xeqI<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> not_new 
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"alive <span class="free">x</span> <span class="free">s</span> <span class="main">=</span> alive <span class="free">x</span> <span class="main">(</span><span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alive_alloc_exhaust<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">l</span>
  <span class="keyword3"><span class="command">assume</span></span> reach_l<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⊢</span> <span class="skolem">l</span> <span class="keyword1">reachable_from</span> <span class="free">x</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">@@</span><span class="skolem">l</span> <span class="main">=</span> <span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span><span class="main">@@</span><span class="skolem">l</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"isNewArr <span class="free">t</span> <span class="main">⟶</span> <span class="skolem">l</span> <span class="main">≠</span> arr_len <span class="main">(</span>new <span class="free">s</span> <span class="free">t</span><span class="main">)</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword1"><span class="command">with</span></span> reach_l <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">T</span></span> <span class="skolem"><span class="skolem">n</span></span> <span class="keyword2"><span class="keyword">where</span></span> t<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">=</span> new_array <span class="skolem">T</span> <span class="skolem">n</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
                          l<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">l</span> <span class="main">=</span> arr_len <span class="main">(</span>new <span class="free">s</span> <span class="free">t</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"ref <span class="skolem">l</span> <span class="main">=</span> new <span class="free">s</span> <span class="free">t</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> this reach_l
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> new <span class="free">s</span> <span class="free">t</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> loc_new_reach<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> not_new <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Lemma 3.4 (v)›</span></span>
<span class="keyword1" id="StoreProperties-xeq5"><span class="command">lemma</span></span> xeq5<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">≡[</span><span class="free">x</span><span class="main">]</span> <span class="free">t</span> <span class="main">⟹</span> <span class="free">s</span><span class="main">⊢</span> <span class="free">l</span> <span class="keyword1">reachable_from</span> <span class="free">x</span> <span class="main">=</span> <span class="free">t</span><span class="main">⊢</span> <span class="free">l</span> <span class="keyword1">reachable_from</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> reach9<span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>  xeq_def<span class="main">)</span>
  

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹T-Equivalence›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹T-equivalence is the extension of X-equivalence from values to types. Two stores are
T-equivalent iff they are X-equivalent for all values of type T. This is formalized by the
predicate <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>teq›</span></span></span></span> \cite[p. 55]{Poetzsch-Heffter97specification}.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">teq</span><span class="main">::</span> <span class="quoted"><span class="quoted">"Javatype <span class="main">⇒</span> Store <span class="main">⇒</span> Store <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">teq</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="free"><span class="bound"><span class="entity">s1</span></span></span> <span class="free"><span class="bound"><span class="entity">s2</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">x</span><span class="main">.</span> typeof <span class="bound">x</span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">⟶</span> <span class="free"><span class="bound"><span class="entity">s1</span></span></span> <span class="main">≡[</span><span class="bound">x</span><span class="main">]</span> <span class="free"><span class="bound"><span class="entity">s2</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Less Alive›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹To specify that methods have no side-effects, the following binary relation on stores 
plays a prominent role. It expresses that the two stores differ only in values that are alive
in the store passed as first argument. This is formalized by the predicate <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>lessalive›</span></span></span></span>
\cite[p. 55]{Poetzsch-Heffter97specification}.
The stores have to be X-equivalent for the references of the
first store that are alive, and the values of the static fields have to be the same in both stores.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">lessalive</span><span class="main">::</span> <span class="quoted"><span class="quoted">"Store <span class="main">⇒</span> Store <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="quoted">"_<span class="keyword3">/ </span><span class="keyword1">≪</span> _"</span> <span class="main">[</span>70<span class="main">,</span>71<span class="main">]</span> 70<span class="main">)</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">lessalive</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="main">∀</span> <span class="bound">x</span><span class="main">.</span> alive <span class="bound">x</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">⟶</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡[</span><span class="bound">x</span><span class="main">]</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">f</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">@@</span>staticLoc <span class="bound">f</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">@@</span>staticLoc <span class="bound">f</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We define an introduction rule for the new operator.›</span></span>

<span class="keyword1" id="StoreProperties-lessaliveI"><span class="command">lemma</span></span> lessaliveI<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">⋀</span> <span class="bound">x</span><span class="main">.</span> alive <span class="bound">x</span> <span class="free">s</span> <span class="main">⟹</span>  <span class="free">s</span> <span class="main">≡[</span><span class="bound">x</span><span class="main">]</span> <span class="free">t</span><span class="main">;</span> <span class="main">⋀</span> <span class="bound">f</span><span class="main">.</span> <span class="free">s</span><span class="main">@@</span>staticLoc <span class="bound">f</span> <span class="main">=</span> <span class="free">t</span><span class="main">@@</span>staticLoc <span class="bound">f</span><span class="main">⟧</span>
   <span class="main">⟹</span> <span class="free">s</span> <span class="main">≪</span> <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lessalive_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹It can be shown that <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>lessalive›</span></span></span></span> is reflexive, transitive and antisymmetric.›</span></span>

<span class="keyword1" id="StoreProperties-lessalive_refl"><span class="command">lemma</span></span> lessalive_refl<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">≪</span> <span class="free">s</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lessalive_def xeq1_refl<span class="main">)</span>

<span class="keyword1" id="StoreProperties-lessalive_trans"><span class="command">lemma</span></span> lessalive_trans <span class="main">[</span><span class="operator">trans</span><span class="main">]</span><span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> s_t<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">≪</span> <span class="free">t</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> t_w<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">≪</span> <span class="free">w</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">≪</span> <span class="free">w</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> lessaliveI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> 
  <span class="keyword3"><span class="command">assume</span></span> alive_x_s<span class="main">:</span> <span class="quoted"><span class="quoted">"alive <span class="skolem">x</span> <span class="free">s</span>"</span></span>
  <span class="keyword1"><span class="command">with</span></span> s_t <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">≡[</span><span class="skolem">x</span><span class="main">]</span> <span class="free">t</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lessalive_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">≡[</span><span class="skolem">x</span><span class="main">]</span> <span class="free">w</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> alive_x_s s_t <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"alive <span class="skolem">x</span> <span class="free">t</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lessalive_def xeq_def<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> t_w <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lessalive_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">≡[</span><span class="skolem">x</span><span class="main">]</span> <span class="free">w</span>"</span></span><span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">f</span>
  <span class="keyword1"><span class="command">from</span></span> s_t t_w <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">@@</span>staticLoc <span class="skolem">f</span> <span class="main">=</span> <span class="free">w</span><span class="main">@@</span>staticLoc <span class="skolem">f</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lessalive_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="StoreProperties-lessalive_antisym"><span class="command">lemma</span></span> lessalive_antisym<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> s_t<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">≪</span> <span class="free">t</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> t_s<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">≪</span> <span class="free">s</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">=</span> <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> xeq2<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="free">s</span> <span class="main">≡[</span><span class="bound">x</span><span class="main">]</span> <span class="free">t</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> 
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">≡[</span><span class="skolem">x</span><span class="main">]</span> <span class="free">t</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"alive <span class="skolem">x</span> <span class="free">s</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> True
      <span class="keyword1"><span class="command">with</span></span> s_t <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lessalive_def<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">note</span></span> unalive_x_s <span class="main">=</span> this
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"alive <span class="skolem">x</span> <span class="free">t</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> True
        <span class="keyword1"><span class="command">with</span></span> t_s <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> xeq1_sym<span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lessalive_def<span class="main">)</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> False 
        <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> xeqI<span class="main">)</span>
          <span class="keyword1"><span class="command">from</span></span> False unalive_x_s <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"alive <span class="skolem">x</span> <span class="free">s</span> <span class="main">=</span> alive <span class="skolem">x</span> <span class="free">t</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">l</span> <span class="keyword3"><span class="command">assume</span></span> reach_s_x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⊢</span> <span class="skolem">l</span> <span class="keyword1">reachable_from</span> <span class="skolem">x</span>"</span></span>
          <span class="keyword1"><span class="command">with</span></span> unalive_x_s <span class="keyword1"><span class="command">have</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> ref <span class="skolem">l</span>"</span></span> 
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> ref_reach_unalive<span class="main">)</span>
          <span class="keyword1"><span class="command">with</span></span> unalive_x_s <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">@@</span><span class="skolem">l</span> <span class="main">=</span> init <span class="main">(</span>ltype <span class="skolem">l</span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> reach_s_x x <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">t</span><span class="main">⊢</span> <span class="skolem">l</span> <span class="keyword1">reachable_from</span> <span class="skolem">x</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> reach.Immediate unreachable_Null<span class="main">)</span>
          <span class="keyword1"><span class="command">with</span></span> False x <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">t</span><span class="main">@@</span><span class="skolem">l</span> <span class="main">=</span> init <span class="main">(</span>ltype <span class="skolem">l</span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">@@</span><span class="skolem">l</span> <span class="main">=</span> <span class="free">t</span><span class="main">@@</span><span class="skolem">l</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword1"><span class="command">from</span></span> s_t <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">f</span><span class="main">.</span> <span class="free">s</span><span class="main">@@</span>staticLoc <span class="bound">f</span> <span class="main">=</span> <span class="free">t</span><span class="main">@@</span>staticLoc <span class="bound">f</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lessalive_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This gives us a partial ordering on the store. Thus, the type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"Store"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
can be added to the appropriate type class <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">ord</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> which lets us define the $&lt;$ and
$\leq$ symbols, and to the type class  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">order</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> which axiomatizes partial orderings.
›</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> Store <span class="main">::</span> <span class="quoted">order</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  le_Store_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≪</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  less_Store_def<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">::</span>Store<span class="main">)</span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">∧</span> <span class="main">¬</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We prove Lemma 3.5 of \cite[p. 56]{Poetzsch-Heffter97specification} for this relation.
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Lemma 3.5 (i)›</span></span>

<span class="keyword1"><span class="command">instance</span></span>  <span class="keyword1"><span class="command">proof</span></span> 
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">s</span> <span class="skolem">t</span> <span class="skolem">w</span><span class="main">::</span> <span class="quoted"><span class="quoted">"Store"</span></span>
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s</span> <span class="main">≤</span> <span class="skolem">s</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> le_Store_def lessalive_refl<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s</span> <span class="main">≤</span> <span class="skolem">t</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">t</span> <span class="main">≤</span> <span class="skolem">w</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s</span> <span class="main">≤</span> <span class="skolem">w</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> le_Store_def<span class="main">)</span> <span class="main">(</span><span class="operator">rule</span> lessalive_trans<span class="main">)</span> 
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s</span> <span class="main">≤</span> <span class="skolem">t</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">t</span> <span class="main">≤</span> <span class="skolem">s</span>"</span></span> 
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">s</span> <span class="main">=</span> <span class="skolem">t</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> le_Store_def<span class="main">)</span> <span class="main">(</span><span class="operator">rule</span> lessalive_antisym<span class="main">)</span> 
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">s</span> <span class="main">&lt;</span> <span class="skolem">t</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">s</span> <span class="main">≤</span> <span class="skolem">t</span> <span class="main">∧</span> <span class="main">¬</span> <span class="skolem">t</span> <span class="main">≤</span> <span class="skolem">s</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> less_Store_def<span class="main">)</span>
  <span class="keyword1"><span class="command">}</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Lemma 3.5 (ii)›</span></span>
<span class="keyword1" id="StoreProperties-lessalive2"><span class="command">lemma</span></span> lessalive2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">s</span> <span class="main">≪</span> <span class="free">t</span><span class="main">;</span> alive <span class="free">x</span> <span class="free">s</span><span class="main">⟧</span> <span class="main">⟹</span> alive <span class="free">x</span> <span class="free">t</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lessalive_def xeq_def<span class="main">)</span>
  

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Lemma 3.5 (iii)›</span></span>
<span class="keyword1" id="StoreProperties-lessalive3"><span class="command">lemma</span></span> lessalive3<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> s_t<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">≪</span> <span class="free">t</span>"</span></span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> alive<span class="main">:</span> <span class="quoted"><span class="quoted">"alive <span class="free">x</span> <span class="free">s</span> <span class="main">∨</span> <span class="main">¬</span> alive <span class="free">x</span> <span class="free">t</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">≡[</span><span class="free">x</span><span class="main">]</span> <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"alive <span class="free">x</span> <span class="free">s</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword1"><span class="command">with</span></span> s_t <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lessalive_def<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword1"><span class="command">note</span></span> unalive_x_s <span class="main">=</span> this
  <span class="keyword1"><span class="command">with</span></span> alive <span class="keyword1"><span class="command">have</span></span> unalive_x_t<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> alive <span class="free">x</span> <span class="free">t</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> xeqI<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> False alive <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"alive <span class="free">x</span> <span class="free">s</span> <span class="main">=</span> alive <span class="free">x</span> <span class="free">t</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">l</span> <span class="keyword3"><span class="command">assume</span></span> reach_s_x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⊢</span> <span class="skolem">l</span> <span class="keyword1">reachable_from</span> <span class="free">x</span>"</span></span>
    <span class="keyword1"><span class="command">with</span></span> unalive_x_s <span class="keyword1"><span class="command">have</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> ref <span class="skolem">l</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> ref_reach_unalive<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> unalive_x_s <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">@@</span><span class="skolem">l</span> <span class="main">=</span> init <span class="main">(</span>ltype <span class="skolem">l</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> reach_s_x x <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">t</span><span class="main">⊢</span> <span class="skolem">l</span> <span class="keyword1">reachable_from</span> <span class="free">x</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> reach.Immediate unreachable_Null<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> unalive_x_t x <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">t</span><span class="main">@@</span><span class="skolem">l</span> <span class="main">=</span> init <span class="main">(</span>ltype <span class="skolem">l</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">@@</span><span class="skolem">l</span> <span class="main">=</span> <span class="free">t</span><span class="main">@@</span><span class="skolem">l</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>
   
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Lemma 3.5 (iv)›</span></span>
<span class="keyword1" id="StoreProperties-lessalive_update"><span class="command">lemma</span></span> lessalive_update <span class="main">[</span><span class="operator">simp</span><span class="main">,</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> s_t<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">≪</span> <span class="free">t</span>"</span></span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> unalive_l<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> alive <span class="main">(</span>ref <span class="free">l</span><span class="main">)</span> <span class="free">t</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">≪</span> <span class="free">t</span><span class="main">⟨</span><span class="free">l</span><span class="main">:=</span><span class="free">x</span><span class="main">⟩</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> unalive_l <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">t</span><span class="main">⟨</span><span class="free">l</span><span class="main">:=</span><span class="free">x</span><span class="main">⟩</span> <span class="main">=</span> <span class="free">t</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">with</span></span> s_t <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="StoreProperties-Xequ4'"><span class="command">lemma</span></span> Xequ4'<span class="main">:</span>  
  <span class="keyword2"><span class="keyword">assumes</span></span> alive<span class="main">:</span> <span class="quoted"><span class="quoted">"alive <span class="free">x</span> <span class="free">s</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">≡[</span><span class="free">x</span><span class="main">]</span> <span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> alive <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≠</span> new <span class="free">s</span> <span class="free">t</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> xeq4<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

  

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Lemma 3.5 (v)›</span></span>
<span class="keyword1" id="StoreProperties-lessalive_alloc"><span class="command">lemma</span></span> lessalive_alloc <span class="main">[</span><span class="operator">simp</span><span class="main">,</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">≪</span> <span class="free">s</span><span class="main">⟨</span><span class="free">t</span><span class="main">⟩</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lessalive_def Xequ4'<span class="main">)</span>
 

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Reachability of Types from Types›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The predicate <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>treach›</span></span></span></span> denotes the fact that the first type reaches 
the second type by stepping finitely many times from a type to the range type of one 
of its fields. This formalization diverges from \cite[p. 106]{Poetzsch-Heffter97specification} 
in that it does not include the number of steps that are allowed to reach the second type.
Reachability of types is a static approximation of reachability in
the store. If I cannot reach the type of a location from the type of a
reference, I cannot reach the location from the reference. See lemma  
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>not_treach_ref_impl_not_reach›</span></span></span></span> below.
›</span></span>

<span class="keyword1"><span class="command">inductive</span></span>
  <span class="entity">treach</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Javatype <span class="main">⇒</span> Javatype <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  Subtype<span class="main">:</span>       <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">U</span></span></span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">T</span></span></span> <span class="main">⟹</span> <span class="free">treach</span> <span class="free"><span class="bound"><span class="entity">T</span></span></span> <span class="free"><span class="bound"><span class="entity">U</span></span></span>"</span></span>
<span class="main">|</span> Attribute<span class="main">:</span>     <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">treach</span> <span class="free"><span class="bound"><span class="entity">T</span></span></span> <span class="free"><span class="bound"><span class="entity">S</span></span></span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="main">≤</span> dtype <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">U</span></span></span> <span class="main">≤</span> rtype <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⟧</span>  <span class="main">⟹</span> <span class="free">treach</span> <span class="free"><span class="bound"><span class="entity">T</span></span></span> <span class="free"><span class="bound"><span class="entity">U</span></span></span>"</span></span>
<span class="main">|</span> ArrLength<span class="main">:</span>     <span class="quoted"><span class="quoted">"<span class="free">treach</span> <span class="main">(</span>ArrT <span class="free"><span class="bound"><span class="entity">AT</span></span></span><span class="main">)</span> IntgT"</span></span>
<span class="main">|</span> ArrElem<span class="main">:</span>       <span class="quoted"><span class="quoted">"<span class="free">treach</span> <span class="main">(</span>ArrT <span class="free"><span class="bound"><span class="entity">AT</span></span></span><span class="main">)</span> <span class="main">(</span>at2jt <span class="free"><span class="bound"><span class="entity">AT</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> Trans <span class="main">[</span><span class="operator">trans</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">treach</span> <span class="free"><span class="bound"><span class="entity">T</span></span></span> <span class="free"><span class="bound"><span class="entity">U</span></span></span><span class="main">;</span> <span class="free">treach</span> <span class="free"><span class="bound"><span class="entity">U</span></span></span> <span class="free"><span class="bound"><span class="entity">V</span></span></span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">treach</span> <span class="free"><span class="bound"><span class="entity">T</span></span></span> <span class="free"><span class="bound"><span class="entity">V</span></span></span>"</span></span>


<span class="keyword1" id="StoreProperties-treach_ref_l"><span class="command">lemma</span></span> treach_ref_l <span class="main">[</span><span class="operator">simp</span><span class="main">,</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> not_Null<span class="main">:</span> <span class="quoted"><span class="quoted">"ref <span class="free">l</span> <span class="main">≠</span> nullV"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"treach <span class="main">(</span>typeof <span class="main">(</span>ref <span class="free">l</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>ltype <span class="free">l</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">l</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>objLoc <span class="skolem">cf</span> <span class="skolem">a</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">l</span><span class="main">=</span>objLoc <span class="skolem">cf</span> <span class="skolem">a</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"treach <span class="main">(</span>CClassT <span class="main">(</span>cls <span class="skolem">cf</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>rtype <span class="main">(</span>att <span class="skolem">cf</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> treach.Attribute <span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="var">?f</span><span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"att <span class="skolem"><span class="skolem"><span class="skolem">cf</span></span></span>"</span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> <span class="var">?S</span><span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"CClassT <span class="main"><span class="main"><span class="main">(</span></span></span>cls <span class="skolem"><span class="skolem"><span class="skolem">cf</span></span></span><span class="main"><span class="main"><span class="main">)</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
       <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> treach.Subtype<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>staticLoc <span class="skolem">f</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">l</span><span class="main">=</span>staticLoc <span class="skolem">f</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"ref <span class="free">l</span> <span class="main">=</span> nullV"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">with</span></span> not_Null <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>arrLenLoc <span class="skolem">T</span> <span class="skolem">a</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">l</span><span class="main">=</span>arrLenLoc <span class="skolem">T</span> <span class="skolem">a</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> treach.ArrLength<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>arrLoc <span class="skolem">T</span> <span class="skolem">a</span> <span class="skolem">i</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">l</span><span class="main">=</span>arrLoc <span class="skolem">T</span> <span class="skolem">a</span> <span class="skolem">i</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> treach.ArrElem<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="StoreProperties-treach_ref_l'"><span class="command">lemma</span></span> treach_ref_l' <span class="main">[</span><span class="operator">simp</span><span class="main">,</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> not_Null<span class="main">:</span> <span class="quoted"><span class="quoted">"ref <span class="free">l</span> <span class="main">≠</span> nullV"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"treach <span class="main">(</span>typeof <span class="main">(</span>ref <span class="free">l</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>typeof <span class="main">(</span><span class="free">s</span><span class="main">@@</span><span class="free">l</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> not_Null <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"treach <span class="main">(</span>typeof <span class="main">(</span>ref <span class="free">l</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>ltype <span class="free">l</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> treach_ref_l<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"typeof <span class="main">(</span><span class="free">s</span><span class="main">@@</span><span class="free">l</span><span class="main">)</span> <span class="main">≤</span> ltype <span class="free">l</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"treach <span class="main">(</span>ltype <span class="free">l</span><span class="main">)</span> <span class="main">(</span>typeof <span class="main">(</span><span class="free">s</span><span class="main">@@</span><span class="free">l</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> treach.intros<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>
  

<span class="keyword1" id="StoreProperties-reach_impl_treach"><span class="command">lemma</span></span> reach_impl_treach<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> reach_l<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">⊢</span> <span class="free">l</span> <span class="keyword1">reachable_from</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"treach <span class="main">(</span>typeof <span class="free">x</span><span class="main">)</span> <span class="main">(</span>ltype <span class="free">l</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> reach_l
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Immediate <span class="skolem">l</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ref <span class="skolem">l</span> <span class="main">≠</span> nullV"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"treach <span class="main">(</span>typeof <span class="main">(</span>ref <span class="skolem">l</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>ltype <span class="skolem">l</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> treach_ref_l<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Indirect <span class="skolem">l</span> <span class="skolem">k</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"treach <span class="main">(</span>typeof <span class="main">(</span><span class="free">s</span><span class="main">@@</span><span class="skolem">k</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>ltype <span class="skolem">l</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"ref <span class="skolem">k</span> <span class="main">≠</span> nullV"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"treach <span class="main">(</span>typeof <span class="main">(</span>ref <span class="skolem">k</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>typeof <span class="main">(</span><span class="free">s</span><span class="main">@@</span><span class="skolem">k</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"treach <span class="main">(</span>typeof <span class="main">(</span>ref <span class="skolem">k</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>ltype <span class="skolem">l</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">iprover</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> treach.Trans<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="StoreProperties-not_treach_ref_impl_not_reach"><span class="command">lemma</span></span> not_treach_ref_impl_not_reach<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> not_treach<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> treach <span class="main">(</span>typeof <span class="free">x</span><span class="main">)</span> <span class="main">(</span>typeof <span class="main">(</span>ref <span class="free">l</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">s</span> <span class="main">⊢</span> <span class="free">l</span> <span class="keyword1">reachable_from</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> 
  <span class="keyword3"><span class="command">assume</span></span> reach_l<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">⊢</span> <span class="free">l</span> <span class="keyword1">reachable_from</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> this not_treach
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Immediate <span class="skolem">l</span><span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> treach <span class="main">(</span>typeof <span class="main">(</span>ref <span class="skolem">l</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>typeof <span class="main">(</span>ref <span class="skolem">l</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">iprover</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> treach.intros order_refl<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Indirect <span class="skolem">l</span> <span class="skolem">k</span><span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> hyp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> treach <span class="main">(</span>typeof <span class="main">(</span><span class="free">s</span><span class="main">@@</span><span class="skolem">k</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>typeof <span class="main">(</span>ref <span class="skolem">l</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> False"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
    <span class="keyword1"><span class="command">have</span></span> not_Null<span class="main">:</span> <span class="quoted"><span class="quoted">"ref <span class="skolem">k</span> <span class="main">≠</span> nullV"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
    <span class="keyword1"><span class="command">have</span></span> not_k_l<span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">¬</span> treach <span class="main">(</span>typeof <span class="main">(</span>ref <span class="skolem">k</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>typeof <span class="main">(</span>ref <span class="skolem">l</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"treach <span class="main">(</span>typeof <span class="main">(</span><span class="free">s</span><span class="main">@@</span><span class="skolem">k</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>typeof <span class="main">(</span>ref <span class="skolem">l</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> False <span class="keyword3"><span class="command">thus</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> hyp<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> True
      <span class="keyword1"><span class="command">from</span></span> not_Null <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"treach <span class="main">(</span>typeof <span class="main">(</span>ref <span class="skolem">k</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>typeof <span class="main">(</span><span class="free">s</span><span class="main">@@</span><span class="skolem">k</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> treach_ref_l'<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> True
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"treach <span class="main">(</span>typeof <span class="main">(</span>ref <span class="skolem">k</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>typeof <span class="main">(</span>ref <span class="skolem">l</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
      <span class="keyword1"><span class="command">with</span></span> not_k_l <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">..</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Lemma 4.6 in \cite[p. 107]{Poetzsch-Heffter97specification}.›</span></span>
<span class="keyword1" id="StoreProperties-treach1"><span class="command">lemma</span></span> treach1<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> x_t<span class="main">:</span> <span class="quoted"><span class="quoted">"typeof <span class="free">x</span> <span class="main">≤</span> <span class="free">T</span>"</span></span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> not_treach<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> treach <span class="free">T</span> <span class="main">(</span>typeof <span class="main">(</span>ref <span class="free">l</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">s</span> <span class="main">⊢</span> <span class="free">l</span> <span class="keyword1">reachable_from</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> treach <span class="main">(</span>typeof <span class="free">x</span><span class="main">)</span> <span class="main">(</span>typeof <span class="main">(</span>ref <span class="free">l</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> 
    <span class="keyword1"><span class="command">from</span></span> x_t <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"treach <span class="free">T</span> <span class="main">(</span>typeof <span class="free">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> treach.intros<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"treach <span class="main">(</span>typeof <span class="free">x</span><span class="main">)</span> <span class="main">(</span>typeof <span class="main">(</span>ref <span class="free">l</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"treach <span class="free">T</span> <span class="main">(</span>typeof <span class="main">(</span>ref <span class="free">l</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">with</span></span> not_treach <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> not_treach_ref_impl_not_reach<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

  
<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="JML">
<div class="head">
<h1>Theory JML</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Jive Data and Store Model
    Author:      Norbert Schirmer &lt;schirmer at informatik.tu-muenchen.de&gt;  and  
                 Nicole Rauch &lt;rauch at informatik.uni-kl.de&gt;, 2005
    Maintainer:  Nicole Rauch &lt;rauch at informatik.uni-kl.de&gt;
    License:     LGPL
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹The Formalization of JML Operators›</span></span>

<span class="keyword1"><span class="command">theory</span></span> JML <span class="keyword2"><span class="keyword">imports</span></span> <span class="quoted">"<a href="#StoreProperties">../Isabelle_Store/StoreProperties</a>"</span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹JML operators that are to be used in Hoare formulae can be formalized here.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">instanceof</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Value <span class="main">⇒</span> Javatype <span class="main">⇒</span> bool"</span></span>  <span class="main">(</span><span class="quoted">"_ <span class="keyword1">@instanceof</span> _"</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">instanceof</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">=</span> <span class="main">(</span>typeof <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="UnivSpec">
<div class="head">
<h1>Theory UnivSpec</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:       Jive Data and Store Model
    Author:      Nicole Rauch &lt;rauch at informatik.uni-kl.de&gt;, 2005
    Maintainer:  Nicole Rauch &lt;rauch at informatik.uni-kl.de&gt;
    License:     LGPL
*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹The Universal Specification›</span></span>

<span class="keyword1"><span class="command">theory</span></span> UnivSpec <span class="keyword2"><span class="keyword">imports</span></span> <span class="quoted">"<a href="#JML">../Isabelle/JML</a>"</span>  <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This theory contains the Isabelle formalization of the
program-dependent specification. This theory has to be provided by the user.
In later versions of Jive, one may be able to generate it from JML model
classes.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
<span class="entity">aCounter</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Value <span class="main">⇒</span> Store <span class="main">⇒</span> JavaInt"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">aCounter</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">~=</span> nullV <span class="main">&amp;</span> <span class="main">(</span>alive <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="main">&amp;</span> typeof <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> CClassT CounterImpl <span class="keyword1">then</span>
    aI <span class="main">(</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">@@</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">..</span>CounterImpl'value<span class="main">)</span> <span class="main">)</span>
   <span class="keyword1">else</span> undefined<span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div>