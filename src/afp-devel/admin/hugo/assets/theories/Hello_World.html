<div id="IO">
<div class="head">
<h1>Theory IO</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">theory</span></span> IO
  <span class="keyword2"><span class="keyword">imports</span></span>
    <a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL/Main.html">Main</a>
    <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/Monad_Syntax.html">HOL-Library.Monad_Syntax</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‚ÄπIO Monad‚Ä∫</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‚Äπ
  Inspired by Haskell.
  Definitions from <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">üåê</span></span>‚Äπhttps://wiki.haskell.org/IO_inside‚Ä∫</span></span>
‚Ä∫</span></span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‚ÄπReal World‚Ä∫</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‚Äπ
  We model the real world with a fake type.

  WARNING:
    Using low-level commands such as <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚¨ö</span></span><span class="raw_text"><span class="raw_text">‚Äπ<span class="keyword1"><span class="command"><span class="keyword1"><span class="command">typedecl</span></span></span></span>‚Ä∫</span></span></span></span> instead of high-level <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚¨ö</span></span><span class="raw_text"><span class="raw_text">‚Äπ<span class="keyword1"><span class="command"><span class="keyword1"><span class="command">datatype</span></span></span></span>‚Ä∫</span></span></span></span> is dangerous.
    We explicitly use a <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚¨ö</span></span><span class="raw_text"><span class="raw_text">‚Äπ<span class="keyword1"><span class="command"><span class="keyword1"><span class="command">typedecl</span></span></span></span>‚Ä∫</span></span></span></span> instead of a <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚¨ö</span></span><span class="raw_text"><span class="raw_text">‚Äπ<span class="keyword1"><span class="command"><span class="keyword1"><span class="command">datatype</span></span></span></span>‚Ä∫</span></span></span></span> because we never want to instantiate
    the world. We don't need a constructor, we just need the type.

  The following models an arbitrary type we cannot reason about.
  Don't reason about the complete world! Only write down some assumptions about parts of the world.
‚Ä∫</span></span>
<span class="keyword1"><span class="command">typedecl</span></span> real_world <span class="main">(</span><span class="quoted">‚Äπ<span class="keyword1">üåê</span>‚Ä∫</span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‚Äπ
  For examples, see <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">üóè</span></span>‚ÄπHelloWorld_Proof.thy‚Ä∫</span></span>.
  In said theory, we model <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚ÄπSTDIN‚Ä∫</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚ÄπSTDOUT‚Ä∫</span></span></span></span> as parts of the world and describe how this part
  of the wold can be affected. We don't model the rest of the world. This allows us to reason about
  <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚ÄπSTDIN‚Ä∫</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚ÄπSTDOUT‚Ä∫</span></span></span></span> as part of the world, but nothing more.
‚Ä∫</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‚ÄπIO Monad‚Ä∫</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‚Äπ
  The set of all functions which take a <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="main"><span class="main">üåê</span></span>‚Ä∫</span></span></span></span> and return an <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="tfree"><span class="tfree">'Œ±</span></span>‚Ä∫</span></span></span></span> and a <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="main"><span class="main">üåê</span></span>‚Ä∫</span></span></span></span>.

  The rough idea of all IO functions is the following: You are given the world in its current state.
  You can do whatever you like to the world. You can produce some value of type <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="tfree"><span class="tfree">'Œ±</span></span>‚Ä∫</span></span></span></span> and you
  have to return the modified world.

  For example, the <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚Äπmain‚Ä∫</span></span></span></span> function is Haskell does not produce a value, therefore, <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚Äπmain‚Ä∫</span></span></span></span> in
  Haskell is of type <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚ÄπIO ()‚Ä∫</span></span></span></span>. Another example in Haskell is <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚ÄπgetLine‚Ä∫</span></span></span></span>, which returns <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚ÄπString‚Ä∫</span></span></span></span>.
  It's type in Haskell is <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚ÄπIO String‚Ä∫</span></span></span></span>. All those functions may also modify the state of the world.
‚Ä∫</span></span>

<span class="keyword1"><span class="command">typedef</span></span> <span class="tfree">'Œ±</span> io <span class="main">=</span> <span class="quoted"><span class="quoted">"UNIV <span class="main">::</span> <span class="main">(</span><span class="main">üåê</span> <span class="main">‚áí</span> <span class="tfree">'Œ±</span> <span class="main">√ó</span> <span class="main">üåê</span><span class="main">)</span> set"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">‚àÉ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">‚àà</span> UNIV"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‚Äπ
  Related Work:
  <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚àó</span></span>‚ÄπProgramming TLS in Isabelle/HOL‚Ä∫</span></span> by Andreas Lochbihler and Marc Z√ºst uses a partial function
  (<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‚Äπ</span></span>‚áÄ‚Ä∫</span></span></span></span>).
  <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚¨ö</span></span><span class="raw_text"><span class="raw_text">‚Äπ
    <span class="keyword1"><span class="command"><span class="keyword1"><span class="command">typedecl</span></span></span></span> real_world
    <span class="keyword1"><span class="command"><span class="keyword1"><span class="command">typedef</span></span></span></span> <span class="tfree"><span class="tfree">'Œ±</span></span> io <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"UNIV :: (üåê ‚áÄ 'Œ± √ó üåê) set"</span></span> <span class="keyword1"><span class="command"><span class="keyword1"><span class="command">by</span></span></span></span> simp
  ‚Ä∫</span></span></span></span>
  We use a total function. This implies the dangerous assumption that all IO functions are total
  (i.e., terminate).
‚Ä∫</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‚Äπ
  The <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚¨ö</span></span><span class="raw_text"><span class="raw_text">‚Äπ<span class="keyword1"><span class="command"><span class="keyword1"><span class="command">typedef</span></span></span></span>‚Ä∫</span></span></span></span> above gives us some convenient definitions.
  Since the model of <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="tfree"><span class="tfree">'Œ±</span></span> io‚Ä∫</span></span></span></span> is just a mode, those definitions should not end up in generated
  code.
‚Ä∫</span></span>
<span class="keyword1"><span class="command">term</span></span> <span class="quoted">Abs_io</span> <span class="comment1">‚Äï ‚ÄπTakes a <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span><span class="quoted">‚Äπ<span class="main">(</span><span class="main">üåê</span> <span class="main">‚áí</span> <span class="tfree">'Œ±</span> <span class="main">√ó</span> <span class="main">üåê</span><span class="main">)</span>‚Ä∫</span></span> and abstracts it to an <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span><span class="quoted">‚Äπ<span class="tfree">'Œ±</span> io‚Ä∫</span></span>.‚Ä∫</span>
<span class="keyword1"><span class="command">term</span></span> <span class="quoted">Rep_io</span> <span class="comment1">‚Äï ‚ÄπUnpacks an <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span><span class="quoted">‚Äπ<span class="tfree">'Œ±</span> io‚Ä∫</span></span> to a <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span><span class="quoted">‚Äπ<span class="main">(</span><span class="main">üåê</span> <span class="main">‚áí</span> <span class="tfree">'Œ±</span> <span class="main">√ó</span> <span class="main">üåê</span><span class="main">)</span>‚Ä∫</span></span>‚Ä∫</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‚ÄπMonad Operations‚Ä∫</span></span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‚Äπ
  Within an <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="tfree"><span class="tfree">'Œ±</span></span> io‚Ä∫</span></span></span></span> context, execute <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="free"><span class="free">action<span class="hidden">‚á©</span><sub>1</sub></span></span>‚Ä∫</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="free"><span class="free">action<span class="hidden">‚á©</span><sub>2</sub></span></span>‚Ä∫</span></span></span></span> sequentially.
  The world is passed through and potentially modified by each action.
‚Ä∫</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'Œ±</span> io <span class="main">‚áí</span> <span class="main">(</span><span class="tfree">'Œ±</span> <span class="main">‚áí</span> <span class="tfree">'Œ≤</span> io<span class="main">)</span> <span class="main">‚áí</span> <span class="tfree">'Œ≤</span> io"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">bind</span> <span class="free"><span class="bound"><span class="entity">action<span class="hidden">‚á©</span><sub>1</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">action<span class="hidden">‚á©</span><sub>2</sub></span></span></span> <span class="main">=</span> Abs_io <span class="main">(</span><span class="main">Œª</span><span class="bound">world<span class="hidden">‚á©</span><sub>0</sub></span><span class="main">.</span>
                                  <span class="keyword1">let</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">world<span class="hidden">‚á©</span><sub>1</sub></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Rep_io <span class="free"><span class="bound"><span class="entity">action<span class="hidden">‚á©</span><sub>1</sub></span></span></span><span class="main">)</span> <span class="bound">world<span class="hidden">‚á©</span><sub>0</sub></span><span class="main">;</span>
                                      <span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="bound">world<span class="hidden">‚á©</span><sub>2</sub></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Rep_io <span class="main">(</span><span class="free"><span class="bound"><span class="entity">action<span class="hidden">‚á©</span><sub>2</sub></span></span></span> <span class="bound">a</span><span class="main">)</span><span class="main">)</span> <span class="bound">world<span class="hidden">‚á©</span><sub>1</sub></span>
                                  <span class="keyword1">in</span> <span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="bound">world<span class="hidden">‚á©</span><sub>2</sub></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‚Äπ
  In Haskell, the definition for <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚Äπbind‚Ä∫</span></span></span></span> (<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚Äπ&gt;&gt;=‚Ä∫</span></span></span></span>) is:
  <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚Äπ
    (&gt;&gt;=) :: IO a -&gt; (a -&gt; IO b) -&gt; IO b
    (action1 &gt;&gt;= action2) world0 =
       let (a, world1) = action1 world0
           (b, world2) = action2 a world1
       in (b, world2)
  ‚Ä∫</span></span></span></span>
‚Ä∫</span></span>

<span class="keyword1"><span class="command">hide_const</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="main">)</span> bind
<span class="keyword1"><span class="command">adhoc_overloading</span></span> bind <span class="quoted">IO.bind</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‚ÄπThanks to <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚¨ö</span></span><span class="raw_text"><span class="raw_text">‚Äπ<span class="keyword1"><span class="command"><span class="keyword1"><span class="command">adhoc_overloading</span></span></span></span>‚Ä∫</span></span></span></span>, we can use monad syntax.‚Ä∫</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"bind <span class="main">(</span><span class="free">foo</span> <span class="main">::</span> <span class="tfree">'Œ±</span> io<span class="main">)</span> <span class="main">(</span><span class="main">Œª</span><span class="bound">a</span><span class="main">.</span> <span class="free">bar</span> <span class="bound">a</span><span class="main">)</span> <span class="main">=</span> <span class="free">foo</span> <span class="main">‚§ú</span> <span class="main">(</span><span class="main">Œª</span><span class="bound">a</span><span class="main">.</span> <span class="free">bar</span> <span class="bound">a</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'Œ±</span> <span class="main">‚áí</span> <span class="tfree">'Œ±</span> io"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">return</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">‚â°</span> Abs_io <span class="main">(</span><span class="main">Œª</span><span class="bound">world</span><span class="main">.</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">,</span> <span class="bound">world</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">hide_const</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="main">)</span> return

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‚Äπ
  In Haskell, the definition for <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚Äπreturn‚Ä∫</span></span></span></span> is::
  <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚Äπ
    return :: a -&gt; IO a
    return a world0  =  (a, world0)
  ‚Ä∫</span></span></span></span>
‚Ä∫</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‚ÄπMonad Laws‚Ä∫</span></span>
<span class="keyword1" id="IO-left_id"><span class="command">lemma</span></span> left_id<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'Œ±</span> <span class="main">‚áí</span> <span class="tfree">'Œ≤</span> io"</span></span> <span class="comment1">‚Äï ‚ÄπMake sure we use our <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const</span><span class="hidden">&gt;</span></span>‚ÄπIO.bind‚Ä∫</span>.‚Ä∫</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>IO.return <span class="free">a</span> <span class="main">‚§ú</span> <span class="free">f</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="free">a</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> return_def IO.bind_def Abs_io_inverse Rep_io_inverse<span class="main">)</span>

<span class="keyword1" id="IO-right_id"><span class="command">lemma</span></span> right_id<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">m</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'Œ±</span> io"</span></span> <span class="comment1">‚Äï ‚ÄπMake sure we use our <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const</span><span class="hidden">&gt;</span></span>‚ÄπIO.bind‚Ä∫</span>.‚Ä∫</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">m</span> <span class="main">‚§ú</span> IO.return<span class="main">)</span> <span class="main">=</span> <span class="free">m</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> return_def IO.bind_def Abs_io_inverse Rep_io_inverse<span class="main">)</span>
    
<span class="keyword1" id="IO-bind_assoc"><span class="command">lemma</span></span> bind_assoc<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">m</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'Œ±</span> io"</span></span> <span class="comment1">‚Äï ‚ÄπMake sure we use our <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const</span><span class="hidden">&gt;</span></span>‚ÄπIO.bind‚Ä∫</span>.‚Ä∫</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">m</span> <span class="main">‚§ú</span> <span class="free">f</span><span class="main">)</span> <span class="main">‚§ú</span> <span class="free">g</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">m</span> <span class="main">‚§ú</span> <span class="main">(</span><span class="main">Œª</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">‚§ú</span> <span class="free">g</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> IO.bind_def Abs_io_inverse Abs_io_inject fun_eq_iff <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‚ÄπCode Generator Setup‚Ä∫</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‚Äπ
  We don't expose our <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const</span><span class="hidden">&gt;</span></span></span>‚ÄπIO.bind‚Ä∫</span></span> definition to code.
  We use the built-in definitions of the target language (e.g., Haskell, SML).
‚Ä∫</span></span>
<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">IO.bind</span> <span class="main">‚áÄ</span> <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"_ &gt;&gt;= _"</span>
                                  <span class="keyword2"><span class="keyword">and</span></span> <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"bind"</span>
            <span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">IO.return</span> <span class="main">‚áÄ</span> <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"return"</span>
                                    <span class="keyword2"><span class="keyword">and</span></span> <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"(() =&gt; _)"</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‚ÄπSML does not come with a bind function. We just define it (hopefully correct).‚Ä∫</span></span>
<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">code_module</span></span> Bind <span class="main">‚áÄ</span> <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">‚Äπ
fun bind x f () = f (x ()) ();
‚Ä∫</span>
<span class="keyword1"><span class="command">code_reserved</span></span> SML bind return
  
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‚Äπ
  Make sure the code generator does not try to define <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="tfree"><span class="tfree">'Œ±</span></span> io‚Ä∫</span></span></span></span> by itself, but always uses
  the one of the target language.
  For Haskell, this is the fully qualified Prelude.IO.
  For SML, we wrap it in a nullary function.
‚Ä∫</span></span>
<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">type_constructor</span></span> io <span class="main">‚áÄ</span> <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"Prelude.IO _"</span>
                                     <span class="keyword2"><span class="keyword">and</span></span> <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"unit -&gt; _"</span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‚Äπ
In Isabelle, a <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπstring‚Ä∫</span></span></span></span> is just a type synonym for <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπchar list‚Ä∫</span></span></span></span>.
When translating a <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπstring‚Ä∫</span></span></span></span> to Haskell, Isabelle does not use Haskell's <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚ÄπString‚Ä∫</span></span></span></span> or 
<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚Äπ[Prelude.Char]‚Ä∫</span></span></span></span>. Instead, Isabelle serializes its own
  <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚Äπdata Char = Char Bool Bool Bool Bool Bool Bool Bool Bool‚Ä∫</span></span></span></span>.
The resulting code will look just ugly.

To use the native strings of Haskell, we use the Isabelle type <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚ÄπString.literal‚Ä∫</span></span></span></span>.
This gets translated to a Haskell <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚ÄπString‚Ä∫</span></span></span></span>.

A string literal in Isabelle is created with <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="keyword1"><span class="keyword1">STR</span></span> <span class="inner_quoted"><span class="inner_quoted">''foo''</span></span> <span class="main"><span class="main">::</span></span> String.literal‚Ä∫</span></span></span></span>.
‚Ä∫</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‚Äπ
  We define IO functions in Isabelle without implementation.
  For a proof in Isabelle, we will only describe their externally observable properties.
  For code generation, we map those functions to the corresponding function of the target language.

  Our assumption is that our description in Isabelle corresponds to the real behavior of those
  functions in the respective target language.

  We use <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚¨ö</span></span><span class="raw_text"><span class="raw_text">‚Äπ<span class="keyword1"><span class="command"><span class="keyword1"><span class="command">axiomatization</span></span></span></span>‚Ä∫</span></span></span></span> instead of <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚¨ö</span></span><span class="raw_text"><span class="raw_text">‚Äπ<span class="keyword1"><span class="command"><span class="keyword1"><span class="command">consts</span></span></span></span>‚Ä∫</span></span></span></span> to axiomatically define that those functions exist,
  but there is no implementation of them. This makes sure that we have to explicitly write down all
  our assumptions about their behavior. Currently, no assumptions (apart from their type) can be
  made about those functions.
‚Ä∫</span></span>
<span class="keyword1"><span class="command">axiomatization</span></span>
  <span class="free">println</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"String.literal <span class="main">‚áí</span> unit io"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="free">getLine</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"String.literal io"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‚ÄπA Haskell module named <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚ÄπStdIO‚Ä∫</span></span></span></span> which just implements <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚Äπprintln‚Ä∫</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚ÄπgetLine‚Ä∫</span></span></span></span>.‚Ä∫</span></span>
<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">code_module</span></span> StdIO <span class="main">‚áÄ</span> <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">‚Äπ
module StdIO (println, getLine) where
import qualified Prelude (putStrLn, getLine)
println = Prelude.putStrLn
getLine = Prelude.getLine
‚Ä∫</span>                              <span class="keyword2"><span class="keyword">and</span></span> <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">‚Äπ
(* Newline behavior in SML is odd.*)
fun println s () = TextIO.print (s ^ "\n");
fun getLine () = case (TextIO.inputLine TextIO.stdIn) of
                  SOME s =&gt; String.substring (s, 0, String.size s - 1)
                | NONE =&gt; raise Fail "getLine";
‚Ä∫</span>

<span class="keyword1"><span class="command">code_reserved</span></span> Haskell StdIO println getLine
<span class="keyword1"><span class="command">code_reserved</span></span> SML println print getLine TextIO

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‚Äπ
  When the code generator sees the functions <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const</span><span class="hidden">&gt;</span></span></span>‚Äπprintln‚Ä∫</span></span> or <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const</span><span class="hidden">&gt;</span></span></span>‚ÄπgetLine‚Ä∫</span></span>, we tell it to use
  our language-specific implementation.
  ‚Ä∫</span></span>
<span class="keyword1"><span class="command">code_printing</span></span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">println</span> <span class="main">‚áÄ</span> <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"StdIO.println"</span>
                              <span class="keyword2"><span class="keyword">and</span></span> <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"println"</span>
            <span class="main">|</span> <span class="keyword2"><span class="keyword">constant</span></span> <span class="quoted">getLine</span> <span class="main">‚áÄ</span> <span class="main">(</span>Haskell<span class="main">)</span> <span class="quoted">"StdIO.getLine"</span>
                              <span class="keyword2"><span class="keyword">and</span></span> <span class="main">(</span>SML<span class="main">)</span> <span class="quoted">"getLine"</span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‚ÄπMonad syntax and <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const</span><span class="hidden">&gt;</span></span></span>‚Äπprintln‚Ä∫</span></span> examples.‚Ä∫</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"bind <span class="main">(</span>println <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''foo''</span><span class="main">)</span><span class="main">)</span>
            <span class="main">(</span><span class="main">Œª</span><span class="main"><span class="bound">_</span></span><span class="main">.</span>  println <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''bar''</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
       println <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''foo''</span><span class="main">)</span> <span class="main">‚§ú</span> <span class="main">(</span><span class="main">Œª</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> println <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''bar''</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> 
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">do</span> <span class="main">{</span> <span class="main"><span class="bound">_</span></span> <span class="main">‚Üê</span> println <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''foo''</span><span class="main">)</span><span class="main">;</span>
            println <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''bar''</span><span class="main">)</span><span class="main">}</span> <span class="main">=</span>
      println <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''foo''</span><span class="main">)</span> <span class="main">‚™¢</span> <span class="main">(</span>println <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''bar''</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>



<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‚ÄπModelling Running an <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="tfree"><span class="tfree">'Œ±</span></span> io‚Ä∫</span></span></span></span> Function‚Ä∫</span></span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‚Äπ
  Apply some function <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="free"><span class="free">iofun</span></span> <span class="main"><span class="main">::</span></span> <span class="tfree"><span class="tfree">'Œ±</span></span> io‚Ä∫</span></span></span></span> to a specific world and return the new world
  (discarding the result of <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="free"><span class="free">iofun</span></span>‚Ä∫</span></span></span></span>).
‚Ä∫</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">exec</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'Œ±</span> io <span class="main">‚áí</span> <span class="main">üåê</span> <span class="main">‚áí</span> <span class="main">üåê</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">exec</span> <span class="free"><span class="bound"><span class="entity">iofun</span></span></span> <span class="free"><span class="bound"><span class="entity">world</span></span></span> <span class="main">=</span> snd <span class="main">(</span>Rep_io <span class="free"><span class="bound"><span class="entity">iofun</span></span></span> <span class="free"><span class="bound"><span class="entity">world</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‚ÄπSimilar, but only get the result.‚Ä∫</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">eval</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'Œ±</span> io <span class="main">‚áí</span> <span class="main">üåê</span> <span class="main">‚áí</span> <span class="tfree">'Œ±</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">eval</span> <span class="free"><span class="bound"><span class="entity">iofun</span></span></span> <span class="free"><span class="bound"><span class="entity">world</span></span></span> <span class="main">=</span> fst <span class="main">(</span>Rep_io <span class="free"><span class="bound"><span class="entity">iofun</span></span></span> <span class="free"><span class="bound"><span class="entity">world</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‚Äπ
  Essentially, <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const</span><span class="hidden">&gt;</span></span></span>‚Äπexec‚Ä∫</span></span> and <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const</span><span class="hidden">&gt;</span></span></span>‚Äπeval‚Ä∫</span></span> extract the payload <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="tfree"><span class="tfree">'Œ±</span></span>‚Ä∫</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="main"><span class="main">üåê</span></span>‚Ä∫</span></span></span></span>
  when executing an <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="tfree"><span class="tfree">'Œ±</span></span> io‚Ä∫</span></span></span></span>.
‚Ä∫</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"Abs_io <span class="main">(</span><span class="main">Œª</span><span class="bound">world</span><span class="main">.</span> <span class="main">(</span>eval <span class="free">iofun</span> <span class="bound">world</span><span class="main">,</span> exec <span class="free">iofun</span> <span class="bound">world</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">iofun</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> exec_def eval_def Rep_io_inverse<span class="main">)</span>

<span class="keyword1" id="IO-exec_Abs_io"><span class="command">lemma</span></span> exec_Abs_io<span class="main">:</span> <span class="quoted"><span class="quoted">"exec <span class="main">(</span>Abs_io <span class="free">f</span><span class="main">)</span> <span class="free">world</span> <span class="main">=</span> snd <span class="main">(</span><span class="free">f</span> <span class="free">world</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> exec_def Abs_io_inverse<span class="main">)</span>


<span class="keyword1" id="IO-exec_then"><span class="command">lemma</span></span> exec_then<span class="main">:</span>
    <span class="quoted"><span class="quoted">"exec <span class="main">(</span><span class="free">io<span class="hidden">‚á©</span><sub>1</sub></span> <span class="main">‚™¢</span> <span class="free">io<span class="hidden">‚á©</span><sub>2</sub></span><span class="main">)</span> <span class="free">world</span> <span class="main">=</span> exec <span class="free">io<span class="hidden">‚á©</span><sub>2</sub></span> <span class="main">(</span>exec <span class="free">io<span class="hidden">‚á©</span><sub>1</sub></span> <span class="free">world</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> eval_then<span class="main">:</span>
    <span class="quoted"><span class="quoted">"eval <span class="main">(</span><span class="free">io<span class="hidden">‚á©</span><sub>1</sub></span> <span class="main">‚™¢</span> <span class="free">io<span class="hidden">‚á©</span><sub>2</sub></span><span class="main">)</span> <span class="free">world</span> <span class="main">=</span> eval <span class="free">io<span class="hidden">‚á©</span><sub>2</sub></span> <span class="main">(</span>exec <span class="free">io<span class="hidden">‚á©</span><sub>1</sub></span> <span class="free">world</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> exec_def eval_def bind_def Abs_io_inverse split_beta<span class="main">)</span>

<span class="keyword1" id="IO-exec_bind"><span class="command">lemma</span></span> exec_bind<span class="main">:</span>
    <span class="quoted"><span class="quoted">"exec <span class="main">(</span><span class="free">io<span class="hidden">‚á©</span><sub>1</sub></span> <span class="main">‚§ú</span> <span class="free">io<span class="hidden">‚á©</span><sub>2</sub></span><span class="main">)</span> <span class="free">world</span> <span class="main">=</span> exec <span class="main">(</span><span class="free">io<span class="hidden">‚á©</span><sub>2</sub></span> <span class="main">(</span>eval <span class="free">io<span class="hidden">‚á©</span><sub>1</sub></span> <span class="free">world</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>exec <span class="free">io<span class="hidden">‚á©</span><sub>1</sub></span> <span class="free">world</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> eval_bind<span class="main">:</span>
    <span class="quoted"><span class="quoted">"eval <span class="main">(</span><span class="free">io<span class="hidden">‚á©</span><sub>1</sub></span> <span class="main">‚§ú</span> <span class="free">io<span class="hidden">‚á©</span><sub>2</sub></span><span class="main">)</span> <span class="free">world</span> <span class="main">=</span> eval <span class="main">(</span><span class="free">io<span class="hidden">‚á©</span><sub>2</sub></span> <span class="main">(</span>eval <span class="free">io<span class="hidden">‚á©</span><sub>1</sub></span> <span class="free">world</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>exec <span class="free">io<span class="hidden">‚á©</span><sub>1</sub></span> <span class="free">world</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> exec_def eval_def bind_def Abs_io_inverse split_beta<span class="main">)</span>

<span class="keyword1" id="IO-exec_return"><span class="command">lemma</span></span> exec_return<span class="main">:</span>
    <span class="quoted"><span class="quoted">"exec <span class="main">(</span>IO.return <span class="free">a</span><span class="main">)</span> <span class="free">world</span> <span class="main">=</span> <span class="free">world</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span>
    <span class="quoted"><span class="quoted">"eval <span class="main">(</span>IO.return <span class="free">a</span><span class="main">)</span> <span class="free">world</span> <span class="main">=</span> <span class="free">a</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> exec_def eval_def Abs_io_inverse return_def<span class="main">)</span>


<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="HelloWorld">
<div class="head">
<h1>Theory HelloWorld</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">theory</span></span> HelloWorld
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="#IO">IO</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‚ÄπHello, World!‚Ä∫</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‚Äπ
  The idea of a <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="free"><span class="free">main</span></span> <span class="main"><span class="main">::</span></span> unit io‚Ä∫</span></span></span></span> function is that, upon start of your program, you will be
  handed a value of type <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="main"><span class="main">üåê</span></span>‚Ä∫</span></span></span></span>. You can pass this world through your code and modify it.
  Be careful with the <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="main"><span class="main">üåê</span></span>‚Ä∫</span></span></span></span>, it's the only one we have.
‚Ä∫</span></span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‚ÄπThe main function, defined in Isabelle. It should have the right type in Haskell.‚Ä∫</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">main</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"unit io"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">main</span> <span class="main">‚â°</span> <span class="keyword1">do</span> <span class="main">{</span>
               <span class="main"><span class="bound">_</span></span> <span class="main">‚Üê</span> println <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Hello World! What is your name?''</span><span class="main">)</span><span class="main">;</span>
               <span class="bound">name</span> <span class="main">‚Üê</span> getLine<span class="main">;</span>
               println <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Hello, ''</span> <span class="main">+</span> <span class="bound">name</span> <span class="main">+</span> <span class="keyword1">STR</span> <span class="inner_quoted">''!''</span><span class="main">)</span>
             <span class="main">}</span>"</span></span>


<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‚ÄπGenerating Code‚Ä∫</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‚ÄπChecking that the generated code compiles.‚Ä∫</span></span>
<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">main</span></span> <span class="keyword2"><span class="keyword">checking</span></span> Haskell<span class="main">?</span> SML


<span class="keyword1"><span class="command">ML_val</span></span><span class="quoted">‚Äπ<span class="entity">Isabelle_System.bash</span> <span class="inner_quoted">"echo ${ISABELLE_TMP} &gt; ${ISABELLE_TMP}/self"</span>‚Ä∫</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‚Äπ
During the build of this session, the code generated in the following subsections will be
written to
‚Ä∫</span></span>
<span class="keyword1"><span class="command">text_raw</span></span><span class="quoted"><span class="plain_text">‚Äπ\verbatiminput{${ISABELLE_TMP}/self}‚Ä∫</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‚ÄπHaskell‚Ä∫</span></span>

<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">main</span></span> <span class="keyword2"><span class="keyword">in</span></span> Haskell <span class="keyword2"><span class="keyword">file</span></span> <span class="quoted">"$ISABELLE_TMP/exported_hs"</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‚ÄπThe generated helper module <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">üóè</span></span>‚Äπ$ISABELLE_TMP/exported_hs/StdIO.hs‚Ä∫</span></span> is shown below.‚Ä∫</span></span>
<span class="keyword1"><span class="command">text_raw</span></span><span class="quoted"><span class="plain_text">‚Äπ\verbatiminput{$ISABELLE_TMP/exported_hs/StdIO.hs}‚Ä∫</span></span>
 
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‚ÄπThe generated main file <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">üóè</span></span>‚Äπ$ISABELLE_TMP/exported_hs/HelloWorld.hs‚Ä∫</span></span> is shown below.‚Ä∫</span></span>
<span class="keyword1"><span class="command">text_raw</span></span><span class="quoted"><span class="plain_text">‚Äπ\verbatiminput{$ISABELLE_TMP/exported_hs/HelloWorld.hs}‚Ä∫</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‚ÄπSML‚Ä∫</span></span>

<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">main</span></span> <span class="keyword2"><span class="keyword">in</span></span> SML <span class="keyword2"><span class="keyword">file</span></span> <span class="quoted">"$ISABELLE_TMP/exported.sml"</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‚ÄπThe generated SML code in <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">üóè</span></span>‚Äπ$ISABELLE_TMP/exported.sml‚Ä∫</span></span> is shown below.‚Ä∫</span></span>
<span class="keyword1"><span class="command">text_raw</span></span><span class="quoted"><span class="plain_text">‚Äπ\verbatiminput{$ISABELLE_TMP/exported.sml}‚Ä∫</span></span>


<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="HelloWorld_Proof">
<div class="head">
<h1>Theory HelloWorld_Proof</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">theory</span></span> HelloWorld_Proof
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="#HelloWorld">HelloWorld</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‚ÄπCorrectness‚Ä∫</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‚ÄπModeling Input and Output‚Ä∫</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‚Äπ
  With the appropriate assumptions about <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const</span><span class="hidden">&gt;</span></span></span>‚Äπprintln‚Ä∫</span></span> and <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const</span><span class="hidden">&gt;</span></span></span>‚ÄπgetLine‚Ä∫</span></span>,
  we can even prove something.
  We summarize our model about input and output in the assumptions of a <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚¨ö</span></span><span class="raw_text"><span class="raw_text">‚Äπ<span class="keyword1"><span class="command"><span class="keyword1"><span class="command">locale</span></span></span></span>‚Ä∫</span></span></span></span>.
‚Ä∫</span></span>
<span class="keyword1"><span class="command">locale</span></span> io_stdio <span class="main">=</span>
  <span class="comment1">‚Äï ‚ÄπWe model <span class="antiquoted"><span class="operator">‚ñ©</span><span class="raw_text">‚ÄπSTDIN‚Ä∫</span></span> and <span class="antiquoted"><span class="operator">‚ñ©</span><span class="raw_text">‚ÄπSTDOUT‚Ä∫</span></span> as part of the <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span><span class="quoted">‚Äπ<span class="main">üåê</span>‚Ä∫</span></span>.
     Note that we know nothing about <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span><span class="quoted">‚Äπ<span class="main">üåê</span>‚Ä∫</span></span>,
     we just model that we can find <span class="antiquoted"><span class="operator">‚ñ©</span><span class="raw_text">‚ÄπSTDIN‚Ä∫</span></span> and <span class="antiquoted"><span class="operator">‚ñ©</span><span class="raw_text">‚ÄπSTDOUT‚Ä∫</span></span> somewhere in there.‚Ä∫</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">stdout_of</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="main">üåê</span> <span class="main">‚áí</span> string list"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">stdin_of</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="main">üåê</span> <span class="main">‚áí</span> string list"</span></span>

  <span class="comment1">‚Äï ‚ÄπAssumptions about <span class="antiquoted"><span class="operator">‚ñ©</span><span class="raw_text">‚ÄπSTDIN‚Ä∫</span></span>:
      Calling <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const</span><span class="hidden">&gt;</span></span>‚Äπprintln‚Ä∫</span> appends to the end of <span class="antiquoted"><span class="operator">‚ñ©</span><span class="raw_text">‚ÄπSTDOUT‚Ä∫</span></span> and <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const</span><span class="hidden">&gt;</span></span>‚ÄπgetLine‚Ä∫</span> does not change
      anything.‚Ä∫</span>
<span class="keyword2"><span class="keyword">assumes</span></span> stdout_of_println<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="free">stdout_of</span> <span class="main">(</span>exec <span class="main">(</span>println <span class="free">str</span><span class="main">)</span> <span class="free">world</span><span class="main">)</span> <span class="main">=</span> <span class="free">stdout_of</span> <span class="free">world</span><span class="main">@</span><span class="main">[</span>String.explode <span class="free">str</span><span class="main">]</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> stdout_of_getLine<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="free">stdout_of</span> <span class="main">(</span>exec getLine <span class="free">world</span><span class="main">)</span> <span class="main">=</span> <span class="free">stdout_of</span> <span class="free">world</span>"</span></span>

  <span class="comment1">‚Äï ‚ÄπAssumptions about <span class="antiquoted"><span class="operator">‚ñ©</span><span class="raw_text">‚ÄπSTDIN‚Ä∫</span></span>:
      Calling <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const</span><span class="hidden">&gt;</span></span>‚Äπprintln‚Ä∫</span> does not change anything and <span class="antiquoted"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const</span><span class="hidden">&gt;</span></span>‚ÄπgetLine‚Ä∫</span> removes the first element
      from the <span class="antiquoted"><span class="operator">‚ñ©</span><span class="raw_text">‚ÄπSTDIN‚Ä∫</span></span> stream.‚Ä∫</span>
  <span class="keyword2"><span class="keyword">and</span></span> stdin_of_println<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="free">stdin_of</span> <span class="main">(</span>exec <span class="main">(</span>println <span class="free">str</span><span class="main">)</span> <span class="free">world</span><span class="main">)</span> <span class="main">=</span> <span class="free">stdin_of</span> <span class="free">world</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> stdin_of_getLine<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="free">stdin_of</span> <span class="free">world</span> <span class="main">=</span> <span class="free">inp</span><span class="main">#</span><span class="free">stdin</span> <span class="main">‚üπ</span>
     <span class="free">stdin_of</span> <span class="main">(</span>exec getLine <span class="free">world</span><span class="main">)</span> <span class="main">=</span> <span class="free">stdin</span> <span class="main">‚àß</span> eval getLine <span class="free">world</span> <span class="main">=</span> String.implode <span class="free">inp</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‚ÄπCorrectness of Hello World‚Ä∫</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‚ÄπCorrectness of <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const</span><span class="hidden">&gt;</span></span></span>‚Äπmain‚Ä∫</span></span>:
    If <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚ÄπSTDOUT‚Ä∫</span></span></span></span> is initially empty and only <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="inner_quoted"><span class="inner_quoted">''corny''</span></span>‚Ä∫</span></span></span></span> will be typed into <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚ñ©</span></span><span class="raw_text"><span class="raw_text">‚ÄπSTDIN‚Ä∫</span></span></span></span>,
    then the program will output: <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">term</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‚Äπ<span class="main"><span class="main">[</span></span><span class="inner_quoted"><span class="inner_quoted">''Hello World! What is your name?''</span></span><span class="main"><span class="main">,</span></span> <span class="inner_quoted"><span class="inner_quoted">''Hello, corny!''</span></span><span class="main"><span class="main">]</span></span>‚Ä∫</span></span></span></span>.
  ‚Ä∫</span></span>
<span class="keyword1"><span class="command">theorem</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> io_stdio<span class="main">)</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> stdout<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">stdout_of</span> <span class="free">world</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
       <span class="keyword2"><span class="keyword">and</span></span> stdin<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">stdin_of</span> <span class="free">world</span> <span class="main">=</span> <span class="main">[</span><span class="inner_quoted">''corny''</span><span class="main">]</span>"</span></span>
     <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">stdout_of</span> <span class="main">(</span>exec main <span class="free">world</span><span class="main">)</span> <span class="main">=</span>
              <span class="main">[</span><span class="inner_quoted">''Hello World! What is your name?''</span><span class="main">,</span>
               <span class="inner_quoted">''Hello, corny!''</span><span class="main">]</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?world1</span></span></span><span class="main">=</span><span class="quoted"><span class="quoted">"exec <span class="main">(</span>println <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Hello World! What is your name?''</span><span class="main">)</span><span class="main">)</span> <span class="free">world</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> stdout_world2<span class="main">:</span>
    <span class="quoted"><span class="quoted">"literal.explode <span class="keyword1">STR</span> <span class="inner_quoted">''Hello World! What is your name?''</span> <span class="main">=</span>
     <span class="inner_quoted">''Hello World! What is your name?''</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">code_simp</span>
  <span class="keyword1"><span class="command">from</span></span> stdin_of_getLine<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> stdin<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="main">[]</span>"</span></span><span class="main">,</span> <span class="operator">OF</span> stdin<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> stdin_world2<span class="main">:</span>
    <span class="quoted"><span class="quoted">"eval getLine <span class="var">?world1</span> <span class="main">=</span> String.implode <span class="inner_quoted">''corny''</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> stdin_of_getLine stdin<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> main_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> exec_bind<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> stdout<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> stdout_world2 stdin_world2<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> plus_literal.rep_eq<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">code_simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="RunningCodeFromIsabelle">
<div class="head">
<h1>Theory RunningCodeFromIsabelle</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">theory</span></span> RunningCodeFromIsabelle
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="#HelloWorld">HelloWorld</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‚ÄπRunning the Generated Code inside Isabelle‚Ä∫</span></span>

<span class="comment1">(*Maintainer note: We invoke the generated code ON PURPOSE from bash to demonstrate how to use
  the generated code from outside Isabelle and make sure the code runs.*)</span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‚Äπ
  Usually, one would use <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">‚¨ö</span></span><span class="raw_text"><span class="raw_text">‚Äπ<span class="keyword1"><span class="command"><span class="keyword1"><span class="command">export_code</span></span></span></span>‚Ä∫</span></span></span></span> to generate code. Here, we want to write the code to
  a temp directory and execute it right afterwards inside Isablle, so we invoke the code generator
  directly from Isabelle/ML.
‚Ä∫</span></span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‚ÄπHaskell‚Ä∫</span></span>

<span class="keyword1"><span class="command">ML</span></span><span class="quoted">‚Äπ
<span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">files</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span>
  <span class="entity">Code_Target.produce_code</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> false <span class="main">[</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> main<span class="antiquote">}</span></span><span class="main">]</span> <span class="inner_quoted">"Haskell"</span> <span class="inner_quoted">"Main"</span> NONE <span class="main">[</span><span class="main">]</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">target</span> <span class="main">=</span> File.tmp_path <span class="main">(</span>Path.basic <span class="main">(</span><span class="inner_quoted">"export"</span> ^ serial_string <span class="main">(</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ghc</span> <span class="main">=</span> getenv <span class="inner_quoted">"ISABELLE_GHC"</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cmd</span> <span class="main">=</span>
  <span class="inner_quoted">"cd "</span> ^ Path.implode <span class="entity">target</span> ^ <span class="inner_quoted">" &amp;&amp; "</span> ^
    Bash.string <span class="entity">ghc</span> ^ <span class="inner_quoted">" Main.hs &amp;&amp; "</span> ^
    <span class="inner_quoted">"(  echo 'Cyber Cat 42' | ./Main )"</span><span class="main">;</span>

<span class="entity">Isabelle_System.make_directory</span> <span class="entity">target</span><span class="main">;</span>

List.app <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">(</span><span class="main">[</span><span class="entity">file</span><span class="main">]</span><span class="main">,</span> <span class="entity">content</span><span class="main">)</span> <span class="main">=&gt;</span> File.write <span class="main">(</span><span class="entity">target</span> + Path.basic <span class="entity">file</span><span class="main">)</span> <span class="entity">content</span><span class="main">)</span> <span class="entity">files</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">exitcode</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">ghc</span> &lt;&gt; <span class="inner_quoted">""</span> <span class="keyword2"><span class="keyword">then</span></span>
    <span class="entity">Isabelle_System.bash</span> <span class="entity">cmd</span>
  <span class="keyword2"><span class="keyword">else</span></span>
    <span class="main">(</span>writeln <span class="inner_quoted">"not running Haskell, because $ISABELLE_GHC is not set."</span><span class="main">;</span> <span class="inner_numeral">0</span><span class="main">)</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">if</span></span> <span class="entity">exitcode</span> &lt;&gt; <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span>
  <span class="keyword3"><span class="keyword">raise</span></span> <span class="main">(</span>Fail <span class="main">(</span><span class="inner_quoted">"example Haskell code did not run as expected, "</span> ^
                 <span class="inner_quoted">"exit code was "</span> ^ <span class="main">(</span>Int.toString <span class="entity">exitcode</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="main">)</span>
‚Ä∫</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‚ÄπSML‚Ä∫</span></span>

<span class="keyword1"><span class="command">ML</span></span><span class="quoted">‚Äπ

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">[</span><span class="main">(</span><span class="main">_</span><span class="main">,</span> <span class="entity">content</span><span class="main">)</span><span class="main">]</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span>
  <span class="entity">Code_Target.produce_code</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> false <span class="main">[</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> main<span class="antiquote">}</span></span><span class="main">]</span> <span class="inner_quoted">"SML"</span> <span class="inner_quoted">"HelloWorld"</span> NONE <span class="main">[</span><span class="main">]</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">target</span> <span class="main">=</span> File.tmp_path <span class="main">(</span>Path.basic <span class="main">(</span><span class="inner_quoted">"export"</span> ^ serial_string <span class="main">(</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">file</span> <span class="main">=</span> <span class="entity">target</span> + Path.basic <span class="inner_quoted">"main.ML"</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cmd</span> <span class="main">=</span>
  <span class="inner_quoted">"echo 'Super Goat 2000' | "</span> ^
    <span class="inner_quoted">"\"${POLYML_EXE?}\" --use "</span> ^ Path.implode <span class="entity">file</span> ^
    <span class="inner_quoted">" --eval 'HelloWorld.main ()'"</span><span class="main">;</span>

<span class="entity">Isabelle_System.make_directory</span> <span class="entity">target</span><span class="main">;</span>
File.write <span class="entity">file</span> <span class="entity">content</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">exitcode</span> <span class="main">=</span> <span class="entity">Isabelle_System.bash</span> <span class="entity">cmd</span><span class="main">;</span>

<span class="keyword2"><span class="keyword">if</span></span> <span class="entity">exitcode</span> &lt;&gt; <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span>
  <span class="keyword3"><span class="keyword">raise</span></span> <span class="main">(</span>Fail <span class="main">(</span><span class="inner_quoted">"example SML code did not run as expected, "</span> ^
                 <span class="inner_quoted">"exit code was "</span> ^ <span class="main">(</span>Int.toString <span class="entity">exitcode</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="main">)</span>
‚Ä∫</span>


<span class="keyword2"><span class="keyword">end</span></span></pre>
</div>