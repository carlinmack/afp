<div id="IMP2_Binary_Heap">
<div class="head">
<h1>Theory IMP2_Binary_Heap</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">theory</span></span> IMP2_Binary_Heap
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="../../imp2/theories/#IMP2">IMP2.IMP2</a> <a href="../../imp2/theories/#IMP2_Aux_Lemmas">IMP2.IMP2_Aux_Lemmas</a>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Introduction›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In this submission imperative versions of the following array-based binary minimum heap
      functions are implemented and verified: insert, get-min, delete-min, make-heap.
      The latter three are then used to prove the correctness of an in-place heapsort, which sorts
      an array in descending order. To do that in Isabelle/HOL, the proof framework IMP2
      \cite{IMP2-AFP} is used. Here arrays are modeled by <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>int ⇒ int›</span></span></span></span> functions. The imperative
      implementations are iterative versions of the partly recursive algorithms described in
      \cite{MS} and \cite{CLRS}.

      This submission starts with the basic definitions and lemmas, which are needed for array-based 
      binary heaps. These definitions and lemmas are parameterised with an arbitrary (transitive) 
      comparison function (where such a function is needed), so they are not only applicable to 
      minimum heaps. After some more general, useful lemmas on arrays, the imperative minimum heap 
      functions and the heapsort are implemented and verified.›</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Heap Related Definitions and Theorems›</span></span>
<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Array Bounds›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A small helper function is used to define valid array indices. Note that the lower index 
      bound <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>l›</span></span></span></span> is arbitrary and not fixed to 0 or 1. The upper index bound <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>r›</span></span></span></span> is not a valid
      index itself, so that the empty array can be denoted by having <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>l = r›</span></span></span></span>.›</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">bounded</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"int <span class="main">⇒</span> int <span class="main">⇒</span> int <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">bounded</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span>"</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Parent and Children›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Definitions›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹For the notion of an array-based binary heap, the parent and child relations on the array 
      indices need to be defined.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">parent</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"int <span class="main">⇒</span> int <span class="main">⇒</span> int"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">parent</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">+</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="keyword1">div</span> <span class="numeral">2</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">l_child</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"int <span class="main">⇒</span> int <span class="main">⇒</span> int"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">l_child</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="numeral">2</span> <span class="main">*</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">+</span> <span class="main">1</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">r_child</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"int <span class="main">⇒</span> int <span class="main">⇒</span> int"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">r_child</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="numeral">2</span> <span class="main">*</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">+</span> <span class="numeral">2</span>"</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Lemmas›</span></span>
<span class="keyword1" id="IMP2_Binary_Heap-parent_upper_bound"><span class="command">lemma</span></span> parent_upper_bound<span class="main">:</span> <span class="quoted"><span class="quoted">"parent <span class="free">l</span> <span class="free">c</span> <span class="main">&lt;</span> <span class="free">c</span> <span class="main">⟷</span> <span class="free">l</span> <span class="main">≤</span> <span class="free">c</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> parent_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="IMP2_Binary_Heap-parent_upper_bound_alt"><span class="command">lemma</span></span> parent_upper_bound_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">l</span> <span class="main">≤</span> parent <span class="free">l</span> <span class="free">c</span> <span class="main">⟹</span> parent <span class="free">l</span> <span class="free">c</span> <span class="main">&lt;</span> <span class="free">c</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> parent_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="IMP2_Binary_Heap-parent_lower_bound"><span class="command">lemma</span></span> parent_lower_bound<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">l</span> <span class="main">≤</span> parent <span class="free">l</span> <span class="free">c</span> <span class="main">⟷</span> <span class="free">l</span> <span class="main">&lt;</span> <span class="free">c</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> parent_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">linarith</span>

<span class="keyword1" id="IMP2_Binary_Heap-grand_parent_upper_bound"><span class="command">lemma</span></span> grand_parent_upper_bound<span class="main">:</span> <span class="quoted"><span class="quoted">"parent <span class="free">l</span> <span class="main">(</span>parent <span class="free">l</span> <span class="free">c</span><span class="main">)</span> <span class="main">&lt;</span> <span class="free">c</span> <span class="main">⟷</span> <span class="free">l</span> <span class="main">≤</span> <span class="free">c</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> parent_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">linarith</span>

<span class="keyword1"><span class="command">corollary</span></span> parent_bounds<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">l</span> <span class="main">&lt;</span> <span class="free">x</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">&lt;</span> <span class="free">r</span> <span class="main">⟹</span> bounded <span class="free">l</span> <span class="free">r</span> <span class="main">(</span>parent <span class="free">l</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> parent_lower_bound parent_upper_bound_alt <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>


<span class="keyword1" id="IMP2_Binary_Heap-l_child_lower_bound"><span class="command">lemma</span></span> l_child_lower_bound<span class="main">:</span> <span class="quoted"><span class="quoted">" <span class="free">p</span> <span class="main">&lt;</span> l_child <span class="free">l</span> <span class="free">p</span> <span class="main">⟷</span> <span class="free">l</span> <span class="main">≤</span> <span class="free">p</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> l_child_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">corollary</span></span> l_child_lower_bound_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">l</span> <span class="main">≤</span> <span class="free">x</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">≤</span> <span class="free">p</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">&lt;</span> l_child <span class="free">l</span> <span class="free">p</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> l_child_lower_bound<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">p</span></span> <span class="quoted"><span class="free">l</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">linarith</span>

<span class="keyword1" id="IMP2_Binary_Heap-parent_l_child"><span class="command">lemma</span></span> parent_l_child<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"parent <span class="free">l</span> <span class="main">(</span>l_child <span class="free">l</span> <span class="free">n</span><span class="main">)</span> <span class="main">=</span> <span class="free">n</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> parent_def l_child_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>


<span class="keyword1" id="IMP2_Binary_Heap-r_child_lower_bound"><span class="command">lemma</span></span> r_child_lower_bound<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">l</span> <span class="main">≤</span> <span class="free">p</span> <span class="main">⟹</span> <span class="free">p</span> <span class="main">&lt;</span> r_child <span class="free">l</span> <span class="free">p</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> r_child_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">corollary</span></span> r_child_lower_bound_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">l</span> <span class="main">≤</span> <span class="free">x</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">≤</span> <span class="free">p</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">&lt;</span> r_child <span class="free">l</span> <span class="free">p</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> r_child_lower_bound<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">l</span></span> <span class="quoted"><span class="free">p</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">linarith</span>

<span class="keyword1" id="IMP2_Binary_Heap-parent_r_child"><span class="command">lemma</span></span> parent_r_child<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"parent <span class="free">l</span> <span class="main">(</span>r_child <span class="free">l</span> <span class="free">n</span><span class="main">)</span> <span class="main">=</span> <span class="free">n</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> parent_def r_child_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>


<span class="keyword1" id="IMP2_Binary_Heap-smaller_l_child"><span class="command">lemma</span></span> smaller_l_child<span class="main">:</span> <span class="quoted"><span class="quoted">"l_child <span class="free">l</span> <span class="free">x</span> <span class="main">&lt;</span> r_child <span class="free">l</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> l_child_def r_child_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="IMP2_Binary_Heap-parent_two_children"><span class="command">lemma</span></span> parent_two_children<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">c</span> <span class="main">=</span> l_child <span class="free">l</span> <span class="free">p</span> <span class="main">∨</span> <span class="free">c</span> <span class="main">=</span> r_child <span class="free">l</span> <span class="free">p</span><span class="main">)</span> <span class="main">⟷</span> parent <span class="free">l</span> <span class="free">c</span> <span class="main">=</span> <span class="free">p</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> parent_def l_child_def r_child_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">linarith</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Heap Invariants›</span></span>
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Definitions›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The following heap invariants and the following lemmas are parameterised with an arbitrary 
      (transitive) comparison function. For the concrete function implementations at the end of 
      this submission <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>≤›</span></span></span></span> on ints is used.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹For the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>make_heap›</span></span></span></span> function, which transforms an unordered array into a valid heap,
      the notion of a partial heap is needed. Here the heap invariant only holds for array indices
      between a certain valid array index <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>m›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>r›</span></span></span></span>. The standard heap invariant is then
      simply the special case where <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>m = l›</span></span></span></span>.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">is_partial_heap</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>order <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">::</span>order <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span>int <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">::</span>order<span class="main">)</span> <span class="main">⇒</span> int <span class="main">⇒</span> int <span class="main">⇒</span> int <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">is_partial_heap</span> <span class="free"><span class="bound"><span class="entity">cmp</span></span></span> <span class="free"><span class="bound"><span class="entity">heap</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">x</span><span class="main">.</span> bounded <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="bound">x</span> <span class="main">⟶</span> 
               bounded <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">(</span>parent <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="bound">x</span><span class="main">)</span> <span class="main">⟶</span> <span class="free"><span class="bound"><span class="entity">cmp</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">heap</span></span></span> <span class="main">(</span>parent <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">heap</span></span></span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">is_heap</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>order <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">::</span>order <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span>int <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">::</span>order<span class="main">)</span> <span class="main">⇒</span> int <span class="main">⇒</span> int <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">is_heap</span> <span class="free"><span class="bound"><span class="entity">cmp</span></span></span> <span class="free"><span class="bound"><span class="entity">heap</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">≡</span> is_partial_heap <span class="free"><span class="bound"><span class="entity">cmp</span></span></span> <span class="free"><span class="bound"><span class="entity">heap</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span>"</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹During all of the modifying heap functions the heap invariant is temporarily violated at
      a single index <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>i›</span></span></span></span> and it is then gradually restored by either <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>sift_down›</span></span></span></span> or 
      <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>sift_up›</span></span></span></span>. The following definitions formalize these weakened invariants.

      The second part of the conjunction in the following definitions states, that the comparison 
      between the parent of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>i›</span></span></span></span> and each of the children of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>i›</span></span></span></span> evaluates to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>True›</span></span></span></span> without 
      explicitly using the child relations.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">is_partial_heap_except_down</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>order <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">::</span>order <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span>int <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">::</span>order<span class="main">)</span> <span class="main">⇒</span> int <span class="main">⇒</span> int <span class="main">⇒</span> int <span class="main">⇒</span> int <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">is_partial_heap_except_down</span> <span class="free"><span class="bound"><span class="entity">cmp</span></span></span> <span class="free"><span class="bound"><span class="entity">heap</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">x</span><span class="main">.</span> bounded <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="bound">x</span> <span class="main">⟶</span>
    <span class="main">(</span><span class="main">(</span>parent <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="bound">x</span> <span class="main">≠</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">⟶</span> bounded <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">(</span>parent <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="bound">x</span><span class="main">)</span> <span class="main">⟶</span> <span class="free"><span class="bound"><span class="entity">cmp</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">heap</span></span></span> <span class="main">(</span>parent <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">heap</span></span></span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> 
     <span class="main">(</span>parent <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="bound">x</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">⟶</span> bounded <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">(</span>parent <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">(</span>parent <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>  
                     <span class="main">⟶</span> <span class="free"><span class="bound"><span class="entity">cmp</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">heap</span></span></span> <span class="main">(</span>parent <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">(</span>parent <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">heap</span></span></span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">is_heap_except_down</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>order <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">::</span>order <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span>int <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">::</span>order<span class="main">)</span> <span class="main">⇒</span> int <span class="main">⇒</span> int <span class="main">⇒</span> int <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">is_heap_except_down</span> <span class="free"><span class="bound"><span class="entity">cmp</span></span></span> <span class="free"><span class="bound"><span class="entity">heap</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">≡</span> is_partial_heap_except_down <span class="free"><span class="bound"><span class="entity">cmp</span></span></span> <span class="free"><span class="bound"><span class="entity">heap</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span>"</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹As mentioned the notion of a partial heap is only needed for <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>make_heap›</span></span></span></span>, 
      which only uses <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>sift_down›</span></span></span></span> internally, so there doesn't need to be an additional 
      definition for the partial heap version of the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>sift_up›</span></span></span></span> invariant.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">is_heap_except_up</span> 
  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>order <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">::</span>order <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span>int <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">::</span>order<span class="main">)</span> <span class="main">⇒</span> int <span class="main">⇒</span> int <span class="main">⇒</span> int <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">is_heap_except_up</span> <span class="free"><span class="bound"><span class="entity">cmp</span></span></span> <span class="free"><span class="bound"><span class="entity">heap</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">x</span><span class="main">.</span> bounded <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="bound">x</span> <span class="main">⟶</span> 
    <span class="main">(</span><span class="main">(</span><span class="bound">x</span> <span class="main">≠</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">⟶</span> bounded <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">(</span>parent <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="bound">x</span><span class="main">)</span> <span class="main">⟶</span> <span class="free"><span class="bound"><span class="entity">cmp</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">heap</span></span></span> <span class="main">(</span>parent <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">heap</span></span></span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> 
     <span class="main">(</span>parent <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="bound">x</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">⟶</span> bounded <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">(</span>parent <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">(</span>parent <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> 
                     <span class="main">⟶</span> <span class="free"><span class="bound"><span class="entity">cmp</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">heap</span></span></span> <span class="main">(</span>parent <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">(</span>parent <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">heap</span></span></span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Lemmas›</span></span>

<span class="keyword1" id="IMP2_Binary_Heap-empty_partial_heap"><span class="command">lemma</span></span> empty_partial_heap<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"is_partial_heap <span class="free">cmp</span> <span class="free">heap</span> <span class="free">l</span> <span class="free">r</span> <span class="free">r</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> is_partial_heap_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">linarith</span>

<span class="keyword1" id="IMP2_Binary_Heap-is_partial_heap_smaller_back"><span class="command">lemma</span></span> is_partial_heap_smaller_back<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"is_partial_heap <span class="free">cmp</span> <span class="free">heap</span> <span class="free">l</span> <span class="free">m</span> <span class="free">r</span> <span class="main">⟹</span> <span class="free">r'</span> <span class="main">≤</span> <span class="free">r</span> <span class="main">⟹</span> is_partial_heap <span class="free">cmp</span> <span class="free">heap</span> <span class="free">l</span> <span class="free">m</span> <span class="free">r'</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> is_partial_heap_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="IMP2_Binary_Heap-is_partial_heap_smaller_front"><span class="command">lemma</span></span> is_partial_heap_smaller_front<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"is_partial_heap <span class="free">cmp</span> <span class="free">heap</span> <span class="free">l</span> <span class="free">m</span> <span class="free">r</span> <span class="main">⟹</span> <span class="free">m</span> <span class="main">≤</span> <span class="free">m'</span> <span class="main">⟹</span> is_partial_heap <span class="free">cmp</span> <span class="free">heap</span> <span class="free">l</span> <span class="free">m'</span> <span class="free">r</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> is_partial_heap_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The second half of each array is a is a partial binary heap, since it contains only leafs,
      which are all trivial binary heaps.›</span></span>
<span class="keyword1" id="IMP2_Binary_Heap-snd_half_is_partial_heap"><span class="command">lemma</span></span> snd_half_is_partial_heap<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">l</span> <span class="main">+</span> <span class="free">r</span><span class="main">)</span> <span class="keyword1">div</span> <span class="numeral">2</span> <span class="main">≤</span> <span class="free">m</span> <span class="main">⟹</span> is_partial_heap <span class="free">cmp</span> <span class="free">heap</span> <span class="free">l</span> <span class="free">m</span> <span class="free">r</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> is_partial_heap_def parent_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">linarith</span>

<span class="keyword1" id="IMP2_Binary_Heap-modify_outside_partial_heap"><span class="command">lemma</span></span> modify_outside_partial_heap<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">heap</span> <span class="main">=</span> <span class="free">heap'</span> <span class="keyword1">on</span> <span class="main">{</span><span class="free">m</span><span class="main">..&lt;</span><span class="free">r</span><span class="main">}</span>"</span></span> 
    <span class="quoted"><span class="quoted">"is_partial_heap <span class="free">cmp</span> <span class="free">heap</span> <span class="free">l</span> <span class="free">m</span> <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"is_partial_heap <span class="free">cmp</span> <span class="free">heap'</span> <span class="free">l</span> <span class="free">m</span> <span class="free">r</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms eq_onD <span class="keyword1"><span class="command">unfolding</span></span> is_partial_heap_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The next few lemmas formalize how the heap invariant is weakened, when the heap is modified
      in a certain way.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This lemma is used by <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>make_heap›</span></span></span></span>.›</span></span>
<span class="keyword1" id="IMP2_Binary_Heap-partial_heap_added_first_el"><span class="command">lemma</span></span> partial_heap_added_first_el<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">l</span> <span class="main">≤</span> <span class="free">m</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">≤</span> <span class="free">r</span>"</span></span>
    <span class="quoted"><span class="quoted">"is_partial_heap <span class="free">cmp</span> <span class="free">heap</span> <span class="free">l</span> <span class="main">(</span><span class="free">m</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"is_partial_heap_except_down <span class="free">cmp</span> <span class="free">heap</span> <span class="free">l</span> <span class="free">m</span> <span class="free">r</span> <span class="free">m</span>"</span></span>
 <span class="keyword1"><span class="command">unfolding</span></span> is_partial_heap_except_down_def
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?p_x</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"parent <span class="free">l</span> <span class="skolem">x</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?gp_x</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"parent <span class="free">l</span> <span class="var">?p_x</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bounded <span class="free">m</span> <span class="free">r</span> <span class="skolem">x</span> <span class="main">⟶</span>
        <span class="main">(</span><span class="var">?p_x</span> <span class="main">≠</span> <span class="free">m</span> <span class="main">⟶</span> bounded <span class="free">m</span> <span class="free">r</span> <span class="var">?p_x</span> <span class="main">⟶</span> <span class="free">cmp</span> <span class="main">(</span><span class="free">heap</span> <span class="var">?p_x</span><span class="main">)</span> <span class="main">(</span><span class="free">heap</span> <span class="skolem">x</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
        <span class="main">(</span><span class="var">?p_x</span> <span class="main">=</span> <span class="free">m</span> <span class="main">⟶</span> bounded <span class="free">m</span> <span class="free">r</span> <span class="var">?gp_x</span> <span class="main">⟶</span> <span class="free">cmp</span> <span class="main">(</span><span class="free">heap</span> <span class="var">?gp_x</span><span class="main">)</span> <span class="main">(</span><span class="free">heap</span> <span class="skolem">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">assume</span></span> x_bound<span class="main">:</span> <span class="quoted"><span class="quoted">"bounded <span class="free">m</span> <span class="free">r</span> <span class="skolem">x</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> p_x_lower<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?p_x</span> <span class="main">≠</span> <span class="free">m</span> <span class="main">⟶</span> bounded <span class="free">m</span> <span class="free">r</span> <span class="var">?p_x</span> <span class="main">⟶</span> <span class="var">?p_x</span> <span class="main">≥</span> <span class="free">m</span> <span class="main">+</span> <span class="main">1</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="var">?p_x</span> <span class="main">≠</span> <span class="free">m</span> <span class="main">⟶</span> bounded <span class="free">m</span> <span class="free">r</span> <span class="var">?p_x</span> <span class="main">⟶</span> <span class="skolem">x</span> <span class="main">≥</span> <span class="free">m</span> <span class="main">+</span> <span class="main">1</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> parent_upper_bound<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">l</span></span> <span class="quoted"><span class="skolem">x</span></span><span class="main">]</span> x_bound assms<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">linarith</span>
    <span class="keyword1"><span class="command">hence</span></span> p_invariant<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?p_x</span> <span class="main">≠</span> <span class="free">m</span> <span class="main">⟶</span> bounded <span class="free">m</span> <span class="free">r</span> <span class="var">?p_x</span> <span class="main">⟶</span> <span class="free">cmp</span> <span class="main">(</span><span class="free">heap</span> <span class="var">?p_x</span><span class="main">)</span> <span class="main">(</span><span class="free">heap</span> <span class="skolem">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>3<span class="main">)</span> is_partial_heap_def p_x_lower x_bound <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

    <span class="keyword1"><span class="command">have</span></span> gp_up_bound<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?p_x</span> <span class="main">=</span> <span class="free">m</span> <span class="main">⟶</span> <span class="var">?gp_x</span> <span class="main">&lt;</span> <span class="free">m</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> parent_upper_bound<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?p_x</span> <span class="main">≠</span> <span class="free">m</span> <span class="main">⟶</span> bounded <span class="free">m</span> <span class="free">r</span> <span class="var">?p_x</span> <span class="main">⟶</span> <span class="free">cmp</span> <span class="main">(</span><span class="free">heap</span> <span class="var">?p_x</span><span class="main">)</span> <span class="main">(</span><span class="free">heap</span> <span class="skolem">x</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
          <span class="main">(</span><span class="var">?p_x</span> <span class="main">=</span> <span class="free">m</span> <span class="main">⟶</span> bounded <span class="free">m</span> <span class="free">r</span> <span class="var">?gp_x</span> <span class="main">⟶</span> <span class="free">cmp</span> <span class="main">(</span><span class="free">heap</span> <span class="var">?gp_x</span><span class="main">)</span> <span class="main">(</span><span class="free">heap</span> <span class="skolem">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> gp_up_bound p_invariant <span class="keyword1"><span class="command">by</span></span> <span class="operator">linarith</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This lemma is used by <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>del_min›</span></span></span></span>.›</span></span>
<span class="keyword1" id="IMP2_Binary_Heap-heap_changed_first_el"><span class="command">lemma</span></span> heap_changed_first_el<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"is_heap <span class="free">cmp</span> <span class="free">heap</span> <span class="free">l</span> <span class="free">r</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">l</span> <span class="main">≤</span> <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"is_heap_except_down <span class="free">cmp</span> <span class="main">(</span><span class="free">heap</span><span class="main">(</span><span class="free">l</span> <span class="main">:=</span> <span class="free">b</span><span class="main">)</span><span class="main">)</span> <span class="free">l</span> <span class="free">r</span> <span class="free">l</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"is_partial_heap <span class="free">cmp</span> <span class="free">heap</span> <span class="free">l</span> <span class="main">(</span><span class="free">l</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="free">r</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>1<span class="main">)</span> is_partial_heap_smaller_front <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"is_partial_heap <span class="free">cmp</span> <span class="main">(</span><span class="free">heap</span><span class="main">(</span><span class="free">l</span> <span class="main">:=</span> <span class="free">b</span><span class="main">)</span><span class="main">)</span> <span class="free">l</span> <span class="main">(</span><span class="free">l</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="free">r</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> modify_outside_partial_heap<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">heap</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> partial_heap_added_first_el<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This lemma is used by <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>insert›</span></span></span></span>.›</span></span>
<span class="keyword1" id="IMP2_Binary_Heap-heap_appended_el"><span class="command">lemma</span></span> heap_appended_el<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> 
    <span class="quoted"><span class="quoted">"is_heap <span class="free">cmp</span> <span class="free">heap</span> <span class="free">l</span> <span class="free">r</span>"</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">heap</span> <span class="main">=</span> <span class="free">heap'</span> <span class="keyword1">on</span> <span class="main">{</span><span class="free">l</span><span class="main">..&lt;</span><span class="free">r</span><span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"is_heap_except_up <span class="free">cmp</span> <span class="free">heap'</span> <span class="free">l</span> <span class="main">(</span><span class="free">r</span><span class="main">+</span><span class="main">1</span><span class="main">)</span> <span class="free">r</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"is_heap <span class="free">cmp</span> <span class="free">heap'</span> <span class="free">l</span> <span class="free">r</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>1<span class="main">,</span>2<span class="main">)</span> modify_outside_partial_heap <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span> 
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> is_partial_heap_def is_heap_except_up_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> not_less_iff_gr_or_eq parent_upper_bound zless_add1_eq<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹First Heap Element›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The next step is to show that the first element of the heap is always the ``smallest'' 
      according to the given comparison function. For the proof a rule for strong induction on lower
      bounded integers is needed. Its proof is based on the proof of strong induction on natural 
      numbers found in \cite{Str_Ind}.›</span></span>
<span class="keyword1" id="IMP2_Binary_Heap-strong_int_gr_induct_helper"><span class="command">lemma</span></span> strong_int_gr_induct_helper<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">&lt;</span> <span class="main">(</span><span class="free">i</span><span class="main">::</span>int<span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">i</span><span class="main">.</span> <span class="free">k</span> <span class="main">&lt;</span> <span class="bound">i</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">⋀</span><span class="bound">j</span><span class="main">.</span> <span class="free">k</span> <span class="main">&lt;</span> <span class="bound">j</span> <span class="main">⟹</span> <span class="bound">j</span> <span class="main">&lt;</span> <span class="bound">i</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">j</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">i</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">j</span><span class="main">.</span> <span class="free">k</span> <span class="main">&lt;</span> <span class="bound">j</span> <span class="main">⟹</span> <span class="bound">j</span> <span class="main">&lt;</span> <span class="free">i</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">j</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">i</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> int_gr_induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> base 
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">linarith</span> 
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">i</span><span class="main">)</span> 
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> 
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">=</span> <span class="skolem">i</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> step.IH step.prems<span class="main">(</span>1<span class="main">,</span>3<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span> 
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">&lt;</span> <span class="skolem">i</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> step.prems<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> step.IH step.prems<span class="main">(</span>1<span class="main">,</span>3<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span> 
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> strong_int_gr_induct<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">&lt;</span> <span class="main">(</span><span class="free">i</span><span class="main">::</span>int<span class="main">)</span>"</span></span> 
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">i</span><span class="main">.</span> <span class="free">k</span> <span class="main">&lt;</span> <span class="bound">i</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">⋀</span><span class="bound">j</span><span class="main">.</span> <span class="free">k</span> <span class="main">&lt;</span> <span class="bound">j</span> <span class="main">⟹</span> <span class="bound">j</span> <span class="main">&lt;</span> <span class="bound">i</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">j</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">i</span><span class="main">)</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">i</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms less_induct strong_int_gr_induct_helper <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Now the main theorem, that the first heap element is the ``smallest'' according to the
      given comparison function, can be proven.›</span></span>
<span class="keyword1"><span class="command">theorem</span></span> heap_first_el<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> 
    <span class="quoted"><span class="quoted">"is_heap <span class="free">cmp</span> <span class="free">heap</span> <span class="free">l</span> <span class="free">r</span>"</span></span>
    <span class="quoted"><span class="quoted">"transp <span class="free">cmp</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">l</span> <span class="main">&lt;</span> <span class="free">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">&lt;</span> <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">cmp</span> <span class="main">(</span><span class="free">heap</span> <span class="free">l</span><span class="main">)</span> <span class="main">(</span><span class="free">heap</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> is_partial_heap_def
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">x</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> strong_int_gr_induct<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free">l</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 1
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>2 <span class="skolem">i</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> cmp_pi_i<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">cmp</span> <span class="main">(</span><span class="free">heap</span> <span class="main">(</span>parent <span class="free">l</span> <span class="skolem">i</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free">heap</span> <span class="skolem">i</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> <span class="quoted">"2.hyps"</span> <span class="quoted">"2.prems"</span><span class="main">(</span>1<span class="main">,</span>4<span class="main">)</span> parent_bounds <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> 
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span><span class="main">)</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"parent <span class="free">l</span> <span class="skolem">i</span> <span class="main">&gt;</span> <span class="free">l</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">cmp</span> <span class="main">(</span><span class="free">heap</span> <span class="free">l</span><span class="main">)</span> <span class="main">(</span><span class="free">heap</span> <span class="main">(</span>parent <span class="free">l</span> <span class="skolem">i</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> <span class="quoted">"2.IH"</span> <span class="quoted">"2.prems"</span><span class="main">(</span>1<span class="main">,</span>2<span class="main">,</span>4<span class="main">)</span> parent_upper_bound_alt <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">using</span></span> <span class="quoted">"2.prems"</span><span class="main">(</span>2<span class="main">)</span> cmp_pi_i transpE <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> parent <span class="free">l</span> <span class="skolem">i</span> <span class="main">&gt;</span> <span class="free">l</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"parent <span class="free">l</span> <span class="skolem">i</span> <span class="main">=</span> <span class="free">l</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> <span class="quoted">"2.hyps"</span> dual_order.order_iff_strict parent_lower_bound <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">using</span></span> cmp_pi_i <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>



<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹General Lemmas on Arrays›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Some additional lemmas on <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "mset_ran"<span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "swap"<span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "eq_on"<span class="antiquote"><span class="antiquote">}</span></span></span></span> are needed
      for the final proofs.›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Lemmas on <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "mset_ran"<span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">arr_mset</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>int <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⇒</span> int <span class="main">⇒</span> int <span class="main">⇒</span> <span class="tfree">'a</span> multiset"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">arr_mset</span> <span class="free"><span class="bound"><span class="entity">arr</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">≡</span> mset_ran <span class="free"><span class="bound"><span class="entity">arr</span></span></span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">..&lt;</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1" id="IMP2_Binary_Heap-in_mset_imp_in_array"><span class="command">lemma</span></span> in_mset_imp_in_array<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈#</span> <span class="main">(</span>arr_mset <span class="free">arr</span> <span class="free">l</span> <span class="free">r</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">i</span><span class="main">.</span> bounded <span class="free">l</span> <span class="free">r</span> <span class="bound">i</span> <span class="main">∧</span> <span class="free">arr</span> <span class="bound">i</span> <span class="main">=</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> mset_ran_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1" id="IMP2_Binary_Heap-arr_mset_remove_last"><span class="command">lemma</span></span> arr_mset_remove_last<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="free">l</span> <span class="main">≤</span> <span class="free">r</span> <span class="main">⟹</span> arr_mset <span class="free">arr</span> <span class="free">l</span> <span class="free">r</span> <span class="main">=</span> arr_mset <span class="free">arr</span> <span class="free">l</span> <span class="main">(</span><span class="free">r</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">-</span> <span class="main">{#</span><span class="free">arr</span> <span class="free">r</span><span class="main">#}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> intvs_upper_decr mset_ran_def<span class="main">)</span>

<span class="keyword1" id="IMP2_Binary_Heap-arr_mset_append"><span class="command">lemma</span></span> arr_mset_append<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="free">l</span> <span class="main">≤</span> <span class="free">r</span> <span class="main">⟹</span> arr_mset <span class="free">arr</span> <span class="free">l</span> <span class="main">(</span><span class="free">r</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">=</span> arr_mset <span class="free">arr</span> <span class="free">l</span> <span class="free">r</span> <span class="main">+</span> <span class="main">{#</span><span class="free">arr</span> <span class="free">r</span><span class="main">#}</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> arr_mset_remove_last<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">l</span></span> <span class="quoted"><span class="free">r</span></span> <span class="quoted"><span class="free">arr</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">corollary</span></span> arr_mset_append_alt<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="free">l</span> <span class="main">≤</span> <span class="free">r</span> <span class="main">⟹</span> arr_mset <span class="main">(</span><span class="free">arr</span><span class="main">(</span><span class="free">r</span> <span class="main">:=</span> <span class="free">b</span><span class="main">)</span><span class="main">)</span> <span class="free">l</span> <span class="main">(</span><span class="free">r</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">=</span> arr_mset <span class="free">arr</span> <span class="free">l</span> <span class="free">r</span> <span class="main">+</span> <span class="main">{#</span><span class="free">b</span><span class="main">#}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> arr_mset_append mset_ran_subst_outside<span class="main">)</span>

<span class="keyword1" id="IMP2_Binary_Heap-arr_mset_remove_first"><span class="command">lemma</span></span> arr_mset_remove_first<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">≤</span> <span class="free">r</span> <span class="main">⟹</span> arr_mset <span class="free">arr</span> <span class="main">(</span><span class="free">i</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="free">r</span> <span class="main">=</span> arr_mset <span class="free">arr</span> <span class="free">i</span> <span class="free">r</span> <span class="main">+</span> <span class="main">{#</span><span class="free">arr</span> <span class="main">(</span><span class="free">i</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">#}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">r</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> int_ge_induct<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> arr_mset_append<span class="main">)</span>

<span class="keyword1" id="IMP2_Binary_Heap-arr_mset_split"><span class="command">lemma</span></span> arr_mset_split<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">l</span> <span class="main">≤</span> <span class="free">m</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">≤</span> <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"arr_mset <span class="free">arr</span> <span class="free">l</span> <span class="free">r</span> <span class="main">=</span> arr_mset <span class="free">arr</span> <span class="free">l</span> <span class="free">m</span> <span class="main">+</span> arr_mset <span class="free">arr</span> <span class="free">m</span> <span class="free">r</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">m</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> int_ge_induct<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free">l</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">i</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> add_last<span class="main">:</span> <span class="quoted"><span class="quoted">"arr_mset <span class="free">arr</span> <span class="free">l</span> <span class="main">(</span><span class="skolem">i</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">=</span> arr_mset <span class="free">arr</span> <span class="free">l</span> <span class="skolem">i</span> <span class="main">+</span> <span class="main">{#</span><span class="free">arr</span> <span class="skolem">i</span><span class="main">#}</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> step arr_mset_append <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">have</span></span> rem_first<span class="main">:</span> <span class="quoted"><span class="quoted">"arr_mset <span class="free">arr</span> <span class="main">(</span><span class="skolem">i</span><span class="main">+</span><span class="main">1</span><span class="main">)</span> <span class="free">r</span> <span class="main">=</span> arr_mset <span class="free">arr</span> <span class="skolem">i</span> <span class="free">r</span> <span class="main">-</span> <span class="main">{#</span><span class="free">arr</span> <span class="skolem">i</span><span class="main">#}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> step.prems arr_mset_remove_first add_diff_cancel_right'<span class="main">)</span> 
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> 
    <span class="keyword1"><span class="command">using</span></span> step add_last rem_first <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹That the first element in a heap is the ``smallest'', can now be expressed using multisets.›</span></span>
<span class="keyword1"><span class="command">corollary</span></span> heap_first_el_alt<span class="main">:</span>                                                   
  <span class="keyword2"><span class="keyword">assumes</span></span> 
    <span class="quoted"><span class="quoted">"transp <span class="free">cmp</span>"</span></span> 
    <span class="quoted"><span class="quoted">"is_heap <span class="free">cmp</span> <span class="free">heap</span> <span class="free">l</span> <span class="free">r</span>"</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈#</span> <span class="main">(</span>arr_mset <span class="free">heap</span> <span class="free">l</span> <span class="free">r</span><span class="main">)</span>"</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">heap</span> <span class="free">l</span> <span class="main">≠</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">cmp</span> <span class="main">(</span><span class="free">heap</span> <span class="free">l</span><span class="main">)</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">metis</span> assms heap_first_el in_mset_imp_in_array le_less<span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Lemmas on <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"swap"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"eq_on"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1" id="IMP2_Binary_Heap-eq_on_subset"><span class="command">lemma</span></span> eq_on_subset<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="free">arr1</span> <span class="main">=</span> <span class="free">arr2</span> <span class="keyword1">on</span> <span class="free">R</span> <span class="main">⟹</span> <span class="free">S</span> <span class="main">⊆</span> <span class="free">R</span> <span class="main">⟹</span> <span class="free">arr1</span> <span class="main">=</span> <span class="free">arr2</span> <span class="keyword1">on</span> <span class="free">S</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq_on_def set_mp<span class="main">)</span>

<span class="keyword1" id="IMP2_Binary_Heap-swap_swaps"><span class="command">lemma</span></span> swap_swaps<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="free">arr'</span> <span class="main">=</span> swap <span class="free">arr</span> <span class="free">x</span> <span class="free">y</span> <span class="main">⟹</span> <span class="free">arr'</span> <span class="free">y</span> <span class="main">=</span> <span class="free">arr</span> <span class="free">x</span> <span class="main">∧</span> <span class="free">arr'</span> <span class="free">x</span> <span class="main">=</span> <span class="free">arr</span> <span class="free">y</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> swap_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="IMP2_Binary_Heap-swap_only_swaps"><span class="command">lemma</span></span> swap_only_swaps<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="free">arr'</span> <span class="main">=</span> swap <span class="free">arr</span> <span class="free">x</span> <span class="free">y</span> <span class="main">⟹</span> <span class="free">z</span> <span class="main">≠</span> <span class="free">x</span> <span class="main">⟹</span> <span class="free">z</span> <span class="main">≠</span> <span class="free">y</span> <span class="main">⟹</span> <span class="free">arr'</span> <span class="free">z</span> <span class="main">=</span> <span class="free">arr</span> <span class="free">z</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> swap_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="IMP2_Binary_Heap-swap_commute"><span class="command">lemma</span></span> swap_commute<span class="main">:</span> <span class="quoted"><span class="quoted">"swap <span class="free">arr</span> <span class="free">x</span> <span class="free">y</span> <span class="main">=</span> swap <span class="free">arr</span> <span class="free">y</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> swap_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1" id="IMP2_Binary_Heap-swap_eq_on"><span class="command">lemma</span></span> swap_eq_on<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="free">arr1</span> <span class="main">=</span> <span class="free">arr2</span> <span class="keyword1">on</span> <span class="free">S</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">∉</span> <span class="free">S</span> <span class="main">⟹</span> <span class="free">y</span> <span class="main">∉</span> <span class="free">S</span> <span class="main">⟹</span> <span class="free">arr1</span> <span class="main">=</span> swap <span class="free">arr2</span> <span class="free">x</span> <span class="free">y</span> <span class="keyword1">on</span> <span class="free">S</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> swap_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">corollary</span></span> swap_parent_eq_on<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">arr1</span> <span class="main">=</span> <span class="free">arr2</span> <span class="keyword1">on</span> <span class="main">-</span> <span class="main">{</span><span class="free">l</span><span class="main">..&lt;</span><span class="free">r</span><span class="main">}</span>"</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">l</span> <span class="main">&lt;</span> <span class="free">c</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">&lt;</span> <span class="free">r</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">arr1</span> <span class="main">=</span> swap <span class="free">arr2</span> <span class="main">(</span>parent <span class="free">l</span> <span class="free">c</span><span class="main">)</span> <span class="free">c</span> <span class="keyword1">on</span> <span class="main">-</span> <span class="main">{</span><span class="free">l</span><span class="main">..&lt;</span><span class="free">r</span><span class="main">}</span> "</span></span>
  <span class="keyword1"><span class="command">using</span></span> parent_bounds swap_eq_on assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

<span class="keyword1"><span class="command">corollary</span></span> swap_child_eq_on<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">arr1</span> <span class="main">=</span> <span class="free">arr2</span> <span class="keyword1">on</span> <span class="main">-</span> <span class="main">{</span><span class="free">l</span><span class="main">..&lt;</span><span class="free">r</span><span class="main">}</span>"</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">=</span> l_child <span class="free">l</span> <span class="free">p</span> <span class="main">∨</span> <span class="free">c</span> <span class="main">=</span> r_child <span class="free">l</span> <span class="free">p</span>"</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">l</span> <span class="main">≤</span> <span class="free">p</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">&lt;</span> <span class="free">r</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">arr1</span> <span class="main">=</span> swap <span class="free">arr2</span> <span class="free">p</span> <span class="free">c</span> <span class="keyword1">on</span> <span class="main">-</span> <span class="main">{</span><span class="free">l</span><span class="main">..&lt;</span><span class="free">r</span><span class="main">}</span> "</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> assms parent_lower_bound parent_two_children swap_parent_eq_on<span class="main">)</span>

<span class="keyword1" id="IMP2_Binary_Heap-swap_child_mset"><span class="command">lemma</span></span> swap_child_mset<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> 
    <span class="quoted"><span class="quoted">"arr_mset <span class="free">arr1</span> <span class="free">l</span> <span class="free">r</span> <span class="main">=</span> arr_mset <span class="free">arr2</span> <span class="free">l</span> <span class="free">r</span>"</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">=</span> l_child <span class="free">l</span> <span class="free">p</span> <span class="main">∨</span> <span class="free">c</span> <span class="main">=</span> r_child <span class="free">l</span> <span class="free">p</span>"</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">l</span> <span class="main">≤</span> <span class="free">p</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">&lt;</span> <span class="free">r</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"arr_mset <span class="free">arr1</span> <span class="free">l</span> <span class="free">r</span> <span class="main">=</span> arr_mset <span class="main">(</span>swap <span class="free">arr2</span> <span class="free">p</span> <span class="free">c</span><span class="main">)</span> <span class="free">l</span> <span class="free">r</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> child_bounded<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">l</span> <span class="main">&lt;</span> <span class="free">c</span> <span class="main">∧</span> <span class="free">c</span> <span class="main">&lt;</span> <span class="free">r</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> assms<span class="main"><span class="main">(</span></span>2-4<span class="main"><span class="main">)</span></span> parent_lower_bound parent_two_children<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> parent_bounded<span class="main">:</span> <span class="quoted"><span class="quoted">"bounded <span class="free">l</span> <span class="free">r</span> <span class="free">p</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> assms<span class="main"><span class="main">(</span></span>2-4<span class="main"><span class="main">)</span></span> dual_order.strict_trans parent_two_children parent_upper_bound_alt<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>1<span class="main">)</span> child_bounded mset_ran_swap<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">p</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="free">l</span><span class="main">..&lt;</span><span class="free">r</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="free">c</span></span> <span class="quoted"><span class="free">arr2</span></span><span class="main">]</span> atLeastLessThan_iff
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The following lemma shows, which propositions have to hold on the pre-swap array, so that
      a comparison between two elements holds on the post-swap array. This is useful for the 
      proofs of the loop invariants of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>sift_up›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>sift_down›</span></span></span></span>. The lemma is kept 
      quite general (except for the argument order) and could probably be more closely
      related to the parent relation for more concise proofs.›</span></span>
<span class="keyword1" id="IMP2_Binary_Heap-cmp_swapI"><span class="command">lemma</span></span> cmp_swapI<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">arr</span><span class="main">::</span><span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>order <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">::</span>order"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">&lt;</span> <span class="free">n</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">&lt;</span> <span class="free">y</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">&lt;</span> <span class="free">n</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">&lt;</span> <span class="free">y</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">=</span> <span class="free">m</span> <span class="main">⟹</span> <span class="free">y</span> <span class="main">=</span> <span class="free">n</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span><span class="free">arr</span> <span class="free">n</span><span class="main">)</span> <span class="main">(</span><span class="free">arr</span> <span class="free">m</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">&lt;</span> <span class="free">n</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">&lt;</span> <span class="free">y</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">≠</span> <span class="free">m</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">≠</span> <span class="free">n</span> <span class="main">⟹</span> <span class="free">y</span> <span class="main">≠</span> <span class="free">m</span> <span class="main">⟹</span> <span class="free">y</span> <span class="main">≠</span> <span class="free">n</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span><span class="free">arr</span> <span class="free">m</span><span class="main">)</span> <span class="main">(</span><span class="free">arr</span> <span class="free">n</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">&lt;</span> <span class="free">n</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">&lt;</span> <span class="free">y</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">=</span> <span class="free">m</span> <span class="main">⟹</span> <span class="free">y</span> <span class="main">≠</span> <span class="free">m</span> <span class="main">⟹</span> <span class="free">y</span> <span class="main">≠</span> <span class="free">n</span> <span class="main">⟹</span>  <span class="free">P</span> <span class="main">(</span><span class="free">arr</span> <span class="free">y</span><span class="main">)</span> <span class="main">(</span><span class="free">arr</span> <span class="free">n</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">&lt;</span> <span class="free">n</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">&lt;</span> <span class="free">y</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">=</span> <span class="free">n</span> <span class="main">⟹</span> <span class="free">y</span> <span class="main">≠</span> <span class="free">m</span> <span class="main">⟹</span> <span class="free">y</span> <span class="main">≠</span> <span class="free">n</span> <span class="main">⟹</span>  <span class="free">P</span> <span class="main">(</span><span class="free">arr</span> <span class="free">m</span><span class="main">)</span> <span class="main">(</span><span class="free">arr</span> <span class="free">y</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">&lt;</span> <span class="free">n</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">&lt;</span> <span class="free">y</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">≠</span> <span class="free">m</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">≠</span> <span class="free">n</span> <span class="main">⟹</span> <span class="free">y</span> <span class="main">=</span> <span class="free">n</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span><span class="free">arr</span> <span class="free">m</span><span class="main">)</span> <span class="main">(</span><span class="free">arr</span> <span class="free">x</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">&lt;</span> <span class="free">n</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">&lt;</span> <span class="free">y</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">≠</span> <span class="free">m</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">≠</span> <span class="free">n</span> <span class="main">⟹</span> <span class="free">y</span> <span class="main">=</span> <span class="free">m</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span><span class="free">arr</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span><span class="free">arr</span> <span class="free">n</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">(</span>swap <span class="free">arr</span> <span class="free">x</span> <span class="free">y</span> <span class="free">m</span><span class="main">)</span> <span class="main">(</span>swap <span class="free">arr</span> <span class="free">x</span> <span class="free">y</span> <span class="free">n</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> assms order.asym swap_only_swaps swap_swaps<span class="main">)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Imperative Heap Implementation›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The following imperative heap functions are based on \cite{MS} and \cite{CLRS}. All functions,
      that are recursive in these books, are iterative in the following implementations. The 
      function definitions are done with IMP2 \cite{IMP2-AFP}. From now on the heaps only contain 
      ints and only use <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>≤›</span></span></span></span> as comparison function. The auxiliary lemmas used from now on are 
      heavily modeled after the proof goals, that are generated by the vcg tool (also part of IMP2).›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Simple Functions›</span></span>
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Parent, Children and Swap›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In this section the parent and children relations are expressed as IMP2 procedures. 
      Additionally a simple procedure, that swaps two array elements, is defined.›</span></span>
<span class="keyword1"><span class="command">procedure_spec</span></span> <span class="entity">prnt</span> <span class="main">(</span>l<span class="main">,</span> x<span class="main">)</span> <span class="keyword2"><span class="keyword">returns</span></span> p
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted">True</span>
    <span class="keyword2"><span class="keyword">ensures</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">=</span> parent <span class="skolem">l<span class="hidden">⇩</span><sub>0</sub></span> <span class="skolem">x<span class="hidden">⇩</span><sub>0</sub></span>"</span></span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted">‹p <span class="main"><span class="main">=</span></span> <span class="main"><span class="main">(</span></span><span class="main"><span class="main">(</span></span>x <span class="main"><span class="main">-</span></span> l <span class="main"><span class="main">-</span></span> 1<span class="main"><span class="main">)</span></span> <span class="main"><span class="main">/</span></span> 2 <span class="main"><span class="main">+</span></span> l<span class="main"><span class="main">)</span></span>›</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">vcg</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> parent_def<span class="main">)</span>

<span class="keyword1"><span class="command">procedure_spec</span></span> <span class="entity">left_child</span> <span class="main">(</span>l<span class="main">,</span> x<span class="main">)</span> <span class="keyword2"><span class="keyword">returns</span></span> lc
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted">True</span> 
    <span class="keyword2"><span class="keyword">ensures</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">lc</span> <span class="main">=</span> l_child <span class="skolem">l<span class="hidden">⇩</span><sub>0</sub></span> <span class="skolem">x<span class="hidden">⇩</span><sub>0</sub></span>"</span></span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted">‹lc <span class="main"><span class="main">=</span></span> 2 <span class="main"><span class="main">*</span></span> x <span class="main"><span class="main">-</span></span> l <span class="main"><span class="main">+</span></span> 1›</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">vcg</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> l_child_def<span class="main">)</span>

<span class="keyword1"><span class="command">procedure_spec</span></span> <span class="entity">right_child</span> <span class="main">(</span>l<span class="main">,</span> x<span class="main">)</span> <span class="keyword2"><span class="keyword">returns</span></span> rc
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted">True</span>
    <span class="keyword2"><span class="keyword">ensures</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">rc</span> <span class="main">=</span> r_child <span class="skolem">l<span class="hidden">⇩</span><sub>0</sub></span> <span class="skolem">x<span class="hidden">⇩</span><sub>0</sub></span>"</span></span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted">‹rc <span class="main"><span class="main">=</span></span> 2 <span class="main"><span class="main">*</span></span> x <span class="main"><span class="main">-</span></span> l <span class="main"><span class="main">+</span></span> 2›</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">vcg</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> r_child_def<span class="main">)</span>

<span class="keyword1"><span class="command">procedure_spec</span></span> <span class="entity">swp</span> <span class="main">(</span>heap<span class="main">,</span> x<span class="main">,</span> y<span class="main">)</span> <span class="keyword2"><span class="keyword">returns</span></span> heap
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted">True</span>
    <span class="keyword2"><span class="keyword">ensures</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">heap</span> <span class="main">=</span> swap <span class="skolem">heap<span class="hidden">⇩</span><sub>0</sub></span> <span class="skolem">x<span class="hidden">⇩</span><sub>0</sub></span> <span class="skolem">y<span class="hidden">⇩</span><sub>0</sub></span> "</span></span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted">‹tmp <span class="main"><span class="main">=</span></span> heap<span class="main"><span class="main">[</span></span>x<span class="main"><span class="main">]</span></span><span class="main"><span class="main">;</span></span> heap<span class="main"><span class="main">[</span></span>x<span class="main"><span class="main">]</span></span> <span class="main"><span class="main">=</span></span> heap<span class="main"><span class="main">[</span></span>y<span class="main"><span class="main">]</span></span><span class="main"><span class="main">;</span></span> heap<span class="main"><span class="main">[</span></span>y<span class="main"><span class="main">]</span></span> <span class="main"><span class="main">=</span></span> tmp›</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">vcg</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> swap_def<span class="main">)</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>get_min›</span></span></span></span>›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In this section <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>get_min›</span></span></span></span> is defined, which simply returns the first element (the minimum) of 
      the heap. For this definition an additional theorem is proven, which enables the use of
      <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "Min_mset"<span class="antiquote"><span class="antiquote">}</span></span></span></span> in the postcondition.›</span></span>

<span class="keyword1"><span class="command">theorem</span></span> heap_minimum<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">l</span> <span class="main">&lt;</span> <span class="free">r</span>"</span></span> 
    <span class="quoted"><span class="quoted">"is_heap <span class="main">(≤)</span> <span class="free">heap</span> <span class="free">l</span> <span class="free">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">heap</span> <span class="free">l</span> <span class="main">=</span> Min_mset <span class="main">(</span>arr_mset <span class="free">heap</span> <span class="free">l</span> <span class="free">r</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈#</span> <span class="main">(</span>arr_mset <span class="free">heap</span> <span class="free">l</span> <span class="free">r</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="free">heap</span> <span class="free">l</span><span class="main">)</span> <span class="main">≤</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">)</span> heap_first_el_alt transp_le <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> dual_order.antisym<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">procedure_spec</span></span> <span class="entity">get_min</span> <span class="main">(</span>heap<span class="main">,</span> l<span class="main">,</span> r<span class="main">)</span> <span class="keyword2"><span class="keyword">returns</span></span> min
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">l</span> <span class="main">&lt;</span> <span class="skolem">r</span> <span class="main">∧</span> is_heap <span class="main">(≤)</span> <span class="skolem">heap</span> <span class="skolem">l</span> <span class="skolem">r</span>"</span></span>  
    <span class="keyword2"><span class="keyword">ensures</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">min</span> <span class="main">=</span> Min_mset <span class="main">(</span>arr_mset <span class="skolem">heap<span class="hidden">⇩</span><sub>0</sub></span> <span class="skolem">l<span class="hidden">⇩</span><sub>0</sub></span> <span class="skolem">r<span class="hidden">⇩</span><sub>0</sub></span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> heap<span class="main">[</span><span class="main">]</span> l r
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted">‹min <span class="main"><span class="main">=</span></span> heap<span class="main"><span class="main">[</span></span>l<span class="main"><span class="main">]</span></span>›</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">vcg</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> heap_minimum<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Modifying Functions›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>sift_up›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>insert›</span></span></span></span>›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The next heap function is <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>insert›</span></span></span></span>, which internally uses <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>sift_up›</span></span></span></span>. In the beginning of 
      this section <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>sift_up_step›</span></span></span></span> is proven, which states that each <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>sift_up›</span></span></span></span> loop iteration 
      correctly transforms the weakened heap invariant. For its proof two additional
      auxiliary lemmas are used. After <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>sift_up_step›</span></span></span></span> <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>sift_up›</span></span></span></span> and then <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>insert›</span></span></span></span> are verified.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>sift_up_step›</span></span></span></span> can be proven directly by the smt-solver without auxiliary lemmas, but they
      were introduced to show the proof details. The analogous proofs for <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>sift_down›</span></span></span></span> were 
      just solved with smt, since the proof structure should be very similar, even though the 
      <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>sift_down›</span></span></span></span> proof goals are slightly more complex.›</span></span>
<span class="keyword1" id="IMP2_Binary_Heap-sift_up_step_aux1"><span class="command">lemma</span></span> sift_up_step_aux1<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">heap</span><span class="main">::</span><span class="quoted"><span class="quoted">"int <span class="main">⇒</span> int"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span>  
    <span class="quoted"><span class="quoted">"is_heap_except_up <span class="main">(≤)</span> <span class="free">heap</span> <span class="free">l</span> <span class="free">r</span> <span class="free">x</span>"</span></span>
    <span class="quoted"><span class="quoted">"parent <span class="free">l</span> <span class="free">x</span> <span class="main">≥</span> <span class="free">l</span>"</span></span> 
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">heap</span> <span class="free">x</span><span class="main">)</span> <span class="main">≤</span> <span class="main">(</span><span class="free">heap</span> <span class="main">(</span>parent <span class="free">l</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span> 
    <span class="quoted"><span class="quoted">"bounded <span class="free">l</span> <span class="free">r</span> <span class="free">k</span>"</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">≠</span> <span class="main">(</span>parent <span class="free">l</span> <span class="free">x</span><span class="main">)</span>"</span></span> 
    <span class="quoted"><span class="quoted">"bounded <span class="free">l</span> <span class="free">r</span> <span class="main">(</span>parent <span class="free">l</span> <span class="free">k</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>swap <span class="free">heap</span> <span class="main">(</span>parent <span class="free">l</span> <span class="free">x</span><span class="main">)</span> <span class="free">x</span> <span class="main">(</span>parent <span class="free">l</span> <span class="free">k</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span> <span class="main">(</span>swap <span class="free">heap</span> <span class="main">(</span>parent <span class="free">l</span> <span class="free">x</span><span class="main">)</span> <span class="free">x</span> <span class="free">k</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">intro</span> cmp_swapI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>parent <span class="free">l</span> <span class="free">k</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="free">k</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>parent <span class="free">l</span> <span class="free">x</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="quoted">"<span class="main">(≤)</span>"</span></span> <span class="quoted"><span class="free">heap</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">,</span>6<span class="main">)</span> parent_upper_bound_alt <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>3<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>1<span class="main">,</span>4<span class="main">,</span>6<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> is_heap_except_up_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>1<span class="main">,</span>3<span class="main">,</span>4<span class="main">,</span>6<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> is_heap_except_up_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>5<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>1<span class="main">,</span>2<span class="main">,</span>4<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> is_heap_except_up_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="IMP2_Binary_Heap-sift_up_step_aux2"><span class="command">lemma</span></span> sift_up_step_aux2<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">heap</span><span class="main">::</span><span class="quoted"><span class="quoted">"int <span class="main">⇒</span> int"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span>
    <span class="quoted"><span class="quoted">"is_heap_except_up <span class="main">(≤)</span> <span class="free">heap</span> <span class="free">l</span> <span class="free">r</span> <span class="free">x</span>"</span></span>
    <span class="quoted"><span class="quoted">"parent <span class="free">l</span> <span class="free">x</span> <span class="main">≥</span> <span class="free">l</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">heap</span> <span class="free">x</span> <span class="main">≤</span> <span class="main">(</span><span class="free">heap</span> <span class="main">(</span>parent <span class="free">l</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"bounded <span class="free">l</span> <span class="free">r</span> <span class="free">k</span>"</span></span>
    <span class="quoted"><span class="quoted">"parent <span class="free">l</span> <span class="free">k</span> <span class="main">=</span> parent <span class="free">l</span> <span class="free">x</span>"</span></span>
    <span class="quoted"><span class="quoted">"bounded <span class="free">l</span> <span class="free">r</span> <span class="main">(</span>parent <span class="free">l</span> <span class="main">(</span>parent <span class="free">l</span> <span class="free">k</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> 
    <span class="quoted"><span class="quoted">"swap <span class="free">heap</span> <span class="main">(</span>parent <span class="free">l</span> <span class="free">x</span><span class="main">)</span> <span class="free">x</span> <span class="main">(</span>parent <span class="free">l</span> <span class="main">(</span>parent <span class="free">l</span> <span class="free">k</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span> swap <span class="free">heap</span> <span class="main">(</span>parent <span class="free">l</span> <span class="free">x</span><span class="main">)</span> <span class="free">x</span> <span class="free">k</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> is_heap_except_up_def
<span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?gp_k</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"parent <span class="free">l</span> <span class="main">(</span>parent <span class="free">l</span> <span class="free">k</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?gp_x</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"parent <span class="free">l</span> <span class="main">(</span>parent <span class="free">l</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> gp_k_eq_gp_x<span class="main">:</span> <span class="quoted"><span class="quoted">"swap <span class="free">heap</span> <span class="main">(</span>parent <span class="free">l</span> <span class="free">x</span><span class="main">)</span> <span class="free">x</span> <span class="var">?gp_k</span> <span class="main">=</span> <span class="free">heap</span> <span class="var">?gp_x</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">,</span></span>5<span class="main"><span class="main">)</span></span> grand_parent_upper_bound less_irrefl swap_only_swaps<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> is_heap_except_up_def
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span><span class="main">)</span>
    <span class="keyword3"><span class="command">assume</span></span> k_eq_x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"swap <span class="free">heap</span> <span class="main">(</span>parent <span class="free">l</span> <span class="free">x</span><span class="main">)</span> <span class="free">x</span> <span class="free">k</span> <span class="main">=</span> <span class="free">heap</span> <span class="main">(</span>parent <span class="free">l</span> <span class="free">x</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> k_eq_x swap_swaps<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>1<span class="main">,</span>2<span class="main">,</span>4<span class="main">,</span>6<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> is_heap_except_up_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> gp_k_eq_gp_x k_eq_x parent_bounds parent_lower_bound<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> k_neq_x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">≠</span> <span class="free">x</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"swap <span class="free">heap</span> <span class="main">(</span>parent <span class="free">l</span> <span class="free">x</span><span class="main">)</span> <span class="free">x</span> <span class="free">k</span> <span class="main">=</span> <span class="free">heap</span> <span class="free">k</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> assms<span class="main"><span class="main">(</span></span>5<span class="main"><span class="main">)</span></span> gp_k_eq_gp_x k_neq_x swap_only_swaps<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> is_heap_except_up_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> gp_k_eq_gp_x k_neq_x order_trans parent_bounds parent_lower_bound<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="IMP2_Binary_Heap-sift_up_step"><span class="command">lemma</span></span> sift_up_step<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">heap</span><span class="main">::</span><span class="quoted"><span class="quoted">"int <span class="main">⇒</span> int"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span>  
    <span class="quoted"><span class="quoted">"is_heap_except_up <span class="main">(≤)</span> <span class="free">heap</span> <span class="free">l</span> <span class="free">r</span> <span class="free">x</span>"</span></span>
    <span class="quoted"><span class="quoted">"parent <span class="free">l</span> <span class="free">x</span> <span class="main">≥</span> <span class="free">l</span>"</span></span> 
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">heap</span> <span class="free">x</span><span class="main">)</span> <span class="main">≤</span> <span class="main">(</span><span class="free">heap</span> <span class="main">(</span>parent <span class="free">l</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"is_heap_except_up <span class="main">(≤)</span> <span class="main">(</span>swap <span class="free">heap</span> <span class="main">(</span>parent <span class="free">l</span> <span class="free">x</span><span class="main">)</span> <span class="free">x</span><span class="main">)</span> <span class="free">l</span> <span class="free">r</span> <span class="main">(</span>parent <span class="free">l</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms sift_up_step_aux1 sift_up_step_aux2
  <span class="keyword1"><span class="command">unfolding</span></span> is_heap_except_up_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>sift_up›</span></span></span></span> restores the heap invariant, that is only violated at the current position, by 
      iteratively swapping the current element with its parent until the beginning of the array is 
      reached or the current element is bigger than its parent.›</span></span>
<span class="keyword1"><span class="command">procedure_spec</span></span> <span class="entity">sift_up</span> <span class="main">(</span>heap<span class="main">,</span> l<span class="main">,</span> r<span class="main">,</span> x<span class="main">)</span> <span class="keyword2"><span class="keyword">returns</span></span> heap
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"is_heap_except_up <span class="main">(≤)</span> <span class="skolem">heap</span> <span class="skolem">l</span> <span class="skolem">r</span> <span class="skolem">x</span> <span class="main">∧</span> bounded <span class="skolem">l</span> <span class="skolem">r</span> <span class="skolem">x</span>"</span></span>
    <span class="keyword2"><span class="keyword">ensures</span></span> <span class="quoted"><span class="quoted">"is_heap <span class="main">(≤)</span> <span class="skolem">heap</span> <span class="skolem">l<span class="hidden">⇩</span><sub>0</sub></span> <span class="skolem">r<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">∧</span>
             arr_mset <span class="skolem">heap<span class="hidden">⇩</span><sub>0</sub></span> <span class="skolem">l<span class="hidden">⇩</span><sub>0</sub></span> <span class="skolem">r<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">=</span> arr_mset <span class="skolem">heap</span> <span class="skolem">l<span class="hidden">⇩</span><sub>0</sub></span> <span class="skolem">r<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">∧</span>
             <span class="skolem">heap<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">=</span> <span class="skolem">heap</span> <span class="keyword1">on</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">l<span class="hidden">⇩</span><sub>0</sub></span><span class="main">..&lt;</span><span class="skolem">r<span class="hidden">⇩</span><sub>0</sub></span><span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> heap<span class="main">[</span><span class="main">]</span> l x r
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted">‹
    p <span class="main"><span class="main">=</span></span> prnt<span class="main"><span class="main">(</span></span>l<span class="main"><span class="main">,</span></span> x<span class="main"><span class="main">)</span></span><span class="main"><span class="main">;</span></span>
    <span class="keyword2"><span class="keyword"><span class="keyword1">while</span></span></span> <span class="main"><span class="keyword1">(</span></span>x <span class="main"><span class="main">&gt;</span></span> l <span class="main"><span class="main">∧</span></span> heap<span class="main"><span class="main">[</span></span>x<span class="main"><span class="main">]</span></span> <span class="main"><span class="main">≤</span></span> heap<span class="main"><span class="main">[</span></span>p<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword1">)</span></span> 
      <span class="main"><span class="keyword1">@variant</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">-</span> <span class="skolem">l</span>›</span></span>
      <span class="main"><span class="keyword1">@invariant</span></span> <span class="quoted"><span class="quoted">‹is_heap_except_up <span class="main">(≤)</span> <span class="skolem">heap</span> <span class="skolem">l</span> <span class="skolem">r</span> <span class="skolem">x</span> <span class="main">∧</span> <span class="skolem">p</span> <span class="main">=</span> parent <span class="skolem">l</span> <span class="skolem">x</span> <span class="main">∧</span> 
                  bounded <span class="skolem">l</span> <span class="skolem">r</span> <span class="skolem">x</span> <span class="main">∧</span> arr_mset <span class="skolem">heap<span class="hidden">⇩</span><sub>0</sub></span> <span class="skolem">l<span class="hidden">⇩</span><sub>0</sub></span> <span class="skolem">r<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">=</span> arr_mset <span class="skolem">heap</span> <span class="skolem">l</span> <span class="skolem">r</span> <span class="main">∧</span>
                  <span class="skolem">heap<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">=</span> <span class="skolem">heap</span>  <span class="keyword1">on</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">l</span><span class="main">..&lt;</span><span class="skolem">r</span><span class="main">}</span>›</span></span> 
    <span class="main"><span class="main">{</span></span>
        heap <span class="main"><span class="main">=</span></span> swp<span class="main"><span class="main">(</span></span>heap<span class="main"><span class="main">,</span></span> p<span class="main"><span class="main">,</span></span> x<span class="main"><span class="main">)</span></span><span class="main"><span class="main">;</span></span>
        x <span class="main"><span class="main">=</span></span> p<span class="main"><span class="main">;</span></span>
        p <span class="main"><span class="main">=</span></span> prnt<span class="main"><span class="main">(</span></span>l<span class="main"><span class="main">,</span></span> x<span class="main"><span class="main">)</span></span>
    <span class="main"><span class="main">}</span></span>›</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">vcg_cs</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">intro</span> conjI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> parent_lower_bound sift_up_step <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> parent_lower_bound <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> parent_bounds <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> parent_bounds <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mset_ran_swap<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> swap_parent_eq_on <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> parent_upper_bound <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> is_heap_except_up_def is_partial_heap_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> le_less not_less parent_lower_bound<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>insert›</span></span></span></span> inserts an element into a heap by appending it to the heap and restoring the heap 
      invariant with <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "sift_up"<span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>
<span class="keyword1"><span class="command">procedure_spec</span></span> <span class="entity">insert</span> <span class="main">(</span>heap<span class="main">,</span> l<span class="main">,</span> r<span class="main">,</span> el<span class="main">)</span> <span class="keyword2"><span class="keyword">returns</span></span> <span class="main">(</span>heap<span class="main">,</span> l<span class="main">,</span> r<span class="main">)</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"is_heap <span class="main">(≤)</span> <span class="skolem">heap</span> <span class="skolem">l</span> <span class="skolem">r</span> <span class="main">∧</span> <span class="skolem">l</span> <span class="main">≤</span> <span class="skolem">r</span>"</span></span>  
    <span class="keyword2"><span class="keyword">ensures</span></span> <span class="quoted"><span class="quoted">"is_heap <span class="main">(≤)</span> <span class="skolem">heap</span> <span class="skolem">l</span> <span class="skolem">r</span> <span class="main">∧</span>
             arr_mset <span class="skolem">heap</span> <span class="skolem">l</span> <span class="skolem">r</span> <span class="main">=</span> arr_mset <span class="skolem">heap<span class="hidden">⇩</span><sub>0</sub></span> <span class="skolem">l<span class="hidden">⇩</span><sub>0</sub></span> <span class="skolem">r<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">+</span> <span class="main">{#</span><span class="skolem">el<span class="hidden">⇩</span><sub>0</sub></span><span class="main">#}</span> <span class="main">∧</span>
             <span class="skolem">l</span> <span class="main">=</span> <span class="skolem">l<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">∧</span> <span class="skolem">r</span> <span class="main">=</span> <span class="skolem">r<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">+</span> <span class="main">1</span>  <span class="main">∧</span> <span class="skolem">heap<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">=</span> <span class="skolem">heap</span> <span class="keyword1">on</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">l</span><span class="main">..&lt;</span><span class="skolem">r</span><span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> heap l r el
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted">‹
    heap<span class="main"><span class="main">[</span></span>r<span class="main"><span class="main">]</span></span> <span class="main"><span class="main">=</span></span> el<span class="main"><span class="main">;</span></span>
    x <span class="main"><span class="main">=</span></span> r<span class="main"><span class="main">;</span></span>
    r <span class="main"><span class="main">=</span></span> r <span class="main"><span class="main">+</span></span> 1<span class="main"><span class="main">;</span></span>
    heap <span class="main"><span class="main">=</span></span> sift_up<span class="main"><span class="main">(</span></span>heap<span class="main"><span class="main">,</span></span> l<span class="main"><span class="main">,</span></span> r<span class="main"><span class="main">,</span></span> x<span class="main"><span class="main">)</span></span>
  ›</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">vcg_cs</span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> heap_appended_el<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> arr_mset_append_alt add_mset_add_single<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>sift_down›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>del_min›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>make_heap›</span></span></span></span>›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The next heap functions are <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>del_min›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>make_heap›</span></span></span></span>, which both use <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>sift_down›</span></span></span></span> to 
      restore/establish the heap invariant. <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>sift_down›</span></span></span></span> is proven first (this time without 
      additional auxiliary lemmas) followed by <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>del_min›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>make_heap›</span></span></span></span>.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>sift_down›</span></span></span></span> restores the heap invariant, that is only violated at the current position, by 
      iteratively swapping the current element with its smallest child until the end of 
      the array is reached or the current element is smaller than its children.›</span></span>
<span class="keyword1"><span class="command">procedure_spec</span></span> <span class="entity">sift_down</span><span class="main">(</span>heap<span class="main">,</span> l<span class="main">,</span> r<span class="main">,</span> x<span class="main">)</span> <span class="keyword2"><span class="keyword">returns</span></span> heap 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"is_partial_heap_except_down <span class="main">(≤)</span> <span class="skolem">heap</span> <span class="skolem">l</span> <span class="skolem">x</span> <span class="skolem">r</span> <span class="skolem">x</span> <span class="main">∧</span> <span class="skolem">l</span> <span class="main">≤</span> <span class="skolem">x</span> <span class="main">∧</span> <span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">r</span>"</span></span>
    <span class="keyword2"><span class="keyword">ensures</span></span> <span class="quoted"><span class="quoted">"is_partial_heap <span class="main">(≤)</span> <span class="skolem">heap</span> <span class="skolem">l<span class="hidden">⇩</span><sub>0</sub></span> <span class="skolem">x<span class="hidden">⇩</span><sub>0</sub></span> <span class="skolem">r<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">∧</span> 
             arr_mset <span class="skolem">heap<span class="hidden">⇩</span><sub>0</sub></span> <span class="skolem">l<span class="hidden">⇩</span><sub>0</sub></span> <span class="skolem">r<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">=</span> arr_mset <span class="skolem">heap</span> <span class="skolem">l<span class="hidden">⇩</span><sub>0</sub></span> <span class="skolem">r<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">∧</span> 
             <span class="skolem">heap<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">=</span> <span class="skolem">heap</span> <span class="keyword1">on</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">l<span class="hidden">⇩</span><sub>0</sub></span><span class="main">..&lt;</span><span class="skolem">r<span class="hidden">⇩</span><sub>0</sub></span><span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted">‹
   lc <span class="main"><span class="main">=</span></span> left_child<span class="main"><span class="main">(</span></span>l<span class="main"><span class="main">,</span></span> x<span class="main"><span class="main">)</span></span><span class="main"><span class="main">;</span></span>
   rc <span class="main"><span class="main">=</span></span> right_child<span class="main"><span class="main">(</span></span>l<span class="main"><span class="main">,</span></span> x<span class="main"><span class="main">)</span></span><span class="main"><span class="main">;</span></span>
    <span class="keyword2"><span class="keyword"><span class="keyword1">while</span></span></span> <span class="main"><span class="keyword1">(</span></span>lc <span class="main"><span class="main">&lt;</span></span> r <span class="main"><span class="main">∧</span></span> <span class="main"><span class="main">(</span></span>heap<span class="main"><span class="main">[</span></span>lc<span class="main"><span class="main">]</span></span> <span class="main"><span class="main">&lt;</span></span> heap<span class="main"><span class="main">[</span></span>x<span class="main"><span class="main">]</span></span> <span class="main"><span class="main">∨</span></span> <span class="main"><span class="main">(</span></span>rc <span class="main"><span class="main">&lt;</span></span> r <span class="main"><span class="main">∧</span></span> heap<span class="main"><span class="main">[</span></span>rc<span class="main"><span class="main">]</span></span> <span class="main"><span class="main">&lt;</span></span> heap<span class="main"><span class="main">[</span></span>x<span class="main"><span class="main">]</span></span><span class="main"><span class="main">)</span></span><span class="main"><span class="main">)</span></span><span class="main"><span class="keyword1">)</span></span> 
      <span class="main"><span class="keyword1">@variant</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">r</span> <span class="main">-</span> <span class="skolem">x</span>›</span></span>
      <span class="main"><span class="keyword1">@invariant</span></span> <span class="quoted"><span class="quoted">‹is_partial_heap_except_down <span class="main">(≤)</span> <span class="skolem">heap</span> <span class="skolem">l</span> <span class="skolem">x<span class="hidden">⇩</span><sub>0</sub></span> <span class="skolem">r</span> <span class="skolem">x</span> <span class="main">∧</span>
                  <span class="skolem">x<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">≤</span> <span class="skolem">x</span> <span class="main">∧</span> <span class="skolem">x</span> <span class="main">≤</span> <span class="skolem">r</span> <span class="main">∧</span> <span class="skolem">lc</span> <span class="main">=</span> l_child <span class="skolem">l</span> <span class="skolem">x</span> <span class="main">∧</span> <span class="skolem">rc</span> <span class="main">=</span> r_child <span class="skolem">l</span> <span class="skolem">x</span> <span class="main">∧</span>
                  arr_mset <span class="skolem">heap<span class="hidden">⇩</span><sub>0</sub></span> <span class="skolem">l</span> <span class="skolem">r</span> <span class="main">=</span> arr_mset <span class="skolem">heap</span> <span class="skolem">l</span> <span class="skolem">r</span> <span class="main">∧</span>
                  <span class="skolem">heap<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">=</span> <span class="skolem">heap</span> <span class="keyword1">on</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">l</span><span class="main">..&lt;</span><span class="skolem">r</span><span class="main">}</span>›</span></span>
  <span class="main"><span class="main">{</span></span> 
    smallest <span class="main"><span class="main">=</span></span> lc<span class="main"><span class="main">;</span></span>
    <span class="keyword2"><span class="keyword"><span class="keyword1">if</span></span></span> <span class="main"><span class="keyword1">(</span></span>rc <span class="main"><span class="main">&lt;</span></span> r <span class="main"><span class="main">∧</span></span> heap<span class="main"><span class="main">[</span></span>rc<span class="main"><span class="main">]</span></span> <span class="main"><span class="main">&lt;</span></span> heap<span class="main"><span class="main">[</span></span>lc<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword1">)</span></span> <span class="main"><span class="main">{</span></span>
      smallest <span class="main"><span class="main">=</span></span> rc
    <span class="main"><span class="main">}</span></span><span class="main"><span class="main">;</span></span>
    heap <span class="main"><span class="main">=</span></span> swp<span class="main"><span class="main">(</span></span>heap<span class="main"><span class="main">,</span></span> x<span class="main"><span class="main">,</span></span> smallest<span class="main"><span class="main">)</span></span><span class="main"><span class="main">;</span></span>
    x <span class="main"><span class="main">=</span></span> smallest<span class="main"><span class="main">;</span></span>
    lc <span class="main"><span class="main">=</span></span> left_child<span class="main"><span class="main">(</span></span>l<span class="main"><span class="main">,</span></span> x<span class="main"><span class="main">)</span></span><span class="main"><span class="main">;</span></span>
    rc <span class="main"><span class="main">=</span></span> right_child<span class="main"><span class="main">(</span></span>l<span class="main"><span class="main">,</span></span> x<span class="main"><span class="main">)</span></span>
  <span class="main"><span class="main">}</span></span>›</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">vcg_cs</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">intro</span> conjI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> is_partial_heap_except_down_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> parent_two_children swap_swaps swap_only_swaps
          swap_commute parent_upper_bound_alt<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> r_child_lower_bound_alt <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> swap_child_mset order_trans <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> swap_child_eq_on <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> less_le_trans not_le order.asym r_child_lower_bound<span class="main">)</span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">intro</span> conjI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> is_partial_heap_except_down_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> parent_two_children swap_swaps swap_only_swaps
          swap_commute parent_upper_bound_alt<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> l_child_lower_bound_alt <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> swap_child_mset order_trans <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> swap_child_eq_on <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> less_le_trans not_le order.asym l_child_lower_bound<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> is_partial_heap_except_down_def is_partial_heap_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> dual_order.strict_trans not_less parent_two_children smaller_l_child<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>del_min›</span></span></span></span> needs an additional lemma which shows, that it actually removes (only) the minimum
      from the heap.›</span></span>
<span class="keyword1" id="IMP2_Binary_Heap-del_min_mset"><span class="command">lemma</span></span> del_min_mset<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">heap</span><span class="main">::</span><span class="quoted"><span class="quoted">"int <span class="main">⇒</span> int"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">l</span> <span class="main">&lt;</span> <span class="free">r</span>"</span></span>
    <span class="quoted"><span class="quoted">"is_heap <span class="main">(≤)</span> <span class="free">heap</span> <span class="free">l</span> <span class="free">r</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">mod_heap</span> <span class="main">=</span> <span class="free">heap</span><span class="main">(</span><span class="free">l</span> <span class="main">:=</span> <span class="free">heap</span> <span class="main">(</span><span class="free">r</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"arr_mset <span class="free">mod_heap</span> <span class="free">l</span> <span class="main">(</span><span class="free">r</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="main">=</span> arr_mset <span class="free">new_heap</span> <span class="free">l</span> <span class="main">(</span><span class="free">r</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> 
    <span class="quoted"><span class="quoted">"arr_mset <span class="free">new_heap</span> <span class="free">l</span> <span class="main">(</span><span class="free">r</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="main">=</span> arr_mset <span class="free">heap</span> <span class="free">l</span> <span class="free">r</span> <span class="main">-</span> <span class="main">{#</span>Min_mset <span class="main">(</span>arr_mset <span class="free">heap</span> <span class="free">l</span> <span class="free">r</span><span class="main">)</span><span class="main">#}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?heap_mset</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"arr_mset <span class="free">heap</span> <span class="free">l</span> <span class="free">r</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> l_is_min<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">heap</span> <span class="free">l</span> <span class="main">=</span> Min_mset <span class="var">?heap_mset</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>1<span class="main">,</span>2<span class="main">)</span> heap_minimum <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>arr_mset <span class="free">mod_heap</span> <span class="free">l</span> <span class="free">r</span><span class="main">)</span> <span class="main">=</span> <span class="var">?heap_mset</span> <span class="main">+</span> <span class="main">{#</span><span class="free">heap</span> <span class="main">(</span><span class="free">r</span><span class="main">-</span><span class="main">1</span><span class="main">)</span><span class="main">#}</span> <span class="main">-</span> <span class="main">{#</span><span class="free">heap</span> <span class="free">l</span><span class="main">#}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">,</span></span>3<span class="main"><span class="main">)</span></span> mset_ran_subst_inside<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>arr_mset <span class="free">mod_heap</span> <span class="free">l</span> <span class="main">(</span><span class="free">r</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="var">?heap_mset</span> <span class="main">-</span> <span class="main">{#</span><span class="free">heap</span> <span class="free">l</span><span class="main">#}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">,</span></span>3<span class="main"><span class="main">)</span></span> arr_mset_remove_last<span class="main">)</span> 
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>4<span class="main">)</span> l_is_min <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>del_min›</span></span></span></span> removes the minimum element from the heap by replacing the first element with the 
      last element, shrinking the array by one and subsequently restoring the heap invariant 
      with <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "sift_down"<span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>
<span class="keyword1"><span class="command">procedure_spec</span></span> <span class="entity">del_min</span> <span class="main">(</span>heap<span class="main">,</span> l<span class="main">,</span> r<span class="main">)</span> <span class="keyword2"><span class="keyword">returns</span></span> <span class="main">(</span>heap<span class="main">,</span> l<span class="main">,</span> r<span class="main">)</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">l</span> <span class="main">&lt;</span> <span class="skolem">r</span> <span class="main">∧</span> is_heap <span class="main">(≤)</span> <span class="skolem">heap</span> <span class="skolem">l</span> <span class="skolem">r</span>"</span></span>  
    <span class="keyword2"><span class="keyword">ensures</span></span> <span class="quoted"><span class="quoted">"is_heap <span class="main">(≤)</span> <span class="skolem">heap</span> <span class="skolem">l</span> <span class="skolem">r</span> <span class="main">∧</span> 
             arr_mset <span class="skolem">heap</span> <span class="skolem">l</span> <span class="skolem">r</span> <span class="main">=</span> arr_mset <span class="skolem">heap<span class="hidden">⇩</span><sub>0</sub></span> <span class="skolem">l<span class="hidden">⇩</span><sub>0</sub></span> <span class="skolem">r<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">-</span> <span class="main">{#</span>Min_mset <span class="main">(</span>arr_mset <span class="skolem">heap<span class="hidden">⇩</span><sub>0</sub></span> <span class="skolem">l<span class="hidden">⇩</span><sub>0</sub></span> <span class="skolem">r<span class="hidden">⇩</span><sub>0</sub></span><span class="main">)</span><span class="main">#}</span> <span class="main">∧</span> 
             <span class="skolem">l</span> <span class="main">=</span> <span class="skolem">l<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">∧</span> <span class="skolem">r</span> <span class="main">=</span> <span class="skolem">r<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">-</span> <span class="main">1</span> <span class="main">∧</span> 
             <span class="skolem">heap<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">=</span> <span class="skolem">heap</span> <span class="keyword1">on</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">l<span class="hidden">⇩</span><sub>0</sub></span><span class="main">..&lt;</span><span class="skolem">r<span class="hidden">⇩</span><sub>0</sub></span><span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> heap l r
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted">‹
    r <span class="main"><span class="main">=</span></span> r <span class="main"><span class="main">-</span></span> 1<span class="main"><span class="main">;</span></span>
    heap<span class="main"><span class="main">[</span></span>l<span class="main"><span class="main">]</span></span> <span class="main"><span class="main">=</span></span> heap<span class="main"><span class="main">[</span></span>r<span class="main"><span class="main">]</span></span><span class="main"><span class="main">;</span></span>
    heap <span class="main"><span class="main">=</span></span> sift_down<span class="main"><span class="main">(</span></span>heap<span class="main"><span class="main">,</span></span> l<span class="main"><span class="main">,</span></span> r<span class="main"><span class="main">,</span></span> l<span class="main"><span class="main">)</span></span>
  ›</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">vcg_cs</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> heap_changed_first_el is_partial_heap_smaller_back<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> conjI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> del_min_mset <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq_on_def intvs_incdec<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> intvs_lower_incr<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>make_heap›</span></span></span></span> transforms an arbitrary array into a heap by iterating through all array 
      positions from the middle of the array up to the beginning of the array and calling 
      <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "sift_down"<span class="antiquote"><span class="antiquote">}</span></span></span></span> for each one.›</span></span>
<span class="keyword1"><span class="command">procedure_spec</span></span> <span class="entity">make_heap</span> <span class="main">(</span>heap<span class="main">,</span> l<span class="main">,</span> r<span class="main">)</span> <span class="keyword2"><span class="keyword">returns</span></span> heap
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">l</span> <span class="main">≤</span> <span class="skolem">r</span>"</span></span>  
    <span class="keyword2"><span class="keyword">ensures</span></span> <span class="quoted"><span class="quoted">"is_heap <span class="main">(≤)</span> <span class="skolem">heap</span> <span class="skolem">l<span class="hidden">⇩</span><sub>0</sub></span> <span class="skolem">r<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">∧</span> 
             arr_mset <span class="skolem">heap</span> <span class="skolem">l<span class="hidden">⇩</span><sub>0</sub></span> <span class="skolem">r<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">=</span> arr_mset <span class="skolem">heap<span class="hidden">⇩</span><sub>0</sub></span> <span class="skolem">l<span class="hidden">⇩</span><sub>0</sub></span> <span class="skolem">r<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">∧</span> 
             <span class="skolem">heap<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">=</span> <span class="skolem">heap</span> <span class="keyword1">on</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">l<span class="hidden">⇩</span><sub>0</sub></span><span class="main">..&lt;</span> <span class="skolem">r<span class="hidden">⇩</span><sub>0</sub></span><span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> heap<span class="main">[</span><span class="main">]</span> l r
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted">‹
    y <span class="main"><span class="main">=</span></span> <span class="main"><span class="main">(</span></span>r <span class="main"><span class="main">+</span></span> l<span class="main"><span class="main">)</span></span><span class="main"><span class="main">/</span></span>2 <span class="main"><span class="main">-</span></span> 1<span class="main"><span class="main">;</span></span>
    <span class="keyword2"><span class="keyword"><span class="keyword1">while</span></span></span> <span class="main"><span class="keyword1">(</span></span>y <span class="main"><span class="main">≥</span></span> l<span class="main"><span class="keyword1">)</span></span>
          <span class="main"><span class="keyword1">@variant</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">y</span> <span class="main">-</span> <span class="skolem">l</span> <span class="main">+</span> <span class="main">1</span>›</span></span>
          <span class="main"><span class="keyword1">@invariant</span></span> <span class="quoted"><span class="quoted">‹is_partial_heap <span class="main">(≤)</span> <span class="skolem">heap</span> <span class="skolem">l</span> <span class="main">(</span><span class="skolem">y</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="skolem">r</span> <span class="main">∧</span>
                      arr_mset <span class="skolem">heap</span> <span class="skolem">l</span> <span class="skolem">r</span> <span class="main">=</span> arr_mset <span class="skolem">heap<span class="hidden">⇩</span><sub>0</sub></span> <span class="skolem">l<span class="hidden">⇩</span><sub>0</sub></span> <span class="skolem">r<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">∧</span>
                      <span class="skolem">l</span> <span class="main">-</span> <span class="main">1</span> <span class="main">≤</span> <span class="skolem">y</span> <span class="main">∧</span> <span class="skolem">y</span> <span class="main">&lt;</span> <span class="skolem">r</span> <span class="main">∧</span> <span class="skolem">heap<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">=</span> <span class="skolem">heap</span> <span class="keyword1">on</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">l</span><span class="main">..&lt;</span><span class="skolem">r</span><span class="main">}</span>›</span></span>
    <span class="main"><span class="main">{</span></span>
      heap <span class="main"><span class="main">=</span></span> sift_down<span class="main"><span class="main">(</span></span>heap<span class="main"><span class="main">,</span></span> l<span class="main"><span class="main">,</span></span> r<span class="main"><span class="main">,</span></span> y<span class="main"><span class="main">)</span></span><span class="main"><span class="main">;</span></span>
      y <span class="main"><span class="main">=</span></span> y <span class="main"><span class="main">-</span></span> 1
    <span class="main"><span class="main">}</span></span>›</span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">vcg_cs</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> conjI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> snd_half_is_partial_heap add.commute<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">linarith</span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> partial_heap_added_first_el le_less <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> eq_on_trans <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> dual_order.antisym <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Heapsort Implementation›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The final part of this submission is the implementation of the in-place heapsort. Firstly it 
      builds the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>≤›</span></span></span></span>-heap and then it iteratively removes the minimum of the heap, which is put at 
      the now vacant end of the shrinking heap. This is done until the heap is empty, which leaves 
      the array sorted in descending order.›</span></span>
<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Auxiliary Lemmas›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Firstly the notion of a sorted array is needed. This is more or less the same as 
      <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "ran_sorted"<span class="antiquote"><span class="antiquote">}</span></span></span></span> generalized for arbitrary comparison functions.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">array_is_sorted</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>int <span class="main">⇒</span> int <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span>  <span class="main">(</span>int <span class="main">⇒</span> int<span class="main">)</span> <span class="main">⇒</span> int <span class="main">⇒</span> int <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">array_is_sorted</span> <span class="free"><span class="bound"><span class="entity">cmp</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">≡</span> <span class="main">∀</span><span class="bound">i</span><span class="main">.</span> <span class="main">∀</span><span class="bound">j</span><span class="main">.</span> bounded <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="bound">i</span> <span class="main">⟶</span> bounded <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="bound">j</span> <span class="main">⟶</span> <span class="bound">i</span> <span class="main">&lt;</span> <span class="bound">j</span> <span class="main">⟶</span> <span class="free"><span class="bound"><span class="entity">cmp</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="bound">i</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="bound">j</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This lemma states, that the heapsort doesn't change the elements contained in the array during
      the loop iterations.›</span></span>
<span class="keyword1" id="IMP2_Binary_Heap-heap_sort_mset_step"><span class="command">lemma</span></span> heap_sort_mset_step<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">arr</span><span class="main">::</span><span class="quoted"><span class="quoted">"int <span class="main">⇒</span> int"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">l</span> <span class="main">&lt;</span> <span class="free">m</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">≤</span> <span class="free">r</span>"</span></span>
    <span class="quoted"><span class="quoted">"arr_mset <span class="free">arr'</span> <span class="free">l</span> <span class="main">(</span><span class="free">m</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="main">=</span> arr_mset <span class="free">arr</span> <span class="free">l</span> <span class="free">m</span> <span class="main">-</span> <span class="main">{#</span>Min_mset <span class="main">(</span>arr_mset <span class="free">arr</span> <span class="free">l</span> <span class="free">m</span><span class="main">)</span><span class="main">#}</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">arr</span> <span class="main">=</span> <span class="free">arr'</span> <span class="keyword1">on</span> <span class="main">-</span> <span class="main">{</span><span class="free">l</span><span class="main">..&lt;</span><span class="free">m</span><span class="main">}</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">mod_arr</span> <span class="main">=</span> <span class="free">arr'</span><span class="main">(</span><span class="free">m</span> <span class="main">-</span> <span class="main">1</span> <span class="main">:=</span> Min_mset <span class="main">(</span>arr_mset <span class="free">arr</span> <span class="free">l</span> <span class="free">m</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"arr_mset <span class="free">arr</span> <span class="free">l</span> <span class="free">r</span> <span class="main">=</span> arr_mset <span class="free">mod_arr</span> <span class="free">l</span> <span class="free">r</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?min</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{#</span>Min_mset <span class="main">(</span>arr_mset <span class="free">arr</span> <span class="free">l</span> <span class="free">m</span><span class="main">)</span><span class="main">#}</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?new_arr_mset</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"arr_mset <span class="free">mod_arr</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> middle<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?new_arr_mset</span> <span class="main">(</span><span class="free">m</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="free">m</span> <span class="main">=</span> <span class="var">?min</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main"><span class="main">(</span></span>5<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> first_half<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?new_arr_mset</span> <span class="free">l</span> <span class="main">(</span><span class="free">m</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="main">=</span> arr_mset <span class="free">arr</span> <span class="free">l</span> <span class="free">m</span> <span class="main">-</span> <span class="var">?min</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">,</span></span>5<span class="main"><span class="main">)</span></span> mset_ran_subst_outside<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="var">?new_arr_mset</span> <span class="free">l</span> <span class="free">m</span> <span class="main">=</span> <span class="var">?new_arr_mset</span> <span class="free">l</span> <span class="main">(</span><span class="free">m</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="main">+</span> <span class="var">?new_arr_mset</span> <span class="main">(</span><span class="free">m</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="free">m</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">,</span></span>3<span class="main"><span class="main">,</span></span>5<span class="main"><span class="main">)</span></span> diff_add_cancel middle arr_mset_append_alt zle_diff1_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> first_half_middle<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?new_arr_mset</span> <span class="free">l</span> <span class="free">m</span> <span class="main">=</span> arr_mset <span class="free">arr</span> <span class="free">l</span> <span class="free">m</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> middle first_half assms<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">mod_arr</span> <span class="main">=</span> <span class="free">arr</span> <span class="keyword1">on</span> <span class="main">-</span> <span class="main">{</span><span class="free">l</span><span class="main">..&lt;</span><span class="free">m</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>1<span class="main">,</span>4<span class="main">,</span>5<span class="main">)</span> eq_on_sym eq_on_trans <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> second_half<span class="main">:</span> <span class="quoted"><span class="quoted">"arr_mset <span class="free">arr</span> <span class="free">m</span> <span class="free">r</span> <span class="main">=</span> arr_mset <span class="free">mod_arr</span> <span class="free">m</span> <span class="free">r</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq_on_def mset_ran_cong<span class="main">)</span>

  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> arr_mset_split assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">,</span></span>2<span class="main"><span class="main">)</span></span> first_half_middle le_less<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This lemma states, that each loop iteration leaves the growing second half of the array 
      sorted in descending order.›</span></span>
<span class="keyword1" id="IMP2_Binary_Heap-heap_sort_second_half_sorted_step"><span class="command">lemma</span></span> heap_sort_second_half_sorted_step<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">arr</span><span class="main">::</span><span class="quoted"><span class="quoted">"int <span class="main">⇒</span> int"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">l<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">&lt;</span> <span class="free">m</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">≤</span> <span class="free">r<span class="hidden">⇩</span><sub>0</sub></span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">arr</span> <span class="main">=</span> <span class="free">arr'</span> <span class="keyword1">on</span> <span class="main">-</span> <span class="main">{</span><span class="free">l<span class="hidden">⇩</span><sub>0</sub></span><span class="main">..&lt;</span><span class="free">m</span><span class="main">}</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">i</span><span class="main">.</span> <span class="main">∀</span><span class="bound">j</span><span class="main">.</span> bounded <span class="free">m</span> <span class="free">r<span class="hidden">⇩</span><sub>0</sub></span> <span class="bound">i</span> <span class="main">⟶</span> bounded <span class="free">m</span> <span class="free">r<span class="hidden">⇩</span><sub>0</sub></span> <span class="bound">j</span> <span class="main">⟶</span>  <span class="bound">i</span> <span class="main">&lt;</span> <span class="bound">j</span> <span class="main">⟶</span> <span class="free">arr</span> <span class="bound">j</span> <span class="main">≤</span> <span class="free">arr</span> <span class="bound">i</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">∈#</span>arr_mset <span class="free">arr</span> <span class="free">l<span class="hidden">⇩</span><sub>0</sub></span> <span class="free">m</span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span><span class="main">∈#</span>arr_mset <span class="free">arr</span> <span class="free">m</span> <span class="free">r<span class="hidden">⇩</span><sub>0</sub></span><span class="main">.</span> <span class="main">¬</span> <span class="bound">x</span> <span class="main">&lt;</span> <span class="bound">y</span>"</span></span>
    <span class="quoted"><span class="quoted">"bounded <span class="main">(</span><span class="free">m</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="free">r<span class="hidden">⇩</span><sub>0</sub></span> <span class="free">i</span>"</span></span> 
    <span class="quoted"><span class="quoted">"bounded <span class="main">(</span><span class="free">m</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="free">r<span class="hidden">⇩</span><sub>0</sub></span> <span class="free">j</span>"</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">&lt;</span> <span class="free">j</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">mod_arr</span> <span class="main">=</span> <span class="main">(</span><span class="free">arr'</span><span class="main">(</span><span class="free">m</span> <span class="main">-</span> <span class="main">1</span> <span class="main">:=</span> Min_mset <span class="main">(</span>arr_mset <span class="free">arr</span> <span class="free">l<span class="hidden">⇩</span><sub>0</sub></span> <span class="free">m</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">mod_arr</span> <span class="free">j</span> <span class="main">≤</span> <span class="free">mod_arr</span> <span class="free">i</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> second_half_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">mod_arr</span> <span class="main">=</span> <span class="free">arr</span> <span class="keyword1">on</span> <span class="main">{</span><span class="free">m</span><span class="main">..&lt;</span> <span class="free">r<span class="hidden">⇩</span><sub>0</sub></span><span class="main">}</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>3<span class="main">,</span> 9<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> eq_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">have</span></span> j_stricter_bound<span class="main">:</span> <span class="quoted"><span class="quoted">"bounded <span class="free">m</span> <span class="free">r<span class="hidden">⇩</span><sub>0</sub></span> <span class="free">j</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>6-8<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> el_at_j<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">mod_arr</span> <span class="free">j</span> <span class="main">∈#</span> arr_mset <span class="free">arr</span> <span class="free">m</span> <span class="free">r<span class="hidden">⇩</span><sub>0</sub></span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> eq_onD second_half_eq <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span><span class="main">)</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">=</span> <span class="main">(</span><span class="free">m</span><span class="main">-</span><span class="main">1</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">mod_arr</span> <span class="free">i</span> <span class="main">∈#</span> arr_mset <span class="free">arr</span> <span class="free">l<span class="hidden">⇩</span><sub>0</sub></span> <span class="free">m</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">,</span></span> 9<span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>5<span class="main">)</span> el_at_j not_less <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span> 
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">≠</span> <span class="main">(</span><span class="free">m</span><span class="main">-</span><span class="main">1</span><span class="main">)</span>"</span></span>  
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"bounded <span class="free">m</span> <span class="free">r<span class="hidden">⇩</span><sub>0</sub></span> <span class="free">i</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>6<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
      <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>4<span class="main">,</span> 8<span class="main">)</span> eq_on_def j_stricter_bound second_half_eq <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The following lemma shows that all elements in the first part of the array (the binary heap) 
      are bigger than the elements in the second part (the sorted part) after every iteration. This 
      lemma and the invariant of the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>heap_sort›</span></span></span></span> loop use <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>¬ x &lt; y›</span></span></span></span> instead of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>x ≥ y›</span></span></span></span> since 
      <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>vcg_cs›</span></span></span></span> doesn't terminate in the latter case.›</span></span>
<span class="keyword1" id="IMP2_Binary_Heap-heap_sort_fst_part_bigger_snd_part_step"><span class="command">lemma</span></span> heap_sort_fst_part_bigger_snd_part_step<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">arr</span><span class="main">::</span><span class="quoted"><span class="quoted">"int <span class="main">⇒</span> int"</span></span> 
  <span class="keyword2"><span class="keyword">assumes</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">l<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">&lt;</span> <span class="free">m</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">≤</span> <span class="free">r<span class="hidden">⇩</span><sub>0</sub></span>"</span></span>
    <span class="quoted"><span class="quoted">"arr_mset <span class="free">arr'</span> <span class="free">l<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">(</span><span class="free">m</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="main">=</span> arr_mset <span class="free">arr</span> <span class="free">l<span class="hidden">⇩</span><sub>0</sub></span> <span class="free">m</span> <span class="main">-</span> <span class="main">{#</span>Min_mset <span class="main">(</span>arr_mset <span class="free">arr</span> <span class="free">l<span class="hidden">⇩</span><sub>0</sub></span> <span class="free">m</span><span class="main">)</span><span class="main">#}</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">arr</span> <span class="main">=</span> <span class="free">arr'</span> <span class="keyword1">on</span> <span class="main">-</span> <span class="main">{</span><span class="free">l<span class="hidden">⇩</span><sub>0</sub></span><span class="main">..&lt;</span><span class="free">m</span><span class="main">}</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span><span class="main">∈#</span>arr_mset <span class="free">arr</span> <span class="free">l<span class="hidden">⇩</span><sub>0</sub></span> <span class="free">m</span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span><span class="main">∈#</span>arr_mset <span class="free">arr</span> <span class="free">m</span> <span class="free">r<span class="hidden">⇩</span><sub>0</sub></span><span class="main">.</span> <span class="main">¬</span> <span class="bound">x</span> <span class="main">&lt;</span> <span class="bound">y</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">mod_arr</span> <span class="main">=</span> <span class="free">arr'</span><span class="main">(</span><span class="free">m</span> <span class="main">-</span> <span class="main">1</span> <span class="main">:=</span> Min_mset <span class="main">(</span>arr_mset <span class="free">arr</span> <span class="free">l<span class="hidden">⇩</span><sub>0</sub></span> <span class="free">m</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">x</span><span class="main">∈#</span>arr_mset <span class="free">mod_arr</span> <span class="free">l<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">(</span><span class="free">m</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">y</span><span class="main">∈#</span>arr_mset <span class="free">mod_arr</span> <span class="main">(</span><span class="free">m</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="free">r<span class="hidden">⇩</span><sub>0</sub></span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="free">x</span> <span class="main">&lt;</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="free">m</span><span class="main">..&lt;</span><span class="free">r<span class="hidden">⇩</span><sub>0</sub></span><span class="main">}</span> <span class="main">⊆</span> <span class="main">-</span> <span class="main">{</span><span class="free">l<span class="hidden">⇩</span><sub>0</sub></span><span class="main">..&lt;</span><span class="free">m</span><span class="main">}</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">arr'</span> <span class="main">=</span> <span class="free">arr</span> <span class="keyword1">on</span> <span class="main">{</span><span class="free">m</span><span class="main">..&lt;</span><span class="free">r<span class="hidden">⇩</span><sub>0</sub></span><span class="main">}</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>4<span class="main">)</span> eq_on_sym eq_on_subset <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">hence</span></span> arr_eq_on<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">mod_arr</span> <span class="main">=</span> <span class="free">arr</span> <span class="keyword1">on</span> <span class="main">{</span><span class="free">m</span><span class="main">..&lt;</span><span class="free">r<span class="hidden">⇩</span><sub>0</sub></span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main"><span class="main">(</span></span>6<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> same_mset<span class="main">:</span> <span class="quoted"><span class="quoted">"arr_mset <span class="free">mod_arr</span> <span class="free">m</span> <span class="free">r<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">=</span> arr_mset <span class="free">arr</span> <span class="free">m</span> <span class="free">r<span class="hidden">⇩</span><sub>0</sub></span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> mset_ran_cong <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈#</span> arr_mset <span class="free">arr</span> <span class="free">l<span class="hidden">⇩</span><sub>0</sub></span> <span class="free">m</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> same_mset assms
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> assms<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">,</span></span>6<span class="main"><span class="main">,</span></span>7<span class="main"><span class="main">)</span></span> add_mset_remove_trivial_eq lran_upd_outside<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span>
        mset_lran cancel_ab_semigroup_add_class.diff_right_commute
        diff_single_trivial multi_self_add_other_not_self order_refl<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> x_bigger_min<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≥</span> Min_mset <span class="main">(</span>arr_mset <span class="free">arr</span> <span class="free">l<span class="hidden">⇩</span><sub>0</sub></span> <span class="free">m</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> Min_le <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span> 
  <span class="keyword1"><span class="command">have</span></span> y_smaller_min<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">≤</span> Min_mset <span class="main">(</span>arr_mset <span class="free">arr</span> <span class="free">l<span class="hidden">⇩</span><sub>0</sub></span> <span class="free">m</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">=</span> <span class="free">mod_arr</span> <span class="main">(</span><span class="free">m</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span><span class="main">∈#</span>arr_mset <span class="free">mod_arr</span> <span class="main">(</span><span class="free">m</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="free">r<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">-</span> <span class="main">{#</span><span class="free">mod_arr</span> <span class="main">(</span><span class="free">m</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">#}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> assms<span class="main"><span class="main">(</span></span>8<span class="main"><span class="main">)</span></span> diff_single_trivial insert_DiffM insert_noteq_member<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span><span class="main">∈#</span>arr_mset <span class="free">arr</span> <span class="free">m</span> <span class="free">r<span class="hidden">⇩</span><sub>0</sub></span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> intvs_decr_l mset_ran_insert same_mset<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>1<span class="main">)</span> assms<span class="main">(</span>5<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span> 
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main"><span class="main">(</span></span>6<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> x_bigger_min <span class="keyword1"><span class="command">by</span></span> <span class="operator">linarith</span> 
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Implementation›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Now finally the correctness of the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>heap_sort›</span></span></span></span> is shown. As mentioned, it starts by 
      transforming the array into a minimum heap using <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "make_heap"<span class="antiquote"><span class="antiquote">}</span></span></span></span>. Then in each 
      iteration it removes the first element from the heap with <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "del_min"<span class="antiquote"><span class="antiquote">}</span></span></span></span> after its value 
      was retrieved with <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "get_min"<span class="antiquote"><span class="antiquote">}</span></span></span></span>. This value is then put at the position freed by 
      <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "del_min"<span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>
<span class="keyword1"><span class="command">program_spec</span></span> <span class="entity">heap_sort</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">l</span> <span class="main">≤</span> <span class="skolem">r</span>"</span></span>  
    <span class="keyword2"><span class="keyword">ensures</span></span> <span class="quoted"><span class="quoted">"array_is_sorted <span class="main">(≥)</span> <span class="skolem">arr</span> <span class="skolem">l<span class="hidden">⇩</span><sub>0</sub></span> <span class="skolem">r<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">∧</span> 
             arr_mset <span class="skolem">arr<span class="hidden">⇩</span><sub>0</sub></span> <span class="skolem">l<span class="hidden">⇩</span><sub>0</sub></span> <span class="skolem">r<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">=</span> arr_mset <span class="skolem">arr</span> <span class="skolem">l<span class="hidden">⇩</span><sub>0</sub></span> <span class="skolem">r<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">∧</span> 
             <span class="skolem">arr<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">=</span> <span class="skolem">arr</span> <span class="keyword1">on</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">l<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">..&lt;</span><span class="skolem">r<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">}</span> <span class="main">∧</span> <span class="skolem">l</span> <span class="main">=</span> <span class="skolem">l<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">∧</span> <span class="skolem">r</span> <span class="main">=</span> <span class="skolem">r<span class="hidden">⇩</span><sub>0</sub></span>"</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> l r arr<span class="main">[</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted">‹
    arr <span class="main"><span class="main">=</span></span> make_heap<span class="main"><span class="main">(</span></span>arr<span class="main"><span class="main">,</span></span> l<span class="main"><span class="main">,</span></span> r<span class="main"><span class="main">)</span></span><span class="main"><span class="main">;</span></span>
    m <span class="main"><span class="main">=</span></span> r<span class="main"><span class="main">;</span></span>
    <span class="keyword2"><span class="keyword"><span class="keyword1">while</span></span></span> <span class="main"><span class="keyword1">(</span></span>m <span class="main"><span class="main">&gt;</span></span> l<span class="main"><span class="keyword1">)</span></span>
      <span class="main"><span class="keyword1">@variant</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">m</span> <span class="main">-</span> <span class="skolem">l</span> <span class="main">+</span> <span class="main">1</span>›</span></span> 
      <span class="main"><span class="keyword1">@invariant</span></span> <span class="quoted"><span class="quoted">‹is_heap <span class="main">(≤)</span> <span class="skolem">arr</span> <span class="skolem">l</span> <span class="skolem">m</span> <span class="main">∧</span>
        array_is_sorted <span class="main">(≥)</span> <span class="skolem">arr</span> <span class="skolem">m</span> <span class="skolem">r<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">∧</span>
        <span class="main">(</span><span class="main">∀</span><span class="bound">x</span> <span class="main">∈#</span> arr_mset <span class="skolem">arr</span> <span class="skolem">l<span class="hidden">⇩</span><sub>0</sub></span> <span class="skolem">m</span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span> <span class="main">∈#</span> arr_mset <span class="skolem">arr</span> <span class="skolem">m</span> <span class="skolem">r<span class="hidden">⇩</span><sub>0</sub></span><span class="main">.</span> <span class="main">¬</span> <span class="bound">x</span> <span class="main">&lt;</span> <span class="bound">y</span><span class="main">)</span> <span class="main">∧</span>
        arr_mset <span class="skolem">arr<span class="hidden">⇩</span><sub>0</sub></span> <span class="skolem">l<span class="hidden">⇩</span><sub>0</sub></span> <span class="skolem">r<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">=</span> arr_mset <span class="skolem">arr</span> <span class="skolem">l<span class="hidden">⇩</span><sub>0</sub></span> <span class="skolem">r<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">∧</span> 
        <span class="skolem">l</span> <span class="main">≤</span> <span class="skolem">m</span> <span class="main">∧</span> <span class="skolem">m</span> <span class="main">≤</span> <span class="skolem">r<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">∧</span> <span class="skolem">l</span> <span class="main">=</span> <span class="skolem">l<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">∧</span> <span class="skolem">arr<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">=</span> <span class="skolem">arr</span> <span class="keyword1">on</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">l<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">..&lt;</span><span class="skolem">r<span class="hidden">⇩</span><sub>0</sub></span><span class="main">}</span>›</span></span>
    <span class="main"><span class="main">{</span></span>
      min <span class="main"><span class="main">=</span></span> get_min<span class="main"><span class="main">(</span></span>arr<span class="main"><span class="main">,</span></span> l<span class="main"><span class="main">,</span></span> m<span class="main"><span class="main">)</span></span><span class="main"><span class="main">;</span></span>
      <span class="main"><span class="main">(</span></span>arr<span class="main"><span class="main">,</span></span> l<span class="main"><span class="main">,</span></span> m<span class="main"><span class="main">)</span></span> <span class="main"><span class="main">=</span></span> del_min<span class="main"><span class="main">(</span></span>arr<span class="main"><span class="main">,</span></span> l<span class="main"><span class="main">,</span></span> m<span class="main"><span class="main">)</span></span><span class="main"><span class="main">;</span></span>
      arr<span class="main"><span class="main">[</span></span>m<span class="main"><span class="main">]</span></span> <span class="main"><span class="main">=</span></span> min 
    <span class="main"><span class="main">}</span></span>
  ›</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">vcg_cs</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> array_is_sorted_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">intro</span> conjI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> is_partial_heap_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> array_is_sorted_def <span class="keyword1"><span class="command">using</span></span> heap_sort_second_half_sorted_step
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> heap_sort_fst_part_bigger_snd_part_step <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> heap_sort_mset_step <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> eq_on_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> ComplD ComplI atLeastLessThan_iff less_le_trans<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div>