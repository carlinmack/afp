<div id="Lazy_Case">
<div class="head">
<h1>Theory Lazy_Case</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Introduction›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Lazy_Case
  <span class="keyword2"><span class="keyword">imports</span></span> <a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL/Main.html">Main</a>
  <span class="keyword2"><span class="keyword">keywords</span></span> <span class="quoted">"lazify"</span> <span class="main">::</span> thy_decl
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Importing this theory adds a preprocessing step to the code generator: All case constants
  (and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> HOL.If<span class="antiquote"><span class="antiquote">}</span></span></span></span>) are replaced by ``lazy'' versions; i.e., new constants that evaluate the
  cases lazily. For example, the type of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> case_list<span class="antiquote"><span class="antiquote">}</span></span></span></span> is
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'a</span></span> <span class="main"><span class="main">⇒</span></span> <span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'b</span></span> <span class="main"><span class="main">⇒</span></span> <span class="tfree"><span class="tfree">'b</span></span> list <span class="main"><span class="main">⇒</span></span> <span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">⇒</span></span> <span class="tfree"><span class="tfree">'b</span></span> list <span class="main"><span class="main">⇒</span></span> <span class="tfree"><span class="tfree">'a</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>. A new constant is created with the type
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span>unit <span class="main"><span class="main">⇒</span></span> <span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">⇒</span></span> <span class="main"><span class="main">(</span></span><span class="tfree"><span class="tfree">'b</span></span> <span class="main"><span class="main">⇒</span></span> <span class="tfree"><span class="tfree">'b</span></span> list <span class="main"><span class="main">⇒</span></span> <span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">⇒</span></span> <span class="tfree"><span class="tfree">'b</span></span> list <span class="main"><span class="main">⇒</span></span> <span class="tfree"><span class="tfree">'a</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>. All fully-applied occurrences of
  the standard case constants are rewritten (using the [<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">attribute</span></span> code_unfold<span class="antiquote"><span class="antiquote">}</span></span></span></span>] attribute).
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The motivation for doing this is twofold:

  <span class="antiquoted"><span class="antiquoted">▸</span></span> Reconstructing match expressions is complicated. For existing target languages, this theory
    reduces the amount of code that has to be trusted in the code generator, because the
    transformation goes through the kernel.
  <span class="antiquoted"><span class="antiquoted">▸</span></span> It lays the groundwork to support targets that do not have syntactic constructs for case
    expressions or that cannot be used for some reason, or targets where lazy evaluation of
    branching constructs is not given.
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The obvious downside is that this construction will usually degrade performance of generated code.
  To some extent, an optimising compiler that performs inlining can alleviate that.
›</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Setup›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> HOL.If<span class="antiquote"><span class="antiquote">}</span></span></span></span> is just an alias for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> case_bool<span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"HOL.If <span class="free">P</span> <span class="free">t</span> <span class="free">f</span> <span class="main">=</span> case_bool <span class="free">t</span> <span class="free">f</span> <span class="free">P</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">ML_file</span></span> <span class="quoted">‹lazy_case.ML›</span>
<span class="keyword1"><span class="command">setup</span></span> <span class="quoted">‹<span class="entity">Lazy_Case.setup</span>›</span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="files/lazy_case.ML">
<div class="head">
<h1>File ‹lazy_case.ML›</h1>
</div>
<pre class="source"><span class="keyword1"><span class="keyword">signature</span></span> <span class="entity">LAZY_CASE</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">sig</span></span>
  <span class="keyword1"><span class="keyword">val</span></span> lazify<span class="main">:</span> <span class="entity">Ctr_Sugar.ctr_sugar</span> <span class="main">-&gt;</span> local_theory <span class="main">-&gt;</span> local_theory
  <span class="keyword1"><span class="keyword">val</span></span> lazify_typ<span class="main">:</span> typ <span class="main">-&gt;</span> local_theory <span class="main">-&gt;</span> local_theory
  <span class="keyword1"><span class="keyword">val</span></span> lazify_cmd<span class="main">:</span> string <span class="main">-&gt;</span> local_theory <span class="main">-&gt;</span> local_theory

  <span class="keyword1"><span class="keyword">val</span></span> lazy_case_plugin<span class="main">:</span> string
  <span class="keyword1"><span class="keyword">val</span></span> setup<span class="main">:</span> theory <span class="main">-&gt;</span> theory
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Lazy_Case</span> <span class="main">:</span> <span class="entity">LAZY_CASE</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Data</span> <span class="main">=</span> Generic_Data
<span class="main">(</span>
  <span class="keyword1"><span class="keyword">type</span></span> <span class="entity">T</span> <span class="main">=</span> Symtab.set
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">empty</span> <span class="main">=</span> Symtab.empty
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">extend</span> <span class="main">=</span> I
  <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">merge</span> <span class="main">=</span> Symtab.merge <span class="keyword1"><span class="keyword">op</span></span> <span class="main">=</span>
<span class="main">)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">init</span> <span class="main">[</span><span class="main">]</span> <span class="main">=</span> error <span class="inner_quoted">"empty list"</span>
  <span class="main">|</span> <span class="entity">init</span> <span class="main">[</span><span class="main">_</span><span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="main">]</span>
  <span class="main">|</span> <span class="entity">init</span> <span class="main">(</span><span class="entity">x</span> :: <span class="entity">xs</span><span class="main">)</span> <span class="main">=</span> <span class="entity">x</span> :: <span class="entity">init</span> <span class="entity">xs</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">lazify</span> <span class="main">{</span><span class="entity">T</span><span class="main">,</span> <span class="entity">casex</span><span class="main">,</span> <span class="entity">ctrs</span><span class="main">,</span> <span class="entity">case_thms</span><span class="main">,</span> <span class="entity">case_cong</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">is_fun</span> <span class="main">=</span> can dest_funT
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">typ_name</span> <span class="main">=</span> fst <span class="main">(</span>dest_Type <span class="entity">T</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">len</span> <span class="main">=</span> length <span class="entity">ctrs</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">idxs</span> <span class="main">=</span> <span class="inner_numeral">0</span> upto <span class="entity">len</span> - <span class="inner_numeral">1</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span> <span class="main">=</span> dest_Const <span class="entity">casex</span> ||&gt; Logic.unvarifyT_global
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">typs</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=</span> strip_type <span class="entity">typ</span>

    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">exists</span> <span class="main">=</span> Symtab.defined <span class="main">(</span>Data.get <span class="main">(</span>Context.Proof <span class="entity">lthy</span><span class="main">)</span><span class="main">)</span> <span class="entity">typ_name</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">warn</span> <span class="main">=</span> Pretty.separate <span class="inner_quoted">""</span> <span class="main">[</span>Syntax.pretty_typ <span class="entity">lthy</span> <span class="entity">T</span><span class="main">,</span> Pretty.str <span class="inner_quoted">"already lazified"</span><span class="main">]</span>
      |&gt; Pretty.block
    <span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">exists</span> <span class="keyword2"><span class="keyword">then</span></span> warning <span class="main">(</span>Pretty.string_of <span class="entity">warn</span><span class="main">)</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="main">(</span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="comment1">(* for records, casex is the dummy pattern *)</span>
    <span class="keyword2"><span class="keyword">if</span></span> Term.is_dummy_pattern <span class="entity">casex</span> <span class="keyword1"><span class="keyword">orelse</span></span> forall <span class="entity">is_fun</span> <span class="main">(</span><span class="entity">init</span> <span class="entity">typs</span><span class="main">)</span> <span class="keyword1"><span class="keyword">orelse</span></span> <span class="entity">exists</span> <span class="keyword2"><span class="keyword">then</span></span>
      <span class="entity">lthy</span>
    <span class="keyword2"><span class="keyword">else</span></span>
      <span class="keyword2"><span class="keyword">let</span></span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">arg_typs</span> <span class="main">=</span> <span class="entity">init</span> <span class="entity">typs</span>

        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">apply_to_unit</span> <span class="entity">typ</span> <span class="entity">idx</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_fun</span> <span class="entity">typ</span> <span class="keyword2"><span class="keyword">then</span></span>
            <span class="main">(</span><span class="entity">typ</span><span class="main">,</span> Bound <span class="entity">idx</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">else</span></span>
            <span class="main">(</span><span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">unit</span><span class="antiquote">}</span></span> --&gt; <span class="entity">typ</span><span class="main">,</span> Bound <span class="entity">idx</span> $ <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="main">()</span>"</span><span class="antiquote">}</span></span><span class="main">)</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">arg_typs'</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span> <span class="main">=</span> split_list <span class="main">(</span>map2 <span class="entity">apply_to_unit</span> <span class="entity">arg_typs</span> <span class="main">(</span>rev <span class="entity">idxs</span><span class="main">)</span><span class="main">)</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">def</span> <span class="main">=</span> list_comb <span class="main">(</span>Const <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span>
          |&gt; fold_rev Term.abs <span class="main">(</span>map <span class="main">(</span>pair <span class="inner_quoted">"c"</span><span class="main">)</span> <span class="entity">arg_typs'</span><span class="main">)</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">binding</span> <span class="main">=</span> Binding.name <span class="inner_quoted">"case_lazy"</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="main">(</span><span class="entity">term</span><span class="main">,</span> <span class="entity">thm</span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="entity">lthy'</span><span class="main">,</span> <span class="entity">lthy</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
          <span class="main">(</span>snd o Local_Theory.begin_nested<span class="main">)</span> <span class="entity">lthy</span>
          |&gt; Proof_Context.concealed
          |&gt; Local_Theory.map_background_naming <span class="main">(</span>Name_Space.mandatory_path <span class="entity">typ_name</span><span class="main">)</span>
          |&gt; Local_Theory.define <span class="main">(</span><span class="main">(</span><span class="entity">binding</span><span class="main">,</span> NoSyn<span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="main">(</span>Thm.def_binding <span class="entity">binding</span><span class="main">,</span> <span class="main">[</span><span class="main">]</span><span class="main">)</span><span class="main">,</span> <span class="entity">def</span><span class="main">)</span><span class="main">)</span>
          |&gt;&gt; apsnd snd
          ||&gt; `Local_Theory.end_nested
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">phi</span> <span class="main">=</span> Proof_Context.export_morphism <span class="entity">lthy</span> <span class="entity">lthy'</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thm'</span> <span class="main">=</span> Morphism.thm <span class="entity">phi</span> <span class="entity">thm</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">term'</span> <span class="main">=</span> Logic.unvarify_global <span class="main">(</span>Morphism.term <span class="entity">phi</span> <span class="entity">term</span><span class="main">)</span>

        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">defs_tac</span> <span class="entity">ctxt</span> <span class="entity">idx</span> <span class="main">=</span>
          Local_Defs.unfold_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">thm'</span><span class="main">,</span> nth <span class="entity">case_thms</span> <span class="entity">idx</span><span class="main">]</span> THEN
            HEADGOAL <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> refl<span class="antiquote">}</span></span></span><span class="main">)</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">frees</span> <span class="main">=</span> fastype_of <span class="entity">term'</span> |&gt; strip_type |&gt; fst |&gt; <span class="entity">init</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">frees_f</span> <span class="main">=</span> Name.invent_names Name.context <span class="inner_quoted">"f0"</span> <span class="entity">frees</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">frees_g</span> <span class="main">=</span> Name.invent_names Name.context <span class="inner_quoted">"g0"</span> <span class="entity">frees</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">fs</span> <span class="main">=</span> map Free <span class="entity">frees_f</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">gs</span> <span class="main">=</span> map Free <span class="entity">frees_g</span>

        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_def_goal</span> <span class="entity">ctr</span> <span class="entity">idx</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">len</span><span class="main">)</span> <span class="main">=</span> dest_Const <span class="entity">ctr</span> ||&gt; strip_type ||&gt; fst ||&gt; length
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">frees</span> <span class="main">=</span> Name.invent Name.context <span class="inner_quoted">"p0"</span> <span class="entity">len</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">=</span> map <span class="main">(</span>Free o rpair dummyT<span class="main">)</span> <span class="entity">frees</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctr_val</span> <span class="main">=</span> list_comb <span class="main">(</span>Const <span class="main">(</span><span class="entity">name</span><span class="main">,</span> dummyT<span class="main">)</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs</span> <span class="main">=</span> list_comb <span class="main">(</span><span class="entity">term'</span><span class="main">,</span> <span class="entity">fs</span><span class="main">)</span> $ <span class="entity">ctr_val</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs</span> <span class="main">=</span>
              <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">len</span> <span class="main">=</span> <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span>
                nth <span class="entity">fs</span> <span class="entity">idx</span> $ <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">"<span class="main">()</span>"</span><span class="antiquote">}</span></span>
              <span class="keyword2"><span class="keyword">else</span></span>
                list_comb <span class="main">(</span>nth <span class="entity">fs</span> <span class="entity">idx</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span>
             <span class="main">(</span><span class="entity">frees</span><span class="main">,</span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span>Syntax.check_term <span class="entity">lthy'</span> <span class="main">(</span><span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>

        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">prove_defs</span> <span class="main">(</span><span class="entity">frees'</span><span class="main">,</span> <span class="entity">goal</span><span class="main">)</span> <span class="entity">idx</span> <span class="main">=</span>
          Goal.prove_future <span class="entity">lthy'</span> <span class="main">(</span>map fst <span class="entity">frees_f</span> @ <span class="entity">frees'</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span> <span class="entity">goal</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span><span class="entity">context</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
            <span class="entity">defs_tac</span> <span class="entity">context</span> <span class="entity">idx</span><span class="main">)</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">def_thms</span> <span class="main">=</span> map2 <span class="entity">prove_defs</span> <span class="main">(</span>map2 <span class="entity">mk_def_goal</span> <span class="entity">ctrs</span> <span class="entity">idxs</span><span class="main">)</span> <span class="entity">idxs</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">frees</span> <span class="main">=</span> Name.invent_names Name.context <span class="inner_quoted">"q0"</span> <span class="entity">arg_typs</span>
        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">unfold_goal</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs</span> <span class="main">=</span> list_comb <span class="main">(</span>Const <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span><span class="main">,</span> map Free <span class="entity">frees</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_abs</span> <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span> <span class="main">=</span>
              <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">is_fun</span> <span class="entity">typ</span> <span class="keyword2"><span class="keyword">then</span></span>
                Free <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span>
              <span class="keyword2"><span class="keyword">else</span></span>
                Abs <span class="main">(</span><span class="inner_quoted">"u"</span><span class="main">,</span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">unit</span><span class="antiquote">}</span></span><span class="main">,</span> Free <span class="main">(</span><span class="entity">name</span><span class="main">,</span> <span class="entity">typ</span><span class="main">)</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs</span> <span class="main">=</span> list_comb <span class="main">(</span>Const <span class="main">(</span>fst <span class="main">(</span>dest_Const <span class="entity">term'</span><span class="main">)</span><span class="main">,</span> dummyT<span class="main">)</span><span class="main">,</span> map <span class="entity">mk_abs</span> <span class="entity">frees</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span>Syntax.check_term <span class="entity">lthy'</span> <span class="main">(</span><span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">end</span></span>

        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">unfold_tac</span> <span class="entity">ctxt</span> <span class="main">=</span>
          Local_Defs.unfold_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">thm'</span><span class="main">]</span> THEN
            HEADGOAL <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> refl<span class="antiquote">}</span></span></span><span class="main">)</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">unfold_thm</span> <span class="main">=</span>
          Goal.prove_future <span class="entity">lthy'</span> <span class="main">(</span>map fst <span class="entity">frees</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span> <span class="entity">unfold_goal</span> <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span><span class="entity">context</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
            <span class="entity">unfold_tac</span> <span class="entity">context</span><span class="main">)</span>

        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_cong_prem</span> <span class="entity">t</span> <span class="entity">ctr</span> <span class="main">(</span><span class="entity">f</span><span class="main">,</span> <span class="entity">g</span><span class="main">)</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="comment1">(* FIXME get rid of dummyT here *)</span>
            <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_all</span> <span class="entity">t</span> <span class="main">=</span> Logic.all_const dummyT $ Abs <span class="main">(</span><span class="inner_quoted">""</span><span class="main">,</span> dummyT<span class="main">,</span> <span class="entity">t</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">len</span> <span class="main">=</span> dest_Const <span class="entity">ctr</span> |&gt; snd |&gt; strip_type |&gt; fst |&gt; length
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args</span> <span class="main">=</span> map Bound <span class="main">(</span><span class="entity">len</span> - <span class="inner_numeral">1</span> downto <span class="inner_numeral">0</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">ctr_val</span> <span class="main">=</span> list_comb <span class="main">(</span>Logic.unvarify_global <span class="entity">ctr</span><span class="main">,</span> <span class="entity">args</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">args'</span> <span class="main">=</span> <span class="keyword2"><span class="keyword">if</span></span> <span class="entity">len</span> <span class="main">=</span> <span class="inner_numeral">0</span> <span class="keyword2"><span class="keyword">then</span></span> <span class="main">[</span>Bound <span class="inner_numeral">0</span><span class="main">]</span> <span class="keyword2"><span class="keyword">else</span></span> <span class="entity">args</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs</span> <span class="main">=</span> list_comb <span class="main">(</span><span class="entity">f</span><span class="main">,</span> <span class="entity">args'</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs</span> <span class="main">=</span> list_comb <span class="main">(</span><span class="entity">g</span><span class="main">,</span> <span class="entity">args'</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">concl</span> <span class="main">=</span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prem</span> <span class="main">=</span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">t</span><span class="main">,</span> <span class="entity">ctr_val</span><span class="main">)</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span> fold <span class="main">(</span>K <span class="entity">mk_all</span><span class="main">)</span> <span class="entity">args'</span> <span class="main">(</span>Logic.mk_implies <span class="main">(</span><span class="entity">prem</span><span class="main">,</span> <span class="entity">concl</span><span class="main">)</span><span class="main">)</span> <span class="keyword2"><span class="keyword">end</span></span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cong_goal</span> <span class="main">=</span>
          <span class="keyword2"><span class="keyword">let</span></span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t1</span> <span class="main">=</span> Free <span class="main">(</span><span class="inner_quoted">"t1"</span><span class="main">,</span> Logic.unvarifyT_global <span class="entity">T</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">t2</span> <span class="main">=</span> Free <span class="main">(</span><span class="inner_quoted">"t2"</span><span class="main">,</span> Logic.unvarifyT_global <span class="entity">T</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">prems</span> <span class="main">=</span>
              <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">t1</span><span class="main">,</span> <span class="entity">t2</span><span class="main">)</span><span class="main">)</span> ::
                map2 <span class="main">(</span><span class="entity">mk_cong_prem</span> <span class="entity">t2</span><span class="main">)</span> <span class="entity">ctrs</span> <span class="main">(</span><span class="entity">fs</span> ~~ <span class="entity">gs</span><span class="main">)</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lhs</span> <span class="main">=</span> list_comb <span class="main">(</span><span class="entity">term'</span><span class="main">,</span> <span class="entity">fs</span><span class="main">)</span> $ <span class="entity">t1</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">rhs</span> <span class="main">=</span> list_comb <span class="main">(</span><span class="entity">term'</span><span class="main">,</span> <span class="entity">gs</span><span class="main">)</span> $ <span class="entity">t2</span>
            <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">concl</span> <span class="main">=</span> <span class="entity">HOLogic.mk_Trueprop</span> <span class="main">(</span><span class="entity">HOLogic.mk_eq</span> <span class="main">(</span><span class="entity">lhs</span><span class="main">,</span> <span class="entity">rhs</span><span class="main">)</span><span class="main">)</span>
          <span class="keyword2"><span class="keyword">in</span></span>
            Logic.list_implies <span class="main">(</span><span class="entity">prems</span><span class="main">,</span> <span class="entity">concl</span><span class="main">)</span>
            |&gt; Syntax.check_term <span class="entity">lthy'</span>
          <span class="keyword2"><span class="keyword">end</span></span>

        <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">cong_tac</span> <span class="entity">ctxt</span> <span class="main">=</span>
          Local_Defs.unfold_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">thm'</span><span class="main">]</span> THEN
            HEADGOAL <span class="main">(</span>eresolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">case_cong</span><span class="main">]</span><span class="main">)</span> THEN
            ALLGOALS <span class="main">(</span><span class="entity">ctxt</span> |&gt; <span class="entity">Subgoal.FOCUS</span>
              <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span>context <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> <span class="entity">prems</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span>
                HEADGOAL <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="entity">prems</span> THEN' resolve_tac <span class="entity">ctxt</span> <span class="entity">prems</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">cong_thm</span> <span class="main">=</span>
          Goal.prove_future <span class="entity">lthy'</span> <span class="main">(</span><span class="inner_quoted">"t1"</span> :: <span class="inner_quoted">"t2"</span> :: map fst <span class="entity">frees_f</span> @ map fst <span class="entity">frees_g</span><span class="main">)</span> <span class="main">[</span><span class="main">]</span> <span class="entity">cong_goal</span>
            <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="main">{</span><span class="entity">context</span><span class="main">,</span> <span class="main">...</span><span class="main">}</span> <span class="main">=&gt;</span> <span class="entity">cong_tac</span> <span class="entity">context</span><span class="main">)</span>

        <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">upd</span> <span class="main">=</span> Data.map <span class="main">(</span>Symtab.update_new <span class="main">(</span><span class="entity">typ_name</span><span class="main">,</span> <span class="main">(</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">in</span></span>
        <span class="entity">lthy'</span>
        |&gt; Local_Theory.note <span class="main">(</span><span class="main">(</span>Binding.empty<span class="main">,</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">attributes</span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">,</span> <span class="entity">def_thms</span><span class="main">)</span> |&gt; snd
        |&gt; Local_Theory.note <span class="main">(</span><span class="main">(</span>Binding.empty<span class="main">,</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">attributes</span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">]</span><span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="entity">unfold_thm</span><span class="main">]</span><span class="main">)</span> |&gt; snd
        |&gt; Local_Theory.note <span class="main">(</span><span class="main">(</span>Binding.empty<span class="main">,</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">attributes</span> <span class="main">[</span><span class="operator">fundef_cong</span><span class="main">]</span><span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">,</span> <span class="main">[</span><span class="entity">cong_thm</span><span class="main">]</span><span class="main">)</span> |&gt; snd
        |&gt; Local_Theory.declaration <span class="main">{</span>syntax <span class="main">=</span> false<span class="main">,</span> pervasive <span class="main">=</span> true<span class="main">}</span> <span class="main">(</span>K <span class="entity">upd</span><span class="main">)</span>
      <span class="keyword2"><span class="keyword">end</span></span>
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">lazify_typ</span> <span class="entity">typ</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="entity">lazify</span> <span class="main">(</span>the <span class="main">(</span><span class="entity">Ctr_Sugar.ctr_sugar_of</span> <span class="entity">lthy</span> <span class="main">(</span>fst <span class="main">(</span>dest_Type <span class="entity">typ</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="entity">lthy</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">lazify_cmd</span> <span class="entity">s</span> <span class="entity">lthy</span> <span class="main">=</span>
  <span class="entity">lazify_typ</span> <span class="main">(</span>Proof_Context.read_type_name <span class="main">{</span>proper <span class="main">=</span> true<span class="main">,</span> strict <span class="main">=</span> false<span class="main">}</span> <span class="entity">lthy</span> <span class="entity">s</span><span class="main">)</span> <span class="entity">lthy</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">lazy_case_plugin</span> <span class="main">=</span>
  <span class="entity">Plugin_Name.declare_setup</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">binding</span> lazy_case<span class="antiquote">}</span></span></span>

<span class="comment1">(** setup **)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="main">_</span> <span class="main">=</span>
  <span class="entity">Outer_Syntax.local_theory</span>
    <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">command_keyword</span> "<span class="keyword1">lazify</span>"<span class="antiquote">}</span></span></span>
    <span class="inner_quoted">"defines a lazy case constant and sets up the code generator"</span>
    <span class="main">(</span>Scan.repeat1 Args.embedded_inner_syntax &gt;&gt; fold <span class="entity">lazify_cmd</span><span class="main">)</span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">setup</span> <span class="main">=</span> <span class="entity">Ctr_Sugar.ctr_sugar_interpretation</span> <span class="entity">lazy_case_plugin</span> <span class="main">(</span><span class="entity">lazify_typ</span> o <span class="main">#</span>T<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="Test_Lazy_Case">
<div class="head">
<h1>Theory Test_Lazy_Case</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Usage›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Test_Lazy_Case
<span class="keyword2"><span class="keyword">imports</span></span> <a href="#Lazy_Case">Lazy_Case</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  This entry provides a <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> datatype<span class="antiquote"><span class="antiquote">}</span></span></span></span> plugin and a separate command.
  The plugin runs by default on all defined datatypes, but it can be disabled individually:
›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="main">(</span><span class="quasi_keyword">plugins</span> <span class="quasi_keyword">del</span><span class="main">:</span> lazy_case<span class="main">)</span> <span class="tfree">'a</span> tree <span class="main">=</span> Node <span class="main">|</span> Fork <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> tree list"</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">command</span></span> lazify<span class="antiquote"><span class="antiquote">}</span></span></span></span> command can be used to add lazy constants if the plugin has been disabled
  during datatype definition.
›</span></span>

<span class="keyword1"><span class="command">lazify</span></span> tree

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Nested and mutual recursion are supported.›</span></span>

<span class="keyword1"><span class="command">datatype</span></span>
  <span class="tfree">'a</span> mlist1 <span class="main">=</span> MNil1 <span class="main">|</span> MCons1 <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> mlist2"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
  <span class="tfree">'a</span> mlist2 <span class="main">=</span> MNil2 <span class="main">|</span> MCons2 <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> mlist1"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Records are supported.›</span></span>

<span class="keyword1"><span class="command">record</span></span> meep <span class="main">=</span>
  x1 <span class="main">::</span> <span class="quoted">nat</span>
  x2 <span class="main">::</span> <span class="quoted">int</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Examples›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">test</span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">test</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">then</span> True <span class="keyword1">else</span> False<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">test'</span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">test'</span> <span class="main">=</span> case_bool True False"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">test''</span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">test''</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">of</span> <span class="main">[]</span> <span class="main">⇒</span> False <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> True<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">fac</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">fac</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">≤</span> <span class="main">1</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">*</span> <span class="free">fac</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Test_Lazy_Case-map_tree"><span class="command">lemma</span></span> map_tree<span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"map_tree <span class="free">f</span> <span class="free">t</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">t</span> <span class="keyword1">of</span> Node <span class="main">⇒</span> Node <span class="main">|</span> Fork <span class="bound">x</span> <span class="bound">ts</span> <span class="main">⇒</span> Fork <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span>map <span class="main">(</span>map_tree <span class="free">f</span><span class="main">)</span> <span class="bound">ts</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The generated code uses neither target-language \texttt{if-then-else} nor match expressions.›</span></span>

<span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">test</span></span> <span class="quoted"><span class="quoted">test'</span></span> <span class="quoted"><span class="quoted">test''</span></span> <span class="quoted"><span class="quoted">fac</span></span> <span class="quoted"><span class="quoted">map_tree</span></span> <span class="keyword2"><span class="keyword">in</span></span> SML

<span class="comment1">(*&lt;*)</span>

<span class="keyword1"><span class="command">ML</span></span><span class="quoted">‹
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">get_code_eqs</span> <span class="entity">ctxt</span> <span class="entity">const</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">thy</span> <span class="main">=</span> Proof_Context.theory_of <span class="entity">ctxt</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">graph</span> <span class="main">=</span> <span class="main">#</span>eqngr <span class="main">(</span><span class="entity">Code_Preproc.obtain</span> true <span class="main">{</span> ctxt <span class="main">=</span> <span class="entity">ctxt</span><span class="main">,</span> consts <span class="main">=</span> <span class="main">[</span><span class="entity">const</span><span class="main">]</span><span class="main">,</span> terms <span class="main">=</span> <span class="main">[</span><span class="main">]</span> <span class="main">}</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">mk_eqs</span> <span class="entity">name</span> <span class="main">=</span> <span class="entity">name</span>
      |&gt; <span class="entity">Code_Preproc.cert</span> <span class="entity">graph</span>
      |&gt; <span class="entity">Code.equations_of_cert</span> <span class="entity">thy</span> ||&gt; these
      |&gt; pair <span class="entity">name</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    AList.lookup <span class="main">(</span><span class="main">=</span><span class="main">)</span> <span class="main">(</span>maps <span class="main">(</span>map <span class="entity">mk_eqs</span><span class="main">)</span> <span class="main">(</span>rev <span class="main">(</span>Graph.strong_conn <span class="entity">graph</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="entity">const</span>
    |&gt; the |&gt; snd
    |&gt; map <span class="main">(</span>fst o snd<span class="main">)</span>
    |&gt; map_filter I
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">check_absence</span> <span class="entity">ctxt</span> <span class="entity">const</span> <span class="main">=</span>
  <span class="keyword2"><span class="keyword">let</span></span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">forbidden</span> <span class="main">=</span>
      <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> HOL.If<span class="antiquote">}</span></span> :: map <span class="main">(</span>fst o dest_Const o <span class="main">#</span>casex<span class="main">)</span> <span class="main">(</span><span class="entity">Ctr_Sugar.ctr_sugars_of</span> <span class="entity">ctxt</span><span class="main">)</span>
    <span class="keyword1"><span class="keyword">val</span></span> <span class="entity">check</span> <span class="main">=</span> exists_subterm <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> Const <span class="main">(</span><span class="entity">c</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> <span class="main">=&gt;</span> member <span class="main">(</span><span class="main">=</span><span class="main">)</span> <span class="entity">forbidden</span> <span class="entity">c</span> <span class="main">|</span> <span class="main">_</span> <span class="main">=&gt;</span> false<span class="main">)</span>
  <span class="keyword2"><span class="keyword">in</span></span>
    <span class="entity">get_code_eqs</span> <span class="entity">ctxt</span> <span class="entity">const</span>
    |&gt; map Thm.prop_of
    |&gt; forall <span class="main">(</span>not o <span class="entity">check</span><span class="main">)</span>
    |&gt; <span class="antiquoted"><span class="entity"><span class="entity"><span class="antiquote">@{</span><span class="operator">assert</span><span class="antiquote">}</span></span></span></span>
  <span class="keyword2"><span class="keyword">end</span></span>
›</span>

<span class="keyword1"><span class="command">ML_val</span></span><span class="quoted">‹<span class="entity">check_absence</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> fac<span class="antiquote">}</span></span><span class="main">:</span> unit›</span>
<span class="keyword1"><span class="command">ML_val</span></span><span class="quoted">‹<span class="entity">check_absence</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> test<span class="antiquote">}</span></span><span class="main">:</span> unit›</span>
<span class="keyword1"><span class="command">ML_val</span></span><span class="quoted">‹<span class="entity">check_absence</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> test'<span class="antiquote">}</span></span><span class="main">:</span> unit›</span>
<span class="keyword1"><span class="command">ML_val</span></span><span class="quoted">‹<span class="entity">check_absence</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> test''<span class="antiquote">}</span></span><span class="main">:</span> unit›</span>
<span class="keyword1"><span class="command">ML_val</span></span><span class="quoted">‹<span class="entity">check_absence</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span> <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const_name</span> map_tree<span class="antiquote">}</span></span><span class="main">:</span> unit›</span>

<span class="comment1">(*&gt;*)</span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div>