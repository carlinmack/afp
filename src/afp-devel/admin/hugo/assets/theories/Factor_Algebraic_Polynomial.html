<div id="Roots_via_IA">
<div class="head">
<h1>Theory Roots_via_IA</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Root Filter via Interval Arithmetic›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Generic Framework›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We provide algorithms for finding all real or complex roots of a polynomial
  from a superset of the roots via interval arithmetic. 
  These algorithms are much faster than just
  evaluating the polynomial via algebraic number computations.›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Roots_via_IA
  <span class="keyword2"><span class="keyword">imports</span></span> 
    <a href="../../algebraic_numbers/theories/#Interval_Arithmetic">Algebraic_Numbers.Interval_Arithmetic</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">interval_of_real</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> real <span class="main">⇒</span> real interval"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">interval_of_real</span> <span class="free"><span class="bound"><span class="entity">prec</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span>
      <span class="main">(</span><span class="keyword1">if</span> is_rat <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">then</span> Interval <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>
       <span class="keyword1">else</span> <span class="keyword1">let</span> <span class="bound">n</span> <span class="main">=</span> <span class="numeral">2</span> <span class="main">^</span> <span class="free"><span class="bound"><span class="entity">prec</span></span></span><span class="main">;</span> <span class="bound">x'</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">*</span> of_int <span class="bound">n</span>
            <span class="keyword1">in</span>  Interval <span class="main">(</span>of_rat <span class="main">(</span>Rat.Fract <span class="main">⌊</span><span class="bound">x'</span><span class="main">⌋</span> <span class="bound">n</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>of_rat <span class="main">(</span>Rat.Fract <span class="main">⌈</span><span class="bound">x'</span><span class="main">⌉</span> <span class="bound">n</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">interval_of_complex</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> complex <span class="main">⇒</span> complex_interval"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">interval_of_complex</span> <span class="free"><span class="bound"><span class="entity">prec</span></span></span> <span class="free"><span class="bound"><span class="entity">z</span></span></span> <span class="main">=</span>
     Complex_Interval <span class="main">(</span>interval_of_real <span class="free"><span class="bound"><span class="entity">prec</span></span></span> <span class="main">(</span>Re <span class="free"><span class="bound"><span class="entity">z</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>interval_of_real <span class="free"><span class="bound"><span class="entity">prec</span></span></span> <span class="main">(</span>Im <span class="free"><span class="bound"><span class="entity">z</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">poly_interval</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> <span class="main">{</span>plus<span class="main">,</span>times<span class="main">,</span>zero<span class="main">}</span> list <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">poly_interval</span> <span class="main">[]</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> <span class="main">0</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">poly_interval</span> <span class="main">[</span><span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">]</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">poly_interval</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">cs</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">+</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">*</span> <span class="free">poly_interval</span> <span class="free"><span class="bound"><span class="entity">cs</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">filter_fun_complex</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"complex poly <span class="main">⇒</span> nat <span class="main">⇒</span> complex <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">filter_fun_complex</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">c</span> <span class="main">=</span> coeffs <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="keyword1">in</span>
      <span class="main">(</span><span class="main">λ</span> <span class="bound">prec</span><span class="main">.</span> <span class="keyword1">let</span> <span class="bound">cs</span> <span class="main">=</span> map <span class="main">(</span>interval_of_complex <span class="bound">prec</span><span class="main">)</span> <span class="bound">c</span>
      <span class="keyword1">in</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">x</span><span class="main">.</span> <span class="main">0</span> <span class="keyword1">∈<span class="hidden">⇩</span><sub>c</sub></span> poly_interval <span class="bound">cs</span> <span class="main">(</span>interval_of_complex <span class="bound">prec</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> 

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">filter_fun_real</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"real poly <span class="main">⇒</span> nat <span class="main">⇒</span> real <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">filter_fun_real</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">c</span> <span class="main">=</span> coeffs <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="keyword1">in</span>
      <span class="main">(</span><span class="main">λ</span> <span class="bound">prec</span><span class="main">.</span> <span class="keyword1">let</span> <span class="bound">cs</span> <span class="main">=</span> map <span class="main">(</span>interval_of_real <span class="bound">prec</span><span class="main">)</span> <span class="bound">c</span>
      <span class="keyword1">in</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">x</span><span class="main">.</span> <span class="main">0</span> <span class="keyword1">∈<span class="hidden">⇩</span><sub>i</sub></span> poly_interval <span class="bound">cs</span> <span class="main">(</span>interval_of_real <span class="bound">prec</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> 

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">genuine_roots</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">_</span> poly <span class="main">⇒</span> <span class="main">_</span> list <span class="main">⇒</span> <span class="main">_</span> list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">genuine_roots</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> filter <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> poly <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="bound">x</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span>"</span></span>

<span class="keyword1" id="Roots_via_IA-zero_in_interval_0"><span class="command">lemma</span></span> zero_in_interval_0 <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="keyword1">∈<span class="hidden">⇩</span><sub>i</sub></span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> zero_interval_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Roots_via_IA-zero_in_complex_interval_0"><span class="command">lemma</span></span> zero_in_complex_interval_0 <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="keyword1">∈<span class="hidden">⇩</span><sub>c</sub></span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> zero_complex_interval_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_complex_interval_def<span class="main">)</span>

<span class="keyword1" id="Roots_via_IA-length_coeffs_degree'"><span class="command">lemma</span></span> length_coeffs_degree'<span class="main">:</span>
  <span class="quoted"><span class="quoted">"length <span class="main">(</span>coeffs <span class="free">p</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">p</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> Suc <span class="main">(</span>degree <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">=</span> <span class="main">0</span>"</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> length_coeffs_degree<span class="main">)</span>

<span class="keyword1" id="Roots_via_IA-poly_in_poly_interval_complex"><span class="command">lemma</span></span> poly_in_poly_interval_complex<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"list_all2 <span class="main">(</span><span class="main">λ</span><span class="bound">c</span> <span class="bound">ivl</span><span class="main">.</span> <span class="bound">c</span> <span class="keyword1">∈<span class="hidden">⇩</span><sub>c</sub></span> <span class="bound">ivl</span><span class="main">)</span> <span class="main">(</span>coeffs <span class="free">p</span><span class="main">)</span> <span class="free">cs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="keyword1">∈<span class="hidden">⇩</span><sub>c</sub></span> <span class="free">ivl</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"poly <span class="free">p</span> <span class="free">x</span> <span class="keyword1">∈<span class="hidden">⇩</span><sub>c</sub></span> poly_interval <span class="free">cs</span> <span class="free">ivl</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> len_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>coeffs <span class="free">p</span><span class="main">)</span> <span class="main">=</span> length <span class="free">cs</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>1<span class="main">)</span> list_all2_lengthD <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"coeffs <span class="free">p</span> <span class="main">=</span> map <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> coeffs <span class="free">p</span> <span class="main">!</span> <span class="bound">i</span><span class="main">)</span> <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span>length <span class="free">cs</span><span class="main">]</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> len_eq <span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> map_nth <span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> map <span class="main">(</span>poly.coeff <span class="free">p</span><span class="main">)</span> <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span>length <span class="free">cs</span><span class="main">]</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> map_cong<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> nth_coeffs_coeff len_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"list_all2 <span class="main">(</span><span class="main">λ</span><span class="bound">c</span> <span class="bound">ivl</span><span class="main">.</span> <span class="bound">c</span> <span class="keyword1">∈<span class="hidden">⇩</span><sub>c</sub></span> <span class="bound">ivl</span><span class="main">)</span> <span class="main">(</span>map <span class="main">(</span>poly.coeff <span class="free">p</span><span class="main">)</span> <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span>length <span class="free">cs</span><span class="main">]</span><span class="main">)</span> <span class="free">cs</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"length <span class="free">cs</span> <span class="main">≥</span> length <span class="main">(</span>coeffs <span class="free">p</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> len_eq <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">)</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">cs</span></span> <span class="quoted"><span class="free">ivl</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">p</span></span> <span class="quoted"><span class="free">x</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> poly_interval.induct<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">ivl</span> <span class="skolem">p</span> <span class="skolem">x</span><span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>2 <span class="skolem">c</span> <span class="skolem">ivl</span> <span class="skolem">p</span> <span class="skolem">x</span><span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"degree <span class="skolem">p</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> 2 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> degree_eq_length_coeffs<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">c'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">=</span> <span class="main">[:</span><span class="skolem">c'</span><span class="main">:]</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> degree_eq_zeroE<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> 2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>3 <span class="skolem">c1</span> <span class="skolem">c2</span> <span class="skolem">cs</span> <span class="skolem">ivl</span> <span class="skolem">p</span> <span class="skolem">x</span><span class="main">)</span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">q</span></span> <span class="skolem"><span class="skolem">c</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">=</span> pCons <span class="skolem">c</span> <span class="skolem">q</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">p</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> pCons_cases<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"list_all2 in_complex_interval <span class="main">(</span>map <span class="main">(</span>poly.coeff <span class="skolem">p</span><span class="main">)</span> <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span>length <span class="main">(</span><span class="skolem">c1</span> <span class="main">#</span> <span class="skolem">c2</span> <span class="main">#</span> <span class="skolem">cs</span><span class="main">)</span><span class="main">]</span><span class="main">)</span>
                  <span class="main">(</span><span class="skolem">c1</span> <span class="main">#</span> <span class="skolem">c2</span> <span class="main">#</span> <span class="skolem">cs</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> <span class="quoted">"3.prems"</span><span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span>length <span class="main">(</span><span class="skolem">c1</span> <span class="main">#</span> <span class="skolem">c2</span> <span class="main">#</span> <span class="skolem">cs</span><span class="main">)</span><span class="main">]</span> <span class="main">=</span> <span class="main">0</span> <span class="main">#</span> map Suc <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span>length <span class="main">(</span><span class="skolem">c2</span> <span class="main">#</span> <span class="skolem">cs</span><span class="main">)</span><span class="main">]</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> length_Cons map_Suc_upt upt_conv_Cons zero_less_Suc<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map <span class="main">(</span>poly.coeff <span class="skolem">p</span><span class="main">)</span> <span class="main">…</span> <span class="main">=</span> <span class="skolem">c</span> <span class="main">#</span> map <span class="main">(</span>poly.coeff <span class="skolem">q</span><span class="main">)</span> <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span>length <span class="main">(</span><span class="skolem">c2</span> <span class="main">#</span> <span class="skolem">cs</span><span class="main">)</span><span class="main">]</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="keyword1">∈<span class="hidden">⇩</span><sub>c</sub></span> <span class="skolem">c1</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
        <span class="quoted"><span class="quoted">"list_all2 in_complex_interval <span class="main">(</span>map <span class="main">(</span>poly.coeff <span class="skolem">q</span><span class="main">)</span> <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span>length <span class="main">(</span><span class="skolem">c2</span> <span class="main">#</span> <span class="skolem">cs</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="main">(</span><span class="skolem">c2</span> <span class="main">#</span> <span class="skolem">cs</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> <span class="quoted">"3.prems"</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> upt_Suc<span class="main">)</span>

    <span class="keyword1"><span class="command">have</span></span> IH<span class="main">:</span> <span class="quoted"><span class="quoted">"poly <span class="skolem">q</span> <span class="skolem">x</span> <span class="keyword1">∈<span class="hidden">⇩</span><sub>c</sub></span> poly_interval <span class="main">(</span><span class="skolem">c2</span> <span class="main">#</span> <span class="skolem">cs</span><span class="main">)</span> <span class="skolem">ivl</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> <span class="quoted">"3.IH"</span><span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>coeffs <span class="skolem">q</span><span class="main">)</span> <span class="main">≤</span> length <span class="main">(</span><span class="skolem">c2</span> <span class="main">#</span> <span class="skolem">cs</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> <span class="quoted">"3.prems"</span><span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> length_coeffs_degree' <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="operator">fact</span><span class="main"><span class="keyword3">+</span></span>

    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">using</span></span> IH <span class="quoted">"3.prems"</span> <span class="quoted"><span class="quoted">‹<span class="skolem">c</span> <span class="keyword1">∈<span class="hidden">⇩</span><sub>c</sub></span> <span class="skolem">c1</span>›</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> plus_complex_interval times_complex_interval<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Roots_via_IA-poly_in_poly_interval_real"><span class="command">lemma</span></span> poly_in_poly_interval_real<span class="main">:</span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span> <span class="main">::</span> <span class="quoted">real</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"list_all2 <span class="main">(</span><span class="main">λ</span><span class="bound">c</span> <span class="bound">ivl</span><span class="main">.</span> <span class="bound">c</span> <span class="keyword1">∈<span class="hidden">⇩</span><sub>i</sub></span> <span class="bound">ivl</span><span class="main">)</span> <span class="main">(</span>coeffs <span class="free">p</span><span class="main">)</span> <span class="free">cs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="keyword1">∈<span class="hidden">⇩</span><sub>i</sub></span> <span class="free">ivl</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"poly <span class="free">p</span> <span class="free">x</span> <span class="keyword1">∈<span class="hidden">⇩</span><sub>i</sub></span> poly_interval <span class="free">cs</span> <span class="free">ivl</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> len_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>coeffs <span class="free">p</span><span class="main">)</span> <span class="main">=</span> length <span class="free">cs</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>1<span class="main">)</span> list_all2_lengthD <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"coeffs <span class="free">p</span> <span class="main">=</span> map <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> coeffs <span class="free">p</span> <span class="main">!</span> <span class="bound">i</span><span class="main">)</span> <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span>length <span class="free">cs</span><span class="main">]</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> len_eq <span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> map_nth <span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> map <span class="main">(</span>poly.coeff <span class="free">p</span><span class="main">)</span> <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span>length <span class="free">cs</span><span class="main">]</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> map_cong<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> nth_coeffs_coeff len_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"list_all2 <span class="main">(</span><span class="main">λ</span><span class="bound">c</span> <span class="bound">ivl</span><span class="main">.</span> <span class="bound">c</span> <span class="keyword1">∈<span class="hidden">⇩</span><sub>i</sub></span> <span class="bound">ivl</span><span class="main">)</span> <span class="main">(</span>map <span class="main">(</span>poly.coeff <span class="free">p</span><span class="main">)</span> <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span>length <span class="free">cs</span><span class="main">]</span><span class="main">)</span> <span class="free">cs</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"length <span class="free">cs</span> <span class="main">≥</span> length <span class="main">(</span>coeffs <span class="free">p</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> len_eq <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">)</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">cs</span></span> <span class="quoted"><span class="free">ivl</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">p</span></span> <span class="quoted"><span class="free">x</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> poly_interval.induct<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">ivl</span> <span class="skolem">p</span> <span class="skolem">x</span><span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>2 <span class="skolem">c</span> <span class="skolem">ivl</span> <span class="skolem">p</span> <span class="skolem">x</span><span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"degree <span class="skolem">p</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> 2 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> degree_eq_length_coeffs<span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">c'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">=</span> <span class="main">[:</span><span class="skolem">c'</span><span class="main">:]</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> degree_eq_zeroE<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> 2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>3 <span class="skolem">c1</span> <span class="skolem">c2</span> <span class="skolem">cs</span> <span class="skolem">ivl</span> <span class="skolem">p</span> <span class="skolem">x</span><span class="main">)</span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">q</span></span> <span class="skolem"><span class="skolem">c</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">=</span> pCons <span class="skolem">c</span> <span class="skolem">q</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">p</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> pCons_cases<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"list_all2 in_interval <span class="main">(</span>map <span class="main">(</span>poly.coeff <span class="skolem">p</span><span class="main">)</span> <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span>length <span class="main">(</span><span class="skolem">c1</span> <span class="main">#</span> <span class="skolem">c2</span> <span class="main">#</span> <span class="skolem">cs</span><span class="main">)</span><span class="main">]</span><span class="main">)</span>
                  <span class="main">(</span><span class="skolem">c1</span> <span class="main">#</span> <span class="skolem">c2</span> <span class="main">#</span> <span class="skolem">cs</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> <span class="quoted">"3.prems"</span><span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span>length <span class="main">(</span><span class="skolem">c1</span> <span class="main">#</span> <span class="skolem">c2</span> <span class="main">#</span> <span class="skolem">cs</span><span class="main">)</span><span class="main">]</span> <span class="main">=</span> <span class="main">0</span> <span class="main">#</span> map Suc <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span>length <span class="main">(</span><span class="skolem">c2</span> <span class="main">#</span> <span class="skolem">cs</span><span class="main">)</span><span class="main">]</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> length_Cons map_Suc_upt upt_conv_Cons zero_less_Suc<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map <span class="main">(</span>poly.coeff <span class="skolem">p</span><span class="main">)</span> <span class="main">…</span> <span class="main">=</span> <span class="skolem">c</span> <span class="main">#</span> map <span class="main">(</span>poly.coeff <span class="skolem">q</span><span class="main">)</span> <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span>length <span class="main">(</span><span class="skolem">c2</span> <span class="main">#</span> <span class="skolem">cs</span><span class="main">)</span><span class="main">]</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="keyword1">∈<span class="hidden">⇩</span><sub>i</sub></span> <span class="skolem">c1</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
        <span class="quoted"><span class="quoted">"list_all2 in_interval <span class="main">(</span>map <span class="main">(</span>poly.coeff <span class="skolem">q</span><span class="main">)</span> <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span>length <span class="main">(</span><span class="skolem">c2</span> <span class="main">#</span> <span class="skolem">cs</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="main">(</span><span class="skolem">c2</span> <span class="main">#</span> <span class="skolem">cs</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> <span class="quoted">"3.prems"</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> upt_Suc<span class="main">)</span>

    <span class="keyword1"><span class="command">have</span></span> IH<span class="main">:</span> <span class="quoted"><span class="quoted">"poly <span class="skolem">q</span> <span class="skolem">x</span> <span class="keyword1">∈<span class="hidden">⇩</span><sub>i</sub></span> poly_interval <span class="main">(</span><span class="skolem">c2</span> <span class="main">#</span> <span class="skolem">cs</span><span class="main">)</span> <span class="skolem">ivl</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> <span class="quoted">"3.IH"</span><span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>coeffs <span class="skolem">q</span><span class="main">)</span> <span class="main">≤</span> length <span class="main">(</span><span class="skolem">c2</span> <span class="main">#</span> <span class="skolem">cs</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> <span class="quoted">"3.prems"</span><span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> length_coeffs_degree' <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="operator">fact</span><span class="main"><span class="keyword3">+</span></span>

    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">using</span></span> IH <span class="quoted">"3.prems"</span> <span class="quoted"><span class="quoted">‹<span class="skolem">c</span> <span class="keyword1">∈<span class="hidden">⇩</span><sub>i</sub></span> <span class="skolem">c1</span>›</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> plus_in_interval times_in_interval<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1" id="Roots_via_IA-in_interval_of_real"><span class="command">lemma</span></span> in_interval_of_real <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="keyword1">∈<span class="hidden">⇩</span><sub>i</sub></span> interval_of_real <span class="free">prec</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> interval_of_real_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def of_rat_rat <span class="dynamic"><span class="dynamic">field_simps</span></span><span class="main">)</span>

<span class="keyword1" id="Roots_via_IA-in_interval_of_complex"><span class="command">lemma</span></span> in_interval_of_complex <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">z</span> <span class="keyword1">∈<span class="hidden">⇩</span><sub>c</sub></span> interval_of_complex <span class="free">prec</span> <span class="free">z</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> interval_of_complex_def in_complex_interval_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Roots_via_IA-distinct_genuine_roots"><span class="command">lemma</span></span> distinct_genuine_roots <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"distinct <span class="free">xs</span> <span class="main">⟹</span> distinct <span class="main">(</span>genuine_roots <span class="free">p</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> genuine_roots_def<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">filter_fun</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> poly <span class="main">⇒</span> <span class="main">(</span>nat <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">::</span> comm_ring <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">filter_fun</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">n</span> <span class="bound">x</span><span class="main">.</span> poly <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="bound">x</span> <span class="main">=</span> <span class="main">0</span> <span class="main">⟶</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">n</span> <span class="bound">x</span><span class="main">)</span>"</span></span> 

<span class="keyword1" id="Roots_via_IA-filter_fun_complex"><span class="command">lemma</span></span> filter_fun_complex<span class="main">:</span> <span class="quoted"><span class="quoted">"filter_fun <span class="free">p</span> <span class="main">(</span>filter_fun_complex <span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> filter_fun_def
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> impI allI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">prec</span> <span class="skolem">x</span>
  <span class="keyword3"><span class="command">assume</span></span> root<span class="main">:</span> <span class="quoted"><span class="quoted">"poly <span class="free">p</span> <span class="skolem">x</span> <span class="main">=</span> <span class="main">0</span>"</span></span> 
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">cs</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">cs</span> <span class="main">=</span> map <span class="main">(</span>interval_of_complex <span class="skolem">prec</span><span class="main">)</span> <span class="main">(</span>coeffs <span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> cs<span class="main">:</span> <span class="quoted"><span class="quoted">"list_all2 in_complex_interval <span class="main">(</span>coeffs <span class="free">p</span><span class="main">)</span> <span class="skolem">cs</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> cs_def list_all2_map2 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> list_all2_refl in_interval_of_complex<span class="main">)</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">P</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">P</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">0</span> <span class="keyword1">∈<span class="hidden">⇩</span><sub>c</sub></span> poly_interval <span class="skolem">cs</span> <span class="main">(</span>interval_of_complex <span class="skolem">prec</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">P</span> <span class="skolem">x</span>"</span></span> 
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"poly <span class="free">p</span> <span class="skolem">x</span> <span class="keyword1">∈<span class="hidden">⇩</span><sub>c</sub></span> poly_interval <span class="skolem">cs</span> <span class="main">(</span>interval_of_complex <span class="skolem">prec</span> <span class="skolem">x</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> poly_in_poly_interval_complex in_interval_of_complex cs<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> root <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> P_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"filter_fun_complex <span class="free">p</span> <span class="skolem">prec</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> filter_fun_complex_def Let_def P_def
    <span class="keyword1"><span class="command">using</span></span> cs_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Roots_via_IA-filter_fun_real"><span class="command">lemma</span></span> filter_fun_real<span class="main">:</span> <span class="quoted"><span class="quoted">"filter_fun <span class="free">p</span> <span class="main">(</span>filter_fun_real <span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> filter_fun_def
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> impI allI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">prec</span> <span class="skolem">x</span>
  <span class="keyword3"><span class="command">assume</span></span> root<span class="main">:</span> <span class="quoted"><span class="quoted">"poly <span class="free">p</span> <span class="skolem">x</span> <span class="main">=</span> <span class="main">0</span>"</span></span> 
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">cs</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">cs</span> <span class="main">=</span> map <span class="main">(</span>interval_of_real <span class="skolem">prec</span><span class="main">)</span> <span class="main">(</span>coeffs <span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> cs<span class="main">:</span> <span class="quoted"><span class="quoted">"list_all2 in_interval <span class="main">(</span>coeffs <span class="free">p</span><span class="main">)</span> <span class="skolem">cs</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> cs_def list_all2_map2 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> list_all2_refl in_interval_of_real<span class="main">)</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">P</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">P</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">0</span> <span class="keyword1">∈<span class="hidden">⇩</span><sub>i</sub></span> poly_interval <span class="skolem">cs</span> <span class="main">(</span>interval_of_real <span class="skolem">prec</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">P</span> <span class="skolem">x</span>"</span></span> 
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"poly <span class="free">p</span> <span class="skolem">x</span> <span class="keyword1">∈<span class="hidden">⇩</span><sub>i</sub></span> poly_interval <span class="skolem">cs</span> <span class="main">(</span>interval_of_real <span class="skolem">prec</span> <span class="skolem">x</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> poly_in_poly_interval_real in_interval_of_real cs<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> root <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> P_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"filter_fun_real <span class="free">p</span> <span class="skolem">prec</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> filter_fun_real_def Let_def P_def
    <span class="keyword1"><span class="command">using</span></span> cs_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">p</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> comm_ring poly"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">f</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> ff<span class="main">:</span> <span class="quoted"><span class="quoted">"filter_fun <span class="free">p</span> <span class="free">f</span>"</span></span> 
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Roots_via_IA-genuine_roots_step"><span class="command">lemma</span></span> genuine_roots_step<span class="main">:</span>
  <span class="quoted"><span class="quoted">"genuine_roots <span class="free">p</span> <span class="free">xs</span> <span class="main">=</span> genuine_roots <span class="free">p</span> <span class="main">(</span>filter <span class="main">(</span><span class="free">f</span> <span class="free">prec</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> genuine_roots_def filter_filter 
  <span class="keyword1"><span class="command">using</span></span> ff<span class="main">[</span><span class="operator">unfolded</span> filter_fun_def<span class="main">,</span> <span class="operator">rule_format</span><span class="main">,</span> <span class="operator">of</span> <span class="main">_</span> <span class="quoted"><span class="free">prec</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span> 

<span class="keyword1" id="Roots_via_IA-genuine_roots_step_preserve_invar"><span class="command">lemma</span></span> genuine_roots_step_preserve_invar<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">z</span><span class="main">.</span> poly <span class="free">p</span> <span class="bound">z</span> <span class="main">=</span> <span class="main">0</span><span class="main">}</span> <span class="main">⊆</span> set <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">z</span><span class="main">.</span> poly <span class="free">p</span> <span class="bound">z</span> <span class="main">=</span> <span class="main">0</span><span class="main">}</span> <span class="main">⊆</span> set <span class="main">(</span>filter <span class="main">(</span><span class="free">f</span> <span class="free">prec</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">z</span><span class="main">.</span> poly <span class="free">p</span> <span class="bound">z</span> <span class="main">=</span> <span class="main">0</span><span class="main">}</span> <span class="main">=</span> set <span class="main">(</span>genuine_roots <span class="free">p</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> genuine_roots_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> set <span class="main">(</span>genuine_roots <span class="free">p</span> <span class="main">(</span>filter <span class="main">(</span><span class="free">f</span> <span class="free">prec</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> genuine_roots_step<span class="main">[</span><span class="operator">of</span> <span class="main">_</span> <span class="quoted"><span class="free">prec</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">⊆</span> set <span class="main">(</span>filter <span class="main">(</span><span class="free">f</span> <span class="free">prec</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> genuine_roots_def<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Roots_via_IA-genuine_roots_finish"><span class="command">lemma</span></span> genuine_roots_finish<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">p</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> field_char_0 poly"</span></span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">z</span><span class="main">.</span> poly <span class="free">p</span> <span class="bound">z</span> <span class="main">=</span> <span class="main">0</span><span class="main">}</span> <span class="main">⊆</span> set <span class="free">xs</span>"</span></span> <span class="quoted"><span class="quoted">"distinct <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"length <span class="free">xs</span> <span class="main">=</span> card <span class="main">{</span><span class="bound">z</span><span class="main">.</span> poly <span class="free">p</span> <span class="bound">z</span> <span class="main">=</span> <span class="main">0</span><span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"genuine_roots <span class="free">p</span> <span class="free">xs</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> finite_subset<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> finite_set<span class="main">]</span> infinite_UNIV_char_0 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>genuine_roots <span class="free">p</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> length <span class="free">xs</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> genuine_roots_def <span class="keyword1"><span class="command">using</span></span> assms 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Int_absorb2 distinct_length_filter<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> genuine_roots_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> filter_True length_filter_less linorder_not_less order_eq_iff<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This is type of the initial search problem. It consists of a polynomial $p$, 
  a list $xs$ of candidate roots, the cardinality of the set of roots of $p$ and a filter function to
  drop non-roots that is parametric in a precision parameter.›</span></span>
<span class="keyword1"><span class="command">typedef</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">overloaded</span></span><span class="main">)</span> <span class="tfree">'a</span> genuine_roots_aux <span class="main">=</span>
  <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="main">(</span><span class="bound">p</span> <span class="main">::</span> <span class="tfree">'a</span> <span class="main">::</span> field_char_0 poly<span class="main">,</span> <span class="bound">xs</span><span class="main">,</span> <span class="bound">n</span><span class="main">,</span> <span class="bound">ff</span><span class="main">)</span><span class="main">.</span> 
    distinct <span class="bound">xs</span> <span class="main">∧</span> 
    <span class="main">{</span><span class="bound">z</span><span class="main">.</span> poly <span class="bound">p</span> <span class="bound">z</span> <span class="main">=</span> <span class="main">0</span><span class="main">}</span> <span class="main">⊆</span> set <span class="bound">xs</span> <span class="main">∧</span> 
    card <span class="main">{</span><span class="bound">z</span><span class="main">.</span> poly <span class="bound">p</span> <span class="bound">z</span> <span class="main">=</span> <span class="main">0</span><span class="main">}</span> <span class="main">=</span> <span class="bound">n</span> <span class="main">∧</span>
    filter_fun <span class="bound">p</span> <span class="bound">ff</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> exI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main"><span class="main">(</span></span></span><span class="main"><span class="main"><span class="main">1</span></span></span><span class="main"><span class="main"><span class="main">,</span></span></span> <span class="main"><span class="main"><span class="main">[]</span></span></span><span class="main"><span class="main"><span class="main">,</span></span></span> <span class="main"><span class="main"><span class="main">0</span></span></span><span class="main"><span class="main"><span class="main">,</span></span></span> <span class="main"><span class="main"><span class="main">λ</span></span></span> <span class="main"><span class="bound"><span class="main"><span class="bound"><span class="main"><span class="bound">_</span></span></span></span></span></span> <span class="main"><span class="bound"><span class="main"><span class="bound"><span class="main"><span class="bound">_</span></span></span></span></span></span><span class="main"><span class="main"><span class="main">.</span></span></span> False<span class="main"><span class="main"><span class="main">)</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> filter_fun_def<span class="main">)</span>

<span class="keyword1"><span class="command">setup_lifting</span></span> type_definition_genuine_roots_aux

<span class="keyword1"><span class="command">lift_definition</span></span> genuine_roots' <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">::</span> field_char_0 genuine_roots_aux <span class="main">⇒</span> <span class="tfree">'a</span> list"</span></span> <span class="keyword2"><span class="keyword">is</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">prec</span> <span class="main">(</span><span class="bound">p</span><span class="main">,</span> <span class="bound">xs</span><span class="main">,</span> <span class="bound">n</span><span class="main">,</span> <span class="bound">ff</span><span class="main">)</span><span class="main">.</span> genuine_roots <span class="bound">p</span> <span class="bound">xs</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> genuine_roots_impl_step' <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">::</span> field_char_0 genuine_roots_aux <span class="main">⇒</span> <span class="tfree">'a</span> genuine_roots_aux"</span></span> <span class="keyword2"><span class="keyword">is</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">prec</span> <span class="main">(</span><span class="bound">p</span><span class="main">,</span> <span class="bound">xs</span><span class="main">,</span> <span class="bound">n</span><span class="main">,</span> <span class="bound">ff</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">p</span><span class="main">,</span> filter <span class="main">(</span><span class="bound">ff</span> <span class="bound">prec</span><span class="main">)</span> <span class="bound">xs</span><span class="main">,</span> <span class="bound">n</span><span class="main">,</span> <span class="bound">ff</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">safe</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">intro</span> distinct_filter<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> filter_fun_def<span class="main">)</span>

<span class="keyword1"><span class="command">lift_definition</span></span> gr_poly <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> field_char_0 genuine_roots_aux <span class="main">⇒</span> <span class="tfree">'a</span> poly"</span></span> <span class="keyword2"><span class="keyword">is</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="bound">p</span> <span class="main">::</span> <span class="tfree">'a</span> poly<span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="bound">p</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> gr_list <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> field_char_0 genuine_roots_aux <span class="main">⇒</span> <span class="tfree">'a</span> list"</span></span> <span class="keyword2"><span class="keyword">is</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">xs</span> <span class="main">::</span> <span class="tfree">'a</span> list<span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="bound">xs</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> gr_numroots <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> field_char_0 genuine_roots_aux <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">is</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">n</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="bound">n</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1" id="Roots_via_IA-genuine_roots'_code"><span class="command">lemma</span></span> genuine_roots'_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"genuine_roots' <span class="free">prec</span> <span class="free">gr</span> <span class="main">=</span>
     <span class="main">(</span><span class="keyword1">if</span> length <span class="main">(</span>gr_list <span class="free">gr</span><span class="main">)</span> <span class="main">=</span> gr_numroots <span class="free">gr</span> <span class="keyword1">then</span> gr_list <span class="free">gr</span>
      <span class="keyword1">else</span> genuine_roots' <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="free">prec</span><span class="main">)</span> <span class="main">(</span>genuine_roots_impl_step' <span class="free">prec</span> <span class="free">gr</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">clarify</span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">prec</span> <span class="main">::</span> <span class="quoted">nat</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">p</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> poly"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">ff</span>
  <span class="keyword3"><span class="command">assume</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">z</span><span class="main">.</span> poly <span class="skolem">p</span> <span class="bound">z</span> <span class="main">=</span> <span class="main">0</span><span class="main">}</span> <span class="main">⊆</span> set <span class="skolem">xs</span>"</span></span> <span class="quoted"><span class="quoted">"distinct <span class="skolem">xs</span>"</span></span> <span class="quoted"><span class="quoted">"filter_fun <span class="skolem">p</span> <span class="skolem">ff</span>"</span></span> 
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"genuine_roots <span class="skolem">p</span> <span class="skolem">xs</span> <span class="main">=</span>
          <span class="main">(</span><span class="keyword1">if</span> length <span class="skolem">xs</span> <span class="main">=</span> card <span class="main">{</span><span class="bound">z</span><span class="main">.</span> poly <span class="skolem">p</span> <span class="bound">z</span> <span class="main">=</span> <span class="main">0</span><span class="main">}</span> <span class="keyword1">then</span> <span class="skolem">xs</span>
           <span class="keyword1">else</span> genuine_roots <span class="skolem">p</span> <span class="main">(</span>filter <span class="main">(</span><span class="skolem">ff</span> <span class="skolem">prec</span><span class="main">)</span> <span class="skolem">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> genuine_roots_finish<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">p</span></span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">]</span> genuine_roots_step<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">p</span></span><span class="main">]</span> * <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">initial_precision</span> <span class="main">::</span> <span class="quoted">nat</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">initial_precision</span> <span class="main">=</span> <span class="numeral">10</span>"</span></span> 

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">genuine_roots_impl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> genuine_roots_aux <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">::</span> field_char_0 list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">genuine_roots_impl</span> <span class="main">=</span> genuine_roots' initial_precision"</span></span> 

<span class="keyword1" id="Roots_via_IA-genuine_roots_impl"><span class="command">lemma</span></span> genuine_roots_impl<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>genuine_roots_impl <span class="free">p</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="bound">z</span><span class="main">.</span> poly <span class="main">(</span>gr_poly <span class="free">p</span><span class="main">)</span> <span class="bound">z</span> <span class="main">=</span> <span class="main">0</span><span class="main">}</span>"</span></span> 
  <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>genuine_roots_impl <span class="free">p</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> genuine_roots_impl_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> genuine_roots_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="Complex_Roots_IA_Code">
<div class="head">
<h1>Theory Complex_Roots_IA_Code</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Application: Compute <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>n›</span></span></span></span>-th Roots of Complex Numbers›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We provide a more efficient algorithm to compute <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>n›</span></span></span></span>-th roots of complex numbers
  than the existing implementation.›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Complex_Roots_IA_Code
  <span class="keyword2"><span class="keyword">imports</span></span> 
    <a href="../../cubic_quartic_equations/theories/#Complex_Roots">Cubic_Quartic_Equations.Complex_Roots</a>
    <a href="#Roots_via_IA">Roots_via_IA</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹TODO: One might change <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> complex_roots_of_int_poly<span class="antiquote"><span class="antiquote">}</span></span></span></span> to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> complex_roots_of_int_poly3<span class="antiquote"><span class="antiquote">}</span></span></span></span>
  in order to avoid an unnecessary factorization of an integer polynomial. However, then
  this change already needs to be performed within the definition of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> all_croots<span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span> 
<span class="keyword1"><span class="command">lift_definition</span></span> all_croots_part1 <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> complex <span class="main">⇒</span> complex genuine_roots_aux"</span></span> <span class="keyword2"><span class="keyword">is</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="bound">n</span> <span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">n</span> <span class="main">=</span> <span class="main">0</span> <span class="main">∨</span> <span class="bound">x</span> <span class="main">=</span> <span class="main">0</span> <span class="main">∨</span> <span class="main">¬</span> algebraic <span class="bound">x</span> <span class="keyword1">then</span> <span class="main">(</span><span class="main">1</span><span class="main">,</span><span class="main">[]</span><span class="main">,</span><span class="main">0</span><span class="main">,</span> filter_fun_complex <span class="main">1</span><span class="main">)</span> 
         <span class="keyword1">else</span> <span class="keyword1">let</span> <span class="bound">p</span> <span class="main">=</span> min_int_poly <span class="bound">x</span><span class="main">;</span>
              <span class="bound">q</span> <span class="main">=</span> poly_nth_root <span class="bound">n</span> <span class="bound">p</span><span class="main">;</span>
              <span class="bound">zeros</span> <span class="main">=</span> complex_roots_of_int_poly <span class="bound">q</span><span class="main">;</span>
              <span class="bound">r</span> <span class="main">=</span> Polynomial.monom <span class="main">1</span> <span class="bound">n</span> <span class="main">-</span> <span class="main">[:</span><span class="bound">x</span><span class="main">:]</span>
         <span class="keyword1">in</span> <span class="main">(</span><span class="bound">r</span><span class="main">,</span><span class="bound">zeros</span><span class="main">,</span> <span class="bound">n</span><span class="main">,</span> filter_fun_complex <span class="bound">r</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> n x
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">=</span> <span class="main">0</span> <span class="main">∨</span> <span class="skolem">x</span> <span class="main">=</span> <span class="main">0</span> <span class="main">∨</span> <span class="main">¬</span> algebraic <span class="skolem">x</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> filter_fun_complex<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">hence</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"algebraic <span class="skolem">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">z</span>
      <span class="keyword3"><span class="command">assume</span></span> zn<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">z</span><span class="main">^</span><span class="skolem">n</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> 
      <span class="keyword1"><span class="command">from</span></span> *<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> repr<span class="main">:</span> <span class="quoted"><span class="quoted">"min_int_poly <span class="skolem">x</span> <span class="keyword1">represents</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">from</span></span> represents_nth_root<span class="main">[</span><span class="operator">OF</span> *<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> zn repr<span class="main">]</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"poly_nth_root <span class="skolem">n</span> <span class="main">(</span>min_int_poly <span class="skolem">x</span><span class="main">)</span> <span class="keyword1">represents</span> <span class="skolem">z</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="main">{</span><span class="bound">z</span><span class="main">.</span> <span class="bound">z</span> <span class="main">^</span> <span class="skolem">n</span> <span class="main">=</span> <span class="skolem">x</span><span class="main">}</span> <span class="main">=</span> <span class="skolem">n</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> card_nth_roots<span class="main">)</span> <span class="main">(</span><span class="operator">use</span> * <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="operator">auto</span><span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> * 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def complex_roots_of_int_poly filter_fun_complex poly_monom<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">declare</span></span> all_croots_code<span class="main">[</span><span class="operator">code</span> <span class="quasi_keyword">del</span><span class="main">]</span>

<span class="keyword1" id="Complex_Roots_IA_Code-all_croots_improved_code"><span class="command">lemma</span></span> all_croots_improved_code<span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"all_croots <span class="free">n</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">n</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">[]</span> <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="free">x</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">[</span><span class="main">0</span><span class="main">]</span>
     <span class="keyword1">else</span> <span class="keyword1">if</span> algebraic <span class="free">x</span> <span class="keyword1">then</span> genuine_roots_impl <span class="main">(</span>all_croots_part1 <span class="free">n</span> <span class="free">x</span><span class="main">)</span>
     <span class="keyword1">else</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''all_croots invoked on non-algebraic number''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> all_croots <span class="free">n</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">=</span> <span class="main">0</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> all_croots_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> n<span class="main">:</span> False
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="main">0</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> x<span class="main">:</span> False
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"algebraic <span class="free">x</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> False
      <span class="keyword1"><span class="command">with</span></span> n x <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> True
      <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">t</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">t</span> <span class="main">=</span> <span class="var">?thesis</span>"</span></span> 
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">t</span> <span class="main">⟷</span> filter <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">^</span> <span class="free">n</span> <span class="main">=</span> <span class="free">x</span><span class="main">)</span>
                <span class="main">(</span>complex_roots_of_int_poly <span class="main">(</span>poly_nth_root <span class="free">n</span> <span class="main">(</span>min_int_poly <span class="free">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
            <span class="main">=</span> genuine_roots_impl <span class="main">(</span>all_croots_part1 <span class="free">n</span> <span class="free">x</span><span class="main">)</span>"</span></span> 
        <span class="keyword1"><span class="command">unfolding</span></span> t_def
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> all_croots_code<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">n</span></span></span></span></span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">x</span></span></span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">unfold</span> Let_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">insert</span> n x True<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> n x True <span class="keyword1"><span class="command">unfolding</span></span> genuine_roots_impl_def
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Let_def genuine_roots_def poly_monom<span class="main">)</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> t_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> x<span class="main">:</span> True
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>all_croots <span class="free">n</span> <span class="main">0</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> all_croots<span class="main">[</span><span class="operator">OF</span> n<span class="main">]</span> <span class="keyword1"><span class="command">using</span></span> n <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>all_croots <span class="free">n</span> <span class="main">0</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> all_croots_def <span class="keyword1"><span class="command">using</span></span> n
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> distinct_filter complex_roots_of_int_poly<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"all_croots <span class="free">n</span> <span class="main">0</span> <span class="main">=</span> <span class="main">[</span><span class="main">0</span><span class="main">]</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> <span class="main"><span class="main">(</span></span>verit<span class="main"><span class="main">,</span></span> del_insts<span class="main"><span class="main">)</span></span> distinct.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> distinct_singleton insert_ident list.set_cases list.set_intros<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> list.simps<span class="main"><span class="main">(</span></span>15<span class="main"><span class="main">)</span></span> mem_Collect_eq set_empty singleton_conv<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?thesis</span> <span class="main">⟷</span> all_croots <span class="free">n</span> <span class="main">0</span> <span class="main">=</span> <span class="main">[</span><span class="main">0</span><span class="main">]</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> n x <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Poly_Connection">
<div class="head">
<h1>Theory Poly_Connection</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Resultants and Multivariate Polynomials›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Connecting Univariate and Multivariate Polynomials›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We define a conversion of multivariate polynomials into univariate polynomials
  w.r.t.\ a fixed variable $x$ and multivariate polynomials as coefficients.›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Poly_Connection
  <span class="keyword2"><span class="keyword">imports</span></span> 
    <a href="../../polynomials/theories/#MPoly_Type_Univariate">Polynomials.MPoly_Type_Univariate</a>
    <a href="../../jordan_normal_form/theories/#Missing_Permutations">Jordan_Normal_Form.Missing_Permutations</a>
    <a href="../../polynomial_interpolation/theories/#Ring_Hom_Poly">Polynomial_Interpolation.Ring_Hom_Poly</a>
    <a href="../../hermite_lindemann/theories/#More_Multivariate_Polynomial_HLW">Hermite_Lindemann.More_Multivariate_Polynomial_HLW</a>
    <a href="../../polynomials/theories/#MPoly_Type_Class">Polynomials.MPoly_Type_Class</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Poly_Connection-mpoly_is_unitE"><span class="command">lemma</span></span> mpoly_is_unitE<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">p</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> <span class="main">{</span>comm_semiring_1<span class="main">,</span> semiring_no_zero_divisors<span class="main">}</span> mpoly"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="keyword1">dvd</span> <span class="main">1</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">c</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">=</span> Const <span class="free">c</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="keyword1">dvd</span> <span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">r</span></span> <span class="keyword2"><span class="keyword">where</span></span> r<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">*</span> <span class="skolem">r</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> r <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">r</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">=</span> lead_monom <span class="main">(</span><span class="main">1</span> <span class="main">::</span> <span class="tfree">'a</span> mpoly<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">=</span> <span class="free">p</span> <span class="main">*</span> <span class="skolem">r</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> r <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lead_monom <span class="main">(</span><span class="free">p</span> <span class="main">*</span> <span class="skolem">r</span><span class="main">)</span> <span class="main">=</span> lead_monom <span class="free">p</span> <span class="main">+</span> lead_monom <span class="skolem">r</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> lead_monom_mult<span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lead_monom <span class="free">p</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"vars <span class="free">p</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lead_monom_eq_0_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">=</span> Const <span class="main">(</span>lead_coeff <span class="free">p</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> vars_empty_iff<span class="main">)</span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">=</span> lead_coeff <span class="main">(</span><span class="main">1</span> <span class="main">::</span> <span class="tfree">'a</span> mpoly<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">=</span> <span class="free">p</span> <span class="main">*</span> <span class="skolem">r</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> r <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lead_coeff <span class="main">(</span><span class="free">p</span> <span class="main">*</span> <span class="skolem">r</span><span class="main">)</span> <span class="main">=</span> lead_coeff <span class="free">p</span> <span class="main">*</span> lead_coeff <span class="skolem">r</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> lead_coeff_mult<span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lead_coeff <span class="free">p</span> <span class="keyword1">dvd</span> <span class="main">1</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> dvdI <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">with</span></span> * <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> that
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Poly_Connection-Const_eq_Const_iff"><span class="command">lemma</span></span> Const_eq_Const_iff <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Const <span class="free">c</span> <span class="main">=</span> Const <span class="free">c'</span> <span class="main">⟷</span> <span class="free">c</span> <span class="main">=</span> <span class="free">c'</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> lead_coeff_Const<span class="main">)</span>

<span class="keyword1" id="Poly_Connection-is_unit_ConstI"><span class="command">lemma</span></span> is_unit_ConstI <span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="keyword1">dvd</span> <span class="main">1</span> <span class="main">⟹</span> Const <span class="free">c</span> <span class="keyword1">dvd</span> <span class="main">1</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> dvd_def mpoly_Const_1 mpoly_Const_mult<span class="main">)</span>

<span class="keyword1" id="Poly_Connection-is_unit_Const_iff"><span class="command">lemma</span></span> is_unit_Const_iff<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">c</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> <span class="main">{</span>comm_semiring_1<span class="main">,</span> semiring_no_zero_divisors<span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"Const <span class="free">c</span> <span class="keyword1">dvd</span> <span class="main">1</span> <span class="main">⟷</span> <span class="free">c</span> <span class="keyword1">dvd</span> <span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"Const <span class="free">c</span> <span class="keyword1">dvd</span> <span class="main">1</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="keyword1">dvd</span> <span class="main">1</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> mpoly_is_unitE<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Poly_Connection-vars_emptyE"><span class="command">lemma</span></span> vars_emptyE<span class="main">:</span> <span class="quoted"><span class="quoted">"vars <span class="free">p</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">⟹</span> <span class="main">(</span><span class="main">⋀</span><span class="bound">c</span><span class="main">.</span> <span class="free">p</span> <span class="main">=</span> Const <span class="bound">c</span> <span class="main">⟹</span> <span class="free">P</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">P</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> vars_empty_iff<span class="main">)</span>

<span class="keyword1" id="Poly_Connection-degree_geI"><span class="command">lemma</span></span> degree_geI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"MPoly_Type.coeff <span class="free">p</span> <span class="free">m</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"MPoly_Type.degree <span class="free">p</span> <span class="free">i</span> <span class="main">≥</span> Poly_Mapping.lookup <span class="free">m</span> <span class="free">i</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lookup <span class="free">m</span> <span class="free">i</span> <span class="main">≤</span> Max <span class="main">(</span>insert <span class="main">0</span> <span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">m</span><span class="main">.</span> lookup <span class="bound">m</span> <span class="free">i</span><span class="main">)</span> <span class="main">`</span> keys <span class="main">(</span>mapping_of <span class="free">p</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> Max.coboundedI<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"lookup <span class="free">m</span> <span class="free">i</span> <span class="main">∈</span> insert <span class="main">0</span> <span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">m</span><span class="main">.</span> lookup <span class="bound">m</span> <span class="free">i</span><span class="main">)</span> <span class="main">`</span> keys <span class="main">(</span>mapping_of <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> coeff_keys<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> MPoly_Type.degree_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Poly_Connection-monom_of_degree_exists"><span class="command">lemma</span></span> monom_of_degree_exists<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">m</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"MPoly_Type.coeff <span class="free">p</span> <span class="free">m</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="quoted"><span class="quoted">"Poly_Mapping.lookup <span class="free">m</span> <span class="free">i</span> <span class="main">=</span> MPoly_Type.degree <span class="free">p</span> <span class="free">i</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"MPoly_Type.degree <span class="free">p</span> <span class="free">i</span> <span class="main">=</span> <span class="main">0</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"MPoly_Type.degree <span class="free">p</span> <span class="free">i</span> <span class="main">=</span> Max <span class="main">(</span>insert <span class="main">0</span> <span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">m</span><span class="main">.</span> lookup <span class="bound">m</span> <span class="free">i</span><span class="main">)</span> <span class="main">`</span> keys <span class="main">(</span>mapping_of <span class="free">p</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> MPoly_Type.degree_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">∈</span> insert <span class="main">0</span> <span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">m</span><span class="main">.</span> lookup <span class="bound">m</span> <span class="free">i</span><span class="main">)</span> <span class="main">`</span> keys <span class="main">(</span>mapping_of <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> Max_in<span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> False that <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> coeff_keys<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> True
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">m</span></span> <span class="keyword2"><span class="keyword">where</span></span> m<span class="main">:</span> <span class="quoted"><span class="quoted">"MPoly_Type.coeff <span class="free">p</span> <span class="skolem">m</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> coeff_all_0 <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> degree_geI<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">p</span></span> <span class="quoted"><span class="skolem">m</span></span> <span class="quoted"><span class="free">i</span></span><span class="main">]</span> m
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> that<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">m</span></span></span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Poly_Connection-degree_leI"><span class="command">lemma</span></span> degree_leI<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">m</span><span class="main">.</span> Poly_Mapping.lookup <span class="bound">m</span> <span class="free">i</span> <span class="main">&gt;</span> <span class="free">n</span> <span class="main">⟹</span> MPoly_Type.coeff <span class="free">p</span> <span class="bound">m</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"MPoly_Type.degree <span class="free">p</span> <span class="free">i</span> <span class="main">≤</span> <span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">=</span> <span class="main">0</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">m</span></span> <span class="keyword2"><span class="keyword">where</span></span> m<span class="main">:</span> <span class="quoted"><span class="quoted">"MPoly_Type.coeff <span class="free">p</span> <span class="skolem">m</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="quoted"><span class="quoted">"Poly_Mapping.lookup <span class="skolem">m</span> <span class="free">i</span> <span class="main">=</span> MPoly_Type.degree <span class="free">p</span> <span class="free">i</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> monom_of_degree_exists False <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Poly_Connection-coeff_gt_degree_eq_0"><span class="command">lemma</span></span> coeff_gt_degree_eq_0<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"Poly_Mapping.lookup <span class="free">m</span> <span class="free">i</span> <span class="main">&gt;</span> MPoly_Type.degree <span class="free">p</span> <span class="free">i</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"MPoly_Type.coeff <span class="free">p</span> <span class="free">m</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms degree_geI leD <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1" id="Poly_Connection-vars_altdef"><span class="command">lemma</span></span> vars_altdef<span class="main">:</span> <span class="quoted"><span class="quoted">"vars <span class="free">p</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">m</span><span class="main">∈</span><span class="main">{</span><span class="bound">m</span><span class="main">.</span> MPoly_Type.coeff <span class="free">p</span> <span class="bound">m</span> <span class="main">≠</span> <span class="main">0</span><span class="main">}</span><span class="main">.</span> keys <span class="bound">m</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> vars_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> arg_cong<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main"><span class="main">⋃</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span> image_cong refl<span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">flip</span><span class="main"><span class="main">:</span></span> coeff_keys<span class="main">)</span>

<span class="keyword1" id="Poly_Connection-degree_pos_iff"><span class="command">lemma</span></span> degree_pos_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"MPoly_Type.degree <span class="free">p</span> <span class="free">x</span> <span class="main">&gt;</span> <span class="main">0</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">∈</span> vars <span class="free">p</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"MPoly_Type.degree <span class="free">p</span> <span class="free">x</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">m</span></span> <span class="keyword2"><span class="keyword">where</span></span> m<span class="main">:</span> <span class="quoted"><span class="quoted">"lookup <span class="skolem">m</span> <span class="free">x</span> <span class="main">=</span> MPoly_Type.degree <span class="free">p</span> <span class="free">x</span>"</span></span> <span class="quoted"><span class="quoted">"MPoly_Type.coeff <span class="free">p</span> <span class="skolem">m</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> monom_of_degree_exists<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">p</span></span> <span class="quoted"><span class="free">x</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
  <span class="keyword1"><span class="command">from</span></span> m <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">‹MPoly_Type.degree <span class="free">p</span> <span class="free">x</span> <span class="main">&gt;</span> <span class="main">0</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> keys <span class="skolem">m</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> in_keys_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> m <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> vars <span class="free">p</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> vars_altdef<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> vars <span class="free">p</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">m</span></span> <span class="keyword2"><span class="keyword">where</span></span> m<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> keys <span class="skolem">m</span>"</span></span> <span class="quoted"><span class="quoted">"MPoly_Type.coeff <span class="free">p</span> <span class="skolem">m</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> vars_altdef<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">&lt;</span> lookup <span class="skolem">m</span> <span class="free">x</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> m <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_keys_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> m <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> MPoly_Type.degree <span class="free">p</span> <span class="free">x</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> degree_geI<span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"MPoly_Type.degree <span class="free">p</span> <span class="free">x</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span> 

<span class="keyword1" id="Poly_Connection-degree_eq_0_iff"><span class="command">lemma</span></span> degree_eq_0_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"MPoly_Type.degree <span class="free">p</span> <span class="free">x</span> <span class="main">=</span> <span class="main">0</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">∉</span> vars <span class="free">p</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> degree_pos_iff<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">p</span></span> <span class="quoted"><span class="free">x</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Poly_Connection-MPoly_Type_monom_zero"><span class="command">lemma</span></span> MPoly_Type_monom_zero<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"MPoly_Type.monom <span class="free">m</span> <span class="main">0</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> More_MPoly_Type.coeff_monom coeff_all_0<span class="main">)</span>

<span class="keyword1" id="Poly_Connection-vars_monom_keys'"><span class="command">lemma</span></span> vars_monom_keys'<span class="main">:</span> <span class="quoted"><span class="quoted">"vars <span class="main">(</span>MPoly_Type.monom <span class="free">m</span> <span class="free">c</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">c</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">{}</span> <span class="keyword1">else</span> keys <span class="free">m</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">=</span> <span class="main">0</span>"</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> vars_monom_keys<span class="main">)</span>

<span class="keyword1" id="Poly_Connection-Const_eq_0_iff"><span class="command">lemma</span></span> Const_eq_0_iff <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Const <span class="free">c</span> <span class="main">=</span> <span class="main">0</span> <span class="main">⟷</span> <span class="free">c</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> lead_coeff_Const mpoly_Const_0<span class="main">)</span>

<span class="keyword1" id="Poly_Connection-monom_remove_key"><span class="command">lemma</span></span> monom_remove_key<span class="main">:</span> <span class="quoted"><span class="quoted">"MPoly_Type.monom <span class="free">m</span> <span class="main">(</span><span class="free">a</span> <span class="main">::</span> <span class="tfree">'a</span> <span class="main">::</span> semiring_1<span class="main">)</span> <span class="main">=</span> 
  MPoly_Type.monom <span class="main">(</span>remove_key <span class="free">x</span> <span class="free">m</span><span class="main">)</span> <span class="free">a</span> <span class="main">*</span> MPoly_Type.monom <span class="main">(</span>Poly_Mapping.single <span class="free">x</span> <span class="main">(</span>lookup <span class="free">m</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span> <span class="main">1</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> MPoly_Type.mult_monom
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> arg_cong2<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted"><span class="quoted">MPoly_Type.monom</span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> remove_key_sum<span class="main">)</span>

<span class="keyword1" id="Poly_Connection-MPoly_Type_monom_0_iff"><span class="command">lemma</span></span> MPoly_Type_monom_0_iff<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"MPoly_Type.monom <span class="free">m</span> <span class="free">x</span> <span class="main">=</span> <span class="main">0</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>full_types<span class="main"><span class="main">)</span></span> MPoly_Type_monom_zero More_MPoly_Type.coeff_monom when_def<span class="main">)</span> 

<span class="keyword1" id="Poly_Connection-vars_signof"><span class="command">lemma</span></span> vars_signof<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"vars <span class="main">(</span>signof <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> signof_def<span class="main">)</span>

<span class="keyword1" id="Poly_Connection-prod_mset_Const"><span class="command">lemma</span></span> prod_mset_Const<span class="main">:</span> <span class="quoted"><span class="quoted">"prod_mset <span class="main">(</span>image_mset Const <span class="free">A</span><span class="main">)</span> <span class="main">=</span> Const <span class="main">(</span>prod_mset <span class="free">A</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">A</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mpoly_Const_mult<span class="main">)</span>

<span class="keyword1" id="Poly_Connection-Const_eq_product_iff"><span class="command">lemma</span></span> Const_eq_product_iff<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">c</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> idom"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"Const <span class="free">c</span> <span class="main">=</span> <span class="free">a</span> <span class="main">*</span> <span class="free">b</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">a'</span> <span class="bound">b'</span><span class="main">.</span> <span class="free">a</span> <span class="main">=</span> Const <span class="bound">a'</span> <span class="main">∧</span> <span class="free">b</span> <span class="main">=</span> Const <span class="bound">b'</span> <span class="main">∧</span> <span class="free">c</span> <span class="main">=</span> <span class="bound">a'</span> <span class="main">*</span> <span class="bound">b'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"Const <span class="free">c</span> <span class="main">=</span> <span class="free">a</span> <span class="main">*</span> <span class="free">b</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lead_monom <span class="main">(</span><span class="free">a</span> <span class="main">*</span> <span class="free">b</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">flip</span><span class="main"><span class="main">:</span></span> *<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"lead_monom <span class="free">a</span> <span class="main">=</span> <span class="main">0</span> <span class="main">∧</span> lead_monom <span class="free">b</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> lead_monom_mult<span class="main">)</span> <span class="main">(</span><span class="operator">use</span> assms * <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"vars <span class="free">a</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="quoted"><span class="quoted">"vars <span class="free">b</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> lead_monom_eq_0_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">a'</span></span> <span class="skolem"><span class="skolem">b'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">=</span> Const <span class="skolem">a'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">=</span> Const <span class="skolem">b'</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> vars_empty_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> * <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∃</span><span class="bound">a'</span> <span class="bound">b'</span><span class="main">.</span> <span class="free">a</span> <span class="main">=</span> Const <span class="bound">a'</span> <span class="main">∧</span> <span class="free">b</span> <span class="main">=</span> Const <span class="bound">b'</span> <span class="main">∧</span> <span class="free">c</span> <span class="main">=</span> <span class="bound">a'</span> <span class="main">*</span> <span class="bound">b'</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">flip</span><span class="main"><span class="main">:</span></span> mpoly_Const_mult<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mpoly_Const_mult<span class="main">)</span>

<span class="keyword1" id="Poly_Connection-irreducible_Const_iff"><span class="command">lemma</span></span> irreducible_Const_iff <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"irreducible <span class="main">(</span>Const <span class="main">(</span><span class="free">c</span> <span class="main">::</span> <span class="tfree">'a</span> <span class="main">::</span> idom<span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> irreducible <span class="free">c</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"irreducible <span class="main">(</span>Const <span class="free">c</span><span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"irreducible <span class="free">c</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> irreducibleI<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">=</span> <span class="skolem">a</span> <span class="main">*</span> <span class="skolem">b</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"Const <span class="free">c</span> <span class="main">=</span> Const <span class="skolem">a</span> <span class="main">*</span> Const <span class="skolem">b</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mpoly_Const_mult<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> * <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Const <span class="skolem">a</span> <span class="keyword1">dvd</span> <span class="main">1</span> <span class="main">∨</span> Const <span class="skolem">b</span> <span class="keyword1">dvd</span> <span class="main">1</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="keyword1">dvd</span> <span class="main">1</span> <span class="main">∨</span> <span class="skolem">b</span> <span class="keyword1">dvd</span> <span class="main">1</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> is_unit_Const_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">use</span> * <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="quoted">‹<span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main">:</span> irreducible_def›</span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"irreducible <span class="free">c</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> * <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"irreducible <span class="main">(</span>Const <span class="free">c</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> irreducibleI<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"Const <span class="free">c</span> <span class="main">=</span> <span class="skolem">a</span> <span class="main">*</span> <span class="skolem">b</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">a'</span></span> <span class="skolem"><span class="skolem">b'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">=</span> Const <span class="skolem">a'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">=</span> Const <span class="skolem">b'</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">=</span> <span class="skolem">a'</span> <span class="main">*</span> <span class="skolem">b'</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Const_eq_product_iff<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a'</span> <span class="keyword1">dvd</span> <span class="main">1</span> <span class="main">∨</span> <span class="skolem">b'</span> <span class="keyword1">dvd</span> <span class="main">1</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> * <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="keyword1">dvd</span> <span class="main">1</span> <span class="main">∨</span> <span class="skolem">b</span> <span class="keyword1">dvd</span> <span class="main">1</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">use</span> * <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="quoted">‹<span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main">:</span> irreducible_def is_unit_Const_iff›</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Poly_Connection-Const_dvd_Const_iff"><span class="command">lemma</span></span> Const_dvd_Const_iff <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Const <span class="free">a</span> <span class="keyword1">dvd</span> Const <span class="free">b</span> <span class="main">⟷</span> <span class="free">a</span> <span class="keyword1">dvd</span> <span class="free">b</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="keyword1">dvd</span> <span class="free">b</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">c</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">=</span> <span class="free">a</span> <span class="main">*</span> <span class="skolem">c</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"Const <span class="free">b</span> <span class="main">=</span> Const <span class="free">a</span> <span class="main">*</span> Const <span class="skolem">c</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mpoly_Const_mult<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"Const <span class="free">a</span> <span class="keyword1">dvd</span> Const <span class="free">b</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"Const <span class="free">a</span> <span class="keyword1">dvd</span> Const <span class="free">b</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p</span></span> <span class="keyword2"><span class="keyword">where</span></span> p<span class="main">:</span> <span class="quoted"><span class="quoted">"Const <span class="free">b</span> <span class="main">=</span> Const <span class="free">a</span> <span class="main">*</span> <span class="skolem">p</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"MPoly_Type.coeff <span class="main">(</span>Const <span class="free">b</span><span class="main">)</span> <span class="main">0</span> <span class="main">=</span> MPoly_Type.coeff <span class="main">(</span>Const <span class="free">a</span> <span class="main">*</span> <span class="skolem">p</span><span class="main">)</span> <span class="main">0</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> p <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> MPoly_Type.coeff <span class="main">(</span>Const <span class="free">a</span><span class="main">)</span> <span class="main">0</span> <span class="main">*</span> MPoly_Type.coeff <span class="skolem">p</span> <span class="main">0</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> mpoly_coeff_times_0 <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="keyword1">dvd</span> <span class="free">b</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mpoly_coeff_Const<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The lemmas above should be moved into the right theories. The part below is on the new 
connection between multivariate polynomials and univariate polynomials.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The imported theories only allow a conversion from one-variable mpoly's to poly and vice-versa.
  However, we require a conversion from arbitrary mpoly's into poly's with mpolys as coefficients.›</span></span>

<span class="comment1">(* converts a multi-variate polynomial into a univariate polynomial with multivariate coefficients *)</span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">mpoly_to_mpoly_poly</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">::</span> comm_ring_1 mpoly <span class="main">⇒</span> <span class="tfree">'a</span> mpoly poly"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">mpoly_to_mpoly_poly</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">m</span> <span class="main">.</span>
        Polynomial.monom <span class="main">(</span>MPoly_Type.monom <span class="main">(</span>remove_key <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="bound">m</span><span class="main">)</span> <span class="main">(</span>MPoly_Type.coeff <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="bound">m</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>lookup <span class="bound">m</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span> 

<span class="keyword1" id="Poly_Connection-mpoly_to_mpoly_poly_add"><span class="command">lemma</span></span> mpoly_to_mpoly_poly_add <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"mpoly_to_mpoly_poly <span class="free">x</span> <span class="main">(</span><span class="free">p</span> <span class="main">+</span> <span class="free">q</span><span class="main">)</span> <span class="main">=</span> mpoly_to_mpoly_poly <span class="free">x</span> <span class="free">p</span> <span class="main">+</span> mpoly_to_mpoly_poly <span class="free">x</span> <span class="free">q</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> mpoly_to_mpoly_poly_def  More_MPoly_Type.coeff_add<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>  MPoly_Type.monom_add add_monom<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> Sum_any.distrib<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Poly_Connection-mpoly_to_mpoly_poly_monom"><span class="command">lemma</span></span> mpoly_to_mpoly_poly_monom<span class="main">:</span> <span class="quoted"><span class="quoted">"mpoly_to_mpoly_poly <span class="free">x</span> <span class="main">(</span>MPoly_Type.monom <span class="free">m</span> <span class="free">a</span><span class="main">)</span> <span class="main">=</span> Polynomial.monom <span class="main">(</span>MPoly_Type.monom <span class="main">(</span>remove_key <span class="free">x</span> <span class="free">m</span><span class="main">)</span> <span class="free">a</span><span class="main">)</span> <span class="main">(</span>lookup <span class="free">m</span> <span class="free">x</span><span class="main">)</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"mpoly_to_mpoly_poly <span class="free">x</span> <span class="main">(</span>MPoly_Type.monom <span class="free">m</span> <span class="free">a</span><span class="main">)</span> <span class="main">=</span> 
    <span class="main">(</span><span class="main">∑</span> <span class="bound">m'</span><span class="main">.</span> Polynomial.monom <span class="main">(</span>MPoly_Type.monom <span class="main">(</span>remove_key <span class="free">x</span> <span class="bound">m'</span><span class="main">)</span> <span class="free">a</span><span class="main">)</span> <span class="main">(</span>lookup <span class="bound">m'</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">when</span> <span class="bound">m'</span> <span class="main">=</span> <span class="free">m</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> mpoly_to_mpoly_poly_def 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> Sum_any.cong<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> when_def More_MPoly_Type.coeff_monom<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> Polynomial.monom <span class="main">(</span>MPoly_Type.monom <span class="main">(</span>remove_key <span class="free">x</span> <span class="free">m</span><span class="main">)</span> <span class="free">a</span><span class="main">)</span> <span class="main">(</span>lookup <span class="free">m</span> <span class="free">x</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> Sum_any_when_equal <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Poly_Connection-remove_key_transfer"><span class="command">lemma</span></span> remove_key_transfer <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"rel_fun <span class="main">(=)</span> <span class="main">(</span>rel_fun <span class="main">(</span>pcr_poly_mapping <span class="main">(=)</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">(</span>pcr_poly_mapping <span class="main">(=)</span> <span class="main">(=)</span><span class="main">)</span><span class="main">)</span>
     <span class="main">(</span><span class="main">λ</span><span class="bound">k0</span> <span class="bound">f</span> <span class="bound">k</span><span class="main">.</span> <span class="bound">f</span> <span class="bound">k</span> <span class="keyword1">when</span> <span class="bound">k</span> <span class="main">≠</span> <span class="bound">k0</span><span class="main">)</span> remove_key"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> pcr_poly_mapping_def cr_poly_mapping_def OO_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rel_fun_def remove_key_lookup<span class="main">)</span>

<span class="keyword1" id="Poly_Connection-remove_key_0"><span class="command">lemma</span></span> remove_key_0 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"remove_key <span class="free">x</span> <span class="main">0</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">auto</span>

<span class="keyword1" id="Poly_Connection-remove_key_single'"><span class="command">lemma</span></span> remove_key_single' <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≠</span> <span class="free">y</span> <span class="main">⟹</span> remove_key <span class="free">x</span> <span class="main">(</span>Poly_Mapping.single <span class="free">y</span> <span class="free">n</span><span class="main">)</span> <span class="main">=</span> Poly_Mapping.single <span class="free">y</span> <span class="free">n</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> when_def fun_eq_iff<span class="main">)</span>


<span class="keyword1" id="Poly_Connection-poly_coeff_Sum_any"><span class="command">lemma</span></span> poly_coeff_Sum_any<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">≠</span> <span class="main">0</span><span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"poly.coeff <span class="main">(</span>Sum_any <span class="free">f</span><span class="main">)</span> <span class="free">n</span> <span class="main">=</span> Sum_any <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> poly.coeff <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Sum_any <span class="free">f</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound"><span class="bound">x</span></span> <span class="main">|</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">≠</span> <span class="main">0</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> Sum_any.expand_set<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"poly.coeff <span class="main">…</span> <span class="free">n</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound"><span class="bound">x</span></span> <span class="main">|</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">≠</span> <span class="main">0</span><span class="main">.</span> poly.coeff <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="free">n</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Polynomial.coeff_sum<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> Sum_any <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> poly.coeff <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="free">n</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> Sum_any.expand_superset <span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">use</span> assms <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Poly_Connection-coeff_coeff_mpoly_to_mpoly_poly"><span class="command">lemma</span></span> coeff_coeff_mpoly_to_mpoly_poly<span class="main">:</span>
  <span class="quoted"><span class="quoted">"MPoly_Type.coeff <span class="main">(</span>poly.coeff <span class="main">(</span>mpoly_to_mpoly_poly <span class="free">x</span> <span class="free">p</span><span class="main">)</span> <span class="free">n</span><span class="main">)</span> <span class="free">m</span> <span class="main">=</span>
     <span class="main">(</span>MPoly_Type.coeff <span class="free">p</span> <span class="main">(</span><span class="free">m</span> <span class="main">+</span> Poly_Mapping.single <span class="free">x</span> <span class="free">n</span><span class="main">)</span> <span class="keyword1">when</span> lookup <span class="free">m</span> <span class="free">x</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"MPoly_Type.coeff <span class="main">(</span>poly.coeff <span class="main">(</span>mpoly_to_mpoly_poly <span class="free">x</span> <span class="free">p</span><span class="main">)</span> <span class="free">n</span><span class="main">)</span> <span class="free">m</span> <span class="main">=</span>
          MPoly_Type.coeff <span class="main">(</span><span class="main">∑</span><span class="bound">a</span><span class="main">.</span> MPoly_Type.monom <span class="main">(</span>remove_key <span class="free">x</span> <span class="bound">a</span><span class="main">)</span> <span class="main">(</span>MPoly_Type.coeff <span class="free">p</span> <span class="bound">a</span><span class="main">)</span> <span class="keyword1">when</span> lookup <span class="bound">a</span> <span class="free">x</span> <span class="main">=</span> <span class="free">n</span><span class="main">)</span> <span class="free">m</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> mpoly_to_mpoly_poly_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> poly_coeff_Sum_any<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> when_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">xa</span><span class="main">.</span> MPoly_Type.coeff <span class="main">(</span>MPoly_Type.monom <span class="main">(</span>remove_key <span class="free">x</span> <span class="bound">xa</span><span class="main">)</span> <span class="main">(</span>MPoly_Type.coeff <span class="free">p</span> <span class="bound">xa</span><span class="main">)</span><span class="main">)</span> <span class="free">m</span> <span class="keyword1">when</span> lookup <span class="bound">xa</span> <span class="free">x</span> <span class="main">=</span> <span class="free">n</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> coeff_Sum_any<span class="main"><span class="keyword3">,</span></span> <span class="operator">force</span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> when_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> Sum_any.cong<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">a</span><span class="main">.</span> MPoly_Type.coeff <span class="free">p</span> <span class="bound">a</span> <span class="keyword1">when</span> lookup <span class="bound">a</span> <span class="free">x</span> <span class="main">=</span> <span class="free">n</span> <span class="main">∧</span> <span class="free">m</span> <span class="main">=</span> remove_key <span class="free">x</span> <span class="bound">a</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> Sum_any.cong<span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> More_MPoly_Type.coeff_monom when_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> lookup <span class="bound">a</span> <span class="free">x</span> <span class="main">=</span> <span class="free">n</span> <span class="main">∧</span> <span class="free">m</span> <span class="main">=</span> remove_key <span class="free">x</span> <span class="bound">a</span><span class="main">)</span> <span class="main">=</span>
             <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> lookup <span class="free">m</span> <span class="free">x</span> <span class="main">=</span> <span class="main">0</span> <span class="main">∧</span> <span class="bound">a</span> <span class="main">=</span> <span class="free">m</span> <span class="main">+</span> Poly_Mapping.single <span class="free">x</span> <span class="free">n</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> ext<span class="main"><span class="keyword3">,</span></span> <span class="operator">transfer</span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_eq_iff when_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">a</span><span class="main">.</span> MPoly_Type.coeff <span class="free">p</span> <span class="bound">a</span> <span class="keyword1">when</span> <span class="main">…</span> <span class="bound">a</span><span class="main">)</span> <span class="main">=</span>
             <span class="main">(</span><span class="main">∑</span><span class="bound">a</span><span class="main">.</span> MPoly_Type.coeff <span class="free">p</span> <span class="bound">a</span> <span class="keyword1">when</span> lookup <span class="free">m</span> <span class="free">x</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">when</span> <span class="bound">a</span> <span class="main">=</span> <span class="free">m</span> <span class="main">+</span> Poly_Mapping.single <span class="free">x</span> <span class="free">n</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> Sum_any.cong<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> when_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span>MPoly_Type.coeff <span class="free">p</span> <span class="main">(</span><span class="free">m</span> <span class="main">+</span> Poly_Mapping.single <span class="free">x</span> <span class="free">n</span><span class="main">)</span> <span class="keyword1">when</span> lookup <span class="free">m</span> <span class="free">x</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> Sum_any_when_equal<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Poly_Connection-mpoly_to_mpoly_poly_Const"><span class="command">lemma</span></span> mpoly_to_mpoly_poly_Const <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"mpoly_to_mpoly_poly <span class="free">x</span> <span class="main">(</span>Const <span class="free">c</span><span class="main">)</span> <span class="main">=</span> <span class="main">[:</span>Const <span class="free">c</span><span class="main">:]</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"mpoly_to_mpoly_poly <span class="free">x</span> <span class="main">(</span>Const <span class="free">c</span><span class="main">)</span> <span class="main">=</span>
          <span class="main">(</span><span class="main">∑</span><span class="bound">m</span><span class="main">.</span> Polynomial.monom <span class="main">(</span>MPoly_Type.monom <span class="main">(</span>remove_key <span class="free">x</span> <span class="bound">m</span><span class="main">)</span>
                  <span class="main">(</span>MPoly_Type.coeff <span class="main">(</span>Const <span class="free">c</span><span class="main">)</span> <span class="bound">m</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>lookup <span class="bound">m</span> <span class="free">x</span><span class="main">)</span> <span class="keyword1">when</span> <span class="bound">m</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> mpoly_to_mpoly_poly_def 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> Sum_any.cong<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> when_def mpoly_coeff_Const<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">[:</span>Const <span class="free">c</span><span class="main">:]</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> Sum_any_when_equal<span class="main">)</span>
       <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mpoly_coeff_Const monom_altdef <span class="quasi_keyword">simp</span> <span class="quasi_keyword">flip</span><span class="main"><span class="main">:</span></span> Const_conv_monom<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Poly_Connection-mpoly_to_mpoly_poly_Var"><span class="command">lemma</span></span> mpoly_to_mpoly_poly_Var<span class="main">:</span>
  <span class="quoted"><span class="quoted">"mpoly_to_mpoly_poly <span class="free">x</span> <span class="main">(</span>Var <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span> <span class="keyword1">then</span> <span class="main">[:</span><span class="main">0</span><span class="main">,</span> <span class="main">1</span><span class="main">:]</span> <span class="keyword1">else</span> <span class="main">[:</span>Var <span class="free">y</span><span class="main">:]</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"mpoly_to_mpoly_poly <span class="free">x</span> <span class="main">(</span>Var <span class="free">y</span><span class="main">)</span> <span class="main">=</span> 
          <span class="main">(</span><span class="main">∑</span><span class="bound">a</span><span class="main">.</span> Polynomial.monom <span class="main">(</span>MPoly_Type.monom <span class="main">(</span>remove_key <span class="free">x</span> <span class="bound">a</span><span class="main">)</span> <span class="main">1</span><span class="main">)</span> <span class="main">(</span>lookup <span class="bound">a</span> <span class="free">x</span><span class="main">)</span>
             <span class="keyword1">when</span> <span class="bound">a</span> <span class="main">=</span> Poly_Mapping.single <span class="free">y</span> <span class="main">1</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> mpoly_to_mpoly_poly_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> Sum_any.cong<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> when_def coeff_Var<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span> <span class="keyword1">then</span> <span class="main">[:</span><span class="main">0</span><span class="main">,</span> <span class="main">1</span><span class="main">:]</span> <span class="keyword1">else</span> <span class="main">[:</span>Var <span class="free">y</span><span class="main">:]</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Polynomial.monom_altdef lookup_single Var_altdef<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Poly_Connection-mpoly_to_mpoly_poly_Var_this"><span class="command">lemma</span></span> mpoly_to_mpoly_poly_Var_this <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"mpoly_to_mpoly_poly <span class="free">x</span> <span class="main">(</span>Var <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">[:</span><span class="main">0</span><span class="main">,</span> <span class="main">1</span><span class="main">:]</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≠</span> <span class="free">y</span> <span class="main">⟹</span> mpoly_to_mpoly_poly <span class="free">x</span> <span class="main">(</span>Var <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">[:</span>Var <span class="free">y</span><span class="main">:]</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mpoly_to_mpoly_poly_Var<span class="main">)</span>

<span class="keyword1" id="Poly_Connection-mpoly_to_mpoly_poly_uminus"><span class="command">lemma</span></span> mpoly_to_mpoly_poly_uminus <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"mpoly_to_mpoly_poly <span class="free">x</span> <span class="main">(</span><span class="main">-</span><span class="free">p</span><span class="main">)</span> <span class="main">=</span> <span class="main">-</span>mpoly_to_mpoly_poly <span class="free">x</span> <span class="free">p</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> mpoly_to_mpoly_poly_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> monom_uminus Sum_any_uminus <span class="quasi_keyword">simp</span> <span class="quasi_keyword">flip</span><span class="main"><span class="main">:</span></span> minus_monom<span class="main">)</span>

<span class="keyword1" id="Poly_Connection-mpoly_to_mpoly_poly_diff"><span class="command">lemma</span></span> mpoly_to_mpoly_poly_diff <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"mpoly_to_mpoly_poly <span class="free">x</span> <span class="main">(</span><span class="free">p</span> <span class="main">-</span> <span class="free">q</span><span class="main">)</span> <span class="main">=</span> mpoly_to_mpoly_poly <span class="free">x</span> <span class="free">p</span> <span class="main">-</span> mpoly_to_mpoly_poly <span class="free">x</span> <span class="free">q</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> diff_conv_add_uminus<span class="main"><span class="keyword3">,</span></span> <span class="operator">subst</span> mpoly_to_mpoly_poly_add<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Poly_Connection-mpoly_to_mpoly_poly_0"><span class="command">lemma</span></span> mpoly_to_mpoly_poly_0 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"mpoly_to_mpoly_poly <span class="free">x</span> <span class="main">0</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> mpoly_Const_0 <span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> mpoly_to_mpoly_poly_Const <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Poly_Connection-mpoly_to_mpoly_poly_1"><span class="command">lemma</span></span> mpoly_to_mpoly_poly_1 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"mpoly_to_mpoly_poly <span class="free">x</span> <span class="main">1</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> mpoly_Const_1 <span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> mpoly_to_mpoly_poly_Const <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Poly_Connection-mpoly_to_mpoly_poly_of_nat"><span class="command">lemma</span></span> mpoly_to_mpoly_poly_of_nat <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"mpoly_to_mpoly_poly <span class="free">x</span> <span class="main">(</span>of_nat <span class="free">n</span><span class="main">)</span> <span class="main">=</span> of_nat <span class="free">n</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> of_nat_mpoly_eq mpoly_to_mpoly_poly_Const of_nat_poly <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1" id="Poly_Connection-mpoly_to_mpoly_poly_of_int"><span class="command">lemma</span></span> mpoly_to_mpoly_poly_of_int <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"mpoly_to_mpoly_poly <span class="free">x</span> <span class="main">(</span>of_int <span class="free">n</span><span class="main">)</span> <span class="main">=</span> of_int <span class="free">n</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> of_nat_mpoly_eq mpoly_to_mpoly_poly_Const of_nat_poly <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Poly_Connection-mpoly_to_mpoly_poly_numeral"><span class="command">lemma</span></span> mpoly_to_mpoly_poly_numeral <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"mpoly_to_mpoly_poly <span class="free">x</span> <span class="main">(</span>numeral <span class="free">n</span><span class="main">)</span> <span class="main">=</span> numeral <span class="free">n</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> mpoly_to_mpoly_poly_of_nat<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="quoted">"numeral <span class="free">n</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> mpoly_to_mpoly_poly_of_nat<span class="main">)</span>

<span class="keyword1" id="Poly_Connection-coeff_monom_mult'"><span class="command">lemma</span></span> coeff_monom_mult'<span class="main">:</span>
  <span class="quoted"><span class="quoted">"MPoly_Type.coeff <span class="main">(</span>MPoly_Type.monom <span class="free">m</span> <span class="free">a</span> <span class="main">*</span> <span class="free">q</span><span class="main">)</span> <span class="free">m'</span> <span class="main">=</span>
   <span class="main">(</span><span class="free">a</span> <span class="main">*</span> MPoly_Type.coeff <span class="free">q</span> <span class="main">(</span><span class="free">m'</span> <span class="main">-</span> <span class="free">m</span><span class="main">)</span> <span class="keyword1">when</span> lookup <span class="free">m'</span> <span class="main">≥</span> lookup <span class="free">m</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"lookup <span class="free">m'</span> <span class="main">≥</span> lookup <span class="free">m</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">*</span> MPoly_Type.coeff <span class="free">q</span> <span class="main">(</span><span class="free">m'</span> <span class="main">-</span> <span class="free">m</span><span class="main">)</span> <span class="main">=</span> MPoly_Type.coeff <span class="main">(</span>MPoly_Type.monom <span class="free">m</span> <span class="free">a</span> <span class="main">*</span> <span class="free">q</span><span class="main">)</span> <span class="main">(</span><span class="free">m</span> <span class="main">+</span> <span class="main">(</span><span class="free">m'</span> <span class="main">-</span> <span class="free">m</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> More_MPoly_Type.coeff_monom_mult <span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">+</span> <span class="main">(</span><span class="free">m'</span> <span class="main">-</span> <span class="free">m</span><span class="main">)</span> <span class="main">=</span> <span class="free">m'</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> True <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> le_fun_def<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
    <span class="keyword1"><span class="command">using</span></span> True <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> when_def<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"MPoly_Type.coeff <span class="main">(</span>MPoly_Type.monom <span class="free">m</span> <span class="free">a</span> <span class="main">*</span> <span class="free">q</span><span class="main">)</span> <span class="free">m'</span> <span class="main">=</span>
          <span class="main">(</span><span class="main">∑</span><span class="bound">m1</span><span class="main">.</span> <span class="free">a</span> <span class="main">*</span> <span class="main">(</span><span class="main">∑</span><span class="bound">m2</span><span class="main">.</span> MPoly_Type.coeff <span class="free">q</span> <span class="bound">m2</span> <span class="keyword1">when</span> <span class="free">m'</span> <span class="main">=</span> <span class="bound">m1</span> <span class="main">+</span> <span class="bound">m2</span><span class="main">)</span> <span class="keyword1">when</span> <span class="bound">m1</span> <span class="main">=</span> <span class="free">m</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> coeff_mpoly_times prod_fun_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> Sum_any.cong<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> More_MPoly_Type.coeff_monom when_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="free">a</span> <span class="main">*</span> <span class="main">(</span><span class="main">∑</span><span class="bound">m2</span><span class="main">.</span> MPoly_Type.coeff <span class="free">q</span> <span class="bound">m2</span> <span class="keyword1">when</span> <span class="free">m'</span> <span class="main">=</span> <span class="free">m</span> <span class="main">+</span> <span class="bound">m2</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> Sum_any_when_equal<span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">m2</span><span class="main">.</span> <span class="free">m'</span> <span class="main">=</span> <span class="free">m</span> <span class="main">+</span> <span class="bound">m2</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">m2</span><span class="main">.</span> False<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> ext<span class="main">)</span> <span class="main">(</span><span class="operator">use</span> False <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="quoted">‹<span class="operator">transfer</span><span class="keyword3">,</span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main">:</span> le_fun_def›</span><span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> False <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Poly_Connection-mpoly_to_mpoly_poly_mult_monom"><span class="command">lemma</span></span> mpoly_to_mpoly_poly_mult_monom<span class="main">:</span>
  <span class="quoted"><span class="quoted">"mpoly_to_mpoly_poly <span class="free">x</span> <span class="main">(</span>MPoly_Type.monom <span class="free">m</span> <span class="free">a</span> <span class="main">*</span> <span class="free">q</span><span class="main">)</span> <span class="main">=</span>
     Polynomial.monom <span class="main">(</span>MPoly_Type.monom <span class="main">(</span>remove_key <span class="free">x</span> <span class="free">m</span><span class="main">)</span> <span class="free">a</span><span class="main">)</span> <span class="main">(</span>lookup <span class="free">m</span> <span class="free">x</span><span class="main">)</span> <span class="main">*</span> mpoly_to_mpoly_poly <span class="free">x</span> <span class="free">q</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> poly_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> mpoly_eqI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">n</span> <span class="main">::</span> <span class="quoted">nat</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">mon</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒<span class="hidden">⇩</span><sub>0</sub></span> nat"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"MPoly_Type.coeff <span class="main">(</span>poly.coeff <span class="var">?lhs</span> <span class="skolem">n</span><span class="main">)</span> <span class="skolem">mon</span> <span class="main">=</span>
          <span class="main">(</span><span class="free">a</span> <span class="main">*</span> MPoly_Type.coeff <span class="free">q</span> <span class="main">(</span><span class="skolem">mon</span> <span class="main">+</span> Poly_Mapping.single <span class="free">x</span> <span class="skolem">n</span> <span class="main">-</span> <span class="free">m</span><span class="main">)</span>
          <span class="keyword1">when</span> lookup <span class="free">m</span> <span class="main">≤</span> lookup <span class="main">(</span><span class="skolem">mon</span> <span class="main">+</span> Poly_Mapping.single <span class="free">x</span> <span class="skolem">n</span><span class="main">)</span> <span class="main">∧</span> lookup <span class="skolem">mon</span> <span class="free">x</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> coeff_coeff_mpoly_to_mpoly_poly coeff_monom_mult' when_def<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"MPoly_Type.coeff <span class="main">(</span>poly.coeff <span class="var">?rhs</span> <span class="skolem">n</span><span class="main">)</span> <span class="skolem">mon</span> <span class="main">=</span>
          <span class="main">(</span><span class="free">a</span> <span class="main">*</span> MPoly_Type.coeff <span class="free">q</span> <span class="main">(</span><span class="skolem">mon</span> <span class="main">-</span> remove_key <span class="free">x</span> <span class="free">m</span> <span class="main">+</span> Poly_Mapping.single <span class="free">x</span> <span class="main">(</span><span class="skolem">n</span> <span class="main">-</span> lookup <span class="free">m</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span>
          <span class="keyword1">when</span> lookup <span class="main">(</span>remove_key <span class="free">x</span> <span class="free">m</span><span class="main">)</span> <span class="main">≤</span> lookup <span class="skolem">mon</span> <span class="main">∧</span> lookup <span class="free">m</span> <span class="free">x</span> <span class="main">≤</span> <span class="skolem">n</span> <span class="main">∧</span> lookup <span class="skolem">mon</span> <span class="free">x</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> coeff_coeff_mpoly_to_mpoly_poly coeff_monom_mult' lookup_minus_fun
                  remove_key_lookup Missing_Polynomial.coeff_monom_mult when_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lookup <span class="main">(</span>remove_key <span class="free">x</span> <span class="free">m</span><span class="main">)</span> <span class="main">≤</span> lookup <span class="skolem">mon</span> <span class="main">∧</span> lookup <span class="free">m</span> <span class="free">x</span> <span class="main">≤</span> <span class="skolem">n</span> <span class="main">∧</span> lookup <span class="skolem">mon</span> <span class="free">x</span> <span class="main">=</span> <span class="main">0</span> <span class="main">⟷</span>
             lookup <span class="free">m</span> <span class="main">≤</span> lookup <span class="main">(</span><span class="skolem">mon</span> <span class="main">+</span> Poly_Mapping.single <span class="free">x</span> <span class="skolem">n</span><span class="main">)</span> <span class="main">∧</span> lookup <span class="skolem">mon</span> <span class="free">x</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">=</span> <span class="var">?P</span>"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> when_def le_fun_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">mon</span> <span class="main">-</span> remove_key <span class="free">x</span> <span class="free">m</span> <span class="main">+</span> Poly_Mapping.single <span class="free">x</span> <span class="main">(</span><span class="skolem">n</span> <span class="main">-</span> lookup <span class="free">m</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">mon</span> <span class="main">+</span> Poly_Mapping.single <span class="free">x</span> <span class="skolem">n</span> <span class="main">-</span> <span class="free">m</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="var"><span class="quoted"><span class="var">?P</span></span></span>
    <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_eq_iff when_def<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">a</span> <span class="main">*</span> MPoly_Type.coeff <span class="free">q</span> <span class="main">(</span><span class="skolem">mon</span> <span class="main">-</span> remove_key <span class="free">x</span> <span class="free">m</span> <span class="main">+</span> Poly_Mapping.single <span class="free">x</span> <span class="main">(</span><span class="skolem">n</span> <span class="main">-</span> lookup <span class="free">m</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">when</span> <span class="var">?P</span><span class="main">)</span> <span class="main">=</span>
         <span class="main">(</span><span class="free">a</span> <span class="main">*</span> MPoly_Type.coeff <span class="free">q</span> <span class="main">…</span> <span class="keyword1">when</span> <span class="var">?P</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> when_cong<span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> MPoly_Type.coeff <span class="main">(</span>poly.coeff <span class="var">?lhs</span> <span class="skolem">n</span><span class="main">)</span> <span class="skolem">mon</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> coeff_coeff_mpoly_to_mpoly_poly coeff_monom_mult' when_def<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"MPoly_Type.coeff <span class="main">(</span>poly.coeff <span class="var">?lhs</span> <span class="skolem">n</span><span class="main">)</span> <span class="skolem">mon</span> <span class="main">=</span> MPoly_Type.coeff <span class="main">(</span>poly.coeff <span class="var">?rhs</span> <span class="skolem">n</span><span class="main">)</span> <span class="skolem">mon</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Poly_Connection-mpoly_to_mpoly_poly_mult"><span class="command">lemma</span></span> mpoly_to_mpoly_poly_mult <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"mpoly_to_mpoly_poly <span class="free">x</span> <span class="main">(</span><span class="free">p</span> <span class="main">*</span> <span class="free">q</span><span class="main">)</span> <span class="main">=</span> mpoly_to_mpoly_poly <span class="free">x</span> <span class="free">p</span> <span class="main">*</span> mpoly_to_mpoly_poly <span class="free">x</span> <span class="free">q</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">q</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> mpoly_induct<span class="main">)</span>
     <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mpoly_to_mpoly_poly_monom mpoly_to_mpoly_poly_mult_monom ring_distribs<span class="main">)</span>

<span class="keyword1" id="Poly_Connection-coeff_mpoly_to_mpoly_poly"><span class="command">lemma</span></span> coeff_mpoly_to_mpoly_poly<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Polynomial.coeff <span class="main">(</span>mpoly_to_mpoly_poly <span class="free">x</span> <span class="free">p</span><span class="main">)</span> <span class="free">n</span> <span class="main">=</span>
     Sum_any <span class="main">(</span><span class="main">λ</span><span class="bound">m</span><span class="main">.</span> MPoly_Type.monom <span class="main">(</span>remove_key <span class="free">x</span> <span class="bound">m</span><span class="main">)</span> <span class="main">(</span>MPoly_Type.coeff <span class="free">p</span> <span class="bound">m</span><span class="main">)</span> <span class="keyword1">when</span> Poly_Mapping.lookup <span class="bound">m</span> <span class="free">x</span> <span class="main">=</span> <span class="free">n</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> mpoly_to_mpoly_poly_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> poly_coeff_Sum_any<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> when_def<span class="main">)</span>

<span class="keyword1" id="Poly_Connection-mpoly_coeff_to_mpoly_poly_coeff"><span class="command">lemma</span></span> mpoly_coeff_to_mpoly_poly_coeff<span class="main">:</span>
  <span class="quoted"><span class="quoted">"MPoly_Type.coeff <span class="free">p</span> <span class="free">m</span> <span class="main">=</span> MPoly_Type.coeff <span class="main">(</span>poly.coeff <span class="main">(</span>mpoly_to_mpoly_poly <span class="free">x</span> <span class="free">p</span><span class="main">)</span> <span class="main">(</span>lookup <span class="free">m</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>remove_key <span class="free">x</span> <span class="free">m</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"MPoly_Type.coeff <span class="main">(</span>poly.coeff <span class="main">(</span>mpoly_to_mpoly_poly <span class="free">x</span> <span class="free">p</span><span class="main">)</span> <span class="main">(</span>lookup <span class="free">m</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>remove_key <span class="free">x</span> <span class="free">m</span><span class="main">)</span> <span class="main">=</span>
        <span class="main">(</span><span class="main">∑</span><span class="bound">xa</span><span class="main">.</span> MPoly_Type.coeff <span class="main">(</span>MPoly_Type.monom <span class="main">(</span>remove_key <span class="free">x</span> <span class="bound">xa</span><span class="main">)</span> <span class="main">(</span>MPoly_Type.coeff <span class="free">p</span> <span class="bound">xa</span><span class="main">)</span> <span class="keyword1">when</span>
             lookup <span class="bound">xa</span> <span class="free">x</span> <span class="main">=</span> lookup <span class="free">m</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span>remove_key <span class="free">x</span> <span class="free">m</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> coeff_mpoly_to_mpoly_poly<span class="main"><span class="keyword3">,</span></span> <span class="operator">subst</span> coeff_Sum_any<span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">xa</span><span class="main">.</span> MPoly_Type.coeff <span class="main">(</span>MPoly_Type.monom <span class="main">(</span>remove_key <span class="free">x</span> <span class="bound">xa</span><span class="main">)</span> <span class="main">(</span>MPoly_Type.coeff <span class="free">p</span> <span class="bound">xa</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>remove_key <span class="free">x</span> <span class="free">m</span><span class="main">)</span>
                    <span class="keyword1">when</span> lookup <span class="bound">xa</span> <span class="free">x</span> <span class="main">=</span> lookup <span class="free">m</span> <span class="free">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> Sum_any.cong<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> when_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">xa</span><span class="main">.</span> MPoly_Type.coeff <span class="free">p</span> <span class="bound">xa</span> <span class="keyword1">when</span> remove_key <span class="free">x</span> <span class="free">m</span> <span class="main">=</span> remove_key <span class="free">x</span> <span class="bound">xa</span> <span class="main">∧</span> lookup <span class="bound">xa</span> <span class="free">x</span> <span class="main">=</span> lookup <span class="free">m</span> <span class="free">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> Sum_any.cong<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> More_MPoly_Type.coeff_monom when_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">xa</span><span class="main">.</span> remove_key <span class="free">x</span> <span class="free">m</span> <span class="main">=</span> remove_key <span class="free">x</span> <span class="bound">xa</span> <span class="main">∧</span> lookup <span class="bound">xa</span> <span class="free">x</span> <span class="main">=</span> lookup <span class="free">m</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">xa</span><span class="main">.</span> <span class="bound">xa</span> <span class="main">=</span> <span class="free">m</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> remove_key_sum <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">xa</span><span class="main">.</span> MPoly_Type.coeff <span class="free">p</span> <span class="bound">xa</span> <span class="keyword1">when</span> <span class="bound">xa</span> <span class="main">=</span> <span class="free">m</span><span class="main">)</span> <span class="main">=</span> MPoly_Type.coeff <span class="free">p</span> <span class="free">m</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Poly_Connection-degree_mpoly_to_mpoly_poly"><span class="command">lemma</span></span> degree_mpoly_to_mpoly_poly <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Polynomial.degree <span class="main">(</span>mpoly_to_mpoly_poly <span class="free">x</span> <span class="free">p</span><span class="main">)</span> <span class="main">=</span> MPoly_Type.degree <span class="free">p</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> antisym<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Polynomial.degree <span class="main">(</span>mpoly_to_mpoly_poly <span class="free">x</span> <span class="free">p</span><span class="main">)</span> <span class="main">≤</span> MPoly_Type.degree <span class="free">p</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> Polynomial.degree_le allI impI<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span> <span class="keyword3"><span class="command">assume</span></span> i<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&gt;</span> MPoly_Type.degree <span class="free">p</span> <span class="free">x</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"poly.coeff <span class="main">(</span>mpoly_to_mpoly_poly <span class="free">x</span> <span class="free">p</span><span class="main">)</span> <span class="skolem">i</span> <span class="main">=</span>
            <span class="main">(</span><span class="main">∑</span><span class="bound">m</span><span class="main">.</span> <span class="main">0</span> <span class="keyword1">when</span> lookup <span class="bound">m</span> <span class="free">x</span> <span class="main">=</span> <span class="skolem">i</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> coeff_mpoly_to_mpoly_poly <span class="keyword1"><span class="command">using</span></span> i
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> Sum_any.cong when_cong refl<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> coeff_gt_degree_eq_0<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"poly.coeff <span class="main">(</span>mpoly_to_mpoly_poly <span class="free">x</span> <span class="free">p</span><span class="main">)</span> <span class="skolem">i</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Polynomial.degree <span class="main">(</span>mpoly_to_mpoly_poly <span class="free">x</span> <span class="free">p</span><span class="main">)</span> <span class="main">≥</span> MPoly_Type.degree <span class="free">p</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">=</span> <span class="main">0</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">m</span></span> <span class="keyword2"><span class="keyword">where</span></span> m<span class="main">:</span> <span class="quoted"><span class="quoted">"MPoly_Type.coeff <span class="free">p</span> <span class="skolem">m</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="quoted"><span class="quoted">"lookup <span class="skolem">m</span> <span class="free">x</span> <span class="main">=</span> MPoly_Type.degree <span class="free">p</span> <span class="free">x</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> monom_of_degree_exists <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Polynomial.degree <span class="main">(</span>mpoly_to_mpoly_poly <span class="free">x</span> <span class="free">p</span><span class="main">)</span> <span class="main">≥</span> MPoly_Type.degree <span class="free">p</span> <span class="free">x</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> Polynomial.le_degree<span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">≠</span> MPoly_Type.coeff <span class="free">p</span> <span class="skolem">m</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> m <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"MPoly_Type.coeff <span class="free">p</span> <span class="skolem">m</span> <span class="main">=</span> MPoly_Type.coeff <span class="main">(</span>poly.coeff <span class="main">(</span>mpoly_to_mpoly_poly <span class="free">x</span> <span class="free">p</span><span class="main">)</span> <span class="main">(</span>lookup <span class="skolem">m</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>remove_key <span class="free">x</span> <span class="skolem">m</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> mpoly_coeff_to_mpoly_poly_coeff<span class="main">)</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"poly.coeff <span class="main">(</span>mpoly_to_mpoly_poly <span class="free">x</span> <span class="free">p</span><span class="main">)</span> <span class="main">(</span>MPoly_Type.degree <span class="free">p</span> <span class="free">x</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> m <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The upcoming lemma is similar to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> reduce_nested_mpoly_extract_var<span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>
<span class="keyword1" id="Poly_Connection-poly_mpoly_to_mpoly_poly"><span class="command">lemma</span></span> poly_mpoly_to_mpoly_poly<span class="main">:</span>
  <span class="quoted"><span class="quoted">"poly <span class="main">(</span>mpoly_to_mpoly_poly <span class="free">x</span> <span class="free">p</span><span class="main">)</span> <span class="main">(</span>Var <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">p</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> mpoly_induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>monom <span class="skolem">m</span> <span class="skolem">a</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> mpoly_to_mpoly_poly_monom poly_monom
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Var<span class="hidden">⇩</span><sub>0</sub>_power mult_single remove_key_sum<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>sum <span class="skolem">p1</span> <span class="skolem">p2</span> <span class="skolem">m</span> <span class="skolem">a</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mpoly_to_mpoly_poly_add<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Poly_Connection-mpoly_to_mpoly_poly_eq_iff"><span class="command">lemma</span></span> mpoly_to_mpoly_poly_eq_iff <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"mpoly_to_mpoly_poly <span class="free">x</span> <span class="free">p</span> <span class="main">=</span> mpoly_to_mpoly_poly <span class="free">x</span> <span class="free">q</span> <span class="main">⟷</span> <span class="free">p</span> <span class="main">=</span> <span class="free">q</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"mpoly_to_mpoly_poly <span class="free">x</span> <span class="free">p</span> <span class="main">=</span> mpoly_to_mpoly_poly <span class="free">x</span> <span class="free">q</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"poly <span class="main">(</span>mpoly_to_mpoly_poly <span class="free">x</span> <span class="free">p</span><span class="main">)</span> <span class="main">(</span>Var <span class="free">x</span><span class="main">)</span> <span class="main">=</span>
         poly <span class="main">(</span>mpoly_to_mpoly_poly <span class="free">x</span> <span class="free">q</span><span class="main">)</span> <span class="main">(</span>Var <span class="free">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">=</span> <span class="free">q</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> poly_mpoly_to_mpoly_poly<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Evaluation, i.e., insertion of concrete values is identical›</span></span>
<span class="keyword1" id="Poly_Connection-insertion_mpoly_to_mpoly_poly"><span class="command">lemma</span></span> insertion_mpoly_to_mpoly_poly<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">≠</span> <span class="free">x</span> <span class="main">⟹</span> <span class="free">β</span> <span class="bound">y</span> <span class="main">=</span> <span class="free">α</span> <span class="bound">y</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"poly <span class="main">(</span>map_poly <span class="main">(</span>insertion <span class="free">β</span><span class="main">)</span> <span class="main">(</span>mpoly_to_mpoly_poly <span class="free">x</span> <span class="free">p</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free">α</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> insertion <span class="free">α</span> <span class="free">p</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> mpoly_induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>monom <span class="skolem">m</span> <span class="skolem">a</span><span class="main">)</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?rkm</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"remove_key <span class="free">x</span> <span class="skolem">m</span>"</span></span> 
  <span class="keyword1"><span class="command">have</span></span> to_alpha<span class="main">:</span> <span class="quoted"><span class="quoted">"insertion <span class="free">β</span> <span class="main">(</span>MPoly_Type.monom <span class="var">?rkm</span> <span class="skolem">a</span><span class="main">)</span> <span class="main">=</span> insertion <span class="free">α</span> <span class="main">(</span>MPoly_Type.monom <span class="var">?rkm</span> <span class="skolem">a</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> insertion_irrelevant_vars<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> assms<span class="main"><span class="keyword3">,</span></span> <span class="operator">insert</span> vars_monom_subset<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="var"><span class="quoted"><span class="var"><span class="quoted"><span class="var"><span class="quoted"><span class="var">?rkm</span></span></span></span></span></span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">a</span></span></span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> remove_key_keys<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> main<span class="main">:</span> <span class="quoted"><span class="quoted">"insertion <span class="free">α</span> <span class="main">(</span>MPoly_Type.monom <span class="var">?rkm</span> <span class="skolem">a</span><span class="main">)</span> <span class="main">*</span> <span class="free">α</span> <span class="free">x</span> <span class="main">^</span> lookup <span class="skolem">m</span> <span class="free">x</span> <span class="main">=</span> insertion <span class="free">α</span> <span class="main">(</span>MPoly_Type.monom <span class="skolem">m</span> <span class="skolem">a</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> monom_remove_key<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">m</span></span> <span class="quoted"><span class="skolem">a</span></span> <span class="quoted"><span class="free">x</span></span><span class="main">]</span> insertion_mult
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> insertion_single mult.left_neutral<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> main to_alpha
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mpoly_to_mpoly_poly_monom map_poly_monom poly_monom<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>sum <span class="skolem">p1</span> <span class="skolem">p2</span> <span class="skolem">m</span> <span class="skolem">a</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mpoly_to_mpoly_poly_add insertion_add map_poly_add<span class="main">)</span> 
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Poly_Connection-mpoly_to_mpoly_poly_dvd_iff"><span class="command">lemma</span></span> mpoly_to_mpoly_poly_dvd_iff <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"mpoly_to_mpoly_poly <span class="free">x</span> <span class="free">p</span> <span class="keyword1">dvd</span> mpoly_to_mpoly_poly <span class="free">x</span> <span class="free">q</span> <span class="main">⟷</span> <span class="free">p</span> <span class="keyword1">dvd</span> <span class="free">q</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"mpoly_to_mpoly_poly <span class="free">x</span> <span class="free">p</span> <span class="keyword1">dvd</span> mpoly_to_mpoly_poly <span class="free">x</span> <span class="free">q</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"poly <span class="main">(</span>mpoly_to_mpoly_poly <span class="free">x</span> <span class="free">p</span><span class="main">)</span> <span class="main">(</span>Var <span class="free">x</span><span class="main">)</span> <span class="keyword1">dvd</span> poly <span class="main">(</span>mpoly_to_mpoly_poly <span class="free">x</span> <span class="free">q</span><span class="main">)</span> <span class="main">(</span>Var <span class="free">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> poly_hom.hom_dvd<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="keyword1">dvd</span> <span class="free">q</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> poly_mpoly_to_mpoly_poly<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Poly_Connection-vars_coeff_mpoly_to_mpoly_poly"><span class="command">lemma</span></span> vars_coeff_mpoly_to_mpoly_poly<span class="main">:</span> <span class="quoted"><span class="quoted">"vars <span class="main">(</span>poly.coeff <span class="main">(</span>mpoly_to_mpoly_poly <span class="free">x</span> <span class="free">p</span><span class="main">)</span> <span class="free">i</span><span class="main">)</span> <span class="main">⊆</span> vars <span class="free">p</span> <span class="main">-</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> mpoly_to_mpoly_poly_def Sum_any.expand_set Polynomial.coeff_sum More_MPoly_Type.coeff_monom
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order.trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> vars_setsum<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">force</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> UN_least<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> impI order.trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> vars_monom_subset<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> remove_key_keys<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> Diff_mono SUP_upper2 coeff_keys vars_def<span class="main">)</span>


<span class="keyword1"><span class="command">locale</span></span> transfer_mpoly_to_mpoly_poly <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span> <span class="main">::</span> <span class="quoted">nat</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">R</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> comm_ring_1 mpoly poly <span class="main">⇒</span> <span class="tfree">'a</span> mpoly <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">R</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">p'</span></span></span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> mpoly_to_mpoly_poly <span class="free">x</span> <span class="free"><span class="bound"><span class="entity">p'</span></span></span>"</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Poly_Connection-transfer_0"><span class="command">lemma</span></span> transfer_0 <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"R <span class="main">0</span> <span class="main">0</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> transfer_1 <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"R <span class="main">1</span> <span class="main">1</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> transfer_Const <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"R <span class="main">[:</span>Const <span class="free">c</span><span class="main">:]</span> <span class="main">(</span>Const <span class="free">c</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> transfer_uminus <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>R <span class="main">===&gt;</span> R<span class="main">)</span> uminus uminus"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> transfer_of_nat <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> R<span class="main">)</span> of_nat of_nat"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> transfer_of_int <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> R<span class="main">)</span> of_nat of_nat"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> transfer_numeral <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> R<span class="main">)</span> of_nat of_nat"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> transfer_add <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>R <span class="main">===&gt;</span> R <span class="main">===&gt;</span> R<span class="main">)</span> <span class="main">(+)</span> <span class="main">(+)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> transfer_diff <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>R <span class="main">===&gt;</span> R <span class="main">===&gt;</span> R<span class="main">)</span> <span class="main">(+)</span> <span class="main">(+)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> transfer_mult <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>R <span class="main">===&gt;</span> R <span class="main">===&gt;</span> R<span class="main">)</span> <span class="main">(*)</span> <span class="main">(*)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> transfer_dvd <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>R <span class="main">===&gt;</span> R <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="keyword1">(dvd)</span> <span class="keyword1">(dvd)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> transfer_monom <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
        <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> R<span class="main">)</span>
          <span class="main">(</span><span class="main">λ</span><span class="bound">m</span> <span class="bound">a</span><span class="main">.</span> Polynomial.monom <span class="main">(</span>MPoly_Type.monom <span class="main">(</span>remove_key <span class="free">x</span> <span class="bound">m</span><span class="main">)</span> <span class="bound">a</span><span class="main">)</span> <span class="main">(</span>lookup <span class="bound">m</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span>
          MPoly_Type.monom"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> transfer_coeff <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
        <span class="quoted"><span class="quoted">"<span class="main">(</span>R <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span>
           <span class="main">(</span><span class="main">λ</span><span class="bound">p</span> <span class="bound">m</span><span class="main">.</span> MPoly_Type.coeff <span class="main">(</span>poly.coeff <span class="bound">p</span> <span class="main">(</span>lookup <span class="bound">m</span> <span class="free">x</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>remove_key <span class="free">x</span> <span class="bound">m</span><span class="main">)</span><span class="main">)</span>
           MPoly_Type.coeff"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> transfer_degree <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
        <span class="quoted"><span class="quoted">"<span class="main">(</span>R <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> Polynomial.degree <span class="main">(</span><span class="main">λ</span><span class="bound">p</span><span class="main">.</span> MPoly_Type.degree <span class="bound">p</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> R_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rel_fun_def mpoly_to_mpoly_poly_monom 
           <span class="quasi_keyword">simp</span> <span class="quasi_keyword">flip</span><span class="main"><span class="main">:</span></span> mpoly_coeff_to_mpoly_poly_coeff<span class="main">)</span>


<span class="keyword1" id="Poly_Connection-transfer_vars"><span class="command">lemma</span></span> transfer_vars <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"R <span class="free">p</span> <span class="free">p'</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋃</span><span class="bound">i</span><span class="main">.</span> vars <span class="main">(</span>poly.coeff <span class="free">p</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span><span class="keyword1">if</span> Polynomial.degree <span class="free">p</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">{}</span> <span class="keyword1">else</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> vars <span class="free">p'</span>"</span></span>
    <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?A</span> <span class="main">∪</span> <span class="var">?B</span> <span class="main">=</span> <span class="main">_</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> equalityI<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"vars <span class="free">p'</span> <span class="main">=</span> vars <span class="main">(</span>poly <span class="free">p</span> <span class="main">(</span>Var <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> R_def poly_mpoly_to_mpoly_poly<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"poly <span class="free">p</span> <span class="main">(</span>Var <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">i</span><span class="main">≤</span>Polynomial.degree <span class="free">p</span><span class="main">.</span> poly.coeff <span class="free">p</span> <span class="bound">i</span> <span class="main">*</span> Var <span class="free">x</span> <span class="main">^</span> <span class="bound">i</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> poly_altdef <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"vars <span class="main">…</span> <span class="main">⊆</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">i</span><span class="main">.</span> vars <span class="main">(</span>poly.coeff <span class="free">p</span> <span class="bound">i</span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span><span class="keyword1">if</span> Polynomial.degree <span class="free">p</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">{}</span> <span class="keyword1">else</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> order.trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> vars_sum<span class="main"><span class="main">]</span></span> UN_mono order.trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> vars_mult<span class="main"><span class="main">]</span></span> Un_mono<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span> <span class="main">::</span> <span class="quoted">nat</span>
    <span class="keyword3"><span class="command">assume</span></span> i<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">∈</span> <span class="main">{..</span>Polynomial.degree <span class="free">p</span><span class="main">}</span>"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"vars <span class="main">(</span>Var <span class="free">x</span> <span class="main">^</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">(</span><span class="keyword1">if</span> Polynomial.degree <span class="free">p</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">{}</span> <span class="keyword1">else</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"Polynomial.degree <span class="free">p</span> <span class="main">=</span> <span class="main">0</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> False
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> order.trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> vars_power<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> vars_Var<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">use</span> i <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"vars <span class="free">p'</span> <span class="main">⊆</span> <span class="var">?A</span> <span class="main">∪</span> <span class="var">?B</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?A</span> <span class="main">⊆</span> vars <span class="free">p'</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms vars_coeff_mpoly_to_mpoly_poly <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> R_def<span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?B</span> <span class="main">⊆</span> vars <span class="free">p'</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> R_def degree_pos_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?A</span> <span class="main">∪</span> <span class="var">?B</span> <span class="main">⊆</span> vars <span class="free">p'</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>   
    
<span class="keyword1" id="Poly_Connection-right_total"><span class="command">lemma</span></span> right_total <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"right_total R"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> right_total_def
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">safe</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">p'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> mpoly"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">p</span><span class="main">.</span> R <span class="bound">p</span> <span class="skolem">p'</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> exI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"mpoly_to_mpoly_poly <span class="free"><span class="free"><span class="free">x</span></span></span> <span class="skolem"><span class="skolem"><span class="skolem">p'</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> R_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Poly_Connection-bi_unique"><span class="command">lemma</span></span> bi_unique <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"bi_unique R"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> bi_unique_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> R_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1" id="Poly_Connection-mpoly_degree_mult_eq"><span class="command">lemma</span></span> mpoly_degree_mult_eq<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">p</span> <span class="free">q</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> idom mpoly"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">q</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"MPoly_Type.degree <span class="main">(</span><span class="free">p</span> <span class="main">*</span> <span class="free">q</span><span class="main">)</span> <span class="free">x</span> <span class="main">=</span> MPoly_Type.degree <span class="free">p</span> <span class="free">x</span> <span class="main">+</span> MPoly_Type.degree <span class="free">q</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> transfer_mpoly_to_mpoly_poly <span class="quoted"><span class="free">x</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">deg</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> mpoly <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">deg</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">p</span><span class="main">.</span> MPoly_Type.degree <span class="bound">p</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"rel_fun R <span class="main">(=)</span> Polynomial.degree <span class="skolem">deg</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> transfer_degree <span class="keyword1"><span class="command">unfolding</span></span> deg_def <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">deg</span> <span class="main">(</span><span class="free">p</span> <span class="main">*</span> <span class="free">q</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">deg</span> <span class="free">p</span> <span class="main">+</span> <span class="skolem">deg</span> <span class="free">q</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> deg_def <span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> degree_mult_eq<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> deg_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>



<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Converts a multi-variate polynomial into a univariate polynomial via inserting values for all but one variable›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">partial_insertion</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nat <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⇒</span> nat <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">::</span> comm_ring_1 mpoly <span class="main">⇒</span> <span class="tfree">'a</span> poly"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">partial_insertion</span> <span class="free"><span class="bound"><span class="entity">α</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> map_poly <span class="main">(</span>insertion <span class="free"><span class="bound"><span class="entity">α</span></span></span><span class="main">)</span> <span class="main">(</span>mpoly_to_mpoly_poly <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span>"</span></span> 

<span class="keyword1" id="Poly_Connection-comm_ring_hom_insertion"><span class="command">lemma</span></span> comm_ring_hom_insertion<span class="main">:</span> <span class="quoted"><span class="quoted">"comm_ring_hom <span class="main">(</span>insertion <span class="free">α</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> insertion_add insertion_mult<span class="main">)</span>


<span class="keyword1" id="Poly_Connection-partial_insertion_add"><span class="command">lemma</span></span> partial_insertion_add<span class="main">:</span> <span class="quoted"><span class="quoted">"partial_insertion <span class="free">α</span> <span class="free">x</span> <span class="main">(</span><span class="free">p</span> <span class="main">+</span> <span class="free">q</span><span class="main">)</span> <span class="main">=</span> partial_insertion <span class="free">α</span> <span class="free">x</span> <span class="free">p</span> <span class="main">+</span> partial_insertion <span class="free">α</span> <span class="free">x</span> <span class="free">q</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> i<span class="main">:</span> comm_ring_hom <span class="quoted"><span class="quoted">"insertion <span class="free">α</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> comm_ring_hom_insertion<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> partial_insertion_def mpoly_to_mpoly_poly_add <span class="dynamic"><span class="dynamic">hom_distribs</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Poly_Connection-partial_insertion_monom"><span class="command">lemma</span></span> partial_insertion_monom<span class="main">:</span> <span class="quoted"><span class="quoted">"partial_insertion <span class="free">α</span> <span class="free">x</span> <span class="main">(</span>MPoly_Type.monom <span class="free">m</span> <span class="free">a</span><span class="main">)</span> <span class="main">=</span> Polynomial.monom <span class="main">(</span>insertion <span class="free">α</span> <span class="main">(</span>MPoly_Type.monom <span class="main">(</span>remove_key <span class="free">x</span> <span class="free">m</span><span class="main">)</span> <span class="free">a</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>lookup <span class="free">m</span> <span class="free">x</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> partial_insertion_def mpoly_to_mpoly_poly_monom 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> map_poly_monom<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Partial insertion + insertion of last value is identical to (full) insertion›</span></span>
<span class="keyword1" id="Poly_Connection-insertion_partial_insertion"><span class="command">lemma</span></span> insertion_partial_insertion<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">≠</span> <span class="free">x</span> <span class="main">⟹</span> <span class="free">β</span> <span class="bound">y</span> <span class="main">=</span> <span class="free">α</span> <span class="bound">y</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"poly <span class="main">(</span>partial_insertion <span class="free">β</span> <span class="free">x</span> <span class="free">p</span><span class="main">)</span> <span class="main">(</span><span class="free">α</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> insertion <span class="free">α</span> <span class="free">p</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">p</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> mpoly_induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>monom <span class="skolem">m</span> <span class="skolem">a</span><span class="main">)</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?rkm</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"remove_key <span class="free">x</span> <span class="skolem">m</span>"</span></span> 
  <span class="keyword1"><span class="command">have</span></span> to_alpha<span class="main">:</span> <span class="quoted"><span class="quoted">"insertion <span class="free">β</span> <span class="main">(</span>MPoly_Type.monom <span class="var">?rkm</span> <span class="skolem">a</span><span class="main">)</span> <span class="main">=</span> insertion <span class="free">α</span> <span class="main">(</span>MPoly_Type.monom <span class="var">?rkm</span> <span class="skolem">a</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> insertion_irrelevant_vars<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> assms<span class="main"><span class="keyword3">,</span></span> <span class="operator">insert</span> vars_monom_subset<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="var"><span class="quoted"><span class="var"><span class="quoted"><span class="var"><span class="quoted"><span class="var">?rkm</span></span></span></span></span></span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">a</span></span></span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> remove_key_keys<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> main<span class="main">:</span> <span class="quoted"><span class="quoted">"insertion <span class="free">α</span> <span class="main">(</span>MPoly_Type.monom <span class="var">?rkm</span> <span class="skolem">a</span><span class="main">)</span> <span class="main">*</span> <span class="free">α</span> <span class="free">x</span> <span class="main">^</span> lookup <span class="skolem">m</span> <span class="free">x</span> <span class="main">=</span> insertion <span class="free">α</span> <span class="main">(</span>MPoly_Type.monom <span class="skolem">m</span> <span class="skolem">a</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> monom_remove_key<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">m</span></span> <span class="quoted"><span class="skolem">a</span></span> <span class="quoted"><span class="free">x</span></span><span class="main">]</span> insertion_mult
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> insertion_single mult.left_neutral<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> main to_alpha <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> partial_insertion_monom poly_monom<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>sum <span class="skolem">p1</span> <span class="skolem">p2</span> <span class="skolem">m</span> <span class="skolem">a</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> partial_insertion_add insertion_add map_poly_add<span class="main">)</span> 
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Poly_Connection-insertion_coeff_mpoly_to_mpoly_poly"><span class="command">lemma</span></span> insertion_coeff_mpoly_to_mpoly_poly<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"insertion <span class="free">α</span> <span class="main">(</span>coeff <span class="main">(</span>mpoly_to_mpoly_poly <span class="free">x</span> <span class="free">p</span><span class="main">)</span> <span class="free">k</span><span class="main">)</span> <span class="main">=</span> coeff <span class="main">(</span>partial_insertion <span class="free">α</span> <span class="free">x</span> <span class="free">p</span><span class="main">)</span> <span class="free">k</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> partial_insertion_def 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> coeff_map_poly<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1" id="Poly_Connection-degree_map_poly_Const"><span class="command">lemma</span></span> degree_map_poly_Const<span class="main">:</span> <span class="quoted"><span class="quoted">"degree <span class="main">(</span>map_poly <span class="main">(</span>Const <span class="main">::</span> <span class="tfree">'a</span> <span class="main">::</span> semiring_0 <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="free">f</span><span class="main">)</span> <span class="main">=</span> degree <span class="free">f</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> degree_map_poly<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1" id="Poly_Connection-degree_partial_insertion_le_mpoly"><span class="command">lemma</span></span> degree_partial_insertion_le_mpoly<span class="main">:</span> <span class="quoted"><span class="quoted">"degree <span class="main">(</span>partial_insertion <span class="free">α</span> <span class="free">x</span> <span class="free">p</span><span class="main">)</span> <span class="main">≤</span> degree <span class="main">(</span>mpoly_to_mpoly_poly <span class="free">x</span> <span class="free">p</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> partial_insertion_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> degree_map_poly_le<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="MPoly_Divide">
<div class="head">
<h1>Theory MPoly_Divide</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Exact Division of Multivariate Polynomials›</span></span>

<span class="keyword1"><span class="command">theory</span></span> MPoly_Divide
  <span class="keyword2"><span class="keyword">imports</span></span> 
    <a href="../../hermite_lindemann/theories/#More_Multivariate_Polynomial_HLW">Hermite_Lindemann.More_Multivariate_Polynomial_HLW</a>
    <a href="../../polynomials/theories/#MPoly_Type_Class">Polynomials.MPoly_Type_Class</a>
    <a href="#Poly_Connection">Poly_Connection</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="MPoly_Divide-poly_lead_coeff_dvd_lead_coeff"><span class="command">lemma</span></span> poly_lead_coeff_dvd_lead_coeff<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="keyword1">dvd</span> <span class="main">(</span><span class="free">q</span> <span class="main">::</span> <span class="tfree">'a</span> <span class="main">::</span> idom poly<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"Polynomial.lead_coeff <span class="free">p</span> <span class="keyword1">dvd</span> Polynomial.lead_coeff <span class="free">q</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">elim</span> dvdE<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Polynomial.lead_coeff_mult<span class="main">)</span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Since there is no particularly sensible algorithm for division with a remainder on
  multivariate polynomials, we define the following division operator that performs an
  exact division if possible and returns 0 otherwise.
›</span></span>

<span class="keyword1"><span class="command">no_notation</span></span> MPoly_Type.div <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">div</span>"</span> 70<span class="main">)</span>

<span class="keyword1"><span class="command">instantiation</span></span> mpoly <span class="main">::</span> <span class="main">(</span><span class="quoted"><span class="quoted">"comm_semiring_1"</span></span><span class="main">)</span> <span class="quoted">divide</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity"><span class="class_parameter">divide_mpoly</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> mpoly <span class="main">⇒</span> <span class="tfree">'a</span> mpoly <span class="main">⇒</span> <span class="tfree">'a</span> mpoly"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">divide_mpoly</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">≠</span> <span class="main">0</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="keyword1">dvd</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">then</span> <span class="keyword1">THE</span> <span class="bound">z</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">*</span> <span class="bound">z</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instance</span></span> mpoly <span class="main">::</span> <span class="main">(</span><span class="quoted">idom</span><span class="main">)</span> <span class="quoted">idom_divide</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> divide_mpoly_def<span class="main">)</span>



<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> transfer_mpoly_to_mpoly_poly<span class="main">)</span> transfer_div <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"R <span class="free">p'</span> <span class="free">p</span>"</span></span> <span class="quoted"><span class="quoted">"R <span class="free">q'</span> <span class="free">q</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">q</span> <span class="keyword1">dvd</span> <span class="free">p</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"R <span class="main">(</span><span class="free">p'</span> <span class="keyword1">div</span> <span class="free">q'</span><span class="main">)</span> <span class="main">(</span><span class="free">p</span> <span class="keyword1">div</span> <span class="free">q</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">smt</span> <span class="main"><span class="main">(</span></span>z3<span class="main"><span class="main">)</span></span> div_by_0 dvd_imp_mult_div_cancel_left mpoly_to_mpoly_poly_0 mpoly_to_mpoly_poly_eq_iff
        mpoly_to_mpoly_poly_mult nonzero_mult_div_cancel_left transfer_mpoly_to_mpoly_poly.R_def<span class="main">)</span>


<span class="keyword1"><span class="command">instantiation</span></span> mpoly <span class="main">::</span> <span class="main">(</span><span class="quoted"><span class="quoted">"<span class="main">{</span>normalization_semidom<span class="main">,</span> idom<span class="main">}</span>"</span></span><span class="main">)</span> <span class="quoted">normalization_semidom</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity"><span class="class_parameter">unit_factor_mpoly</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> mpoly <span class="main">⇒</span> <span class="tfree">'a</span> mpoly"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">unit_factor_mpoly</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> Const <span class="main">(</span>unit_factor <span class="main">(</span>lead_coeff <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity"><span class="class_parameter">normalize_mpoly</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> mpoly <span class="main">⇒</span> <span class="tfree">'a</span> mpoly"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">normalize_mpoly</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> Rings.divide <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">(</span>unit_factor <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="MPoly_Divide-unit_factor_mpoly_Const"><span class="command">lemma</span></span> unit_factor_mpoly_Const <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"unit_factor <span class="main">(</span>Const <span class="free">c</span><span class="main">)</span> <span class="main">=</span> Const <span class="main">(</span>unit_factor <span class="free">c</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> unit_factor_mpoly_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="MPoly_Divide-normalize_mpoly_Const"><span class="command">lemma</span></span> normalize_mpoly_Const <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"normalize <span class="main">(</span>Const <span class="free">c</span><span class="main">)</span> <span class="main">=</span> Const <span class="main">(</span>normalize <span class="free">c</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">=</span> <span class="main">0</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"normalize <span class="main">(</span>Const <span class="free">c</span><span class="main">)</span> <span class="main">=</span> Const <span class="free">c</span> <span class="keyword1">div</span> Const <span class="main">(</span>unit_factor <span class="free">c</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> normalize_mpoly_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> Const <span class="main">(</span>unit_factor <span class="free">c</span> <span class="main">*</span> normalize <span class="free">c</span><span class="main">)</span> <span class="keyword1">div</span> Const <span class="main">(</span>unit_factor <span class="free">c</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> Const <span class="main">(</span>unit_factor <span class="free">c</span><span class="main">)</span> <span class="main">*</span> Const <span class="main">(</span>normalize <span class="free">c</span><span class="main">)</span> <span class="keyword1">div</span> Const <span class="main">(</span>unit_factor <span class="free">c</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> mpoly_Const_mult<span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> Const <span class="main">(</span>normalize <span class="free">c</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="free">c</span> <span class="main">≠</span> <span class="main">0</span>›</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> nonzero_mult_div_cancel_left<span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> normalize_mpoly_def<span class="main">)</span>

<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"unit_factor <span class="main">(</span><span class="main">0</span> <span class="main">::</span> <span class="tfree">'a</span> mpoly<span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> unit_factor_mpoly_def<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"unit_factor <span class="skolem">x</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="keyword1">dvd</span> <span class="main">1</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> mpoly"</span></span>
    <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> mpoly_is_unitE <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> is_unit_unit_factor<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> mpoly"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"unit_factor <span class="skolem">x</span> <span class="keyword1">dvd</span> <span class="main">1</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> unit_factor_mpoly_def<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> mpoly"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="keyword1">dvd</span> <span class="main">1</span>"</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"unit_factor <span class="main">(</span><span class="skolem">x</span> <span class="main">*</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">x</span> <span class="main">*</span> unit_factor <span class="skolem">y</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">=</span> <span class="main">0</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Const <span class="main">(</span>unit_factor <span class="main">(</span>lead_coeff <span class="skolem">x</span> <span class="main">*</span> lead_coeff <span class="skolem">y</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
            <span class="skolem">x</span> <span class="main">*</span> Const <span class="main">(</span>unit_factor <span class="main">(</span>lead_coeff <span class="skolem">y</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="keyword1">dvd</span> <span class="main">1</span>›</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> unit_factor_mult_unit_left<span class="main">)</span>
         <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> mpoly_is_unitE <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mpoly_Const_mult<span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">≠</span> <span class="main">0</span>›</span></span> False
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> unit_factor_mpoly_def lead_coeff_mult<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> unit_factor_mpoly_def<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">p</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> mpoly"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?c</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"Const <span class="main">(</span>unit_factor <span class="main">(</span>lead_coeff <span class="skolem">p</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"unit_factor <span class="skolem">p</span> <span class="main">*</span> normalize <span class="skolem">p</span> <span class="main">=</span> <span class="skolem">p</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">=</span> <span class="main">0</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="var">?c</span> <span class="keyword1">dvd</span> <span class="main">1</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> is_unit_ConstI<span class="main">)</span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="keyword1">dvd</span> <span class="skolem">p</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?c</span> <span class="main">*</span> <span class="main">(</span><span class="skolem">p</span> <span class="keyword1">div</span> <span class="var">?c</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">p</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> dvd_imp_mult_div_cancel_left<span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> unit_factor_mpoly_def normalize_mpoly_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> normalize_mpoly_def<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"normalize <span class="main">(</span><span class="main">0</span> <span class="main">::</span> <span class="tfree">'a</span> mpoly<span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> normalize_mpoly_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>



<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The following is an exact division operator that can fail, i.e.\ if the divisor does not
  divide the dividend, it returns <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const</span><span class="hidden">&gt;</span></span></span>‹None›</span></span>.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">divide_option</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> idom_divide <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> option"</span></span>  <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1">div?</span>"</span> 70<span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">divide_option</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="keyword1">dvd</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="keyword1">then</span> Some <span class="main">(</span><span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="keyword1">div</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span><span class="main">)</span> <span class="keyword1">else</span> None<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We now show that exact division on the ring $R[X_1,\ldots, X_n]$ can be reduced to
  exact division on the ring $R[X_1,\ldots,X_n][X]$, i.e.\ we can go from <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="tfree"><span class="tfree">'a</span></span> mpoly›</span></span></span></span> to
  a <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">typ</span><span class="hidden">&gt;</span></span></span><span class="quoted"><span class="quoted">‹<span class="tfree"><span class="tfree">'a</span></span> mpoly poly›</span></span></span></span> where the coefficients have one variable less than the original
  multivariate polynomial. We basically simply use the isomorphism between these two rings.
›</span></span>

<span class="keyword1" id="MPoly_Divide-divide_option_mpoly"><span class="command">lemma</span></span> divide_option_mpoly<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">p</span> <span class="free">q</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> idom_divide mpoly"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="keyword1">div?</span> <span class="free">q</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">V</span> <span class="main">=</span> vars <span class="free">p</span> <span class="main">∪</span> vars <span class="free">q</span> <span class="keyword1">in</span>
           <span class="main">(</span><span class="keyword1">if</span> <span class="bound">V</span> <span class="main">=</span> <span class="main">{}</span> <span class="keyword1">then</span>
              <span class="keyword1">let</span> <span class="bound">a</span> <span class="main">=</span> MPoly_Type.coeff <span class="free">p</span> <span class="main">0</span><span class="main">;</span> <span class="bound">b</span> <span class="main">=</span> MPoly_Type.coeff <span class="free">q</span> <span class="main">0</span><span class="main">;</span> <span class="bound">c</span> <span class="main">=</span> <span class="bound">a</span> <span class="keyword1">div</span> <span class="bound">b</span>
              <span class="keyword1">in</span>  <span class="keyword1">if</span> <span class="bound">b</span> <span class="main">*</span> <span class="bound">c</span> <span class="main">=</span> <span class="bound">a</span> <span class="keyword1">then</span> Some <span class="main">(</span>Const <span class="bound">c</span><span class="main">)</span> <span class="keyword1">else</span> None
            <span class="keyword1">else</span>
              <span class="keyword1">let</span> <span class="bound">x</span> <span class="main">=</span> Max <span class="bound">V</span><span class="main">;</span>
                  <span class="bound">p'</span> <span class="main">=</span> mpoly_to_mpoly_poly <span class="bound">x</span> <span class="free">p</span><span class="main">;</span> <span class="bound">q'</span> <span class="main">=</span> mpoly_to_mpoly_poly <span class="bound">x</span> <span class="free">q</span>
              <span class="keyword1">in</span>  <span class="keyword1">case</span> <span class="bound">p'</span> <span class="keyword1">div?</span> <span class="bound">q'</span> <span class="keyword1">of</span>
                    None <span class="main">⇒</span> None
                  <span class="main">|</span> Some <span class="bound">r</span> <span class="main">⇒</span> Some <span class="main">(</span>poly <span class="bound">r</span> <span class="main">(</span>Var <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> Max <span class="main">(</span>vars <span class="free">p</span> <span class="main">∪</span> vars <span class="free">q</span><span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">p'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p'</span> <span class="main">=</span> mpoly_to_mpoly_poly <span class="skolem">x</span> <span class="free">p</span>"</span></span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">q'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">q'</span> <span class="main">=</span> mpoly_to_mpoly_poly <span class="skolem">x</span> <span class="free">q</span>"</span></span>
  <span class="keyword1"><span class="command">interpret</span></span> transfer_mpoly_to_mpoly_poly <span class="quoted"><span class="skolem">x</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"R <span class="skolem">p'</span> <span class="free">p</span>"</span></span> <span class="quoted"><span class="quoted">"R <span class="skolem">q'</span> <span class="free">q</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> p'_def q'_def R_def<span class="main">)</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"vars <span class="free">p</span> <span class="main">∪</span> vars <span class="free">q</span> <span class="main">=</span> <span class="main">{}</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">a</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">=</span> MPoly_Type.coeff <span class="free">p</span> <span class="main">0</span>"</span></span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">b</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">=</span> MPoly_Type.coeff <span class="free">q</span> <span class="main">0</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">=</span> Const <span class="skolem">a</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">q</span> <span class="main">=</span> Const <span class="skolem">b</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> True <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> vars_emptyE <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> a_def b_def mpoly_coeff_Const<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">b</span> <span class="main">=</span> <span class="main">0</span>"</span></span><span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def mpoly_coeff_Const mpoly_Const_mult divide_option_def <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> dvdE<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> dvd_triv_left<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?rhs</span> <span class="main">=</span>
            <span class="main">(</span><span class="keyword1">case</span> <span class="skolem">p'</span> <span class="keyword1">div?</span> <span class="skolem">q'</span> <span class="keyword1">of</span> None <span class="main">⇒</span> None
              <span class="main">|</span> Some <span class="bound">r</span> <span class="main">⇒</span> Some <span class="main">(</span>poly <span class="bound">r</span> <span class="main">(</span>Var <span class="skolem">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> False
      <span class="keyword1"><span class="command">unfolding</span></span> Let_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> <span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> if_False<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">flip</span><span class="main"><span class="main">:</span></span> x_def p'_def q'_def <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> option.case_cong<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="skolem">q'</span> <span class="keyword1">dvd</span> <span class="skolem">p'</span> <span class="keyword1">then</span> Some <span class="main">(</span>poly <span class="main">(</span><span class="skolem">p'</span> <span class="keyword1">div</span> <span class="skolem">q'</span><span class="main">)</span> <span class="main">(</span>Var <span class="skolem">x</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">else</span> None<span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> False <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> divide_option_def<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="free">p</span> <span class="keyword1">div?</span> <span class="free">q</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> divide_option_def
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> if_cong refl arg_cong<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted">Some</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">q'</span> <span class="keyword1">dvd</span> <span class="skolem">p'</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">q</span> <span class="keyword1">dvd</span> <span class="free">p</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">q</span> <span class="keyword1">dvd</span> <span class="free">p</span>"</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"R <span class="main">(</span><span class="skolem">p'</span> <span class="keyword1">div</span> <span class="skolem">q'</span><span class="main">)</span> <span class="main">(</span><span class="free">p</span> <span class="keyword1">div</span> <span class="free">q</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"poly <span class="main">(</span><span class="skolem">p'</span> <span class="keyword1">div</span> <span class="skolem">q'</span><span class="main">)</span> <span class="main">(</span>Var <span class="skolem">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">p</span> <span class="keyword1">div</span> <span class="free">q</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> R_def poly_mpoly_to_mpoly_poly<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Next, we show that exact division on the ring $R[X_1,\ldots,X_n][Y]$ can be reduced to
  exact division on the ring $R[X_1,\ldots,X_n]$. This is essentially just polynomial division.
›</span></span>
<span class="keyword1" id="MPoly_Divide-divide_option_mpoly_poly"><span class="command">lemma</span></span> divide_option_mpoly_poly<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">p</span> <span class="free">q</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> idom_divide mpoly poly"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="keyword1">div?</span> <span class="free">q</span> <span class="main">=</span> 
            <span class="main">(</span><span class="keyword1">if</span> <span class="free">p</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> Some <span class="main">0</span>
            <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="free">q</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> None
            <span class="keyword1">else</span> <span class="keyword1">let</span> <span class="bound">dp</span> <span class="main">=</span> Polynomial.degree <span class="free">p</span><span class="main">;</span> <span class="bound">dq</span> <span class="main">=</span> Polynomial.degree <span class="free">q</span>
                 <span class="keyword1">in</span>  <span class="keyword1">if</span> <span class="bound">dp</span> <span class="main">&lt;</span> <span class="bound">dq</span> <span class="keyword1">then</span> None
                     <span class="keyword1">else</span> <span class="keyword1">case</span> Polynomial.lead_coeff <span class="free">p</span> <span class="keyword1">div?</span> Polynomial.lead_coeff <span class="free">q</span> <span class="keyword1">of</span>
                            None <span class="main">⇒</span> None
                          <span class="main">|</span> Some <span class="bound">c</span> <span class="main">⇒</span> <span class="main">(</span>
                              <span class="keyword1">case</span> <span class="main">(</span><span class="free">p</span> <span class="main">-</span> Polynomial.monom <span class="bound">c</span> <span class="main">(</span><span class="bound">dp</span> <span class="main">-</span> <span class="bound">dq</span><span class="main">)</span> <span class="main">*</span> <span class="free">q</span><span class="main">)</span> <span class="keyword1">div?</span> <span class="free">q</span> <span class="keyword1">of</span>
                                None <span class="main">⇒</span> None
                              <span class="main">|</span> Some <span class="bound">r</span> <span class="main">⇒</span> Some <span class="main">(</span>Polynomial.monom <span class="bound">c</span> <span class="main">(</span><span class="bound">dp</span> <span class="main">-</span> <span class="bound">dq</span><span class="main">)</span> <span class="main">+</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">=</span> <span class="main">0</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">q</span> <span class="main">=</span> <span class="main">0</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">q</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">dp</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">dp</span> <span class="main">=</span> Polynomial.degree <span class="free">p</span>"</span></span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">dq</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">dq</span> <span class="main">=</span> Polynomial.degree <span class="free">q</span>"</span></span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">cp</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">cp</span> <span class="main">=</span> Polynomial.lead_coeff <span class="free">p</span>"</span></span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">cq</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">cq</span> <span class="main">=</span> Polynomial.lead_coeff <span class="free">q</span>"</span></span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">mon</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">mon</span> <span class="main">=</span> Polynomial.monom <span class="main">(</span><span class="skolem">cp</span> <span class="keyword1">div</span> <span class="skolem">cq</span><span class="main">)</span> <span class="main">(</span><span class="skolem">dp</span> <span class="main">-</span> <span class="skolem">dq</span><span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">dp</span> <span class="main">&lt;</span> <span class="skolem">dq</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="free">q</span> <span class="keyword1">dvd</span> <span class="free">p</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> dp_def dq_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> <span class="quoted"><span class="quoted">‹<span class="free">p</span> <span class="main">≠</span> <span class="main">0</span>›</span></span> divides_degree leD<span class="main">)</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">using</span></span> True <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> divide_option_def dp_def dq_def<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> deg<span class="main">:</span> False
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">cq</span> <span class="keyword1">dvd</span> <span class="skolem">cp</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> False
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="free">q</span> <span class="keyword1">dvd</span> <span class="free">p</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> cq_def cp_def <span class="keyword1"><span class="command">using</span></span> poly_lead_coeff_dvd_lead_coeff <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">using</span></span> deg False <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dp_def dq_def Let_def divide_option_def cp_def cq_def<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> dvd1<span class="main">:</span> True
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">q</span> <span class="keyword1">dvd</span> <span class="main">(</span><span class="free">p</span> <span class="main">-</span> <span class="skolem">mon</span> <span class="main">*</span> <span class="free">q</span><span class="main">)</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> False
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span><span class="free">q</span> <span class="keyword1">dvd</span> <span class="free">p</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> dvd_diff dvd_triv_right<span class="main">)</span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
          <span class="keyword1"><span class="command">using</span></span> deg dvd1 False
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dp_def dq_def Let_def divide_option_def cp_def cq_def mon_def<span class="main">)</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> dvd2<span class="main">:</span> True
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="free">q</span> <span class="keyword1">dvd</span> <span class="free">p</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> diff_eq_eq dvd_add dvd_triv_right<span class="main">)</span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?rhs</span> <span class="main">=</span> Some <span class="main">(</span><span class="skolem">mon</span> <span class="main">+</span> <span class="main">(</span><span class="free">p</span> <span class="main">-</span> <span class="skolem">mon</span> <span class="main">*</span> <span class="free">q</span><span class="main">)</span> <span class="keyword1">div</span> <span class="free">q</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> deg dvd1 dvd2
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> dp_def dq_def Let_def divide_option_def cp_def cq_def mon_def<span class="main">)</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">mon</span> <span class="main">+</span> <span class="main">(</span><span class="free">p</span> <span class="main">-</span> <span class="skolem">mon</span> <span class="main">*</span> <span class="free">q</span><span class="main">)</span> <span class="keyword1">div</span> <span class="free">q</span> <span class="main">=</span> <span class="free">p</span> <span class="keyword1">div</span> <span class="free">q</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> dvd2 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">elim</span> dvdE<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">algebra_simps</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Some <span class="main">…</span> <span class="main">=</span> <span class="free">p</span> <span class="keyword1">div?</span> <span class="free">q</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="free">q</span> <span class="keyword1">dvd</span> <span class="free">p</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> divide_option_def<span class="main">)</span>
        <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> divide_option_def<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  These two equations now serve as two mutually recursive code equations that allow us to
  reduce exact division of multivariate polynomials to exact division of their coefficients.
  Termination of these code equations is not shown explicitly, but is obvious since one variable
  is eliminated in every step.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">divide_option_mpoly</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> idom_divide mpoly <span class="main">⇒</span> <span class="main">_</span>"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">divide_option_mpoly</span> <span class="main">=</span> divide_option"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">divide_option_mpoly_poly</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> idom_divide mpoly poly <span class="main">⇒</span> <span class="main">_</span>"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">divide_option_mpoly_poly</span> <span class="main">=</span> divide_option"</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> divide_option_mpoly_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span>
  divide_option_mpoly <span class="main">[</span><span class="operator">folded</span> divide_option_mpoly_def divide_option_mpoly_poly_def<span class="main">]</span>

<span class="keyword1"><span class="command">lemmas</span></span> divide_option_mpoly_poly_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span>
  divide_option_mpoly_poly <span class="main">[</span><span class="operator">folded</span> divide_option_mpoly_def divide_option_mpoly_poly_def<span class="main">]</span>

<span class="keyword1" id="MPoly_Divide-divide_mpoly_code"><span class="command">lemma</span></span> divide_mpoly_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">p</span> <span class="free">q</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> idom_divide mpoly"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="keyword1">div</span> <span class="free">q</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> divide_option_mpoly <span class="free">p</span> <span class="free">q</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="main">0</span> <span class="main">|</span> Some <span class="bound">r</span> <span class="main">⇒</span> <span class="bound">r</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> divide_option_mpoly_def divide_option_def divide_mpoly_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="MPoly_Divide_Code">
<div class="head">
<h1>Theory MPoly_Divide_Code</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Implementation of Division on Multivariate Polynomials›</span></span>

<span class="keyword1"><span class="command">theory</span></span> MPoly_Divide_Code
  <span class="keyword2"><span class="keyword">imports</span></span> 
    <a href="#MPoly_Divide">MPoly_Divide</a> 
    <a href="../../polynomials/theories/#MPoly_Type_Class_FMap">Polynomials.MPoly_Type_Class_FMap</a>
    <a href="../../polynomials/theories/#MPoly_Type_Univariate">Polynomials.MPoly_Type_Univariate</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We now set up code equations for some of the operations that we will need, such as division,
  <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const</span><span class="hidden">&gt;</span></span></span>‹mpoly_to_poly›</span></span>, and <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator"><span class="hidden">\&lt;^</span><span class="control">const</span><span class="hidden">&gt;</span></span></span>‹mpoly_to_mpoly_poly›</span></span>.
›</span></span>

<span class="keyword1" id="MPoly_Divide_Code-mapping_of_MPoly"><span class="command">lemma</span></span> mapping_of_MPoly<span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"mapping_of <span class="main">(</span>MPoly <span class="free">p</span><span class="main">)</span> <span class="main">=</span> <span class="free">p</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> MPoly_inverse<span class="main">)</span>

<span class="keyword1"><span class="command">lift_definition</span></span> filter_pm <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒<span class="hidden">⇩</span><sub>0</sub></span> <span class="tfree">'b</span> <span class="main">::</span> zero<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒<span class="hidden">⇩</span><sub>0</sub></span> <span class="tfree">'b</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">is</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">P</span> <span class="bound">f</span> <span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">P</span> <span class="bound">x</span> <span class="keyword1">then</span> <span class="bound">f</span> <span class="bound">x</span> <span class="keyword1">else</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">erule</span> finite_subset<span class="main"><span class="main">[</span></span><span class="operator">rotated</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="MPoly_Divide_Code-lookup_filter_pm"><span class="command">lemma</span></span> lookup_filter_pm<span class="main">:</span> <span class="quoted"><span class="quoted">"lookup <span class="main">(</span>filter_pm <span class="free">P</span> <span class="free">f</span><span class="main">)</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">P</span> <span class="free">x</span> <span class="keyword1">then</span> lookup <span class="free">f</span> <span class="free">x</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">auto</span>


<span class="keyword1" id="MPoly_Divide_Code-filter_pm_code"><span class="command">lemma</span></span> filter_pm_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"filter_pm <span class="free">P</span> <span class="main">(</span>Pm_fmap <span class="free">m</span><span class="main">)</span> <span class="main">=</span> Pm_fmap <span class="main">(</span>fmfilter <span class="free">P</span> <span class="free">m</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> poly_mapping_eqI <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fmlookup_default_def lookup_filter_pm<span class="main">)</span>

<span class="keyword1" id="MPoly_Divide_Code-remove_key_conv_filter_pm"><span class="command">lemma</span></span> remove_key_conv_filter_pm <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"remove_key <span class="free">x</span> <span class="free">m</span> <span class="main">=</span> filter_pm <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">≠</span> <span class="free">x</span><span class="main">)</span> <span class="free">m</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">auto</span>

<span class="keyword1" id="MPoly_Divide_Code-finite_poly_coeff_nonzero"><span class="command">lemma</span></span> finite_poly_coeff_nonzero<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">{</span><span class="bound">n</span><span class="main">.</span> poly.coeff <span class="free">p</span> <span class="bound">n</span> <span class="main">≠</span> <span class="main">0</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> MOST_coeff_eq_0 eventually_cofinite<span class="main">)</span>

<span class="keyword1" id="MPoly_Divide_Code-poly_degree_conv_Max"><span class="command">lemma</span></span> poly_degree_conv_Max<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"Polynomial.degree <span class="free">p</span> <span class="main">=</span> Max <span class="main">{</span><span class="bound">n</span><span class="main">.</span> poly.coeff <span class="free">p</span> <span class="bound">n</span> <span class="main">≠</span> <span class="main">0</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> antisym degree_le Max.boundedI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">n</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">∈</span> <span class="main">{</span><span class="bound">n</span><span class="main">.</span> poly.coeff <span class="free">p</span> <span class="bound">n</span> <span class="main">≠</span> <span class="main">0</span><span class="main">}</span>"</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">≤</span> Polynomial.degree <span class="free">p</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> le_degree<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> poly_eq_iff finite_poly_coeff_nonzero<span class="main">)</span>

<span class="keyword1" id="MPoly_Divide_Code-mpoly_to_poly_code_aux"><span class="command">lemma</span></span> mpoly_to_poly_code_aux<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">p</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> comm_monoid_add mpoly"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">x</span> <span class="main">::</span> <span class="quoted">nat</span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">I</span> <span class="main">≡</span> <span class="main">(</span><span class="main">λ</span><span class="bound">m</span><span class="main">.</span> lookup <span class="bound">m</span> <span class="free">x</span><span class="main">)</span> <span class="main">`</span> Set.filter <span class="main">(</span><span class="main">λ</span><span class="bound">m</span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span><span class="main">∈</span>keys <span class="bound">m</span><span class="main">.</span> <span class="bound">y</span> <span class="main">=</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span>keys <span class="main">(</span>mapping_of <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"<span class="free">I</span> <span class="main">=</span> <span class="main">{</span><span class="bound">n</span><span class="main">.</span> poly.coeff <span class="main">(</span>mpoly_to_poly <span class="free">x</span> <span class="free">p</span><span class="main">)</span> <span class="bound">n</span> <span class="main">≠</span> <span class="main">0</span><span class="main">}</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"mpoly_to_poly <span class="free">x</span> <span class="free">p</span> <span class="main">=</span> <span class="main">0</span> <span class="main">⟷</span> <span class="free">I</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span>   <span class="quoted"><span class="quoted">"<span class="free">I</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">⟹</span> Polynomial.degree <span class="main">(</span>mpoly_to_poly <span class="free">x</span> <span class="free">p</span><span class="main">)</span> <span class="main">=</span> Max <span class="free">I</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">∈</span> <span class="free">I</span> <span class="main">⟷</span> poly.coeff <span class="main">(</span>mpoly_to_poly <span class="free">x</span> <span class="free">p</span><span class="main">)</span> <span class="skolem">n</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">n</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">I</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">m</span><span class="main">.</span> lookup <span class="bound">m</span> <span class="free">x</span><span class="main">)</span> <span class="main">`</span> <span class="main">(</span>keys <span class="main">(</span>mapping_of <span class="free">p</span><span class="main">)</span> <span class="main">∩</span> <span class="main">{</span><span class="bound">m</span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span><span class="main">∈</span>keys <span class="bound">m</span><span class="main">.</span> <span class="bound">y</span> <span class="main">=</span> <span class="free">x</span><span class="main">}</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> I_def Set.filter_def<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">m</span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span><span class="main">∈</span>keys <span class="bound">m</span><span class="main">.</span> <span class="bound">y</span> <span class="main">=</span> <span class="free">x</span><span class="main">}</span> <span class="main">=</span> range <span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> monomial <span class="bound">n</span> <span class="free">x</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> equalityI subsetI<span class="main">)</span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">m</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="main">∈</span> <span class="var">?lhs</span>"</span></span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="main">=</span> monomial <span class="main">(</span>lookup <span class="skolem">m</span> <span class="free">x</span><span class="main">)</span> <span class="free">x</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_eq_iff when_def<span class="main">)</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="main">∈</span> <span class="var">?rhs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">∈</span> <span class="main">(</span><span class="main">λ</span><span class="bound">m</span><span class="main">.</span> lookup <span class="bound">m</span> <span class="free">x</span><span class="main">)</span> <span class="main">`</span> <span class="main">(</span>keys <span class="main">(</span>mapping_of <span class="free">p</span><span class="main">)</span> <span class="main">∩</span> <span class="main">…</span><span class="main">)</span> <span class="main">⟷</span>
               monomial <span class="skolem">n</span> <span class="free">x</span> <span class="main">∈</span> keys <span class="main">(</span>mapping_of <span class="free">p</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">⟷</span> poly.coeff <span class="main">(</span>mpoly_to_poly <span class="free">x</span> <span class="free">p</span><span class="main">)</span> <span class="skolem">n</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> coeff_def in_keys_iff<span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword3"><span class="command">thus</span></span> I<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">I</span> <span class="main">=</span> <span class="main">{</span><span class="bound">n</span><span class="main">.</span> poly.coeff <span class="main">(</span>mpoly_to_poly <span class="free">x</span> <span class="free">p</span><span class="main">)</span> <span class="bound">n</span> <span class="main">≠</span> <span class="main">0</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">show</span></span> eq_0_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"mpoly_to_poly <span class="free">x</span> <span class="free">p</span> <span class="main">=</span> <span class="main">0</span> <span class="main">⟷</span> <span class="free">I</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> I <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> poly_eq_iff<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">I</span> <span class="main">≠</span> <span class="main">{}</span> <span class="main">⟹</span> Polynomial.degree <span class="main">(</span>mpoly_to_poly <span class="free">x</span> <span class="free">p</span><span class="main">)</span> <span class="main">=</span> Max <span class="free">I</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> poly_degree_conv_Max<span class="main">)</span> <span class="main">(</span><span class="operator">use</span> eq_0_iff I <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1" id="MPoly_Divide_Code-mpoly_to_poly_code"><span class="command">lemma</span></span> mpoly_to_poly_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Polynomial.coeffs <span class="main">(</span>mpoly_to_poly <span class="free">x</span> <span class="free">p</span><span class="main">)</span> <span class="main">=</span>
     <span class="main">(</span><span class="keyword1">let</span> <span class="bound">I</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">m</span><span class="main">.</span> lookup <span class="bound">m</span> <span class="free">x</span><span class="main">)</span> <span class="main">`</span> Set.filter <span class="main">(</span><span class="main">λ</span><span class="bound">m</span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span><span class="main">∈</span>keys <span class="bound">m</span><span class="main">.</span> <span class="bound">y</span> <span class="main">=</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span>keys <span class="main">(</span>mapping_of <span class="free">p</span><span class="main">)</span><span class="main">)</span>
      <span class="keyword1">in</span>  <span class="keyword1">if</span> <span class="bound">I</span> <span class="main">=</span> <span class="main">{}</span> <span class="keyword1">then</span> <span class="main">[]</span> <span class="keyword1">else</span> map <span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> MPoly_Type.coeff <span class="free">p</span> <span class="main">(</span>Poly_Mapping.single <span class="free">x</span> <span class="bound">n</span><span class="main">)</span><span class="main">)</span> <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span>Max <span class="bound">I</span> <span class="main">+</span> <span class="main">1</span><span class="main">]</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">I</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">I</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">m</span><span class="main">.</span> lookup <span class="bound">m</span> <span class="free">x</span><span class="main">)</span> <span class="main">`</span> Set.filter <span class="main">(</span><span class="main">λ</span><span class="bound">m</span><span class="main">.</span> <span class="main">∀</span><span class="bound">y</span><span class="main">∈</span>keys <span class="bound">m</span><span class="main">.</span> <span class="bound">y</span> <span class="main">=</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span>keys <span class="main">(</span>mapping_of <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">I</span> <span class="main">=</span> <span class="main">{}</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> mpoly_to_poly_code_aux<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="free">p</span></span><span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> I_def<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"mpoly_to_poly <span class="free">x</span> <span class="free">p</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> mpoly_to_poly_code_aux<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="free">p</span></span><span class="main">]</span> False <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> I_def<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> False <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?rhs</span> <span class="main">=</span> map <span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> MPoly_Type.coeff <span class="free">p</span> <span class="main">(</span>Poly_Mapping.single <span class="free">x</span> <span class="bound">n</span><span class="main">)</span><span class="main">)</span> <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span>Max <span class="skolem">I</span> <span class="main">+</span> <span class="main">1</span><span class="main">]</span>"</span></span>
      <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">=</span> <span class="var">?rhs'</span>"</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> I_def Let_def<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="var">?lhs</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> nth_equalityI<span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"length <span class="var">?rhs'</span> <span class="main">=</span> length <span class="var">?lhs</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> mpoly_to_poly_code_aux<span class="main">(</span>3<span class="main">)</span><span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="free">p</span></span><span class="main">]</span> False
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> I_def length_coeffs_degree<span class="main">)</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="var">?rhs'</span> <span class="main">!</span> <span class="skolem">n</span> <span class="main">=</span> <span class="var">?lhs</span> <span class="main">!</span> <span class="skolem">n</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">&lt;</span> length <span class="var">?rhs'</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">n</span> <span class="keyword1"><span class="command">using</span></span> that
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> upt_Suc <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> nth_coeffs_coeff<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">fun</span></span> <span class="entity">mpoly_to_mpoly_poly_impl_aux1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span>nat <span class="main">⇒<span class="hidden">⇩</span><sub>0</sub></span> nat<span class="main">)</span> <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span> list <span class="main">⇒</span> nat <span class="main">⇒</span> <span class="main">(</span><span class="main">(</span>nat <span class="main">⇒<span class="hidden">⇩</span><sub>0</sub></span> nat<span class="main">)</span> <span class="main">×</span> <span class="tfree">'a</span><span class="main">)</span> list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">mpoly_to_mpoly_poly_impl_aux1</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">[]</span> <span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">mpoly_to_mpoly_poly_impl_aux1</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">mon'</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">)</span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="main">=</span>
     <span class="main">(</span><span class="keyword1">if</span> lookup <span class="free"><span class="bound"><span class="entity">mon'</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="keyword1">then</span> <span class="main">[</span><span class="main">(</span>remove_key <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">mon'</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">)</span><span class="main">]</span> <span class="keyword1">else</span> <span class="main">[]</span><span class="main">)</span> <span class="main">@</span> <span class="free">mpoly_to_mpoly_poly_impl_aux1</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="free"><span class="bound"><span class="entity">j</span></span></span>"</span></span>

<span class="keyword1" id="MPoly_Divide_Code-mpoly_to_mpoly_poly_impl_aux1_altdef"><span class="command">lemma</span></span> mpoly_to_mpoly_poly_impl_aux1_altdef<span class="main">:</span>
  <span class="quoted"><span class="quoted">"mpoly_to_mpoly_poly_impl_aux1 <span class="free">i</span> <span class="free">xs</span> <span class="free">j</span> <span class="main">=</span>
     map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">mon</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span>remove_key <span class="free">i</span> <span class="bound">mon</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>filter <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">mon</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span><span class="main">.</span> lookup <span class="bound">mon</span> <span class="free">i</span> <span class="main">=</span> <span class="free">j</span><span class="main">)</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="MPoly_Divide_Code-map_of_mpoly_to_mpoly_poly_impl_aux1"><span class="command">lemma</span></span> map_of_mpoly_to_mpoly_poly_impl_aux1<span class="main">:</span>
  <span class="quoted"><span class="quoted">"map_of <span class="main">(</span>mpoly_to_mpoly_poly_impl_aux1 <span class="free">i</span> <span class="free">xs</span> <span class="free">j</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">mon</span><span class="main">.</span>
     <span class="main">(</span><span class="keyword1">if</span> lookup <span class="bound">mon</span> <span class="free">i</span> <span class="main">&gt;</span> <span class="main">0</span> <span class="keyword1">then</span> None
      <span class="keyword1">else</span> map_of <span class="free">xs</span> <span class="main">(</span><span class="bound">mon</span> <span class="main">+</span> Poly_Mapping.single <span class="free">i</span> <span class="free">j</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ext<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">i</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quoted"><span class="free">j</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> mpoly_to_mpoly_poly_impl_aux1.induct<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> remove_key_lookup<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">meson</span> remove_key_sum<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> add_left_cancel lookup_single_eq remove_key_sum<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> remove_key_add remove_key_single remove_key_sum single_zero<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="MPoly_Divide_Code-lookup0_fmap_of_list_mpoly_to_mpoly_poly_impl_aux1"><span class="command">lemma</span></span> lookup0_fmap_of_list_mpoly_to_mpoly_poly_impl_aux1<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lookup0 <span class="main">(</span>fmap_of_list <span class="main">(</span>mpoly_to_mpoly_poly_impl_aux1 <span class="free">i</span> <span class="free">xs</span> <span class="free">j</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">mon</span><span class="main">.</span>
     lookup0 <span class="main">(</span>fmap_of_list <span class="free">xs</span><span class="main">)</span> <span class="main">(</span><span class="bound">mon</span> <span class="main">+</span> Poly_Mapping.single <span class="free">i</span> <span class="free">j</span><span class="main">)</span> <span class="keyword1">when</span> lookup <span class="bound">mon</span> <span class="free">i</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmlookup_default_def fmlookup_of_list map_of_mpoly_to_mpoly_poly_impl_aux1<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">mpoly_to_mpoly_poly_impl_aux2</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">mpoly_to_mpoly_poly_impl_aux2</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="main">=</span> poly.coeff <span class="main">(</span>mpoly_to_mpoly_poly <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">j</span></span></span>"</span></span>

<span class="keyword1" id="MPoly_Divide_Code-coeff_MPoly"><span class="command">lemma</span></span> coeff_MPoly<span class="main">:</span> <span class="quoted"><span class="quoted">"MPoly_Type.coeff <span class="main">(</span>MPoly <span class="free">f</span><span class="main">)</span> <span class="free">m</span> <span class="main">=</span> lookup <span class="free">f</span> <span class="free">m</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> coeff_def mpoly.MPoly_inverse<span class="main">)</span>

<span class="keyword1" id="MPoly_Divide_Code-mpoly_to_mpoly_poly_impl_aux2_code"><span class="command">lemma</span></span> mpoly_to_mpoly_poly_impl_aux2_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"mpoly_to_mpoly_poly_impl_aux2 <span class="free">i</span> <span class="main">(</span>MPoly <span class="main">(</span>Pm_fmap <span class="main">(</span>fmap_of_list <span class="free">xs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="free">j</span> <span class="main">=</span>
     MPoly <span class="main">(</span>Pm_fmap <span class="main">(</span>fmap_of_list <span class="main">(</span>mpoly_to_mpoly_poly_impl_aux1 <span class="free">i</span> <span class="free">xs</span> <span class="free">j</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> mpoly_to_mpoly_poly_impl_aux2_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> mpoly_eqI<span class="main">)</span>
     <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> coeff_coeff_mpoly_to_mpoly_poly coeff_MPoly
                lookup0_fmap_of_list_mpoly_to_mpoly_poly_impl_aux1<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">mpoly_to_mpoly_poly_impl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">::</span> comm_ring_1 mpoly <span class="main">⇒</span> <span class="tfree">'a</span> mpoly list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">mpoly_to_mpoly_poly_impl</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">[]</span> <span class="keyword1">else</span>
     map <span class="main">(</span>mpoly_to_mpoly_poly_impl_aux2 <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span>Suc <span class="main">(</span>MPoly_Type.degree <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">]</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="MPoly_Divide_Code-mpoly_to_mpoly_poly_eq_0_iff"><span class="command">lemma</span></span> mpoly_to_mpoly_poly_eq_0_iff <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"mpoly_to_mpoly_poly <span class="free">x</span> <span class="free">p</span> <span class="main">=</span> <span class="main">0</span> <span class="main">⟷</span> <span class="free">p</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> transfer_mpoly_to_mpoly_poly <span class="quoted"><span class="free">x</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">p'</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p'</span> <span class="main">=</span> mpoly_to_mpoly_poly <span class="free">x</span> <span class="free">p</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"R <span class="skolem">p'</span> <span class="free">p</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> R_def p'_def<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> p'_def <span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="MPoly_Divide_Code-mpoly_to_mpoly_poly_code"><span class="command">lemma</span></span> mpoly_to_mpoly_poly_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"Polynomial.coeffs <span class="main">(</span>mpoly_to_mpoly_poly <span class="free">x</span> <span class="free">p</span><span class="main">)</span> <span class="main">=</span> mpoly_to_mpoly_poly_impl <span class="free">x</span> <span class="free">p</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> nth_equalityI<span class="main">)</span>
     <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mpoly_to_mpoly_poly_impl_def length_coeffs_degree
                 mpoly_to_mpoly_poly_impl_aux2_def coeffs_nth <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> upt_Suc<span class="main">)</span>

<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"mpoly_to_mpoly_poly <span class="main">0</span> <span class="main">(</span>Var <span class="main">0</span> <span class="main">^</span> <span class="numeral">2</span> <span class="main">+</span> Var <span class="main">0</span> <span class="main">*</span> Var <span class="main">1</span> <span class="main">+</span> Var <span class="main">1</span> <span class="main">^</span> <span class="numeral">2</span> <span class="main">::</span> int mpoly<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"Rings.divide <span class="main">(</span>Var <span class="main">0</span> <span class="main">^</span> <span class="numeral">2</span> <span class="main">*</span> Var <span class="main">1</span> <span class="main">+</span> Var <span class="main">0</span> <span class="main">*</span> Var <span class="main">1</span> <span class="main">^</span> <span class="numeral">2</span> <span class="main">::</span> int mpoly<span class="main">)</span> <span class="main">(</span>Var <span class="main">1</span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="MPoly_Container">
<div class="head">
<h1>Theory MPoly_Container</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Class Instances for Multivariate Polynomials and Containers›</span></span>


<span class="keyword1"><span class="command">theory</span></span> MPoly_Container
  <span class="keyword2"><span class="keyword">imports</span></span> 
    <span class="quoted">"<a href="../../polynomials/theories/#MPoly_Type_Class">Polynomials.MPoly_Type_Class</a>"</span>
    <span class="quoted">"<a href="../../containers/theories/#Set_Impl">Containers.Set_Impl</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Basic setup for using multivariate polynomials in combination with container framework.›</span></span>
 
<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>eq<span class="main">)</span> ceq <span class="quoted">poly_mapping</span>
<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>dlist<span class="main">)</span> set_impl <span class="quoted">poly_mapping</span> <span class="comment1">(* difference list *)</span>
<span class="keyword1"><span class="command">derive</span></span> <span class="main">(</span>no<span class="main">)</span> ccompare <span class="quoted">poly_mapping</span> <span class="comment1">(* no order on poly-mapping *)</span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="Multivariate_Resultant">
<div class="head">
<h1>Theory Multivariate_Resultant</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Resultants of Multivariate Polynomials›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We utilize the conversion of multivariate polynomials into univariate polynomials
  for the definition of the resultant of multivariate polynomials via
  the resultant for univariate polynomials. In this way, we can use the algorithm
  to efficiently compute resultants for the multivariate case.›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Multivariate_Resultant
  <span class="keyword2"><span class="keyword">imports</span></span> 
    <a href="#Poly_Connection">Poly_Connection</a>
    <a href="../../algebraic_numbers/theories/#Resultant">Algebraic_Numbers.Resultant</a>
    <a href="../../subresultants/theories/#Subresultant">Subresultants.Subresultant</a>
    <a href="#MPoly_Divide_Code">MPoly_Divide_Code</a>
    <a href="#MPoly_Container">MPoly_Container</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">hide_const</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="main">)</span> 
  MPoly_Type.degree
  MPoly_Type.coeff
  Symmetric_Polynomials.lead_coeff

<span class="keyword1" id="Multivariate_Resultant-det_sylvester_matrix_higher_degree"><span class="command">lemma</span></span> det_sylvester_matrix_higher_degree<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"det <span class="main">(</span>sylvester_mat_sub <span class="main">(</span>degree <span class="free">f</span> <span class="main">+</span> <span class="free">n</span><span class="main">)</span> <span class="main">(</span>degree <span class="free">g</span><span class="main">)</span> <span class="free">f</span> <span class="free">g</span><span class="main">)</span>
  <span class="main">=</span> det <span class="main">(</span>sylvester_mat_sub <span class="main">(</span>degree <span class="free">f</span><span class="main">)</span> <span class="main">(</span>degree <span class="free">g</span><span class="main">)</span> <span class="free">f</span> <span class="free">g</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span>lead_coeff <span class="free">g</span> <span class="main">*</span> <span class="main">(</span><span class="main">-</span><span class="main">1</span><span class="main">)</span><span class="main">^</span><span class="main">(</span>degree <span class="free">g</span><span class="main">)</span><span class="main">)</span><span class="main">^</span><span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?A</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"sylvester_mat_sub <span class="main">(</span>degree <span class="free">f</span> <span class="main">+</span> Suc <span class="skolem">n</span><span class="main">)</span> <span class="main">(</span>degree <span class="free">g</span><span class="main">)</span> <span class="free">f</span> <span class="free">g</span>"</span></span> 
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?d</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"degree <span class="free">f</span> <span class="main">+</span> Suc <span class="skolem">n</span> <span class="main">+</span> degree <span class="free">g</span>"</span></span> 
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">h</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">h</span> <span class="skolem">i</span> <span class="main">=</span> <span class="var">?A</span> <span class="main">$$</span> <span class="main">(</span><span class="skolem">i</span><span class="main">,</span><span class="main">0</span><span class="main">)</span> <span class="main">*</span> cofactor <span class="var">?A</span> <span class="skolem">i</span> <span class="main">0</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">i</span>
  <span class="keyword1"><span class="command">have</span></span> mult_left_zero<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="main">0</span> <span class="main">⟹</span> <span class="skolem">x</span> <span class="main">*</span> <span class="skolem">y</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"det <span class="var">?A</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">i</span><span class="main">&lt;</span><span class="var">?d</span><span class="main">.</span> <span class="skolem">h</span> <span class="bound">i</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> h_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> laplace_expansion_column<span class="main"><span class="main">[</span></span><span class="operator">OF</span> sylvester_mat_sub_carrier<span class="main"><span class="main">,</span></span> <span class="operator">of</span> <span class="quoted"><span class="main"><span class="quoted"><span class="main"><span class="quoted"><span class="main">0</span></span></span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">force</span><span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> sum <span class="skolem">h</span> <span class="main">(</span><span class="main">{</span>degree <span class="free">g</span><span class="main">}</span> <span class="main">∪</span> <span class="main">(</span><span class="main">{..&lt;</span><span class="var">?d</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span>degree <span class="free">g</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> sum.cong<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> sum <span class="skolem">h</span> <span class="main">{</span>degree <span class="free">g</span><span class="main">}</span> <span class="main">+</span> sum <span class="skolem">h</span> <span class="main">(</span><span class="main">{..&lt;</span><span class="var">?d</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span>degree <span class="free">g</span><span class="main">}</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> sum.union_disjoint<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"sum <span class="skolem">h</span> <span class="main">(</span><span class="main">{..&lt;</span><span class="var">?d</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span>degree <span class="free">g</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> h_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> sum.neutral ballI mult_left_zero<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sylvester_mat_sub_def coeff_eq_0<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"sum <span class="skolem">h</span> <span class="main">{</span>degree <span class="free">g</span><span class="main">}</span> <span class="main">=</span> <span class="skolem">h</span> <span class="main">(</span>degree <span class="free">g</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> lead_coeff <span class="free">g</span> <span class="main">*</span> cofactor <span class="var">?A</span> <span class="main">(</span>degree <span class="free">g</span><span class="main">)</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> h_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> arg_cong<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main"><span class="main">λ</span></span></span> <span class="bound"><span class="bound"><span class="bound">x</span></span></span><span class="main"><span class="main"><span class="main">.</span></span></span> <span class="bound"><span class="bound"><span class="bound">x</span></span></span> <span class="main"><span class="main"><span class="main">*</span></span></span> <span class="main"><span class="main"><span class="main">_</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sylvester_mat_sub_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"cofactor <span class="var">?A</span> <span class="main">(</span>degree <span class="free">g</span><span class="main">)</span> <span class="main">0</span> <span class="main">=</span> <span class="main">(</span><span class="main">-</span><span class="main">1</span><span class="main">)</span><span class="main">^</span><span class="main">(</span>degree <span class="free">g</span><span class="main">)</span> <span class="main">*</span> det <span class="main">(</span>sylvester_mat_sub <span class="main">(</span>degree <span class="free">f</span> <span class="main">+</span> <span class="skolem">n</span><span class="main">)</span> <span class="main">(</span>degree <span class="free">g</span><span class="main">)</span> <span class="free">f</span> <span class="free">g</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> cofactor_def
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> arg_cong2<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">λ</span></span> <span class="bound"><span class="bound">x</span></span> <span class="bound"><span class="bound">y</span></span><span class="main"><span class="main">.</span></span> <span class="main"><span class="main">(</span></span><span class="main"><span class="main">-</span></span><span class="main"><span class="main">1</span></span><span class="main"><span class="main">)</span></span><span class="main"><span class="main">^</span></span><span class="bound"><span class="bound">x</span></span> <span class="main"><span class="main">*</span></span> det <span class="bound"><span class="bound">y</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">force</span><span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"mat_delete <span class="var">?A</span> <span class="main">(</span>degree <span class="free">g</span><span class="main">)</span> <span class="main">0</span> <span class="main">=</span> sylvester_mat_sub <span class="main">(</span>degree <span class="free">f</span> <span class="main">+</span> <span class="skolem">n</span><span class="main">)</span> <span class="main">(</span>degree <span class="free">g</span><span class="main">)</span> <span class="free">f</span> <span class="free">g</span>"</span></span> 
      <span class="keyword1"><span class="command">unfolding</span></span> sylvester_mat_sub_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> eq_matI<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mat_delete_def coeff_eq_0<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> Suc <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The conversion of multivariate into univariate polynomials permits us to define resultants in the multivariate
  setting. Since in our application one of the polynomials is already univariate, we use a non-symmetric definition
  where only one of the input polynomials is multivariate.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">resultant_mpoly_poly</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">::</span> comm_ring_1 mpoly <span class="main">⇒</span> <span class="tfree">'a</span> poly <span class="main">⇒</span> <span class="tfree">'a</span> mpoly"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">resultant_mpoly_poly</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">=</span> resultant <span class="main">(</span>mpoly_to_mpoly_poly <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="main">(</span>map_poly Const <span class="free"><span class="bound"><span class="entity">q</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This lemma tells us that there is only a minor difference between computing the multivariate resultant and then
  plugging in values, or first inserting values and then evaluate the univariate resultant.›</span></span>
<span class="keyword1" id="Multivariate_Resultant-insertion_resultant_mpoly_poly"><span class="command">lemma</span></span> insertion_resultant_mpoly_poly<span class="main">:</span> <span class="quoted"><span class="quoted">"insertion <span class="free">α</span> <span class="main">(</span>resultant_mpoly_poly <span class="free">x</span> <span class="free">p</span> <span class="free">q</span><span class="main">)</span> <span class="main">=</span> resultant <span class="main">(</span>partial_insertion <span class="free">α</span> <span class="free">x</span> <span class="free">p</span><span class="main">)</span> <span class="free">q</span> <span class="main">*</span> 
  <span class="main">(</span>lead_coeff <span class="free">q</span> <span class="main">*</span> <span class="main">(</span><span class="main">-</span><span class="main">1</span><span class="main">)</span><span class="main">^</span> degree <span class="free">q</span><span class="main">)</span><span class="main">^</span><span class="main">(</span>degree <span class="main">(</span>mpoly_to_mpoly_poly <span class="free">x</span> <span class="free">p</span><span class="main">)</span> <span class="main">-</span> degree <span class="main">(</span>partial_insertion <span class="free">α</span> <span class="free">x</span> <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?pa</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"partial_insertion <span class="free">α</span> <span class="free">x</span>"</span></span> 
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?a</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"insertion <span class="free">α</span>"</span></span> 
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?q</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"map_poly Const <span class="free">q</span>"</span></span> 
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?m</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"mpoly_to_mpoly_poly <span class="free">x</span>"</span></span> 
  <span class="keyword1"><span class="command">interpret</span></span> a<span class="main">:</span> comm_ring_hom <span class="var"><span class="quoted"><span class="var">?a</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> comm_ring_hom_insertion<span class="main">)</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">m</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">m</span> <span class="main">=</span> degree <span class="main">(</span><span class="var">?m</span> <span class="free">p</span><span class="main">)</span> <span class="main">-</span> degree <span class="main">(</span><span class="var">?pa</span> <span class="free">p</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">from</span></span> degree_partial_insertion_le_mpoly<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">α</span></span> <span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="free">p</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> deg<span class="main">:</span> <span class="quoted"><span class="quoted">"degree <span class="main">(</span><span class="var">?m</span> <span class="free">p</span><span class="main">)</span> <span class="main">=</span> degree <span class="main">(</span><span class="var">?pa</span> <span class="free">p</span><span class="main">)</span> <span class="main">+</span> <span class="skolem">m</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> m_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">k</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span> <span class="main">=</span> degree <span class="main">(</span><span class="var">?pa</span> <span class="free">p</span><span class="main">)</span> <span class="main">+</span> <span class="skolem">m</span>"</span></span> 
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">l</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">l</span> <span class="main">=</span> degree <span class="free">q</span>"</span></span> 
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"resultant <span class="main">(</span><span class="var">?pa</span> <span class="free">p</span><span class="main">)</span> <span class="free">q</span> <span class="main">=</span> det <span class="main">(</span>sylvester_mat_sub <span class="main">(</span>degree <span class="main">(</span><span class="var">?pa</span> <span class="free">p</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>degree <span class="free">q</span><span class="main">)</span> <span class="main">(</span><span class="var">?pa</span> <span class="free">p</span><span class="main">)</span> <span class="free">q</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> resultant_def sylvester_mat_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?a</span> <span class="main">(</span>resultant_mpoly_poly <span class="free">x</span> <span class="free">p</span> <span class="free">q</span><span class="main">)</span> <span class="main">=</span> <span class="var">?a</span> <span class="main">(</span>det <span class="main">(</span>sylvester_mat_sub <span class="main">(</span>degree <span class="main">(</span><span class="var">?pa</span> <span class="free">p</span><span class="main">)</span> <span class="main">+</span> <span class="skolem">m</span><span class="main">)</span> <span class="main">(</span>degree <span class="free">q</span><span class="main">)</span> <span class="main">(</span><span class="var">?m</span> <span class="free">p</span><span class="main">)</span> <span class="var">?q</span><span class="main">)</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> resultant_mpoly_poly_def resultant_def sylvester_mat_def degree_map_poly_Const deg <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span>
    det <span class="main">(</span>a.mat_hom <span class="main">(</span>sylvester_mat_sub <span class="main">(</span>degree <span class="main">(</span><span class="var">?pa</span> <span class="free">p</span><span class="main">)</span> <span class="main">+</span> <span class="skolem">m</span><span class="main">)</span> <span class="main">(</span>degree <span class="free">q</span><span class="main">)</span> <span class="main">(</span><span class="var">?m</span> <span class="free">p</span><span class="main">)</span> <span class="var">?q</span><span class="main">)</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> a.hom_det <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"a.mat_hom <span class="main">(</span>sylvester_mat_sub <span class="main">(</span>degree <span class="main">(</span><span class="var">?pa</span> <span class="free">p</span><span class="main">)</span> <span class="main">+</span> <span class="skolem">m</span><span class="main">)</span> <span class="main">(</span>degree <span class="free">q</span><span class="main">)</span> <span class="main">(</span><span class="var">?m</span> <span class="free">p</span><span class="main">)</span> <span class="var">?q</span><span class="main">)</span>
    <span class="main">=</span> sylvester_mat_sub <span class="main">(</span>degree <span class="main">(</span><span class="var">?pa</span> <span class="free">p</span><span class="main">)</span> <span class="main">+</span> <span class="skolem">m</span><span class="main">)</span> <span class="main">(</span>degree <span class="free">q</span><span class="main">)</span> <span class="main">(</span><span class="var">?pa</span> <span class="free">p</span><span class="main">)</span> <span class="free">q</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> k_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> l_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> eq_matI<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sylvester_mat_sub_def coeff_map_poly<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"det <span class="main">…</span> <span class="main">=</span> det <span class="main">(</span>sylvester_mat_sub <span class="main">(</span>degree <span class="main">(</span><span class="var">?pa</span> <span class="free">p</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>degree <span class="free">q</span><span class="main">)</span> <span class="main">(</span><span class="var">?pa</span> <span class="free">p</span><span class="main">)</span> <span class="free">q</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span>lead_coeff <span class="free">q</span> <span class="main">*</span> <span class="main">(</span><span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="main">^</span> degree <span class="free">q</span><span class="main">)</span> <span class="main">^</span> <span class="skolem">m</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> det_sylvester_matrix_higher_degree<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"det <span class="main">(</span>sylvester_mat_sub <span class="main">(</span>degree <span class="main">(</span><span class="var">?pa</span> <span class="free">p</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>degree <span class="free">q</span><span class="main">)</span> <span class="main">(</span><span class="var">?pa</span> <span class="free">p</span><span class="main">)</span> <span class="free">q</span><span class="main">)</span> <span class="main">=</span> resultant <span class="main">(</span><span class="var">?pa</span> <span class="free">p</span><span class="main">)</span> <span class="free">q</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> resultant_def sylvester_mat_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> m_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Multivariate_Resultant-insertion_resultant_mpoly_poly_zero"><span class="command">lemma</span></span> insertion_resultant_mpoly_poly_zero<span class="main">:</span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">q</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> idom poly"</span></span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> q<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">q</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"insertion <span class="free">α</span> <span class="main">(</span>resultant_mpoly_poly <span class="free">x</span> <span class="free">p</span> <span class="free">q</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span> <span class="main">⟷</span> resultant <span class="main">(</span>partial_insertion <span class="free">α</span> <span class="free">x</span> <span class="free">p</span><span class="main">)</span> <span class="free">q</span> <span class="main">=</span> <span class="main">0</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> insertion_resultant_mpoly_poly <span class="keyword1"><span class="command">using</span></span> q <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Multivariate_Resultant-vars_resultant"><span class="command">lemma</span></span> vars_resultant<span class="main">:</span> <span class="quoted"><span class="quoted">"vars <span class="main">(</span>resultant <span class="free">p</span> <span class="free">q</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">⋃</span> <span class="main">(</span>vars <span class="main">`</span> <span class="main">(</span>range <span class="main">(</span>coeff <span class="free">p</span><span class="main">)</span> <span class="main">∪</span> range <span class="main">(</span>coeff <span class="free">q</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> resultant_def det_def sylvester_mat_def sylvester_mat_sub_def 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order.trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> vars_setsum<span class="main"><span class="main">]</span></span><span class="main">)</span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">using</span></span> finite_permutations <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> UN_least<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order.trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> vars_mult<span class="main"><span class="main">]</span></span><span class="main">)</span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order.trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> vars_prod<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> UN_least<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹By taking the resultant, one variable is deleted.›</span></span>
<span class="keyword1" id="Multivariate_Resultant-vars_resultant_mpoly_poly"><span class="command">lemma</span></span> vars_resultant_mpoly_poly<span class="main">:</span> <span class="quoted"><span class="quoted">"vars <span class="main">(</span>resultant_mpoly_poly <span class="free">x</span> <span class="free">p</span> <span class="free">q</span><span class="main">)</span> <span class="main">⊆</span> vars <span class="free">p</span> <span class="main">-</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">y</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> vars <span class="main">(</span>resultant_mpoly_poly <span class="free">x</span> <span class="free">p</span> <span class="free">q</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">from</span></span> set_mp<span class="main">[</span><span class="operator">OF</span> vars_resultant this<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> resultant_mpoly_poly_def<span class="main"><span class="main">]</span></span><span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">i</span></span> 
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> vars <span class="main">(</span>coeff <span class="main">(</span>mpoly_to_mpoly_poly <span class="free">x</span> <span class="free">p</span><span class="main">)</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">∨</span> <span class="skolem">y</span> <span class="main">∈</span> vars <span class="main">(</span>coeff <span class="main">(</span>map_poly Const <span class="free">q</span><span class="main">)</span> <span class="skolem">i</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"vars <span class="main">(</span>coeff <span class="main">(</span>map_poly Const <span class="free">q</span><span class="main">)</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> coeff_map_poly<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> vars <span class="main">(</span>coeff <span class="main">(</span>mpoly_to_mpoly_poly <span class="free">x</span> <span class="free">p</span><span class="main">)</span> <span class="skolem">i</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">y</span> <span class="main">∈</span> More_MPoly_Type.vars <span class="free">p</span> <span class="main">-</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> vars_coeff_mpoly_to_mpoly_poly <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹For resultants, we manually have to select the implementation that 
  works on integral domains, because there is no factorial ring instance for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"int mpoly"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>

<span class="keyword1" id="Multivariate_Resultant-resultant_mpoly_poly_code"><span class="command">lemma</span></span> resultant_mpoly_poly_code<span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"resultant_mpoly_poly <span class="free">x</span> <span class="free">p</span> <span class="free">q</span> <span class="main">=</span> resultant_impl_idom_divide <span class="main">(</span>mpoly_to_mpoly_poly <span class="free">x</span> <span class="free">p</span><span class="main">)</span> <span class="main">(</span>map_poly Const <span class="free">q</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> resultant_mpoly_poly_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Make the idom-divide-resultant algorithm executable. The following
  three lines have to be removed when switching to the development version of AFP,
  where the code-setup for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> resultant_impl_idom_divide<span class="antiquote"><span class="antiquote">}</span></span></span></span> is already integrated.›</span></span>
<span class="keyword1"><span class="command">declare</span></span> resultant_impl_main_def<span class="main">[</span><span class="operator">code</span><span class="main">]</span>
<span class="keyword1"><span class="command">declare</span></span> subresultant_prs_def<span class="main">[</span><span class="operator">code</span><span class="main">]</span>
<span class="keyword1"><span class="command">declare</span></span> subresultant_prs_main.simps<span class="main">[</span><span class="operator">code</span><span class="main">]</span>



<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="Is_Int_To_Int">
<div class="head">
<h1>Theory Is_Int_To_Int</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Testing for Integrality and Conversion to Integers›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Is_Int_To_Int
  <span class="keyword2"><span class="keyword">imports</span></span> 
    <a href="../../polynomial_interpolation/theories/#Is_Rat_To_Rat">Polynomial_Interpolation.Is_Rat_To_Rat</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Is_Int_To_Int-inv_of_rat"><span class="command">lemma</span></span> inv_of_rat<span class="main">:</span> <span class="quoted"><span class="quoted">"inv of_rat <span class="main">(</span>of_rat <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> injI inv_f_eq of_rat_eq_iff<span class="main">)</span>

<span class="keyword1" id="Is_Int_To_Int-of_rat_Ints_iff"><span class="command">lemma</span></span> of_rat_Ints_iff<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>of_rat <span class="free">x</span> <span class="main">::</span> <span class="tfree">'a</span> <span class="main">::</span> field_char_0<span class="main">)</span> <span class="main">∈</span> <span class="main">ℤ</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span> <span class="main">∈</span> <span class="main">ℤ</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Ints_cases Ints_of_int inv_of_rat of_rat_of_int_eq<span class="main">)</span>

<span class="keyword1" id="Is_Int_To_Int-is_int_code"><span class="command">lemma</span></span> is_int_code<span class="main">[</span><span class="operator">code_unfold</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">∈</span> <span class="main">ℤ</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>is_rat <span class="free">x</span> <span class="main">∧</span> is_int_rat <span class="main">(</span>to_rat <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="main">ℤ</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">∈</span> <span class="main">ℚ</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">∈</span> <span class="main">ℤ</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Ints_cases Rats_of_int<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span>is_rat <span class="free">x</span> <span class="main">∧</span> is_int_rat <span class="main">(</span>to_rat <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">intro</span> conj_cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> refl<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="main">ℚ</span>"</span></span> 
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">y</span></span> <span class="keyword2"><span class="keyword">where</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> of_rat <span class="skolem">y</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> Rats_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">∈</span> <span class="main">ℤ</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>to_rat <span class="free">x</span> <span class="main">∈</span> <span class="main">ℤ</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> x
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> of_rat_Ints_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">to_int</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> is_rat <span class="main">⇒</span> int"</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">to_int</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> int_of_rat <span class="main">(</span>to_rat <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span> 

<span class="keyword1" id="Is_Int_To_Int-of_int_to_int"><span class="command">lemma</span></span> of_int_to_int<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="main">ℤ</span> <span class="main">⟹</span> of_int <span class="main">(</span>to_int <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">x</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Ints_cases int_of_rat<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> of_rat_of_int_eq to_int_def to_rat_of_rat<span class="main">)</span>

<span class="keyword1" id="Is_Int_To_Int-to_int_of_int"><span class="command">lemma</span></span> to_int_of_int<span class="main">:</span> <span class="quoted"><span class="quoted">"to_int <span class="main">(</span>of_int <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> int_of_rat<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> of_rat_of_int_eq to_int_def to_rat_of_rat<span class="main">)</span>

<span class="keyword1" id="Is_Int_To_Int-to_rat_complex_of_real"><span class="command">lemma</span></span> to_rat_complex_of_real<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"to_rat <span class="main">(</span>complex_of_real <span class="free">x</span><span class="main">)</span> <span class="main">=</span> to_rat <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Re_complex_of_real complex_of_real_of_rat of_rat_to_rat to_rat to_rat_of_rat<span class="main">)</span>

<span class="keyword1" id="Is_Int_To_Int-to_int_complex_of_real"><span class="command">lemma</span></span> to_int_complex_of_real<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"to_int <span class="main">(</span>complex_of_real <span class="free">x</span><span class="main">)</span> <span class="main">=</span> to_int <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> to_int_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Roots_of_Algebraic_Poly">
<div class="head">
<h1>Theory Roots_of_Algebraic_Poly</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Representing Roots of Polynomials with Algebraic Coefficients›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We provide an algorithm to compute a non-zero integer polynomial $q$ from a polynomial
 $p$ with algebraic coefficients such that all roots of $p$ are also roots of $q$.

 In this way, we have a constructive proof that the set of complex algebraic numbers 
 is algebraically closed.›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Roots_of_Algebraic_Poly
  <span class="keyword2"><span class="keyword">imports</span></span> 
    <a href="../../cubic_quartic_equations/theories/#Min_Int_Poly_Impl">Cubic_Quartic_Equations.Min_Int_Poly_Impl</a>
    <a href="#Multivariate_Resultant">Multivariate_Resultant</a>
    <a href="#Is_Int_To_Int">Is_Int_To_Int</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Preliminaries›</span></span>

<span class="keyword1"><span class="command">hide_const</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="main">)</span> up_ring.monom
<span class="keyword1"><span class="command">hide_const</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="main">)</span> MPoly_Type.monom

<span class="keyword1" id="Roots_of_Algebraic_Poly-map_mpoly_Const"><span class="command">lemma</span></span> map_mpoly_Const<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">0</span> <span class="main">=</span> <span class="main">0</span> <span class="main">⟹</span> map_mpoly <span class="free">f</span> <span class="main">(</span>Const <span class="free">i</span><span class="main">)</span> <span class="main">=</span> Const <span class="main">(</span><span class="free">f</span> <span class="free">i</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> mpoly_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> coeff_map_mpoly mpoly_coeff_Const<span class="main">)</span>

<span class="keyword1" id="Roots_of_Algebraic_Poly-map_mpoly_Var"><span class="command">lemma</span></span> map_mpoly_Var<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">1</span> <span class="main">=</span> <span class="main">1</span> <span class="main">⟹</span> map_mpoly <span class="main">(</span><span class="free">f</span> <span class="main">::</span> <span class="tfree">'b</span> <span class="main">::</span> zero_neq_one <span class="main">⇒</span> <span class="main">_</span><span class="main">)</span> <span class="main">(</span>Var <span class="free">i</span><span class="main">)</span> <span class="main">=</span> Var <span class="free">i</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> mpoly_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> coeff_map_mpoly coeff_Var when_def<span class="main">)</span>

<span class="keyword1" id="Roots_of_Algebraic_Poly-map_mpoly_monom"><span class="command">lemma</span></span> map_mpoly_monom<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">0</span> <span class="main">=</span> <span class="main">0</span> <span class="main">⟹</span> map_mpoly <span class="free">f</span> <span class="main">(</span>MPoly_Type.monom <span class="free">m</span> <span class="free">a</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>MPoly_Type.monom <span class="free">m</span> <span class="main">(</span><span class="free">f</span> <span class="free">a</span><span class="main">)</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> mpoly_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">unfold</span> coeff_map_mpoly if_distrib coeff_monom<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> when_def<span class="main">)</span>

<span class="keyword1" id="Roots_of_Algebraic_Poly-remove_key_single'"><span class="command">lemma</span></span> remove_key_single'<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"remove_key <span class="free">v</span> <span class="main">(</span>Poly_Mapping.single <span class="free">w</span> <span class="free">n</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">v</span> <span class="main">=</span> <span class="free">w</span> <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> Poly_Mapping.single <span class="free">w</span> <span class="free">n</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> add.right_neutral lookup_single_not_eq remove_key_single remove_key_sum single_zero<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span> comm_monoid_add_hom
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1" id="Roots_of_Algebraic_Poly-hom_Sum_any"><span class="command">lemma</span></span> hom_Sum_any<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> fin<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">≠</span> <span class="main">0</span><span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">hom</span> <span class="main">(</span>Sum_any <span class="free">f</span><span class="main">)</span> <span class="main">=</span> Sum_any <span class="main">(</span><span class="main">λ</span> <span class="bound">x</span><span class="main">.</span> <span class="free">hom</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> Sum_any.expand_set hom_sum
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> sum.mono_neutral_right<span class="main"><span class="main">[</span></span><span class="operator">OF</span> fin<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
 
<span class="keyword1" id="Roots_of_Algebraic_Poly-comm_monoid_add_hom_mpoly_map"><span class="command">lemma</span></span> comm_monoid_add_hom_mpoly_map<span class="main">:</span> <span class="quoted"><span class="quoted">"comm_monoid_add_hom <span class="main">(</span>map_mpoly <span class="free">hom</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">intro</span> mpoly_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hom_add<span class="main">)</span>

<span class="keyword1" id="Roots_of_Algebraic_Poly-map_mpoly_hom_Const"><span class="command">lemma</span></span> map_mpoly_hom_Const<span class="main">:</span> <span class="quoted"><span class="quoted">"map_mpoly <span class="free">hom</span> <span class="main">(</span>Const <span class="free">i</span><span class="main">)</span> <span class="main">=</span> Const <span class="main">(</span><span class="free">hom</span> <span class="free">i</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> map_mpoly_Const<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="Roots_of_Algebraic_Poly-map_mpoly_hom_monom"><span class="command">lemma</span></span> map_mpoly_hom_monom<span class="main">:</span> <span class="quoted"><span class="quoted">"map_mpoly <span class="free">hom</span> <span class="main">(</span>MPoly_Type.monom <span class="free">m</span> <span class="free">a</span><span class="main">)</span> <span class="main">=</span> MPoly_Type.monom <span class="free">m</span> <span class="main">(</span><span class="free">hom</span> <span class="free">a</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> map_mpoly_monom<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> comm_ring_hom
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1" id="Roots_of_Algebraic_Poly-mpoly_to_poly_map_mpoly_hom"><span class="command">lemma</span></span> mpoly_to_poly_map_mpoly_hom<span class="main">:</span> <span class="quoted"><span class="quoted">"mpoly_to_poly <span class="free">x</span> <span class="main">(</span>map_mpoly <span class="free">hom</span> <span class="free">p</span><span class="main">)</span> <span class="main">=</span> map_poly <span class="free">hom</span> <span class="main">(</span>mpoly_to_poly <span class="free">x</span> <span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> poly_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">unfold</span> coeff_mpoly_to_poly coeff_map_poly_hom<span class="main"><span class="keyword3">,</span></span> <span class="operator">subst</span> coeff_map_mpoly'<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
 
<span class="keyword1" id="Roots_of_Algebraic_Poly-comm_ring_hom_mpoly_map"><span class="command">lemma</span></span> comm_ring_hom_mpoly_map<span class="main">:</span> <span class="quoted"><span class="quoted">"comm_ring_hom <span class="main">(</span>map_mpoly <span class="free">hom</span><span class="main">)</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> mp<span class="main">:</span> comm_monoid_add_hom <span class="quoted"><span class="quoted">"map_mpoly <span class="free">hom</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> comm_monoid_add_hom_mpoly_map<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"map_mpoly <span class="free">hom</span> <span class="main">1</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> mpoly_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> MPoly_Type.coeff_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">transfer</span> <span class="quasi_keyword">fixing</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">hom</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">transfer</span> <span class="quasi_keyword">fixing</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">hom</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> when_def<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="skolem">y</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"map_mpoly <span class="free">hom</span> <span class="main">(</span><span class="skolem">x</span> <span class="main">*</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">=</span> map_mpoly <span class="free">hom</span> <span class="skolem">x</span> <span class="main">*</span> map_mpoly <span class="free">hom</span> <span class="skolem">y</span>"</span></span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> mpoly_eqI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> coeff_map_mpoly'<span class="main"><span class="keyword3">,</span></span> <span class="operator">force</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> coeff_mpoly_times<span class="main">)</span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> prod_fun_unfold_prod<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> prod_fun_unfold_prod<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> coeff_map_mpoly'<span class="main"><span class="keyword3">,</span></span> <span class="operator">force</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> coeff_map_mpoly'<span class="main"><span class="keyword3">,</span></span> <span class="operator">force</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> hom_Sum_any<span class="main">)</span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> 
      <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
        <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?X</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">a</span><span class="main">.</span> MPoly_Type.coeff <span class="skolem">x</span> <span class="bound">a</span> <span class="main">≠</span> <span class="main">0</span><span class="main">}</span>"</span></span> 
        <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?Y</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">a</span><span class="main">.</span> MPoly_Type.coeff <span class="skolem">y</span> <span class="bound">a</span> <span class="main">≠</span> <span class="main">0</span><span class="main">}</span>"</span></span> 
        <span class="keyword1"><span class="command">have</span></span> fin<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span><span class="var">?X</span> <span class="main">×</span> <span class="var">?Y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> finite_subset<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ fin<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> Sum_any.cong<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> mon pair <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">pair</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> hom_mult when_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Roots_of_Algebraic_Poly-mpoly_to_mpoly_poly_map_mpoly_hom"><span class="command">lemma</span></span> mpoly_to_mpoly_poly_map_mpoly_hom<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"mpoly_to_mpoly_poly <span class="free">x</span> <span class="main">(</span>map_mpoly <span class="free">hom</span> <span class="free">p</span><span class="main">)</span> <span class="main">=</span> map_poly <span class="main">(</span>map_mpoly <span class="free">hom</span><span class="main">)</span> <span class="main">(</span>mpoly_to_mpoly_poly <span class="free">x</span> <span class="free">p</span><span class="main">)</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> mp<span class="main">:</span> comm_ring_hom <span class="quoted"><span class="quoted">"map_mpoly <span class="free">hom</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> comm_ring_hom_mpoly_map<span class="main">)</span>
  <span class="keyword1"><span class="command">interpret</span></span> mmp<span class="main">:</span> map_poly_comm_monoid_add_hom <span class="quoted"><span class="quoted">"map_mpoly <span class="free">hom</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> mpoly_to_mpoly_poly_def 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> mmp.hom_Sum_any<span class="main"><span class="keyword3">,</span></span> <span class="operator">force</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> Sum_any.cong<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> mp.map_poly_hom_monom map_mpoly_hom_monom<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>    
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> inj_comm_ring_hom
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1" id="Roots_of_Algebraic_Poly-inj_comm_ring_hom_mpoly_map"><span class="command">lemma</span></span> inj_comm_ring_hom_mpoly_map<span class="main">:</span> <span class="quoted"><span class="quoted">"inj_comm_ring_hom <span class="main">(</span>map_mpoly <span class="free">hom</span><span class="main">)</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> mp<span class="main">:</span> comm_ring_hom <span class="quoted"><span class="quoted">"map_mpoly <span class="free">hom</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> comm_ring_hom_mpoly_map<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
    <span class="keyword3"><span class="command">assume</span></span> 0<span class="main">:</span> <span class="quoted"><span class="quoted">"map_mpoly <span class="free">hom</span> <span class="skolem">x</span> <span class="main">=</span> <span class="main">0</span>"</span></span>     
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="main">0</span>"</span></span> 
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> mpoly_eqI<span class="main">)</span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">m</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"MPoly_Type.coeff <span class="skolem">x</span> <span class="skolem">m</span> <span class="main">=</span> MPoly_Type.coeff <span class="main">0</span> <span class="skolem">m</span>"</span></span> 
        <span class="keyword1"><span class="command">using</span></span> arg_cong<span class="main">[</span><span class="operator">OF</span> 0<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="bound">p</span><span class="main">.</span> MPoly_Type.coeff <span class="bound">p</span> <span class="skolem">m</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Roots_of_Algebraic_Poly-resultant_mpoly_poly_hom"><span class="command">lemma</span></span> resultant_mpoly_poly_hom<span class="main">:</span> <span class="quoted"><span class="quoted">"resultant_mpoly_poly <span class="free">x</span> <span class="main">(</span>map_mpoly <span class="free">hom</span> <span class="free">p</span><span class="main">)</span> <span class="main">(</span>map_poly <span class="free">hom</span> <span class="free">q</span><span class="main">)</span> <span class="main">=</span> map_mpoly <span class="free">hom</span> <span class="main">(</span>resultant_mpoly_poly <span class="free">x</span> <span class="free">p</span> <span class="free">q</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> mp<span class="main">:</span> inj_comm_ring_hom <span class="quoted"><span class="quoted">"map_mpoly <span class="free">hom</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> inj_comm_ring_hom_mpoly_map<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> resultant_mpoly_poly_def 
  <span class="keyword1"><span class="command">unfolding</span></span> mpoly_to_mpoly_poly_map_mpoly_hom 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> mp.resultant_map_poly<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> mp.degree_map_poly_hom<span class="main"><span class="keyword3">,</span></span> <span class="operator">unfold_locales</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> mp.degree_map_poly_hom<span class="main"><span class="keyword3">,</span></span> <span class="operator">unfold_locales</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> arg_cong<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted"><span class="quoted">"resultant <span class="main"><span class="main">_</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">intro</span> poly_eqI<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> coeff_map_poly<span class="main"><span class="keyword3">,</span></span> <span class="operator">force</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_mpoly_hom_Const<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Roots_of_Algebraic_Poly-map_insort_key"><span class="command">lemma</span></span> map_insort_key<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">g1</span> <span class="bound">x</span> <span class="main">≤</span> <span class="free">g1</span> <span class="bound">y</span> <span class="main">⟷</span> <span class="free">g2</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">≤</span> <span class="free">g2</span> <span class="main">(</span><span class="free">f</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"map <span class="free">f</span> <span class="main">(</span>insort_key <span class="free">g1</span> <span class="free">a</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> insort_key <span class="free">g2</span> <span class="main">(</span><span class="free">f</span> <span class="free">a</span><span class="main">)</span> <span class="main">(</span>map <span class="free">f</span> <span class="free">xs</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1" id="Roots_of_Algebraic_Poly-map_sort_key"><span class="command">lemma</span></span> map_sort_key<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">g1</span> <span class="bound">x</span> <span class="main">≤</span> <span class="free">g1</span> <span class="bound">y</span> <span class="main">⟷</span> <span class="free">g2</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">≤</span> <span class="free">g2</span> <span class="main">(</span><span class="free">f</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"map <span class="free">f</span> <span class="main">(</span>sort_key <span class="free">g1</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> sort_key <span class="free">g2</span> <span class="main">(</span>map <span class="free">f</span> <span class="free">xs</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> map_insort_key<span class="main">)</span>

<span class="keyword1"><span class="command">hide_const</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="main">)</span> MPoly_Type.degree
<span class="keyword1"><span class="command">hide_const</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="main">)</span> MPoly_Type.coeffs
<span class="keyword1"><span class="command">hide_const</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="main">)</span> MPoly_Type.coeff
<span class="keyword1"><span class="command">hide_const</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="main">)</span> Symmetric_Polynomials.lead_coeff

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹More Facts about Resultants›</span></span>

<span class="keyword1" id="Roots_of_Algebraic_Poly-resultant_iff_coprime_main"><span class="command">lemma</span></span> resultant_iff_coprime_main<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="free">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> field poly"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> deg<span class="main">:</span> <span class="quoted"><span class="quoted">"degree <span class="free">f</span> <span class="main">&gt;</span> <span class="main">0</span> <span class="main">∨</span> degree <span class="free">g</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span> 
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"resultant <span class="free">f</span> <span class="free">g</span> <span class="main">=</span> <span class="main">0</span> <span class="main">⟷</span> <span class="main">¬</span> coprime <span class="free">f</span> <span class="free">g</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"resultant <span class="free">f</span> <span class="free">g</span> <span class="main">=</span> <span class="main">0</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword1"><span class="command">from</span></span> resultant_zero_imp_common_factor<span class="main">[</span><span class="operator">OF</span> deg True<span class="main">]</span> True
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword1"><span class="command">from</span></span> deg <span class="keyword1"><span class="command">have</span></span> fg<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">∨</span> <span class="free">g</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> resultant_non_zero_imp_coprime<span class="main">[</span><span class="operator">OF</span> False fg<span class="main">]</span> deg False
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Roots_of_Algebraic_Poly-resultant_zero_iff_coprime"><span class="command">lemma</span></span> resultant_zero_iff_coprime<span class="main">:</span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="free">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> field poly"</span></span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">∨</span> <span class="free">g</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"resultant <span class="free">f</span> <span class="free">g</span> <span class="main">=</span> <span class="main">0</span> <span class="main">⟷</span> <span class="main">¬</span> coprime <span class="free">f</span> <span class="free">g</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"degree <span class="free">f</span> <span class="main">&gt;</span> <span class="main">0</span> <span class="main">∨</span> degree <span class="free">g</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> resultant_iff_coprime_main<span class="main">[</span><span class="operator">OF</span> True<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"degree <span class="free">f</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="quoted"><span class="quoted">"degree <span class="free">g</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">c</span></span> <span class="skolem"><span class="skolem">d</span></span> <span class="keyword2"><span class="keyword">where</span></span> f<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">=</span> <span class="main">[:</span><span class="skolem">c</span><span class="main">:]</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> g<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="main">=</span> <span class="main">[:</span><span class="skolem">d</span><span class="main">:]</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> degree0_coeffs <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> cd<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">∨</span> <span class="skolem">d</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> f g <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> res<span class="main">:</span> <span class="quoted"><span class="quoted">"resultant <span class="free">f</span> <span class="free">g</span> <span class="main">=</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> f g resultant_const <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"coprime <span class="free">f</span> <span class="free">g</span>"</span></span>  
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> assms one_neq_zero res resultant_non_zero_imp_coprime<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> res <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The problem with the upcoming lemma is that "root" and "irreducibility" refer to the same type.
  In the actual application we interested in "irreducibility" over the integers, but the roots
  we are interested in are either real or complex.›</span></span>
<span class="keyword1" id="Roots_of_Algebraic_Poly-resultant_zero_iff_common_root_irreducible"><span class="command">lemma</span></span> resultant_zero_iff_common_root_irreducible<span class="main">:</span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="free">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> field poly"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> irr<span class="main">:</span> <span class="quoted"><span class="quoted">"irreducible <span class="free">g</span>"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> root<span class="main">:</span> <span class="quoted"><span class="quoted">"poly <span class="free">g</span> <span class="free">a</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="comment1">(* g has at least some root *)</span>
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"resultant <span class="free">f</span> <span class="free">g</span> <span class="main">=</span> <span class="main">0</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span> <span class="bound">x</span><span class="main">.</span> poly <span class="free">f</span> <span class="bound">x</span> <span class="main">=</span> <span class="main">0</span> <span class="main">∧</span> poly <span class="free">g</span> <span class="bound">x</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> irr root <span class="keyword1"><span class="command">have</span></span> deg<span class="main">:</span> <span class="quoted"><span class="quoted">"degree <span class="free">g</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> degree0_coeffs<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">g</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> 
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">x</span><span class="main">.</span> poly <span class="free">f</span> <span class="bound">x</span> <span class="main">=</span> <span class="main">0</span> <span class="main">∧</span> poly <span class="free">g</span> <span class="bound">x</span> <span class="main">=</span> <span class="main">0</span>"</span></span> 
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"poly <span class="free">f</span> <span class="skolem">x</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="quoted"><span class="quoted">"poly <span class="free">g</span> <span class="skolem">x</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> resultant_zero<span class="main">[</span><span class="operator">OF</span> _ this<span class="main">]</span> deg <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"resultant <span class="free">f</span> <span class="free">g</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"resultant <span class="free">f</span> <span class="free">g</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> resultant_zero_imp_common_factor<span class="main">[</span><span class="operator">OF</span> _ this<span class="main">]</span> deg
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> coprime <span class="free">f</span> <span class="free">g</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> this<span class="main">[</span><span class="operator">unfolded</span> not_coprime_iff_common_factor<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">r</span></span> <span class="keyword2"><span class="keyword">where</span></span>
       rf<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">r</span> <span class="keyword1">dvd</span> <span class="free">f</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> rg<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">r</span> <span class="keyword1">dvd</span> <span class="free">g</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> r<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> is_unit <span class="skolem">r</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> rg r irr <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="keyword1">dvd</span> <span class="skolem">r</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> algebraic_semidom_class.irreducible_altdef<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> rf <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="keyword1">dvd</span> <span class="free">f</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> root <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">x</span><span class="main">.</span> poly <span class="free">f</span> <span class="bound">x</span> <span class="main">=</span> <span class="main">0</span> <span class="main">∧</span> poly <span class="free">g</span> <span class="bound">x</span> <span class="main">=</span> <span class="main">0</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> exI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">a</span></span></span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> dvd_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1" id="Roots_of_Algebraic_Poly-resultant_zero_iff_common_root_complex"><span class="command">lemma</span></span> resultant_zero_iff_common_root_complex<span class="main">:</span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="free">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"complex poly"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> g<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> 
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"resultant <span class="free">f</span> <span class="free">g</span> <span class="main">=</span> <span class="main">0</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span> <span class="bound">x</span><span class="main">.</span> poly <span class="free">f</span> <span class="bound">x</span> <span class="main">=</span> <span class="main">0</span> <span class="main">∧</span> poly <span class="free">g</span> <span class="bound">x</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"degree <span class="free">g</span> <span class="main">=</span> <span class="main">0</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> deg<span class="main">:</span> False
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> 
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">x</span><span class="main">.</span> poly <span class="free">f</span> <span class="bound">x</span> <span class="main">=</span> <span class="main">0</span> <span class="main">∧</span> poly <span class="free">g</span> <span class="bound">x</span> <span class="main">=</span> <span class="main">0</span>"</span></span> 
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"poly <span class="free">f</span> <span class="skolem">x</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="quoted"><span class="quoted">"poly <span class="free">g</span> <span class="skolem">x</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> resultant_zero<span class="main">[</span><span class="operator">OF</span> _ this<span class="main">]</span> deg <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"resultant <span class="free">f</span> <span class="free">g</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"resultant <span class="free">f</span> <span class="free">g</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> resultant_zero_imp_common_factor<span class="main">[</span><span class="operator">OF</span> _ this<span class="main">]</span> deg
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> coprime <span class="free">f</span> <span class="free">g</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> this<span class="main">[</span><span class="operator">unfolded</span> not_coprime_iff_common_factor<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">r</span></span> <span class="keyword2"><span class="keyword">where</span></span>
       rf<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">r</span> <span class="keyword1">dvd</span> <span class="free">f</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> rg<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">r</span> <span class="keyword1">dvd</span> <span class="free">g</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> r<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> is_unit <span class="skolem">r</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> rg g <span class="keyword1"><span class="command">have</span></span> r0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">r</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> r <span class="keyword1"><span class="command">have</span></span> degr<span class="main">:</span> <span class="quoted"><span class="quoted">"degree <span class="skolem">r</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> constant <span class="main">(</span>poly <span class="skolem">r</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> constant_degree<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> fundamental_theorem_of_algebra<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">a</span></span> <span class="keyword2"><span class="keyword">where</span></span> root<span class="main">:</span> <span class="quoted"><span class="quoted">"poly <span class="skolem">r</span> <span class="skolem">a</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> rf rg root <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">x</span><span class="main">.</span> poly <span class="free">f</span> <span class="bound">x</span> <span class="main">=</span> <span class="main">0</span> <span class="main">∧</span> poly <span class="free">g</span> <span class="bound">x</span> <span class="main">=</span> <span class="main">0</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> exI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">a</span></span></span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> dvd_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> deg<span class="main">:</span> True
  <span class="keyword1"><span class="command">from</span></span> degree0_coeffs<span class="main">[</span><span class="operator">OF</span> deg<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">c</span></span> <span class="keyword2"><span class="keyword">where</span></span> gc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="main">=</span> <span class="main">[:</span><span class="skolem">c</span><span class="main">:]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> gc g <span class="keyword1"><span class="command">have</span></span> c<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"resultant <span class="free">f</span> <span class="free">g</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> gc resultant_const <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">with</span></span> gc c <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Systems of Polynomials›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Definition of solving a system of polynomials, one being multivariate›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">mpoly_polys_solution</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> field mpoly <span class="main">⇒</span> <span class="main">(</span>nat <span class="main">⇒</span> <span class="tfree">'a</span> poly<span class="main">)</span> <span class="main">⇒</span> nat set <span class="main">⇒</span> <span class="main">(</span>nat <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">mpoly_polys_solution</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">qs</span></span></span> <span class="free"><span class="bound"><span class="entity">N</span></span></span> <span class="free"><span class="bound"><span class="entity">α</span></span></span> <span class="main">=</span> <span class="main">(</span>
       insertion <span class="free"><span class="bound"><span class="entity">α</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">0</span> <span class="main">∧</span>
       <span class="main">(</span><span class="main">∀</span> <span class="bound">i</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">N</span></span></span><span class="main">.</span> poly <span class="main">(</span><span class="free"><span class="bound"><span class="entity">qs</span></span></span> <span class="bound">i</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">α</span></span></span> <span class="main">(</span>Suc <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The upcoming lemma shows how to eliminate single variables in multi-variate root-problems.
  Because of the problem mentioned in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] resultant_zero_iff_common_root_irreducible<span class="antiquote"><span class="antiquote">}</span></span></span></span>,
  we here restrict to polynomials over the complex numbers. Since the result computations are homomorphisms,
  we are able to lift it to integer polynomials where we are interested in real or complex
  roots.›</span></span>
<span class="keyword1" id="Roots_of_Algebraic_Poly-resultant_mpoly_polys_solution"><span class="command">lemma</span></span> resultant_mpoly_polys_solution<span class="main">:</span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">p</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"complex mpoly"</span></span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> nz<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">∉</span> <span class="free">qs</span> <span class="main">`</span> <span class="free">N</span>"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> i<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">∈</span> <span class="free">N</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mpoly_polys_solution <span class="main">(</span>resultant_mpoly_poly <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span> <span class="free">p</span> <span class="main">(</span><span class="free">qs</span> <span class="free">i</span><span class="main">)</span><span class="main">)</span> <span class="free">qs</span> <span class="main">(</span><span class="free">N</span> <span class="main">-</span> <span class="main">{</span><span class="free">i</span><span class="main">}</span><span class="main">)</span> <span class="free">α</span>
  <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span> <span class="bound">v</span><span class="main">.</span> mpoly_polys_solution <span class="free">p</span> <span class="free">qs</span> <span class="free">N</span> <span class="main">(</span><span class="free">α</span><span class="main">(</span><span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span> <span class="main">:=</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?x</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"Suc <span class="free">i</span>"</span></span> 
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?q</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="free">qs</span> <span class="free">i</span>"</span></span> 
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?mres</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"resultant_mpoly_poly <span class="var">?x</span> <span class="free">p</span> <span class="var">?q</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> i <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">M</span></span> <span class="keyword2"><span class="keyword">where</span></span> N<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">N</span> <span class="main">=</span> insert <span class="free">i</span> <span class="skolem">M</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> MN<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">M</span> <span class="main">=</span> <span class="free">N</span> <span class="main">-</span> <span class="main">{</span><span class="free">i</span><span class="main">}</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> iM<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">∉</span> <span class="skolem">M</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> nz i <span class="keyword1"><span class="command">have</span></span> nzq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?q</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> lc0<span class="main">:</span> <span class="quoted"><span class="quoted">"lead_coeff <span class="main">(</span><span class="free">qs</span> <span class="free">i</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"mpoly_polys_solution <span class="var">?mres</span> <span class="free">qs</span> <span class="main">(</span><span class="free">N</span> <span class="main">-</span> <span class="main">{</span><span class="free">i</span><span class="main">}</span><span class="main">)</span> <span class="free">α</span> <span class="main">⟷</span>
   insertion <span class="free">α</span> <span class="var">?mres</span> <span class="main">=</span> <span class="main">0</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">i</span> <span class="main">∈</span> <span class="skolem">M</span><span class="main">.</span> poly <span class="main">(</span><span class="free">qs</span> <span class="bound">i</span><span class="main">)</span> <span class="main">(</span><span class="free">α</span> <span class="main">(</span>Suc <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> mpoly_polys_solution_def MN <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"insertion <span class="free">α</span> <span class="var">?mres</span> <span class="main">=</span> <span class="main">0</span> <span class="main">⟷</span> resultant <span class="main">(</span>partial_insertion <span class="free">α</span> <span class="var">?x</span> <span class="free">p</span><span class="main">)</span> <span class="var">?q</span> <span class="main">=</span> <span class="main">0</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> insertion_resultant_mpoly_poly_zero<span class="main"><span class="main">[</span></span><span class="operator">OF</span> nzq<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">v</span><span class="main">.</span> poly <span class="main">(</span>partial_insertion <span class="free">α</span> <span class="var">?x</span> <span class="free">p</span><span class="main">)</span> <span class="bound">v</span> <span class="main">=</span> <span class="main">0</span> <span class="main">∧</span> poly <span class="var">?q</span> <span class="bound">v</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> resultant_zero_iff_common_root_complex<span class="main"><span class="main">[</span></span><span class="operator">OF</span> nzq<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">v</span><span class="main">.</span> insertion <span class="main">(</span><span class="free">α</span><span class="main">(</span><span class="var">?x</span> <span class="main">:=</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span> <span class="free">p</span> <span class="main">=</span> <span class="main">0</span> <span class="main">∧</span> poly <span class="var">?q</span> <span class="bound">v</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> iff_exI conj_cong refl arg_cong<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">λ</span></span> <span class="bound"><span class="bound">x</span></span><span class="main"><span class="main">.</span></span> <span class="bound"><span class="bound">x</span></span> <span class="main"><span class="main">=</span></span> <span class="main"><span class="main">0</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">v</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"poly <span class="main">(</span>partial_insertion <span class="free">α</span> <span class="var">?x</span> <span class="free">p</span><span class="main">)</span> <span class="skolem">v</span> <span class="main">=</span> poly <span class="main">(</span>partial_insertion <span class="free">α</span> <span class="var">?x</span> <span class="free">p</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="free">α</span><span class="main">(</span><span class="var">?x</span> <span class="main">:=</span> <span class="skolem">v</span><span class="main">)</span><span class="main">)</span> <span class="var">?x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> insertion <span class="main">(</span><span class="free">α</span><span class="main">(</span><span class="var">?x</span> <span class="main">:=</span> <span class="skolem">v</span><span class="main">)</span><span class="main">)</span> <span class="free">p</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> insertion_partial_insertion<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"poly <span class="main">(</span>partial_insertion <span class="free">α</span> <span class="var">?x</span> <span class="free">p</span><span class="main">)</span> <span class="skolem">v</span> <span class="main">=</span> insertion <span class="main">(</span><span class="free">α</span><span class="main">(</span><span class="var">?x</span> <span class="main">:=</span> <span class="skolem">v</span><span class="main">)</span><span class="main">)</span> <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">i</span><span class="main">∈</span><span class="skolem">M</span><span class="main">.</span> poly <span class="main">(</span><span class="free">qs</span> <span class="bound">i</span><span class="main">)</span> <span class="main">(</span><span class="free">α</span> <span class="main">(</span>Suc <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span>
    <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">v</span><span class="main">.</span> insertion <span class="main">(</span><span class="free">α</span><span class="main">(</span><span class="var">?x</span> <span class="main">:=</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span> <span class="free">p</span> <span class="main">=</span> <span class="main">0</span> <span class="main">∧</span> poly <span class="main">(</span><span class="free">qs</span> <span class="free">i</span><span class="main">)</span> <span class="bound">v</span> <span class="main">=</span> <span class="main">0</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">i</span><span class="main">∈</span><span class="skolem">M</span><span class="main">.</span> poly <span class="main">(</span><span class="free">qs</span> <span class="bound">i</span><span class="main">)</span> <span class="main">(</span><span class="main">(</span><span class="free">α</span><span class="main">(</span><span class="var">?x</span> <span class="main">:=</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>Suc <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> iM <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span>  <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span> <span class="bound">v</span><span class="main">.</span> mpoly_polys_solution <span class="free">p</span> <span class="free">qs</span> <span class="free">N</span> <span class="main">(</span><span class="free">α</span><span class="main">(</span><span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span> <span class="main">:=</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> mpoly_polys_solution_def N <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> iff_exI<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We now restrict solutions to be evaluated to zero outside the variable range. Then there are only finitely 
  many solutions for our applications.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">mpoly_polys_zero_solution</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> field mpoly <span class="main">⇒</span> <span class="main">(</span>nat <span class="main">⇒</span> <span class="tfree">'a</span> poly<span class="main">)</span> <span class="main">⇒</span> nat set <span class="main">⇒</span> <span class="main">(</span>nat <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">mpoly_polys_zero_solution</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">qs</span></span></span> <span class="free"><span class="bound"><span class="entity">N</span></span></span> <span class="free"><span class="bound"><span class="entity">α</span></span></span> <span class="main">=</span> <span class="main">(</span>mpoly_polys_solution <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">qs</span></span></span> <span class="free"><span class="bound"><span class="entity">N</span></span></span> <span class="free"><span class="bound"><span class="entity">α</span></span></span>
    <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">i</span><span class="main">.</span> <span class="bound">i</span> <span class="main">∉</span> insert <span class="main">0</span> <span class="main">(</span>Suc <span class="main">`</span> <span class="free"><span class="bound"><span class="entity">N</span></span></span><span class="main">)</span> <span class="main">⟶</span> <span class="free"><span class="bound"><span class="entity">α</span></span></span> <span class="bound">i</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span>"</span></span> 

<span class="keyword1" id="Roots_of_Algebraic_Poly-resultant_mpoly_polys_zero_solution"><span class="command">lemma</span></span> resultant_mpoly_polys_zero_solution<span class="main">:</span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">p</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"complex mpoly"</span></span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> nz<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">∉</span> <span class="free">qs</span> <span class="main">`</span> <span class="free">N</span>"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> i<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">∈</span> <span class="free">N</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span> 
  <span class="quoted"><span class="quoted">"mpoly_polys_zero_solution <span class="main">(</span>resultant_mpoly_poly <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span> <span class="free">p</span> <span class="main">(</span><span class="free">qs</span> <span class="free">i</span><span class="main">)</span><span class="main">)</span> <span class="free">qs</span> <span class="main">(</span><span class="free">N</span> <span class="main">-</span> <span class="main">{</span><span class="free">i</span><span class="main">}</span><span class="main">)</span> <span class="free">α</span> 
    <span class="main">⟹</span> <span class="main">∃</span> <span class="bound">v</span><span class="main">.</span> mpoly_polys_zero_solution <span class="free">p</span> <span class="free">qs</span> <span class="free">N</span> <span class="main">(</span><span class="free">α</span><span class="main">(</span>Suc <span class="free">i</span> <span class="main">:=</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span>"</span></span> 
  <span class="quoted"><span class="quoted">"mpoly_polys_zero_solution <span class="free">p</span> <span class="free">qs</span> <span class="free">N</span> <span class="free">α</span> 
    <span class="main">⟹</span> mpoly_polys_zero_solution <span class="main">(</span>resultant_mpoly_poly <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span> <span class="free">p</span> <span class="main">(</span><span class="free">qs</span> <span class="free">i</span><span class="main">)</span><span class="main">)</span> <span class="free">qs</span> <span class="main">(</span><span class="free">N</span> <span class="main">-</span> <span class="main">{</span><span class="free">i</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="free">α</span><span class="main">(</span>Suc <span class="free">i</span> <span class="main">:=</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"mpoly_polys_zero_solution <span class="main">(</span>resultant_mpoly_poly <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span> <span class="free">p</span> <span class="main">(</span><span class="free">qs</span> <span class="free">i</span><span class="main">)</span><span class="main">)</span> <span class="free">qs</span> <span class="main">(</span><span class="free">N</span> <span class="main">-</span> <span class="main">{</span><span class="free">i</span><span class="main">}</span><span class="main">)</span> <span class="free">α</span>"</span></span> 
  <span class="keyword1"><span class="command">hence</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"mpoly_polys_solution <span class="main">(</span>resultant_mpoly_poly <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span> <span class="free">p</span> <span class="main">(</span><span class="free">qs</span> <span class="free">i</span><span class="main">)</span><span class="main">)</span> <span class="free">qs</span> <span class="main">(</span><span class="free">N</span> <span class="main">-</span> <span class="main">{</span><span class="free">i</span><span class="main">}</span><span class="main">)</span> <span class="free">α</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> 2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span> <span class="bound">i</span><span class="main">.</span> <span class="bound">i</span> <span class="main">∉</span> insert <span class="main">0</span> <span class="main">(</span>Suc <span class="main">`</span> <span class="main">(</span><span class="free">N</span> <span class="main">-</span> <span class="main">{</span><span class="bound">i</span><span class="main">}</span><span class="main">)</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">α</span> <span class="bound">i</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> mpoly_polys_zero_solution_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> resultant_mpoly_polys_solution<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">qs</span></span> <span class="quoted"><span class="free">N</span></span> <span class="main">_</span> <span class="quoted"><span class="free">p</span></span> <span class="quoted"><span class="free">α</span></span><span class="main">,</span> <span class="operator">OF</span> nz i<span class="main">]</span> 1 <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"mpoly_polys_solution <span class="free">p</span> <span class="free">qs</span> <span class="free">N</span> <span class="main">(</span><span class="free">α</span><span class="main">(</span>Suc <span class="free">i</span> <span class="main">:=</span> <span class="skolem">v</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> 2 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"mpoly_polys_zero_solution <span class="free">p</span> <span class="free">qs</span> <span class="free">N</span> <span class="main">(</span><span class="free">α</span><span class="main">(</span>Suc <span class="free">i</span> <span class="main">:=</span> <span class="skolem">v</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> i <span class="keyword1"><span class="command">unfolding</span></span> mpoly_polys_zero_solution_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">v</span><span class="main">.</span> mpoly_polys_zero_solution <span class="free">p</span> <span class="free">qs</span> <span class="free">N</span> <span class="main">(</span><span class="free">α</span><span class="main">(</span>Suc <span class="free">i</span> <span class="main">:=</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"mpoly_polys_zero_solution <span class="free">p</span> <span class="free">qs</span> <span class="free">N</span> <span class="free">α</span>"</span></span> 
  <span class="keyword1"><span class="command">from</span></span> this<span class="main">[</span><span class="operator">unfolded</span> mpoly_polys_zero_solution_def<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"mpoly_polys_solution <span class="free">p</span> <span class="free">qs</span> <span class="free">N</span> <span class="free">α</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> 2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">i</span><span class="main">.</span> <span class="bound">i</span> <span class="main">∉</span> insert <span class="main">0</span> <span class="main">(</span>Suc <span class="main">`</span> <span class="free">N</span><span class="main">)</span> <span class="main">⟶</span> <span class="free">α</span> <span class="bound">i</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> 1 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"mpoly_polys_solution <span class="free">p</span> <span class="free">qs</span> <span class="free">N</span> <span class="main">(</span><span class="free">α</span><span class="main">(</span>Suc <span class="free">i</span> <span class="main">:=</span> <span class="free">α</span> <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">v</span><span class="main">.</span> mpoly_polys_solution <span class="free">p</span> <span class="free">qs</span> <span class="free">N</span> <span class="main">(</span><span class="free">α</span><span class="main">(</span>Suc <span class="free">i</span> <span class="main">:=</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">with</span></span> resultant_mpoly_polys_solution<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">qs</span></span> <span class="quoted"><span class="free">N</span></span> <span class="main">_</span> <span class="quoted"><span class="free">p</span></span> <span class="quoted"><span class="free">α</span></span><span class="main">,</span> <span class="operator">OF</span> nz i<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"mpoly_polys_solution <span class="main">(</span>resultant_mpoly_poly <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span> <span class="free">p</span> <span class="main">(</span><span class="free">qs</span> <span class="free">i</span><span class="main">)</span><span class="main">)</span> <span class="free">qs</span> <span class="main">(</span><span class="free">N</span> <span class="main">-</span> <span class="main">{</span><span class="free">i</span><span class="main">}</span><span class="main">)</span> <span class="free">α</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"mpoly_polys_solution <span class="main">(</span>resultant_mpoly_poly <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span> <span class="free">p</span> <span class="main">(</span><span class="free">qs</span> <span class="free">i</span><span class="main">)</span><span class="main">)</span> <span class="free">qs</span> <span class="main">(</span><span class="free">N</span> <span class="main">-</span> <span class="main">{</span><span class="free">i</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="free">α</span> <span class="main">(</span>Suc <span class="free">i</span> <span class="main">:=</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> mpoly_polys_solution_def 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> insertion_irrelevant_vars<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">α</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">insert</span> vars_resultant_mpoly_poly<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"mpoly_polys_zero_solution <span class="main">(</span>resultant_mpoly_poly <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span> <span class="free">p</span> <span class="main">(</span><span class="free">qs</span> <span class="free">i</span><span class="main">)</span><span class="main">)</span> <span class="free">qs</span> <span class="main">(</span><span class="free">N</span> <span class="main">-</span> <span class="main">{</span><span class="free">i</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="free">α</span><span class="main">(</span>Suc <span class="free">i</span> <span class="main">:=</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> mpoly_polys_zero_solution_def <span class="keyword1"><span class="command">using</span></span> 2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The following two lemmas show that if we start with a system of polynomials with finitely
  many solutions, then the resulting polynomial cannot be the zero-polynomial.›</span></span>
<span class="keyword1" id="Roots_of_Algebraic_Poly-finite_resultant_mpoly_polys_non_empty"><span class="command">lemma</span></span> finite_resultant_mpoly_polys_non_empty<span class="main">:</span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">p</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"complex mpoly"</span></span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> nz<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">∉</span> <span class="free">qs</span> <span class="main">`</span> <span class="free">N</span>"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> i<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">∈</span> <span class="free">N</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> fin<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">{</span><span class="bound">α</span><span class="main">.</span> mpoly_polys_zero_solution <span class="free">p</span> <span class="free">qs</span> <span class="free">N</span> <span class="bound">α</span><span class="main">}</span>"</span></span> 
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">{</span><span class="bound">α</span><span class="main">.</span> mpoly_polys_zero_solution <span class="main">(</span>resultant_mpoly_poly <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span> <span class="free">p</span> <span class="main">(</span><span class="free">qs</span> <span class="free">i</span><span class="main">)</span><span class="main">)</span> <span class="free">qs</span> <span class="main">(</span><span class="free">N</span> <span class="main">-</span> <span class="main">{</span><span class="free">i</span><span class="main">}</span><span class="main">)</span> <span class="bound">α</span><span class="main">}</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?solN</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"mpoly_polys_zero_solution <span class="free">p</span> <span class="free">qs</span> <span class="free">N</span>"</span></span> 
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?solN1</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"mpoly_polys_zero_solution <span class="main">(</span>resultant_mpoly_poly <span class="main">(</span>Suc <span class="free">i</span><span class="main">)</span> <span class="free">p</span> <span class="main">(</span><span class="free">qs</span> <span class="free">i</span><span class="main">)</span><span class="main">)</span> <span class="free">qs</span> <span class="main">(</span><span class="free">N</span> <span class="main">-</span> <span class="main">{</span><span class="free">i</span><span class="main">}</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?x</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"Suc <span class="free">i</span>"</span></span> 
  <span class="keyword1"><span class="command">note</span></span> defs <span class="main">=</span> mpoly_polys_zero_solution_def
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">zero</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">zero</span> <span class="skolem">α</span> <span class="main">=</span> <span class="skolem">α</span><span class="main">(</span><span class="var">?x</span> <span class="main">:=</span> <span class="main">0</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">α</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> complex"</span></span> 
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">α</span>
    <span class="keyword3"><span class="command">assume</span></span> sol<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?solN1</span> <span class="skolem">α</span>"</span></span> 
    <span class="keyword1"><span class="command">from</span></span> sol<span class="main">[</span><span class="operator">unfolded</span> defs<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> 0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">α</span> <span class="var">?x</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> resultant_mpoly_polys_zero_solution<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">qs</span></span> <span class="quoted"><span class="free">N</span></span> <span class="quoted"><span class="free">i</span></span> <span class="quoted"><span class="free">p</span></span><span class="main">,</span> <span class="operator">OF</span> nz i sol<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">v</span></span> 
      <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="var">?solN</span> <span class="main">(</span><span class="skolem">α</span><span class="main">(</span><span class="var">?x</span> <span class="main">:=</span> <span class="skolem">v</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> sol<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">α</span><span class="main">(</span><span class="var">?x</span> <span class="main">:=</span> <span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> <span class="main">{</span><span class="bound">α</span><span class="main">.</span> <span class="var">?solN</span> <span class="bound">α</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">zero</span> <span class="main">(</span><span class="skolem">α</span><span class="main">(</span><span class="var">?x</span> <span class="main">:=</span> <span class="skolem">v</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> <span class="skolem">zero</span> <span class="main">`</span> <span class="main">{</span><span class="bound">α</span><span class="main">.</span> <span class="var">?solN</span> <span class="bound">α</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">zero</span> <span class="main">(</span><span class="skolem">α</span><span class="main">(</span><span class="var">?x</span> <span class="main">:=</span> <span class="skolem">v</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">α</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> 0 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> zero_def<span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">α</span> <span class="main">∈</span> <span class="skolem">zero</span> <span class="main">`</span> <span class="main">{</span><span class="bound">α</span><span class="main">.</span> <span class="var">?solN</span> <span class="bound">α</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">α</span><span class="main">.</span> <span class="var">?solN1</span> <span class="bound">α</span><span class="main">}</span> <span class="main">⊆</span> <span class="skolem">zero</span> <span class="main">`</span> <span class="main">{</span><span class="bound">α</span><span class="main">.</span> <span class="var">?solN</span> <span class="bound">α</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">from</span></span> finite_subset<span class="main">[</span><span class="operator">OF</span> this finite_imageI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> fin<span class="main"><span class="main">]</span></span><span class="main">]</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Roots_of_Algebraic_Poly-finite_resultant_mpoly_polys_empty"><span class="command">lemma</span></span> finite_resultant_mpoly_polys_empty<span class="main">:</span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">p</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"complex mpoly"</span></span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">{</span><span class="bound">α</span><span class="main">.</span> mpoly_polys_zero_solution <span class="free">p</span> <span class="free">qs</span> <span class="main">{}</span> <span class="bound">α</span><span class="main">}</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">g</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">g</span> <span class="skolem">x</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">i</span> <span class="main">::</span> nat<span class="main">.</span> <span class="keyword1">if</span> <span class="bound">i</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="skolem">x</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="quoted">complex</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">=</span> <span class="main">0</span>"</span></span> 
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span> <span class="bound">x</span><span class="main">.</span> mpoly_polys_zero_solution <span class="free">p</span> <span class="free">qs</span> <span class="main">{}</span> <span class="main">(</span><span class="skolem">g</span> <span class="bound">x</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> mpoly_polys_zero_solution_def mpoly_polys_solution_def g_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"range <span class="skolem">g</span> <span class="main">⊆</span> <span class="main">{</span><span class="bound">α</span><span class="main">.</span> mpoly_polys_zero_solution <span class="free">p</span> <span class="free">qs</span> <span class="main">{}</span> <span class="bound">α</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> finite_subset<span class="main">[</span><span class="operator">OF</span> this assms<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>range <span class="skolem">g</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"inj <span class="skolem">g</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> g_def inj_on_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>UNIV <span class="main">::</span> complex set<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">using</span></span> infinite_UNIV_char_0 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Elimination of Auxiliary Variables›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">eliminate_aux_vars</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> comm_ring_1 mpoly <span class="main">⇒</span> <span class="main">(</span>nat <span class="main">⇒</span> <span class="tfree">'a</span> poly<span class="main">)</span> <span class="main">⇒</span> nat list <span class="main">⇒</span> <span class="tfree">'a</span> poly"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">eliminate_aux_vars</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">qs</span></span></span> <span class="main">[]</span> <span class="main">=</span> mpoly_to_poly <span class="main">0</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span>"</span></span> 
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">eliminate_aux_vars</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">qs</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">is</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">eliminate_aux_vars</span> <span class="main">(</span>resultant_mpoly_poly <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">qs</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">qs</span></span></span> <span class="free"><span class="bound"><span class="entity">is</span></span></span>"</span></span> 
      

<span class="keyword1" id="Roots_of_Algebraic_Poly-eliminate_aux_vars_of_int_poly"><span class="command">lemma</span></span> eliminate_aux_vars_of_int_poly<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"eliminate_aux_vars <span class="main">(</span>map_mpoly <span class="main">(</span>of_int <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">::</span> <span class="main">{</span>comm_ring_1<span class="main">,</span>ring_char_0<span class="main">}</span><span class="main">)</span> <span class="free">mp</span><span class="main">)</span> <span class="main">(</span>of_int_poly <span class="main">∘</span> <span class="free">qs</span><span class="main">)</span> <span class="free">is</span>
  <span class="main">=</span> of_int_poly <span class="main">(</span>eliminate_aux_vars <span class="free">mp</span> <span class="free">qs</span> <span class="free">is</span><span class="main">)</span>"</span></span>  
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?h</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"of_int <span class="main">::</span> <span class="main">_</span> <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> 
  <span class="keyword1"><span class="command">interpret</span></span> mp<span class="main">:</span> comm_ring_hom <span class="quoted"><span class="quoted">"<span class="main">(</span>map_mpoly <span class="var">?h</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> of_int_hom.comm_ring_hom_mpoly_map<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="quoted">"<span class="free">is</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">mp</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> Nil
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> of_int_hom.mpoly_to_poly_map_mpoly_hom<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">i</span> <span class="quoted">"<span class="skolem">is</span>"</span> <span class="skolem">mp</span><span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> eliminate_aux_vars.simps Cons<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> arg_cong<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">λ</span></span> <span class="bound"><span class="bound">x</span></span><span class="main"><span class="main">.</span></span> eliminate_aux_vars <span class="bound"><span class="bound">x</span></span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">unfold</span> o_def<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> of_int_hom.resultant_mpoly_poly_hom<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The polynomial of the elimination process will represent the first value <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">α</span></span> <span class="main"><span class="main">0</span></span> <span class="main"><span class="main">::</span></span> complex"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> of any
  solution to the multi-polynomial problem.›</span></span>
<span class="keyword1" id="Roots_of_Algebraic_Poly-eliminate_aux_vars"><span class="command">lemma</span></span> eliminate_aux_vars<span class="main">:</span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">p</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"complex mpoly"</span></span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"distinct <span class="free">is</span>"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"vars <span class="free">p</span> <span class="main">⊆</span> insert <span class="main">0</span> <span class="main">(</span>Suc <span class="main">`</span> set <span class="free">is</span><span class="main">)</span>"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">{</span><span class="bound">α</span><span class="main">.</span> mpoly_polys_zero_solution <span class="free">p</span> <span class="free">qs</span> <span class="main">(</span>set <span class="free">is</span><span class="main">)</span> <span class="bound">α</span><span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">∉</span> <span class="free">qs</span> <span class="main">`</span> set <span class="free">is</span>"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"mpoly_polys_solution <span class="free">p</span> <span class="free">qs</span> <span class="main">(</span>set <span class="free">is</span><span class="main">)</span> <span class="free">α</span>"</span></span> 
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"poly <span class="main">(</span>eliminate_aux_vars <span class="free">p</span> <span class="free">qs</span> <span class="free">is</span><span class="main">)</span> <span class="main">(</span><span class="free">α</span> <span class="main">0</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span> <span class="main">∧</span> eliminate_aux_vars <span class="free">p</span> <span class="free">qs</span> <span class="free">is</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="quoted">"<span class="free">is</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Nil <span class="skolem">p</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> Nil<span class="main">(</span>3<span class="main">)</span> finite_resultant_mpoly_polys_empty<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">p</span></span><span class="main">]</span> 
  <span class="keyword1"><span class="command">have</span></span> p0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> Nil<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> vars<span class="main">:</span> <span class="quoted"><span class="quoted">"vars <span class="skolem">p</span> <span class="main">⊆</span> <span class="main">{</span><span class="main">0</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">note</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> poly_eq_insertion<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span>
  <span class="keyword1"><span class="command">from</span></span> Nil<span class="main">(</span>5<span class="main">)</span><span class="main">[</span><span class="operator">unfolded</span> mpoly_polys_solution_def<span class="main">]</span> 
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"insertion <span class="free">α</span> <span class="skolem">p</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"insertion <span class="free">α</span> <span class="skolem">p</span> <span class="main">=</span> insertion <span class="main">(</span><span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="free">α</span> <span class="main">0</span><span class="main">)</span> <span class="skolem">p</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> insertion_irrelevant_vars<span class="main"><span class="keyword3">,</span></span> <span class="operator">insert</span> vars<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> p0 mpoly_to_poly_inverse<span class="main">[</span><span class="operator">OF</span> vars<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> poly_to_mpoly0<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">i</span> <span class="quoted">"<span class="skolem">is</span>"</span> <span class="skolem">p</span><span class="main">)</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?x</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"Suc <span class="skolem">i</span>"</span></span> 
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?p</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"resultant_mpoly_poly <span class="var">?x</span> <span class="skolem">p</span> <span class="main">(</span><span class="free">qs</span> <span class="skolem">i</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> dist<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="skolem">is</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Cons<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> vars<span class="main">:</span> <span class="quoted"><span class="quoted">"vars <span class="var">?p</span> <span class="main">⊆</span> insert <span class="main">0</span> <span class="main">(</span>Suc <span class="main">`</span> set <span class="skolem">is</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Cons<span class="main">(</span>3<span class="main">)</span> vars_resultant_mpoly_poly<span class="main">[</span><span class="operator">of</span> <span class="var"><span class="quoted"><span class="var">?x</span></span></span> <span class="quoted"><span class="skolem">p</span></span> <span class="quoted"><span class="quoted">"<span class="free">qs</span> <span class="skolem">i</span>"</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> fin<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">{</span><span class="bound">α</span><span class="main">.</span> mpoly_polys_zero_solution <span class="var">?p</span> <span class="free">qs</span> <span class="main">(</span>set <span class="skolem">is</span><span class="main">)</span> <span class="bound">α</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> finite_resultant_mpoly_polys_non_empty<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">qs</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">i</span> <span class="main">#</span> <span class="skolem">is</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="skolem">i</span></span> <span class="quoted"><span class="skolem">p</span></span><span class="main">,</span> <span class="operator">OF</span> Cons<span class="main"><span class="main">(</span></span>5<span class="main"><span class="main">)</span></span><span class="main">]</span> Cons<span class="main">(</span>2<span class="main">,</span>4<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> 0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">∉</span> <span class="free">qs</span> <span class="main">`</span> set <span class="skolem">is</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Cons<span class="main">(</span>5<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∃</span><span class="bound">v</span><span class="main">.</span> mpoly_polys_solution <span class="skolem">p</span> <span class="free">qs</span> <span class="main">(</span>set <span class="main">(</span><span class="skolem">i</span> <span class="main">#</span> <span class="skolem">is</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free">α</span><span class="main">(</span><span class="var">?x</span> <span class="main">:=</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> Cons<span class="main">(</span>6<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> exI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free"><span class="free">α</span></span></span> <span class="var"><span class="var"><span class="var">?x</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> this resultant_mpoly_polys_solution<span class="main">[</span><span class="operator">OF</span> Cons<span class="main"><span class="main">(</span></span>5<span class="main"><span class="main">)</span></span><span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="skolem">i</span></span> <span class="quoted"><span class="skolem">p</span></span> <span class="quoted"><span class="free">α</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"mpoly_polys_solution <span class="var">?p</span> <span class="free">qs</span> <span class="main">(</span>set <span class="main">(</span><span class="skolem">i</span> <span class="main">#</span> <span class="skolem">is</span><span class="main">)</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">i</span><span class="main">}</span><span class="main">)</span> <span class="free">α</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">i</span> <span class="main">#</span> <span class="skolem">is</span><span class="main">)</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">i</span><span class="main">}</span> <span class="main">=</span> set <span class="skolem">is</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Cons<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"mpoly_polys_solution <span class="var">?p</span> <span class="free">qs</span> <span class="main">(</span>set <span class="skolem">is</span><span class="main">)</span> <span class="free">α</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">note</span></span> IH <span class="main">=</span> Cons<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> dist vars fin 0 this<span class="main">]</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> eliminate_aux_vars.simps <span class="keyword1"><span class="command">using</span></span> IH <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹A Representing Polynomial for the Roots of a Polynomial with Algebraic Coefficients›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹First convert an algebraic polynomial into a system of integer polynomials.›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">initial_root_problem</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> <span class="main">{</span>is_rat<span class="main">,</span>field_gcd<span class="main">}</span> poly <span class="main">⇒</span> int mpoly <span class="main">×</span> <span class="main">(</span>nat <span class="main">×</span> <span class="tfree">'a</span> <span class="main">×</span> int poly<span class="main">)</span> list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">initial_root_problem</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> 
      <span class="bound">n</span> <span class="main">=</span> degree <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">;</span>
      <span class="bound">cs</span> <span class="main">=</span> coeffs <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">;</span>
      <span class="bound">rcs</span> <span class="main">=</span> remdups <span class="main">(</span>filter <span class="main">(</span><span class="main">λ</span> <span class="bound">c</span><span class="main">.</span> <span class="bound">c</span> <span class="main">∉</span> <span class="main">ℤ</span><span class="main">)</span> <span class="bound">cs</span><span class="main">)</span><span class="main">;</span>
      <span class="bound">pairs</span> <span class="main">=</span> map <span class="main">(</span><span class="main">λ</span> <span class="bound">c</span><span class="main">.</span> <span class="main">(</span><span class="bound">c</span><span class="main">,</span> min_int_poly <span class="bound">c</span><span class="main">)</span><span class="main">)</span> <span class="bound">rcs</span><span class="main">;</span>
      <span class="bound">spairs</span> <span class="main">=</span> sort_key <span class="main">(</span><span class="main">λ</span> <span class="main">(</span><span class="bound">c</span><span class="main">,</span><span class="bound">f</span><span class="main">)</span><span class="main">.</span> degree <span class="bound">f</span><span class="main">)</span> <span class="bound">pairs</span><span class="main">;</span> <span class="comment1">― ‹sort by degree so that easy computations will be done first›</span>
      <span class="bound">triples</span> <span class="main">=</span> zip <span class="main">[</span><span class="main">0</span> <span class="main">..&lt;</span> length <span class="bound">spairs</span><span class="main">]</span> <span class="bound">spairs</span><span class="main">;</span>
      <span class="bound">mpoly</span> <span class="main">=</span> <span class="main">(</span>sum <span class="main">(</span><span class="main">λ</span> <span class="bound">i</span><span class="main">.</span> <span class="keyword1">let</span> <span class="bound">c</span> <span class="main">=</span> coeff <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="bound">i</span> <span class="keyword1">in</span>
            MPoly_Type.monom <span class="main">(</span>Poly_Mapping.single <span class="main">0</span> <span class="bound">i</span><span class="main">)</span> <span class="main">1</span> <span class="main">*</span> <span class="comment1">― ‹$x_0 ^ i * ...$›</span>
             <span class="main">(</span><span class="keyword1">case</span> find <span class="main">(</span><span class="main">λ</span> <span class="main">(</span><span class="bound">j</span><span class="main">,</span><span class="bound">d</span><span class="main">,</span><span class="bound">f</span><span class="main">)</span><span class="main">.</span> <span class="bound">d</span> <span class="main">=</span> <span class="bound">c</span><span class="main">)</span> <span class="bound">triples</span> <span class="keyword1">of</span> 
             None <span class="main">⇒</span> Const <span class="main">(</span>to_int <span class="bound">c</span><span class="main">)</span>
           <span class="main">|</span> Some <span class="main">(</span><span class="bound">j</span><span class="main">,</span><span class="bound">pair</span><span class="main">)</span> <span class="main">⇒</span> Var <span class="main">(</span>Suc <span class="bound">j</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
             <span class="main">{..</span><span class="bound">n</span><span class="main">}</span><span class="main">)</span>
     <span class="keyword1">in</span> <span class="main">(</span><span class="bound">mpoly</span><span class="main">,</span> <span class="bound">triples</span><span class="main">)</span><span class="main">)</span>"</span></span> 

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹And then eliminate all auxiliary variables›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">representative_poly</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> <span class="main">{</span>is_rat<span class="main">,</span>field_char_0<span class="main">,</span>field_gcd<span class="main">}</span> poly <span class="main">⇒</span> int poly"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">representative_poly</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> initial_root_problem <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="keyword1">of</span>
     <span class="main">(</span><span class="bound">mp</span><span class="main">,</span> <span class="bound">triples</span><span class="main">)</span> <span class="main">⇒</span> 
     <span class="keyword1">let</span> <span class="bound">is</span> <span class="main">=</span> map fst <span class="bound">triples</span><span class="main">;</span>
         <span class="bound">qs</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">j</span><span class="main">.</span> snd <span class="main">(</span>snd <span class="main">(</span><span class="bound">triples</span> <span class="main">!</span> <span class="bound">j</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
       <span class="keyword1">in</span> eliminate_aux_vars <span class="bound">mp</span> <span class="bound">qs</span> <span class="bound">is</span><span class="main">)</span>"</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Soundness Proof for Complex Algebraic Polynomials›</span></span>

<span class="keyword1" id="Roots_of_Algebraic_Poly-get_representative_complex"><span class="command">lemma</span></span> get_representative_complex<span class="main">:</span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">p</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"complex poly"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> p<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> algebraic<span class="main">:</span> <span class="quoted"><span class="quoted">"Ball <span class="main">(</span>set <span class="main">(</span>coeffs <span class="free">p</span><span class="main">)</span><span class="main">)</span> algebraic"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> res<span class="main">:</span> <span class="quoted"><span class="quoted">"initial_root_problem <span class="free">p</span> <span class="main">=</span> <span class="main">(</span><span class="free">mp</span><span class="main">,</span> <span class="free">triples</span><span class="main">)</span>"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted">"is"</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">is</span> <span class="main">=</span> map fst <span class="free">triples</span>"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> qs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">j</span><span class="main">.</span> <span class="bound">j</span> <span class="main">&lt;</span> length <span class="free">is</span> <span class="main">⟹</span> <span class="free">qs</span> <span class="bound">j</span> <span class="main">=</span> snd <span class="main">(</span>snd <span class="main">(</span><span class="free">triples</span> <span class="main">!</span> <span class="bound">j</span><span class="main">)</span><span class="main">)</span>"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> root<span class="main">:</span> <span class="quoted"><span class="quoted">"poly <span class="free">p</span> <span class="free">x</span> <span class="main">=</span> <span class="main">0</span>"</span></span> 
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"eliminate_aux_vars <span class="free">mp</span> <span class="free">qs</span> <span class="free">is</span> <span class="keyword1">represents</span> <span class="free">x</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">rcs</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">rcs</span> <span class="main">=</span> remdups <span class="main">(</span>filter <span class="main">(</span><span class="main">λ</span><span class="bound">c</span><span class="main">.</span> <span class="bound">c</span> <span class="main">∉</span> <span class="main">ℤ</span><span class="main">)</span> <span class="main">(</span>coeffs <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span> 
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">spairs</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">spairs</span> <span class="main">=</span> sort_key <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">c</span><span class="main">,</span> <span class="bound">f</span><span class="main">)</span><span class="main">.</span> degree <span class="bound">f</span><span class="main">)</span> <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">c</span><span class="main">.</span> <span class="main">(</span><span class="bound">c</span><span class="main">,</span> min_int_poly <span class="bound">c</span><span class="main">)</span><span class="main">)</span> <span class="skolem">rcs</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?find</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="bound">i</span><span class="main">.</span> find <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">j</span><span class="main">,</span> <span class="bound">d</span><span class="main">,</span> <span class="bound">f</span><span class="main">)</span><span class="main">.</span> <span class="bound">d</span> <span class="main">=</span> coeff <span class="free">p</span> <span class="bound">i</span><span class="main">)</span> <span class="free">triples</span>"</span></span> 
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">trans</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">trans</span> <span class="skolem">i</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="var">?find</span> <span class="skolem">i</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Const <span class="main">(</span>to_int <span class="main">(</span>coeff <span class="free">p</span> <span class="skolem">i</span><span class="main">)</span><span class="main">)</span> 
     <span class="main">|</span> Some <span class="main">(</span><span class="bound">j</span><span class="main">,</span> <span class="bound">pair</span><span class="main">)</span> <span class="main">⇒</span> Var <span class="main">(</span>Suc <span class="bound">j</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">i</span> 
  <span class="keyword1"><span class="command">note</span></span> res <span class="main">=</span> res<span class="main">[</span><span class="operator">unfolded</span> initial_root_problem_def Let_def<span class="main">,</span> <span class="operator">folded</span> rcs_def<span class="main">,</span> <span class="operator">folded</span> spairs_def<span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> triples<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">triples</span> <span class="main">=</span> zip <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span>length <span class="skolem">spairs</span><span class="main">]</span> <span class="skolem">spairs</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> res <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">note</span></span> res <span class="main">=</span> res<span class="main">[</span><span class="operator">folded</span> triples<span class="main">,</span> <span class="operator">folded</span> trans_def<span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> mp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">mp</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">i</span><span class="main">≤</span>degree <span class="free">p</span><span class="main">.</span> MPoly_Type.monom <span class="main">(</span>Poly_Mapping.single <span class="main">0</span> <span class="bound">i</span><span class="main">)</span> <span class="main">1</span> <span class="main">*</span> <span class="skolem">trans</span> <span class="bound">i</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> res <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> dist_rcs<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="skolem">rcs</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> rcs_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map fst <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">c</span><span class="main">.</span> <span class="main">(</span><span class="bound">c</span><span class="main">,</span> min_int_poly <span class="bound">c</span><span class="main">)</span><span class="main">)</span> <span class="skolem">rcs</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> o_def<span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> dist_spairs<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map fst <span class="skolem">spairs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> spairs_def 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> distinct_map distinct_sort set_sort<span class="main">)</span>
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">c</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="main">∈</span> set <span class="skolem">rcs</span>"</span></span> 
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="main">∈</span> set <span class="main">(</span>coeffs <span class="free">p</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> rcs_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> algebraic <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"algebraic <span class="skolem">c</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> rcs_alg <span class="main">=</span> this
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">c</span>
    <span class="keyword3"><span class="command">assume</span></span> c<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="main">∈</span> range <span class="main">(</span>coeff <span class="free">p</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="main">∉</span> <span class="main">ℤ</span>"</span></span> 
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="main">∈</span> set <span class="main">(</span>coeffs <span class="free">p</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> range_coeff <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> c <span class="keyword1"><span class="command">have</span></span> crcs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="main">∈</span> set <span class="skolem">rcs</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> rcs_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> rcs_alg<span class="main">[</span><span class="operator">OF</span> crcs<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"algebraic <span class="skolem">c</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">from</span></span> min_int_poly_represents<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"min_int_poly <span class="skolem">c</span> <span class="keyword1">represents</span> <span class="skolem">c</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">f</span><span class="main">.</span> <span class="main">(</span><span class="skolem">c</span><span class="main">,</span><span class="bound">f</span><span class="main">)</span> <span class="main">∈</span> set <span class="skolem">spairs</span> <span class="main">∧</span> <span class="bound">f</span> <span class="keyword1">represents</span> <span class="skolem">c</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> crcs <span class="keyword1"><span class="command">unfolding</span></span> spairs_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">have</span></span> dist_is<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="free">is</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> <span class="quoted">"is"</span> triples <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">note</span></span> eliminate <span class="main">=</span> eliminate_aux_vars<span class="main">[</span><span class="operator">OF</span> dist_is<span class="main">]</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?mp</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"map_mpoly of_int <span class="free">mp</span> <span class="main">::</span> complex mpoly"</span></span> 
  <span class="keyword1"><span class="command">have</span></span> vars_mp<span class="main">:</span> <span class="quoted"><span class="quoted">"vars <span class="free">mp</span> <span class="main">⊆</span> insert <span class="main">0</span> <span class="main">(</span>Suc <span class="main">`</span> set <span class="free">is</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> mp
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order.trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> vars_setsum<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">force</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> UN_least<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> order.trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> vars_mult<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> Un_least<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> order.trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> vars_monom_single<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">force</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> i 
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="var">?find</span> <span class="skolem">i</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> None 
        <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> trans_def None <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Some <span class="skolem">j_pair</span><span class="main">)</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">j</span></span> <span class="skolem"><span class="skolem">c</span></span> <span class="skolem"><span class="skolem">f</span></span> <span class="keyword2"><span class="keyword">where</span></span> find<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?find</span> <span class="skolem">i</span> <span class="main">=</span> Some <span class="main">(</span><span class="skolem">j</span><span class="main">,</span><span class="skolem">c</span><span class="main">,</span><span class="skolem">f</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">j_pair</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
        <span class="keyword1"><span class="command">from</span></span> find_Some_D<span class="main">[</span><span class="operator">OF</span> find<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Suc <span class="skolem">j</span> <span class="main">∈</span> Suc <span class="main">`</span> <span class="main">(</span>fst <span class="main">`</span> set <span class="free">triples</span><span class="main">)</span>"</span></span>  <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> trans_def find <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> vars_Var <span class="quoted">"is"</span><span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">hence</span></span> varsMp<span class="main">:</span> <span class="quoted"><span class="quoted">"vars <span class="var">?mp</span> <span class="main">⊆</span> insert <span class="main">0</span> <span class="main">(</span>Suc <span class="main">`</span> set <span class="free">is</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> vars_map_mpoly_subset <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">note</span></span> eliminate <span class="main">=</span> eliminate<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?f</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="bound">j</span><span class="main">.</span> snd <span class="main">(</span>snd <span class="main">(</span><span class="free">triples</span> <span class="main">!</span> <span class="bound">j</span><span class="main">)</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?c</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="bound">j</span><span class="main">.</span> fst <span class="main">(</span>snd <span class="main">(</span><span class="free">triples</span> <span class="main">!</span> <span class="bound">j</span><span class="main">)</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">j</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">∈</span> set <span class="free">is</span>"</span></span> 
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?c</span> <span class="skolem">j</span><span class="main">,</span> <span class="var">?f</span> <span class="skolem">j</span><span class="main">)</span> <span class="main">∈</span> set <span class="skolem">spairs</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> <span class="quoted">"is"</span> triples <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="var">?f</span> <span class="skolem">j</span> <span class="keyword1">represents</span> <span class="var">?c</span> <span class="skolem">j</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="var">?f</span> <span class="skolem">j</span> <span class="main">=</span> min_int_poly <span class="main">(</span><span class="var">?c</span> <span class="skolem">j</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> spairs_def 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> min_int_poly_represents<span class="main"><span class="main">[</span></span><span class="operator">OF</span> rcs_alg<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> is_repr <span class="main">=</span> this
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?qs</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>of_int_poly <span class="keyword1">o</span> <span class="free">qs</span><span class="main">)</span> <span class="main">::</span> nat <span class="main">⇒</span> complex poly"</span></span> 
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">j</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">∈</span> set <span class="free">is</span>"</span></span> 
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">&lt;</span> length <span class="free">is</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> <span class="quoted">"is"</span> triples <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> j_len <span class="main">=</span> this
  <span class="keyword1"><span class="command">have</span></span> qs_0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">∉</span> <span class="free">qs</span> <span class="main">`</span> set <span class="free">is</span>"</span></span> 
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">∈</span> <span class="free">qs</span> <span class="main">`</span> set <span class="free">is</span>"</span></span> 
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">j</span></span> <span class="keyword2"><span class="keyword">where</span></span> j<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">∈</span> set <span class="free">is</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> 0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">qs</span> <span class="skolem">j</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> is_repr<span class="main">[</span><span class="operator">OF</span> j<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?f</span> <span class="skolem">j</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> 0 <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">unfolding</span></span> qs<span class="main">[</span><span class="operator">OF</span> j_len<span class="main"><span class="main">[</span></span><span class="operator">OF</span> j<span class="main"><span class="main">]</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">hence</span></span> qs0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">∉</span> <span class="var">?qs</span> <span class="main">`</span> set <span class="free">is</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">note</span></span> eliminate <span class="main">=</span> eliminate<span class="main">[</span><span class="operator">OF</span> _ this<span class="main">]</span> 
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">roots</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">roots</span> <span class="skolem">p</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">SOME</span> <span class="bound">xs</span><span class="main">.</span> set <span class="bound">xs</span> <span class="main">=</span> <span class="main">{</span><span class="bound">x</span> <span class="main">.</span> poly <span class="skolem">p</span> <span class="bound">x</span> <span class="main">=</span> <span class="main">0</span><span class="main">}</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">p</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"complex poly"</span></span> 
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">p</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"complex poly"</span></span> 
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> 
    <span class="keyword1"><span class="command">from</span></span> someI_ex<span class="main">[</span><span class="operator">OF</span> finite_list<span class="main"><span class="main">[</span></span><span class="operator">OF</span> poly_roots_finite<span class="main"><span class="main">[</span></span><span class="operator">OF</span> this<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="operator">folded</span> roots_def<span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="skolem">roots</span> <span class="skolem">p</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> poly <span class="skolem">p</span> <span class="bound">x</span> <span class="main">=</span> <span class="main">0</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> roots <span class="main">=</span> this
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">qs_roots</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">qs_roots</span> <span class="main">=</span> concat_lists <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span> <span class="bound">i</span><span class="main">.</span> <span class="skolem">roots</span> <span class="main">(</span><span class="var">?qs</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">[</span><span class="main">0</span> <span class="main">..&lt;</span> length <span class="free">triples</span><span class="main">]</span><span class="main">)</span>"</span></span> 
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">evals</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">evals</span> <span class="main">=</span> concat <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span> <span class="bound">part</span><span class="main">.</span> <span class="keyword1">let</span> 
    <span class="bound">q</span> <span class="main">=</span> partial_insertion <span class="main">(</span><span class="main">λ</span> <span class="bound">i</span><span class="main">.</span> <span class="bound">part</span> <span class="main">!</span> <span class="main">(</span><span class="bound">i</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span> <span class="main">0</span> <span class="var">?mp</span><span class="main">;</span>
    <span class="bound">new_roots</span> <span class="main">=</span> <span class="skolem">roots</span> <span class="bound">q</span>
    <span class="keyword1">in</span> map <span class="main">(</span><span class="main">λ</span> <span class="bound">r</span><span class="main">.</span> <span class="bound">r</span> <span class="main">#</span> <span class="bound">part</span><span class="main">)</span> <span class="bound">new_roots</span><span class="main">)</span> <span class="skolem">qs_roots</span><span class="main">)</span>"</span></span>  
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">conv</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">conv</span> <span class="skolem">roots</span> <span class="skolem">i</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="skolem">i</span> <span class="main">≤</span> length <span class="free">triples</span> <span class="keyword1">then</span> <span class="skolem">roots</span> <span class="main">!</span> <span class="skolem">i</span> <span class="keyword1">else</span> <span class="main">0</span> <span class="main">::</span> complex<span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">roots</span> <span class="skolem">i</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">alphas</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">alphas</span> <span class="main">=</span> map <span class="skolem">conv</span> <span class="skolem">evals</span>"</span></span> 
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">n</span>
    <span class="keyword3"><span class="command">assume</span></span> n<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">∈</span> <span class="main">{..</span>degree <span class="free">p</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?cn</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"coeff <span class="free">p</span> <span class="skolem">n</span>"</span></span> 
    <span class="keyword1"><span class="command">from</span></span> n <span class="keyword1"><span class="command">have</span></span> mem<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?cn</span> <span class="main">∈</span> set <span class="main">(</span>coeffs <span class="free">p</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> p <span class="keyword1"><span class="command">unfolding</span></span> Polynomial.coeffs_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="var">?cn</span> <span class="main">∉</span> <span class="main">ℤ</span>"</span></span>
      <span class="keyword1"><span class="command">with</span></span> mem <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?cn</span> <span class="main">∈</span> set <span class="skolem">rcs</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> rcs_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?cn</span><span class="main">,</span> min_int_poly <span class="var">?cn</span><span class="main">)</span> <span class="main">∈</span> set <span class="skolem">spairs</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> spairs_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">i</span><span class="main">.</span> <span class="main">(</span><span class="bound">i</span><span class="main">,</span> <span class="var">?cn</span><span class="main">,</span> min_int_poly <span class="var">?cn</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">triples</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> triples set_zip set_conv_nth 
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="var">?find</span> <span class="skolem">n</span> <span class="main">≠</span> None"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> find_None_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> non_int_find <span class="main">=</span> this
  <span class="keyword1"><span class="command">have</span></span> fin<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">{</span><span class="bound">α</span><span class="main">.</span> mpoly_polys_zero_solution <span class="var">?mp</span> <span class="var">?qs</span> <span class="main">(</span>set <span class="free">is</span><span class="main">)</span> <span class="bound">α</span><span class="main">}</span>"</span></span> 
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> finite_subset<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ finite_set<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">alphas</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">standard</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">clarify</span><span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">α</span>
    <span class="keyword3"><span class="command">assume</span></span> sol<span class="main">:</span> <span class="quoted"><span class="quoted">"mpoly_polys_zero_solution <span class="var">?mp</span> <span class="var">?qs</span> <span class="main">(</span>set <span class="free">is</span><span class="main">)</span> <span class="skolem">α</span>"</span></span> 
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">part</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">part</span> <span class="main">=</span> map <span class="main">(</span><span class="main">λ</span> <span class="bound">i</span><span class="main">.</span> <span class="skolem">α</span> <span class="main">(</span>Suc <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">[</span><span class="main">0</span> <span class="main">..&lt;</span> length <span class="free">triples</span><span class="main">]</span>"</span></span> 
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&gt;</span> length <span class="free">triples</span>"</span></span> 
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">∉</span> insert <span class="main">0</span> <span class="main">(</span>Suc <span class="main">`</span> set <span class="free">is</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> triples <span class="quoted">"is"</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">α</span> <span class="skolem">i</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> sol<span class="main">[</span><span class="operator">unfolded</span> mpoly_polys_zero_solution_def<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> alpha0 <span class="main">=</span> this
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&lt;</span> length <span class="free">triples</span>"</span></span> 
      <span class="keyword1"><span class="command">hence</span></span> i<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">∈</span> set <span class="free">is</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> triples <span class="quoted">"is"</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">from</span></span> qs0 i <span class="keyword1"><span class="command">have</span></span> 0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?qs</span> <span class="skolem">i</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">from</span></span> i sol<span class="main">[</span><span class="operator">unfolded</span> mpoly_polys_zero_solution_def mpoly_polys_solution_def<span class="main">]</span> 
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"poly <span class="main">(</span><span class="var">?qs</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">(</span><span class="skolem">α</span> <span class="main">(</span>Suc <span class="skolem">i</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">α</span> <span class="main">(</span>Suc <span class="skolem">i</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span><span class="skolem">roots</span> <span class="main">(</span><span class="var">?qs</span> <span class="skolem">i</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"poly <span class="main">(</span><span class="var">?qs</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">(</span><span class="skolem">α</span> <span class="main">(</span>Suc <span class="skolem">i</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> roots<span class="main">[</span><span class="operator">OF</span> 0<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> roots2 <span class="main">=</span> this
    <span class="keyword1"><span class="command">hence</span></span> part<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">part</span> <span class="main">∈</span> set <span class="skolem">qs_roots</span>"</span></span> 
      <span class="keyword1"><span class="command">unfolding</span></span> part_def qs_roots_def concat_lists_listset listset <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?gamma</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> <span class="skolem">part</span> <span class="main">!</span> <span class="main">(</span><span class="bound">i</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?f</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"partial_insertion <span class="var">?gamma</span> <span class="main">0</span> <span class="var">?mp</span>"</span></span> 
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">α</span> <span class="main">0</span> <span class="main">∈</span> set <span class="main">(</span><span class="skolem">roots</span> <span class="var">?f</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command">from</span></span> sol<span class="main">[</span><span class="operator">unfolded</span> mpoly_polys_zero_solution_def mpoly_polys_solution_def<span class="main">]</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">=</span> insertion <span class="skolem">α</span> <span class="var">?mp</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> insertion <span class="main">(</span><span class="main">λ</span> <span class="bound">i</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">i</span> <span class="main">≤</span> length <span class="free">triples</span> <span class="keyword1">then</span> <span class="skolem">α</span> <span class="bound">i</span> <span class="keyword1">else</span> <span class="skolem">part</span> <span class="main">!</span> <span class="main">(</span><span class="bound">i</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span> <span class="var">?mp</span>"</span></span> 
        <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">=</span> insertion <span class="var">?beta</span> <span class="main">_</span>"</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> insertion_irrelevant_vars<span class="main">)</span>
        <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">∈</span> vars <span class="var">?mp</span>"</span></span> 
        <span class="keyword1"><span class="command">from</span></span> set_mp<span class="main">[</span><span class="operator">OF</span> varsMp this<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">≤</span> length <span class="free">triples</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> triples <span class="quoted">"is"</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">α</span> <span class="skolem">i</span> <span class="main">=</span> <span class="var">?beta</span> <span class="skolem">i</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> poly <span class="main">(</span>partial_insertion <span class="main">(</span><span class="var">?beta</span><span class="main">(</span><span class="main">0</span> <span class="main">:=</span> <span class="skolem">part</span> <span class="main">!</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span> <span class="main">0</span> <span class="var">?mp</span><span class="main">)</span> <span class="main">(</span><span class="var">?beta</span> <span class="main">0</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> insertion_partial_insertion<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?beta</span><span class="main">(</span><span class="main">0</span> <span class="main">:=</span> <span class="skolem">part</span> <span class="main">!</span> <span class="main">0</span><span class="main">)</span> <span class="main">=</span> <span class="var">?gamma</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> part_def 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> ext<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> root<span class="main">:</span> <span class="quoted"><span class="quoted">"poly <span class="var">?f</span> <span class="main">(</span><span class="skolem">α</span> <span class="main">0</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?f</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> 
      <span class="keyword1"><span class="command">proof</span></span>
        <span class="keyword1"><span class="command">interpret</span></span> mp<span class="main">:</span> inj_comm_ring_hom <span class="quoted"><span class="quoted">"map_mpoly complex_of_int"</span></span> 
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> of_int_hom.inj_comm_ring_hom_mpoly_map<span class="main">)</span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="var">?f</span> <span class="main">=</span> <span class="main">0</span>"</span></span> 
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">=</span> coeff <span class="var">?f</span> <span class="main">(</span>degree <span class="free">p</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> insertion <span class="var">?gamma</span> <span class="main">(</span>coeff <span class="main">(</span>mpoly_to_mpoly_poly <span class="main">0</span> <span class="var">?mp</span><span class="main">)</span> <span class="main">(</span>degree <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span> 
          <span class="keyword1"><span class="command">unfolding</span></span> insertion_coeff_mpoly_to_mpoly_poly<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">..</span></span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"coeff <span class="main">(</span>mpoly_to_mpoly_poly <span class="main">0</span> <span class="var">?mp</span><span class="main">)</span> <span class="main">(</span>degree <span class="free">p</span><span class="main">)</span> <span class="main">=</span> map_mpoly of_int <span class="main">(</span>coeff <span class="main">(</span>mpoly_to_mpoly_poly <span class="main">0</span> <span class="free">mp</span><span class="main">)</span> <span class="main">(</span>degree <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span> 
          <span class="keyword1"><span class="command">unfolding</span></span> of_int_hom.mpoly_to_mpoly_poly_map_mpoly_hom 
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> coeff_map_poly<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"coeff <span class="main">(</span>mpoly_to_mpoly_poly <span class="main">0</span> <span class="free">mp</span><span class="main">)</span> <span class="main">(</span>degree <span class="free">p</span><span class="main">)</span> <span class="main">=</span> 
          <span class="main">(</span><span class="main">∑</span><span class="bound">x</span><span class="main">.</span> MPoly_Type.monom <span class="main">(</span>remove_key <span class="main">0</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span>MPoly_Type.coeff <span class="free">mp</span> <span class="bound">x</span><span class="main">)</span> <span class="keyword1">when</span> lookup <span class="bound">x</span> <span class="main">0</span> <span class="main">=</span> degree <span class="free">p</span><span class="main">)</span>"</span></span> 
          <span class="keyword1"><span class="command">unfolding</span></span> mpoly_to_mpoly_poly_def when_def
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> coeff_hom.hom_Sum_any<span class="main"><span class="keyword3">,</span></span> <span class="operator">force</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">unfold</span> Polynomial.coeff_monom<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">x</span><span class="main">.</span> MPoly_Type.monom <span class="main">(</span>remove_key <span class="main">0</span> <span class="bound">x</span><span class="main">)</span>
           <span class="main">(</span><span class="main">∑</span><span class="bound">xa</span><span class="main">≤</span>degree <span class="free">p</span><span class="main">.</span> <span class="keyword1">let</span> <span class="bound">xx</span> <span class="main">=</span> Poly_Mapping.single <span class="main">0</span> <span class="bound">xa</span> <span class="keyword1">in</span>
               <span class="main">∑</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">)</span><span class="main">.</span> MPoly_Type.coeff <span class="main">(</span><span class="skolem">trans</span> <span class="bound">xa</span><span class="main">)</span> <span class="bound">b</span> <span class="keyword1">when</span> <span class="bound">x</span> <span class="main">=</span> <span class="bound">xx</span> <span class="main">+</span> <span class="bound">b</span> <span class="keyword1">when</span>
                         <span class="bound">a</span> <span class="main">=</span> <span class="bound">xx</span><span class="main">)</span> <span class="keyword1">when</span>
          lookup <span class="bound">x</span> <span class="main">0</span> <span class="main">=</span> degree <span class="free">p</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> mp coeff_sum More_MPoly_Type.coeff_monom coeff_mpoly_times Let_def
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> prod_fun_unfold_prod<span class="main"><span class="keyword3">,</span></span> <span class="operator">force</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">force</span><span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> when_mult<span class="main"><span class="keyword3">,</span></span> <span class="operator">subst</span> when_commute<span class="main">)</span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> when_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> Sum_any.cong sum.cong if_cong arg_cong<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted">"MPoly_Type.monom <span class="main">_</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">x</span><span class="main">.</span> MPoly_Type.monom <span class="main">(</span>remove_key <span class="main">0</span> <span class="bound">x</span><span class="main">)</span>
           <span class="main">(</span><span class="main">∑</span><span class="bound">i</span><span class="main">≤</span>degree <span class="free">p</span><span class="main">.</span> <span class="main">∑</span><span class="bound">m</span><span class="main">.</span> MPoly_Type.coeff <span class="main">(</span><span class="skolem">trans</span> <span class="bound">i</span><span class="main">)</span> <span class="bound">m</span> <span class="keyword1">when</span> <span class="bound">x</span> <span class="main">=</span> Poly_Mapping.single <span class="main">0</span> <span class="bound">i</span> <span class="main">+</span> <span class="bound">m</span><span class="main">)</span> <span class="keyword1">when</span>
          lookup <span class="bound">x</span> <span class="main">0</span> <span class="main">=</span> degree <span class="free">p</span><span class="main">)</span>"</span></span> 
          <span class="keyword1"><span class="command">unfolding</span></span> Sum_any_when_dependent_prod_left Let_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">x</span><span class="main">.</span> MPoly_Type.monom <span class="main">(</span>remove_key <span class="main">0</span> <span class="bound">x</span><span class="main">)</span>
           <span class="main">(</span><span class="main">∑</span><span class="bound">i</span> <span class="main">∈</span> <span class="main">{</span>degree <span class="free">p</span><span class="main">}</span><span class="main">.</span> <span class="main">∑</span><span class="bound">m</span><span class="main">.</span> MPoly_Type.coeff <span class="main">(</span><span class="skolem">trans</span> <span class="bound">i</span><span class="main">)</span> <span class="bound">m</span> <span class="keyword1">when</span> <span class="bound">x</span> <span class="main">=</span> Poly_Mapping.single <span class="main">0</span> <span class="bound">i</span> <span class="main">+</span> <span class="bound">m</span><span class="main">)</span> <span class="keyword1">when</span>
          lookup <span class="bound">x</span> <span class="main">0</span> <span class="main">=</span> degree <span class="free">p</span><span class="main">)</span>"</span></span> 
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> Sum_any.cong when_cong refl arg_cong<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted"><span class="quoted">"MPoly_Type.monom <span class="main"><span class="main">_</span></span>"</span></span></span><span class="main"><span class="main">]</span></span> sum.mono_neutral_right<span class="main"><span class="keyword3">,</span></span> <span class="operator">force</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> ballI Sum_any_zeroI<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> when_def<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> i x
          <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">goal_cases</span><span class="main">)</span>
            <span class="keyword3"><span class="command">case</span></span> 1
            <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"lookup <span class="skolem">x</span> <span class="main">0</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> lookup_add<span class="main">)</span>
            <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">∉</span> vars <span class="main">(</span><span class="skolem">trans</span> <span class="skolem">i</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> trans_def
              <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> vars_Var<span class="main">)</span>
            <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
              <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> set_mp coeff_notin_vars in_keys_iff neq0_conv<span class="main">)</span>
          <span class="keyword1"><span class="command">qed</span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">x</span><span class="main">.</span> MPoly_Type.monom <span class="main">(</span>remove_key <span class="main">0</span> <span class="bound">x</span><span class="main">)</span>
            <span class="main">(</span><span class="main">∑</span><span class="bound">m</span><span class="main">.</span> MPoly_Type.coeff <span class="main">(</span><span class="skolem">trans</span> <span class="main">(</span>degree <span class="free">p</span><span class="main">)</span><span class="main">)</span> <span class="bound">m</span> <span class="keyword1">when</span> <span class="bound">x</span> <span class="main">=</span> Poly_Mapping.single <span class="main">0</span> <span class="main">(</span>degree <span class="free">p</span><span class="main">)</span> <span class="main">+</span> <span class="bound">m</span><span class="main">)</span> <span class="keyword1">when</span>
          lookup <span class="bound">x</span> <span class="main">0</span> <span class="main">=</span> degree <span class="free">p</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">=</span> <span class="var">?mid</span>"</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"insertion <span class="var">?gamma</span> <span class="main">(</span>map_mpoly of_int <span class="main">…</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> 
        <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="var">?find</span> <span class="main">(</span>degree <span class="free">p</span><span class="main">)</span>"</span></span><span class="main">)</span>
          <span class="keyword3"><span class="command">case</span></span> None
          <span class="keyword1"><span class="command">from</span></span> non_int_find<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"degree <span class="free">p</span>"</span></span><span class="main">]</span> None 
          <span class="keyword1"><span class="command">have</span></span> lcZ<span class="main">:</span> <span class="quoted"><span class="quoted">"lead_coeff <span class="free">p</span> <span class="main">∈</span> <span class="main">ℤ</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?mid</span> <span class="main">=</span>  <span class="main">(</span><span class="main">∑</span><span class="bound">x</span><span class="main">.</span> MPoly_Type.monom <span class="main">(</span>remove_key <span class="main">0</span> <span class="bound">x</span><span class="main">)</span>
           <span class="main">(</span><span class="main">∑</span><span class="bound">m</span><span class="main">.</span> <span class="main">(</span>to_int <span class="main">(</span>lead_coeff <span class="free">p</span><span class="main">)</span> <span class="keyword1">when</span>
                 <span class="bound">x</span> <span class="main">=</span> Poly_Mapping.single <span class="main">0</span> <span class="main">(</span>degree <span class="free">p</span><span class="main">)</span> <span class="main">+</span> <span class="bound">m</span> <span class="keyword1">when</span> <span class="bound">m</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">when</span>
              lookup <span class="bound">x</span> <span class="main">0</span> <span class="main">=</span> degree <span class="free">p</span><span class="main">)</span>"</span></span> 
            <span class="keyword1"><span class="command">using</span></span> None <span class="keyword1"><span class="command">unfolding</span></span> trans_def None option.simps mpoly_coeff_Const when_def
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> Sum_any.cong if_cong refl<span class="main"><span class="keyword3">,</span></span> <span class="operator">intro</span> arg_cong<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"MPoly_Type.monom <span class="main"><span class="main"><span class="main">_</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span> Sum_any.cong<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
          <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">x</span><span class="main">.</span> MPoly_Type.monom <span class="main">(</span>remove_key <span class="main">0</span> <span class="bound">x</span><span class="main">)</span>
           <span class="main">(</span>to_int <span class="main">(</span>lead_coeff <span class="free">p</span><span class="main">)</span> <span class="keyword1">when</span> <span class="bound">x</span> <span class="main">=</span> Poly_Mapping.single <span class="main">0</span> <span class="main">(</span>degree <span class="free">p</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">when</span>
               lookup <span class="bound">x</span> <span class="main">0</span> <span class="main">=</span> degree <span class="free">p</span> <span class="keyword1">when</span> <span class="bound">x</span> <span class="main">=</span> Poly_Mapping.single <span class="main">0</span> <span class="main">(</span>degree <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span> 
            <span class="keyword1"><span class="command">unfolding</span></span> Sum_any_when_equal<span class="main">[</span><span class="operator">of</span> <span class="main">_</span> <span class="quoted"><span class="main">0</span></span><span class="main">]</span>
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> Sum_any.cong<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> when_def<span class="main">)</span>
          <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> MPoly_Type.monom <span class="main">(</span>remove_key <span class="main">0</span> <span class="main">(</span>Poly_Mapping.single <span class="main">0</span> <span class="main">(</span>degree <span class="free">p</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
           <span class="main">(</span>to_int <span class="main">(</span>lead_coeff <span class="free">p</span><span class="main">)</span><span class="main">)</span> "</span></span> 
            <span class="keyword1"><span class="command">unfolding</span></span> Sum_any_when_equal <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> Const <span class="main">(</span>to_int <span class="main">(</span>lead_coeff <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mpoly_monom_0_eq_Const<span class="main">)</span>
          <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_mpoly of_int <span class="main">…</span> <span class="main">=</span> Const <span class="main">(</span>lead_coeff <span class="free">p</span><span class="main">)</span>"</span></span> 
            <span class="keyword1"><span class="command">unfolding</span></span> of_int_hom.map_mpoly_hom_Const of_int_to_int<span class="main">[</span><span class="operator">OF</span> lcZ<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"insertion <span class="var">?gamma</span> <span class="main">…</span> <span class="main">=</span> lead_coeff <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> p <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> Some
          <span class="keyword1"><span class="command">from</span></span> find_Some_D<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> Some <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">j</span></span> <span class="skolem"><span class="skolem">f</span></span> <span class="keyword2"><span class="keyword">where</span></span> mem<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">j</span><span class="main">,</span>lead_coeff <span class="free">p</span><span class="main">,</span><span class="skolem">f</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">triples</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
            Some<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?find</span> <span class="main">(</span>degree <span class="free">p</span><span class="main">)</span> <span class="main">=</span> Some <span class="main">(</span><span class="skolem">j</span><span class="main">,</span> lead_coeff <span class="free">p</span><span class="main">,</span> <span class="skolem">f</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">from</span></span> mem <span class="keyword1"><span class="command">have</span></span> j<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">&lt;</span> length <span class="free">triples</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> triples set_zip <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?mid</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> lookup <span class="bound">x</span> <span class="main">0</span> <span class="main">=</span> degree <span class="free">p</span>
              <span class="keyword1">then</span> MPoly_Type.monom <span class="main">(</span>remove_key <span class="main">0</span> <span class="bound">x</span><span class="main">)</span>
                <span class="main">(</span><span class="main">∑</span><span class="bound">m</span><span class="main">.</span> <span class="main">1</span> <span class="keyword1">when</span> <span class="bound">m</span> <span class="main">=</span> Poly_Mapping.single <span class="main">(</span>Suc <span class="skolem">j</span><span class="main">)</span> <span class="main">1</span> <span class="keyword1">when</span> <span class="bound">x</span> <span class="main">=</span> Poly_Mapping.single <span class="main">0</span> <span class="main">(</span>degree <span class="free">p</span><span class="main">)</span> <span class="main">+</span> <span class="bound">m</span><span class="main">)</span>
            <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span>"</span></span> 
            <span class="keyword1"><span class="command">unfolding</span></span> trans_def Some option.simps split when_def coeff_Var <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> lookup <span class="bound">x</span> <span class="main">0</span> <span class="main">=</span> degree <span class="free">p</span>
          <span class="keyword1">then</span> MPoly_Type.monom <span class="main">(</span>remove_key <span class="main">0</span> <span class="bound">x</span><span class="main">)</span> <span class="main">1</span>
                <span class="keyword1">when</span> <span class="bound">x</span> <span class="main">=</span> Poly_Mapping.single <span class="main">0</span> <span class="main">(</span>degree <span class="free">p</span><span class="main">)</span> <span class="main">+</span> Poly_Mapping.single <span class="main">(</span>Suc <span class="skolem">j</span><span class="main">)</span> <span class="main">1</span>
              <span class="keyword1">else</span> <span class="main">0</span> <span class="keyword1">when</span> <span class="bound">x</span> <span class="main">=</span> Poly_Mapping.single <span class="main">0</span> <span class="main">(</span>degree <span class="free">p</span><span class="main">)</span> <span class="main">+</span> Poly_Mapping.single <span class="main">(</span>Suc <span class="skolem">j</span><span class="main">)</span> <span class="main">1</span><span class="main">)</span>"</span></span> 
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> when_commute<span class="main">)</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> Sum_any_when_equal<span class="main">)</span>
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> Sum_any.cong<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> when_def<span class="main">)</span>
          <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span>MPoly_Type.monom <span class="main">(</span>remove_key <span class="main">0</span> <span class="bound">x</span><span class="main">)</span> <span class="main">1</span> <span class="keyword1">when</span> lookup <span class="bound">x</span> <span class="main">0</span> <span class="main">=</span> degree <span class="free">p</span><span class="main">)</span>
            <span class="keyword1">when</span> <span class="bound">x</span> <span class="main">=</span> Poly_Mapping.single <span class="main">0</span> <span class="main">(</span>degree <span class="free">p</span><span class="main">)</span> <span class="main">+</span> Poly_Mapping.single <span class="main">(</span>Suc <span class="skolem">j</span><span class="main">)</span> <span class="main">1</span><span class="main">)</span>"</span></span> 
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> Sum_any.cong<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> when_def<span class="main">)</span>
          <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> MPoly_Type.monom <span class="main">(</span>Poly_Mapping.single <span class="main">(</span>Suc <span class="skolem">j</span><span class="main">)</span> <span class="main">1</span><span class="main">)</span> <span class="main">1</span>"</span></span>  
            <span class="keyword1"><span class="command">unfolding</span></span> Sum_any_when_equal <span class="keyword1"><span class="command">unfolding</span></span> when_def 
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lookup_add remove_key_add<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span>
              remove_key_single' lookup_single<span class="main">)</span>
          <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> Var <span class="main">(</span>Suc <span class="skolem">j</span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> mpoly_eqI<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> coeff_Var coeff_monom<span class="main">)</span>
          <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_mpoly complex_of_int <span class="main">…</span> <span class="main">=</span> Var <span class="main">(</span>Suc <span class="skolem">j</span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_mpoly_Var<span class="main">)</span>
          <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"insertion <span class="var">?gamma</span> <span class="main">…</span> <span class="main">=</span> <span class="skolem">part</span> <span class="main">!</span> <span class="skolem">j</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="skolem">α</span> <span class="main">(</span>Suc <span class="skolem">j</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> part_def <span class="keyword1"><span class="command">using</span></span> j <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> 
          <span class="keyword1"><span class="command">proof</span></span>
            <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">α</span> <span class="main">(</span>Suc <span class="skolem">j</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span> 
            <span class="keyword1"><span class="command">with</span></span> roots2<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> j<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> root0<span class="main">:</span> <span class="quoted"><span class="quoted">"poly <span class="main">(</span><span class="var">?qs</span> <span class="skolem">j</span><span class="main">)</span> <span class="main">0</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">from</span></span> j <span class="quoted">"is"</span> <span class="keyword1"><span class="command">have</span></span> ji<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">&lt;</span> length <span class="free">is</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">hence</span></span> jis<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">∈</span> set <span class="free">is</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> <span class="quoted">"is"</span> triples set_zip <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">from</span></span> mem <span class="keyword1"><span class="command">have</span></span> tj<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">triples</span> <span class="main">!</span> <span class="skolem">j</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">j</span><span class="main">,</span> lead_coeff <span class="free">p</span><span class="main">,</span> <span class="skolem">f</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> triples set_zip <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">from</span></span> root0<span class="main">[</span><span class="operator">unfolded</span> qs<span class="main"><span class="main">[</span></span><span class="operator">OF</span> ji<span class="main"><span class="main">]</span></span> o_def tj<span class="main">]</span> 
            <span class="keyword1"><span class="command">have</span></span> rootf<span class="main">:</span> <span class="quoted"><span class="quoted">"poly <span class="skolem">f</span> <span class="main">0</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">from</span></span> is_repr<span class="main">[</span><span class="operator">OF</span> jis<span class="main">,</span> <span class="operator">unfolded</span> tj<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> rootlc<span class="main">:</span> <span class="quoted"><span class="quoted">"ipoly <span class="skolem">f</span> <span class="main">(</span>lead_coeff <span class="free">p</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span> 
              <span class="keyword2"><span class="keyword">and</span></span> f<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="main">=</span> min_int_poly <span class="main">(</span>lead_coeff <span class="free">p</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">from</span></span> f <span class="keyword1"><span class="command">have</span></span> irr<span class="main">:</span> <span class="quoted"><span class="quoted">"irreducible <span class="skolem">f</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">from</span></span> rootf <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="main">0</span><span class="main">,</span><span class="main">1</span><span class="main">:]</span> <span class="keyword1">dvd</span> <span class="skolem">f</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> dvd_iff_poly_eq_0 <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
            <span class="keyword1"><span class="command">from</span></span> this<span class="main">[</span><span class="operator">unfolded</span> dvd_def<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">g</span></span> <span class="keyword2"><span class="keyword">where</span></span> f<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">f</span> <span class="main">=</span> <span class="main">[:</span><span class="main">0</span><span class="main">,</span> <span class="main">1</span><span class="main">:]</span> <span class="main">*</span> <span class="skolem">g</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">from</span></span> irreducibleD<span class="main">[</span><span class="operator">OF</span> irr f<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"is_unit <span class="skolem">g</span>"</span></span>
              <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> is_unit_poly_iff one_neq_zero one_pCons pCons_eq_iff<span class="main">)</span> 
            <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">c</span></span> <span class="keyword2"><span class="keyword">where</span></span> g<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">g</span> <span class="main">=</span> <span class="main">[:</span><span class="skolem">c</span><span class="main">:]</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> c<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="keyword1">dvd</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> is_unit_poly_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">from</span></span> rootlc<span class="main">[</span><span class="operator">unfolded</span> f g<span class="main">]</span> c <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lead_coeff <span class="free">p</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">with</span></span> p <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">qed</span></span>
          <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
        <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">from</span></span> roots<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> root <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">α</span> <span class="main">0</span> <span class="main">#</span> <span class="skolem">part</span> <span class="main">∈</span> set <span class="skolem">evals</span>"</span></span> 
      <span class="keyword1"><span class="command">unfolding</span></span> evals_def set_concat Let_def set_map 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> bexI<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ part<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"map <span class="skolem">α</span> <span class="main">[</span><span class="main">0</span> <span class="main">..&lt;</span> Suc <span class="main">(</span>length <span class="free">triples</span><span class="main">)</span><span class="main">]</span> <span class="main">∈</span> set <span class="skolem">evals</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> part_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Utility.map_upt_Suc<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">conv</span> <span class="main">(</span>map <span class="skolem">α</span> <span class="main">[</span><span class="main">0</span> <span class="main">..&lt;</span> Suc <span class="main">(</span>length <span class="free">triples</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="main">∈</span> set <span class="skolem">alphas</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> alphas_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">conv</span> <span class="main">(</span>map <span class="skolem">α</span> <span class="main">[</span><span class="main">0</span> <span class="main">..&lt;</span> Suc <span class="main">(</span>length <span class="free">triples</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">α</span>"</span></span> 
    <span class="keyword1"><span class="command">proof</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">conv</span> <span class="main">(</span>map <span class="skolem">α</span> <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span>Suc <span class="main">(</span>length <span class="free">triples</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="skolem">i</span> <span class="main">=</span> <span class="skolem">α</span> <span class="skolem">i</span>"</span></span> 
        <span class="keyword1"><span class="command">unfolding</span></span> conv_def <span class="keyword1"><span class="command">using</span></span> alpha0
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&lt;</span> length <span class="free">triples</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">=</span> length <span class="free">triples</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> nth_append<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">α</span> <span class="main">∈</span> set <span class="skolem">alphas</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">note</span></span> eliminate <span class="main">=</span> eliminate<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">α</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">α</span> <span class="skolem">x</span> <span class="skolem">j</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="skolem">j</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="skolem">x</span> <span class="keyword1">else</span> <span class="var">?c</span> <span class="main">(</span><span class="skolem">j</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">j</span>
  <span class="keyword1"><span class="command">have</span></span> α<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">α</span> <span class="skolem">x</span> <span class="main">(</span>Suc <span class="skolem">j</span><span class="main">)</span> <span class="main">=</span> <span class="var">?c</span> <span class="skolem">j</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">α</span> <span class="skolem">x</span> <span class="main">0</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">j</span> <span class="skolem">x</span> <span class="keyword1"><span class="command">unfolding</span></span> α_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">interpret</span></span> mp<span class="main">:</span> inj_comm_ring_hom <span class="quoted"><span class="quoted">"map_mpoly complex_of_int"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> of_int_hom.inj_comm_ring_hom_mpoly_map<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> ins<span class="main">:</span> <span class="quoted"><span class="quoted">"insertion <span class="main">(</span><span class="skolem">α</span> <span class="skolem">x</span><span class="main">)</span> <span class="var">?mp</span> <span class="main">=</span> poly <span class="free">p</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span>
    <span class="keyword1"><span class="command">unfolding</span></span> poly_altdef mp mp.hom_sum insertion_sum insertion_mult mp.hom_mult
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> sum.cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> refl<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">subst</span> mult.commute<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> arg_cong2<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">(*)</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">n</span>
    <span class="keyword3"><span class="command">assume</span></span> n<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">∈</span> <span class="main">{..</span>degree <span class="free">p</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?cn</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"coeff <span class="free">p</span> <span class="skolem">n</span>"</span></span> 
    <span class="keyword1"><span class="command">from</span></span> n <span class="keyword1"><span class="command">have</span></span> mem<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?cn</span> <span class="main">∈</span> set <span class="main">(</span>coeffs <span class="free">p</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> p <span class="keyword1"><span class="command">unfolding</span></span> Polynomial.coeffs_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"insertion <span class="main">(</span><span class="skolem">α</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span>map_mpoly complex_of_int <span class="main">(</span>MPoly_Type.monom <span class="main">(</span>Poly_Mapping.single <span class="main">0</span> <span class="skolem">n</span><span class="main">)</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∏</span><span class="bound">a</span><span class="main">.</span> <span class="skolem">α</span> <span class="skolem">x</span> <span class="bound">a</span> <span class="main">^</span> <span class="main">(</span><span class="skolem">n</span> <span class="keyword1">when</span> <span class="bound">a</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">unfolding</span></span> of_int_hom.map_mpoly_hom_monom <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lookup_single<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="main">∏</span><span class="bound">a</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">a</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="skolem">α</span> <span class="skolem">x</span> <span class="bound">a</span> <span class="main">^</span> <span class="skolem">n</span> <span class="keyword1">else</span> <span class="main">1</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> Prod_any.cong<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> when_def<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="skolem">α</span> <span class="skolem">x</span> <span class="main">0</span> <span class="main">^</span> <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="skolem">x</span> <span class="main">^</span> <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> α <span class="keyword1"><span class="command">..</span></span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"insertion <span class="main">(</span><span class="skolem">α</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span>map_mpoly complex_of_int <span class="main">(</span>MPoly_Type.monom <span class="main">(</span>Poly_Mapping.single <span class="main">0</span> <span class="skolem">n</span><span class="main">)</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">x</span> <span class="main">^</span> <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"insertion <span class="main">(</span><span class="skolem">α</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span>map_mpoly complex_of_int <span class="main">(</span><span class="skolem">trans</span> <span class="skolem">n</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="var">?cn</span>"</span></span> 
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="var">?find</span> <span class="skolem">n</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> None
      <span class="keyword1"><span class="command">with</span></span> non_int_find<span class="main">[</span><span class="operator">OF</span> n<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> ints<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?cn</span> <span class="main">∈</span> <span class="main">ℤ</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">from</span></span> None <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> trans_def <span class="keyword1"><span class="command">using</span></span> ints 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> of_int_hom.map_mpoly_hom_Const of_int_to_int<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Some <span class="skolem">triple</span><span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> find_Some_D<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> this <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">j</span></span> <span class="skolem"><span class="skolem">f</span></span> 
        <span class="keyword2"><span class="keyword">where</span></span> mem<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">j</span><span class="main">,</span><span class="var">?cn</span><span class="main">,</span><span class="skolem">f</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">triples</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> Some<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?find</span> <span class="skolem">n</span> <span class="main">=</span> Some <span class="main">(</span><span class="skolem">j</span><span class="main">,</span><span class="var">?cn</span><span class="main">,</span><span class="skolem">f</span><span class="main">)</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">triple</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> mem <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">triples</span> <span class="main">!</span> <span class="skolem">j</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">j</span><span class="main">,</span><span class="var">?cn</span><span class="main">,</span><span class="skolem">f</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> triples set_zip <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> trans_def Some <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_mpoly_Var α_def<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">from</span></span> root <span class="keyword1"><span class="command">have</span></span>  <span class="quoted"><span class="quoted">"insertion <span class="main">(</span><span class="skolem">α</span> <span class="free">x</span><span class="main">)</span> <span class="var">?mp</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> ins <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"mpoly_polys_solution <span class="var">?mp</span> <span class="var">?qs</span> <span class="main">(</span>set <span class="free">is</span><span class="main">)</span> <span class="main">(</span><span class="skolem">α</span> <span class="free">x</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> mpoly_polys_solution_def
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">intro</span> ballI<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">j</span>
    <span class="keyword3"><span class="command">assume</span></span> j<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">∈</span> set <span class="free">is</span>"</span></span> 
    <span class="keyword1"><span class="command">from</span></span> is_repr<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"poly <span class="main">(</span><span class="var">?qs</span> <span class="skolem">j</span><span class="main">)</span> <span class="main">(</span><span class="skolem">α</span> <span class="free">x</span> <span class="main">(</span>Suc <span class="skolem">j</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> α qs<span class="main">[</span><span class="operator">OF</span> j_len<span class="main"><span class="main">[</span></span><span class="operator">OF</span> j<span class="main"><span class="main">]</span></span><span class="main">]</span> o_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">note</span></span> eliminate <span class="main">=</span> eliminate<span class="main">[</span><span class="operator">OF</span> this<span class="main">,</span> <span class="operator">unfolded</span> α eliminate_aux_vars_of_int_poly<span class="main">]</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"eliminate_aux_vars <span class="free">mp</span> <span class="free">qs</span> <span class="free">is</span> <span class="keyword1">represents</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>  

<span class="keyword1" id="Roots_of_Algebraic_Poly-representative_poly_complex"><span class="command">lemma</span></span> representative_poly_complex<span class="main">:</span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span> <span class="main">::</span> <span class="quoted">complex</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> p<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> algebraic<span class="main">:</span> <span class="quoted"><span class="quoted">"Ball <span class="main">(</span>set <span class="main">(</span>coeffs <span class="free">p</span><span class="main">)</span><span class="main">)</span> algebraic"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> root<span class="main">:</span> <span class="quoted"><span class="quoted">"poly <span class="free">p</span> <span class="free">x</span> <span class="main">=</span> <span class="main">0</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"representative_poly <span class="free">p</span> <span class="keyword1">represents</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">mp</span></span> <span class="skolem"><span class="skolem">triples</span></span> <span class="keyword2"><span class="keyword">where</span></span> init<span class="main">:</span> <span class="quoted"><span class="quoted">"initial_root_problem <span class="free">p</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">mp</span><span class="main">,</span> <span class="skolem">triples</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">from</span></span> get_representative_complex<span class="main">[</span><span class="operator">OF</span> p algebraic init refl _ root<span class="main">]</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> representative_poly_def init Let_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span> 

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Soundness Proof for Real Algebraic Polynomials›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We basically use the result for complex algebraic polynomials which 
  are a superset of real algebraic polynomials.›</span></span>


<span class="keyword1" id="Roots_of_Algebraic_Poly-initial_root_problem_complex_of_real_poly"><span class="command">lemma</span></span> initial_root_problem_complex_of_real_poly<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"initial_root_problem <span class="main">(</span>map_poly complex_of_real <span class="free">p</span><span class="main">)</span> <span class="main">=</span> 
   map_prod id <span class="main">(</span>map <span class="main">(</span>map_prod id <span class="main">(</span>map_prod complex_of_real id<span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>initial_root_problem <span class="free">p</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?c</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"of_real <span class="main">::</span> real <span class="main">⇒</span> complex"</span></span> 
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?cp</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"map_poly <span class="var">?c</span>"</span></span> 
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?p</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="var">?cp</span> <span class="free">p</span> <span class="main">::</span> complex poly"</span></span> 
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">cn</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">cn</span> <span class="main">=</span> degree <span class="var">?p</span>"</span></span> 
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">n</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">=</span> degree <span class="free">p</span>"</span></span> 
  <span class="keyword1"><span class="command">have</span></span> n<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">cn</span> <span class="main">=</span> <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> n_def cn_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">note</span></span> def <span class="main">=</span> initial_root_problem_def<span class="main">[</span><span class="operator">of</span> <span class="var"><span class="quoted"><span class="var">?p</span></span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">note</span></span> def <span class="main">=</span> def<span class="main">[</span><span class="operator">folded</span> cn_def<span class="main">,</span> <span class="operator">unfolded</span> n<span class="main">]</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">ccs</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ccs</span> <span class="main">=</span> coeffs <span class="var">?p</span>"</span></span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">cs</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">cs</span> <span class="main">=</span> coeffs <span class="free">p</span>"</span></span> 
  <span class="keyword1"><span class="command">have</span></span> cs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">ccs</span> <span class="main">=</span> map <span class="var">?c</span> <span class="skolem">cs</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> ccs_def cs_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">note</span></span> def <span class="main">=</span> def<span class="main">[</span><span class="operator">folded</span> ccs_def<span class="main">]</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">crcs</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">crcs</span> <span class="main">=</span> remdups <span class="main">(</span>filter <span class="main">(</span><span class="main">λ</span><span class="bound">c</span><span class="main">.</span> <span class="bound">c</span> <span class="main">∉</span> <span class="main">ℤ</span><span class="main">)</span> <span class="skolem">ccs</span><span class="main">)</span>"</span></span> 
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">rcs</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">rcs</span> <span class="main">=</span> remdups <span class="main">(</span>filter <span class="main">(</span><span class="main">λ</span><span class="bound">c</span><span class="main">.</span> <span class="bound">c</span> <span class="main">∉</span> <span class="main">ℤ</span><span class="main">)</span> <span class="skolem">cs</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">have</span></span> rcs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">crcs</span> <span class="main">=</span> map <span class="var">?c</span> <span class="skolem">rcs</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> crcs_def rcs_def cs <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">cs</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">cpairs</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">cpairs</span> <span class="main">=</span> map <span class="main">(</span><span class="main">λ</span><span class="bound">c</span><span class="main">.</span> <span class="main">(</span><span class="bound">c</span><span class="main">,</span> min_int_poly <span class="bound">c</span><span class="main">)</span><span class="main">)</span> <span class="skolem">crcs</span>"</span></span> 
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">pairs</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">pairs</span> <span class="main">=</span> map <span class="main">(</span><span class="main">λ</span><span class="bound">c</span><span class="main">.</span> <span class="main">(</span><span class="bound">c</span><span class="main">,</span> min_int_poly <span class="bound">c</span><span class="main">)</span><span class="main">)</span> <span class="skolem">rcs</span>"</span></span> 
  <span class="keyword1"><span class="command">have</span></span> pairs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">cpairs</span> <span class="main">=</span> map <span class="main">(</span>map_prod <span class="var">?c</span> id<span class="main">)</span> <span class="skolem">pairs</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> pairs_def cpairs_def rcs <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">cspairs</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">cspairs</span> <span class="main">=</span> sort_key <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">c</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> degree <span class="bound">y</span><span class="main">)</span> <span class="skolem">cpairs</span>"</span></span> 
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">spairs</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">spairs</span> <span class="main">=</span> sort_key <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">c</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> degree <span class="bound">y</span><span class="main">)</span> <span class="skolem">pairs</span>"</span></span> 
  <span class="keyword1"><span class="command">have</span></span> spairs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">cspairs</span> <span class="main">=</span> map <span class="main">(</span>map_prod <span class="var">?c</span> id<span class="main">)</span> <span class="skolem">spairs</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> spairs_def cspairs_def pairs 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> sym<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> map_sort_key<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">ctriples</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ctriples</span> <span class="main">=</span> zip <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span>length <span class="skolem">cspairs</span><span class="main">]</span> <span class="skolem">cspairs</span>"</span></span> 
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">triples</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">triples</span> <span class="main">=</span> zip <span class="main">[</span><span class="main">0</span><span class="main">..&lt;</span>length <span class="skolem">spairs</span><span class="main">]</span> <span class="skolem">spairs</span>"</span></span> 
  <span class="keyword1"><span class="command">have</span></span> triples<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">ctriples</span> <span class="main">=</span> map <span class="main">(</span>map_prod id <span class="main">(</span>map_prod <span class="var">?c</span> id<span class="main">)</span><span class="main">)</span> <span class="skolem">triples</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> ctriples_def triples_def spairs <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> nth_equalityI<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> def <span class="main">=</span> def<span class="main">[</span><span class="operator">unfolded</span> Let_def<span class="main">,</span> <span class="operator">folded</span> crcs_def<span class="main">,</span> <span class="operator">folded</span> cpairs_def<span class="main">,</span> <span class="operator">folded</span> cspairs_def<span class="main">,</span> <span class="operator">folded</span> ctriples_def<span class="main">,</span>
      <span class="operator">unfolded</span> of_real_hom.coeff_map_poly_hom<span class="main">]</span>
  <span class="keyword1"><span class="command">note</span></span> def2 <span class="main">=</span> initial_root_problem_def<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">p</span></span><span class="main">,</span> <span class="operator">unfolded</span> Let_def<span class="main">,</span> <span class="operator">folded</span> n_def cs_def<span class="main">,</span> <span class="operator">folded</span> rcs_def<span class="main">,</span> <span class="operator">folded</span> pairs_def<span class="main">,</span>
      <span class="operator">folded</span> spairs_def<span class="main">,</span> <span class="operator">folded</span> triples_def<span class="main">]</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"initial_root_problem <span class="var">?p</span> <span class="main">=</span> map_prod id <span class="main">(</span>map <span class="main">(</span>map_prod id <span class="main">(</span>map_prod <span class="var">?c</span> id<span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>initial_root_problem <span class="free">p</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> def def2 triples to_int_complex_of_real
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">intro</span> sum.cong refl arg_cong<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main"><span class="main">λ</span></span></span> <span class="bound"><span class="bound"><span class="bound">x</span></span></span><span class="main"><span class="main"><span class="main">.</span></span></span> <span class="main"><span class="main"><span class="main">_</span></span></span> <span class="main"><span class="main"><span class="main">*</span></span></span> <span class="bound"><span class="bound"><span class="bound">x</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">induct</span> <span class="quoted"><span class="skolem">triples</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1" id="Roots_of_Algebraic_Poly-representative_poly_real"><span class="command">lemma</span></span> representative_poly_real<span class="main">:</span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span> <span class="main">::</span> <span class="quoted">real</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> p<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> algebraic<span class="main">:</span> <span class="quoted"><span class="quoted">"Ball <span class="main">(</span>set <span class="main">(</span>coeffs <span class="free">p</span><span class="main">)</span><span class="main">)</span> algebraic"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> root<span class="main">:</span> <span class="quoted"><span class="quoted">"poly <span class="free">p</span> <span class="free">x</span> <span class="main">=</span> <span class="main">0</span>"</span></span> 
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"representative_poly <span class="free">p</span> <span class="keyword1">represents</span> <span class="free">x</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">mp</span></span> <span class="skolem"><span class="skolem">triples</span></span> <span class="keyword2"><span class="keyword">where</span></span> init<span class="main">:</span> <span class="quoted"><span class="quoted">"initial_root_problem <span class="free">p</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">mp</span><span class="main">,</span> <span class="skolem">triples</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="quoted">"<span class="skolem"><span class="skolem">is</span></span>"</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">is</span> <span class="main">=</span> map fst <span class="skolem">triples</span>"</span></span> 
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">qs</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">qs</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">j</span><span class="main">.</span> snd <span class="main">(</span>snd <span class="main">(</span><span class="skolem">triples</span> <span class="main">!</span> <span class="bound">j</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?c</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"of_real <span class="main">::</span> real <span class="main">⇒</span> complex"</span></span> 
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?cp</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"map_poly <span class="var">?c</span>"</span></span> 
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?ct</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"map <span class="main">(</span>map_prod id <span class="main">(</span>map_prod <span class="var">?c</span> id<span class="main">)</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?p</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="var">?cp</span> <span class="free">p</span> <span class="main">::</span> complex poly"</span></span> 
  <span class="keyword1"><span class="command">have</span></span> p<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?p</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> p <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"initial_root_problem <span class="var">?p</span> <span class="main">=</span> map_prod id <span class="var">?ct</span> <span class="main">(</span>initial_root_problem <span class="free">p</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> initial_root_problem_complex_of_real_poly<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> this<span class="main">[</span><span class="operator">unfolded</span> init<span class="main">]</span> 
  <span class="keyword1"><span class="command">have</span></span> res<span class="main">:</span> <span class="quoted"><span class="quoted">"initial_root_problem <span class="var">?p</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">mp</span><span class="main">,</span> <span class="var">?ct</span> <span class="skolem">triples</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> root <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">=</span> <span class="var">?c</span> <span class="main">(</span>poly <span class="free">p</span> <span class="free">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> poly <span class="var">?p</span> <span class="main">(</span><span class="var">?c</span> <span class="free">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> root<span class="main">:</span> <span class="quoted"><span class="quoted">"poly <span class="var">?p</span> <span class="main">(</span><span class="var">?c</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">have</span></span> qs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">&lt;</span> length <span class="skolem">is</span> <span class="main">⟹</span> <span class="skolem">qs</span> <span class="skolem">j</span> <span class="main">=</span> snd <span class="main">(</span>snd <span class="main">(</span><span class="var">?ct</span> <span class="skolem">triples</span> <span class="main">!</span> <span class="skolem">j</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">j</span>
    <span class="keyword1"><span class="command">unfolding</span></span> is_def qs_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> set_conv_nth<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted">"is"</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">is</span> <span class="main">=</span> map fst <span class="main">(</span><span class="var">?ct</span> <span class="skolem">triples</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> is_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> 
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">cc</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">cc</span> <span class="main">∈</span> set <span class="main">(</span>coeffs <span class="var">?p</span><span class="main">)</span>"</span></span> 
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">c</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="main">∈</span> set <span class="main">(</span>coeffs <span class="free">p</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> cc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">cc</span> <span class="main">=</span> <span class="var">?c</span> <span class="skolem">c</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> algebraic this<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"algebraic <span class="skolem">cc</span>"</span></span> 
      <span class="keyword1"><span class="command">unfolding</span></span> cc algebraic_complex_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">hence</span></span> algebraic<span class="main">:</span> <span class="quoted"><span class="quoted">"Ball <span class="main">(</span>set <span class="main">(</span>coeffs <span class="var">?p</span><span class="main">)</span><span class="main">)</span> algebraic"</span></span> <span class="keyword1"><span class="command">..</span></span> 
  <span class="keyword1"><span class="command">from</span></span> get_representative_complex<span class="main">[</span><span class="operator">OF</span> p this res <span class="quoted">"is"</span> qs root<span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"eliminate_aux_vars <span class="skolem">mp</span> <span class="skolem">qs</span> <span class="skolem">is</span> <span class="keyword1">represents</span> <span class="var">?c</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"eliminate_aux_vars <span class="skolem">mp</span> <span class="skolem">qs</span> <span class="skolem">is</span> <span class="keyword1">represents</span> <span class="free">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> representative_poly_def res init split Let_def qs_def is_def <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Algebraic Closedness of Complex Algebraic Numbers›</span></span>

<span class="comment1">(* TODO: could be generalised to arbitrary algebraically closed fields? *)</span>
<span class="keyword1" id="Roots_of_Algebraic_Poly-complex_algebraic_numbers_are_algebraically_closed"><span class="command">lemma</span></span> complex_algebraic_numbers_are_algebraically_closed<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> nc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> constant <span class="main">(</span>poly <span class="free">p</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> alg<span class="main">:</span> <span class="quoted"><span class="quoted">"Ball <span class="main">(</span>set <span class="main">(</span>coeffs <span class="free">p</span><span class="main">)</span><span class="main">)</span> algebraic"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span> <span class="bound">z</span> <span class="main">::</span> complex<span class="main">.</span> algebraic <span class="bound">z</span> <span class="main">∧</span> poly <span class="free">p</span> <span class="bound">z</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> fundamental_theorem_of_algebra<span class="main">[</span><span class="operator">OF</span> nc<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">z</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    root<span class="main">:</span> <span class="quoted"><span class="quoted">"poly <span class="free">p</span> <span class="skolem">z</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> algebraic_representsI<span class="main">[</span><span class="operator">OF</span> representative_poly_complex<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ alg root<span class="main"><span class="main">]</span></span><span class="main">]</span> nc root
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"algebraic <span class="skolem">z</span> <span class="main">∧</span> poly <span class="free">p</span> <span class="skolem">z</span> <span class="main">=</span> <span class="main">0</span>"</span></span> 
    <span class="keyword1"><span class="command">using</span></span> constant_degree degree_0 <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="Roots_of_Algebraic_Poly_Impl">
<div class="head">
<h1>Theory Roots_of_Algebraic_Poly_Impl</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Executable Version to Compute Representative Polynomials›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Roots_of_Algebraic_Poly_Impl
<span class="keyword2"><span class="keyword">imports</span></span> 
  <a href="#Roots_of_Algebraic_Poly">Roots_of_Algebraic_Poly</a>
  <a href="../../polynomials/theories/#MPoly_Type_Class_FMap">Polynomials.MPoly_Type_Class_FMap</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We need to specialize our code to real and complex polynomials, 
  since <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> algebraic<span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> min_int_poly<span class="antiquote"><span class="antiquote">}</span></span></span></span> are
  not executable in their parametric versions.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">initial_root_problem_real</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"real poly <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">initial_root_problem_real</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> initial_root_problem <span class="free"><span class="bound"><span class="entity">p</span></span></span>"</span></span> 

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">initial_root_problem_complex</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"complex poly <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">initial_root_problem_complex</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> initial_root_problem <span class="free"><span class="bound"><span class="entity">p</span></span></span>"</span></span> 

<span class="keyword1"><span class="command">lemmas</span></span> initial_root_problem_code <span class="main">=</span> 
  initial_root_problem_real_def<span class="main">[</span><span class="operator">unfolded</span> initial_root_problem_def<span class="main">]</span>
  initial_root_problem_complex_def<span class="main">[</span><span class="operator">unfolded</span> initial_root_problem_def<span class="main">]</span>

<span class="keyword1"><span class="command">declare</span></span> initial_root_problem_code<span class="main">[</span><span class="operator">code</span><span class="main">]</span>

<span class="keyword1" id="Roots_of_Algebraic_Poly_Impl-initial_root_problem_code_unfold"><span class="command">lemma</span></span> initial_root_problem_code_unfold<span class="main">[</span><span class="operator">code_unfold</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"initial_root_problem <span class="main">=</span> initial_root_problem_complex"</span></span> 
  <span class="quoted"><span class="quoted">"initial_root_problem <span class="main">=</span> initial_root_problem_real"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> ext<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">representative_poly_real</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"real poly <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">representative_poly_real</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> representative_poly <span class="free"><span class="bound"><span class="entity">p</span></span></span>"</span></span> 

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">representative_poly_complex</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"complex poly <span class="main">⇒</span> <span class="main">_</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">representative_poly_complex</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> representative_poly <span class="free"><span class="bound"><span class="entity">p</span></span></span>"</span></span> 

<span class="keyword1"><span class="command">lemmas</span></span> representative_poly_code <span class="main">=</span> 
  representative_poly_real_def<span class="main">[</span><span class="operator">unfolded</span> representative_poly_def<span class="main">]</span>
  representative_poly_complex_def<span class="main">[</span><span class="operator">unfolded</span> representative_poly_def<span class="main">]</span>

<span class="keyword1"><span class="command">declare</span></span> representative_poly_code<span class="main">[</span><span class="operator">code</span><span class="main">]</span>

<span class="keyword1" id="Roots_of_Algebraic_Poly_Impl-representative_poly_code_unfold"><span class="command">lemma</span></span> representative_poly_code_unfold<span class="main">[</span><span class="operator">code_unfold</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"representative_poly <span class="main">=</span> representative_poly_complex"</span></span> 
  <span class="quoted"><span class="quoted">"representative_poly <span class="main">=</span> representative_poly_real"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> ext<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹TODO: after merging with AFP devel, this code equation can be removed as it is already present there.›</span></span>
<span class="keyword1" id="Roots_of_Algebraic_Poly_Impl-algebraic_complex_fun"><span class="command">lemma</span></span> algebraic_complex_fun<span class="main">[</span><span class="operator">code_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"algebraic <span class="main">=</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">x</span><span class="main">.</span> algebraic <span class="main">(</span>Re <span class="bound">x</span><span class="main">)</span> <span class="main">∧</span> algebraic <span class="main">(</span>Im <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> ext<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> algebraic_complex_iff<span class="main">)</span>

 
<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="Roots_of_Real_Complex_Poly">
<div class="head">
<h1>Theory Roots_of_Real_Complex_Poly</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Roots of Real and Complex Algebraic Polynomials›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We are now able to actually compute all roots of polynomials
  with real and complex algebraic coefficients. The main addition to
  calculating the representative polynomial for a superset of all roots
  is to find the genuine roots. For this we utilize the approximation algorithm
  via interval arithmetic.›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Roots_of_Real_Complex_Poly
  <span class="keyword2"><span class="keyword">imports</span></span>
    <a href="#Roots_of_Algebraic_Poly_Impl">Roots_of_Algebraic_Poly_Impl</a>
    <a href="#Roots_via_IA">Roots_via_IA</a>
    <a href="#MPoly_Container">MPoly_Container</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">hide_const</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="main">)</span> Module.smult

<span class="keyword1"><span class="command">typedef</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">overloaded</span></span><span class="main">)</span> <span class="tfree">'a</span> rf_poly <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span> <span class="bound">p</span> <span class="main">::</span> <span class="tfree">'a</span> <span class="main">::</span> idom poly<span class="main">.</span> rsquarefree <span class="bound">p</span><span class="main">}</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> exI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="main"><span class="quoted"><span class="main"><span class="quoted"><span class="main">1</span></span></span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rsquarefree_def<span class="main">)</span>

<span class="keyword1"><span class="command">setup_lifting</span></span> type_definition_rf_poly

<span class="keyword1"><span class="command">context</span></span> 
<span class="keyword2"><span class="keyword">begin</span></span> 
<span class="keyword1"><span class="command">lifting_forget</span></span> poly.lifting

<span class="keyword1"><span class="command">lift_definition</span></span> poly_rf <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> idom rf_poly <span class="main">⇒</span> <span class="tfree">'a</span> poly"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">roots_of_poly_dummy</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span><span class="main">{</span>comm_ring_1<span class="main">,</span>ring_no_zero_divisors<span class="main">}</span> poly <span class="main">⇒</span> <span class="main">_</span>"</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">roots_of_poly_dummy</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">SOME</span> <span class="bound">xs</span><span class="main">.</span> set <span class="bound">xs</span> <span class="main">=</span> <span class="main">{</span><span class="bound">r</span><span class="main">.</span> poly <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="bound">r</span> <span class="main">=</span> <span class="main">0</span><span class="main">}</span> <span class="main">∧</span> distinct <span class="bound">xs</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Roots_of_Real_Complex_Poly-roots_of_poly_dummy_code"><span class="command">lemma</span></span> roots_of_poly_dummy_code<span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"roots_of_poly_dummy <span class="free">p</span> <span class="main">=</span> Code.abort <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''roots-of-poly-dummy''</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span> <span class="bound">x</span><span class="main">.</span> roots_of_poly_dummy <span class="free">p</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Roots_of_Real_Complex_Poly-roots_of_poly_dummy"><span class="command">lemma</span></span> roots_of_poly_dummy<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> p<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>roots_of_poly_dummy <span class="free">p</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> poly <span class="free">p</span> <span class="bound">x</span> <span class="main">=</span> <span class="main">0</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>roots_of_poly_dummy <span class="free">p</span><span class="main">)</span>"</span></span> 
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> someI_ex<span class="main">[</span><span class="operator">OF</span> finite_distinct_list<span class="main"><span class="main">[</span></span><span class="operator">OF</span> poly_roots_finite<span class="main"><span class="main">[</span></span><span class="operator">OF</span> p<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="operator">folded</span> roots_of_poly_dummy_def<span class="main">]</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>roots_of_poly_dummy <span class="free">p</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> poly <span class="free">p</span> <span class="bound">x</span> <span class="main">=</span> <span class="main">0</span><span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>roots_of_poly_dummy <span class="free">p</span><span class="main">)</span>"</span></span>  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> roots_of_complex_rf_poly_part1 <span class="main">::</span> <span class="quoted"><span class="quoted">"complex rf_poly <span class="main">⇒</span> complex genuine_roots_aux"</span></span> <span class="keyword2"><span class="keyword">is</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="bound">p</span><span class="main">.</span> <span class="keyword1">if</span> Ball <span class="main">(</span>set <span class="main">(</span>Polynomial.coeffs <span class="bound">p</span><span class="main">)</span><span class="main">)</span> algebraic <span class="keyword1">then</span> 
        <span class="keyword1">let</span> <span class="bound">q</span> <span class="main">=</span> representative_poly <span class="bound">p</span><span class="main">;</span>
         <span class="bound">zeros</span> <span class="main">=</span> complex_roots_of_int_poly <span class="bound">q</span>
         <span class="keyword1">in</span> <span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">zeros</span><span class="main">,</span>Polynomial.degree <span class="bound">p</span><span class="main">,</span> filter_fun_complex <span class="bound">p</span><span class="main">)</span>
        <span class="keyword1">else</span> <span class="main">(</span><span class="bound">p</span><span class="main">,</span>roots_of_poly_dummy <span class="bound">p</span><span class="main">,</span>Polynomial.degree <span class="bound">p</span><span class="main">,</span> filter_fun_complex <span class="bound">p</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> p
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword3"><span class="command">assume</span></span> rp<span class="main">:</span> <span class="quoted"><span class="quoted">"rsquarefree <span class="skolem">p</span>"</span></span> 
    <span class="keyword1"><span class="command">hence</span></span> card<span class="main">:</span> <span class="quoted"><span class="quoted">"card <span class="main">{</span><span class="bound">x</span><span class="main">.</span> poly <span class="skolem">p</span> <span class="bound">x</span> <span class="main">=</span> <span class="main">0</span><span class="main">}</span> <span class="main">=</span> Polynomial.degree <span class="skolem">p</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> rsquarefree_card_degree rsquarefree_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">from</span></span> rp <span class="keyword1"><span class="command">have</span></span> p<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> rsquarefree_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> ff<span class="main">:</span> <span class="quoted"><span class="quoted">"filter_fun <span class="skolem">p</span> <span class="main">(</span>filter_fun_complex <span class="skolem">p</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> filter_fun_complex<span class="main">)</span> 
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"Ball <span class="main">(</span>set <span class="main">(</span>Polynomial.coeffs <span class="skolem">p</span><span class="main">)</span><span class="main">)</span> algebraic"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> False 
      <span class="keyword1"><span class="command">with</span></span> roots_of_poly_dummy<span class="main">[</span><span class="operator">OF</span> p<span class="main">]</span> ff
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> rp card <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> True
      <span class="keyword1"><span class="command">from</span></span> rp card representative_poly_complex<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">p</span></span><span class="main">]</span> 
        complex_roots_of_int_poly<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted">"representative_poly <span class="skolem"><span class="skolem">p</span></span>"</span></span></span><span class="main">]</span> ff
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> Let_def rsquarefree_def <span class="keyword1"><span class="command">using</span></span> True <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">lift_definition</span></span> roots_of_real_rf_poly_part1 <span class="main">::</span> <span class="quoted"><span class="quoted">"real rf_poly <span class="main">⇒</span> real genuine_roots_aux"</span></span> <span class="keyword2"><span class="keyword">is</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="bound">p</span><span class="main">.</span> <span class="keyword1">let</span> <span class="bound">n</span> <span class="main">=</span> count_roots <span class="bound">p</span> <span class="keyword1">in</span> 
        <span class="keyword1">if</span> Ball <span class="main">(</span>set <span class="main">(</span>Polynomial.coeffs <span class="bound">p</span><span class="main">)</span><span class="main">)</span> algebraic <span class="keyword1">then</span> 
        <span class="keyword1">let</span> <span class="bound">q</span> <span class="main">=</span> representative_poly <span class="bound">p</span><span class="main">;</span>
         <span class="bound">zeros</span> <span class="main">=</span> real_roots_of_int_poly <span class="bound">q</span>
         <span class="keyword1">in</span> <span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">zeros</span><span class="main">,</span><span class="bound">n</span><span class="main">,</span> filter_fun_real <span class="bound">p</span><span class="main">)</span>
        <span class="keyword1">else</span> <span class="main">(</span><span class="bound">p</span><span class="main">,</span>roots_of_poly_dummy <span class="bound">p</span><span class="main">,</span><span class="bound">n</span><span class="main">,</span> filter_fun_real <span class="bound">p</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> p
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword3"><span class="command">assume</span></span> rp<span class="main">:</span> <span class="quoted"><span class="quoted">"rsquarefree <span class="skolem">p</span>"</span></span> 
    <span class="keyword1"><span class="command">from</span></span> rp <span class="keyword1"><span class="command">have</span></span> p<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> rsquarefree_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> ff<span class="main">:</span> <span class="quoted"><span class="quoted">"filter_fun <span class="skolem">p</span> <span class="main">(</span>filter_fun_real <span class="skolem">p</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> filter_fun_real<span class="main">)</span> 
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"Ball <span class="main">(</span>set <span class="main">(</span>Polynomial.coeffs <span class="skolem">p</span><span class="main">)</span><span class="main">)</span> algebraic"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> False 
      <span class="keyword1"><span class="command">with</span></span> roots_of_poly_dummy<span class="main">[</span><span class="operator">OF</span> p<span class="main">]</span> ff
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> rp <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def count_roots_correct<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> True
      <span class="keyword1"><span class="command">from</span></span> rp representative_poly_real<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">p</span></span><span class="main">]</span> 
        real_roots_of_int_poly<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted">"representative_poly <span class="skolem"><span class="skolem">p</span></span>"</span></span></span><span class="main">]</span> ff
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> Let_def rsquarefree_def <span class="keyword1"><span class="command">using</span></span> True 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> count_roots_correct<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">roots_of_complex_rf_poly</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"complex rf_poly <span class="main">⇒</span> complex list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">roots_of_complex_rf_poly</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> genuine_roots_impl <span class="main">(</span>roots_of_complex_rf_poly_part1 <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span>"</span></span> 

<span class="keyword1" id="Roots_of_Real_Complex_Poly-roots_of_complex_rf_poly"><span class="command">lemma</span></span> roots_of_complex_rf_poly<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>roots_of_complex_rf_poly <span class="free">p</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> poly <span class="main">(</span>poly_rf <span class="free">p</span><span class="main">)</span> <span class="bound">x</span> <span class="main">=</span> <span class="main">0</span><span class="main">}</span>"</span></span> 
  <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>roots_of_complex_rf_poly <span class="free">p</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> roots_of_complex_rf_poly_def genuine_roots_impl
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> genuine_roots_impl<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">roots_of_real_rf_poly</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"real rf_poly <span class="main">⇒</span> real list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">roots_of_real_rf_poly</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> genuine_roots_impl <span class="main">(</span>roots_of_real_rf_poly_part1 <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span>"</span></span> 

<span class="keyword1" id="Roots_of_Real_Complex_Poly-roots_of_real_rf_poly"><span class="command">lemma</span></span> roots_of_real_rf_poly<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>roots_of_real_rf_poly <span class="free">p</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> poly <span class="main">(</span>poly_rf <span class="free">p</span><span class="main">)</span> <span class="bound">x</span> <span class="main">=</span> <span class="main">0</span><span class="main">}</span>"</span></span> 
  <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>roots_of_real_rf_poly <span class="free">p</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> roots_of_real_rf_poly_def genuine_roots_impl
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> genuine_roots_impl Let_def<span class="main">)</span>

<span class="keyword1"><span class="command">typedef</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">overloaded</span></span><span class="main">)</span> <span class="tfree">'a</span> rf_polys <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span> <span class="main">(</span><span class="bound">a</span> <span class="main">::</span> <span class="tfree">'a</span> <span class="main">::</span> idom<span class="main">,</span> <span class="bound">ps</span> <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> poly <span class="main">×</span> nat<span class="main">)</span> list<span class="main">)</span><span class="main">.</span> Ball <span class="main">(</span>fst <span class="main">`</span> set <span class="bound">ps</span><span class="main">)</span> rsquarefree<span class="main">}</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> exI<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main"><span class="main">(</span></span></span><span class="main"><span class="main"><span class="main">_</span></span></span><span class="main"><span class="main"><span class="main">,</span></span></span>Nil<span class="main"><span class="main"><span class="main">)</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">setup_lifting</span></span> type_definition_rf_polys

<span class="keyword1"><span class="command">lift_definition</span></span> yun_polys <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> <span class="main">{</span>euclidean_ring_gcd<span class="main">,</span>field_char_0<span class="main">,</span>semiring_gcd_mult_normalize<span class="main">}</span> poly <span class="main">⇒</span> <span class="tfree">'a</span> rf_polys"</span></span>
  <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="bound">p</span><span class="main">.</span> yun_factorization gcd <span class="bound">p</span>"</span></span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> p
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> square_free_rsquarefree<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">insert</span> yun_factorization<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">p</span></span></span></span></span></span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">OF</span> refl<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"yun_factorization gcd <span class="skolem">p</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> square_free_factorizationD<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">typedef_overloaded</span><span class="main">]</span><span class="main">]</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">lift_definition</span></span> <span class="main">(</span>code_dt<span class="main">)</span> yun_rf <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> idom rf_polys <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">×</span> <span class="main">(</span><span class="tfree">'a</span> rf_poly <span class="main">×</span> nat<span class="main">)</span> list"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span>"</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> list_all_iff<span class="main"><span class="keyword3">,</span></span> <span class="operator">force</span><span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword2"><span class="keyword">end</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">polys_rf</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> idom rf_polys <span class="main">⇒</span> <span class="tfree">'a</span> rf_poly list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">polys_rf</span> <span class="main">=</span> map fst <span class="keyword1">o</span> snd <span class="keyword1">o</span> yun_rf"</span></span> 

<span class="keyword1" id="Roots_of_Real_Complex_Poly-yun_polys"><span class="command">lemma</span></span> yun_polys<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"poly <span class="free">p</span> <span class="free">x</span> <span class="main">=</span> <span class="main">0</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span> <span class="bound">q</span> <span class="main">∈</span> set <span class="main">(</span>polys_rf <span class="main">(</span>yun_polys <span class="free">p</span><span class="main">)</span><span class="main">)</span><span class="main">.</span> poly <span class="main">(</span>poly_rf <span class="bound">q</span><span class="main">)</span> <span class="free">x</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> polys_rf_def o_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">transfer</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> p x
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword3"><span class="command">assume</span></span> p<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">c</span></span> <span class="skolem"><span class="skolem">ps</span></span> <span class="keyword2"><span class="keyword">where</span></span> yun<span class="main">:</span> <span class="quoted"><span class="quoted">"yun_factorization gcd <span class="skolem">p</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">c</span><span class="main">,</span><span class="skolem">ps</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
    <span class="keyword1"><span class="command">from</span></span> yun_factorization<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> sff<span class="main">:</span> <span class="quoted"><span class="quoted">"square_free_factorization <span class="skolem">p</span> <span class="main">(</span><span class="skolem">c</span><span class="main">,</span> <span class="skolem">ps</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> square_free_factorizationD'<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> sff<span class="main">]</span> p <span class="keyword1"><span class="command">have</span></span> c0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> yun 
      <span class="keyword1"><span class="command">unfolding</span></span> square_free_factorizationD'<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> sff<span class="main">]</span> poly_smult poly_prod_list snd_conv
      mult_eq_0_iff prod_list_zero_iff
      <span class="keyword1"><span class="command">using</span></span> c0 <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">roots_of_complex_rf_polys</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"complex rf_polys <span class="main">⇒</span> complex list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">roots_of_complex_rf_polys</span> <span class="free"><span class="bound"><span class="entity">ps</span></span></span> <span class="main">=</span> concat <span class="main">(</span>map roots_of_complex_rf_poly <span class="main">(</span>polys_rf <span class="free"><span class="bound"><span class="entity">ps</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span> 

<span class="keyword1" id="Roots_of_Real_Complex_Poly-roots_of_complex_rf_polys"><span class="command">lemma</span></span> roots_of_complex_rf_polys<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"set <span class="main">(</span>roots_of_complex_rf_polys <span class="free">ps</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="main">∃</span> <span class="bound">p</span> <span class="main">∈</span> set <span class="main">(</span>polys_rf <span class="free">ps</span><span class="main">)</span><span class="main">.</span> poly <span class="main">(</span>poly_rf <span class="bound">p</span><span class="main">)</span> <span class="bound">x</span> <span class="main">=</span> <span class="main">0</span> <span class="main">}</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> roots_of_complex_rf_polys_def set_concat set_map image_comp o_def
    roots_of_complex_rf_poly <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">roots_of_real_rf_polys</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"real rf_polys <span class="main">⇒</span> real list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">roots_of_real_rf_polys</span> <span class="free"><span class="bound"><span class="entity">ps</span></span></span> <span class="main">=</span> concat <span class="main">(</span>map roots_of_real_rf_poly <span class="main">(</span>polys_rf <span class="free"><span class="bound"><span class="entity">ps</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span> 

<span class="keyword1" id="Roots_of_Real_Complex_Poly-roots_of_real_rf_polys"><span class="command">lemma</span></span> roots_of_real_rf_polys<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"set <span class="main">(</span>roots_of_real_rf_polys <span class="free">ps</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="main">∃</span> <span class="bound">p</span> <span class="main">∈</span> set <span class="main">(</span>polys_rf <span class="free">ps</span><span class="main">)</span><span class="main">.</span> poly <span class="main">(</span>poly_rf <span class="bound">p</span><span class="main">)</span> <span class="bound">x</span> <span class="main">=</span> <span class="main">0</span> <span class="main">}</span>"</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> roots_of_real_rf_polys_def set_concat set_map image_comp o_def
    roots_of_real_rf_poly <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">roots_of_complex_poly</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"complex poly <span class="main">⇒</span> complex list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">roots_of_complex_poly</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">[]</span> <span class="keyword1">else</span> roots_of_complex_rf_polys <span class="main">(</span>yun_polys <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span> 

<span class="keyword1" id="Roots_of_Real_Complex_Poly-roots_of_complex_poly"><span class="command">lemma</span></span> roots_of_complex_poly<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> p<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>roots_of_complex_poly <span class="free">p</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> poly <span class="free">p</span> <span class="bound">x</span> <span class="main">=</span> <span class="main">0</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> p <span class="keyword1"><span class="command">unfolding</span></span> roots_of_complex_poly_def 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> roots_of_complex_rf_polys yun_polys<span class="main"><span class="main">[</span></span><span class="operator">OF</span> p<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">roots_of_real_poly</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"real poly <span class="main">⇒</span> real list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">roots_of_real_poly</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="main">[]</span> <span class="keyword1">else</span> roots_of_real_rf_polys <span class="main">(</span>yun_polys <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span> 

<span class="keyword1" id="Roots_of_Real_Complex_Poly-roots_of_real_poly"><span class="command">lemma</span></span> roots_of_real_poly<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> p<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> 
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>roots_of_real_poly <span class="free">p</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> poly <span class="free">p</span> <span class="bound">x</span> <span class="main">=</span> <span class="main">0</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> p <span class="keyword1"><span class="command">unfolding</span></span> roots_of_real_poly_def 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> roots_of_real_rf_polys yun_polys<span class="main"><span class="main">[</span></span><span class="operator">OF</span> p<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Roots_of_Real_Complex_Poly-distinct_concat'"><span class="command">lemma</span></span> distinct_concat'<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> distinct <span class="main">(</span>list_neq <span class="free">xs</span> <span class="main">[]</span><span class="main">)</span><span class="main">;</span>
     <span class="main">⋀</span> <span class="bound">ys</span><span class="main">.</span> <span class="bound">ys</span> <span class="main">∈</span> set <span class="free">xs</span> <span class="main">⟹</span> distinct <span class="bound">ys</span><span class="main">;</span>
     <span class="main">⋀</span> <span class="bound">ys</span> <span class="bound">zs</span><span class="main">.</span> <span class="main">⟦</span> <span class="bound">ys</span> <span class="main">∈</span> set <span class="free">xs</span> <span class="main">;</span> <span class="bound">zs</span> <span class="main">∈</span> set <span class="free">xs</span> <span class="main">;</span> <span class="bound">ys</span> <span class="main">≠</span> <span class="bound">zs</span> <span class="main">⟧</span> <span class="main">⟹</span> set <span class="bound">ys</span> <span class="main">∩</span> set <span class="bound">zs</span> <span class="main">=</span> <span class="main">{}</span>
   <span class="main">⟧</span> <span class="main">⟹</span> distinct <span class="main">(</span>concat <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>

<span class="keyword1" id="Roots_of_Real_Complex_Poly-roots_of_rf_yun_polys_distinct"><span class="command">lemma</span></span> roots_of_rf_yun_polys_distinct<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> 
  rt<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">p</span><span class="main">.</span> set <span class="main">(</span><span class="free">rop</span> <span class="bound">p</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> poly <span class="main">(</span>poly_rf <span class="bound">p</span><span class="main">)</span> <span class="bound">x</span> <span class="main">=</span> <span class="main">0</span><span class="main">}</span>"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> dist<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span> <span class="bound">p</span><span class="main">.</span> distinct <span class="main">(</span><span class="free">rop</span> <span class="bound">p</span><span class="main">)</span>"</span></span> 
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>concat <span class="main">(</span>map <span class="free">rop</span> <span class="main">(</span>polys_rf <span class="main">(</span>yun_polys <span class="free">p</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> polys_rf_def
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">goal_cases</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">rop</span> <span class="skolem">p</span><span class="main">)</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">c</span></span> <span class="skolem"><span class="skolem">fs</span></span> <span class="keyword2"><span class="keyword">where</span></span> yun<span class="main">:</span> <span class="quoted"><span class="quoted">"yun_factorization gcd <span class="skolem">p</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">c</span><span class="main">,</span><span class="skolem">fs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">note</span></span> sff <span class="main">=</span> yun_factorization<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> yun<span class="main">]</span>
  <span class="keyword1"><span class="command">note</span></span> sff1 <span class="main">=</span> square_free_factorizationD<span class="main">[</span><span class="operator">OF</span> sff<span class="main">]</span>
  <span class="keyword1"><span class="command">note</span></span> sff2 <span class="main">=</span> square_free_factorizationD'<span class="main">[</span><span class="operator">OF</span> sff<span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> rs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">p</span><span class="main">,</span><span class="skolem">i</span><span class="main">)</span> <span class="main">∈</span> set <span class="skolem">fs</span> <span class="main">⟹</span> rsquarefree <span class="skolem">p</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">p</span> <span class="skolem">i</span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> square_free_rsquarefree<span class="main"><span class="keyword3">,</span></span> <span class="operator">insert</span> sff1<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> 1 <span class="main">=</span> 1<span class="main">[</span><span class="operator">OF</span> rs<span class="main">]</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> yun snd_conv map_map o_def <span class="keyword1"><span class="command">using</span></span> 1 sff1<span class="main">(</span>3<span class="main">,</span>5<span class="main">)</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">fs</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">pi</span> <span class="skolem">fs</span><span class="main">)</span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p</span></span> <span class="skolem"><span class="skolem">i</span></span> <span class="keyword2"><span class="keyword">where</span></span> pi<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">pi</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">p</span><span class="main">,</span><span class="skolem">i</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">p</span><span class="main">,</span><span class="skolem">i</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span><span class="skolem">pi</span> <span class="main">#</span> <span class="skolem">fs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">note</span></span> p_i <span class="main">=</span> Cons<span class="main">(</span>2-4<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> IH<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>concat <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="skolem">rop</span> <span class="main">(</span>fst <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="skolem">fs</span><span class="main">)</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> Cons<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">OF</span> Cons<span class="main"><span class="main"><span class="main">(</span></span></span>2<span class="main"><span class="main"><span class="main">,</span></span></span>3<span class="main"><span class="main"><span class="main">,</span></span></span>4<span class="main"><span class="main"><span class="main">)</span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">insert</span> Cons<span class="main"><span class="main">(</span></span>5<span class="main"><span class="main">)</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span>
      <span class="keyword3"><span class="command">assume</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> set <span class="main">(</span><span class="skolem">rop</span> <span class="skolem">p</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">x</span><span class="main">∈</span>set <span class="skolem">fs</span><span class="main">.</span> set <span class="main">(</span><span class="skolem">rop</span> <span class="main">(</span>fst <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">from</span></span> x<span class="main">[</span><span class="operator">unfolded</span> p_i<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> rtp<span class="main">:</span> <span class="quoted"><span class="quoted">"poly <span class="skolem">p</span> <span class="skolem">x</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">from</span></span> x <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">q</span></span> <span class="skolem"><span class="skolem">j</span></span> <span class="keyword2"><span class="keyword">where</span></span> qj<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">q</span><span class="main">,</span><span class="skolem">j</span><span class="main">)</span> <span class="main">∈</span> set <span class="skolem">fs</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> set <span class="main">(</span><span class="skolem">rop</span> <span class="skolem">q</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
      <span class="keyword1"><span class="command">from</span></span> Cons<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">q</span></span> <span class="quoted"><span class="skolem">j</span></span><span class="main">]</span> x qj <span class="keyword1"><span class="command">have</span></span> rtq<span class="main">:</span> <span class="quoted"><span class="quoted">"poly <span class="skolem">q</span> <span class="skolem">x</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">from</span></span> Cons<span class="main">(</span>5<span class="main">)</span><span class="main">[</span><span class="operator">unfolded</span> pi<span class="main">]</span> qj <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">p</span><span class="main">,</span><span class="skolem">i</span><span class="main">)</span> <span class="main">≠</span> <span class="main">(</span><span class="skolem">q</span><span class="main">,</span><span class="skolem">j</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">from</span></span> p_i<span class="main">(</span>3<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> _ this<span class="main">]</span> qj <span class="keyword1"><span class="command">have</span></span> cop<span class="main">:</span> <span class="quoted"><span class="quoted">"algebraic_semidom_class.coprime <span class="skolem">p</span> <span class="skolem">q</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">from</span></span> rtp <span class="keyword1"><span class="command">have</span></span> dvdp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="main">-</span><span class="skolem">x</span><span class="main">,</span><span class="main">1</span><span class="main">:]</span> <span class="keyword1">dvd</span> <span class="skolem">p</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> poly_eq_0_iff_dvd <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">from</span></span> rtq <span class="keyword1"><span class="command">have</span></span> dvdq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="main">-</span><span class="skolem">x</span><span class="main">,</span><span class="main">1</span><span class="main">:]</span> <span class="keyword1">dvd</span> <span class="skolem">q</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> poly_eq_0_iff_dvd <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">from</span></span> cop dvdp dvdq <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"is_unit <span class="main">[:</span><span class="main">-</span><span class="skolem">x</span><span class="main">,</span><span class="main">1</span><span class="main">:]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> coprime_common_divisor<span class="main">)</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> pi <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> p_i<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> IH<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Roots_of_Real_Complex_Poly-distinct_roots_of_real_poly"><span class="command">lemma</span></span> distinct_roots_of_real_poly<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>roots_of_real_poly <span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> roots_of_real_poly_def roots_of_real_rf_polys_def
  <span class="keyword1"><span class="command">using</span></span> roots_of_rf_yun_polys_distinct<span class="main">[</span><span class="operator">of</span> <span class="quoted">roots_of_real_rf_poly</span> <span class="quoted"><span class="free">p</span></span><span class="main">,</span> <span class="operator">OF</span> roots_of_real_rf_poly<span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Roots_of_Real_Complex_Poly-distinct_roots_of_complex_poly"><span class="command">lemma</span></span> distinct_roots_of_complex_poly<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>roots_of_complex_poly <span class="free">p</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> roots_of_complex_poly_def roots_of_complex_rf_polys_def
  <span class="keyword1"><span class="command">using</span></span> roots_of_rf_yun_polys_distinct<span class="main">[</span><span class="operator">of</span> <span class="quoted">roots_of_complex_rf_poly</span> <span class="quoted"><span class="free">p</span></span><span class="main">,</span> <span class="operator">OF</span> roots_of_complex_rf_poly<span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>


<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="Factor_Complex_Poly">
<div class="head">
<h1>Theory Factor_Complex_Poly</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Factorization of Polynomials with Algebraic Coefficients›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Complex Algebraic Coefficients›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Factor_Complex_Poly
  <span class="keyword2"><span class="keyword">imports</span></span> 
    <a href="#Roots_of_Real_Complex_Poly">Roots_of_Real_Complex_Poly</a>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">hide_const</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="main">)</span> MPoly_Type.smult MPoly_Type.degree MPoly_Type.coeff MPoly_Type.coeffs

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">factor_complex_main</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"complex poly <span class="main">⇒</span> complex <span class="main">×</span> <span class="main">(</span>complex <span class="main">×</span> nat<span class="main">)</span> list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">factor_complex_main</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span> <span class="keyword1">let</span> <span class="main">(</span><span class="bound">c</span><span class="main">,</span><span class="bound">pis</span><span class="main">)</span> <span class="main">=</span> yun_rf <span class="main">(</span>yun_polys <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="keyword1">in</span>
    <span class="main">(</span><span class="bound">c</span><span class="main">,</span> concat <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span> <span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">i</span><span class="main">)</span><span class="main">.</span> map <span class="main">(</span><span class="main">λ</span> <span class="bound">r</span><span class="main">.</span> <span class="main">(</span><span class="bound">r</span><span class="main">,</span><span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>roots_of_complex_rf_poly <span class="bound">p</span><span class="main">)</span><span class="main">)</span> <span class="bound">pis</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Factor_Complex_Poly-factor_complex_main"><span class="command">lemma</span></span> factor_complex_main<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> rt<span class="main">:</span> <span class="quoted"><span class="quoted">"factor_complex_main <span class="free">p</span> <span class="main">=</span> <span class="main">(</span><span class="free">c</span><span class="main">,</span><span class="free">xis</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">=</span> smult <span class="free">c</span> <span class="main">(</span><span class="main">∏</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">i</span><span class="main">)</span><span class="main">←</span><span class="free">xis</span><span class="main">.</span> <span class="main">[:</span><span class="main">-</span> <span class="bound">x</span><span class="main">,</span> <span class="main">1</span><span class="main">:]</span> <span class="main">^</span> Suc <span class="bound">i</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">d</span></span> <span class="skolem"><span class="skolem">pis</span></span> <span class="keyword2"><span class="keyword">where</span></span> yun<span class="main">:</span> <span class="quoted"><span class="quoted">"yun_factorization gcd <span class="free">p</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">d</span><span class="main">,</span><span class="skolem">pis</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">d'</span></span> <span class="skolem"><span class="skolem">pis'</span></span> <span class="keyword2"><span class="keyword">where</span></span> yun_rf<span class="main">:</span> <span class="quoted"><span class="quoted">"yun_rf <span class="main">(</span>yun_polys <span class="free">p</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">d'</span><span class="main">,</span><span class="skolem">pis'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?p</span></span></span> <span class="main">=</span> <span class="quoted">poly_rf</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?map</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"map <span class="main">(</span><span class="main">λ</span> <span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">i</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="var">?p</span> <span class="bound">p</span><span class="main">,</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span>"</span></span> 
  <span class="keyword1"><span class="command">from</span></span> yun yun_rf <span class="keyword1"><span class="command">have</span></span> d'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">d'</span> <span class="main">=</span> <span class="skolem">d</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> pis<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">pis</span> <span class="main">=</span> <span class="var">?map</span> <span class="skolem">pis'</span>"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">atomize</span><span class="main"><span class="main">(</span></span><span class="quasi_keyword">full</span><span class="main"><span class="main">)</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>  
  <span class="keyword1"><span class="command">from</span></span> rt<span class="main">[</span><span class="operator">unfolded</span> factor_complex_main_def yun_rf split Let_def d'<span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> xis<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xis</span> <span class="main">=</span> concat <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">p</span><span class="main">,</span> <span class="bound">i</span><span class="main">)</span><span class="main">.</span> map <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="main">(</span><span class="bound">r</span><span class="main">,</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>roots_of_complex_rf_poly <span class="bound">p</span><span class="main">)</span><span class="main">)</span> <span class="skolem">pis'</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> d<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">d</span> <span class="main">=</span> <span class="free">c</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> yun <span class="main">=</span> yun_factorization<span class="main">[</span><span class="operator">OF</span> yun<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator"><span class="operator">unfolded</span></span> d<span class="main"><span class="main"><span class="main">]</span></span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">note</span></span> yun <span class="main">=</span> square_free_factorizationD<span class="main">[</span><span class="operator">OF</span> yun<span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main">(</span></span></span></span></span></span>1<span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main">)</span></span></span></span></span></span><span class="main">]</span> yun<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">unfolded</span> snd_conv<span class="main">]</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?exp</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="bound">pis</span><span class="main">.</span> <span class="main">∏</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">i</span><span class="main">)</span><span class="main">←</span>concat
    <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">p</span><span class="main">,</span> <span class="bound">i</span><span class="main">)</span><span class="main">.</span> map <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="main">(</span><span class="bound">r</span><span class="main">,</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>roots_of_complex_rf_poly <span class="bound">p</span><span class="main">)</span><span class="main">)</span> <span class="bound">pis</span><span class="main">)</span><span class="main">.</span> <span class="main">[:</span><span class="main">-</span> <span class="bound">x</span><span class="main">,</span> <span class="main">1</span><span class="main">:]</span> <span class="main">^</span> Suc <span class="bound">i</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> yun<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> p<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">=</span> smult <span class="free">c</span> <span class="main">(</span><span class="main">∏</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">i</span><span class="main">)</span><span class="main">∈</span>set <span class="skolem">pis</span><span class="main">.</span> <span class="bound">a</span> <span class="main">^</span> Suc <span class="bound">i</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∏</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">i</span><span class="main">)</span><span class="main">∈</span>set <span class="skolem">pis</span><span class="main">.</span> <span class="bound">a</span> <span class="main">^</span> Suc <span class="bound">i</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∏</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">i</span><span class="main">)</span><span class="main">←</span><span class="skolem">pis</span><span class="main">.</span> <span class="bound">a</span> <span class="main">^</span> Suc <span class="bound">i</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> prod.distinct_set_conv_list<span class="main"><span class="main">[</span></span><span class="operator">OF</span> yun<span class="main"><span class="main">(</span></span>5<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="var">?exp</span> <span class="skolem">pis'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> yun<span class="main">(</span>2<span class="main">,</span>6<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> pis 
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">pis'</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">pi</span> <span class="skolem">pis</span><span class="main">)</span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p</span></span> <span class="skolem"><span class="skolem">i</span></span> <span class="keyword2"><span class="keyword">where</span></span> pi<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">pi</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">p</span><span class="main">,</span><span class="skolem">i</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?rts</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"roots_of_complex_rf_poly <span class="skolem">p</span>"</span></span>
    <span class="keyword1"><span class="command">note</span></span> Cons <span class="main">=</span> Cons<span class="main">[</span><span class="operator">unfolded</span> pi<span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> IH<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∏</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">i</span><span class="main">)</span><span class="main">←</span><span class="var">?map</span> <span class="skolem">pis</span><span class="main">.</span> <span class="bound">a</span> <span class="main">^</span> Suc <span class="bound">i</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="var">?exp</span> <span class="skolem">pis</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> Cons<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">OF</span> Cons<span class="main"><span class="main">(</span></span>2-3<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> Cons<span class="main">(</span>2-3<span class="main">)</span><span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="var"><span class="var">?p</span></span> <span class="skolem"><span class="skolem">p</span></span>"</span></span></span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">i</span></span></span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> p<span class="main">:</span> <span class="quoted"><span class="quoted">"square_free <span class="main">(</span><span class="var">?p</span> <span class="skolem">p</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"degree <span class="main">(</span><span class="var">?p</span> <span class="skolem">p</span><span class="main">)</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="var">?p</span> <span class="skolem">p</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="quoted"><span class="quoted">"monic <span class="main">(</span><span class="var">?p</span> <span class="skolem">p</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∏</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">i</span><span class="main">)</span><span class="main">←</span><span class="var">?map</span> <span class="main">(</span><span class="skolem">pi</span> <span class="main">#</span> <span class="skolem">pis</span><span class="main">)</span><span class="main">.</span> <span class="bound">a</span> <span class="main">^</span> Suc <span class="bound">i</span><span class="main">)</span> <span class="main">=</span> <span class="var">?p</span> <span class="skolem">p</span> <span class="main">^</span> Suc <span class="skolem">i</span> <span class="main">*</span> <span class="main">(</span><span class="main">∏</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">i</span><span class="main">)</span><span class="main">←</span><span class="var">?map</span> <span class="skolem">pis</span><span class="main">.</span> <span class="bound">a</span> <span class="main">^</span> Suc <span class="bound">i</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> pi <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∏</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">i</span><span class="main">)</span><span class="main">←</span><span class="var">?map</span> <span class="skolem">pis</span><span class="main">.</span> <span class="bound">a</span> <span class="main">^</span> Suc <span class="bound">i</span><span class="main">)</span> <span class="main">=</span> <span class="var">?exp</span> <span class="skolem">pis</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> IH<span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> id<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∏</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">i</span><span class="main">)</span><span class="main">←</span><span class="var">?map</span> <span class="main">(</span><span class="skolem">pi</span> <span class="main">#</span> <span class="skolem">pis</span><span class="main">)</span><span class="main">.</span> <span class="bound">a</span> <span class="main">^</span> Suc <span class="bound">i</span><span class="main">)</span> <span class="main">=</span> <span class="var">?p</span> <span class="skolem">p</span> <span class="main">^</span> Suc <span class="skolem">i</span> <span class="main">*</span> <span class="var">?exp</span> <span class="skolem">pis</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?exp</span> <span class="main">(</span><span class="skolem">pi</span> <span class="main">#</span> <span class="skolem">pis</span><span class="main">)</span> <span class="main">=</span> <span class="var">?exp</span> <span class="main">[</span><span class="main">(</span><span class="skolem">p</span><span class="main">,</span><span class="skolem">i</span><span class="main">)</span><span class="main">]</span> <span class="main">*</span> <span class="var">?exp</span> <span class="skolem">pis</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> pi <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?exp</span> <span class="main">[</span><span class="main">(</span><span class="skolem">p</span><span class="main">,</span><span class="skolem">i</span><span class="main">)</span><span class="main">]</span> <span class="main">=</span> <span class="main">(</span><span class="main">∏</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">i</span><span class="main">)</span><span class="main">←</span> <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="main">(</span><span class="bound">r</span><span class="main">,</span> <span class="skolem">i</span><span class="main">)</span><span class="main">)</span> <span class="var">?rts</span><span class="main">)</span><span class="main">.</span> <span class="main">[:</span><span class="main">-</span> <span class="bound">x</span><span class="main">,</span> <span class="main">1</span><span class="main">:]</span> <span class="main">^</span> Suc <span class="bound">i</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="main">∏</span> <span class="bound">x</span> <span class="main">←</span> <span class="var">?rts</span><span class="main">.</span> <span class="main">[:</span><span class="main">-</span> <span class="bound">x</span><span class="main">,</span> <span class="main">1</span><span class="main">:]</span><span class="main">)</span><span class="main">^</span>Suc <span class="skolem">i</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> prod_list_power <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> arg_cong<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted"><span class="quoted">prod_list</span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∏</span> <span class="bound">x</span> <span class="main">←</span> <span class="var">?rts</span><span class="main">.</span> <span class="main">[:</span><span class="main">-</span> <span class="bound">x</span><span class="main">,</span> <span class="main">1</span><span class="main">:]</span><span class="main">)</span> <span class="main">=</span> <span class="var">?p</span> <span class="skolem">p</span>"</span></span> 
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command">from</span></span> fundamental_theorem_algebra_factorized<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="var">?p</span> <span class="skolem">p</span>"</span></span><span class="main">,</span> <span class="operator">unfolded</span> <span class="quoted"><span class="quoted">‹monic <span class="main">(</span><span class="var">?p</span> <span class="skolem">p</span><span class="main">)</span>›</span></span><span class="main">]</span>
      <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">as</span></span> <span class="keyword2"><span class="keyword">where</span></span> as<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?p</span> <span class="skolem">p</span> <span class="main">=</span> <span class="main">(</span><span class="main">∏</span><span class="bound">a</span><span class="main">←</span><span class="skolem">as</span><span class="main">.</span> <span class="main">[:</span><span class="main">-</span> <span class="bound">a</span><span class="main">,</span> <span class="main">1</span><span class="main">:]</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> smult_1_left<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="main">∏</span><span class="bound">a</span><span class="main">∈</span>set <span class="skolem">as</span><span class="main">.</span> <span class="main">[:</span><span class="main">-</span> <span class="bound">a</span><span class="main">,</span> <span class="main">1</span><span class="main">:]</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> sym<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> prod.distinct_set_conv_list<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> ccontr<span class="main">)</span>
        <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> distinct <span class="skolem">as</span>"</span></span> 
        <span class="keyword1"><span class="command">from</span></span> not_distinct_decomp<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">as1</span></span> <span class="skolem"><span class="skolem">as2</span></span> <span class="skolem"><span class="skolem">as3</span></span> <span class="skolem"><span class="skolem">a</span></span> <span class="keyword2"><span class="keyword">where</span></span>
          a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">as</span> <span class="main">=</span> <span class="skolem">as1</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">a</span><span class="main">]</span> <span class="main">@</span> <span class="skolem">as2</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">a</span><span class="main">]</span> <span class="main">@</span> <span class="skolem">as3</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
        <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">q</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span> <span class="main">=</span> <span class="main">(</span><span class="main">∏</span><span class="bound">a</span><span class="main">←</span><span class="skolem">as1</span> <span class="main">@</span> <span class="skolem">as2</span> <span class="main">@</span> <span class="skolem">as3</span><span class="main">.</span> <span class="main">[:</span><span class="main">-</span> <span class="bound">a</span><span class="main">,</span> <span class="main">1</span><span class="main">:]</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?p</span> <span class="skolem">p</span> <span class="main">=</span> <span class="main">(</span><span class="main">∏</span><span class="bound">a</span><span class="main">←</span><span class="skolem">as</span><span class="main">.</span> <span class="main">[:</span><span class="main">-</span> <span class="bound">a</span><span class="main">,</span> <span class="main">1</span><span class="main">:]</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="main">∏</span><span class="bound">a</span><span class="main">←</span><span class="main">(</span><span class="main">[</span><span class="skolem">a</span><span class="main">]</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">a</span><span class="main">]</span><span class="main">)</span><span class="main">.</span> <span class="main">[:</span><span class="main">-</span> <span class="bound">a</span><span class="main">,</span> <span class="main">1</span><span class="main">:]</span><span class="main">)</span> <span class="main">*</span> <span class="skolem">q</span>"</span></span>
          <span class="keyword1"><span class="command">unfolding</span></span> q_def a map_append prod_list.append <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">ac_simps</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">[:</span><span class="main">-</span><span class="skolem">a</span><span class="main">,</span><span class="main">1</span><span class="main">:]</span> <span class="main">*</span> <span class="main">[:</span><span class="main">-</span><span class="skolem">a</span><span class="main">,</span><span class="main">1</span><span class="main">:]</span> <span class="main">*</span> <span class="skolem">q</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?p</span> <span class="skolem">p</span> <span class="main">=</span> <span class="main">(</span><span class="main">[:</span><span class="main">-</span><span class="skolem">a</span><span class="main">,</span><span class="main">1</span><span class="main">:]</span> <span class="main">*</span> <span class="main">[:</span><span class="main">-</span><span class="skolem">a</span><span class="main">,</span><span class="main">1</span><span class="main">:]</span><span class="main">)</span> <span class="main">*</span> <span class="skolem">q</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="main">-</span><span class="skolem">a</span><span class="main">,</span><span class="main">1</span><span class="main">:]</span> <span class="main">*</span> <span class="main">[:</span><span class="main">-</span><span class="skolem">a</span><span class="main">,</span><span class="main">1</span><span class="main">:]</span> <span class="keyword1">dvd</span> <span class="var">?p</span> <span class="skolem">p</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> dvd_def <span class="keyword1"><span class="command">..</span></span>
        <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹square_free <span class="main">(</span><span class="var">?p</span> <span class="skolem">p</span><span class="main">)</span>›</span></span><span class="main">[</span><span class="operator">unfolded</span> square_free_def<span class="main">,</span> <span class="operator">THEN</span> conjunct2<span class="main">,</span> <span class="operator">rule_format</span><span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="main">-</span><span class="skolem">a</span><span class="main">,</span><span class="main">1</span><span class="main">:]</span>"</span></span><span class="main">]</span> 
        <span class="keyword3"><span class="command">show</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="skolem">as</span> <span class="main">=</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> poly <span class="main">(</span><span class="var">?p</span> <span class="skolem">p</span><span class="main">)</span> <span class="bound">x</span> <span class="main">=</span> <span class="main">0</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> as poly_prod_list 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> o_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">induct</span> <span class="quoted"><span class="skolem">as</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> set <span class="var">?rts</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> roots_of_complex_rf_poly<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∏</span><span class="bound">a</span><span class="main">∈</span>set <span class="var">?rts</span><span class="main">.</span> <span class="main">[:</span><span class="main">-</span> <span class="bound">a</span><span class="main">,</span> <span class="main">1</span><span class="main">:]</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∏</span><span class="bound">a</span><span class="main">←</span><span class="var">?rts</span><span class="main">.</span> <span class="main">[:</span><span class="main">-</span> <span class="bound">a</span><span class="main">,</span> <span class="main">1</span><span class="main">:]</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> prod.distinct_set_conv_list<span class="main"><span class="main">[</span></span><span class="operator">OF</span> roots_of_complex_rf_poly<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> id2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?exp</span> <span class="main">(</span><span class="skolem">pi</span> <span class="main">#</span> <span class="skolem">pis</span><span class="main">)</span> <span class="main">=</span> <span class="var">?p</span> <span class="skolem">p</span> <span class="main">^</span> Suc <span class="skolem">i</span> <span class="main">*</span> <span class="var">?exp</span> <span class="skolem">pis</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> id id2 <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?exp</span> <span class="skolem">pis'</span> <span class="main">=</span> <span class="main">(</span><span class="main">∏</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">i</span><span class="main">)</span><span class="main">←</span><span class="free">xis</span><span class="main">.</span> <span class="main">[:</span><span class="main">-</span> <span class="bound">x</span><span class="main">,</span> <span class="main">1</span><span class="main">:]</span> <span class="main">^</span> Suc <span class="bound">i</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> xis <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> p xis <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">factor_complex_poly</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"complex poly <span class="main">⇒</span> complex <span class="main">×</span> <span class="main">(</span>complex poly <span class="main">×</span> nat<span class="main">)</span> list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">factor_complex_poly</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> factor_complex_main <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="keyword1">of</span>
     <span class="main">(</span><span class="bound">c</span><span class="main">,</span><span class="bound">ris</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="bound">c</span><span class="main">,</span> map <span class="main">(</span><span class="main">λ</span> <span class="main">(</span><span class="bound">r</span><span class="main">,</span><span class="bound">i</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="main">[:</span><span class="main">-</span><span class="bound">r</span><span class="main">,</span><span class="main">1</span><span class="main">:]</span><span class="main">,</span>Suc <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="bound">ris</span><span class="main">)</span><span class="main">)</span>"</span></span>


<span class="keyword1"><span class="command">theorem</span></span> factor_complex_poly<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> fp<span class="main">:</span> <span class="quoted"><span class="quoted">"factor_complex_poly <span class="free">p</span> <span class="main">=</span> <span class="main">(</span><span class="free">c</span><span class="main">,</span><span class="free">qis</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">=</span> smult <span class="free">c</span> <span class="main">(</span><span class="main">∏</span><span class="main">(</span><span class="bound">q</span><span class="main">,</span> <span class="bound">i</span><span class="main">)</span><span class="main">←</span><span class="free">qis</span><span class="main">.</span> <span class="bound">q</span> <span class="main">^</span> <span class="bound">i</span><span class="main">)</span>"</span></span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">q</span><span class="main">,</span><span class="free">i</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">qis</span> <span class="main">⟹</span> irreducible <span class="free">q</span> <span class="main">∧</span> <span class="free">i</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">∧</span> monic <span class="free">q</span> <span class="main">∧</span> degree <span class="free">q</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> fp<span class="main">[</span><span class="operator">unfolded</span> factor_complex_poly_def<span class="main">]</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">pis</span></span> <span class="keyword2"><span class="keyword">where</span></span> fp<span class="main">:</span> <span class="quoted"><span class="quoted">"factor_complex_main <span class="free">p</span> <span class="main">=</span> <span class="main">(</span><span class="free">c</span><span class="main">,</span><span class="skolem">pis</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> qis<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">qis</span> <span class="main">=</span> map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">r</span><span class="main">,</span> <span class="bound">i</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="main">[:</span><span class="main">-</span> <span class="bound">r</span><span class="main">,</span> <span class="main">1</span><span class="main">:]</span><span class="main">,</span> Suc <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="skolem">pis</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"factor_complex_main <span class="free">p</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> factor_complex_main<span class="main">[</span><span class="operator">OF</span> fp<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> p<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">=</span> smult <span class="free">c</span> <span class="main">(</span><span class="main">∏</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">i</span><span class="main">)</span><span class="main">←</span><span class="skolem">pis</span><span class="main">.</span> <span class="main">[:</span><span class="main">-</span> <span class="bound">x</span><span class="main">,</span> <span class="main">1</span><span class="main">:]</span> <span class="main">^</span> Suc <span class="bound">i</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">=</span> smult <span class="free">c</span> <span class="main">(</span><span class="main">∏</span><span class="main">(</span><span class="bound">q</span><span class="main">,</span> <span class="bound">i</span><span class="main">)</span><span class="main">←</span><span class="free">qis</span><span class="main">.</span> <span class="bound">q</span> <span class="main">^</span> <span class="bound">i</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> p qis
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> arg_cong<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main"><span class="main">λ</span></span></span> <span class="bound"><span class="bound"><span class="bound">p</span></span></span><span class="main"><span class="main"><span class="main">.</span></span></span> smult <span class="free"><span class="free"><span class="free">c</span></span></span> <span class="main"><span class="main"><span class="main">(</span></span></span>prod_list <span class="bound"><span class="bound"><span class="bound">p</span></span></span><span class="main"><span class="main"><span class="main">)</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">q</span><span class="main">,</span><span class="free">i</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">qis</span> <span class="main">⟹</span> irreducible <span class="free">q</span> <span class="main">∧</span> <span class="free">i</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">∧</span> monic <span class="free">q</span> <span class="main">∧</span> degree <span class="free">q</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> linear_irreducible_field<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">q</span></span><span class="main">]</span> <span class="keyword1"><span class="command">unfolding</span></span> qis <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div><div id="Factor_Real_Poly">
<div class="head">
<h1>Theory Factor_Real_Poly</h1>
</div>
<pre class="source"><span class="comment1">(* Factorization of polynomials with real algebraic coefficients *)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Real Algebraic Coefficients›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We basically perform a factorization via complex algebraic numbers,
  take all real roots, and 
  then merge each pair of conjugate roots into a quadratic factor.›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Factor_Real_Poly
  <span class="keyword2"><span class="keyword">imports</span></span>
    <a href="#Factor_Complex_Poly">Factor_Complex_Poly</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">hide_const</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="main">)</span> Coset.order

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">delete_cnj</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"complex <span class="main">⇒</span> nat <span class="main">⇒</span> <span class="main">(</span>complex <span class="main">×</span> nat<span class="main">)</span> list <span class="main">⇒</span> <span class="main">(</span>complex <span class="main">×</span> nat<span class="main">)</span> list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">delete_cnj</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">)</span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">yjs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="keyword1">then</span> <span class="keyword1">if</span> Suc <span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">yjs</span></span></span> <span class="keyword1">else</span> <span class="keyword1">if</span> Suc <span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="main">&gt;</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="keyword1">then</span>
    <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="main">-</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">yjs</span></span></span><span class="main">)</span> <span class="keyword1">else</span> <span class="free">delete_cnj</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">-</span> Suc <span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">yjs</span></span></span> <span class="keyword1">else</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">j</span></span></span><span class="main">)</span> <span class="main">#</span> <span class="free">delete_cnj</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="free"><span class="bound"><span class="entity">yjs</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">delete_cnj</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">[]</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>

<span class="keyword1" id="Factor_Real_Poly-delete_cnj_length"><span class="command">lemma</span></span> delete_cnj_length<span class="main">[</span><span class="operator">termination_simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"length <span class="main">(</span>delete_cnj <span class="free">x</span> <span class="free">i</span> <span class="free">yjs</span><span class="main">)</span> <span class="main">≤</span> length <span class="free">yjs</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="free">i</span></span> <span class="quoted"><span class="free">yjs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> delete_cnj.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">complex_roots_to_real_factorization</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>complex <span class="main">×</span> nat<span class="main">)</span> list <span class="main">⇒</span> <span class="main">(</span>real poly <span class="main">×</span> nat<span class="main">)</span>list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">complex_roots_to_real_factorization</span> <span class="main">[]</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">complex_roots_to_real_factorization</span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">∈</span> <span class="main">ℝ</span> <span class="keyword1">then</span> 
    <span class="main">(</span><span class="main">[:</span><span class="main">-</span><span class="main">(</span>Re <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">,</span><span class="main">1</span><span class="main">:]</span><span class="main">,</span>Suc <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> <span class="main">#</span> <span class="free">complex_roots_to_real_factorization</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">else</span> 
    <span class="keyword1">let</span> <span class="bound">xx</span> <span class="main">=</span> cnj <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">;</span> <span class="bound">ys</span> <span class="main">=</span> delete_cnj <span class="bound">xx</span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">;</span> <span class="bound">p</span> <span class="main">=</span> map_poly Re <span class="main">(</span><span class="main">[:</span><span class="main">-</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">,</span><span class="main">1</span><span class="main">:]</span> <span class="main">*</span> <span class="main">[:</span><span class="main">-</span><span class="bound">xx</span><span class="main">,</span><span class="main">1</span><span class="main">:]</span><span class="main">)</span>
    <span class="keyword1">in</span> <span class="main">(</span><span class="bound">p</span><span class="main">,</span>Suc <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> <span class="main">#</span> <span class="free">complex_roots_to_real_factorization</span> <span class="bound">ys</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">factor_real_poly</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"real poly <span class="main">⇒</span> real <span class="main">×</span> <span class="main">(</span>real poly <span class="main">×</span> nat<span class="main">)</span> list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">factor_real_poly</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">≡</span> <span class="keyword1">case</span> factor_complex_main <span class="main">(</span>map_poly of_real <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="keyword1">of</span> 
    <span class="main">(</span><span class="bound">c</span><span class="main">,</span><span class="bound">ris</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span>Re <span class="bound">c</span><span class="main">,</span> complex_roots_to_real_factorization <span class="bound">ris</span><span class="main">)</span> "</span></span>


<span class="keyword1" id="Factor_Real_Poly-monic_imp_nonzero"><span class="command">lemma</span></span> monic_imp_nonzero<span class="main">:</span> <span class="quoted"><span class="quoted">"monic <span class="free">x</span> <span class="main">⟹</span> <span class="free">x</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> semiring_1 poly"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Factor_Real_Poly-delete_cnj"><span class="command">lemma</span></span> delete_cnj<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> 
  <span class="quoted"><span class="quoted">"order <span class="free">x</span> <span class="main">(</span><span class="main">∏</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">i</span><span class="main">)</span><span class="main">←</span><span class="free">xis</span><span class="main">.</span> <span class="main">[:</span><span class="main">-</span> <span class="bound">x</span><span class="main">,</span> <span class="main">1</span><span class="main">:]</span> <span class="main">^</span> Suc <span class="bound">i</span><span class="main">)</span> <span class="main">≥</span> <span class="free">si</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">si</span> <span class="main">≠</span> <span class="main">0</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∏</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">i</span><span class="main">)</span><span class="main">←</span><span class="free">xis</span><span class="main">.</span> <span class="main">[:</span><span class="main">-</span> <span class="bound">x</span><span class="main">,</span> <span class="main">1</span><span class="main">:]</span> <span class="main">^</span> Suc <span class="bound">i</span><span class="main">)</span> <span class="main">=</span>
    <span class="main">[:</span><span class="main">-</span> <span class="free">x</span><span class="main">,</span> <span class="main">1</span><span class="main">:]</span> <span class="main">^</span> <span class="free">si</span> <span class="main">*</span> <span class="main">(</span><span class="main">∏</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">i</span><span class="main">)</span><span class="main">←</span>delete_cnj <span class="free">x</span> <span class="free">si</span> <span class="free">xis</span><span class="main">.</span> <span class="main">[:</span><span class="main">-</span> <span class="bound">x</span><span class="main">,</span> <span class="main">1</span><span class="main">:]</span> <span class="main">^</span> Suc <span class="bound">i</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="free">si</span></span> <span class="quoted"><span class="free">xis</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> delete_cnj.induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>2 <span class="skolem">x</span> <span class="skolem">si</span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"order <span class="skolem">x</span> <span class="main">1</span> <span class="main">≥</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="main">-</span><span class="skolem">x</span><span class="main">,</span><span class="main">1</span><span class="main">:]</span><span class="main">^</span><span class="main">1</span> <span class="keyword1">dvd</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> order_divides <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">from</span></span> power_le_dvd<span class="main">[</span><span class="operator">OF</span> this<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="main">1</span></span><span class="main">]</span> <span class="quoted"><span class="quoted">‹<span class="skolem">si</span> <span class="main">≠</span> <span class="main">0</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="main">-</span> <span class="skolem">x</span><span class="main">,</span> <span class="main">1</span><span class="main">:]</span> <span class="keyword1">dvd</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">from</span></span> divides_degree<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> 
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">x</span> <span class="skolem">i</span> <span class="skolem">y</span> <span class="skolem">j</span> <span class="skolem">yjs</span><span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> IH <span class="main">=</span> 1<span class="main">(</span>1-2<span class="main">)</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?yj</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="main">-</span><span class="skolem">y</span><span class="main">,</span><span class="main">1</span><span class="main">:]</span><span class="main">^</span>Suc <span class="skolem">j</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?yjs</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∏</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">i</span><span class="main">)</span><span class="main">←</span><span class="skolem">yjs</span><span class="main">.</span> <span class="main">[:</span><span class="main">-</span> <span class="bound">x</span><span class="main">,</span> <span class="main">1</span><span class="main">:]</span> <span class="main">^</span> Suc <span class="bound">i</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?x</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span> <span class="main">-</span> <span class="skolem">x</span><span class="main">,</span> <span class="main">1</span> <span class="main">:]</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?xi</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="var">?x</span> <span class="main">^</span> <span class="skolem">i</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"monic <span class="main">(</span><span class="main">∏</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">i</span><span class="main">)</span><span class="main">←</span><span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">j</span><span class="main">)</span> <span class="main">#</span> <span class="skolem">yjs</span><span class="main">.</span> <span class="main">[:</span><span class="main">-</span> <span class="bound">x</span><span class="main">,</span> <span class="main">1</span><span class="main">:]</span> <span class="main">^</span> Suc <span class="bound">i</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> monic_prod_list_pow<span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"monic <span class="main">(</span><span class="var">?yj</span> <span class="main">*</span> <span class="var">?yjs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">from</span></span> monic_imp_nonzero<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> yy0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?yj</span> <span class="main">*</span> <span class="var">?yjs</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">have</span></span> id<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∏</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">i</span><span class="main">)</span><span class="main">←</span><span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">j</span><span class="main">)</span> <span class="main">#</span> <span class="skolem">yjs</span><span class="main">.</span> <span class="main">[:</span><span class="main">-</span> <span class="bound">x</span><span class="main">,</span> <span class="main">1</span><span class="main">:]</span> <span class="main">^</span> Suc <span class="bound">i</span><span class="main">)</span> <span class="main">=</span> <span class="var">?yj</span> <span class="main">*</span> <span class="var">?yjs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">from</span></span> 1<span class="main">(</span>3-<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> ord<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">≤</span> order <span class="skolem">x</span> <span class="main">(</span><span class="var">?yj</span> <span class="main">*</span> <span class="var">?yjs</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> i<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> id <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">from</span></span> ord<span class="main">[</span><span class="operator">unfolded</span> order_mult<span class="main"><span class="main">[</span></span><span class="operator">OF</span> yy0<span class="main"><span class="main">]</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> ord<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">≤</span> order <span class="skolem">x</span> <span class="var">?yj</span> <span class="main">+</span> order <span class="skolem">x</span> <span class="var">?yjs</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">from</span></span> this<span class="main">[</span><span class="operator">unfolded</span> order_linear_power'<span class="main">]</span> 
  <span class="keyword1"><span class="command">have</span></span> ord<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">≤</span> <span class="main">(</span><span class="keyword1">if</span> <span class="skolem">y</span> <span class="main">=</span> <span class="skolem">x</span> <span class="keyword1">then</span> Suc <span class="skolem">j</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span> <span class="main">+</span> order <span class="skolem">x</span> <span class="var">?yjs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> 
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">from</span></span> ord False <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">≤</span> order <span class="skolem">x</span> <span class="var">?yjs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">note</span></span> IH <span class="main">=</span> IH<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> False this i<span class="main">]</span>
    <span class="keyword1"><span class="command">from</span></span> False <span class="keyword1"><span class="command">have</span></span> del<span class="main">:</span> <span class="quoted"><span class="quoted">"delete_cnj <span class="skolem">x</span> <span class="skolem">i</span> <span class="main">(</span><span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">j</span><span class="main">)</span> <span class="main">#</span> <span class="skolem">yjs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">y</span><span class="main">,</span><span class="skolem">j</span><span class="main">)</span> <span class="main">#</span> delete_cnj <span class="skolem">x</span> <span class="skolem">i</span> <span class="skolem">yjs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>    
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> del id IH
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">ac_simps</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">note</span></span> xy <span class="main">=</span> this
    <span class="keyword1"><span class="command">note</span></span> IH <span class="main">=</span> IH<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> True<span class="main">]</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"Suc <span class="skolem">j</span> <span class="main">≥</span> <span class="skolem">i</span>"</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> False
      <span class="keyword1"><span class="command">from</span></span> ord <span class="keyword1"><span class="command">have</span></span> ord<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">-</span> Suc <span class="skolem">j</span> <span class="main">≤</span> order <span class="skolem">x</span> <span class="var">?yjs</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> xy <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?xi</span> <span class="main">=</span> <span class="var">?x</span> <span class="main">^</span> <span class="main">(</span>Suc <span class="skolem">j</span> <span class="main">+</span> <span class="main">(</span><span class="skolem">i</span> <span class="main">-</span> Suc <span class="skolem">j</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> False <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="var">?x</span> <span class="main">^</span> Suc <span class="skolem">j</span> <span class="main">*</span> <span class="var">?x</span> <span class="main">^</span> <span class="main">(</span><span class="skolem">i</span> <span class="main">-</span> Suc <span class="skolem">j</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> power_add <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> xi<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?xi</span> <span class="main">=</span> <span class="var">?x</span> <span class="main">^</span> Suc <span class="skolem">j</span> <span class="main">*</span> <span class="var">?x</span> <span class="main">^</span> <span class="main">(</span><span class="skolem">i</span> <span class="main">-</span> Suc <span class="skolem">j</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
      <span class="keyword1"><span class="command">from</span></span> False <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"Suc <span class="skolem">j</span> <span class="main">≠</span> <span class="skolem">i</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="skolem">i</span> <span class="main">&lt;</span> Suc <span class="skolem">j</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">-</span> Suc <span class="skolem">j</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">note</span></span> IH <span class="main">=</span> IH<span class="main">[</span><span class="operator">OF</span> this<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">,</span></span>2<span class="main"><span class="main">)</span></span> ord this<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">]</span>
      <span class="keyword1"><span class="command">from</span></span> xy False <span class="keyword1"><span class="command">have</span></span> del<span class="main">:</span> <span class="quoted"><span class="quoted">"delete_cnj <span class="skolem">x</span> <span class="skolem">i</span> <span class="main">(</span><span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">j</span><span class="main">)</span> <span class="main">#</span> <span class="skolem">yjs</span><span class="main">)</span> <span class="main">=</span> delete_cnj <span class="skolem">x</span> <span class="main">(</span><span class="skolem">i</span> <span class="main">-</span> Suc <span class="skolem">j</span><span class="main">)</span> <span class="skolem">yjs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> del id <span class="keyword1"><span class="command">unfolding</span></span> IH xi <span class="keyword1"><span class="command">unfolding</span></span> xy <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> True
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"Suc <span class="skolem">j</span> <span class="main">=</span> <span class="skolem">i</span> <span class="main">∨</span> <span class="skolem">i</span> <span class="main">&lt;</span> Suc <span class="skolem">j</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span>
        <span class="keyword3"><span class="command">assume</span></span> i<span class="main">:</span> <span class="quoted"><span class="quoted">"Suc <span class="skolem">j</span> <span class="main">=</span> <span class="skolem">i</span>"</span></span>
        <span class="keyword1"><span class="command">from</span></span> xy i <span class="keyword1"><span class="command">have</span></span> del<span class="main">:</span> <span class="quoted"><span class="quoted">"delete_cnj <span class="skolem">x</span> <span class="skolem">i</span> <span class="main">(</span><span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">j</span><span class="main">)</span> <span class="main">#</span> <span class="skolem">yjs</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">yjs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> id del <span class="keyword1"><span class="command">unfolding</span></span> xy i <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">assume</span></span> ij<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&lt;</span> Suc <span class="skolem">j</span>"</span></span>
        <span class="keyword1"><span class="command">with</span></span> xy i <span class="keyword1"><span class="command">have</span></span> del<span class="main">:</span> <span class="quoted"><span class="quoted">"delete_cnj <span class="skolem">x</span> <span class="skolem">i</span> <span class="main">(</span><span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">j</span><span class="main">)</span> <span class="main">#</span> <span class="skolem">yjs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">y</span><span class="main">,</span> <span class="skolem">j</span> <span class="main">-</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">#</span> <span class="skolem">yjs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">from</span></span> ij <span class="keyword1"><span class="command">have</span></span> idd<span class="main">:</span> <span class="quoted"><span class="quoted">"Suc <span class="skolem">j</span> <span class="main">=</span> <span class="skolem">i</span> <span class="main">+</span> Suc <span class="main">(</span><span class="skolem">j</span> <span class="main">-</span> <span class="skolem">i</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> id del <span class="keyword1"><span class="command">unfolding</span></span> xy idd power_add <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">theorem</span></span> factor_real_poly<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> fp<span class="main">:</span> <span class="quoted"><span class="quoted">"factor_real_poly <span class="free">p</span> <span class="main">=</span> <span class="main">(</span><span class="free">c</span><span class="main">,</span><span class="free">qis</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">=</span> smult <span class="free">c</span> <span class="main">(</span><span class="main">∏</span><span class="main">(</span><span class="bound">q</span><span class="main">,</span> <span class="bound">i</span><span class="main">)</span><span class="main">←</span><span class="free">qis</span><span class="main">.</span> <span class="bound">q</span> <span class="main">^</span> <span class="bound">i</span><span class="main">)</span>"</span></span> 
    <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">q</span><span class="main">,</span><span class="free">j</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">qis</span> <span class="main">⟹</span> irreducible <span class="free">q</span> <span class="main">∧</span> <span class="free">j</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">∧</span> monic <span class="free">q</span> <span class="main">∧</span> degree <span class="free">q</span> <span class="main">∈</span> <span class="main">{</span><span class="main">1</span><span class="main">,</span><span class="numeral">2</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> map_poly_inj_idom_hom <span class="quoted">of_real</span><span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">p</span> <span class="main">=</span> smult <span class="free">c</span> <span class="main">(</span><span class="main">∏</span><span class="main">(</span><span class="bound">q</span><span class="main">,</span> <span class="bound">i</span><span class="main">)</span><span class="main">←</span><span class="free">qis</span><span class="main">.</span> <span class="bound">q</span> <span class="main">^</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">(</span><span class="free">q</span><span class="main">,</span><span class="free">j</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">qis</span> <span class="main">⟶</span> irreducible <span class="free">q</span> <span class="main">∧</span> <span class="free">j</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">∧</span> monic <span class="free">q</span> <span class="main">∧</span> degree <span class="free">q</span> <span class="main">∈</span> <span class="main">{</span><span class="main">1</span><span class="main">,</span><span class="numeral">2</span><span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">=</span> <span class="main">0</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True
    <span class="keyword1"><span class="command">have</span></span> yun<span class="main">:</span> <span class="quoted"><span class="quoted">"yun_rf <span class="main">(</span>yun_polys <span class="main">(</span><span class="main">0</span> <span class="main">::</span> complex poly<span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">0</span><span class="main">,</span><span class="main">[]</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> yun_factorization_def<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"factor_real_poly <span class="free">p</span> <span class="main">=</span> <span class="main">(</span><span class="main">0</span><span class="main">,</span><span class="main">[]</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> True
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> factor_real_poly_def factor_complex_main_def yun<span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> fp <span class="keyword1"><span class="command">have</span></span> id<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">qis</span> <span class="main">=</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> True <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">note</span></span> p0 <span class="main">=</span> this
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?c</span></span></span> <span class="main">=</span> <span class="quoted">complex_of_real</span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?rp</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"map_poly Re"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?cp</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"map_poly <span class="var">?c</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?p</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="var">?cp</span> <span class="free">p</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> fp<span class="main">[</span><span class="operator">unfolded</span> factor_real_poly_def<span class="main">]</span>
      <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">d</span></span> <span class="skolem"><span class="skolem">xis</span></span> <span class="keyword2"><span class="keyword">where</span></span> fp<span class="main">:</span> <span class="quoted"><span class="quoted">"factor_complex_main <span class="var">?p</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">d</span><span class="main">,</span><span class="skolem">xis</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> c<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">=</span> Re <span class="skolem">d</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> qis<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">qis</span> <span class="main">=</span> complex_roots_to_real_factorization <span class="skolem">xis</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"factor_complex_main <span class="var">?p</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> factor_complex_main<span class="main">[</span><span class="operator">OF</span> fp<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> p<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?p</span> <span class="main">=</span> smult <span class="skolem">d</span> <span class="main">(</span><span class="main">∏</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">i</span><span class="main">)</span><span class="main">←</span><span class="skolem">xis</span><span class="main">.</span> <span class="main">[:</span><span class="main">-</span> <span class="bound">x</span><span class="main">,</span> <span class="main">1</span><span class="main">:]</span> <span class="main">^</span> Suc <span class="bound">i</span><span class="main">)</span>"</span></span> 
      <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">=</span> smult <span class="skolem">d</span> <span class="var">?q</span>"</span></span><span class="main">)</span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">from</span></span> arg_cong<span class="main">[</span><span class="operator">OF</span> this<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span> <span class="bound">p</span><span class="main">.</span> coeff <span class="bound">p</span> <span class="main">(</span>degree <span class="bound">p</span><span class="main">)</span>"</span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"coeff <span class="var">?p</span> <span class="main">(</span>degree <span class="var">?p</span><span class="main">)</span> <span class="main">=</span> coeff <span class="main">(</span>smult <span class="skolem">d</span> <span class="var">?q</span><span class="main">)</span> <span class="main">(</span>degree <span class="main">(</span>smult <span class="skolem">d</span> <span class="var">?q</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"coeff <span class="var">?p</span> <span class="main">(</span>degree <span class="var">?p</span><span class="main">)</span> <span class="main">=</span> <span class="var">?c</span> <span class="main">(</span>coeff <span class="free">p</span> <span class="main">(</span>degree <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"coeff <span class="main">(</span>smult <span class="skolem">d</span> <span class="var">?q</span><span class="main">)</span> <span class="main">(</span>degree <span class="main">(</span>smult <span class="skolem">d</span> <span class="var">?q</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">d</span> <span class="main">*</span> coeff <span class="var">?q</span> <span class="main">(</span>degree <span class="var">?q</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"monic <span class="var">?q</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> monic_prod_list_pow<span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> d<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">d</span> <span class="main">=</span> <span class="var">?c</span> <span class="main">(</span>coeff <span class="free">p</span> <span class="main">(</span>degree <span class="free">p</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> arg_cong<span class="main">[</span><span class="operator">OF</span> this<span class="main">,</span> <span class="operator">of</span> <span class="quoted">Re</span><span class="main">,</span> <span class="operator">folded</span> c<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> c<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">=</span> coeff <span class="free">p</span> <span class="main">(</span>degree <span class="free">p</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>coeffs <span class="var">?p</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">ℝ</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> p <span class="keyword1"><span class="command">have</span></span> q'<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>coeffs <span class="main">(</span>smult <span class="skolem">d</span> <span class="var">?q</span><span class="main">)</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">ℝ</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> d p0 <span class="keyword1"><span class="command">have</span></span> d0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">d</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"smult <span class="skolem">d</span> <span class="var">?q</span> <span class="main">=</span> <span class="main">[:</span><span class="skolem">d</span><span class="main">:]</span> <span class="main">*</span> <span class="var">?q</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> real_poly_factor<span class="main">[</span><span class="operator">OF</span> q'<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> this<span class="main"><span class="main">]</span></span><span class="main">]</span> d0 d
    <span class="keyword1"><span class="command">have</span></span> q<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>coeffs <span class="var">?q</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">ℝ</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> 
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">=</span> <span class="var">?rp</span> <span class="var">?p</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> sym<span class="main"><span class="keyword3">,</span></span> <span class="operator">subst</span> map_poly_map_poly<span class="main"><span class="keyword3">,</span></span> <span class="operator">force</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> map_poly_idI<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="var">?rp</span> <span class="main">(</span>smult <span class="skolem">d</span> <span class="var">?q</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> p <span class="keyword1"><span class="command">..</span></span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?q</span> <span class="main">=</span> <span class="var">?cp</span> <span class="main">(</span><span class="var">?rp</span> <span class="var">?q</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> sym<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> map_poly_of_real_Re<span class="main"><span class="keyword3">,</span></span> <span class="operator">insert</span> q<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">d</span> <span class="main">=</span> <span class="var">?c</span> <span class="free">c</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> d c <span class="keyword1"><span class="command">..</span></span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"smult <span class="main">(</span><span class="var">?c</span> <span class="free">c</span><span class="main">)</span> <span class="main">(</span><span class="var">?cp</span> <span class="main">(</span><span class="var">?rp</span> <span class="var">?q</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="var">?cp</span> <span class="main">(</span>smult <span class="free">c</span> <span class="main">(</span><span class="var">?rp</span> <span class="var">?q</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">hom_distribs</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?rp</span> <span class="main">…</span> <span class="main">=</span> smult <span class="free">c</span> <span class="main">(</span><span class="var">?rp</span> <span class="var">?q</span><span class="main">)</span>"</span></span> 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> map_poly_map_poly<span class="main"><span class="keyword3">,</span></span> <span class="operator">force</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> map_poly_idI<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> p<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">=</span> smult <span class="free">c</span> <span class="main">(</span><span class="var">?rp</span> <span class="var">?q</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?fact</span></span></span> <span class="main">=</span> <span class="quoted">complex_roots_to_real_factorization</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?rp</span> <span class="var">?q</span> <span class="main">=</span> <span class="main">(</span><span class="main">∏</span><span class="main">(</span><span class="bound">q</span><span class="main">,</span> <span class="bound">i</span><span class="main">)</span><span class="main">←</span><span class="free">qis</span><span class="main">.</span> <span class="bound">q</span> <span class="main">^</span> <span class="bound">i</span><span class="main">)</span> <span class="main">∧</span>
      <span class="main">(</span><span class="main">(</span><span class="free">q</span><span class="main">,</span> <span class="free">j</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">qis</span> <span class="main">⟶</span> irreducible <span class="free">q</span> <span class="main">∧</span> <span class="free">j</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">∧</span> monic <span class="free">q</span> <span class="main">∧</span> degree <span class="free">q</span> <span class="main">∈</span> <span class="main">{</span><span class="main">1</span><span class="main">,</span> <span class="numeral">2</span><span class="main">}</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> q <span class="keyword1"><span class="command">unfolding</span></span> qis
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">xis</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> complex_roots_to_real_factorization.induct<span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> 1
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>2 <span class="skolem">x</span> <span class="skolem">i</span> <span class="skolem">xis</span><span class="main">)</span>
      <span class="keyword1"><span class="command">note</span></span> IH <span class="main">=</span> 2<span class="main">(</span>1-2<span class="main">)</span>
      <span class="keyword1"><span class="command">note</span></span> prems <span class="main">=</span> 2<span class="main">(</span>3<span class="main">)</span>
      <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?xi</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="main">-</span> <span class="skolem">x</span><span class="main">,</span> <span class="main">1</span><span class="main">:]</span> <span class="main">^</span> Suc <span class="skolem">i</span>"</span></span>
      <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?xis</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∏</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">i</span><span class="main">)</span><span class="main">←</span><span class="skolem">xis</span><span class="main">.</span> <span class="main">[:</span><span class="main">-</span> <span class="bound">x</span><span class="main">,</span> <span class="main">1</span><span class="main">:]</span> <span class="main">^</span> Suc <span class="bound">i</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">have</span></span> id<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∏</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">i</span><span class="main">)</span><span class="main">←</span><span class="main">(</span><span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">i</span><span class="main">)</span> <span class="main">#</span> <span class="skolem">xis</span><span class="main">)</span><span class="main">.</span> <span class="main">[:</span><span class="main">-</span> <span class="bound">x</span><span class="main">,</span> <span class="main">1</span><span class="main">:]</span> <span class="main">^</span> Suc <span class="bound">i</span><span class="main">)</span> <span class="main">=</span> <span class="var">?xi</span> <span class="main">*</span> <span class="var">?xis</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="main">ℝ</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> True
        <span class="keyword1"><span class="command">have</span></span> xi<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>coeffs <span class="var">?xi</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">ℝ</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> real_poly_power<span class="main"><span class="keyword3">,</span></span> <span class="operator">insert</span> True<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
        <span class="keyword1"><span class="command">have</span></span> xis<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>coeffs <span class="var">?xis</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">ℝ</span>"</span></span> 
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> real_poly_factor<span class="main"><span class="main">[</span></span><span class="operator">OF</span> prems<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> id<span class="main"><span class="main">]</span></span> xi<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> linear_power_nonzero<span class="main">)</span>
        <span class="keyword1"><span class="command">note</span></span> IH <span class="main">=</span> IH<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> True xis<span class="main">]</span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?rp</span> <span class="main">(</span><span class="var">?xi</span> <span class="main">*</span> <span class="var">?xis</span><span class="main">)</span> <span class="main">=</span> <span class="var">?rp</span> <span class="var">?xi</span> <span class="main">*</span> <span class="var">?rp</span> <span class="var">?xis</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> map_poly_Re_mult<span class="main"><span class="main">[</span></span><span class="operator">OF</span> xi xis<span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?rp</span> <span class="var">?xi</span> <span class="main">=</span> <span class="main">(</span><span class="var">?rp</span> <span class="main">[:</span> <span class="main">-</span><span class="skolem">x</span><span class="main">,</span><span class="main">1</span> <span class="main">:]</span><span class="main">)</span><span class="main">^</span>Suc <span class="skolem">i</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> map_poly_Re_power<span class="main"><span class="keyword3">,</span></span> <span class="operator">insert</span> True<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?rp</span> <span class="main">[:</span> <span class="main">-</span><span class="skolem">x</span><span class="main">,</span><span class="main">1</span> <span class="main">:]</span> <span class="main">=</span> <span class="main">[:</span><span class="main">-</span><span class="main">(</span>Re <span class="skolem">x</span><span class="main">)</span><span class="main">,</span><span class="main">1</span><span class="main">:]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?rp</span> <span class="var">?xis</span> <span class="main">=</span> <span class="main">(</span><span class="main">∏</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span> <span class="main">←</span> <span class="var">?fact</span> <span class="skolem">xis</span><span class="main">.</span> <span class="bound">a</span> <span class="main">^</span> <span class="bound">b</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> IH <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>        
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="main">-</span> Re <span class="skolem">x</span><span class="main">,</span> <span class="main">1</span><span class="main">:]</span> <span class="main">^</span> Suc <span class="skolem">i</span> <span class="main">*</span> <span class="main">(</span><span class="main">∏</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span> <span class="main">←</span> <span class="var">?fact</span> <span class="skolem">xis</span><span class="main">.</span> <span class="bound">a</span> <span class="main">^</span> <span class="bound">b</span><span class="main">)</span> <span class="main">=</span> 
          <span class="main">(</span><span class="main">∏</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span> <span class="main">←</span> <span class="var">?fact</span> <span class="main">(</span><span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">i</span><span class="main">)</span> <span class="main">#</span> <span class="skolem">xis</span><span class="main">)</span><span class="main">.</span> <span class="bound">a</span> <span class="main">^</span> <span class="bound">b</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> True <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> idd<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?rp</span> <span class="main">(</span><span class="var">?xi</span> <span class="main">*</span> <span class="var">?xis</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∏</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span> <span class="main">←</span> <span class="var">?fact</span> <span class="main">(</span><span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">i</span><span class="main">)</span> <span class="main">#</span> <span class="skolem">xis</span><span class="main">)</span><span class="main">.</span> <span class="bound">a</span> <span class="main">^</span> <span class="bound">b</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
        <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> id idd
        <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> conjI<span class="main"><span class="keyword3">,</span></span> <span class="operator">force</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">intro</span> impI<span class="main">)</span>
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">q</span><span class="main">,</span> <span class="free">j</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span><span class="var">?fact</span> <span class="main">(</span><span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">#</span> <span class="skolem">xis</span><span class="main">)</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">q</span><span class="main">,</span><span class="free">j</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span><span class="var">?fact</span> <span class="skolem">xis</span><span class="main">)</span> <span class="main">∨</span> <span class="main">(</span><span class="free">q</span> <span class="main">=</span> <span class="main">[:</span><span class="main">-</span> Re <span class="skolem">x</span><span class="main">,</span> <span class="main">1</span><span class="main">:]</span> <span class="main">∧</span> <span class="free">j</span> <span class="main">=</span> Suc <span class="skolem">i</span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">using</span></span> True <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"irreducible <span class="free">q</span> <span class="main">∧</span> <span class="free">j</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">∧</span> monic <span class="free">q</span> <span class="main">∧</span> degree <span class="free">q</span> <span class="main">∈</span> <span class="main">{</span><span class="main">1</span><span class="main">,</span> <span class="numeral">2</span><span class="main">}</span>"</span></span>
          <span class="keyword1"><span class="command">proof</span></span>
            <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">q</span><span class="main">,</span><span class="free">j</span><span class="main">)</span> <span class="main">∈</span> set <span class="main">(</span><span class="var">?fact</span> <span class="skolem">xis</span><span class="main">)</span>"</span></span>
            <span class="keyword1"><span class="command">with</span></span> IH <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">next</span></span>
            <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">q</span> <span class="main">=</span> <span class="main">[:</span><span class="main">-</span> Re <span class="skolem">x</span><span class="main">,</span> <span class="main">1</span><span class="main">:]</span> <span class="main">∧</span> <span class="free">j</span> <span class="main">=</span> Suc <span class="skolem">i</span>"</span></span>
            <span class="keyword1"><span class="command">with</span></span> linear_irreducible_field<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="main">-</span> Re <span class="skolem">x</span><span class="main">,</span> <span class="main">1</span><span class="main">:]</span>"</span></span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> False
        <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">xi</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xi</span> <span class="main">=</span> <span class="main">[:</span>Re <span class="skolem">x</span> <span class="main">*</span> Re <span class="skolem">x</span> <span class="main">+</span> Im <span class="skolem">x</span> <span class="main">*</span> Im <span class="skolem">x</span><span class="main">,</span> <span class="main">-</span> <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> Re <span class="skolem">x</span><span class="main">)</span><span class="main">,</span> <span class="main">1</span><span class="main">:]</span>"</span></span>
        <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">xx</span></span> <span class="keyword2"><span class="keyword">where</span></span> xx<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">xx</span> <span class="main">=</span> cnj <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">have</span></span> xi<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">xi</span> <span class="main">=</span> <span class="var">?rp</span> <span class="main">(</span><span class="main">[:</span><span class="main">-</span><span class="skolem">x</span><span class="main">,</span><span class="main">1</span><span class="main">:]</span> <span class="main">*</span> <span class="main">[:</span><span class="main">-</span><span class="skolem">xx</span><span class="main">,</span><span class="main">1</span><span class="main">:]</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> xx xi_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">have</span></span> cpxi<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?cp</span> <span class="skolem">xi</span> <span class="main">=</span> <span class="main">[:</span><span class="main">-</span><span class="skolem">x</span><span class="main">,</span><span class="main">1</span><span class="main">:]</span> <span class="main">*</span> <span class="main">[:</span><span class="main">-</span><span class="skolem">xx</span><span class="main">,</span><span class="main">1</span><span class="main">:]</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> xi_def
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> xx legacy_Complex_simps<span class="main">)</span>
        <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">yis</span></span> <span class="keyword2"><span class="keyword">where</span></span> yis<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">yis</span> <span class="main">=</span> delete_cnj <span class="skolem">xx</span> <span class="main">(</span>Suc <span class="skolem">i</span><span class="main">)</span> <span class="skolem">xis</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">from</span></span> False <span class="keyword1"><span class="command">have</span></span> fact<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?fact</span> <span class="main">(</span><span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">i</span><span class="main">)</span> <span class="main">#</span> <span class="skolem">xis</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="skolem">xi</span><span class="main">,</span>Suc <span class="skolem">i</span><span class="main">)</span> <span class="main">#</span> <span class="var">?fact</span> <span class="skolem">yis</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">unfolding</span></span> xi_def xx yis <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">note</span></span> IH <span class="main">=</span> IH<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> False xx yis xi<span class="main">]</span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"irreducible <span class="skolem">xi</span>"</span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fold</span> irreducible_connect_field<span class="main">)</span>
        <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> irreducible<span class="hidden">⇩</span><sub>d</sub>I<span class="main">)</span>
          <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"degree <span class="skolem">xi</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> xi <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">q</span> <span class="skolem">p</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"real poly"</span></span> 
          <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"degree <span class="skolem">q</span> <span class="main">&gt;</span> <span class="main">0</span>"</span></span> <span class="quoted"><span class="quoted">"degree <span class="skolem">q</span> <span class="main">&lt;</span> degree <span class="skolem">xi</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> qp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">xi</span> <span class="main">=</span> <span class="skolem">q</span> <span class="main">*</span> <span class="skolem">p</span>"</span></span>
          <span class="keyword1"><span class="command">hence</span></span> dq<span class="main">:</span> <span class="quoted"><span class="quoted">"degree <span class="skolem">q</span> <span class="main">=</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> xi <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">have</span></span> dxi<span class="main">:</span> <span class="quoted"><span class="quoted">"degree <span class="skolem">xi</span> <span class="main">=</span> <span class="numeral">2</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xi</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> xi <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">with</span></span> qp <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">q</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">p</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"degree <span class="skolem">xi</span> <span class="main">=</span> degree <span class="skolem">q</span> <span class="main">+</span> degree <span class="skolem">p</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> qp
            <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> degree_mult_eq<span class="main">)</span>
          <span class="keyword1"><span class="command">with</span></span> dq <span class="keyword1"><span class="command">have</span></span> dp<span class="main">:</span> <span class="quoted"><span class="quoted">"degree <span class="skolem">p</span> <span class="main">=</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> dxi <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">{</span></span>
            <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">c</span> <span class="main">::</span> <span class="quoted">complex</span>
            <span class="keyword3"><span class="command">assume</span></span> rt<span class="main">:</span> <span class="quoted"><span class="quoted">"poly <span class="main">(</span><span class="var">?cp</span> <span class="skolem">xi</span><span class="main">)</span> <span class="skolem">c</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
            <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"poly <span class="main">(</span><span class="var">?cp</span> <span class="skolem">q</span> <span class="main">*</span> <span class="var">?cp</span> <span class="skolem">p</span><span class="main">)</span> <span class="skolem">c</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> qp <span class="dynamic"><span class="dynamic">hom_distribs</span></span><span class="main">)</span>
            <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>poly <span class="main">(</span><span class="var">?cp</span> <span class="skolem">q</span><span class="main">)</span> <span class="skolem">c</span> <span class="main">=</span> <span class="main">0</span> <span class="main">∨</span> poly <span class="main">(</span><span class="var">?cp</span> <span class="skolem">p</span><span class="main">)</span> <span class="skolem">c</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="main">=</span> roots1 <span class="main">(</span><span class="var">?cp</span> <span class="skolem">q</span><span class="main">)</span> <span class="main">∨</span> <span class="skolem">c</span> <span class="main">=</span> roots1 <span class="main">(</span><span class="var">?cp</span> <span class="skolem">p</span><span class="main">)</span>"</span></span>
              <span class="keyword1"><span class="command">using</span></span> roots1<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="var">?cp</span> <span class="skolem">q</span>"</span></span><span class="main">]</span> roots1<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="var">?cp</span> <span class="skolem">p</span>"</span></span><span class="main">]</span> dp dq <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="main">∈</span> <span class="main">ℝ</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> roots1_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
            <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">c</span> <span class="main">≠</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> False <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command">}</span></span>
          <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"poly <span class="main">(</span><span class="var">?cp</span> <span class="skolem">xi</span><span class="main">)</span> <span class="skolem">x</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
          <span class="keyword3"><span class="command">thus</span></span> <span class="quoted">False</span> <span class="keyword1"><span class="command">unfolding</span></span> cpxi <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">hence</span></span> xi'<span class="main">:</span> <span class="quoted"><span class="quoted">"irreducible <span class="skolem">xi</span>"</span></span> <span class="quoted"><span class="quoted">"monic <span class="skolem">xi</span>"</span></span> <span class="quoted"><span class="quoted">"degree <span class="skolem">xi</span> <span class="main">=</span> <span class="numeral">2</span>"</span></span>
          <span class="keyword1"><span class="command">unfolding</span></span> xi <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?xxi</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="main">-</span> <span class="skolem">xx</span><span class="main">,</span> <span class="main">1</span><span class="main">:]</span> <span class="main">^</span> Suc <span class="skolem">i</span>"</span></span>
        <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?yis</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∏</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">i</span><span class="main">)</span><span class="main">←</span><span class="skolem">yis</span><span class="main">.</span> <span class="main">[:</span><span class="main">-</span> <span class="bound">x</span><span class="main">,</span> <span class="main">1</span><span class="main">:]</span> <span class="main">^</span> Suc <span class="bound">i</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?yi</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="var">?cp</span> <span class="skolem">xi</span><span class="main">)</span><span class="main">^</span>Suc <span class="skolem">i</span>"</span></span>
        <span class="keyword1"><span class="command">have</span></span> yi<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>coeffs <span class="var">?yi</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">ℝ</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> real_poly_power<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> xi<span class="main">)</span>
        <span class="keyword1"><span class="command">have</span></span> mon<span class="main">:</span> <span class="quoted"><span class="quoted">"monic <span class="main">(</span><span class="main">∏</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">i</span><span class="main">)</span><span class="main">←</span><span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">i</span><span class="main">)</span> <span class="main">#</span> <span class="skolem">xis</span><span class="main">.</span> <span class="main">[:</span><span class="main">-</span> <span class="bound">x</span><span class="main">,</span> <span class="main">1</span><span class="main">:]</span> <span class="main">^</span> Suc <span class="bound">i</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> monic_prod_list_pow<span class="main">)</span>
        <span class="keyword1"><span class="command">from</span></span> monic_imp_nonzero<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> xixis<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?xi</span> <span class="main">*</span> <span class="var">?xis</span> <span class="main">≠</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> id <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">from</span></span> False <span class="keyword1"><span class="command">have</span></span> xxx<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">xx</span> <span class="main">≠</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> xx <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> legacy_Complex_simps Reals_def<span class="main">)</span>
        <span class="keyword1"><span class="command">from</span></span> prems<span class="main">[</span><span class="operator">unfolded</span> id<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> prems<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>coeffs <span class="main">(</span><span class="var">?xi</span> <span class="main">*</span> <span class="var">?xis</span><span class="main">)</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">ℝ</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
        <span class="keyword1"><span class="command">from</span></span> id <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="main">-</span> <span class="skolem">x</span><span class="main">,</span> <span class="main">1</span><span class="main">:]</span> <span class="main">^</span> Suc <span class="skolem">i</span> <span class="keyword1">dvd</span> <span class="var">?xi</span> <span class="main">*</span> <span class="var">?xis</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">from</span></span> xixis this<span class="main">[</span><span class="operator">unfolded</span> order_divides<span class="main">]</span> 
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"order <span class="skolem">x</span> <span class="main">(</span><span class="var">?xi</span> <span class="main">*</span> <span class="var">?xis</span><span class="main">)</span> <span class="main">≥</span> Suc <span class="skolem">i</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">with</span></span> complex_conjugate_order<span class="main">[</span><span class="operator">OF</span> prems xixis<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">,</span> <span class="operator">folded</span> xx<span class="main">]</span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"order <span class="skolem">xx</span> <span class="main">(</span><span class="var">?xi</span> <span class="main">*</span> <span class="var">?xis</span><span class="main">)</span> <span class="main">≥</span> Suc <span class="skolem">i</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"order <span class="skolem">xx</span> <span class="var">?xi</span> <span class="main">+</span> order <span class="skolem">xx</span> <span class="var">?xis</span> <span class="main">≥</span> Suc <span class="skolem">i</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> order_mult<span class="main">[</span><span class="operator">OF</span> xixis<span class="main">]</span> <span class="keyword1"><span class="command">.</span></span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"order <span class="skolem">xx</span> <span class="var">?xi</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> order_linear_power' <span class="keyword1"><span class="command">using</span></span> xxx <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"order <span class="skolem">xx</span> <span class="var">?xis</span> <span class="main">≥</span> Suc <span class="skolem">i</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">hence</span></span> yis<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?xis</span> <span class="main">=</span> <span class="var">?xxi</span> <span class="main">*</span> <span class="var">?yis</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> yis 
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> delete_cnj<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
        <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="var">?xi</span> <span class="main">*</span> <span class="var">?xis</span> <span class="main">=</span> <span class="main">(</span><span class="var">?xi</span> <span class="main">*</span> <span class="var">?xxi</span><span class="main">)</span> <span class="main">*</span> <span class="var">?yis</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">ac_simps</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?xi</span> <span class="main">*</span> <span class="var">?xxi</span> <span class="main">=</span> <span class="main">(</span><span class="main">[:</span><span class="main">-</span> <span class="skolem">x</span><span class="main">,</span> <span class="main">1</span><span class="main">:]</span> <span class="main">*</span> <span class="main">[:</span><span class="main">-</span> <span class="skolem">xx</span><span class="main">,</span> <span class="main">1</span><span class="main">:]</span><span class="main">)</span><span class="main">^</span>Suc <span class="skolem">i</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> power_mult_distrib<span class="main">)</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="main">-</span> <span class="skolem">x</span><span class="main">,</span> <span class="main">1</span><span class="main">:]</span> <span class="main">*</span> <span class="main">[:</span><span class="main">-</span> <span class="skolem">xx</span><span class="main">,</span> <span class="main">1</span><span class="main">:]</span> <span class="main">=</span> <span class="var">?cp</span> <span class="skolem">xi</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> cpxi <span class="keyword1"><span class="command">..</span></span>
        <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> idd<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?xi</span> <span class="main">*</span> <span class="var">?xis</span> <span class="main">=</span> <span class="main">(</span><span class="var">?cp</span> <span class="skolem">xi</span><span class="main">)</span><span class="main">^</span>Suc <span class="skolem">i</span> <span class="main">*</span> <span class="var">?yis</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">from</span></span> prems<span class="main">[</span><span class="operator">unfolded</span> idd<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> R<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>coeffs <span class="main">(</span><span class="main">(</span><span class="var">?cp</span> <span class="skolem">xi</span><span class="main">)</span><span class="main">^</span>Suc <span class="skolem">i</span> <span class="main">*</span> <span class="var">?yis</span><span class="main">)</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">ℝ</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
        <span class="keyword1"><span class="command">have</span></span> yis<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>coeffs <span class="var">?yis</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">ℝ</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> real_poly_factor<span class="main"><span class="main">[</span></span><span class="operator">OF</span> R yi<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> xi_def<span class="main">)</span>
        <span class="keyword1"><span class="command">note</span></span> IH <span class="main">=</span> IH<span class="main">[</span><span class="operator">OF</span> yis<span class="main">]</span> 
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?rp</span> <span class="main">(</span><span class="var">?xi</span> <span class="main">*</span> <span class="var">?xis</span><span class="main">)</span> <span class="main">=</span> <span class="var">?rp</span> <span class="var">?yi</span> <span class="main">*</span> <span class="var">?rp</span> <span class="var">?yis</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> idd
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> map_poly_Re_mult<span class="main"><span class="main">[</span></span><span class="operator">OF</span> yi yis<span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?rp</span> <span class="var">?yi</span> <span class="main">=</span> <span class="skolem">xi</span><span class="main">^</span>Suc <span class="skolem">i</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fold</span> <span class="dynamic"><span class="dynamic">hom_distribs</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> map_poly_Re_of_real<span class="main">)</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?rp</span> <span class="var">?yis</span> <span class="main">=</span> <span class="main">(</span><span class="main">∏</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span> <span class="main">←</span> <span class="var">?fact</span> <span class="skolem">yis</span><span class="main">.</span> <span class="bound">a</span> <span class="main">^</span> <span class="bound">b</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> IH <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xi</span> <span class="main">^</span> Suc <span class="skolem">i</span> <span class="main">*</span> <span class="main">(</span><span class="main">∏</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span> <span class="main">←</span> <span class="var">?fact</span> <span class="skolem">yis</span><span class="main">.</span> <span class="bound">a</span> <span class="main">^</span> <span class="bound">b</span><span class="main">)</span> <span class="main">=</span> 
          <span class="main">(</span><span class="main">∏</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span> <span class="main">←</span> <span class="var">?fact</span> <span class="main">(</span><span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">i</span><span class="main">)</span> <span class="main">#</span> <span class="skolem">xis</span><span class="main">)</span><span class="main">.</span> <span class="bound">a</span> <span class="main">^</span> <span class="bound">b</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> fact <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> idd<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?rp</span> <span class="main">(</span><span class="var">?xi</span> <span class="main">*</span> <span class="var">?xis</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∏</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span> <span class="main">←</span> <span class="var">?fact</span> <span class="main">(</span><span class="main">(</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">i</span><span class="main">)</span> <span class="main">#</span> <span class="skolem">xis</span><span class="main">)</span><span class="main">.</span> <span class="bound">a</span> <span class="main">^</span> <span class="bound">b</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
        <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> id idd fact <span class="keyword1"><span class="command">using</span></span> IH xi' <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> p <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">=</span> smult <span class="free">c</span> <span class="main">(</span><span class="main">∏</span><span class="main">(</span><span class="bound">q</span><span class="main">,</span> <span class="bound">i</span><span class="main">)</span><span class="main">←</span><span class="free">qis</span><span class="main">.</span> <span class="bound">q</span> <span class="main">^</span> <span class="bound">i</span><span class="main">)</span>"</span></span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">q</span><span class="main">,</span><span class="free">j</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">qis</span> <span class="main">⟹</span> irreducible <span class="free">q</span> <span class="main">∧</span> <span class="free">j</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">∧</span> monic <span class="free">q</span> <span class="main">∧</span> degree <span class="free">q</span> <span class="main">∈</span> <span class="main">{</span><span class="main">1</span><span class="main">,</span><span class="numeral">2</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span></pre>
</div>