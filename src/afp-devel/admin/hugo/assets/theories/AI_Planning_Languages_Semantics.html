<div id="Error_Monad_Add">
<div class="head">
<h1>Theory Error_Monad_Add</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">theory</span></span> Error_Monad_Add
<span class="keyword2"><span class="keyword">imports</span></span>
  <span class="quoted">"<a href="../../certification_monads/theories/#Check_Monad">Certification_Monads.Check_Monad</a>"</span>
  <span class="quoted">"<a href="../../show/theories/#Show_Instances">Show.Show_Instances</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="comment1">(* TODO: Move *)</span>  
  <span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">assert_opt</span> <span class="free"><span class="bound"><span class="entity">Φ</span></span></span> <span class="main">≡</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">Φ</span></span></span> <span class="keyword1">then</span> Some <span class="main">()</span> <span class="keyword1">else</span> None"</span></span>  

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">lift_opt</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">≡</span> <span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="keyword1">of</span> Some <span class="bound">x</span> <span class="main">⇒</span> Error_Monad.return <span class="bound">x</span> <span class="main">|</span> None <span class="main">⇒</span> Error_Monad.error <span class="free"><span class="bound"><span class="entity">e</span></span></span>"</span></span>
    
  <span class="keyword1" id="Error_Monad_Add-lift_opt_simps"><span class="command">lemma</span></span> lift_opt_simps<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"lift_opt None <span class="free">e</span> <span class="main">=</span> error <span class="free">e</span>"</span></span>
    <span class="quoted"><span class="quoted">"lift_opt <span class="main">(</span>Some <span class="free">v</span><span class="main">)</span> <span class="free">e</span> <span class="main">=</span> return <span class="free">v</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> lift_opt_def<span class="main">)</span>
  
  <span class="comment1">(* TODO: Move *)</span>  
  <span class="keyword1" id="Error_Monad_Add-reflcl_image_iff"><span class="command">lemma</span></span> reflcl_image_iff<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">R</span><span class="main"><span class="hidden">⇧</span><sup>=</sup></span><span class="main">``</span><span class="free">S</span> <span class="main">=</span> <span class="free">S</span><span class="main">∪</span><span class="free">R</span><span class="main">``</span><span class="free">S</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span> 
    
  <span class="keyword1"><span class="command">named_theorems</span></span> return_iff
      
  <span class="keyword1" id="Error_Monad_Add-bind_return_iff"><span class="command">lemma</span></span> bind_return_iff<span class="main">[</span><span class="operator">return_iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Error_Monad.bind <span class="free">m</span> <span class="free">f</span> <span class="main">=</span> Inr <span class="free">y</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="free">m</span> <span class="main">=</span> Inr <span class="bound">x</span> <span class="main">∧</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">=</span> Inr <span class="free">y</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    
  <span class="keyword1" id="Error_Monad_Add-lift_opt_return_iff"><span class="command">lemma</span></span> lift_opt_return_iff<span class="main">[</span><span class="operator">return_iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lift_opt <span class="free">m</span> <span class="free">e</span> <span class="main">=</span> Inr <span class="free">x</span> <span class="main">⟷</span> <span class="free">m</span><span class="main">=</span>Some <span class="free">x</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> lift_opt_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
      
  <span class="keyword1" id="Error_Monad_Add-check_return_iff"><span class="command">lemma</span></span> check_return_iff<span class="main">[</span><span class="operator">return_iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"check <span class="free">Φ</span> <span class="free">e</span> <span class="main">=</span> Inr <span class="free">uu</span> <span class="main">⟷</span> <span class="free">Φ</span>"</span></span>    
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> check_def<span class="main">)</span>
  
  
  <span class="keyword1" id="Error_Monad_Add-check_simps"><span class="command">lemma</span></span> check_simps<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>  
    <span class="quoted"><span class="quoted">"check True <span class="free">e</span> <span class="main">=</span> succeed"</span></span>
    <span class="quoted"><span class="quoted">"check False <span class="free">e</span> <span class="main">=</span> error <span class="free">e</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> check_def<span class="main">)</span>
        
  <span class="keyword1" id="Error_Monad_Add-Let_return_iff"><span class="command">lemma</span></span> Let_return_iff<span class="main">[</span><span class="operator">return_iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">let</span> <span class="bound">x</span><span class="main">=</span><span class="free">v</span> <span class="keyword1">in</span> <span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> Inr <span class="free">w</span> <span class="main">⟷</span> <span class="free">f</span> <span class="free">v</span> <span class="main">=</span> Inr <span class="free">w</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

  
  <span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">ERR</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"shows <span class="main">⇒</span> <span class="main">(</span>unit <span class="main">⇒</span> shows<span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ERR</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span>"</span></span>
  <span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">ERRS</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"String.literal <span class="main">⇒</span> <span class="main">(</span>unit <span class="main">⇒</span> shows<span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ERRS</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> ERR <span class="main">(</span>shows <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>"</span></span>
  
  
  <span class="keyword1" id="Error_Monad_Add-error_monad_bind_split"><span class="command">lemma</span></span> error_monad_bind_split<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">(</span>bind <span class="free">m</span> <span class="free">f</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">v</span><span class="main">.</span> <span class="free">m</span> <span class="main">=</span> Inl <span class="bound">v</span> <span class="main">⟶</span> <span class="free">P</span> <span class="main">(</span>Inl <span class="bound">v</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">v</span><span class="main">.</span> <span class="free">m</span> <span class="main">=</span> Inr <span class="bound">v</span> <span class="main">⟶</span> <span class="free">P</span> <span class="main">(</span><span class="free">f</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">m</span></span><span class="main">)</span> <span class="operator">auto</span>
  
  <span class="keyword1" id="Error_Monad_Add-error_monad_bind_split_asm"><span class="command">lemma</span></span> error_monad_bind_split_asm<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">(</span>bind <span class="free">m</span> <span class="free">f</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">¬</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="free">m</span> <span class="main">=</span> Inl <span class="bound">x</span> <span class="main">∧</span> <span class="main">¬</span> <span class="free">P</span> <span class="main">(</span>Inl <span class="bound">x</span><span class="main">)</span> <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="free">m</span> <span class="main">=</span> Inr <span class="bound">x</span> <span class="main">∧</span> <span class="main">¬</span> <span class="free">P</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">m</span></span><span class="main">)</span> <span class="operator">auto</span>
  
  <span class="keyword1"><span class="command">lemmas</span></span> error_monad_bind_splits <span class="main">=</span>error_monad_bind_split error_monad_bind_split_asm
  
  
<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Option_Monad_Add">
<div class="head">
<h1>Theory Option_Monad_Add</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">theory</span></span> Option_Monad_Add
<span class="keyword2"><span class="keyword">imports</span></span> <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/Monad_Syntax.html">HOL-Library.Monad_Syntax</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">oassert</span> <span class="free"><span class="bound"><span class="entity">Φ</span></span></span> <span class="main">≡</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">Φ</span></span></span> <span class="keyword1">then</span> Some <span class="main">()</span> <span class="keyword1">else</span> None"</span></span>

  <span class="keyword1"><span class="command">fun</span></span> <span class="entity">omap</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">⇀</span><span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> list <span class="main">⇀</span> <span class="tfree">'b</span> list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">omap</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">[]</span> <span class="main">=</span> Some <span class="main">[]</span>"</span></span> 
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">omap</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span> <span class="bound">y</span> <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">;</span> <span class="bound">ys</span> <span class="main">←</span> <span class="free">omap</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">;</span> Some <span class="main">(</span><span class="bound">y</span><span class="main">#</span><span class="bound">ys</span><span class="main">)</span> <span class="main">}</span>"</span></span>  
    
  <span class="keyword1" id="Option_Monad_Add-omap_cong"><span class="command">lemma</span></span> omap_cong<span class="main">[</span><span class="operator">fundef_cong</span><span class="main">]</span><span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">∈</span>set <span class="free">l'</span> <span class="main">⟹</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">f'</span> <span class="bound">x</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">l</span><span class="main">=</span><span class="free">l'</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"omap <span class="free">f</span> <span class="free">l</span> <span class="main">=</span> omap <span class="free">f'</span> <span class="free">l'</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> assms<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">l'</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>

  <span class="keyword1" id="Option_Monad_Add-assert_eq_iff"><span class="command">lemma</span></span> assert_eq_iff<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"oassert <span class="free">Φ</span> <span class="main">=</span> None <span class="main">⟷</span> <span class="main">¬</span><span class="free">Φ</span>"</span></span>  
    <span class="quoted"><span class="quoted">"oassert <span class="free">Φ</span> <span class="main">=</span> Some <span class="free">u</span> <span class="main">⟷</span> <span class="free">Φ</span>"</span></span>  
    <span class="keyword1"><span class="command">unfolding</span></span> oassert_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1" id="Option_Monad_Add-omap_length"><span class="command">lemma</span></span> omap_length<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"omap <span class="free">f</span> <span class="free">l</span> <span class="main">=</span> Some <span class="free">l'</span> <span class="main">⟹</span> length <span class="free">l'</span> <span class="main">=</span> length <span class="free">l</span>"</span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">l</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">l'</span></span><span class="main">)</span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> Option.bind_splits<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span> 

  <span class="keyword1" id="Option_Monad_Add-omap_append"><span class="command">lemma</span></span> omap_append<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"omap <span class="free">f</span> <span class="main">(</span><span class="free">xs</span><span class="main">@</span><span class="free">ys</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span><span class="bound">xs</span> <span class="main">←</span> omap <span class="free">f</span> <span class="free">xs</span><span class="main">;</span> <span class="bound">ys</span> <span class="main">←</span> omap <span class="free">f</span> <span class="free">ys</span><span class="main">;</span> Some <span class="main">(</span><span class="bound">xs</span><span class="main">@</span><span class="bound">ys</span><span class="main">)</span><span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>
    
        
  <span class="keyword1" id="Option_Monad_Add-omap_alt"><span class="command">lemma</span></span> omap_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"omap <span class="free">f</span> <span class="free">l</span> <span class="main">=</span> Some <span class="free">l'</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">l'</span> <span class="main">=</span> map <span class="main">(</span>the <span class="keyword1">o</span> <span class="free">f</span><span class="main">)</span> <span class="free">l</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">∈</span>set <span class="free">l</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">≠</span> None<span class="main">)</span><span class="main">)</span>"</span></span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">l</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">l'</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> Option.bind_splits<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    
  <span class="keyword1" id="Option_Monad_Add-omap_alt_None"><span class="command">lemma</span></span> omap_alt_None<span class="main">:</span> <span class="quoted"><span class="quoted">"omap <span class="free">f</span> <span class="free">l</span> <span class="main">=</span> None <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span><span class="main">∈</span>set <span class="free">l</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">=</span> None<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">l</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> Option.bind_splits<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    
  <span class="keyword1" id="Option_Monad_Add-omap_nth"><span class="command">lemma</span></span> omap_nth<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>omap <span class="free">f</span> <span class="free">l</span> <span class="main">=</span> Some <span class="free">l'</span><span class="main">;</span> <span class="free">i</span><span class="main">&lt;</span>length <span class="free">l</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">f</span> <span class="main">(</span><span class="free">l</span><span class="main">!</span><span class="free">i</span><span class="main">)</span> <span class="main">=</span> Some <span class="main">(</span><span class="free">l'</span><span class="main">!</span><span class="free">i</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">l</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">l'</span></span> <span class="quoted"><span class="free">i</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> Option.bind_splits <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> nth_Cons <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> nat.splits<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1" id="Option_Monad_Add-omap_eq_Nil_conv"><span class="command">lemma</span></span> omap_eq_Nil_conv<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"omap <span class="free">f</span> <span class="free">xs</span> <span class="main">=</span> Some <span class="main">[]</span> <span class="main">⟷</span> <span class="free">xs</span><span class="main">=</span><span class="main">[]</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> Option.bind_splits<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1" id="Option_Monad_Add-omap_eq_Cons_conv"><span class="command">lemma</span></span> omap_eq_Cons_conv<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"omap <span class="free">f</span> <span class="free">xs</span> <span class="main">=</span> Some <span class="main">(</span><span class="free">y</span><span class="main">#</span><span class="free">ys'</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span> <span class="bound">xs'</span><span class="main">.</span> <span class="free">xs</span><span class="main">=</span><span class="bound">x</span><span class="main">#</span><span class="bound">xs'</span> <span class="main">∧</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">=</span> Some <span class="free">y</span> <span class="main">∧</span> omap <span class="free">f</span> <span class="bound">xs'</span> <span class="main">=</span> Some <span class="free">ys'</span><span class="main">)</span>"</span></span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> Option.bind_splits<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
        
  <span class="keyword1" id="Option_Monad_Add-omap_eq_append_conv"><span class="command">lemma</span></span> omap_eq_append_conv<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"omap <span class="free">f</span> <span class="free">xs</span> <span class="main">=</span> Some <span class="main">(</span><span class="free">ys<span class="hidden">⇩</span><sub>1</sub></span><span class="main">@</span><span class="free">ys<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">xs<span class="hidden">⇩</span><sub>1</sub></span> <span class="bound">xs<span class="hidden">⇩</span><sub>2</sub></span><span class="main">.</span> <span class="free">xs</span><span class="main">=</span><span class="bound">xs<span class="hidden">⇩</span><sub>1</sub></span><span class="main">@</span><span class="bound">xs<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">∧</span> omap <span class="free">f</span> <span class="bound">xs<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">=</span> Some <span class="free">ys<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">∧</span> omap <span class="free">f</span> <span class="bound">xs<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">=</span> Some <span class="free">ys<span class="hidden">⇩</span><sub>2</sub></span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">ys<span class="hidden">⇩</span><sub>1</sub></span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 0 3 <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> Option.bind_splits<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> append_Cons<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  
  <span class="keyword1" id="Option_Monad_Add-omap_list_all2_conv"><span class="command">lemma</span></span> omap_list_all2_conv<span class="main">:</span> <span class="quoted"><span class="quoted">"omap <span class="free">f</span> <span class="free">xs</span> <span class="main">=</span> Some <span class="free">ys</span> <span class="main">⟷</span> <span class="main">(</span>list_all2 <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">=</span> Some <span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="free">xs</span> <span class="free">ys</span>"</span></span>  
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> Option.bind_splits <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> list_all2_Cons1<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> list_all2_Cons1<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> list_all2_Cons1<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> option.inject<span class="main">)</span>
    
    
    
    
  <span class="keyword1"><span class="command">fun</span></span> <span class="entity">omap_option</span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">omap_option</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> None <span class="main">=</span> Some None"</span></span>    
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">omap_option</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span> <span class="bound">x</span> <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">;</span> Some <span class="main">(</span>Some <span class="bound">x</span><span class="main">)</span> <span class="main">}</span>"</span></span>
  
  <span class="keyword1" id="Option_Monad_Add-omap_option_conv"><span class="command">lemma</span></span> omap_option_conv<span class="main">:</span>
    <span class="quoted"><span class="quoted">"omap_option <span class="free">f</span> <span class="free">xx</span> <span class="main">=</span> None <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="free">xx</span><span class="main">=</span>Some <span class="bound">x</span> <span class="main">∧</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">=</span> None<span class="main">)</span>"</span></span> 
    <span class="quoted"><span class="quoted">"omap_option <span class="free">f</span> <span class="free">xx</span> <span class="main">=</span> <span class="main">(</span>Some <span class="main">(</span>Some <span class="free">x'</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="free">xx</span><span class="main">=</span>Some <span class="bound">x</span> <span class="main">∧</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">=</span> Some <span class="free">x'</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"omap_option <span class="free">f</span> <span class="free">xx</span> <span class="main">=</span> <span class="main">(</span>Some None<span class="main">)</span> <span class="main">⟷</span> <span class="free">xx</span><span class="main">=</span>None"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xx</span></span><span class="main"><span class="keyword3">;</span></span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> Option.bind_splits<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  
  <span class="keyword1" id="Option_Monad_Add-omap_option_eq"><span class="command">lemma</span></span> omap_option_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"omap_option <span class="free">f</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">x</span> <span class="keyword1">of</span> None <span class="main">⇒</span> Some None <span class="main">|</span> Some <span class="bound">x</span> <span class="main">⇒</span> <span class="keyword1">do</span> <span class="main">{</span> <span class="bound">x</span> <span class="main">←</span> <span class="free">f</span> <span class="bound">x</span><span class="main">;</span> Some <span class="main">(</span>Some <span class="bound">x</span><span class="main">)</span> <span class="main">}</span><span class="main">)</span>"</span></span>  
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
      
  <span class="keyword1"><span class="command">fun</span></span> <span class="entity">omap_prod</span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">omap_prod</span> <span class="free"><span class="bound"><span class="entity">f<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">f<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span> <span class="bound">a</span><span class="main">←</span><span class="free"><span class="bound"><span class="entity">f<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">;</span> <span class="bound">b</span><span class="main">←</span><span class="free"><span class="bound"><span class="entity">f<span class="hidden">⇩</span><sub>2</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">;</span> Some <span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">b</span><span class="main">)</span> <span class="main">}</span>"</span></span>
    
      
  <span class="comment1">(* Extend map function for datatype to option monad.
    TODO: Show reasonable lemmas, like parametricity, etc. 
    Hopefully only depending on BNF-property of datatype
   *)</span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">omap_dt</span> <span class="free"><span class="bound"><span class="entity">setf</span></span></span> <span class="free"><span class="bound"><span class="entity">mapf</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">obj</span></span></span> <span class="main">≡</span> <span class="keyword1">do</span> <span class="main">{</span>
    oassert <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">setf</span></span></span> <span class="free"><span class="bound"><span class="entity">obj</span></span></span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">x</span> <span class="main">≠</span> None<span class="main">)</span><span class="main">;</span>
    Some <span class="main">(</span><span class="free"><span class="bound"><span class="entity">mapf</span></span></span> <span class="main">(</span>the <span class="keyword1">o</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">obj</span></span></span><span class="main">)</span>
  <span class="main">}</span>"</span></span>
    
    
    
<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="SASP_Semantics">
<div class="head">
<h1>Theory SASP_Semantics</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">theory</span></span> SASP_Semantics
<span class="keyword2"><span class="keyword">imports</span></span> <a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Semantics of Fast-Downward's Multi-Valued Planning Tasks Language›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Syntax›</span></span>
  <span class="keyword1"><span class="command">type_synonym</span></span> name <span class="main">=</span> <span class="quoted">string</span>
  <span class="keyword1"><span class="command">type_synonym</span></span> ast_variable <span class="main">=</span> <span class="quoted"><span class="quoted">"name <span class="main">×</span> nat option <span class="main">×</span> name list"</span></span> <span class="comment1">(* var name, axiom layer, atom names *)</span>
  <span class="keyword1"><span class="command">type_synonym</span></span> ast_variable_section <span class="main">=</span> <span class="quoted"><span class="quoted">"ast_variable list"</span></span>
  <span class="keyword1"><span class="command">type_synonym</span></span> ast_initial_state <span class="main">=</span> <span class="quoted"><span class="quoted">"nat list"</span></span>
  <span class="keyword1"><span class="command">type_synonym</span></span> ast_goal <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nat <span class="main">×</span> nat<span class="main">)</span> list"</span></span>
  <span class="keyword1"><span class="command">type_synonym</span></span> ast_precond <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>nat <span class="main">×</span> nat<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">type_synonym</span></span> ast_effect <span class="main">=</span> <span class="quoted"><span class="quoted">"ast_precond list <span class="main">×</span> nat <span class="main">×</span> nat option <span class="main">×</span> nat"</span></span>
  <span class="keyword1"><span class="command">type_synonym</span></span> ast_operator <span class="main">=</span> <span class="quoted"><span class="quoted">"name <span class="main">×</span> ast_precond list <span class="main">×</span> ast_effect list <span class="main">×</span> nat"</span></span>
  <span class="keyword1"><span class="command">type_synonym</span></span> ast_operator_section <span class="main">=</span> <span class="quoted"><span class="quoted">"ast_operator list"</span></span>
  
  <span class="keyword1"><span class="command">type_synonym</span></span> ast_problem <span class="main">=</span> 
    <span class="quoted"><span class="quoted">"ast_variable_section <span class="main">×</span> ast_initial_state <span class="main">×</span> ast_goal <span class="main">×</span> ast_operator_section"</span></span>

  <span class="keyword1"><span class="command">type_synonym</span></span> plan <span class="main">=</span> <span class="quoted"><span class="quoted">"name list"</span></span>
    
  <span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Well-Formedness›</span></span>
    
  <span class="keyword1"><span class="command">locale</span></span> ast_problem <span class="main">=</span>
    <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">problem</span> <span class="main">::</span> <span class="quoted">ast_problem</span>
  <span class="keyword2"><span class="keyword">begin</span></span>    
    <span class="keyword1"><span class="command">definition</span></span> <span class="entity">astDom</span> <span class="main">::</span> <span class="quoted">ast_variable_section</span> <span class="comment1">(* TODO: Dom → Vars, D → X*)</span>
      <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">astDom</span> <span class="main">≡</span> <span class="keyword1">case</span> <span class="free">problem</span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">D</span><span class="main">,</span><span class="bound">I</span><span class="main">,</span><span class="bound">G</span><span class="main">,</span><span class="bound">δ</span><span class="main">)</span> <span class="main">⇒</span> <span class="bound">D</span>"</span></span>
    <span class="keyword1"><span class="command">definition</span></span> <span class="entity">astI</span> <span class="main">::</span> <span class="quoted">ast_initial_state</span>
      <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">astI</span> <span class="main">≡</span> <span class="keyword1">case</span> <span class="free">problem</span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">D</span><span class="main">,</span><span class="bound">I</span><span class="main">,</span><span class="bound">G</span><span class="main">,</span><span class="bound">δ</span><span class="main">)</span> <span class="main">⇒</span> <span class="bound">I</span>"</span></span>
    <span class="keyword1"><span class="command">definition</span></span> <span class="entity">astG</span> <span class="main">::</span> <span class="quoted">ast_goal</span>
      <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">astG</span> <span class="main">≡</span> <span class="keyword1">case</span> <span class="free">problem</span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">D</span><span class="main">,</span><span class="bound">I</span><span class="main">,</span><span class="bound">G</span><span class="main">,</span><span class="bound">δ</span><span class="main">)</span> <span class="main">⇒</span> <span class="bound">G</span>"</span></span>
    <span class="keyword1"><span class="command">definition</span></span> <span class="entity">astδ</span> <span class="main">::</span> <span class="quoted">ast_operator_section</span>
      <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">astδ</span> <span class="main">≡</span> <span class="keyword1">case</span> <span class="free">problem</span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">D</span><span class="main">,</span><span class="bound">I</span><span class="main">,</span><span class="bound">G</span><span class="main">,</span><span class="bound">δ</span><span class="main">)</span> <span class="main">⇒</span> <span class="bound">δ</span>"</span></span>
    
    <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">numVars</span> <span class="main">≡</span> length astDom"</span></span>
    <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">numVals</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≡</span> length <span class="main">(</span>snd <span class="main">(</span>snd <span class="main">(</span>astDom<span class="main">!</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

    <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">wf_partial_state</span> <span class="free"><span class="bound"><span class="entity">ps</span></span></span> <span class="main">≡</span> 
        distinct <span class="main">(</span>map fst <span class="free"><span class="bound"><span class="entity">ps</span></span></span><span class="main">)</span> 
      <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="main">∈</span> set <span class="free"><span class="bound"><span class="entity">ps</span></span></span><span class="main">.</span> <span class="bound">x</span> <span class="main">&lt;</span> numVars <span class="main">∧</span> <span class="bound">v</span> <span class="main">&lt;</span> numVals <span class="bound">x</span><span class="main">)</span>"</span></span>
      
    <span class="keyword1"><span class="command">definition</span></span> <span class="entity">wf_operator</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"ast_operator <span class="main">⇒</span> bool"</span></span> 
      <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">wf_operator</span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">name</span><span class="main">,</span> <span class="bound">pres</span><span class="main">,</span> <span class="bound">effs</span><span class="main">,</span> <span class="bound">cost</span><span class="main">)</span><span class="main">.</span> 
        wf_partial_state <span class="bound">pres</span> 
      <span class="main">∧</span> distinct <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">v</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="bound">v</span><span class="main">)</span> <span class="bound">effs</span><span class="main">)</span> <span class="comment1">― ‹This may be too restrictive›</span>
      <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="main">(</span><span class="bound">epres</span><span class="main">,</span><span class="bound">x</span><span class="main">,</span><span class="bound">vp</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>set <span class="bound">effs</span><span class="main">.</span> 
          wf_partial_state <span class="bound">epres</span> 
        <span class="main">∧</span> <span class="bound">x</span> <span class="main">&lt;</span> numVars <span class="main">∧</span> <span class="bound">v</span> <span class="main">&lt;</span> numVals <span class="bound">x</span>  
        <span class="main">∧</span> <span class="main">(</span><span class="keyword1">case</span> <span class="bound">vp</span> <span class="keyword1">of</span> None <span class="main">⇒</span> True <span class="main">|</span> Some <span class="bound">v</span> <span class="main">⇒</span> <span class="bound">v</span><span class="main">&lt;</span>numVals <span class="bound">x</span><span class="main">)</span>
        <span class="main">)</span>
    "</span></span>
      
    <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">well_formed</span> <span class="main">≡</span> 
      <span class="comment1">― ‹Initial state›</span>
      length astI <span class="main">=</span> numVars
    <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">x</span></span><span class="main">&lt;</span>numVars<span class="main">.</span> astI<span class="main">!</span><span class="bound">x</span> <span class="main">&lt;</span> numVals <span class="bound">x</span><span class="main">)</span>

      <span class="comment1">― ‹Goal›</span>
    <span class="main">∧</span> wf_partial_state astG

    <span class="comment1">― ‹Operators›</span>
    <span class="main">∧</span> <span class="main">(</span>distinct <span class="main">(</span>map fst astδ<span class="main">)</span><span class="main">)</span>
    <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">π</span><span class="main">∈</span>set astδ<span class="main">.</span> wf_operator <span class="bound">π</span><span class="main">)</span>
    "</span></span>
      
  <span class="keyword2"><span class="keyword">end</span></span>  
  
  <span class="keyword1"><span class="command">locale</span></span> wf_ast_problem <span class="main">=</span> ast_problem <span class="main">+</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> wf<span class="main">:</span> <span class="quoted">well_formed</span>
  <span class="keyword2"><span class="keyword">begin</span></span>
    <span class="keyword1" id="SASP_Semantics-wf_initial"><span class="command">lemma</span></span> wf_initial<span class="main">:</span> 
      <span class="quoted"><span class="quoted">"length astI <span class="main">=</span> numVars"</span></span> 
      <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound"><span class="bound">x</span></span><span class="main">&lt;</span>numVars<span class="main">.</span> astI<span class="main">!</span><span class="bound">x</span> <span class="main">&lt;</span> numVals <span class="bound">x</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> wf <span class="keyword1"><span class="command">unfolding</span></span> well_formed_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword1" id="SASP_Semantics-wf_goal"><span class="command">lemma</span></span> wf_goal<span class="main">:</span> <span class="quoted"><span class="quoted">"wf_partial_state astG"</span></span>    
      <span class="keyword1"><span class="command">using</span></span> wf <span class="keyword1"><span class="command">unfolding</span></span> well_formed_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword1" id="SASP_Semantics-wf_operators"><span class="command">lemma</span></span> wf_operators<span class="main">:</span> 
      <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map fst astδ<span class="main">)</span>"</span></span>
      <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">π</span><span class="main">∈</span>set astδ<span class="main">.</span> wf_operator <span class="bound">π</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> wf <span class="keyword1"><span class="command">unfolding</span></span> well_formed_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword2"><span class="keyword">end</span></span>      
    
    
  <span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Semantics as Transition System›</span></span>  
    
  <span class="keyword1"><span class="command">type_synonym</span></span> state <span class="main">=</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇀</span> nat"</span></span>
  <span class="keyword1"><span class="command">type_synonym</span></span> pstate <span class="main">=</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇀</span> nat"</span></span>
    
    
  <span class="keyword1"><span class="command">context</span></span> ast_problem
  <span class="keyword2"><span class="keyword">begin</span></span>    
    
    <span class="keyword1"><span class="command">definition</span></span> <span class="entity">Dom</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat set"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">Dom</span> <span class="main">=</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span>numVars<span class="main">}</span>"</span></span>

    <span class="keyword1"><span class="command">definition</span></span> <span class="entity">range_of_var</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">range_of_var</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≡</span> <span class="main">{</span><span class="main">0</span><span class="main">..&lt;</span>numVals <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">}</span>"</span></span>

    <span class="keyword1"><span class="command">definition</span></span> <span class="entity">valid_states</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"state set"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">valid_states</span> <span class="main">≡</span> <span class="main">{</span>
      <span class="bound">s</span><span class="main">.</span> dom <span class="bound">s</span> <span class="main">=</span> Dom <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">∈</span>Dom<span class="main">.</span> the <span class="main">(</span><span class="bound">s</span> <span class="bound">x</span><span class="main">)</span> <span class="main">∈</span> range_of_var <span class="bound">x</span><span class="main">)</span>
    <span class="main">}</span>"</span></span>

    <span class="keyword1"><span class="command">definition</span></span> <span class="entity">I</span> <span class="main">::</span> <span class="quoted">state</span> 
      <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">I</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≡</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">&lt;</span>length astI <span class="keyword1">then</span> Some <span class="main">(</span>astI<span class="main">!</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="keyword1">else</span> None"</span></span>

    <span class="keyword1"><span class="command">definition</span></span> <span class="entity">subsuming_states</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"pstate <span class="main">⇒</span> state set"</span></span>
      <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">subsuming_states</span> <span class="free"><span class="bound"><span class="entity">partial</span></span></span> <span class="main">≡</span> <span class="main">{</span> <span class="bound"><span class="bound">s</span></span><span class="main">∈</span>valid_states<span class="main">.</span> <span class="free"><span class="bound"><span class="entity">partial</span></span></span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> <span class="bound">s</span> <span class="main">}</span>"</span></span>

    <span class="keyword1"><span class="command">definition</span></span> <span class="entity">G</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"state set"</span></span> 
      <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">G</span> <span class="main">≡</span> subsuming_states <span class="main">(</span>map_of astG<span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

    <span class="keyword1"><span class="command">definition</span></span> <span class="entity">implicit_pres</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"ast_effect list <span class="main">⇒</span> ast_precond list"</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
      <span class="quoted"><span class="quoted">"<span class="free">implicit_pres</span> <span class="free"><span class="bound"><span class="entity">effs</span></span></span> <span class="main">≡</span> 
      map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">v</span><span class="main">,</span><span class="bound">vpre</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">v</span><span class="main">,</span>the <span class="bound">vpre</span><span class="main">)</span><span class="main">)</span>
          <span class="main">(</span>filter <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">vpre</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="bound">vpre</span><span class="main">≠</span>None<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">effs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">context</span></span> ast_problem
<span class="keyword2"><span class="keyword">begin</span></span>

    <span class="keyword1"><span class="command">definition</span></span> <span class="entity">lookup_operator</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"name <span class="main">⇒</span> ast_operator option"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
      <span class="quoted"><span class="quoted">"<span class="free">lookup_operator</span> <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="main">≡</span> find <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">n</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="bound">n</span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">name</span></span></span><span class="main">)</span> astδ"</span></span>

    <span class="keyword1"><span class="command">definition</span></span> <span class="entity">enabled</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"name <span class="main">⇒</span> state <span class="main">⇒</span> bool"</span></span>
      <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">enabled</span> <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span>
        <span class="keyword1">case</span> lookup_operator <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="keyword1">of</span>
          Some <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">pres</span><span class="main">,</span><span class="bound">effs</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">⇒</span> 
              <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">∈</span>subsuming_states <span class="main">(</span>map_of <span class="bound">pres</span><span class="main">)</span>
            <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">∈</span>subsuming_states <span class="main">(</span>map_of <span class="main">(</span>implicit_pres <span class="bound">effs</span><span class="main">)</span><span class="main">)</span>
        <span class="main">|</span> None <span class="main">⇒</span> False"</span></span>
      
    <span class="keyword1"><span class="command">definition</span></span> <span class="entity">eff_enabled</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"state <span class="main">⇒</span> ast_effect <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
      <span class="quoted"><span class="quoted">"<span class="free">eff_enabled</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">pres</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">∈</span>subsuming_states <span class="main">(</span>map_of <span class="bound">pres</span><span class="main">)</span>"</span></span>

    <span class="keyword1"><span class="command">definition</span></span> <span class="entity">execute</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"name <span class="main">⇒</span> state <span class="main">⇒</span> state"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
      <span class="quoted"><span class="quoted">"<span class="free">execute</span> <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> 
        <span class="keyword1">case</span> lookup_operator <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="keyword1">of</span>
          Some <span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">effs</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">⇒</span>
            <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">++</span> map_of <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">x</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>filter <span class="main">(</span>eff_enabled <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="bound">effs</span><span class="main">)</span><span class="main">)</span>
        <span class="main">|</span> None <span class="main">⇒</span> undefined                                    
        "</span></span>

    <span class="keyword1"><span class="command">fun</span></span> <span class="entity">path_to</span> <span class="keyword2"><span class="keyword">where</span></span>
      <span class="quoted"><span class="quoted">"<span class="free">path_to</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">[]</span> <span class="free"><span class="bound"><span class="entity">s'</span></span></span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">s'</span></span></span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">s</span></span></span>"</span></span>
    <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">path_to</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">π</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">πs</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">s'</span></span></span> <span class="main">⟷</span> enabled <span class="free"><span class="bound"><span class="entity">π</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">∧</span> <span class="free">path_to</span> <span class="main">(</span>execute <span class="free"><span class="bound"><span class="entity">π</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">πs</span></span></span> <span class="free"><span class="bound"><span class="entity">s'</span></span></span>"</span></span>

    <span class="keyword1"><span class="command">definition</span></span> <span class="entity">valid_plan</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"plan <span class="main">⇒</span> bool"</span></span> 
      <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">valid_plan</span> <span class="free"><span class="bound"><span class="entity">πs</span></span></span> <span class="main">≡</span> <span class="main">∃</span><span class="bound">s'</span><span class="main">∈</span>G<span class="main">.</span> path_to I <span class="free"><span class="bound"><span class="entity">πs</span></span></span> <span class="bound">s'</span>"</span></span>


  <span class="keyword2"><span class="keyword">end</span></span>

  <span class="comment1">(*
    Next steps:
      * well-formed stuff
      * Executable SAS+ validator (well_formed and execute function)

  *)</span>  
    
  <span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Preservation of well-formedness›</span></span>  
  <span class="keyword1"><span class="command">context</span></span> wf_ast_problem 
  <span class="keyword2"><span class="keyword">begin</span></span>      
    <span class="keyword1" id="SASP_Semantics-I_valid"><span class="command">lemma</span></span> I_valid<span class="main">:</span> <span class="quoted"><span class="quoted">"I <span class="main">∈</span> valid_states"</span></span>
      <span class="keyword1"><span class="command">using</span></span> wf_initial 
      <span class="keyword1"><span class="command">unfolding</span></span> valid_states_def Dom_def I_def range_of_var_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span>if_splits<span class="main">)</span>
      
    <span class="keyword1" id="SASP_Semantics-lookup_operator_wf"><span class="command">lemma</span></span> lookup_operator_wf<span class="main">:</span>
      <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"lookup_operator <span class="free">name</span> <span class="main">=</span> Some <span class="free">π</span>"</span></span>
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"wf_operator <span class="free">π</span>"</span></span> <span class="quoted"><span class="quoted">"fst <span class="free">π</span> <span class="main">=</span> <span class="free">name</span>"</span></span>  
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">name'</span></span> <span class="skolem"><span class="skolem">pres</span></span> <span class="skolem"><span class="skolem">effs</span></span> <span class="skolem"><span class="skolem">cost</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">π</span><span class="main">=</span><span class="main">(</span><span class="skolem">name'</span><span class="main">,</span><span class="skolem">pres</span><span class="main">,</span><span class="skolem">effs</span><span class="main">,</span><span class="skolem">cost</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">π</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">name'</span><span class="main">=</span><span class="free">name</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> IN_AST<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">name</span><span class="main">,</span><span class="skolem">pres</span><span class="main">,</span><span class="skolem">effs</span><span class="main">,</span><span class="skolem">cost</span><span class="main">)</span> <span class="main">∈</span> set astδ"</span></span>
        <span class="keyword1"><span class="command">using</span></span> assms
        <span class="keyword1"><span class="command">unfolding</span></span> lookup_operator_def
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> case_prodD find_Some_iff<span class="main">)</span>  
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> case_prodD find_Some_iff nth_mem<span class="main">)</span>  
      
      <span class="keyword1"><span class="command">from</span></span> IN_AST <span class="keyword3"><span class="command">show</span></span> WF<span class="main">:</span> <span class="quoted"><span class="quoted">"wf_operator <span class="free">π</span>"</span></span> <span class="quoted"><span class="quoted">"fst <span class="free">π</span> <span class="main">=</span> <span class="free">name</span>"</span></span>   
        <span class="keyword1"><span class="command">unfolding</span></span> enabled_def <span class="keyword1"><span class="command">using</span></span> wf_operators <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>
        
        
    <span class="keyword1" id="SASP_Semantics-execute_preserves_valid"><span class="command">lemma</span></span> execute_preserves_valid<span class="main">:</span>
      <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">∈</span>valid_states"</span></span>  
      <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"enabled <span class="free">name</span> <span class="free">s</span>"</span></span>  
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"execute <span class="free">name</span> <span class="free">s</span> <span class="main">∈</span> valid_states"</span></span>  
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹enabled <span class="free">name</span> <span class="free">s</span>›</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">name'</span></span> <span class="skolem"><span class="skolem">pres</span></span> <span class="skolem"><span class="skolem">effs</span></span> <span class="skolem"><span class="skolem">cost</span></span> <span class="keyword2"><span class="keyword">where</span></span>
        <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lookup_operator <span class="free">name</span> <span class="main">=</span> Some <span class="main">(</span><span class="skolem">name'</span><span class="main">,</span><span class="skolem">pres</span><span class="main">,</span><span class="skolem">effs</span><span class="main">,</span><span class="skolem">cost</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> enabled_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> lookup_operator_wf<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> WF<span class="main">:</span> <span class="quoted"><span class="quoted">"wf_operator <span class="main">(</span><span class="free">name</span><span class="main">,</span><span class="skolem">pres</span><span class="main">,</span><span class="skolem">effs</span><span class="main">,</span><span class="skolem">cost</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>   
      
      <span class="keyword1"><span class="command">have</span></span> X1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">++</span> <span class="skolem">m</span> <span class="main">∈</span> valid_states"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span> <span class="bound">v</span><span class="main">.</span> <span class="skolem">m</span> <span class="bound">x</span> <span class="main">=</span> Some <span class="bound">v</span> <span class="main">⟶</span> <span class="bound">x</span><span class="main">&lt;</span>numVars <span class="main">∧</span> <span class="bound">v</span><span class="main">&lt;</span>numVals <span class="bound">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span>
        <span class="keyword1"><span class="command">using</span></span> that <span class="quoted"><span class="quoted">‹<span class="free">s</span><span class="main">∈</span>valid_states›</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 
            <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valid_states_def Dom_def range_of_var_def map_add_def dom_def 
            <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>  
      
      <span class="keyword1"><span class="command">have</span></span> X2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span><span class="main">&lt;</span>numVars"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">&lt;</span>numVals <span class="skolem">x</span>"</span></span> 
        <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"map_of <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">x</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>filter <span class="main">(</span>eff_enabled <span class="free">s</span><span class="main">)</span> <span class="skolem">effs</span><span class="main">)</span><span class="main">)</span> <span class="skolem">x</span> <span class="main">=</span> Some <span class="skolem">v</span>"</span></span>    
        <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">v</span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
        <span class="keyword1"><span class="command">from</span></span> that <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">epres</span></span> <span class="skolem"><span class="skolem">vp</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">epres</span><span class="main">,</span><span class="skolem">x</span><span class="main">,</span><span class="skolem">vp</span><span class="main">,</span><span class="skolem">v</span><span class="main">)</span> <span class="main">∈</span> set <span class="skolem">effs</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> map_of_SomeD<span class="main">)</span>
        <span class="keyword1"><span class="command">with</span></span> WF <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span><span class="main">&lt;</span>numVars"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">v</span><span class="main">&lt;</span>numVals <span class="skolem">x</span>"</span></span>
          <span class="keyword1"><span class="command">unfolding</span></span> wf_operator_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">qed</span></span>
          
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">using</span></span> assms  
        <span class="keyword1"><span class="command">unfolding</span></span> enabled_def execute_def 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> X1 X2<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>      
    
    <span class="keyword1" id="SASP_Semantics-path_to_pres_valid"><span class="command">lemma</span></span> path_to_pres_valid<span class="main">:</span>
      <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">∈</span>valid_states"</span></span>
      <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"path_to <span class="free">s</span> <span class="free">πs</span> <span class="free">s'</span>"</span></span>
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">s'</span><span class="main">∈</span>valid_states"</span></span>
      <span class="keyword1"><span class="command">using</span></span> assms
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">πs</span></span> <span class="quoted"><span class="free">s'</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> path_to.induct<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> execute_preserves_valid<span class="main">)</span>  
      
  <span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="SASP_Checker">
<div class="head">
<h1>Theory SASP_Checker</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">theory</span></span> SASP_Checker
<span class="keyword2"><span class="keyword">imports</span></span> <a href="#SASP_Semantics">SASP_Semantics</a>
  <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/Code_Target_Nat.html">HOL-Library.Code_Target_Nat</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹An Executable Checker for Multi-Valued Planning Problem Solutions›</span></span>


  <span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Auxiliary Lemmas›</span></span>
  <span class="keyword1" id="SASP_Checker-map_of_leI"><span class="command">lemma</span></span> map_of_leI<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map fst <span class="free">l</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">k</span> <span class="bound">v</span><span class="main">.</span> <span class="main">(</span><span class="bound">k</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">∈</span>set <span class="free">l</span> <span class="main">⟹</span> <span class="free">m</span> <span class="bound">k</span> <span class="main">=</span> Some <span class="bound">v</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"map_of <span class="free">l</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> <span class="free">m</span>"</span></span>  
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> hide_lams<span class="main"><span class="main">)</span></span> domIff map_le_def map_of_SomeD not_Some_eq<span class="main">)</span>  

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"fst <span class="main">∘</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">b</span><span class="main">,</span> <span class="bound">c</span><span class="main">,</span> <span class="bound">d</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="free">f</span> <span class="bound">a</span> <span class="bound">b</span> <span class="bound">c</span> <span class="bound">d</span><span class="main">,</span> <span class="free">g</span> <span class="bound">a</span> <span class="bound">b</span> <span class="bound">c</span> <span class="bound">d</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span><span class="bound">b</span><span class="main">,</span><span class="bound">c</span><span class="main">,</span><span class="bound">d</span><span class="main">)</span><span class="main">.</span> <span class="free">f</span> <span class="bound">a</span> <span class="bound">b</span> <span class="bound">c</span> <span class="bound">d</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      
  <span class="keyword1" id="SASP_Checker-map_mp"><span class="command">lemma</span></span> map_mp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">m</span><span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span><span class="free">m'</span> <span class="main">⟹</span> <span class="free">m</span> <span class="free">k</span> <span class="main">=</span> Some <span class="free">v</span> <span class="main">⟹</span> <span class="free">m'</span> <span class="free">k</span> <span class="main">=</span> Some <span class="free">v</span>"</span></span>    
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> map_le_def dom_def<span class="main">)</span>
      
      
  <span class="keyword1" id="SASP_Checker-map_add_map_of_fold"><span class="command">lemma</span></span> map_add_map_of_fold<span class="main">:</span> 
    <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">ps</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">m</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇀</span> <span class="tfree">'b</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map fst <span class="free">ps</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">++</span> map_of <span class="free">ps</span> <span class="main">=</span> fold <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">k</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="bound">m</span><span class="main">.</span> <span class="bound">m</span><span class="main">(</span><span class="bound">k</span> <span class="main">↦</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span> <span class="free">ps</span> <span class="free">m</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> X1<span class="main">:</span> <span class="quoted"><span class="quoted">"fold <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">k</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="bound">m</span><span class="main">.</span> <span class="bound">m</span><span class="main">(</span><span class="bound">k</span> <span class="main">↦</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span> <span class="skolem">ps</span> <span class="skolem">m</span><span class="main">(</span><span class="skolem">a</span> <span class="main">↦</span> <span class="skolem">b</span><span class="main">)</span> 
            <span class="main">=</span> fold <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">k</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="bound">m</span><span class="main">.</span> <span class="bound">m</span><span class="main">(</span><span class="bound">k</span> <span class="main">↦</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span> <span class="skolem">ps</span> <span class="main">(</span><span class="skolem">m</span><span class="main">(</span><span class="skolem">a</span> <span class="main">↦</span> <span class="skolem">b</span><span class="main">)</span><span class="main">)</span>"</span></span> 
      <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∉</span> fst <span class="main">`</span> set <span class="skolem">ps</span>"</span></span>
      <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">a</span> <span class="skolem">b</span> <span class="skolem">ps</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">m</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇀</span> <span class="tfree">'b</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> that
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">ps</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">m</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fun_upd_twist<span class="main">)</span>
    
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">using</span></span> assms
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">ps</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">m</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> X1<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>    

  

  <span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Well-formedness Check›</span></span>
  <span class="keyword1"><span class="command">lemmas</span></span> wf_code_thms <span class="main">=</span> 
      ast_problem.astDom_def ast_problem.astI_def ast_problem.astG_def ast_problem.astδ_def
      ast_problem.numVars_def ast_problem.numVals_def 
      ast_problem.wf_partial_state_def ast_problem.wf_operator_def ast_problem.well_formed_def
      
      
  <span class="keyword1"><span class="command">declare</span></span> wf_code_thms<span class="main">[</span><span class="operator">code</span><span class="main">]</span>
      
  <span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">ast_problem.well_formed</span></span> <span class="keyword2"><span class="keyword">in</span></span> SML

    
  <span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Execution›</span></span>  
    
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">match_pre</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"ast_precond <span class="main">⇒</span> state <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">match_pre</span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="bound">s</span><span class="main">.</span> <span class="bound">s</span> <span class="bound">x</span> <span class="main">=</span> Some <span class="bound">v</span>"</span></span>
    
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">match_pres</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"ast_precond list <span class="main">⇒</span> state <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">match_pres</span> <span class="free"><span class="bound"><span class="entity">pres</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="main">∀</span><span class="bound">pre</span><span class="main">∈</span>set <span class="free"><span class="bound"><span class="entity">pres</span></span></span><span class="main">.</span> match_pre <span class="bound">pre</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span>"</span></span>
    
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">match_implicit_pres</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"ast_effect list <span class="main">⇒</span> state <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">match_implicit_pres</span> <span class="free"><span class="bound"><span class="entity">effs</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="main">∀</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">x</span><span class="main">,</span><span class="bound">vp</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">∈</span>set <span class="free"><span class="bound"><span class="entity">effs</span></span></span><span class="main">.</span> 
      <span class="main">(</span><span class="keyword1">case</span> <span class="bound">vp</span> <span class="keyword1">of</span> None <span class="main">⇒</span> True <span class="main">|</span> Some <span class="bound">v</span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="bound">x</span> <span class="main">=</span> Some <span class="bound">v</span><span class="main">)</span>"</span></span>
    
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">enabled_opr'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"ast_operator <span class="main">⇒</span> state <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
    <span class="quoted"><span class="quoted">"<span class="free">enabled_opr'</span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">name</span><span class="main">,</span><span class="bound">pres</span><span class="main">,</span><span class="bound">effs</span><span class="main">,</span><span class="bound">cost</span><span class="main">)</span> <span class="bound">s</span><span class="main">.</span> match_pres <span class="bound">pres</span> <span class="bound">s</span> <span class="main">∧</span> match_implicit_pres <span class="bound">effs</span> <span class="bound">s</span>"</span></span>
      
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">eff_enabled'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"state <span class="main">⇒</span> ast_effect <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">eff_enabled'</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">pres</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> match_pres <span class="bound">pres</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span>"</span></span>
    
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">execute_opr'</span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">name</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">effs</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="bound">s</span><span class="main">.</span> 
    <span class="keyword1">let</span> <span class="bound">effs</span> <span class="main">=</span> filter <span class="main">(</span>eff_enabled' <span class="bound">s</span><span class="main">)</span> <span class="bound">effs</span>
    <span class="keyword1">in</span> fold <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">x</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="bound">v</span><span class="main">)</span> <span class="bound">s</span><span class="main">.</span> <span class="bound">s</span><span class="main">(</span><span class="bound">x</span><span class="main">↦</span><span class="bound">v</span><span class="main">)</span><span class="main">)</span> <span class="bound">effs</span> <span class="bound">s</span>
  "</span></span>  

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">lookup_operator'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"ast_problem <span class="main">⇒</span> name <span class="main">⇀</span> ast_operator"</span></span> 
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">lookup_operator'</span> <span class="main">≡</span> <span class="main">λ</span><span class="main">(</span><span class="bound">D</span><span class="main">,</span><span class="bound">I</span><span class="main">,</span><span class="bound">G</span><span class="main">,</span><span class="bound">δ</span><span class="main">)</span> <span class="bound">name</span><span class="main">.</span> find <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">n</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="bound">n</span><span class="main">=</span><span class="bound">name</span><span class="main">)</span> <span class="bound">δ</span>"</span></span>
    
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">enabled'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"ast_problem <span class="main">⇒</span> name <span class="main">⇒</span> state <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">enabled'</span> <span class="free"><span class="bound"><span class="entity">problem</span></span></span> <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> 
      <span class="keyword1">case</span> lookup_operator' <span class="free"><span class="bound"><span class="entity">problem</span></span></span> <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="keyword1">of</span> 
        Some <span class="bound">π</span> <span class="main">⇒</span> enabled_opr' <span class="bound">π</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span>
      <span class="main">|</span> None <span class="main">⇒</span> False"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">execute'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"ast_problem <span class="main">⇒</span> name <span class="main">⇒</span> state <span class="main">⇒</span> state"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">execute'</span> <span class="free"><span class="bound"><span class="entity">problem</span></span></span> <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">≡</span> 
      <span class="keyword1">case</span> lookup_operator' <span class="free"><span class="bound"><span class="entity">problem</span></span></span> <span class="free"><span class="bound"><span class="entity">name</span></span></span> <span class="keyword1">of</span> 
        Some <span class="bound">π</span> <span class="main">⇒</span> execute_opr' <span class="bound">π</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span>
      <span class="main">|</span> None <span class="main">⇒</span> undefined"</span></span>
    
    
  <span class="keyword1"><span class="command">context</span></span> wf_ast_problem <span class="keyword2"><span class="keyword">begin</span></span>  
    
    <span class="keyword1" id="SASP_Checker-match_pres_correct"><span class="command">lemma</span></span> match_pres_correct<span class="main">:</span>
      <span class="keyword2"><span class="keyword">assumes</span></span> D<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map fst <span class="free">pres</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">∈</span>valid_states"</span></span>  
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"match_pres <span class="free">pres</span> <span class="free">s</span> <span class="main">⟷</span> <span class="free">s</span><span class="main">∈</span>subsuming_states <span class="main">(</span>map_of <span class="free">pres</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"match_pres <span class="free">pres</span> <span class="free">s</span> <span class="main">⟷</span> map_of <span class="free">pres</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> <span class="free">s</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> match_pres_def match_pre_def
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span>
        <span class="keyword1"><span class="command">using</span></span> map_le_def map_of_SomeD <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fastforce</span>  
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>full_types<span class="main"><span class="main">)</span></span> D domIff map_le_def map_of_eq_Some_iff option.simps<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span>
    
      <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>          
        <span class="keyword1"><span class="command">unfolding</span></span> subsuming_states_def 
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>
       
    <span class="keyword1" id="SASP_Checker-match_implicit_pres_correct"><span class="command">lemma</span></span> match_implicit_pres_correct<span class="main">:</span>
      <span class="keyword2"><span class="keyword">assumes</span></span> D<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">v</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> <span class="bound">v</span><span class="main">)</span> <span class="free">effs</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">∈</span>valid_states"</span></span>  
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"match_implicit_pres <span class="free">effs</span> <span class="free">s</span> <span class="main">⟷</span> <span class="free">s</span><span class="main">∈</span>subsuming_states <span class="main">(</span>map_of <span class="main">(</span>implicit_pres <span class="free">effs</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> subsuming_states_def 
        <span class="keyword1"><span class="command">unfolding</span></span> match_implicit_pres_def implicit_pres_def
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 
            <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits option.splits 
            <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> distinct_map_filter
            <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> map_of_leI<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> distinct_map_filter <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> map_mp<span class="main">)</span>  
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>  
    <span class="keyword1"><span class="command">qed</span></span>
          
    <span class="keyword1" id="SASP_Checker-enabled_opr'_correct"><span class="command">lemma</span></span> enabled_opr'_correct<span class="main">:</span>
      <span class="keyword2"><span class="keyword">assumes</span></span> V<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">∈</span>valid_states"</span></span>
      <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"lookup_operator <span class="free">name</span> <span class="main">=</span> Some <span class="free">π</span>"</span></span>  
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"enabled_opr' <span class="free">π</span> <span class="free">s</span> <span class="main">⟷</span> enabled <span class="free">name</span> <span class="free">s</span>"</span></span>  
      <span class="keyword1"><span class="command">using</span></span> lookup_operator_wf<span class="main">[</span><span class="operator">OF</span> assms<span class="main"><span class="main"><span class="main">(</span></span></span>2<span class="main"><span class="main"><span class="main">)</span></span></span><span class="main">]</span> assms
      <span class="keyword1"><span class="command">unfolding</span></span> enabled_opr'_def enabled_def wf_operator_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 
          <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> match_pres_correct<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ V<span class="main"><span class="main">]</span></span> match_implicit_pres_correct<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ V<span class="main"><span class="main">]</span></span>
          <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> wf_partial_state_def
          <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split
          <span class="main">)</span>  
       
    <span class="keyword1" id="SASP_Checker-eff_enabled'_correct"><span class="command">lemma</span></span> eff_enabled'_correct<span class="main">:</span>
      <span class="keyword2"><span class="keyword">assumes</span></span> V<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">∈</span>valid_states"</span></span>
      <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">case</span> <span class="free">eff</span> <span class="keyword1">of</span> <span class="main">(</span><span class="bound">pres</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span> <span class="main">⇒</span> wf_partial_state <span class="bound">pres</span>"</span></span>  
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"eff_enabled' <span class="free">s</span> <span class="free">eff</span> <span class="main">⟷</span> eff_enabled <span class="free">s</span> <span class="free">eff</span>"</span></span>  
      <span class="keyword1"><span class="command">using</span></span> assms  
      <span class="keyword1"><span class="command">unfolding</span></span> eff_enabled'_def eff_enabled_def wf_partial_state_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> match_pres_correct<span class="main">)</span>  
    
    
    <span class="keyword1" id="SASP_Checker-execute_opr'_correct"><span class="command">lemma</span></span> execute_opr'_correct<span class="main">:</span>
      <span class="keyword2"><span class="keyword">assumes</span></span> V<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">∈</span>valid_states"</span></span>
      <span class="keyword2"><span class="keyword">assumes</span></span> LO<span class="main">:</span> <span class="quoted"><span class="quoted">"lookup_operator <span class="free">name</span> <span class="main">=</span> Some <span class="free">π</span>"</span></span>  
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"execute_opr' <span class="free">π</span> <span class="free">s</span> <span class="main">=</span> execute <span class="free">name</span> <span class="free">s</span>"</span></span>  
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">π</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="main">(</span>fields <span class="skolem">name</span> <span class="skolem">pres</span> <span class="skolem">effs</span><span class="main">)</span>
        
      <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"filter <span class="main">(</span>eff_enabled' <span class="free">s</span><span class="main">)</span> <span class="skolem">effs</span> <span class="main">=</span> filter <span class="main">(</span>eff_enabled <span class="free">s</span><span class="main">)</span> <span class="skolem">effs</span>"</span></span>  
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> filter_cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> refl<span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> eff_enabled'_correct<span class="main"><span class="main">[</span></span><span class="operator">OF</span> V<span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command">using</span></span> lookup_operator_wf<span class="main">[</span><span class="operator">OF</span> LO<span class="main">]</span>  
        <span class="keyword1"><span class="command">unfolding</span></span> wf_operator_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  
          
      <span class="keyword1"><span class="command">have</span></span> X1<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map fst <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">x</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>filter <span class="main">(</span>eff_enabled <span class="free">s</span><span class="main">)</span> <span class="skolem">effs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> lookup_operator_wf<span class="main">[</span><span class="operator">OF</span> LO<span class="main">]</span>
        <span class="keyword1"><span class="command">unfolding</span></span> wf_operator_def 
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> distinct_map_filter<span class="main">)</span>
        
      <span class="keyword1"><span class="command">term</span></span> <span class="quoted"><span class="quoted">"filter <span class="main">(</span>eff_enabled <span class="free">s</span><span class="main">)</span> <span class="skolem">effs</span>"</span></span>    
          
      <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
        <span class="quoted"><span class="quoted">"fold <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">x</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="bound">s</span><span class="main">.</span> <span class="bound">s</span><span class="main">(</span><span class="bound">x</span> <span class="main">↦</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span> <span class="skolem">l</span> <span class="free">s</span> <span class="main">=</span>
         fold <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">k</span><span class="main">,</span> <span class="bound">v</span><span class="main">)</span> <span class="bound">m</span><span class="main">.</span> <span class="bound">m</span><span class="main">(</span><span class="bound">k</span> <span class="main">↦</span> <span class="bound">v</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">x</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="skolem">l</span><span class="main">)</span> <span class="free">s</span>"</span></span> 
        <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">l</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"ast_effect list"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">l</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">s</span></span><span class="main">)</span> <span class="operator">auto</span>
          
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> 
        <span class="keyword1"><span class="command">unfolding</span></span> execute_opr'_def execute_def <span class="keyword1"><span class="command">using</span></span> LO
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> map_add_map_of_fold<span class="main"><span class="main">[</span></span><span class="operator">OF</span> X1<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
        
      
    <span class="keyword1" id="SASP_Checker-lookup_operator'_correct"><span class="command">lemma</span></span> lookup_operator'_correct<span class="main">:</span> 
      <span class="quoted"><span class="quoted">"lookup_operator' <span class="free">problem</span> <span class="free">name</span> <span class="main">=</span> lookup_operator <span class="free">name</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> lookup_operator'_def lookup_operator_def
      <span class="keyword1"><span class="command">unfolding</span></span> astδ_def  
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span>  
        
    <span class="keyword1" id="SASP_Checker-enabled'_correct"><span class="command">lemma</span></span> enabled'_correct<span class="main">:</span>
      <span class="keyword2"><span class="keyword">assumes</span></span> V<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">∈</span>valid_states"</span></span>
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"enabled' <span class="free">problem</span> <span class="free">name</span> <span class="free">s</span> <span class="main">=</span> enabled <span class="free">name</span> <span class="free">s</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> enabled'_def  
      <span class="keyword1"><span class="command">using</span></span> enabled_opr'_correct<span class="main">[</span><span class="operator">OF</span> V<span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> enabled_def lookup_operator'_correct<span class="main">)</span>  
        
    <span class="keyword1" id="SASP_Checker-execute'_correct"><span class="command">lemma</span></span> execute'_correct<span class="main">:</span>
      <span class="keyword2"><span class="keyword">assumes</span></span> V<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">∈</span>valid_states"</span></span>
      <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"enabled <span class="free">name</span> <span class="free">s</span>"</span></span>      <span class="comment1">(* Intentionally put this here, also we could resolve non-enabled case by reflexivity (undefined=undefined) *)</span>
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"execute' <span class="free">problem</span> <span class="free">name</span> <span class="free">s</span> <span class="main">=</span> execute <span class="free">name</span> <span class="free">s</span>"</span></span>  
      <span class="keyword1"><span class="command">unfolding</span></span> execute'_def  
      <span class="keyword1"><span class="command">using</span></span> execute_opr'_correct<span class="main">[</span><span class="operator">OF</span> V<span class="main">]</span> <span class="quoted"><span class="quoted">‹enabled <span class="free">name</span> <span class="free">s</span>›</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> enabled_def lookup_operator'_correct<span class="main">)</span>  
        
        
        
  <span class="keyword2"><span class="keyword">end</span></span>    

  <span class="keyword1"><span class="command">context</span></span> ast_problem 
  <span class="keyword2"><span class="keyword">begin</span></span>  
    
    <span class="keyword1"><span class="command">fun</span></span> <span class="entity">simulate_plan</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"plan <span class="main">⇒</span> state <span class="main">⇀</span> state"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
      <span class="quoted"><span class="quoted">"<span class="free">simulate_plan</span> <span class="main">[]</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> Some <span class="free"><span class="bound"><span class="entity">s</span></span></span>"</span></span>
    <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">simulate_plan</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">π</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">πs</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="main">(</span>
        <span class="keyword1">if</span> enabled <span class="free"><span class="bound"><span class="entity">π</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="keyword1">then</span> 
          <span class="keyword1">let</span> <span class="bound">s'</span> <span class="main">=</span> execute <span class="free"><span class="bound"><span class="entity">π</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="keyword1">in</span>
          <span class="free">simulate_plan</span> <span class="free"><span class="bound"><span class="entity">πs</span></span></span> <span class="bound">s'</span>
        <span class="keyword1">else</span>
          None
      <span class="main">)</span>"</span></span>  
    
    <span class="keyword1" id="SASP_Checker-simulate_plan_correct"><span class="command">lemma</span></span> simulate_plan_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"simulate_plan <span class="free">πs</span> <span class="free">s</span> <span class="main">=</span> Some <span class="free">s'</span> <span class="main">⟷</span> path_to <span class="free">s</span> <span class="free">πs</span> <span class="free">s'</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">s</span></span> <span class="quoted"><span class="free">πs</span></span> <span class="quoted"><span class="free">s'</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> path_to.induct<span class="main">)</span> <span class="operator">auto</span>  
      
    <span class="keyword1"><span class="command">definition</span></span> <span class="entity">check_plan</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"plan <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
      <span class="quoted"><span class="quoted">"<span class="free">check_plan</span> <span class="free"><span class="bound"><span class="entity">πs</span></span></span> <span class="main">=</span> <span class="main">(</span>
        <span class="keyword1">case</span> simulate_plan <span class="free"><span class="bound"><span class="entity">πs</span></span></span> I <span class="keyword1">of</span> 
          None <span class="main">⇒</span> False 
        <span class="main">|</span> Some <span class="bound">s'</span> <span class="main">⇒</span> <span class="bound">s'</span> <span class="main">∈</span> G<span class="main">)</span>"</span></span>
      
    <span class="keyword1" id="SASP_Checker-check_plan_correct"><span class="command">lemma</span></span> check_plan_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"check_plan <span class="free">πs</span> <span class="main">⟷</span> valid_plan <span class="free">πs</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> check_plan_def valid_plan_def 
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> simulate_plan_correct<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      
  <span class="keyword2"><span class="keyword">end</span></span>  
    
  <span class="keyword1"><span class="command">fun</span></span> <span class="entity">simulate_plan'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"ast_problem <span class="main">⇒</span> plan <span class="main">⇒</span> state <span class="main">⇀</span> state"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">simulate_plan'</span> <span class="free"><span class="bound"><span class="entity">problem</span></span></span> <span class="main">[]</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> Some <span class="free"><span class="bound"><span class="entity">s</span></span></span>"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">simulate_plan'</span> <span class="free"><span class="bound"><span class="entity">problem</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">π</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">πs</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="main">(</span>
      <span class="keyword1">if</span> enabled' <span class="free"><span class="bound"><span class="entity">problem</span></span></span> <span class="free"><span class="bound"><span class="entity">π</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="keyword1">then</span>
        <span class="keyword1">let</span> <span class="bound">s</span> <span class="main">=</span> execute' <span class="free"><span class="bound"><span class="entity">problem</span></span></span> <span class="free"><span class="bound"><span class="entity">π</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="keyword1">in</span>
        <span class="free">simulate_plan'</span> <span class="free"><span class="bound"><span class="entity">problem</span></span></span> <span class="free"><span class="bound"><span class="entity">πs</span></span></span> <span class="bound">s</span>
      <span class="keyword1">else</span>
        None
    <span class="main">)</span>"</span></span>  
    
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Avoiding duplicate lookup.›</span></span>
  <span class="comment1">(*[code]  *)</span>  
  <span class="keyword1" id="SASP_Checker-simulate_plan'_code"><span class="command">lemma</span></span> simulate_plan'_code<span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"simulate_plan' <span class="free">problem</span> <span class="main">[]</span> <span class="free">s</span> <span class="main">=</span> Some <span class="free">s</span>"</span></span>
    <span class="quoted"><span class="quoted">"simulate_plan' <span class="free">problem</span> <span class="main">(</span><span class="free">π</span><span class="main">#</span><span class="free">πs</span><span class="main">)</span> <span class="free">s</span> <span class="main">=</span> <span class="main">(</span>
      <span class="keyword1">case</span> lookup_operator' <span class="free">problem</span> <span class="free">π</span> <span class="keyword1">of</span>
        None <span class="main">⇒</span> None
      <span class="main">|</span> Some <span class="bound">π</span> <span class="main">⇒</span> 
          <span class="keyword1">if</span> enabled_opr' <span class="bound">π</span> <span class="free">s</span> <span class="keyword1">then</span> 
            simulate_plan' <span class="free">problem</span> <span class="free">πs</span> <span class="main">(</span>execute_opr' <span class="bound">π</span> <span class="free">s</span><span class="main">)</span>
          <span class="keyword1">else</span> None
    <span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> enabled'_def execute'_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
    
    
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">initial_state'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"ast_problem <span class="main">⇒</span> state"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">initial_state'</span> <span class="free"><span class="bound"><span class="entity">problem</span></span></span> <span class="main">≡</span> <span class="keyword1">let</span> <span class="bound">astI</span> <span class="main">=</span> ast_problem.astI <span class="free"><span class="bound"><span class="entity">problem</span></span></span> <span class="keyword1">in</span> <span class="main">(</span>
       <span class="main">λ</span><span class="bound">v</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">v</span><span class="main">&lt;</span>length <span class="bound">astI</span> <span class="keyword1">then</span> Some <span class="main">(</span><span class="bound">astI</span><span class="main">!</span><span class="bound">v</span><span class="main">)</span> <span class="keyword1">else</span> None
     <span class="main">)</span>"</span></span>
      
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">check_plan'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"ast_problem <span class="main">⇒</span> plan <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">check_plan'</span> <span class="free"><span class="bound"><span class="entity">problem</span></span></span> <span class="free"><span class="bound"><span class="entity">πs</span></span></span> <span class="main">=</span> <span class="main">(</span>
      <span class="keyword1">case</span> simulate_plan' <span class="free"><span class="bound"><span class="entity">problem</span></span></span> <span class="free"><span class="bound"><span class="entity">πs</span></span></span> <span class="main">(</span>initial_state' <span class="free"><span class="bound"><span class="entity">problem</span></span></span><span class="main">)</span> <span class="keyword1">of</span> 
        None <span class="main">⇒</span> False 
      <span class="main">|</span> Some <span class="bound">s'</span> <span class="main">⇒</span> match_pres <span class="main">(</span>ast_problem.astG <span class="free"><span class="bound"><span class="entity">problem</span></span></span><span class="main">)</span> <span class="bound">s'</span><span class="main">)</span>"</span></span>
      
      
  <span class="keyword1"><span class="command">context</span></span> wf_ast_problem 
  <span class="keyword2"><span class="keyword">begin</span></span>  
    
    <span class="keyword1" id="SASP_Checker-simulate_plan'_correct"><span class="command">lemma</span></span> simulate_plan'_correct<span class="main">:</span>
      <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">∈</span>valid_states"</span></span>
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"simulate_plan' <span class="free">problem</span> <span class="free">πs</span> <span class="free">s</span> <span class="main">=</span> simulate_plan <span class="free">πs</span> <span class="free">s</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> assms
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">πs</span></span> <span class="quoted"><span class="free">s</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> simulate_plan.induct<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> enabled'_correct execute'_correct execute_preserves_valid<span class="main">)</span>  
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
        
    <span class="keyword1" id="SASP_Checker-simulate_plan'_correct_paper"><span class="command">lemma</span></span> simulate_plan'_correct_paper<span class="main">:</span> <span class="comment1">(* For presentation in paper. 
        Summarizing intermediate refinement step. *)</span>
      <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span><span class="main">∈</span>valid_states"</span></span>
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"simulate_plan' <span class="free">problem</span> <span class="free">πs</span> <span class="free">s</span> <span class="main">=</span> Some <span class="free">s'</span>
            <span class="main">⟷</span> path_to <span class="free">s</span> <span class="free">πs</span> <span class="free">s'</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> simulate_plan'_correct<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> simulate_plan_correct <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      
        
    <span class="keyword1" id="SASP_Checker-initial_state'_correct"><span class="command">lemma</span></span> initial_state'_correct<span class="main">:</span> 
      <span class="quoted"><span class="quoted">"initial_state' <span class="free">problem</span> <span class="main">=</span> I"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> initial_state'_def I_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>

    <span class="keyword1" id="SASP_Checker-check_plan'_correct"><span class="command">lemma</span></span> check_plan'_correct<span class="main">:</span>
      <span class="quoted"><span class="quoted">"check_plan' <span class="free">problem</span> <span class="free">πs</span> <span class="main">=</span> check_plan <span class="free">πs</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command">have</span></span> D<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map fst astG<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> wf_goal <span class="keyword1"><span class="command">unfolding</span></span> wf_partial_state_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span> 
        
      <span class="keyword1"><span class="command">have</span></span> S'V<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">s'</span><span class="main">∈</span>valid_states"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"simulate_plan <span class="free">πs</span> I <span class="main">=</span> Some <span class="skolem">s'</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">s'</span>
        <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> simulate_plan_correct path_to_pres_valid<span class="main"><span class="main">[</span></span><span class="operator">OF</span> I_valid<span class="main"><span class="main">]</span></span><span class="main">)</span>
          
      <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> check_plan'_def check_plan_def
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 
            <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits 
            <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> initial_state'_correct simulate_plan'_correct<span class="main"><span class="main">[</span></span><span class="operator">OF</span> I_valid<span class="main"><span class="main">]</span></span>
            <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> match_pres_correct<span class="main"><span class="main">[</span></span><span class="operator">OF</span> D S'V<span class="main"><span class="main">]</span></span> G_def
            <span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>  
        
  <span class="keyword2"><span class="keyword">end</span></span>

    
  <span class="comment1">(* Overall checker *)</span>  
    
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">verify_plan</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"ast_problem <span class="main">⇒</span> plan <span class="main">⇒</span> String.literal <span class="main">+</span> unit"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">verify_plan</span> <span class="free"><span class="bound"><span class="entity">problem</span></span></span> <span class="free"><span class="bound"><span class="entity">πs</span></span></span> <span class="main">=</span> <span class="main">(</span>
      <span class="keyword1">if</span> ast_problem.well_formed <span class="free"><span class="bound"><span class="entity">problem</span></span></span> <span class="keyword1">then</span>
        <span class="keyword1">if</span> check_plan' <span class="free"><span class="bound"><span class="entity">problem</span></span></span> <span class="free"><span class="bound"><span class="entity">πs</span></span></span> <span class="keyword1">then</span> Inr <span class="main">()</span> <span class="keyword1">else</span> Inl <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Invalid plan''</span><span class="main">)</span>
      <span class="keyword1">else</span> Inl <span class="main">(</span><span class="keyword1">STR</span> <span class="inner_quoted">''Problem not well formed''</span><span class="main">)</span>
    <span class="main">)</span>"</span></span>

  <span class="keyword1" id="SASP_Checker-verify_plan_correct"><span class="command">lemma</span></span> verify_plan_correct<span class="main">:</span>
    <span class="quoted"><span class="quoted">"verify_plan <span class="free">problem</span> <span class="free">πs</span> <span class="main">=</span> Inr <span class="main">()</span> 
    <span class="main">⟷</span> ast_problem.well_formed <span class="free">problem</span> <span class="main">∧</span> ast_problem.valid_plan <span class="free">problem</span> <span class="free">πs</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"ast_problem.well_formed <span class="free">problem</span>"</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> wf_ast_problem <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
          
      <span class="keyword1"><span class="command">from</span></span> check_plan'_correct check_plan_correct 
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"check_plan' <span class="free">problem</span> <span class="free">πs</span> <span class="main">=</span> valid_plan <span class="free">πs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">}</span></span> 
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>  
      <span class="keyword1"><span class="command">unfolding</span></span> verify_plan_def
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>  
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">nat_opt_of_integer</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"integer <span class="main">⇒</span> nat option"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
       <span class="quoted"><span class="quoted">"<span class="free">nat_opt_of_integer</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">≥</span> <span class="main">0</span><span class="main">)</span> <span class="keyword1">then</span> Some <span class="main">(</span>nat_of_integer <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> <span class="keyword1">else</span> None<span class="main">)</span>"</span></span>

  <span class="comment1">(*Export functions, which includes constructors*)</span>
  <span class="keyword1"><span class="command">export_code</span></span> <span class="quoted"><span class="quoted">verify_plan</span></span> <span class="quoted"><span class="quoted">nat_of_integer</span></span> <span class="quoted"><span class="quoted">integer_of_nat</span></span> <span class="quoted"><span class="quoted">nat_opt_of_integer</span></span> <span class="quoted"><span class="quoted">Inl</span></span> <span class="quoted"><span class="quoted">Inr</span></span> <span class="quoted"><span class="quoted">String.explode</span></span> <span class="quoted"><span class="quoted">String.implode</span></span>
    <span class="keyword2"><span class="keyword">in</span></span> SML
    <span class="keyword2"><span class="keyword">module_name</span></span> SASP_Checker_Exported
    <span class="keyword2"><span class="keyword">file</span></span> <span class="quoted">"code/SASP_Checker_Exported.sml"</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="PDDL_STRIPS_Semantics">
<div class="head">
<h1>Theory PDDL_STRIPS_Semantics</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹PDDL and STRIPS Semantics›</span></span>
<span class="keyword1"><span class="command">theory</span></span> PDDL_STRIPS_Semantics
<span class="keyword2"><span class="keyword">imports</span></span>
  <span class="quoted">"<a href="../../propositional_proof_systems/theories/#Formulas">Propositional_Proof_Systems.Formulas</a>"</span>
  <span class="quoted">"<a href="../../propositional_proof_systems/theories/#Sema">Propositional_Proof_Systems.Sema</a>"</span>
  <span class="quoted">"<a href="../../propositional_proof_systems/theories/#Consistency">Propositional_Proof_Systems.Consistency</a>"</span>
  <span class="quoted">"<a href="../../automatic_refinement/theories/#Misc">Automatic_Refinement.Misc</a>"</span>
  <span class="quoted">"<a href="../../automatic_refinement/theories/#Refine_Util">Automatic_Refinement.Refine_Util</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">no_notation</span></span> insert <span class="main">(</span><span class="quoted">"_ <span class="keyword1">▹</span> _"</span> <span class="main">[</span>56<span class="main">,</span>55<span class="main">]</span> 55<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Utility Functions›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">index_by</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">≡</span> map_of <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">x</span><span class="main">,</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="PDDL_STRIPS_Semantics-index_by_eq_Some_eq"><span class="command">lemma</span></span> index_by_eq_Some_eq<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map <span class="free">f</span> <span class="free">l</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"index_by <span class="free">f</span> <span class="free">l</span> <span class="free">n</span> <span class="main">=</span> Some <span class="free">x</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">x</span><span class="main">∈</span>set <span class="free">l</span> <span class="main">∧</span> <span class="free">f</span> <span class="free">x</span> <span class="main">=</span> <span class="free">n</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> index_by_def
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> o_def<span class="main">)</span>

<span class="keyword1" id="PDDL_STRIPS_Semantics-index_by_eq_SomeD"><span class="command">lemma</span></span> index_by_eq_SomeD<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"index_by <span class="free">f</span> <span class="free">l</span> <span class="free">n</span> <span class="main">=</span> Some <span class="free">x</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">x</span><span class="main">∈</span>set <span class="free">l</span> <span class="main">∧</span> <span class="free">f</span> <span class="free">x</span> <span class="main">=</span> <span class="free">n</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> index_by_def
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> map_of_SomeD<span class="main">)</span>


<span class="keyword1" id="PDDL_STRIPS_Semantics-lookup_zip_idx_eq"><span class="command">lemma</span></span> lookup_zip_idx_eq<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"length <span class="free">params</span> <span class="main">=</span> length <span class="free">args</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span><span class="main">&lt;</span>length <span class="free">args</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"distinct <span class="free">params</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">k</span> <span class="main">=</span> <span class="free">params</span> <span class="main">!</span> <span class="free">i</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"map_of <span class="main">(</span>zip <span class="free">params</span> <span class="free">args</span><span class="main">)</span> <span class="free">k</span> <span class="main">=</span> Some <span class="main">(</span><span class="free">args</span> <span class="main">!</span> <span class="free">i</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_set_conv_nth<span class="main">)</span>

<span class="keyword1" id="PDDL_STRIPS_Semantics-rtrancl_image_idem"><span class="command">lemma</span></span> rtrancl_image_idem<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">R</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="free">R</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="free">s</span> <span class="main">=</span> <span class="free">R</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="free">s</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> relcomp_Image rtrancl_idemp_self_comp<span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Abstract Syntax›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Generic Entities›</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> name <span class="main">=</span> <span class="quoted">string</span>

<span class="keyword1"><span class="command">datatype</span></span> predicate <span class="main">=</span> Pred <span class="main">(</span><span class="free"><span class="entity">name</span></span><span class="main">:</span> <span class="quoted">name</span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Some of the AST entities are defined over a polymorphic <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>'val›</span></span></span></span> type,
  which gets either instantiated by variables (for domains)
  or objects (for problems).
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹An atom is either a predicate with arguments, or an equality statement.›</span></span>
<span class="keyword1"><span class="command">datatype</span></span> <span class="tfree">'ent</span> atom <span class="main">=</span> predAtm <span class="main">(</span><span class="free"><span class="entity">predicate</span></span><span class="main">:</span> <span class="quoted">predicate</span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="entity">arguments</span></span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="tfree">'ent</span> list"</span></span><span class="main">)</span>
                     <span class="main">|</span> Eq <span class="main">(</span><span class="free"><span class="entity">lhs</span></span><span class="main">:</span> <span class="tfree"><span class="quoted"><span class="tfree">'ent</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="entity">rhs</span></span><span class="main">:</span> <span class="tfree"><span class="quoted"><span class="tfree">'ent</span></span></span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A type is a list of primitive type names.
  To model a primitive type, we use a singleton list.›</span></span>
<span class="keyword1"><span class="command">datatype</span></span> type <span class="main">=</span> Either <span class="main">(</span><span class="free"><span class="entity">primitives</span></span><span class="main">:</span> <span class="quoted"><span class="quoted">"name list"</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹An effect contains a list of values to be added, and a list of values
  to be removed.›</span></span>
<span class="keyword1"><span class="command">datatype</span></span> <span class="tfree">'ent</span> ast_effect <span class="main">=</span> Effect <span class="main">(</span><span class="free"><span class="entity">adds</span></span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'ent</span> atom formula<span class="main">)</span> list"</span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="entity">dels</span></span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'ent</span> atom formula<span class="main">)</span> list"</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Variables are identified by their names.›</span></span>
<span class="keyword1"><span class="command">datatype</span></span> variable <span class="main">=</span> <span class="entity">varname</span><span class="main">:</span> Var <span class="quoted">name</span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Objects and constants are identified by their names›</span></span>
<span class="keyword1"><span class="command">datatype</span></span> object <span class="main">=</span> <span class="entity">name</span><span class="main">:</span> Obj <span class="quoted">name</span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="quoted">"term"</span> <span class="main">=</span> VAR <span class="quoted">variable</span> <span class="main">|</span> CONST <span class="quoted">object</span>
<span class="keyword1"><span class="command">hide_const</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="main">)</span> VAR CONST <span class="comment1">― ‹Refer to constructors by qualified names only›</span>




<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Domains›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹An action schema has a name, a typed parameter list, a precondition,
  and an effect.›</span></span>
<span class="keyword1"><span class="command">datatype</span></span> ast_action_schema <span class="main">=</span> Action_Schema
  <span class="main">(</span><span class="free"><span class="entity">name</span></span><span class="main">:</span> <span class="quoted">name</span><span class="main">)</span>
  <span class="main">(</span><span class="free"><span class="entity">parameters</span></span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>variable <span class="main">×</span> type<span class="main">)</span> list"</span></span><span class="main">)</span>
  <span class="main">(</span><span class="free"><span class="entity">precondition</span></span><span class="main">:</span> <span class="quoted"><span class="quoted">"term atom formula"</span></span><span class="main">)</span>
  <span class="main">(</span><span class="free"><span class="entity">effect</span></span><span class="main">:</span> <span class="quoted"><span class="quoted">"term ast_effect"</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A predicate declaration contains the predicate's name and its
  argument types.›</span></span>
<span class="keyword1"><span class="command">datatype</span></span> predicate_decl <span class="main">=</span> PredDecl
  <span class="main">(</span><span class="free"><span class="entity">pred</span></span><span class="main">:</span> <span class="quoted">predicate</span><span class="main">)</span>
  <span class="main">(</span><span class="free"><span class="entity">argTs</span></span><span class="main">:</span> <span class="quoted"><span class="quoted">"type list"</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A domain contains the declarations of primitive types, predicates,
  and action schemas.›</span></span>
<span class="keyword1"><span class="command">datatype</span></span> ast_domain <span class="main">=</span> Domain
  <span class="main">(</span><span class="free"><span class="entity">types</span></span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>name <span class="main">×</span> name<span class="main">)</span> list"</span></span><span class="main">)</span> <span class="comment1">― ‹ <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>(type, supertype)›</span></span> declarations. ›</span>
  <span class="main">(</span><span class="free"><span class="entity">predicates</span></span><span class="main">:</span> <span class="quoted"><span class="quoted">"predicate_decl list"</span></span><span class="main">)</span>
  <span class="main">(</span><span class="quoted">"<span class="free"><span class="entity">consts</span></span>"</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>object <span class="main">×</span> type<span class="main">)</span> list"</span></span><span class="main">)</span>
  <span class="main">(</span><span class="free"><span class="entity">actions</span></span><span class="main">:</span> <span class="quoted"><span class="quoted">"ast_action_schema list"</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Problems›</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A fact is a predicate applied to objects.›</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> fact <span class="main">=</span> <span class="quoted"><span class="quoted">"predicate <span class="main">×</span> object list"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A problem consists of a domain, a list of objects,
  a description of the initial state, and a description of the goal state. ›</span></span>
<span class="keyword1"><span class="command">datatype</span></span> ast_problem <span class="main">=</span> Problem
  <span class="main">(</span><span class="free"><span class="entity">domain</span></span><span class="main">:</span> <span class="quoted">ast_domain</span><span class="main">)</span>
  <span class="main">(</span><span class="free"><span class="entity">objects</span></span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>object <span class="main">×</span> type<span class="main">)</span> list"</span></span><span class="main">)</span>
  <span class="main">(</span><span class="free"><span class="entity">init</span></span><span class="main">:</span> <span class="quoted"><span class="quoted">"object atom formula list"</span></span><span class="main">)</span>
  <span class="main">(</span><span class="free"><span class="entity">goal</span></span><span class="main">:</span> <span class="quoted"><span class="quoted">"object atom formula"</span></span><span class="main">)</span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Plans›</span></span>
<span class="keyword1"><span class="command">datatype</span></span> plan_action <span class="main">=</span> PAction
  <span class="main">(</span><span class="free"><span class="entity">name</span></span><span class="main">:</span> <span class="quoted">name</span><span class="main">)</span>
  <span class="main">(</span><span class="free"><span class="entity">arguments</span></span><span class="main">:</span> <span class="quoted"><span class="quoted">"object list"</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">type_synonym</span></span> plan <span class="main">=</span> <span class="quoted"><span class="quoted">"plan_action list"</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Ground Actions›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The following datatype represents an action scheme that has been
  instantiated by replacing the arguments with concrete objects,
  also called ground action.
›</span></span>
<span class="keyword1"><span class="command">datatype</span></span> ground_action <span class="main">=</span> Ground_Action
  <span class="main">(</span><span class="free"><span class="entity">precondition</span></span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>object atom<span class="main">)</span> formula"</span></span><span class="main">)</span>
  <span class="main">(</span><span class="free"><span class="entity">effect</span></span><span class="main">:</span> <span class="quoted"><span class="quoted">"object ast_effect"</span></span><span class="main">)</span>



<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Closed-World Assumption, Equality, and Negation›</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Discriminator for atomic predicate formulas.›</span></span>
  <span class="keyword1"><span class="command">fun</span></span> <span class="entity">is_predAtom</span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">is_predAtom</span> <span class="main">(</span>Atom <span class="main">(</span>predAtm <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> True"</span></span> <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">is_predAtom</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> False"</span></span>


  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The world model is a set of (atomic) formulas›</span></span>
  <span class="keyword1"><span class="command">type_synonym</span></span> world_model <span class="main">=</span> <span class="quoted"><span class="quoted">"object atom formula set"</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹It is basic, if it only contains atoms›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">wm_basic</span> <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="main">≡</span> <span class="main">∀</span><span class="bound">a</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">M</span></span></span><span class="main">.</span> is_predAtom <span class="bound">a</span>"</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A valuation extracted from the atoms of the world model›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">valuation</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"world_model <span class="main">⇒</span> object atom valuation"</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">valuation</span> <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="main">≡</span> <span class="main">λ</span>predAtm <span class="bound">p</span> <span class="bound">xs</span> <span class="main">⇒</span> Atom <span class="main">(</span>predAtm <span class="bound">p</span> <span class="bound">xs</span><span class="main">)</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="main">|</span> Eq <span class="bound">a</span> <span class="bound">b</span> <span class="main">⇒</span> <span class="bound">a</span><span class="main">=</span><span class="bound">b</span>"</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Augment a world model by adding negated versions of all atoms
    not contained in it, as well as interpretations of equality.›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">close_world</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"world_model <span class="main">⇒</span> world_model"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">close_world</span> <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="main">=</span>
    <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="main">∪</span> <span class="main">{</span><span class="main"><span class="hidden">❙</span><b>¬</b></span><span class="main">(</span>Atom <span class="main">(</span>predAtm <span class="bound">p</span> <span class="bound">as</span><span class="main">)</span><span class="main">)</span> <span class="main">|</span> <span class="bound">p</span> <span class="bound">as</span><span class="main">.</span> Atom <span class="main">(</span>predAtm <span class="bound">p</span> <span class="bound">as</span><span class="main">)</span> <span class="main">∉</span> <span class="free"><span class="bound"><span class="entity">M</span></span></span><span class="main">}</span>
    <span class="main">∪</span> <span class="main">{</span>Atom <span class="main">(</span>Eq <span class="bound">a</span> <span class="bound">a</span><span class="main">)</span> <span class="main">|</span> <span class="bound">a</span><span class="main">.</span> True<span class="main">}</span> <span class="main">∪</span> <span class="main">{</span><span class="main"><span class="hidden">❙</span><b>¬</b></span><span class="main">(</span>Atom <span class="main">(</span>Eq <span class="bound">a</span> <span class="bound">b</span><span class="main">)</span><span class="main">)</span> <span class="main">|</span> <span class="bound">a</span> <span class="bound">b</span><span class="main">.</span> <span class="bound">a</span><span class="main">≠</span><span class="bound">b</span><span class="main">}</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">close_neg</span> <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="main">∪</span> <span class="main">{</span><span class="main"><span class="hidden">❙</span><b>¬</b></span><span class="main">(</span>Atom <span class="bound">a</span><span class="main">)</span> <span class="main">|</span> <span class="bound">a</span><span class="main">.</span> Atom <span class="bound">a</span> <span class="main">∉</span> <span class="free"><span class="bound"><span class="entity">M</span></span></span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"wm_basic <span class="free">M</span> <span class="main">⟹</span> close_world <span class="free">M</span> <span class="main">=</span> close_neg <span class="main">(</span><span class="free">M</span> <span class="main">∪</span> <span class="main">{</span>Atom <span class="main">(</span>Eq <span class="bound">a</span> <span class="bound">a</span><span class="main">)</span> <span class="main">|</span> <span class="bound">a</span><span class="main">.</span> True<span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> close_world_def close_neg_def wm_basic_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 0 3<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> atom.exhaust<span class="main">)</span>


  <span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">cw_entailment</span> <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1"><span class="hidden">⇧</span><sup>c</sup>⊫<span class="hidden">⇩</span><sub>=</sub></span>"</span> 53<span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="keyword1"><span class="free"><span class="hidden">⇧</span><sup>c</sup>⊫<span class="hidden">⇩</span><sub>=</sub></span></span> <span class="free"><span class="bound"><span class="entity">φ</span></span></span> <span class="main">≡</span> close_world <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="main">⊫</span> <span class="free"><span class="bound"><span class="entity">φ</span></span></span>"</span></span>


  <span class="keyword1" id="PDDL_STRIPS_Semantics-close_world_extensive"><span class="command">lemma</span></span>
    close_world_extensive<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">M</span> <span class="main">⊆</span> close_world <span class="free">M</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
    close_world_idem<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"close_world <span class="main">(</span>close_world <span class="free">M</span><span class="main">)</span> <span class="main">=</span> close_world <span class="free">M</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> close_world_def<span class="main">)</span>

  <span class="keyword1" id="PDDL_STRIPS_Semantics-in_close_world_conv"><span class="command">lemma</span></span> in_close_world_conv<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="free">φ</span> <span class="main">∈</span> close_world <span class="free">M</span> <span class="main">⟷</span> <span class="main">(</span>
        <span class="free">φ</span><span class="main">∈</span><span class="free">M</span>
      <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">p</span> <span class="bound">as</span><span class="main">.</span> <span class="free">φ</span><span class="main">=</span><span class="main"><span class="hidden">❙</span><b>¬</b></span><span class="main">(</span>Atom <span class="main">(</span>predAtm <span class="bound">p</span> <span class="bound">as</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> Atom <span class="main">(</span>predAtm <span class="bound">p</span> <span class="bound">as</span><span class="main">)</span><span class="main">∉</span><span class="free">M</span><span class="main">)</span>
      <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">a</span><span class="main">.</span> <span class="free">φ</span><span class="main">=</span>Atom <span class="main">(</span>Eq <span class="bound">a</span> <span class="bound">a</span><span class="main">)</span><span class="main">)</span>
      <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">a</span> <span class="bound">b</span><span class="main">.</span> <span class="free">φ</span><span class="main">=</span><span class="main"><span class="hidden">❙</span><b>¬</b></span><span class="main">(</span>Atom <span class="main">(</span>Eq <span class="bound">a</span> <span class="bound">b</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">a</span><span class="main">≠</span><span class="bound">b</span><span class="main">)</span>
    <span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> close_world_def<span class="main">)</span>

  <span class="keyword1" id="PDDL_STRIPS_Semantics-valuation_aux_1"><span class="command">lemma</span></span> valuation_aux_1<span class="main">:</span>
    <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">M</span> <span class="main">::</span> <span class="quoted">world_model</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">φ</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"object atom formula"</span></span>
    <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">C</span> <span class="main">≡</span> close_world <span class="free">M</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">φ</span><span class="main">∈</span><span class="free">C</span><span class="main">.</span> <span class="free">𝒜</span> <span class="main">⊨</span> <span class="bound">φ</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">𝒜</span> <span class="main">=</span> valuation <span class="free">M</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> A <span class="keyword1"><span class="command">unfolding</span></span> C_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_close_world_conv valuation_def Ball_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ext <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> atom.split<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> formula_semantics.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> formula_semantics.simps<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> formula_semantics.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> formula_semantics.simps<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> atom.collapse<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> formula_semantics.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> is_predAtm_def<span class="main">)</span>



  <span class="keyword1" id="PDDL_STRIPS_Semantics-valuation_aux_2"><span class="command">lemma</span></span> valuation_aux_2<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"wm_basic <span class="free">M</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">G</span><span class="main">∈</span>close_world <span class="free">M</span><span class="main">.</span> valuation <span class="free">M</span> <span class="main">⊨</span> <span class="bound">G</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> wm_basic_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_close_world_conv valuation_def <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> is_predAtom.elims<span class="main">)</span>

  <span class="keyword1" id="PDDL_STRIPS_Semantics-val_imp_close_world"><span class="command">lemma</span></span> val_imp_close_world<span class="main">:</span> <span class="quoted"><span class="quoted">"valuation <span class="free">M</span> <span class="main">⊨</span> <span class="free">φ</span> <span class="main">⟹</span> <span class="free">M</span> <span class="keyword1"><span class="hidden">⇧</span><sup>c</sup>⊫<span class="hidden">⇩</span><sub>=</sub></span> <span class="free">φ</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> entailment_def
    <span class="keyword1"><span class="command">using</span></span> valuation_aux_1
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

  <span class="keyword1" id="PDDL_STRIPS_Semantics-close_world_imp_val"><span class="command">lemma</span></span> close_world_imp_val<span class="main">:</span>
    <span class="quoted"><span class="quoted">"wm_basic <span class="free">M</span> <span class="main">⟹</span> <span class="free">M</span> <span class="keyword1"><span class="hidden">⇧</span><sup>c</sup>⊫<span class="hidden">⇩</span><sub>=</sub></span> <span class="free">φ</span> <span class="main">⟹</span> valuation <span class="free">M</span> <span class="main">⊨</span> <span class="free">φ</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> entailment_def <span class="keyword1"><span class="command">using</span></span> valuation_aux_2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Main theorem of this section:
    If a world model <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>M›</span></span></span></span> contains only atoms, its induced valuation
    satisfies a formula <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>φ›</span></span></span></span> if and only if the closure of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>M›</span></span></span></span> entails <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>φ›</span></span></span></span>.

    Note that there are no syntactic restrictions on <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>φ›</span></span></span></span>,
    in particular, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>φ›</span></span></span></span> may contain negation.
  ›</span></span>
  <span class="keyword1"><span class="command">theorem</span></span> valuation_iff_close_world<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"wm_basic <span class="free">M</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"valuation <span class="free">M</span> <span class="main">⊨</span> <span class="free">φ</span> <span class="main">⟷</span> <span class="free">M</span> <span class="keyword1"><span class="hidden">⇧</span><sup>c</sup>⊫<span class="hidden">⇩</span><sub>=</sub></span> <span class="free">φ</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms val_imp_close_world close_world_imp_val <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Proper Generalization›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Adding negation and equality is a proper generalization of the
  case without negation and equality›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">is_STRIPS_fmla</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'ent</span> atom formula <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">is_STRIPS_fmla</span> <span class="main">(</span>Atom <span class="main">(</span>predAtm <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> True"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">is_STRIPS_fmla</span> <span class="main">(</span><span class="main">⊥</span><span class="main">)</span> <span class="main">⟷</span> True"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">is_STRIPS_fmla</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">φ<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="main"><span class="hidden">❙</span><b>∧</b></span> <span class="free"><span class="bound"><span class="entity">φ<span class="hidden">⇩</span><sub>2</sub></span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="free">is_STRIPS_fmla</span> <span class="free"><span class="bound"><span class="entity">φ<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="main">∧</span> <span class="free">is_STRIPS_fmla</span> <span class="free"><span class="bound"><span class="entity">φ<span class="hidden">⇩</span><sub>2</sub></span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">is_STRIPS_fmla</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">φ<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="main"><span class="hidden">❙</span><b>∨</b></span> <span class="free"><span class="bound"><span class="entity">φ<span class="hidden">⇩</span><sub>2</sub></span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="free">is_STRIPS_fmla</span> <span class="free"><span class="bound"><span class="entity">φ<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="main">∧</span> <span class="free">is_STRIPS_fmla</span> <span class="free"><span class="bound"><span class="entity">φ<span class="hidden">⇩</span><sub>2</sub></span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">is_STRIPS_fmla</span> <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>¬</b></span><span class="main">⊥</span><span class="main">)</span> <span class="main">⟷</span> True"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">is_STRIPS_fmla</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">⟷</span> False"</span></span>

<span class="keyword1" id="PDDL_STRIPS_Semantics-aux1"><span class="command">lemma</span></span> aux1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>wm_basic <span class="free">M</span><span class="main">;</span> is_STRIPS_fmla <span class="free">φ</span><span class="main">;</span> valuation <span class="free">M</span> <span class="main">⊨</span> <span class="free">φ</span><span class="main">;</span> <span class="main">∀</span><span class="bound">G</span><span class="main">∈</span><span class="free">M</span><span class="main">.</span> <span class="free">𝒜</span> <span class="main">⊨</span> <span class="bound">G</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">𝒜</span> <span class="main">⊨</span> <span class="free">φ</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">φ</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> is_STRIPS_fmla.induct<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valuation_def<span class="main">)</span>

<span class="keyword1" id="PDDL_STRIPS_Semantics-aux2"><span class="command">lemma</span></span> aux2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>wm_basic <span class="free">M</span><span class="main">;</span> is_STRIPS_fmla <span class="free">φ</span><span class="main">;</span> <span class="main">∀</span><span class="bound">𝒜</span><span class="main">.</span> <span class="main">(</span><span class="main">∀</span><span class="bound">G</span><span class="main">∈</span><span class="free">M</span><span class="main">.</span> <span class="bound">𝒜</span> <span class="main">⊨</span> <span class="bound">G</span><span class="main">)</span> <span class="main">⟶</span> <span class="bound">𝒜</span> <span class="main">⊨</span> <span class="free">φ</span><span class="main">⟧</span> <span class="main">⟹</span> valuation <span class="free">M</span> <span class="main">⊨</span> <span class="free">φ</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">φ</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> is_STRIPS_fmla.induct<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> in_close_world_conv valuation_aux_2<span class="main">)</span>
  <span class="keyword1"><span class="command">using</span></span> in_close_world_conv valuation_aux_2 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">using</span></span> in_close_world_conv valuation_aux_2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>


<span class="keyword1" id="PDDL_STRIPS_Semantics-valuation_iff_STRIPS"><span class="command">lemma</span></span> valuation_iff_STRIPS<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"wm_basic <span class="free">M</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"is_STRIPS_fmla <span class="free">φ</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"valuation <span class="free">M</span> <span class="main">⊨</span> <span class="free">φ</span> <span class="main">⟷</span> <span class="free">M</span> <span class="main">⊫</span> <span class="free">φ</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> aux1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">𝒜</span><span class="main">.</span> <span class="main">⟦</span>valuation <span class="free">M</span> <span class="main">⊨</span> <span class="free">φ</span><span class="main">;</span> <span class="main">∀</span><span class="bound">G</span><span class="main">∈</span><span class="free">M</span><span class="main">.</span> <span class="bound">𝒜</span> <span class="main">⊨</span> <span class="bound">G</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="bound">𝒜</span> <span class="main">⊨</span> <span class="free">φ</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">φ</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> is_STRIPS_fmla.induct<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valuation_def<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> aux2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="main">∀</span><span class="bound">𝒜</span><span class="main">.</span> <span class="main">(</span><span class="main">∀</span><span class="bound">G</span><span class="main">∈</span><span class="free">M</span><span class="main">.</span> <span class="bound">𝒜</span> <span class="main">⊨</span> <span class="bound">G</span><span class="main">)</span> <span class="main">⟶</span> <span class="bound">𝒜</span> <span class="main">⊨</span> <span class="free">φ</span><span class="main">⟧</span> <span class="main">⟹</span> valuation <span class="free">M</span> <span class="main">⊨</span> <span class="free">φ</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">φ</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> is_STRIPS_fmla.induct<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> in_close_world_conv valuation_aux_2<span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> in_close_world_conv valuation_aux_2 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">using</span></span> in_close_world_conv valuation_aux_2 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> entailment_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> aux1 aux2<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Our extension to negation and equality is a proper generalization of the
  standard STRIPS semantics for formula without negation and equality›</span></span>
<span class="keyword1"><span class="command">theorem</span></span> proper_STRIPS_generalization<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>wm_basic <span class="free">M</span><span class="main">;</span> is_STRIPS_fmla <span class="free">φ</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">M</span> <span class="keyword1"><span class="hidden">⇧</span><sup>c</sup>⊫<span class="hidden">⇩</span><sub>=</sub></span> <span class="free">φ</span> <span class="main">⟷</span> <span class="free">M</span> <span class="main">⊫</span> <span class="free">φ</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> valuation_iff_close_world<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> valuation_iff_STRIPS<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹STRIPS Semantics›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹For this section, we fix a domain <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>D›</span></span></span></span>, using Isabelle's
  locale mechanism.›</span></span>
<span class="keyword1"><span class="command">locale</span></span> ast_domain <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">D</span> <span class="main">::</span> <span class="quoted">ast_domain</span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹It seems to be agreed upon that, in case of a contradictory effect,
    addition overrides deletion. We model this behaviour by first executing
    the deletions, and then the additions.›</span></span>
  <span class="keyword1"><span class="command">fun</span></span> <span class="entity">apply_effect</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"object ast_effect <span class="main">⇒</span> world_model <span class="main">⇒</span> world_model"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
     <span class="quoted"><span class="quoted">"<span class="free">apply_effect</span> <span class="main">(</span>Effect <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">d</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">-</span> set <span class="free"><span class="bound"><span class="entity">d</span></span></span><span class="main">)</span> <span class="main">∪</span> <span class="main">(</span>set <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Execute a ground action›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">execute_ground_action</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"ground_action <span class="main">⇒</span> world_model <span class="main">⇒</span> world_model"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">execute_ground_action</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="main">=</span> apply_effect <span class="main">(</span>effect <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">M</span></span></span>"</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Predicate to model that the given list of action instances is
    executable, and transforms an initial world model <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>M›</span></span></span></span> into a final
    model <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>M'›</span></span></span></span>.

    Note that this definition over the list structure is more convenient in HOL
    than to explicitly define an indexed sequence <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>M<span class="hidden">⇩</span><sub>0</sub>…M<span class="hidden">⇩</span><sub>N</sub>›</span></span></span></span> of intermediate world
     models, as done in [Lif87].
  ›</span></span>
  <span class="keyword1"><span class="command">fun</span></span> <span class="entity">ground_action_path</span>
    <span class="main">::</span> <span class="quoted"><span class="quoted">"world_model <span class="main">⇒</span> ground_action list <span class="main">⇒</span> world_model <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">ground_action_path</span> <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="main">[]</span> <span class="free"><span class="bound"><span class="entity">M'</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">M'</span></span></span><span class="main">)</span>"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ground_action_path</span> <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">α</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">αs</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">M'</span></span></span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="keyword1"><span class="hidden">⇧</span><sup>c</sup>⊫<span class="hidden">⇩</span><sub>=</sub></span> precondition <span class="free"><span class="bound"><span class="entity">α</span></span></span>
    <span class="main">∧</span> <span class="free">ground_action_path</span> <span class="main">(</span>execute_ground_action <span class="free"><span class="bound"><span class="entity">α</span></span></span> <span class="free"><span class="bound"><span class="entity">M</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">αs</span></span></span> <span class="free"><span class="bound"><span class="entity">M'</span></span></span>"</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Function equations as presented in paper,
    with inlined <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> execute_ground_action<span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>
  <span class="keyword1" id="PDDL_STRIPS_Semantics-ground_action_path_in_paper"><span class="command">lemma</span></span> ground_action_path_in_paper<span class="main">:</span>
    <span class="quoted"><span class="quoted">"ground_action_path <span class="free">M</span> <span class="main">[]</span> <span class="free">M'</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">M</span> <span class="main">=</span> <span class="free">M'</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"ground_action_path <span class="free">M</span> <span class="main">(</span><span class="free">α</span><span class="main">#</span><span class="free">αs</span><span class="main">)</span> <span class="free">M'</span> <span class="main">⟷</span> <span class="free">M</span> <span class="keyword1"><span class="hidden">⇧</span><sup>c</sup>⊫<span class="hidden">⇩</span><sub>=</sub></span> precondition <span class="free">α</span>
    <span class="main">∧</span> <span class="main">(</span>ground_action_path <span class="main">(</span>apply_effect <span class="main">(</span>effect <span class="free">α</span><span class="main">)</span> <span class="free">M</span><span class="main">)</span> <span class="free">αs</span> <span class="free">M'</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> execute_ground_action_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Context of <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>ast_domain›</span></span>›</span>



<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Well-Formedness of PDDL›</span></span>

<span class="comment1">(* Well-formedness *)</span>

<span class="comment1">(*
  Compute signature: predicate/arity
  Check that all atoms (schemas and facts) satisfy signature

  for action:
    Check that used parameters ⊆ declared parameters

  for init/goal: Check that facts only use declared objects
*)</span>


<span class="keyword1"><span class="command">fun</span></span> <span class="entity">ty_term</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ty_term</span> <span class="free"><span class="bound"><span class="entity">varT</span></span></span> <span class="free"><span class="bound"><span class="entity">objT</span></span></span> <span class="main">(</span>term.VAR <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">varT</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ty_term</span> <span class="free"><span class="bound"><span class="entity">varT</span></span></span> <span class="free"><span class="bound"><span class="entity">objT</span></span></span> <span class="main">(</span>term.CONST <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">objT</span></span></span> <span class="free"><span class="bound"><span class="entity">c</span></span></span>"</span></span>


<span class="keyword1" id="PDDL_STRIPS_Semantics-ty_term_mono"><span class="command">lemma</span></span> ty_term_mono<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">varT</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> <span class="free">varT'</span> <span class="main">⟹</span> <span class="free">objT</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> <span class="free">objT'</span> <span class="main">⟹</span>
  ty_term <span class="free">varT</span> <span class="free">objT</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> ty_term <span class="free">varT'</span> <span class="free">objT'</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> map_leI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> x v
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> map_leD<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">context</span></span> ast_domain <span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The signature is a partial function that maps the predicates
    of the domain to lists of argument types.›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">sig</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"predicate <span class="main">⇀</span> type list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">sig</span> <span class="main">≡</span> map_of <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span>PredDecl <span class="bound">p</span> <span class="bound">n</span> <span class="main">⇒</span> <span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">n</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>predicates <span class="free">D</span><span class="main">)</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We use a flat subtype hierarchy, where every type is a subtype
    of object, and there are no other subtype relations.

    Note that we do not need to restrict this relation to declared types,
    as we will explicitly ensure that all types used in the problem are
    declared.
    ›</span></span>

  <span class="keyword1"><span class="command">fun</span></span> <span class="entity">subtype_edge</span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">subtype_edge</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">ty</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">superty</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">superty</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">ty</span></span></span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">subtype_rel</span> <span class="main">≡</span> set <span class="main">(</span>map subtype_edge <span class="main">(</span>types <span class="free">D</span><span class="main">)</span><span class="main">)</span>"</span></span>

  <span class="comment1">(*
  definition "subtype_rel ≡ {''object''}×UNIV"
  *)</span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">of_type</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"type <span class="main">⇒</span> type <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">of_type</span> <span class="free"><span class="bound"><span class="entity">oT</span></span></span> <span class="free"><span class="bound"><span class="entity">T</span></span></span> <span class="main">≡</span> set <span class="main">(</span>primitives <span class="free"><span class="bound"><span class="entity">oT</span></span></span><span class="main">)</span> <span class="main">⊆</span> subtype_rel<span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> set <span class="main">(</span>primitives <span class="free"><span class="bound"><span class="entity">T</span></span></span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This checks that every primitive on the LHS is contained in or a
    subtype of a primitive on the RHS›</span></span>


  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹For the next few definitions, we fix a partial function that maps
    a polymorphic entity type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'e</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to types. An entity can be
    instantiated by variables or objects later.›</span></span>
  <span class="keyword1"><span class="command">context</span></span>
    <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">ty_ent</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'ent</span> <span class="main">⇀</span> type"</span></span>  <span class="comment1">― ‹Entity's type, None if invalid›</span>
  <span class="keyword2"><span class="keyword">begin</span></span>

    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Checks whether an entity has a given type›</span></span>
    <span class="keyword1"><span class="command">definition</span></span> <span class="entity">is_of_type</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'ent</span> <span class="main">⇒</span> type <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
      <span class="quoted"><span class="quoted">"<span class="free">is_of_type</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">T</span></span></span> <span class="main">⟷</span> <span class="main">(</span>
        <span class="keyword1">case</span> <span class="free">ty_ent</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="keyword1">of</span>
          Some <span class="bound">vT</span> <span class="main">⇒</span> of_type <span class="bound">vT</span> <span class="free"><span class="bound"><span class="entity">T</span></span></span>
        <span class="main">|</span> None <span class="main">⇒</span> False<span class="main">)</span>"</span></span>

    <span class="keyword1"><span class="command">fun</span></span> <span class="entity">wf_pred_atom</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"predicate <span class="main">×</span> <span class="tfree">'ent</span> list <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
      <span class="quoted"><span class="quoted">"<span class="free">wf_pred_atom</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span>
        <span class="keyword1">case</span> sig <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="keyword1">of</span>
          None <span class="main">⇒</span> False
        <span class="main">|</span> Some <span class="bound">Ts</span> <span class="main">⇒</span> list_all2 is_of_type <span class="free"><span class="bound"><span class="entity">vs</span></span></span> <span class="bound">Ts</span><span class="main">)</span>"</span></span>

    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Predicate-atoms are well-formed if their arguments match the
      signature, equalities are well-formed if the arguments are valid
      objects (have a type).

      TODO: We could check that types may actually overlap
    ›</span></span>
    <span class="keyword1"><span class="command">fun</span></span> <span class="entity">wf_atom</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'ent</span> atom <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
      <span class="quoted"><span class="quoted">"<span class="free">wf_atom</span> <span class="main">(</span>predAtm <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">)</span> <span class="main">⟷</span> wf_pred_atom <span class="main">(</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">)</span>"</span></span>
    <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">wf_atom</span> <span class="main">(</span>Eq <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="free">ty_ent</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">≠</span> None <span class="main">∧</span> <span class="free">ty_ent</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">≠</span> None"</span></span>

    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A formula is well-formed if it consists of valid atoms,
      and does not contain negations, except for the encoding <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span><span class="hidden">❙</span><b>¬</b>⊥›</span></span></span></span> of true.
    ›</span></span>
    <span class="keyword1"><span class="command">fun</span></span> <span class="entity">wf_fmla</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'ent</span> atom<span class="main">)</span> formula <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
      <span class="quoted"><span class="quoted">"<span class="free">wf_fmla</span> <span class="main">(</span>Atom <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span> <span class="main">⟷</span> wf_atom <span class="free"><span class="bound"><span class="entity">a</span></span></span>"</span></span>
    <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">wf_fmla</span> <span class="main">(</span><span class="main">⊥</span><span class="main">)</span> <span class="main">⟷</span> True"</span></span>
    <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">wf_fmla</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">φ1</span></span></span> <span class="main"><span class="hidden">❙</span><b>∧</b></span> <span class="free"><span class="bound"><span class="entity">φ2</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">wf_fmla</span> <span class="free"><span class="bound"><span class="entity">φ1</span></span></span> <span class="main">∧</span> <span class="free">wf_fmla</span> <span class="free"><span class="bound"><span class="entity">φ2</span></span></span><span class="main">)</span>"</span></span>
    <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">wf_fmla</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">φ1</span></span></span> <span class="main"><span class="hidden">❙</span><b>∨</b></span> <span class="free"><span class="bound"><span class="entity">φ2</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">wf_fmla</span> <span class="free"><span class="bound"><span class="entity">φ1</span></span></span> <span class="main">∧</span> <span class="free">wf_fmla</span> <span class="free"><span class="bound"><span class="entity">φ2</span></span></span><span class="main">)</span>"</span></span>
    <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">wf_fmla</span> <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>¬</b></span><span class="free"><span class="bound"><span class="entity">φ</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="free">wf_fmla</span> <span class="free"><span class="bound"><span class="entity">φ</span></span></span>"</span></span>
    <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">wf_fmla</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">φ1</span></span></span> <span class="main"><span class="hidden">❙</span><b>→</b></span> <span class="free"><span class="bound"><span class="entity">φ2</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">wf_fmla</span> <span class="free"><span class="bound"><span class="entity">φ1</span></span></span> <span class="main">∧</span> <span class="free">wf_fmla</span> <span class="free"><span class="bound"><span class="entity">φ2</span></span></span><span class="main">)</span>"</span></span>

    <span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"wf_fmla <span class="free">φ</span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">a</span><span class="main">∈</span>atoms <span class="free">φ</span><span class="main">.</span> wf_atom <span class="bound">a</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">φ</span></span><span class="main">)</span> <span class="operator">auto</span>

    <span class="comment1">(*lemma wf_fmla_add_simps[simp]: "wf_fmla (<span class="hidden">❙</span><b>¬</b>φ) ⟷ φ=⊥"
      by (cases φ) auto*)</span>

    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Special case for a well-formed atomic predicate formula›</span></span>
    <span class="keyword1"><span class="command">fun</span></span> <span class="entity">wf_fmla_atom</span> <span class="keyword2"><span class="keyword">where</span></span>
      <span class="quoted"><span class="quoted">"<span class="free">wf_fmla_atom</span> <span class="main">(</span>Atom <span class="main">(</span>predAtm <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> wf_pred_atom <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">)</span>"</span></span>
    <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">wf_fmla_atom</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">⟷</span> False"</span></span>

    <span class="keyword1" id="PDDL_STRIPS_Semantics-wf_fmla_atom_alt"><span class="command">lemma</span></span> wf_fmla_atom_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"wf_fmla_atom <span class="free">φ</span> <span class="main">⟷</span> is_predAtom <span class="free">φ</span> <span class="main">∧</span> wf_fmla <span class="free">φ</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">φ</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> wf_fmla_atom.cases<span class="main">)</span> <span class="operator">auto</span>

    <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹An effect is well-formed if the added and removed formulas
      are atomic›</span></span>
    <span class="keyword1"><span class="command">fun</span></span> <span class="entity">wf_effect</span> <span class="keyword2"><span class="keyword">where</span></span>
      <span class="quoted"><span class="quoted">"<span class="free">wf_effect</span> <span class="main">(</span>Effect <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">d</span></span></span><span class="main">)</span> <span class="main">⟷</span>
          <span class="main">(</span><span class="main">∀</span><span class="bound">ae</span><span class="main">∈</span>set <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">.</span> wf_fmla_atom <span class="bound">ae</span><span class="main">)</span>
        <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">de</span><span class="main">∈</span>set <span class="free"><span class="bound"><span class="entity">d</span></span></span><span class="main">.</span>  wf_fmla_atom <span class="bound">de</span><span class="main">)</span>"</span></span>

  <span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Context fixing <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>ty_ent›</span></span>›</span>


  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">constT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"object <span class="main">⇀</span> type"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">constT</span> <span class="main">≡</span> map_of <span class="main">(</span>consts <span class="free">D</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹An action schema is well-formed if the parameter names are distinct,
    and the precondition and effect is well-formed wrt.\ the parameters.
  ›</span></span>
  <span class="keyword1"><span class="command">fun</span></span> <span class="entity">wf_action_schema</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"ast_action_schema <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">wf_action_schema</span> <span class="main">(</span>Action_Schema <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">params</span></span></span> <span class="free"><span class="bound"><span class="entity">pre</span></span></span> <span class="free"><span class="bound"><span class="entity">eff</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span>
      <span class="keyword1">let</span>
        <span class="bound">tyt</span> <span class="main">=</span> ty_term <span class="main">(</span>map_of <span class="free"><span class="bound"><span class="entity">params</span></span></span><span class="main">)</span> constT
      <span class="keyword1">in</span>
        distinct <span class="main">(</span>map fst <span class="free"><span class="bound"><span class="entity">params</span></span></span><span class="main">)</span>
      <span class="main">∧</span> wf_fmla <span class="bound">tyt</span> <span class="free"><span class="bound"><span class="entity">pre</span></span></span>
      <span class="main">∧</span> wf_effect <span class="bound">tyt</span> <span class="free"><span class="bound"><span class="entity">eff</span></span></span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A type is well-formed if it consists only of declared primitive types,
     and the type object.›</span></span>
  <span class="keyword1"><span class="command">fun</span></span> <span class="entity">wf_type</span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">wf_type</span> <span class="main">(</span>Either <span class="free"><span class="bound"><span class="entity">Ts</span></span></span><span class="main">)</span> <span class="main">⟷</span> set <span class="free"><span class="bound"><span class="entity">Ts</span></span></span> <span class="main">⊆</span> insert <span class="inner_quoted">''object''</span> <span class="main">(</span>fst<span class="main">`</span>set <span class="main">(</span>types <span class="free">D</span><span class="main">)</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A predicate is well-formed if its argument types are well-formed.›</span></span>
  <span class="keyword1"><span class="command">fun</span></span> <span class="entity">wf_predicate_decl</span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">wf_predicate_decl</span> <span class="main">(</span>PredDecl <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">Ts</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">T</span><span class="main">∈</span>set <span class="free"><span class="bound"><span class="entity">Ts</span></span></span><span class="main">.</span> wf_type <span class="bound">T</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The types declaration is well-formed, if all supertypes are declared types (or object)›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">wf_types</span> <span class="main">≡</span> snd<span class="main">`</span>set <span class="main">(</span>types <span class="free">D</span><span class="main">)</span> <span class="main">⊆</span> insert <span class="inner_quoted">''object''</span> <span class="main">(</span>fst<span class="main">`</span>set <span class="main">(</span>types <span class="free">D</span><span class="main">)</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A domain is well-formed if
    <span class="antiquoted"><span class="antiquoted">▪</span></span> there are no duplicate declared predicate names,
    <span class="antiquoted"><span class="antiquoted">▪</span></span> all declared predicates are well-formed,
    <span class="antiquoted"><span class="antiquoted">▪</span></span> there are no duplicate action names,
    <span class="antiquoted"><span class="antiquoted">▪</span></span> and all declared actions are well-formed
    ›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">wf_domain</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">wf_domain</span> <span class="main">≡</span>
      wf_types
    <span class="main">∧</span> distinct <span class="main">(</span>map <span class="main">(</span>predicate_decl.pred<span class="main">)</span> <span class="main">(</span>predicates <span class="free">D</span><span class="main">)</span><span class="main">)</span>
    <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">p</span><span class="main">∈</span>set <span class="main">(</span>predicates <span class="free">D</span><span class="main">)</span><span class="main">.</span> wf_predicate_decl <span class="bound">p</span><span class="main">)</span>
    <span class="main">∧</span> distinct <span class="main">(</span>map fst <span class="main">(</span>consts <span class="free">D</span><span class="main">)</span><span class="main">)</span>
    <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="main">(</span><span class="bound">n</span><span class="main">,</span><span class="bound">T</span><span class="main">)</span><span class="main">∈</span>set <span class="main">(</span>consts <span class="free">D</span><span class="main">)</span><span class="main">.</span> wf_type <span class="bound">T</span><span class="main">)</span>
    <span class="main">∧</span> distinct <span class="main">(</span>map ast_action_schema.name <span class="main">(</span>actions <span class="free">D</span><span class="main">)</span><span class="main">)</span>
    <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">a</span><span class="main">∈</span>set <span class="main">(</span>actions <span class="free">D</span><span class="main">)</span><span class="main">.</span> wf_action_schema <span class="bound">a</span><span class="main">)</span>
    "</span></span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹locale <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>ast_domain›</span></span>›</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We fix a problem, and also include the definitions for the domain
  of this problem.›</span></span>
<span class="keyword1"><span class="command">locale</span></span> ast_problem <span class="main">=</span> ast_domain <span class="quoted"><span class="quoted">"domain <span class="free">P</span>"</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">P</span> <span class="main">::</span> <span class="quoted">ast_problem</span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We refer to the problem domain as <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>D›</span></span></span></span>›</span></span>
  <span class="keyword1"><span class="command">abbreviation</span></span> <span class="quoted"><span class="quoted">"<span class="free">D</span> <span class="main">≡</span> ast_problem.domain <span class="free">P</span>"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">objT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"object <span class="main">⇀</span> type"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">objT</span> <span class="main">≡</span> map_of <span class="main">(</span>objects <span class="free">P</span><span class="main">)</span> <span class="main">++</span> constT"</span></span>

  <span class="keyword1" id="PDDL_STRIPS_Semantics-objT_alt"><span class="command">lemma</span></span> objT_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"objT <span class="main">=</span> map_of <span class="main">(</span>consts D <span class="main">@</span> objects <span class="free">P</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> objT_def constT_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">wf_fact</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"fact <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">wf_fact</span> <span class="main">=</span> wf_pred_atom objT"</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This definition is needed for well-formedness of the initial model,
    and forward-references to the concept of world model.
  ›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">wf_world_model</span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">wf_world_model</span> <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span><span class="bound">f</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">M</span></span></span><span class="main">.</span> wf_fmla_atom objT <span class="bound">f</span><span class="main">)</span>"</span></span>

  <span class="comment1">(*Note: current semantics assigns each object a unique type *)</span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">wf_problem</span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">wf_problem</span> <span class="main">≡</span>
      wf_domain
    <span class="main">∧</span> distinct <span class="main">(</span>map fst <span class="main">(</span>objects <span class="free">P</span><span class="main">)</span> <span class="main">@</span> map fst <span class="main">(</span>consts D<span class="main">)</span><span class="main">)</span>
    <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="main">(</span><span class="bound">n</span><span class="main">,</span><span class="bound">T</span><span class="main">)</span><span class="main">∈</span>set <span class="main">(</span>objects <span class="free">P</span><span class="main">)</span><span class="main">.</span> wf_type <span class="bound">T</span><span class="main">)</span>
    <span class="main">∧</span> distinct <span class="main">(</span>init <span class="free">P</span><span class="main">)</span>
    <span class="main">∧</span> wf_world_model <span class="main">(</span>set <span class="main">(</span>init <span class="free">P</span><span class="main">)</span><span class="main">)</span>
    <span class="main">∧</span> wf_fmla objT <span class="main">(</span>goal <span class="free">P</span><span class="main">)</span>
    "</span></span>

  <span class="keyword1"><span class="command">fun</span></span> <span class="entity">wf_effect_inst</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"object ast_effect <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">wf_effect_inst</span> <span class="main">(</span>Effect <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">d</span></span></span><span class="main">)</span><span class="main">)</span>
      <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">a</span><span class="main">∈</span>set <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">∪</span> set <span class="free"><span class="bound"><span class="entity">d</span></span></span><span class="main">.</span> wf_fmla_atom objT <span class="bound">a</span><span class="main">)</span>"</span></span>

  <span class="keyword1" id="PDDL_STRIPS_Semantics-wf_effect_inst_alt"><span class="command">lemma</span></span> wf_effect_inst_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"wf_effect_inst <span class="free">eff</span> <span class="main">=</span> wf_effect objT <span class="free">eff</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">eff</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹locale <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>ast_problem›</span></span>›</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Locale to express a well-formed domain›</span></span>
<span class="keyword1"><span class="command">locale</span></span> wf_ast_domain <span class="main">=</span> ast_domain <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> wf_domain<span class="main">:</span> <span class="quoted">wf_domain</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Locale to express a well-formed problem›</span></span>
<span class="keyword1"><span class="command">locale</span></span> wf_ast_problem <span class="main">=</span> ast_problem <span class="quoted"><span class="free">P</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">P</span> <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> wf_problem<span class="main">:</span> <span class="quoted">wf_problem</span>
<span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">sublocale</span></span> wf_ast_domain <span class="quoted"><span class="quoted">"domain <span class="free">P</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
    <span class="keyword1"><span class="command">using</span></span> wf_problem
    <span class="keyword1"><span class="command">unfolding</span></span> wf_problem_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹locale <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>wf_ast_problem›</span></span>›</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹PDDL Semantics›</span></span>

<span class="comment1">(* Semantics *)</span>

<span class="comment1">(*  To apply plan_action:
    find action schema, instantiate, check precond, apply effect
*)</span>



<span class="keyword1"><span class="command">context</span></span> ast_domain <span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">resolve_action_schema</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"name <span class="main">⇀</span> ast_action_schema"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">resolve_action_schema</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> index_by ast_action_schema.name <span class="main">(</span>actions <span class="free">D</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span>"</span></span>

  <span class="keyword1"><span class="command">fun</span></span> <span class="entity">subst_term</span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">subst_term</span> <span class="free"><span class="bound"><span class="entity">psubst</span></span></span> <span class="main">(</span>term.VAR <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">psubst</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">subst_term</span> <span class="free"><span class="bound"><span class="entity">psubst</span></span></span> <span class="main">(</span>term.CONST <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">c</span></span></span>"</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹To instantiate an action schema, we first compute a substitution from
    parameters to objects, and then apply this substitution to the
    precondition and effect. The substitution is applied via the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>map_xxx›</span></span></span></span>
    functions generated by the datatype package.
    ›</span></span>
  <span class="keyword1"><span class="command">fun</span></span> <span class="entity">instantiate_action_schema</span>
    <span class="main">::</span> <span class="quoted"><span class="quoted">"ast_action_schema <span class="main">⇒</span> object list <span class="main">⇒</span> ground_action"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">instantiate_action_schema</span> <span class="main">(</span>Action_Schema <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">params</span></span></span> <span class="free"><span class="bound"><span class="entity">pre</span></span></span> <span class="free"><span class="bound"><span class="entity">eff</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">args</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span>
        <span class="bound">tsubst</span> <span class="main">=</span> subst_term <span class="main">(</span>the <span class="keyword1">o</span> <span class="main">(</span>map_of <span class="main">(</span>zip <span class="main">(</span>map fst <span class="free"><span class="bound"><span class="entity">params</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">args</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
        <span class="bound">pre_inst</span> <span class="main">=</span> <span class="main">(</span>map_formula <span class="keyword1">o</span> map_atom<span class="main">)</span> <span class="bound">tsubst</span> <span class="free"><span class="bound"><span class="entity">pre</span></span></span><span class="main">;</span>
        <span class="bound">eff_inst</span> <span class="main">=</span> <span class="main">(</span>map_ast_effect<span class="main">)</span> <span class="bound">tsubst</span> <span class="free"><span class="bound"><span class="entity">eff</span></span></span>
      <span class="keyword1">in</span>
        Ground_Action <span class="bound">pre_inst</span> <span class="bound">eff_inst</span>
      <span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Context of <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>ast_domain›</span></span>›</span>


<span class="keyword1"><span class="command">context</span></span> ast_problem <span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Initial model›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">I</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"world_model"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">I</span> <span class="main">≡</span> set <span class="main">(</span>init <span class="free">P</span><span class="main">)</span>"</span></span>


  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Resolve a plan action and instantiate the referenced action schema.›</span></span>
  <span class="keyword1"><span class="command">fun</span></span> <span class="entity">resolve_instantiate</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"plan_action <span class="main">⇒</span> ground_action"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">resolve_instantiate</span> <span class="main">(</span>PAction <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">args</span></span></span><span class="main">)</span> <span class="main">=</span>
      instantiate_action_schema
        <span class="main">(</span>the <span class="main">(</span>resolve_action_schema <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span><span class="main">)</span>
        <span class="free"><span class="bound"><span class="entity">args</span></span></span>"</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Check whether object has specified type›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">is_obj_of_type</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">T</span></span></span> <span class="main">≡</span> <span class="keyword1">case</span> objT <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">of</span>
    None <span class="main">⇒</span> False
  <span class="main">|</span> Some <span class="bound">oT</span> <span class="main">⇒</span> of_type <span class="bound">oT</span> <span class="free"><span class="bound"><span class="entity">T</span></span></span>"</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We can also use the generic <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>is_of_type›</span></span></span></span> function.›</span></span>
  <span class="keyword1" id="PDDL_STRIPS_Semantics-is_obj_of_type_alt"><span class="command">lemma</span></span> is_obj_of_type_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"is_obj_of_type <span class="main">=</span> is_of_type objT"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> ext<span class="main">)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> is_obj_of_type_def is_of_type_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>


  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹HOL encoding of matching an action's formal parameters against an
    argument list.
    The parameters of the action are encoded as a list of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>name×type›</span></span></span></span> pairs,
    such that we map it to a list of types first. Then, the list
    relator <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> list_all2<span class="antiquote"><span class="antiquote">}</span></span></span></span> checks that arguments and types have the same
    length, and each matching pair of argument and type
    satisfies the predicate <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> is_obj_of_type<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  ›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">action_params_match</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">args</span></span></span>
    <span class="main">≡</span> list_all2 is_obj_of_type <span class="free"><span class="bound"><span class="entity">args</span></span></span> <span class="main">(</span>map snd <span class="main">(</span>parameters <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹At this point, we can define well-formedness of a plan action:
    The action must refer to a declared action schema, the arguments must
    be compatible with the formal parameters' types.
  ›</span></span>
 <span class="comment1">(* Objects are valid and match parameter types *)</span>
  <span class="keyword1"><span class="command">fun</span></span> <span class="entity">wf_plan_action</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"plan_action <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">wf_plan_action</span> <span class="main">(</span>PAction <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">args</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>
      <span class="keyword1">case</span> resolve_action_schema <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">of</span>
        None <span class="main">⇒</span> False
      <span class="main">|</span> Some <span class="bound">a</span> <span class="main">⇒</span>
          action_params_match <span class="bound">a</span> <span class="free"><span class="bound"><span class="entity">args</span></span></span>
        <span class="main">∧</span> wf_effect_inst <span class="main">(</span>effect <span class="main">(</span>instantiate_action_schema <span class="bound">a</span> <span class="free"><span class="bound"><span class="entity">args</span></span></span><span class="main">)</span><span class="main">)</span>
        <span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
    TODO: The second conjunct is redundant, as instantiating a well formed
      action with valid objects yield a valid effect.
  ›</span></span>



  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A sequence of plan actions form a path, if they are well-formed and
    their instantiations form a path.›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">plan_action_path</span>
    <span class="main">::</span> <span class="quoted"><span class="quoted">"world_model <span class="main">⇒</span> plan_action list <span class="main">⇒</span> world_model <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">plan_action_path</span> <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="free"><span class="bound"><span class="entity">πs</span></span></span> <span class="free"><span class="bound"><span class="entity">M'</span></span></span> <span class="main">=</span>
        <span class="main">(</span><span class="main">(</span><span class="main">∀</span><span class="bound">π</span> <span class="main">∈</span> set <span class="free"><span class="bound"><span class="entity">πs</span></span></span><span class="main">.</span> wf_plan_action <span class="bound">π</span><span class="main">)</span>
      <span class="main">∧</span> ground_action_path <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="main">(</span>map resolve_instantiate <span class="free"><span class="bound"><span class="entity">πs</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">M'</span></span></span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹A plan is valid wrt.\ a given initial model, if it forms a path to a
    goal model ›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">valid_plan_from</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"world_model <span class="main">⇒</span> plan <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">valid_plan_from</span> <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="free"><span class="bound"><span class="entity">πs</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">∃</span><span class="bound">M'</span><span class="main">.</span> plan_action_path <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="free"><span class="bound"><span class="entity">πs</span></span></span> <span class="bound">M'</span> <span class="main">∧</span> <span class="bound">M'</span> <span class="keyword1"><span class="hidden">⇧</span><sup>c</sup>⊫<span class="hidden">⇩</span><sub>=</sub></span> <span class="main">(</span>goal <span class="free">P</span><span class="main">)</span><span class="main">)</span>"</span></span>

  <span class="comment1">(* Implementation note: resolve and instantiate already done inside
      enabledness check, redundancy! *)</span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Finally, a plan is valid if it is valid wrt.\ the initial world
    model <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> I<span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">valid_plan</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"plan <span class="main">⇒</span> bool"</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">valid_plan</span> <span class="main">≡</span> valid_plan_from I"</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Concise definition used in paper:›</span></span>
  <span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"valid_plan <span class="free">πs</span> <span class="main">≡</span> <span class="main">∃</span><span class="bound">M'</span><span class="main">.</span> plan_action_path I <span class="free">πs</span> <span class="bound">M'</span> <span class="main">∧</span> <span class="bound">M'</span> <span class="keyword1"><span class="hidden">⇧</span><sup>c</sup>⊫<span class="hidden">⇩</span><sub>=</sub></span> <span class="main">(</span>goal <span class="free">P</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> valid_plan_def valid_plan_from_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>


<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Context of <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>ast_problem›</span></span>›</span>



<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Preservation of Well-Formedness›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Well-Formed Action Instances›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The goal of this section is to establish that well-formedness of
  world models is preserved by execution of well-formed plan actions.
›</span></span>

<span class="keyword1"><span class="command">context</span></span> ast_problem <span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹As plan actions are executed by first instantiating them, and then
    executing the action instance, it is natural to define a well-formedness
    concept for action instances.›</span></span>

  <span class="keyword1"><span class="command">fun</span></span> <span class="entity">wf_ground_action</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"ground_action <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">wf_ground_action</span> <span class="main">(</span>Ground_Action <span class="free"><span class="bound"><span class="entity">pre</span></span></span> <span class="free"><span class="bound"><span class="entity">eff</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span>
        wf_fmla objT <span class="free"><span class="bound"><span class="entity">pre</span></span></span>
      <span class="main">∧</span> wf_effect objT <span class="free"><span class="bound"><span class="entity">eff</span></span></span>
      <span class="main">)</span>
    "</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We first prove that instantiating a well-formed action schema will yield
    a well-formed action instance.

    We begin with some auxiliary lemmas before the actual theorem.
  ›</span></span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> ast_domain<span class="main">)</span> of_type_refl<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"of_type <span class="free">T</span> <span class="free">T</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> of_type_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> ast_domain<span class="main">)</span> of_type_trans<span class="main">[</span><span class="operator">trans</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"of_type <span class="free">T1</span> <span class="free">T2</span> <span class="main">⟹</span> of_type <span class="free">T2</span> <span class="free">T3</span> <span class="main">⟹</span> of_type <span class="free">T1</span> <span class="free">T3</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> of_type_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> hide_lams<span class="main"><span class="main">)</span></span>
      Image_mono contra_subsetD order_refl rtrancl_image_idem<span class="main">)</span>

  <span class="keyword1" id="PDDL_STRIPS_Semantics-is_of_type_map_ofE"><span class="command">lemma</span></span> is_of_type_map_ofE<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"is_of_type <span class="main">(</span>map_of <span class="free">params</span><span class="main">)</span> <span class="free">x</span> <span class="free">T</span>"</span></span>
    <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">i</span> <span class="free">xT</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span><span class="main">&lt;</span>length <span class="free">params</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">params</span><span class="main">!</span><span class="free">i</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">xT</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"of_type <span class="free">xT</span> <span class="free">T</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">unfolding</span></span> is_of_type_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> map_of_SomeD <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_set_conv_nth<span class="main">)</span>

  <span class="keyword1" id="PDDL_STRIPS_Semantics-wf_atom_mono"><span class="command">lemma</span></span> wf_atom_mono<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> SS<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">tys</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> <span class="free">tys'</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> WF<span class="main">:</span> <span class="quoted"><span class="quoted">"wf_atom <span class="free">tys</span> <span class="free">a</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"wf_atom <span class="free">tys'</span> <span class="free">a</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"list_all2 <span class="main">(</span>is_of_type <span class="free">tys'</span><span class="main">)</span> <span class="skolem">xs</span> <span class="skolem">Ts</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"list_all2 <span class="main">(</span>is_of_type <span class="free">tys</span><span class="main">)</span> <span class="skolem">xs</span> <span class="skolem">Ts</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">xs</span> <span class="skolem">Ts</span>
      <span class="keyword1"><span class="command">using</span></span> that
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">induction</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> is_of_type_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> map_leD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> SS<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> WF <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">a</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> map_leD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> SS<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1" id="PDDL_STRIPS_Semantics-wf_fmla_atom_mono"><span class="command">lemma</span></span> wf_fmla_atom_mono<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> SS<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">tys</span> <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> <span class="free">tys'</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> WF<span class="main">:</span> <span class="quoted"><span class="quoted">"wf_fmla_atom <span class="free">tys</span> <span class="free">a</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"wf_fmla_atom <span class="free">tys'</span> <span class="free">a</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"list_all2 <span class="main">(</span>is_of_type <span class="free">tys'</span><span class="main">)</span> <span class="skolem">xs</span> <span class="skolem">Ts</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"list_all2 <span class="main">(</span>is_of_type <span class="free">tys</span><span class="main">)</span> <span class="skolem">xs</span> <span class="skolem">Ts</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">xs</span> <span class="skolem">Ts</span>
      <span class="keyword1"><span class="command">using</span></span> that
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">induction</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> is_of_type_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> map_leD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> SS<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> WF <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">a</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> wf_fmla_atom.cases<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> map_leD<span class="main"><span class="main">[</span></span><span class="operator">OF</span> SS<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>


  <span class="keyword1" id="PDDL_STRIPS_Semantics-constT_ss_objT"><span class="command">lemma</span></span> constT_ss_objT<span class="main">:</span> <span class="quoted"><span class="quoted">"constT <span class="keyword1">⊆<span class="hidden">⇩</span><sub>m</sub></span> objT"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> constT_def objT_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">rule</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> map_add_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

  <span class="keyword1" id="PDDL_STRIPS_Semantics-wf_atom_constT_imp_objT"><span class="command">lemma</span></span> wf_atom_constT_imp_objT<span class="main">:</span> <span class="quoted"><span class="quoted">"wf_atom <span class="main">(</span>ty_term <span class="free">Q</span> constT<span class="main">)</span> <span class="free">a</span> <span class="main">⟹</span> wf_atom <span class="main">(</span>ty_term <span class="free">Q</span> objT<span class="main">)</span> <span class="free">a</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> wf_atom_mono<span class="main"><span class="main">[</span></span><span class="operator">rotated</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ty_term_mono<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> constT_ss_objT<span class="main">)</span>

  <span class="keyword1" id="PDDL_STRIPS_Semantics-wf_fmla_atom_constT_imp_objT"><span class="command">lemma</span></span> wf_fmla_atom_constT_imp_objT<span class="main">:</span> <span class="quoted"><span class="quoted">"wf_fmla_atom <span class="main">(</span>ty_term <span class="free">Q</span> constT<span class="main">)</span> <span class="free">a</span> <span class="main">⟹</span> wf_fmla_atom <span class="main">(</span>ty_term <span class="free">Q</span> objT<span class="main">)</span> <span class="free">a</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> wf_fmla_atom_mono<span class="main"><span class="main">[</span></span><span class="operator">rotated</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ty_term_mono<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> constT_ss_objT<span class="main">)</span>

  <span class="keyword1"><span class="command">context</span></span>
    <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">Q</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"variable <span class="main">⇒</span> object"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> INST<span class="main">:</span> <span class="quoted"><span class="quoted">"is_of_type <span class="free">Q</span> <span class="free">x</span> <span class="free">T</span> <span class="main">⟹</span> is_of_type objT <span class="main">(</span><span class="free">f</span> <span class="free">x</span><span class="main">)</span> <span class="free">T</span>"</span></span>
  <span class="keyword2"><span class="keyword">begin</span></span>

    <span class="keyword1" id="PDDL_STRIPS_Semantics-is_of_type_var_conv"><span class="command">lemma</span></span> is_of_type_var_conv<span class="main">:</span> <span class="quoted"><span class="quoted">"is_of_type <span class="main">(</span>ty_term <span class="free">Q</span> objT<span class="main">)</span> <span class="main">(</span>term.VAR <span class="free">x</span><span class="main">)</span> <span class="free">T</span>  <span class="main">⟷</span> is_of_type <span class="free">Q</span> <span class="free">x</span> <span class="free">T</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> is_of_type_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main">)</span>

    <span class="keyword1" id="PDDL_STRIPS_Semantics-is_of_type_const_conv"><span class="command">lemma</span></span> is_of_type_const_conv<span class="main">:</span> <span class="quoted"><span class="quoted">"is_of_type <span class="main">(</span>ty_term <span class="free">Q</span> objT<span class="main">)</span> <span class="main">(</span>term.CONST <span class="free">x</span><span class="main">)</span> <span class="free">T</span>  <span class="main">⟷</span> is_of_type objT <span class="free">x</span> <span class="free">T</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> is_of_type_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

    <span class="keyword1" id="PDDL_STRIPS_Semantics-INST'"><span class="command">lemma</span></span> INST'<span class="main">:</span> <span class="quoted"><span class="quoted">"is_of_type <span class="main">(</span>ty_term <span class="free">Q</span> objT<span class="main">)</span> <span class="free">x</span> <span class="free">T</span> <span class="main">⟹</span> is_of_type objT <span class="main">(</span>subst_term <span class="free">f</span> <span class="free">x</span><span class="main">)</span> <span class="free">T</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="keyword1"><span class="command">using</span></span> INST <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> is_of_type_var_conv is_of_type_const_conv<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


    <span class="keyword1" id="PDDL_STRIPS_Semantics-wf_inst_eq_aux"><span class="command">lemma</span></span> wf_inst_eq_aux<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Q</span> <span class="free">x</span> <span class="main">=</span> Some <span class="free">T</span> <span class="main">⟹</span> objT <span class="main">(</span><span class="free">f</span> <span class="free">x</span><span class="main">)</span> <span class="main">≠</span> None"</span></span>
      <span class="keyword1"><span class="command">using</span></span> INST<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="free">T</span></span><span class="main">]</span> <span class="keyword1"><span class="command">unfolding</span></span> is_of_type_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

    <span class="keyword1" id="PDDL_STRIPS_Semantics-wf_inst_eq_aux'"><span class="command">lemma</span></span> wf_inst_eq_aux'<span class="main">:</span> <span class="quoted"><span class="quoted">"ty_term <span class="free">Q</span> objT <span class="free">x</span> <span class="main">=</span> Some <span class="free">T</span> <span class="main">⟹</span> objT <span class="main">(</span>subst_term <span class="free">f</span> <span class="free">x</span><span class="main">)</span> <span class="main">≠</span> None"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> wf_inst_eq_aux<span class="main">)</span>


    <span class="keyword1" id="PDDL_STRIPS_Semantics-wf_inst_atom"><span class="command">lemma</span></span> wf_inst_atom<span class="main">:</span>
      <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"wf_atom <span class="main">(</span>ty_term <span class="free">Q</span> constT<span class="main">)</span> <span class="free">a</span>"</span></span>
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"wf_atom objT <span class="main">(</span>map_atom <span class="main">(</span>subst_term <span class="free">f</span><span class="main">)</span> <span class="free">a</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command">have</span></span> X1<span class="main">:</span> <span class="quoted"><span class="quoted">"list_all2 <span class="main">(</span>is_of_type objT<span class="main">)</span> <span class="main">(</span>map <span class="main">(</span>subst_term <span class="free">f</span><span class="main">)</span> <span class="skolem">xs</span><span class="main">)</span> <span class="skolem">Ts</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span>
        <span class="quoted"><span class="quoted">"list_all2 <span class="main">(</span>is_of_type <span class="main">(</span>ty_term <span class="free">Q</span> objT<span class="main">)</span><span class="main">)</span> <span class="skolem">xs</span> <span class="skolem">Ts</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">xs</span> <span class="skolem">Ts</span>
        <span class="keyword1"><span class="command">using</span></span> that
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">induction</span>
        <span class="keyword1"><span class="command">using</span></span> INST'
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">using</span></span> assms<span class="main">[</span><span class="operator">THEN</span> wf_atom_constT_imp_objT<span class="main">]</span> wf_inst_eq_aux'
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">a</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

    <span class="keyword1"><span class="command">qed</span></span>

    <span class="keyword1" id="PDDL_STRIPS_Semantics-wf_inst_formula_atom"><span class="command">lemma</span></span> wf_inst_formula_atom<span class="main">:</span>
      <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"wf_fmla_atom <span class="main">(</span>ty_term <span class="free">Q</span> constT<span class="main">)</span> <span class="free">a</span>"</span></span>
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"wf_fmla_atom objT <span class="main">(</span><span class="main">(</span>map_formula <span class="keyword1">o</span> map_atom <span class="keyword1">o</span> subst_term<span class="main">)</span> <span class="free">f</span> <span class="free">a</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> assms<span class="main">[</span><span class="operator">THEN</span> wf_fmla_atom_constT_imp_objT<span class="main">]</span> wf_inst_atom
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">a</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> wf_fmla_atom.cases<span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> INST' list.rel_map<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> list_all2_mono<span class="main">)</span>

    <span class="keyword1" id="PDDL_STRIPS_Semantics-wf_inst_effect"><span class="command">lemma</span></span> wf_inst_effect<span class="main">:</span>
      <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"wf_effect <span class="main">(</span>ty_term <span class="free">Q</span> constT<span class="main">)</span> <span class="free">φ</span>"</span></span>
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"wf_effect objT <span class="main">(</span><span class="main">(</span>map_ast_effect <span class="keyword1">o</span> subst_term<span class="main">)</span> <span class="free">f</span> <span class="free">φ</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> assms
      <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">φ</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Effect <span class="skolem">x1a</span> <span class="skolem">x2a</span><span class="main">)</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> wf_inst_formula_atom <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">qed</span></span>

    <span class="keyword1" id="PDDL_STRIPS_Semantics-wf_inst_formula"><span class="command">lemma</span></span> wf_inst_formula<span class="main">:</span>
      <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"wf_fmla <span class="main">(</span>ty_term <span class="free">Q</span> constT<span class="main">)</span> <span class="free">φ</span>"</span></span>
      <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"wf_fmla objT <span class="main">(</span><span class="main">(</span>map_formula <span class="keyword1">o</span> map_atom <span class="keyword1">o</span> subst_term<span class="main">)</span> <span class="free">f</span> <span class="free">φ</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> assms
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">φ</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> wf_inst_atom <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> wf_inst_eq_aux<span class="main">)</span>

  <span class="keyword2"><span class="keyword">end</span></span>



  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Instantiating a well-formed action schema with compatible arguments
    will yield a well-formed action instance.
  ›</span></span>
  <span class="keyword1"><span class="command">theorem</span></span> wf_instantiate_action_schema<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"action_params_match <span class="free">a</span> <span class="free">args</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"wf_action_schema <span class="free">a</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"wf_ground_action <span class="main">(</span>instantiate_action_schema <span class="free">a</span> <span class="free">args</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">a</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="main">(</span>Action_Schema <span class="skolem">name</span> <span class="skolem">params</span> <span class="skolem">pre</span> <span class="skolem">eff</span><span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> INST<span class="main">:</span>
      <span class="quoted"><span class="quoted">"is_of_type objT <span class="main">(</span><span class="main">(</span>the <span class="main">∘</span> map_of <span class="main">(</span>zip <span class="main">(</span>map fst <span class="skolem">params</span><span class="main">)</span> <span class="free">args</span><span class="main">)</span><span class="main">)</span> <span class="skolem">x</span><span class="main">)</span> <span class="skolem">T</span>"</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"is_of_type <span class="main">(</span>map_of <span class="skolem">params</span><span class="main">)</span> <span class="skolem">x</span> <span class="skolem">T</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">T</span>
      <span class="keyword1"><span class="command">using</span></span> that
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> is_of_type_map_ofE<span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> assms
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> i xT
        <span class="keyword1"><span class="command">unfolding</span></span> action_params_match_def
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> lookup_zip_idx_eq<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> i<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="skolem">i</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span>
          <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> list_all2_lengthD<span class="main">)</span><span class="main"><span class="keyword3">?</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> list_all2_nthD2<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> p<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="skolem">i</span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">?</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span>
                <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> is_obj_of_type_alt is_of_type_def
                <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> of_type_trans
                <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">using</span></span> assms<span class="main">(</span>2<span class="main">)</span> wf_inst_formula wf_inst_effect
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> term.splits <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def comp_apply<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Context of <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>ast_problem›</span></span>›</span>



<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Preservation›</span></span>

<span class="keyword1"><span class="command">context</span></span> ast_problem <span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We start by defining two shorthands for enabledness and execution of
    a plan action.›</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Shorthand for enabled plan action: It is well-formed, and the
    precondition holds for its instance.›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">plan_action_enabled</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"plan_action <span class="main">⇒</span> world_model <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">plan_action_enabled</span> <span class="free"><span class="bound"><span class="entity">π</span></span></span> <span class="free"><span class="bound"><span class="entity">M</span></span></span>
      <span class="main">⟷</span> wf_plan_action <span class="free"><span class="bound"><span class="entity">π</span></span></span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="keyword1"><span class="hidden">⇧</span><sup>c</sup>⊫<span class="hidden">⇩</span><sub>=</sub></span> precondition <span class="main">(</span>resolve_instantiate <span class="free"><span class="bound"><span class="entity">π</span></span></span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Shorthand for executing a plan action: Resolve, instantiate, and
    apply effect›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">execute_plan_action</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"plan_action <span class="main">⇒</span> world_model <span class="main">⇒</span> world_model"</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">execute_plan_action</span> <span class="free"><span class="bound"><span class="entity">π</span></span></span> <span class="free"><span class="bound"><span class="entity">M</span></span></span>
      <span class="main">=</span> <span class="main">(</span>apply_effect <span class="main">(</span>effect <span class="main">(</span>resolve_instantiate <span class="free"><span class="bound"><span class="entity">π</span></span></span><span class="main">)</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">M</span></span></span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> plan_action_path<span class="antiquote"><span class="antiquote">}</span></span></span></span> predicate can be decomposed naturally
    using these shorthands: ›</span></span>
  <span class="keyword1" id="PDDL_STRIPS_Semantics-plan_action_path_Nil"><span class="command">lemma</span></span> plan_action_path_Nil<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"plan_action_path <span class="free">M</span> <span class="main">[]</span> <span class="free">M'</span> <span class="main">⟷</span> <span class="free">M'</span><span class="main">=</span><span class="free">M</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> plan_action_path_def<span class="main">)</span>

  <span class="keyword1" id="PDDL_STRIPS_Semantics-plan_action_path_Cons"><span class="command">lemma</span></span> plan_action_path_Cons<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"plan_action_path <span class="free">M</span> <span class="main">(</span><span class="free">π</span><span class="main">#</span><span class="free">πs</span><span class="main">)</span> <span class="free">M'</span> <span class="main">⟷</span>
      plan_action_enabled <span class="free">π</span> <span class="free">M</span>
    <span class="main">∧</span> plan_action_path <span class="main">(</span>execute_plan_action <span class="free">π</span> <span class="free">M</span><span class="main">)</span> <span class="free">πs</span> <span class="free">M'</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span>
      <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> plan_action_path_def execute_plan_action_def
            execute_ground_action_def plan_action_enabled_def<span class="main">)</span>



<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Context of <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>ast_problem›</span></span>›</span>

<span class="keyword1"><span class="command">context</span></span> wf_ast_problem <span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The initial world model is well-formed›</span></span>
  <span class="keyword1" id="PDDL_STRIPS_Semantics-wf_I"><span class="command">lemma</span></span> wf_I<span class="main">:</span> <span class="quoted"><span class="quoted">"wf_world_model I"</span></span>
    <span class="keyword1"><span class="command">using</span></span> wf_problem
    <span class="keyword1"><span class="command">unfolding</span></span> I_def wf_world_model_def wf_problem_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">safe</span><span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> f <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">f</span></span><span class="main">)</span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Application of a well-formed effect preserves well-formedness
    of the model›</span></span>
  <span class="keyword1" id="PDDL_STRIPS_Semantics-wf_apply_effect"><span class="command">lemma</span></span> wf_apply_effect<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"wf_effect objT <span class="free">e</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"wf_world_model <span class="free">s</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"wf_world_model <span class="main">(</span>apply_effect <span class="free">e</span> <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms wf_problem
    <span class="keyword1"><span class="command">unfolding</span></span> wf_world_model_def wf_problem_def wf_domain_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">e</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> formula.splits prod.splits<span class="main">)</span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Execution of plan actions preserves well-formedness›</span></span>
  <span class="keyword1"><span class="command">theorem</span></span> wf_execute<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"plan_action_enabled <span class="free">π</span> <span class="free">s</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"wf_world_model <span class="free">s</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"wf_world_model <span class="main">(</span>execute_plan_action <span class="free">π</span> <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">π</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="main">(</span>PAction <span class="skolem">name</span> <span class="skolem">args</span><span class="main">)</span>

    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹plan_action_enabled <span class="free">π</span> <span class="free">s</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"wf_plan_action <span class="free">π</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> plan_action_enabled_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">a</span></span> <span class="keyword2"><span class="keyword">where</span></span>
      <span class="quoted"><span class="quoted">"resolve_action_schema <span class="skolem">name</span> <span class="main">=</span> Some <span class="skolem">a</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span>
      T<span class="main">:</span> <span class="quoted"><span class="quoted">"action_params_match <span class="skolem">a</span> <span class="skolem">args</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

    <span class="keyword1"><span class="command">from</span></span> wf_domain <span class="keyword1"><span class="command">have</span></span>
      <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map ast_action_schema.name <span class="main">(</span>actions D<span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> wf_domain_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹resolve_action_schema <span class="skolem">name</span> <span class="main">=</span> Some <span class="skolem">a</span>›</span></span> <span class="keyword1"><span class="command">have</span></span>
      <span class="quoted"><span class="quoted">"<span class="skolem">a</span> <span class="main">∈</span> set <span class="main">(</span>actions D<span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> resolve_action_schema_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">with</span></span> wf_domain <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"wf_action_schema <span class="skolem">a</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> wf_domain_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"wf_ground_action <span class="main">(</span>resolve_instantiate <span class="free">π</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹resolve_action_schema <span class="skolem">name</span> <span class="main">=</span> Some <span class="skolem">a</span>›</span></span> T
        wf_instantiate_action_schema
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> execute_plan_action_def execute_ground_action_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> wf_apply_effect<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"resolve_instantiate <span class="free">π</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> <span class="quoted"><span class="quoted">‹wf_world_model <span class="free">s</span>›</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">theorem</span></span> wf_execute_compact_notation<span class="main">:</span>
    <span class="quoted"><span class="quoted">"plan_action_enabled <span class="free">π</span> <span class="free">s</span> <span class="main">⟹</span> wf_world_model <span class="free">s</span>
    <span class="main">⟹</span> wf_world_model <span class="main">(</span>execute_plan_action <span class="free">π</span> <span class="free">s</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> wf_execute<span class="main">)</span>


  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Execution of a plan preserves well-formedness›</span></span>
  <span class="keyword1"><span class="command">corollary</span></span> wf_plan_action_path<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"wf_world_model <span class="free">M</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">" plan_action_path <span class="free">M</span> <span class="free">πs</span> <span class="free">M'</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"wf_world_model <span class="free">M'</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">πs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">M</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> wf_execute<span class="main">)</span>


<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Context of <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>wf_ast_problem›</span></span>›</span>




<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Theory›</span>
</pre>
</div><div id="PDDL_STRIPS_Checker">
<div class="head">
<h1>Theory PDDL_STRIPS_Checker</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Executable PDDL Checker›</span></span>
<span class="keyword1"><span class="command">theory</span></span> PDDL_STRIPS_Checker
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="#PDDL_STRIPS_Semantics">PDDL_STRIPS_Semantics</a>

  <a href="#Error_Monad_Add">Error_Monad_Add</a>
  <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL/String.html">HOL.String</a>"</span>

  <span class="comment1">(*"HOL-Library.Code_Char"     TODO: This might lead to performance loss! CHECK! *)</span>
  <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/Code_Target_Nat.html">HOL-Library.Code_Target_Nat</a>"</span>

  <span class="quoted">"<a href="https://www.cl.cam.ac.uk/research/hvg/Isabelle/dist/library/HOL/HOL-Library/While_Combinator.html">HOL-Library.While_Combinator</a>"</span>

  <span class="quoted">"<a href="../../containers/theories/#Containers">Containers.Containers</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Generic DFS Reachability Checker›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Used for subtype checks›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">E_of_succ</span> <span class="free"><span class="bound"><span class="entity">succ</span></span></span> <span class="main">≡</span> <span class="main">{</span> <span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">.</span> <span class="bound">v</span><span class="main">∈</span>set <span class="main">(</span><span class="free"><span class="bound"><span class="entity">succ</span></span></span> <span class="bound">u</span><span class="main">)</span> <span class="main">}</span>"</span></span>
<span class="keyword1" id="PDDL_STRIPS_Checker-succ_as_E"><span class="command">lemma</span></span> succ_as_E<span class="main">:</span> <span class="quoted"><span class="quoted">"set <span class="main">(</span><span class="free">succ</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> E_of_succ <span class="free">succ</span> <span class="main">``</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> E_of_succ_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">succ</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> list"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">E</span> <span class="main">≡</span> E_of_succ <span class="free">succ</span>"</span></span>


<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">dfs_reachable</span> <span class="free"><span class="bound"><span class="entity">D</span></span></span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">≡</span>
  <span class="keyword1">let</span> <span class="main">(</span><span class="bound">V</span><span class="main">,</span><span class="bound">w</span><span class="main">,</span><span class="bound">brk</span><span class="main">)</span> <span class="main">=</span> while <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">V</span><span class="main">,</span><span class="bound">w</span><span class="main">,</span><span class="bound">brk</span><span class="main">)</span><span class="main">.</span> <span class="main">¬</span><span class="bound">brk</span> <span class="main">∧</span> <span class="bound">w</span><span class="main">≠</span><span class="main">[]</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">V</span><span class="main">,</span><span class="bound">w</span><span class="main">,</span><span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span>
    <span class="keyword1">case</span> <span class="bound">w</span> <span class="keyword1">of</span> <span class="bound">v</span><span class="main">#</span><span class="bound">w</span> <span class="main">⇒</span>
    <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">D</span></span></span> <span class="bound">v</span> <span class="keyword1">then</span> <span class="main">(</span><span class="bound">V</span><span class="main">,</span><span class="bound">v</span><span class="main">#</span><span class="bound">w</span><span class="main">,</span>True<span class="main">)</span>
    <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="bound">v</span><span class="main">∈</span><span class="bound">V</span> <span class="keyword1">then</span> <span class="main">(</span><span class="bound">V</span><span class="main">,</span><span class="bound">w</span><span class="main">,</span>False<span class="main">)</span>
    <span class="keyword1">else</span>
      <span class="keyword1">let</span> <span class="bound">V</span> <span class="main">=</span> insert <span class="bound">v</span> <span class="bound">V</span> <span class="keyword1">in</span>
      <span class="keyword1">let</span> <span class="bound">w</span> <span class="main">=</span> <span class="free">succ</span> <span class="bound">v</span> <span class="main">@</span> <span class="bound">w</span> <span class="keyword1">in</span>
      <span class="main">(</span><span class="bound">V</span><span class="main">,</span><span class="bound">w</span><span class="main">,</span>False<span class="main">)</span>
    <span class="main">)</span> <span class="main">(</span><span class="main">{}</span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">w</span></span></span><span class="main">,</span>False<span class="main">)</span>
  <span class="keyword1">in</span> <span class="bound">brk</span>"</span></span>


<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">w<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> finite_dfs_reachable<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main"><span class="main">!</span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> set <span class="free">w<span class="hidden">⇩</span><sub>0</sub></span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword2"><span class="keyword">private</span></span> <span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">W<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">≡</span> set <span class="free">w<span class="hidden">⇩</span><sub>0</sub></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">dfs_reachable_invar</span> <span class="free"><span class="bound"><span class="entity">D</span></span></span> <span class="free"><span class="bound"><span class="entity">V</span></span></span> <span class="free"><span class="bound"><span class="entity">W</span></span></span> <span class="free"><span class="bound"><span class="entity">brk</span></span></span> <span class="main">⟷</span>
    W<span class="hidden">⇩</span><sub>0</sub> <span class="main">⊆</span> <span class="free"><span class="bound"><span class="entity">W</span></span></span> <span class="main">∪</span> <span class="free"><span class="bound"><span class="entity">V</span></span></span>
  <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">W</span></span></span> <span class="main">∪</span> <span class="free"><span class="bound"><span class="entity">V</span></span></span> <span class="main">⊆</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> W<span class="hidden">⇩</span><sub>0</sub>
  <span class="main">∧</span> E<span class="main">``</span><span class="free"><span class="bound"><span class="entity">V</span></span></span> <span class="main">⊆</span> <span class="free"><span class="bound"><span class="entity">W</span></span></span> <span class="main">∪</span> <span class="free"><span class="bound"><span class="entity">V</span></span></span>
  <span class="main">∧</span> Collect <span class="free"><span class="bound"><span class="entity">D</span></span></span> <span class="main">∩</span> <span class="free"><span class="bound"><span class="entity">V</span></span></span> <span class="main">=</span> <span class="main">{}</span>
  <span class="main">∧</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">brk</span></span></span> <span class="main">⟶</span> Collect <span class="free"><span class="bound"><span class="entity">D</span></span></span> <span class="main">∩</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> W<span class="hidden">⇩</span><sub>0</sub> <span class="main">≠</span> <span class="main">{}</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="PDDL_STRIPS_Checker-card_decreases"><span class="command">lemma</span></span> card_decreases<span class="main">:</span> <span class="quoted"><span class="quoted">"
   <span class="main">⟦</span>finite <span class="free">V</span><span class="main">;</span> <span class="free">y</span> <span class="main">∉</span> <span class="free">V</span><span class="main">;</span> dfs_reachable_invar <span class="free">D</span> <span class="free">V</span> <span class="main">(</span>Set.insert <span class="free">y</span> <span class="free">W</span><span class="main">)</span> <span class="free">brk</span> <span class="main">⟧</span>
   <span class="main">⟹</span> card <span class="main">(</span>E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> W<span class="hidden">⇩</span><sub>0</sub> <span class="main">-</span> Set.insert <span class="free">y</span> <span class="free">V</span><span class="main">)</span> <span class="main">&lt;</span> card <span class="main">(</span>E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> W<span class="hidden">⇩</span><sub>0</sub> <span class="main">-</span> <span class="free">V</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> psubset_card_mono<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> dfs_reachable_invar_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="PDDL_STRIPS_Checker-all_neq_Cons_is_Nil"><span class="command">lemma</span></span> all_neq_Cons_is_Nil<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="comment1">(* Odd term remaining in goal … *)</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">y</span> <span class="bound">ys</span><span class="main">.</span> <span class="free">x2</span> <span class="main">≠</span> <span class="bound">y</span> <span class="main">#</span> <span class="bound">ys</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">x2</span> <span class="main">=</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x2</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="PDDL_STRIPS_Checker-dfs_reachable_correct"><span class="command">lemma</span></span> dfs_reachable_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"dfs_reachable <span class="free">D</span> <span class="free">w<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">⟷</span> Collect <span class="free">D</span> <span class="main">∩</span> E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> set <span class="free">w<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> dfs_reachable_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> while_rule<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span>
    P<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="bound">V</span><span class="main">,</span><span class="bound">w</span><span class="main">,</span><span class="bound">brk</span><span class="main">)</span><span class="main">.</span> dfs_reachable_invar <span class="free">D</span> <span class="bound">V</span> <span class="main">(</span>set <span class="bound">w</span><span class="main">)</span> <span class="bound">brk</span> <span class="main">∧</span> finite <span class="bound">V</span>"</span></span>
    <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> r<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"measure <span class="main">(</span><span class="main">λ</span><span class="bound">V</span><span class="main">.</span> card <span class="main">(</span>E<span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> <span class="main">(</span>set <span class="free">w<span class="hidden">⇩</span><sub>0</sub></span><span class="main">)</span> <span class="main">-</span> <span class="bound">V</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">&lt;*lex*&gt;</span> measure length <span class="keyword1">&lt;*lex*&gt;</span> measure <span class="main">(</span><span class="main">λ</span>True<span class="main">⇒</span><span class="main">0</span> <span class="main">|</span> False<span class="main">⇒</span><span class="main">1</span><span class="main">)</span>"</span></span>
    <span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> dfs_reachable_invar_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> neq_Nil_conv succ_as_E<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free">succ</span></span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> dfs_reachable_invar_def Image_iff <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rtrancl.rtrancl_into_rtrancl<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> dfs_reachable_invar_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Image_closed_trancl<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> neq_Nil_conv card_decreases<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">tab_succ</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">≡</span> Mapping.lookup_default <span class="main">[]</span> <span class="main">(</span>fold <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">.</span> Mapping.map_default <span class="bound">u</span> <span class="main">[]</span> <span class="main">(</span>Cons <span class="bound">v</span><span class="main">)</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> Mapping.empty<span class="main">)</span>"</span></span>


<span class="keyword1" id="PDDL_STRIPS_Checker-Some_eq_map_option"><span class="command">lemma</span></span> Some_eq_map_option <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Some <span class="free">y</span> <span class="main">=</span> map_option <span class="free">f</span> <span class="free">xo</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∃</span><span class="bound">z</span><span class="main">.</span> <span class="free">xo</span> <span class="main">=</span> Some <span class="bound">z</span> <span class="main">∧</span> <span class="free">f</span> <span class="bound">z</span> <span class="main">=</span> <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_option_case <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>


<span class="keyword1" id="PDDL_STRIPS_Checker-tab_succ_correct"><span class="command">lemma</span></span> tab_succ_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"E_of_succ <span class="main">(</span>tab_succ <span class="free">l</span><span class="main">)</span> <span class="main">=</span> set <span class="free">l</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set <span class="main">(</span>Mapping.lookup_default <span class="main">[]</span> <span class="main">(</span>fold <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">u</span><span class="main">,</span><span class="bound">v</span><span class="main">)</span><span class="main">.</span> Mapping.map_default <span class="bound">u</span> <span class="main">[]</span> <span class="main">(</span>Cons <span class="bound">v</span><span class="main">)</span><span class="main">)</span> <span class="free">l</span> <span class="skolem">m</span><span class="main">)</span> <span class="skolem">u</span><span class="main">)</span> <span class="main">=</span> set <span class="free">l</span> <span class="main">``</span> <span class="main">{</span><span class="skolem">u</span><span class="main">}</span> <span class="main">∪</span> set <span class="main">(</span>Mapping.lookup_default <span class="main">[]</span> <span class="skolem">m</span> <span class="skolem">u</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span> <span class="skolem">u</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">l</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">m</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span>
      <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Mapping.lookup_default_def Mapping.map_default_def Mapping.default_def
      <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> lookup_map_entry' lookup_update' keys_is_none_rep Option.is_none_def
      <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits
    <span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> this<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> m<span class="main"><span class="main">=</span></span><span class="quoted">Mapping.empty</span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> E_of_succ_def tab_succ_def lookup_default_empty<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="PDDL_STRIPS_Checker-finite_imp_finite_dfs_reachable"><span class="command">lemma</span></span> finite_imp_finite_dfs_reachable<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>finite <span class="free">E</span><span class="main">;</span> finite <span class="free">S</span><span class="main">⟧</span> <span class="main">⟹</span> finite <span class="main">(</span><span class="free">E</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span><span class="free">S</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> finite_subset<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> B<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="free">S</span> <span class="main">∪</span> <span class="main">(</span>Relation.Domain <span class="free">E</span> <span class="main">∪</span> Relation.Range <span class="free">E</span><span class="main">)</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> finite_Domain finite_Range <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> rtranclE<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="PDDL_STRIPS_Checker-dfs_reachable_tab_succ_correct"><span class="command">lemma</span></span> dfs_reachable_tab_succ_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"dfs_reachable <span class="main">(</span>tab_succ <span class="free">l</span><span class="main">)</span> <span class="free">D</span> <span class="free">vs<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">⟷</span> Collect <span class="free">D</span> <span class="main">∩</span> <span class="main">(</span>set <span class="free">l</span><span class="main">)</span><span class="main"><span class="hidden">⇧</span><sup>*</sup></span><span class="main">``</span>set <span class="free">vs<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> dfs_reachable_correct<span class="main">)</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tab_succ_correct finite_imp_finite_dfs_reachable<span class="main">)</span>



<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Implementation Refinements›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Of-Type›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">of_type_impl</span> <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="free"><span class="bound"><span class="entity">oT</span></span></span> <span class="free"><span class="bound"><span class="entity">T</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="main">∀</span><span class="bound">pt</span><span class="main">∈</span>set <span class="main">(</span>primitives <span class="free"><span class="bound"><span class="entity">oT</span></span></span><span class="main">)</span><span class="main">.</span> dfs_reachable <span class="free"><span class="bound"><span class="entity">G</span></span></span> <span class="main">(</span><span class="main">(=)</span> <span class="bound">pt</span><span class="main">)</span> <span class="main">(</span>primitives <span class="free"><span class="bound"><span class="entity">T</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>


<span class="keyword1"><span class="command">fun</span></span> <span class="entity">ty_term'</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">ty_term'</span> <span class="free"><span class="bound"><span class="entity">varT</span></span></span> <span class="free"><span class="bound"><span class="entity">objT</span></span></span> <span class="main">(</span>term.VAR <span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">varT</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">ty_term'</span> <span class="free"><span class="bound"><span class="entity">varT</span></span></span> <span class="free"><span class="bound"><span class="entity">objT</span></span></span> <span class="main">(</span>term.CONST <span class="free"><span class="bound"><span class="entity">c</span></span></span><span class="main">)</span> <span class="main">=</span> Mapping.lookup <span class="free"><span class="bound"><span class="entity">objT</span></span></span> <span class="free"><span class="bound"><span class="entity">c</span></span></span>"</span></span>

<span class="keyword1" id="PDDL_STRIPS_Checker-ty_term'_correct_aux"><span class="command">lemma</span></span> ty_term'_correct_aux<span class="main">:</span> <span class="quoted"><span class="quoted">"ty_term' <span class="free">varT</span> <span class="free">objT</span> <span class="free">t</span> <span class="main">=</span> ty_term <span class="free">varT</span> <span class="main">(</span>Mapping.lookup <span class="free">objT</span><span class="main">)</span> <span class="free">t</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="PDDL_STRIPS_Checker-ty_term'_correct"><span class="command">lemma</span></span> ty_term'_correct<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ty_term' <span class="free">varT</span> <span class="free">objT</span> <span class="main">=</span> ty_term <span class="free">varT</span> <span class="main">(</span>Mapping.lookup <span class="free">objT</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> ty_term'_correct_aux <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">context</span></span> ast_domain <span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">of_type1</span> <span class="free"><span class="bound"><span class="entity">pt</span></span></span> <span class="free"><span class="bound"><span class="entity">T</span></span></span> <span class="main">⟷</span> <span class="free"><span class="bound"><span class="entity">pt</span></span></span> <span class="main">∈</span> subtype_rel<span class="main"><span class="hidden">⇧</span><sup>*</sup></span> <span class="main">``</span> set <span class="main">(</span>primitives <span class="free"><span class="bound"><span class="entity">T</span></span></span><span class="main">)</span>"</span></span>

  <span class="keyword1" id="PDDL_STRIPS_Checker-of_type_refine1"><span class="command">lemma</span></span> of_type_refine1<span class="main">:</span> <span class="quoted"><span class="quoted">"of_type <span class="free">oT</span> <span class="free">T</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∀</span><span class="bound">pt</span><span class="main">∈</span>set <span class="main">(</span>primitives <span class="free">oT</span><span class="main">)</span><span class="main">.</span> of_type1 <span class="bound">pt</span> <span class="free">T</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> of_type_def of_type1_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">STG</span> <span class="main">≡</span> <span class="main">(</span>tab_succ <span class="main">(</span>map subtype_edge <span class="main">(</span>types <span class="free">D</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

  <span class="keyword1" id="PDDL_STRIPS_Checker-subtype_rel_impl"><span class="command">lemma</span></span> subtype_rel_impl<span class="main">:</span> <span class="quoted"><span class="quoted">"subtype_rel <span class="main">=</span> E_of_succ <span class="main">(</span>tab_succ <span class="main">(</span>map subtype_edge <span class="main">(</span>types <span class="free">D</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tab_succ_correct subtype_rel_def<span class="main">)</span>

  <span class="keyword1" id="PDDL_STRIPS_Checker-of_type1_impl"><span class="command">lemma</span></span> of_type1_impl<span class="main">:</span> <span class="quoted"><span class="quoted">"of_type1 <span class="free">pt</span> <span class="free">T</span> <span class="main">⟷</span> dfs_reachable <span class="main">(</span>tab_succ <span class="main">(</span>map subtype_edge <span class="main">(</span>types <span class="free">D</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">(=)</span><span class="free">pt</span><span class="main">)</span> <span class="main">(</span>primitives <span class="free">T</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> subtype_rel_impl of_type1_def dfs_reachable_tab_succ_correct tab_succ_correct<span class="main">)</span>

  <span class="keyword1" id="PDDL_STRIPS_Checker-of_type_impl_correct"><span class="command">lemma</span></span> of_type_impl_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"of_type_impl STG <span class="free">oT</span> <span class="free">T</span> <span class="main">⟷</span> of_type <span class="free">oT</span> <span class="free">T</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> of_type1_impl STG_def of_type_impl_def of_type_refine1 <span class="keyword1"><span class="command">..</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">mp_constT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>object<span class="main">,</span> type<span class="main">)</span> mapping"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">mp_constT</span> <span class="main">=</span> Mapping.of_alist <span class="main">(</span>consts <span class="free">D</span><span class="main">)</span>"</span></span>

  <span class="keyword1" id="PDDL_STRIPS_Checker-mp_objT_correct"><span class="command">lemma</span></span> mp_objT_correct<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Mapping.lookup mp_constT <span class="main">=</span> constT"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> mp_constT_def constT_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Map_To_Mapping.map_apply_def<span class="main">)</span>






  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Lifting the subtype-graph through wf-checker›</span></span>
  <span class="keyword1"><span class="command">context</span></span>
    <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">ty_ent</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'ent</span> <span class="main">⇀</span> type"</span></span>  <span class="comment1">― ‹Entity's type, None if invalid›</span>
  <span class="keyword2"><span class="keyword">begin</span></span>

    <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">is_of_type'</span> <span class="free"><span class="bound"><span class="entity">stg</span></span></span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="free"><span class="bound"><span class="entity">T</span></span></span> <span class="main">⟷</span> <span class="main">(</span>
      <span class="keyword1">case</span> <span class="free">ty_ent</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="keyword1">of</span>
        Some <span class="bound">vT</span> <span class="main">⇒</span> of_type_impl <span class="free"><span class="bound"><span class="entity">stg</span></span></span> <span class="bound">vT</span> <span class="free"><span class="bound"><span class="entity">T</span></span></span>
      <span class="main">|</span> None <span class="main">⇒</span> False<span class="main">)</span>"</span></span>

    <span class="keyword1" id="PDDL_STRIPS_Checker-is_of_type'_correct"><span class="command">lemma</span></span> is_of_type'_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"is_of_type' STG <span class="free">v</span> <span class="free">T</span> <span class="main">=</span> is_of_type <span class="free">ty_ent</span> <span class="free">v</span> <span class="free">T</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> is_of_type'_def is_of_type_def of_type_impl_correct <span class="keyword1"><span class="command">..</span></span>

    <span class="keyword1"><span class="command">fun</span></span> <span class="entity">wf_pred_atom'</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">wf_pred_atom'</span> <span class="free"><span class="bound"><span class="entity">stg</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="keyword1">case</span> sig <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="keyword1">of</span>
          None <span class="main">⇒</span> False
        <span class="main">|</span> Some <span class="bound">Ts</span> <span class="main">⇒</span> list_all2 <span class="main">(</span>is_of_type' <span class="free"><span class="bound"><span class="entity">stg</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span> <span class="bound">Ts</span><span class="main">)</span>"</span></span>

    <span class="keyword1" id="PDDL_STRIPS_Checker-wf_pred_atom'_correct"><span class="command">lemma</span></span> wf_pred_atom'_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"wf_pred_atom' STG <span class="free">pvs</span> <span class="main">=</span> wf_pred_atom <span class="free">ty_ent</span> <span class="free">pvs</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">pvs</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> is_of_type'_correct<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span>option.split<span class="main">)</span>

    <span class="keyword1"><span class="command">fun</span></span> <span class="entity">wf_atom'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">⇒</span> <span class="tfree">'ent</span> atom <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
      <span class="quoted"><span class="quoted">"<span class="free">wf_atom'</span> <span class="free"><span class="bound"><span class="entity">stg</span></span></span> <span class="main">(</span>atom.predAtm <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">)</span> <span class="main">⟷</span> wf_pred_atom' <span class="free"><span class="bound"><span class="entity">stg</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">)</span>"</span></span>
    <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">wf_atom'</span> <span class="free"><span class="bound"><span class="entity">stg</span></span></span> <span class="main">(</span>atom.Eq <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">ty_ent</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">≠</span> None <span class="main">∧</span> <span class="free">ty_ent</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">≠</span> None<span class="main">)</span>"</span></span>

    <span class="keyword1" id="PDDL_STRIPS_Checker-wf_atom'_correct"><span class="command">lemma</span></span> wf_atom'_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"wf_atom' STG <span class="free">a</span> <span class="main">=</span> wf_atom <span class="free">ty_ent</span> <span class="free">a</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">a</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> wf_pred_atom'_correct is_of_type'_correct<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

    <span class="keyword1"><span class="command">fun</span></span> <span class="entity">wf_fmla'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'ent</span> atom<span class="main">)</span> formula <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
      <span class="quoted"><span class="quoted">"<span class="free">wf_fmla'</span> <span class="free"><span class="bound"><span class="entity">stg</span></span></span> <span class="main">(</span>Atom <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span> <span class="main">⟷</span> wf_atom' <span class="free"><span class="bound"><span class="entity">stg</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span>"</span></span>
    <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">wf_fmla'</span> <span class="free"><span class="bound"><span class="entity">stg</span></span></span> <span class="main">⊥</span> <span class="main">⟷</span> True"</span></span>
    <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">wf_fmla'</span> <span class="free"><span class="bound"><span class="entity">stg</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">φ1</span></span></span> <span class="main"><span class="hidden">❙</span><b>∧</b></span> <span class="free"><span class="bound"><span class="entity">φ2</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">wf_fmla'</span> <span class="free"><span class="bound"><span class="entity">stg</span></span></span> <span class="free"><span class="bound"><span class="entity">φ1</span></span></span> <span class="main">∧</span> <span class="free">wf_fmla'</span> <span class="free"><span class="bound"><span class="entity">stg</span></span></span> <span class="free"><span class="bound"><span class="entity">φ2</span></span></span><span class="main">)</span>"</span></span>
    <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">wf_fmla'</span> <span class="free"><span class="bound"><span class="entity">stg</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">φ1</span></span></span> <span class="main"><span class="hidden">❙</span><b>∨</b></span> <span class="free"><span class="bound"><span class="entity">φ2</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">wf_fmla'</span> <span class="free"><span class="bound"><span class="entity">stg</span></span></span> <span class="free"><span class="bound"><span class="entity">φ1</span></span></span> <span class="main">∧</span> <span class="free">wf_fmla'</span> <span class="free"><span class="bound"><span class="entity">stg</span></span></span> <span class="free"><span class="bound"><span class="entity">φ2</span></span></span><span class="main">)</span>"</span></span>
    <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">wf_fmla'</span> <span class="free"><span class="bound"><span class="entity">stg</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">φ1</span></span></span> <span class="main"><span class="hidden">❙</span><b>→</b></span> <span class="free"><span class="bound"><span class="entity">φ2</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">wf_fmla'</span> <span class="free"><span class="bound"><span class="entity">stg</span></span></span> <span class="free"><span class="bound"><span class="entity">φ1</span></span></span> <span class="main">∧</span> <span class="free">wf_fmla'</span> <span class="free"><span class="bound"><span class="entity">stg</span></span></span> <span class="free"><span class="bound"><span class="entity">φ2</span></span></span><span class="main">)</span>"</span></span>
    <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">wf_fmla'</span> <span class="free"><span class="bound"><span class="entity">stg</span></span></span> <span class="main">(</span><span class="main"><span class="hidden">❙</span><b>¬</b></span><span class="free"><span class="bound"><span class="entity">φ</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="free">wf_fmla'</span> <span class="free"><span class="bound"><span class="entity">stg</span></span></span> <span class="free"><span class="bound"><span class="entity">φ</span></span></span>"</span></span>

    <span class="keyword1" id="PDDL_STRIPS_Checker-wf_fmla'_correct"><span class="command">lemma</span></span> wf_fmla'_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"wf_fmla' STG <span class="free">φ</span> <span class="main">⟷</span> wf_fmla <span class="free">ty_ent</span> <span class="free">φ</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">φ</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> wf_fmla.induct<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> wf_atom'_correct<span class="main">)</span>

    <span class="keyword1"><span class="command">fun</span></span> <span class="entity">wf_fmla_atom1'</span> <span class="keyword2"><span class="keyword">where</span></span>
      <span class="quoted"><span class="quoted">"<span class="free">wf_fmla_atom1'</span> <span class="free"><span class="bound"><span class="entity">stg</span></span></span> <span class="main">(</span>Atom <span class="main">(</span>predAtm <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> wf_pred_atom' <span class="free"><span class="bound"><span class="entity">stg</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">)</span>"</span></span>
    <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">wf_fmla_atom1'</span> <span class="free"><span class="bound"><span class="entity">stg</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">⟷</span> False"</span></span>

    <span class="keyword1" id="PDDL_STRIPS_Checker-wf_fmla_atom1'_correct"><span class="command">lemma</span></span> wf_fmla_atom1'_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"wf_fmla_atom1' STG <span class="free">φ</span> <span class="main">=</span> wf_fmla_atom <span class="free">ty_ent</span> <span class="free">φ</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">φ</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> wf_fmla_atom.cases<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span>
        <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> wf_atom'_correct is_of_type'_correct<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

    <span class="keyword1"><span class="command">fun</span></span> <span class="entity">wf_effect'</span> <span class="keyword2"><span class="keyword">where</span></span>
      <span class="quoted"><span class="quoted">"<span class="free">wf_effect'</span> <span class="free"><span class="bound"><span class="entity">stg</span></span></span> <span class="main">(</span>Effect <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">d</span></span></span><span class="main">)</span> <span class="main">⟷</span>
          <span class="main">(</span><span class="main">∀</span><span class="bound">ae</span><span class="main">∈</span>set <span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">.</span> wf_fmla_atom1' <span class="free"><span class="bound"><span class="entity">stg</span></span></span> <span class="bound">ae</span><span class="main">)</span>
        <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">de</span><span class="main">∈</span>set <span class="free"><span class="bound"><span class="entity">d</span></span></span><span class="main">.</span>  wf_fmla_atom1' <span class="free"><span class="bound"><span class="entity">stg</span></span></span> <span class="bound">de</span><span class="main">)</span>"</span></span>

    <span class="keyword1" id="PDDL_STRIPS_Checker-wf_effect'_correct"><span class="command">lemma</span></span> wf_effect'_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"wf_effect' STG <span class="free">e</span> <span class="main">=</span> wf_effect <span class="free">ty_ent</span> <span class="free">e</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">e</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> wf_fmla_atom1'_correct<span class="main">)</span>

  <span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Context fixing <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>ty_ent›</span></span>›</span>

  <span class="keyword1"><span class="command">fun</span></span> <span class="entity">wf_action_schema'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">⇒</span> <span class="main">_</span> <span class="main">⇒</span> ast_action_schema <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">wf_action_schema'</span> <span class="free"><span class="bound"><span class="entity">stg</span></span></span> <span class="free"><span class="bound"><span class="entity">conT</span></span></span> <span class="main">(</span>Action_Schema <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">params</span></span></span> <span class="free"><span class="bound"><span class="entity">pre</span></span></span> <span class="free"><span class="bound"><span class="entity">eff</span></span></span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span>
      <span class="keyword1">let</span>
        <span class="bound">tyv</span> <span class="main">=</span> ty_term' <span class="main">(</span>map_of <span class="free"><span class="bound"><span class="entity">params</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">conT</span></span></span>
      <span class="keyword1">in</span>
        distinct <span class="main">(</span>map fst <span class="free"><span class="bound"><span class="entity">params</span></span></span><span class="main">)</span>
      <span class="main">∧</span> wf_fmla' <span class="bound">tyv</span> <span class="free"><span class="bound"><span class="entity">stg</span></span></span> <span class="free"><span class="bound"><span class="entity">pre</span></span></span>
      <span class="main">∧</span> wf_effect' <span class="bound">tyv</span> <span class="free"><span class="bound"><span class="entity">stg</span></span></span> <span class="free"><span class="bound"><span class="entity">eff</span></span></span><span class="main">)</span>"</span></span>

  <span class="keyword1" id="PDDL_STRIPS_Checker-wf_action_schema'_correct"><span class="command">lemma</span></span> wf_action_schema'_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"wf_action_schema' STG mp_constT <span class="free">s</span> <span class="main">=</span> wf_action_schema <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">s</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> wf_fmla'_correct wf_effect'_correct<span class="main">)</span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">wf_domain'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">⇒</span> <span class="main">_</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">wf_domain'</span> <span class="free"><span class="bound"><span class="entity">stg</span></span></span> <span class="free"><span class="bound"><span class="entity">conT</span></span></span> <span class="main">≡</span>
      wf_types
    <span class="main">∧</span> distinct <span class="main">(</span>map <span class="main">(</span>predicate_decl.pred<span class="main">)</span> <span class="main">(</span>predicates <span class="free">D</span><span class="main">)</span><span class="main">)</span>
    <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">p</span><span class="main">∈</span>set <span class="main">(</span>predicates <span class="free">D</span><span class="main">)</span><span class="main">.</span> wf_predicate_decl <span class="bound">p</span><span class="main">)</span>
    <span class="main">∧</span> distinct <span class="main">(</span>map fst <span class="main">(</span>consts <span class="free">D</span><span class="main">)</span><span class="main">)</span>
    <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="main">(</span><span class="bound">n</span><span class="main">,</span><span class="bound">T</span><span class="main">)</span><span class="main">∈</span>set <span class="main">(</span>consts <span class="free">D</span><span class="main">)</span><span class="main">.</span> wf_type <span class="bound">T</span><span class="main">)</span>
    <span class="main">∧</span> distinct <span class="main">(</span>map ast_action_schema.name <span class="main">(</span>actions <span class="free">D</span><span class="main">)</span><span class="main">)</span>
    <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">a</span><span class="main">∈</span>set <span class="main">(</span>actions <span class="free">D</span><span class="main">)</span><span class="main">.</span> wf_action_schema' <span class="free"><span class="bound"><span class="entity">stg</span></span></span> <span class="free"><span class="bound"><span class="entity">conT</span></span></span> <span class="bound">a</span><span class="main">)</span>
    "</span></span>

  <span class="keyword1" id="PDDL_STRIPS_Checker-wf_domain'_correct"><span class="command">lemma</span></span> wf_domain'_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"wf_domain' STG mp_constT <span class="main">=</span> wf_domain"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> wf_domain_def wf_domain'_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> wf_action_schema'_correct<span class="main">)</span>


<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Context of <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>ast_domain›</span></span>›</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Application of Effects›</span></span>

<span class="keyword1"><span class="command">context</span></span> ast_domain <span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We implement the application of an effect by explicit iteration over
    the additions and deletions›</span></span>
  <span class="keyword1"><span class="command">fun</span></span> <span class="entity">apply_effect_exec</span>
    <span class="main">::</span> <span class="quoted"><span class="quoted">"object ast_effect <span class="main">⇒</span> world_model <span class="main">⇒</span> world_model"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">apply_effect_exec</span> <span class="main">(</span>Effect <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">d</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span>
      <span class="main">=</span> fold <span class="main">(</span><span class="main">λ</span><span class="bound">add</span> <span class="bound">s</span><span class="main">.</span> Set.insert <span class="bound">add</span> <span class="bound">s</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span>
          <span class="main">(</span>fold <span class="main">(</span><span class="main">λ</span><span class="bound">del</span> <span class="bound">s</span><span class="main">.</span> Set.remove <span class="bound">del</span> <span class="bound">s</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">d</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>"</span></span>

  <span class="keyword1" id="PDDL_STRIPS_Checker-apply_effect_exec_refine"><span class="command">lemma</span></span> apply_effect_exec_refine<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"apply_effect_exec <span class="main">(</span>Effect <span class="main">(</span><span class="free">a</span><span class="main">)</span> <span class="main">(</span><span class="free">d</span><span class="main">)</span><span class="main">)</span> <span class="free">s</span>
    <span class="main">=</span> apply_effect <span class="main">(</span>Effect <span class="main">(</span><span class="free">a</span><span class="main">)</span> <span class="main">(</span><span class="free">d</span><span class="main">)</span><span class="main">)</span> <span class="free">s</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">a</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">s</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> Nil
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">d</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">s</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> Nil
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">a</span> <span class="skolem">d</span><span class="main">)</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> image_def<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">a</span> <span class="skolem">a</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">d</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">s</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> Nil
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">metis</span> Set.insert_def sup_assoc insert_iff<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">a</span> <span class="skolem">d</span><span class="main">)</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Un_commute minus_set_fold union_set_fold<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">lemmas</span></span> apply_effect_eq_impl_eq
    <span class="main">=</span> apply_effect_exec_refine<span class="main">[</span><span class="operator">symmetric</span><span class="main">,</span> <span class="operator">unfolded</span> apply_effect_exec.simps<span class="main">]</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Context of <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>ast_domain›</span></span>›</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Well-Formedness›</span></span>

<span class="keyword1"><span class="command">context</span></span> ast_problem <span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹ We start by defining a mapping from objects to types. The container
    framework will generate efficient, red-black tree based code for that
    later. ›</span></span>

  <span class="keyword1"><span class="command">type_synonym</span></span> objT <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>object<span class="main">,</span> type<span class="main">)</span> mapping"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">mp_objT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>object<span class="main">,</span> type<span class="main">)</span> mapping"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">mp_objT</span> <span class="main">=</span> Mapping.of_alist <span class="main">(</span>consts D <span class="main">@</span> objects <span class="free">P</span><span class="main">)</span>"</span></span>

  <span class="keyword1" id="PDDL_STRIPS_Checker-mp_objT_correct"><span class="command">lemma</span></span> mp_objT_correct<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Mapping.lookup mp_objT <span class="main">=</span> objT"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> mp_objT_def objT_alt
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Map_To_Mapping.map_apply_def<span class="main">)</span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We refine the typecheck to use the mapping›</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">is_obj_of_type_impl</span> <span class="free"><span class="bound"><span class="entity">stg</span></span></span> <span class="free"><span class="bound"><span class="entity">mp</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">T</span></span></span> <span class="main">=</span> <span class="main">(</span>
    <span class="keyword1">case</span> Mapping.lookup <span class="free"><span class="bound"><span class="entity">mp</span></span></span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">of</span> None <span class="main">⇒</span> False <span class="main">|</span> Some <span class="bound">oT</span> <span class="main">⇒</span> of_type_impl <span class="free"><span class="bound"><span class="entity">stg</span></span></span> <span class="bound">oT</span> <span class="free"><span class="bound"><span class="entity">T</span></span></span>
  <span class="main">)</span>"</span></span>

  <span class="keyword1" id="PDDL_STRIPS_Checker-is_obj_of_type_impl_correct"><span class="command">lemma</span></span> is_obj_of_type_impl_correct<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"is_obj_of_type_impl STG mp_objT <span class="main">=</span> is_obj_of_type"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> ext<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> is_obj_of_type_impl_def is_obj_of_type_def of_type_impl_correct <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We refine the well-formedness checks to use the mapping›</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">wf_fact'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"objT <span class="main">⇒</span> <span class="main">_</span> <span class="main">⇒</span> fact <span class="main">⇒</span> bool"</span></span>
    <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">wf_fact'</span> <span class="free"><span class="bound"><span class="entity">ot</span></span></span> <span class="free"><span class="bound"><span class="entity">stg</span></span></span> <span class="main">≡</span> wf_pred_atom' <span class="main">(</span>Mapping.lookup <span class="free"><span class="bound"><span class="entity">ot</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">stg</span></span></span>"</span></span>

  <span class="keyword1" id="PDDL_STRIPS_Checker-wf_fact'_correct"><span class="command">lemma</span></span> wf_fact'_correct<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"wf_fact' mp_objT STG <span class="main">=</span> wf_fact"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> wf_fact'_def wf_fact_def wf_pred_atom'_correct<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span><span class="main">)</span>


  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">wf_fmla_atom2'</span> <span class="free"><span class="bound"><span class="entity">mp</span></span></span> <span class="free"><span class="bound"><span class="entity">stg</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span>
    <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="keyword1">of</span> formula.Atom <span class="main">(</span>predAtm <span class="bound">p</span> <span class="bound">vs</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span>wf_fact' <span class="free"><span class="bound"><span class="entity">mp</span></span></span> <span class="free"><span class="bound"><span class="entity">stg</span></span></span> <span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">vs</span><span class="main">)</span><span class="main">)</span> <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> False<span class="main">)</span>"</span></span>

  <span class="keyword1" id="PDDL_STRIPS_Checker-wf_fmla_atom2'_correct"><span class="command">lemma</span></span> wf_fmla_atom2'_correct<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"wf_fmla_atom2' mp_objT STG <span class="free">φ</span> <span class="main">=</span> wf_fmla_atom objT <span class="free">φ</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">φ</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> wf_fmla_atom.cases<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> wf_fmla_atom2'_def wf_fact_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">wf_problem'</span> <span class="free"><span class="bound"><span class="entity">stg</span></span></span> <span class="free"><span class="bound"><span class="entity">conT</span></span></span> <span class="free"><span class="bound"><span class="entity">mp</span></span></span> <span class="main">≡</span>
      wf_domain' <span class="free"><span class="bound"><span class="entity">stg</span></span></span> <span class="free"><span class="bound"><span class="entity">conT</span></span></span>
    <span class="main">∧</span> distinct <span class="main">(</span>map fst <span class="main">(</span>objects <span class="free">P</span><span class="main">)</span> <span class="main">@</span> map fst <span class="main">(</span>consts D<span class="main">)</span><span class="main">)</span>
    <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="main">(</span><span class="bound">n</span><span class="main">,</span><span class="bound">T</span><span class="main">)</span><span class="main">∈</span>set <span class="main">(</span>objects <span class="free">P</span><span class="main">)</span><span class="main">.</span> wf_type <span class="bound">T</span><span class="main">)</span>
    <span class="main">∧</span> distinct <span class="main">(</span>init <span class="free">P</span><span class="main">)</span>
    <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">f</span><span class="main">∈</span>set <span class="main">(</span>init <span class="free">P</span><span class="main">)</span><span class="main">.</span> wf_fmla_atom2' <span class="free"><span class="bound"><span class="entity">mp</span></span></span> <span class="free"><span class="bound"><span class="entity">stg</span></span></span> <span class="bound">f</span><span class="main">)</span>
    <span class="main">∧</span> wf_fmla' <span class="main">(</span>Mapping.lookup <span class="free"><span class="bound"><span class="entity">mp</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">stg</span></span></span> <span class="main">(</span>goal <span class="free">P</span><span class="main">)</span>"</span></span>

  <span class="keyword1" id="PDDL_STRIPS_Checker-wf_problem'_correct"><span class="command">lemma</span></span> wf_problem'_correct<span class="main">:</span>
    <span class="quoted"><span class="quoted">"wf_problem' STG mp_constT mp_objT <span class="main">=</span> wf_problem"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> wf_problem_def wf_problem'_def wf_world_model_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> wf_domain'_correct wf_fmla'_correct<span class="main">)</span>


  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Instantiating actions will yield well-founded effects.
    Corollary of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> wf_instantiate_action_schema<span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>
  <span class="keyword1" id="PDDL_STRIPS_Checker-wf_effect_inst_weak"><span class="command">lemma</span></span> wf_effect_inst_weak<span class="main">:</span>
    <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">a</span> <span class="free">args</span>
    <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">ai</span> <span class="main">≡</span> instantiate_action_schema <span class="free">a</span> <span class="free">args</span>"</span></span>
    <span class="keyword2"><span class="keyword">assumes</span></span> A<span class="main">:</span> <span class="quoted"><span class="quoted">"action_params_match <span class="free">a</span> <span class="free">args</span>"</span></span>
      <span class="quoted"><span class="quoted">"wf_action_schema <span class="free">a</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"wf_effect_inst <span class="main">(</span>effect <span class="free">ai</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> wf_instantiate_action_schema<span class="main">[</span><span class="operator">OF</span> A<span class="main">]</span> <span class="keyword1"><span class="command">unfolding</span></span> ai_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">ai</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> wf_effect_inst_alt<span class="main">)</span>


<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Context of <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>ast_problem›</span></span>›</span>


<span class="keyword1"><span class="command">context</span></span> wf_ast_domain <span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Resolving an action yields a well-founded action schema.›</span></span>
  <span class="comment1">(* TODO: This must be implicitly proved when showing that plan execution
    preserves wf. Try to remove this redundancy!*)</span>
  <span class="keyword1" id="PDDL_STRIPS_Checker-resolve_action_wf"><span class="command">lemma</span></span> resolve_action_wf<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"resolve_action_schema <span class="free">n</span> <span class="main">=</span> Some <span class="free">a</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"wf_action_schema <span class="free">a</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">from</span></span> wf_domain <span class="keyword1"><span class="command">have</span></span>
      X1<span class="main">:</span> <span class="quoted"><span class="quoted">"distinct <span class="main">(</span>map ast_action_schema.name <span class="main">(</span>actions <span class="free">D</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">and</span></span> X2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">a</span><span class="main">∈</span>set <span class="main">(</span>actions <span class="free">D</span><span class="main">)</span><span class="main">.</span> wf_action_schema <span class="bound">a</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> wf_domain_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> resolve_action_schema_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> index_by_eq_Some_eq<span class="main"><span class="main">[</span></span><span class="operator">OF</span> X1<span class="main"><span class="main">]</span></span> X2<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Context of <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>ast_domain›</span></span>›</span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Execution of Plan Actions›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We will perform two refinement steps, to summarize redundant operations›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We first lift action schema lookup into the error monad. ›</span></span>
<span class="keyword1"><span class="command">context</span></span> ast_domain <span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">resolve_action_schemaE</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">≡</span>
    lift_opt
      <span class="main">(</span>resolve_action_schema <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span>
      <span class="main">(</span>ERR <span class="main">(</span>shows <span class="inner_quoted">''No such action schema ''</span> <span class="keyword1">o</span> shows <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Context of <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>ast_domain›</span></span>›</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Theory›</span>
</pre>
</div><div id="Lifschitz_Consistency">
<div class="head">
<h1>Theory Lifschitz_Consistency</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Soundness theorem for the STRIPS semantics›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We prove the soundness theorem according to ~\cite{lifschitz1987semantics}.›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Lifschitz_Consistency
<span class="keyword2"><span class="keyword">imports</span></span> <a href="#PDDL_STRIPS_Semantics">PDDL_STRIPS_Semantics</a>
<span class="keyword2"><span class="keyword">begin</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹States are modeled as valuations of our underlying predicate logic.›</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> state <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>predicate<span class="main">×</span>object list<span class="main">)</span> valuation"</span></span>

<span class="keyword1"><span class="command">context</span></span> ast_domain <span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹An action is a partial function from states to states. ›</span></span>
  <span class="keyword1"><span class="command">type_synonym</span></span> action <span class="main">=</span> <span class="quoted"><span class="quoted">"state <span class="main">⇀</span> state"</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The Isabelle/HOL formula <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">prop</span></span> <span class="quoted"><span class="quoted">‹<span class="free"><span class="free">f</span></span> <span class="free"><span class="free">s</span></span> <span class="main"><span class="main">=</span></span> Some <span class="free"><span class="free">s'</span></span>›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> means
    that <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>f›</span></span></span></span> is applicable in state <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>s›</span></span></span></span>, and the result is <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>s'›</span></span></span></span>. ›</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Definition B (i)--(iv) in Lifschitz's paper~\cite{lifschitz1987semantics}›</span></span>

  <span class="keyword1"><span class="command">fun</span></span> <span class="entity">is_NegPredAtom</span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">is_NegPredAtom</span> <span class="main">(</span>Not <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">=</span> is_predAtom <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span> <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">is_NegPredAtom</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> False"</span></span>

  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">close_eq</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span>predAtm <span class="bound">p</span> <span class="bound">xs</span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">xs</span><span class="main">)</span> <span class="main">|</span> Eq <span class="bound">a</span> <span class="bound">b</span> <span class="main">⇒</span> <span class="bound">a</span><span class="main">=</span><span class="bound">b</span><span class="main">)</span>"</span></span>

  <span class="keyword1" id="Lifschitz_Consistency-close_eq_predAtm"><span class="command">lemma</span></span> close_eq_predAtm<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"close_eq <span class="free">s</span> <span class="main">(</span>predAtm <span class="free">p</span> <span class="free">xs</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">s</span> <span class="main">(</span><span class="free">p</span><span class="main">,</span><span class="free">xs</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> close_eq_def<span class="main">)</span>                    

  <span class="keyword1" id="Lifschitz_Consistency-close_eq_Eq"><span class="command">lemma</span></span> close_eq_Eq<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"close_eq <span class="free">s</span> <span class="main">(</span>Eq <span class="free">a</span> <span class="free">b</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">a</span><span class="main">=</span><span class="free">b</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> close_eq_def<span class="main">)</span>


  <span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">entail_eq</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"state <span class="main">⇒</span> object atom formula <span class="main">⇒</span> bool"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">⊨<span class="hidden">⇩</span><sub>=</sub></span>"</span> 55<span class="main">)</span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">entail_eq</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">≡</span> close_eq <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">⊨</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span>"</span></span>


  <span class="keyword1"><span class="command">fun</span></span> <span class="entity">sound_opr</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"ground_action <span class="main">⇒</span> action <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">sound_opr</span> <span class="main">(</span>Ground_Action <span class="free"><span class="bound"><span class="entity">pre</span></span></span> <span class="main">(</span>Effect <span class="free"><span class="bound"><span class="entity">add</span></span></span> <span class="free"><span class="bound"><span class="entity">del</span></span></span><span class="main">)</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">⟷</span>
      <span class="main">(</span><span class="main">∀</span><span class="bound">s</span><span class="main">.</span> <span class="bound">s</span> <span class="main">⊨<span class="hidden">⇩</span><sub>=</sub></span> <span class="free"><span class="bound"><span class="entity">pre</span></span></span> <span class="main">⟶</span>
        <span class="main">(</span><span class="main">∃</span><span class="bound">s'</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">s</span> <span class="main">=</span> Some <span class="bound">s'</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">atm</span><span class="main">.</span> is_predAtom <span class="bound">atm</span> <span class="main">∧</span> <span class="bound">atm</span> <span class="main">∉</span> set <span class="free"><span class="bound"><span class="entity">del</span></span></span> <span class="main">∧</span> <span class="bound">s</span> <span class="main">⊨<span class="hidden">⇩</span><sub>=</sub></span> <span class="bound">atm</span> <span class="main">⟶</span> <span class="bound">s'</span> <span class="main">⊨<span class="hidden">⇩</span><sub>=</sub></span> <span class="bound">atm</span><span class="main">)</span>
              <span class="main">∧</span>  <span class="main">(</span><span class="main">∀</span><span class="bound">atm</span><span class="main">.</span> is_predAtom <span class="bound">atm</span> <span class="main">∧</span> <span class="bound">atm</span> <span class="main">∉</span> set <span class="free"><span class="bound"><span class="entity">add</span></span></span> <span class="main">∧</span> <span class="bound">s</span> <span class="main">⊨<span class="hidden">⇩</span><sub>=</sub></span> Not <span class="bound">atm</span> <span class="main">⟶</span> <span class="bound">s'</span> <span class="main">⊨<span class="hidden">⇩</span><sub>=</sub></span> Not <span class="bound">atm</span><span class="main">)</span>
              <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">fmla</span><span class="main">.</span> <span class="bound">fmla</span> <span class="main">∈</span> set <span class="free"><span class="bound"><span class="entity">add</span></span></span> <span class="main">⟶</span> <span class="bound">s'</span> <span class="main">⊨<span class="hidden">⇩</span><sub>=</sub></span> <span class="bound">fmla</span><span class="main">)</span>
              <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">fmla</span><span class="main">.</span> <span class="bound">fmla</span> <span class="main">∈</span> set <span class="free"><span class="bound"><span class="entity">del</span></span></span> <span class="main">∧</span> <span class="bound">fmla</span> <span class="main">∉</span> set <span class="free"><span class="bound"><span class="entity">add</span></span></span> <span class="main">⟶</span> <span class="bound">s'</span> <span class="main">⊨<span class="hidden">⇩</span><sub>=</sub></span> <span class="main">(</span>Not <span class="bound">fmla</span><span class="main">)</span><span class="main">)</span>
              <span class="main">)</span><span class="main">)</span>
        <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">fmla</span><span class="main">∈</span>set <span class="free"><span class="bound"><span class="entity">add</span></span></span><span class="main">.</span> is_predAtom <span class="bound">fmla</span><span class="main">)</span>"</span></span>

  <span class="keyword1" id="Lifschitz_Consistency-sound_opr_alt"><span class="command">lemma</span></span> sound_opr_alt<span class="main">:</span>
    <span class="quoted"><span class="quoted">"sound_opr <span class="free">opr</span> <span class="free">f</span> <span class="main">=</span>
      <span class="main">(</span><span class="main">(</span><span class="main">∀</span><span class="bound">s</span><span class="main">.</span> <span class="bound">s</span> <span class="main">⊨<span class="hidden">⇩</span><sub>=</sub></span> <span class="main">(</span>precondition <span class="free">opr</span><span class="main">)</span> <span class="main">⟶</span>
          <span class="main">(</span><span class="main">∃</span><span class="bound">s'</span><span class="main">.</span> <span class="free">f</span> <span class="bound">s</span> <span class="main">=</span> <span class="main">(</span>Some <span class="bound">s'</span><span class="main">)</span>
                <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">atm</span><span class="main">.</span> is_predAtom <span class="bound">atm</span> <span class="main">∧</span> <span class="bound">atm</span> <span class="main">∉</span> set<span class="main">(</span>dels <span class="main">(</span>effect <span class="free">opr</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">s</span> <span class="main">⊨<span class="hidden">⇩</span><sub>=</sub></span> <span class="bound">atm</span> <span class="main">⟶</span> <span class="bound">s'</span> <span class="main">⊨<span class="hidden">⇩</span><sub>=</sub></span> <span class="bound">atm</span><span class="main">)</span>
                <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">atm</span><span class="main">.</span> is_predAtom <span class="bound">atm</span> <span class="main">∧</span> <span class="bound">atm</span> <span class="main">∉</span> set <span class="main">(</span>adds <span class="main">(</span>effect <span class="free">opr</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">s</span> <span class="main">⊨<span class="hidden">⇩</span><sub>=</sub></span> Not <span class="bound">atm</span> <span class="main">⟶</span> <span class="bound">s'</span> <span class="main">⊨<span class="hidden">⇩</span><sub>=</sub></span> Not <span class="bound">atm</span><span class="main">)</span>
                <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">atm</span><span class="main">.</span> <span class="bound">atm</span> <span class="main">∈</span> set<span class="main">(</span>adds <span class="main">(</span>effect <span class="free">opr</span><span class="main">)</span><span class="main">)</span> <span class="main">⟶</span> <span class="bound">s'</span> <span class="main">⊨<span class="hidden">⇩</span><sub>=</sub></span> <span class="bound">atm</span><span class="main">)</span>
                <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">fmla</span><span class="main">.</span> <span class="bound">fmla</span> <span class="main">∈</span> set <span class="main">(</span>dels <span class="main">(</span>effect <span class="free">opr</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">fmla</span> <span class="main">∉</span> set<span class="main">(</span>adds <span class="main">(</span>effect <span class="free">opr</span><span class="main">)</span><span class="main">)</span> <span class="main">⟶</span> <span class="bound">s'</span> <span class="main">⊨<span class="hidden">⇩</span><sub>=</sub></span> <span class="main">(</span>Not <span class="bound">fmla</span><span class="main">)</span><span class="main">)</span>
                <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">a</span> <span class="bound">b</span><span class="main">.</span> <span class="bound">s</span> <span class="main">⊨<span class="hidden">⇩</span><sub>=</sub></span> Atom <span class="main">(</span>Eq <span class="bound">a</span> <span class="bound">b</span><span class="main">)</span> <span class="main">⟶</span> <span class="bound">s'</span> <span class="main">⊨<span class="hidden">⇩</span><sub>=</sub></span> Atom <span class="main">(</span>Eq <span class="bound">a</span> <span class="bound">b</span><span class="main">)</span><span class="main">)</span>
                <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">a</span> <span class="bound">b</span><span class="main">.</span> <span class="bound">s</span> <span class="main">⊨<span class="hidden">⇩</span><sub>=</sub></span> Not <span class="main">(</span>Atom <span class="main">(</span>Eq <span class="bound">a</span> <span class="bound">b</span><span class="main">)</span><span class="main">)</span> <span class="main">⟶</span> <span class="bound">s'</span> <span class="main">⊨<span class="hidden">⇩</span><sub>=</sub></span> Not <span class="main">(</span>Atom <span class="main">(</span>Eq <span class="bound">a</span> <span class="bound">b</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
                <span class="main">)</span><span class="main">)</span>
        <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">fmla</span><span class="main">∈</span>set<span class="main">(</span>adds <span class="main">(</span>effect <span class="free">opr</span><span class="main">)</span><span class="main">)</span><span class="main">.</span> is_predAtom <span class="bound">fmla</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">opr</span><span class="main">,</span><span class="free">f</span><span class="main">)</span>"</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> sound_opr.cases<span class="main">)</span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Definition B (v)--(vii) in  Lifschitz's paper~\cite{lifschitz1987semantics}›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">sound_system</span>
    <span class="main">::</span> <span class="quoted"><span class="quoted">"ground_action set
      <span class="main">⇒</span> world_model
      <span class="main">⇒</span> state
      <span class="main">⇒</span> <span class="main">(</span>ground_action <span class="main">⇒</span> action<span class="main">)</span>
      <span class="main">⇒</span> bool"</span></span>
    <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">sound_system</span> <span class="free"><span class="bound"><span class="entity">Σ</span></span></span> <span class="free"><span class="bound"><span class="entity">M<span class="hidden">⇩</span><sub>0</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">s<span class="hidden">⇩</span><sub>0</sub></span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">⟷</span>
      <span class="main">(</span><span class="main">(</span><span class="main">∀</span><span class="bound">fmla</span><span class="main">∈</span>close_world <span class="free"><span class="bound"><span class="entity">M<span class="hidden">⇩</span><sub>0</sub></span></span></span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">s<span class="hidden">⇩</span><sub>0</sub></span></span></span>  <span class="main">⊨<span class="hidden">⇩</span><sub>=</sub></span> <span class="bound">fmla</span><span class="main">)</span>
      <span class="main">∧</span> wm_basic <span class="free"><span class="bound"><span class="entity">M<span class="hidden">⇩</span><sub>0</sub></span></span></span>
      <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">α</span><span class="main">∈</span><span class="free"><span class="bound"><span class="entity">Σ</span></span></span><span class="main">.</span> sound_opr <span class="bound">α</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">α</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Composing two actions›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">compose_action</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"action <span class="main">⇒</span> action <span class="main">⇒</span> action"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">compose_action</span> <span class="free"><span class="bound"><span class="entity">f1</span></span></span> <span class="free"><span class="bound"><span class="entity">f2</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">f2</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">of</span> Some <span class="bound">y</span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">f1</span></span></span> <span class="bound">y</span> <span class="main">|</span> None <span class="main">⇒</span> None<span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Composing a list of actions›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">compose_actions</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"action list <span class="main">⇒</span> action"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="free">compose_actions</span> <span class="free"><span class="bound"><span class="entity">fs</span></span></span> <span class="main">≡</span> fold compose_action <span class="free"><span class="bound"><span class="entity">fs</span></span></span> Some"</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Composing a list of actions satisfies some natural lemmas: ›</span></span>
  <span class="keyword1" id="Lifschitz_Consistency-compose_actions_Nil"><span class="command">lemma</span></span> compose_actions_Nil<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"compose_actions <span class="main">[]</span> <span class="main">=</span> Some"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> compose_actions_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1" id="Lifschitz_Consistency-compose_actions_Cons"><span class="command">lemma</span></span> compose_actions_Cons<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="free">s</span> <span class="main">=</span> Some <span class="free">s'</span> <span class="main">⟹</span> compose_actions <span class="main">(</span><span class="free">f</span><span class="main">#</span><span class="free">fs</span><span class="main">)</span> <span class="free">s</span> <span class="main">=</span> compose_actions <span class="free">fs</span> <span class="free">s'</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command">interpret</span></span> monoid_add <span class="quoted">compose_action</span> <span class="quoted">Some</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">unfold_locales</span>
      <span class="keyword1"><span class="command">unfolding</span></span> compose_action_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="free">s</span> <span class="main">=</span> Some <span class="free">s'</span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> compose_actions_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> compose_action_def fold_plus_sum_list_rev<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Soundness Theorem in Lifschitz's paper~\cite{lifschitz1987semantics}.›</span></span>
<span class="keyword1"><span class="command">theorem</span></span> STRIPS_sema_sound<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"sound_system <span class="free">Σ</span> <span class="free">M<span class="hidden">⇩</span><sub>0</sub></span> <span class="free">s<span class="hidden">⇩</span><sub>0</sub></span> <span class="free">f</span>"</span></span>
    <span class="comment1">― ‹For a sound system <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>Σ›</span></span>›</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"set <span class="free">αs</span> <span class="main">⊆</span> <span class="free">Σ</span>"</span></span>
    <span class="comment1">― ‹And a plan <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>αs›</span></span>›</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"ground_action_path <span class="free">M<span class="hidden">⇩</span><sub>0</sub></span> <span class="free">αs</span> <span class="free">M'</span>"</span></span>
    <span class="comment1">― ‹Which is accepted by the system, yielding result <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>M'›</span></span>
          (called <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>R(αs)›</span></span> in Lifschitz's paper~\cite{lifschitz1987semantics}.)›</span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">s'</span>
    <span class="comment1">― ‹We have that <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>f(αs)›</span></span> is applicable
          in initial state, yielding state <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>s'›</span></span> (called <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>f<span class="hidden">⇩</span><sub>α</sub><span class="hidden">⇩</span><sub>s</sub>(s<span class="hidden">⇩</span><sub>0</sub>)›</span></span> in Lifschitz's paper~\cite{lifschitz1987semantics}.)›</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"compose_actions <span class="main">(</span>map <span class="free">f</span> <span class="free">αs</span><span class="main">)</span> <span class="free">s<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">=</span> Some <span class="free">s'</span>"</span></span>
    <span class="comment1">― ‹The result world model <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>M'›</span></span> is satisfied in state <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>s'›</span></span>›</span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">fmla</span><span class="main">∈</span>close_world <span class="free">M'</span><span class="main">.</span> <span class="free">s'</span> <span class="main">⊨<span class="hidden">⇩</span><sub>=</sub></span> <span class="bound">fmla</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>valuation <span class="free">M'</span> <span class="main">⊨</span> <span class="skolem">fmla</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"wm_basic <span class="free">M'</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">fmla</span><span class="main">∈</span><span class="free">M'</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">fmla</span>
    <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">fmla</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> valuation_def wm_basic_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> atom.split<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">s'</span><span class="main">.</span> compose_actions <span class="main">(</span>map <span class="free">f</span> <span class="free">αs</span><span class="main">)</span> <span class="free">s<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">=</span> Some <span class="bound">s'</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">fmla</span><span class="main">∈</span>close_world <span class="free">M'</span><span class="main">.</span> <span class="bound">s'</span> <span class="main">⊨<span class="hidden">⇩</span><sub>=</sub></span> <span class="bound">fmla</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">αs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">s<span class="hidden">⇩</span><sub>0</sub></span></span> <span class="quoted"><span class="free">M<span class="hidden">⇩</span><sub>0</sub></span></span> <span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> Nil
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> close_world_def compose_action_def sound_system_def<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> ass<span class="main">:</span> <span class="main">(</span>Cons <span class="skolem">α</span> <span class="skolem">αs</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">pre</span></span> <span class="skolem"><span class="skolem">add</span></span> <span class="skolem"><span class="skolem">del</span></span> <span class="keyword2"><span class="keyword">where</span></span> a<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">α</span> <span class="main">=</span> Ground_Action <span class="skolem">pre</span> <span class="main">(</span>Effect <span class="skolem">add</span> <span class="skolem">del</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> ground_action.exhaust ast_effect.exhaust <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?M<span class="hidden">⇩</span><sub>1</sub></span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"execute_ground_action <span class="skolem">α</span> <span class="skolem">M<span class="hidden">⇩</span><sub>0</sub></span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"close_world <span class="skolem">M<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">⊫</span> precondition <span class="skolem">α</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> ass<span class="main">(</span>4<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> s0_ent_cwM0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">fmla</span><span class="main">∈</span><span class="main">(</span>close_world <span class="skolem">M<span class="hidden">⇩</span><sub>0</sub></span><span class="main">)</span><span class="main">.</span> close_eq <span class="skolem">s<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">⊨</span> <span class="bound">fmla</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> ass<span class="main">(</span>2<span class="main">)</span>
      <span class="keyword1"><span class="command">unfolding</span></span> sound_system_def
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> s0_ent_alpha_precond<span class="main">:</span> <span class="quoted"><span class="quoted">"close_eq <span class="skolem">s<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">⊨</span> precondition <span class="skolem">α</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> entailment_def
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">s<span class="hidden">⇩</span><sub>1</sub></span></span> <span class="keyword2"><span class="keyword">where</span></span> s1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span> <span class="skolem">α</span><span class="main">)</span> <span class="skolem">s<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">=</span> Some <span class="skolem">s<span class="hidden">⇩</span><sub>1</sub></span>"</span></span>
      <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">atm</span><span class="main">.</span> is_predAtom <span class="bound">atm</span> <span class="main">⟶</span> <span class="bound">atm</span> <span class="main">∉</span> set<span class="main">(</span>dels <span class="main">(</span>effect <span class="skolem">α</span><span class="main">)</span><span class="main">)</span>
                                            <span class="main">⟶</span> close_eq <span class="skolem">s<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">⊨</span> <span class="bound">atm</span>
                                            <span class="main">⟶</span> close_eq <span class="skolem">s<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⊨</span> <span class="bound">atm</span><span class="main">)</span>"</span></span>
      <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">fmla</span><span class="main">.</span> <span class="bound">fmla</span> <span class="main">∈</span> set<span class="main">(</span>adds <span class="main">(</span>effect <span class="skolem">α</span><span class="main">)</span><span class="main">)</span>
                                            <span class="main">⟶</span> close_eq <span class="skolem">s<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⊨</span> <span class="bound">fmla</span><span class="main">)</span>"</span></span>
      <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">atm</span><span class="main">.</span> is_predAtom <span class="bound">atm</span> <span class="main">∧</span> <span class="bound">atm</span> <span class="main">∉</span> set <span class="main">(</span>adds <span class="main">(</span>effect <span class="skolem">α</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> close_eq <span class="skolem">s<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">⊨</span> Not <span class="bound">atm</span> <span class="main">⟶</span> close_eq <span class="skolem">s<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⊨</span> Not <span class="bound">atm</span><span class="main">)</span>"</span></span>
      <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">fmla</span><span class="main">.</span> <span class="bound">fmla</span> <span class="main">∈</span> set <span class="main">(</span>dels <span class="main">(</span>effect <span class="skolem">α</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">fmla</span> <span class="main">∉</span> set<span class="main">(</span>adds <span class="main">(</span>effect <span class="skolem">α</span><span class="main">)</span><span class="main">)</span> <span class="main">⟶</span> close_eq <span class="skolem">s<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⊨</span> <span class="main">(</span>Not <span class="bound">fmla</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">a</span> <span class="bound">b</span><span class="main">.</span> close_eq <span class="skolem">s<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">⊨</span> Atom <span class="main">(</span>Eq <span class="bound">a</span> <span class="bound">b</span><span class="main">)</span> <span class="main">⟶</span> close_eq <span class="skolem">s<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⊨</span> Atom <span class="main">(</span>Eq <span class="bound">a</span> <span class="bound">b</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">a</span> <span class="bound">b</span><span class="main">.</span> close_eq <span class="skolem">s<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">⊨</span> Not <span class="main">(</span>Atom <span class="main">(</span>Eq <span class="bound">a</span> <span class="bound">b</span><span class="main">)</span><span class="main">)</span> <span class="main">⟶</span> close_eq <span class="skolem">s<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⊨</span> Not <span class="main">(</span>Atom <span class="main">(</span>Eq <span class="bound">a</span> <span class="bound">b</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> ass<span class="main">(</span>2-4<span class="main">)</span>
      <span class="keyword1"><span class="command">unfolding</span></span> sound_system_def sound_opr_alt <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"close_eq <span class="skolem">s<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">⊨</span> <span class="skolem">fmla</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">fmla</span><span class="main">∈</span>close_world <span class="var">?M<span class="hidden">⇩</span><sub>1</sub></span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">fmla</span>
      <span class="keyword1"><span class="command">using</span></span> ass<span class="main">(</span>2<span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> that s1 s0_ent_cwM0
      <span class="keyword1"><span class="command">unfolding</span></span> sound_system_def execute_ground_action_def wm_basic_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> in_close_world_conv<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> DiffE UnE a apply_effect.simps ground_action.sel<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> ast_effect.sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> ast_effect.sel<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> close_world_extensive subsetCE<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Diff_iff Un_iff a ground_action.sel<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> ast_domain.apply_effect.simps ast_domain.close_eq_predAtm ast_effect.sel<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> ast_effect.sel<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> formula_semantics.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> formula_semantics.simps<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> in_close_world_conv is_predAtom.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">atm</span><span class="main">.</span> <span class="skolem">fmla</span> <span class="main">≠</span> formula.Atom <span class="bound">atm</span><span class="main">)</span> <span class="main">⟶</span> <span class="skolem">s</span> <span class="main">⊨</span> <span class="skolem">fmla</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">fmla</span><span class="main">∈</span><span class="var">?M<span class="hidden">⇩</span><sub>1</sub></span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">fmla</span> <span class="skolem">s</span>
    <span class="keyword1"><span class="command">proof</span></span><span class="operator">-</span>
      <span class="keyword1"><span class="command">have</span></span> alpha<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">s</span><span class="main">.</span><span class="main">∀</span><span class="bound">fmla</span><span class="main">∈</span>set<span class="main">(</span>adds <span class="main">(</span>effect <span class="skolem">α</span><span class="main">)</span><span class="main">)</span><span class="main">.</span> <span class="main">¬</span> is_predAtom <span class="bound">fmla</span> <span class="main">⟶</span> <span class="bound">s</span> <span class="main">⊨</span> <span class="bound">fmla</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> ass<span class="main">(</span>2<span class="main">,</span>3<span class="main">)</span>
        <span class="keyword1"><span class="command">unfolding</span></span> sound_system_def ast_domain.sound_opr_alt
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">using</span></span> that
        <span class="keyword1"><span class="command">unfolding</span></span> a execute_ground_action_def
        <span class="keyword1"><span class="command">using</span></span> ass.prems<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">unfolded</span> sound_system_def<span class="main">]</span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">fmla</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> wm_basic_def<span class="main">)</span>

    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∀</span><span class="bound">opr</span><span class="main">∈</span><span class="free">Σ</span><span class="main">.</span> sound_opr <span class="bound">opr</span> <span class="main">(</span><span class="free">f</span> <span class="bound">opr</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> ass<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> sound_system_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"wm_basic <span class="var">?M<span class="hidden">⇩</span><sub>1</sub></span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> ass<span class="main">(</span>2<span class="main">,</span>3<span class="main">)</span>
      <span class="keyword1"><span class="command">unfolding</span></span> sound_system_def execute_ground_action_def
      <span class="keyword1"><span class="command">thm</span></span> sound_opr.cases
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">α</span><span class="main">,</span><span class="free">f</span> <span class="skolem">α</span><span class="main">)</span>"</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> sound_opr.cases<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> wm_basic_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"sound_system <span class="free">Σ</span> <span class="var">?M<span class="hidden">⇩</span><sub>1</sub></span> <span class="skolem">s<span class="hidden">⇩</span><sub>1</sub></span> <span class="free">f</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> sound_system_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> wm_basic_def<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> ass.IH<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> ass.prems <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">s'</span></span> <span class="keyword2"><span class="keyword">where</span></span>
      <span class="quoted"><span class="quoted">"compose_actions <span class="main">(</span>map <span class="free">f</span> <span class="skolem">αs</span><span class="main">)</span> <span class="skolem">s<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">=</span> Some <span class="skolem">s'</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">a</span><span class="main">∈</span>close_world <span class="free">M'</span><span class="main">.</span> <span class="skolem">s'</span> <span class="main">⊨<span class="hidden">⇩</span><sub>=</sub></span> <span class="bound">a</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> s1<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">with</span></span> that <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹More compact notation of the soundness theorem.›</span></span>
  <span class="keyword1"><span class="command">theorem</span></span> STRIPS_sema_sound_compact_version<span class="main">:</span>
    <span class="quoted"><span class="quoted">"sound_system <span class="free">Σ</span> <span class="free">M<span class="hidden">⇩</span><sub>0</sub></span> <span class="free">s<span class="hidden">⇩</span><sub>0</sub></span> <span class="free">f</span> <span class="main">⟹</span> set <span class="free">αs</span> <span class="main">⊆</span> <span class="free">Σ</span>
    <span class="main">⟹</span> ground_action_path <span class="free">M<span class="hidden">⇩</span><sub>0</sub></span> <span class="free">αs</span> <span class="free">M'</span>
    <span class="main">⟹</span> <span class="main">∃</span><span class="bound">s'</span><span class="main">.</span> compose_actions <span class="main">(</span>map <span class="free">f</span> <span class="free">αs</span><span class="main">)</span> <span class="free">s<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">=</span> Some <span class="bound">s'</span>
          <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">fmla</span><span class="main">∈</span>close_world <span class="free">M'</span><span class="main">.</span> <span class="bound">s'</span> <span class="main">⊨<span class="hidden">⇩</span><sub>=</sub></span> <span class="bound">fmla</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> STRIPS_sema_sound <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Context of <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>ast_domain›</span></span>›</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Soundness Theorem for PDDL›</span></span>

<span class="keyword1"><span class="command">context</span></span> wf_ast_problem <span class="keyword2"><span class="keyword">begin</span></span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Mapping world models to states›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">state_to_wm</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"state <span class="main">⇒</span> world_model"</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">state_to_wm</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">{</span>formula.Atom <span class="main">(</span>predAtm <span class="bound">p</span> <span class="bound">xs</span><span class="main">)</span> <span class="main">|</span> <span class="bound">p</span> <span class="bound">xs</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">xs</span><span class="main">)</span><span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="entity">wm_to_state</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"world_model <span class="main">⇒</span> state"</span></span>
    <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">wm_to_state</span> <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">p</span><span class="main">,</span><span class="bound">xs</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span>formula.Atom <span class="main">(</span>predAtm <span class="bound">p</span> <span class="bound">xs</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">M</span></span></span><span class="main">)</span>"</span></span>


  <span class="keyword1" id="Lifschitz_Consistency-wm_to_state_eq"><span class="command">lemma</span></span> wm_to_state_eq<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"wm_to_state <span class="free">M</span> <span class="main">(</span><span class="free">p</span><span class="main">,</span> <span class="free">as</span><span class="main">)</span> <span class="main">⟷</span> Atom <span class="main">(</span>predAtm <span class="free">p</span> <span class="free">as</span><span class="main">)</span> <span class="main">∈</span> <span class="free">M</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> wm_to_state_def<span class="main">)</span>




  <span class="keyword1" id="Lifschitz_Consistency-wm_to_state_inv"><span class="command">lemma</span></span> wm_to_state_inv<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"wm_to_state <span class="main">(</span>state_to_wm <span class="free">s</span><span class="main">)</span> <span class="main">=</span> <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> wm_to_state_def
      state_to_wm_def image_def<span class="main">)</span>

  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Mapping AST action instances to actions›</span></span>
  <span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">pddl_opr_to_act</span> <span class="free"><span class="bound"><span class="entity">g_opr</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">=</span> <span class="main">(</span>
    <span class="keyword1">let</span> <span class="bound">M</span> <span class="main">=</span> state_to_wm <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="keyword1">in</span>
    <span class="keyword1">if</span> <span class="main">(</span>wm_to_state <span class="main">(</span>close_world <span class="bound">M</span><span class="main">)</span><span class="main">)</span> <span class="main">⊨<span class="hidden">⇩</span><sub>=</sub></span> <span class="main">(</span>precondition <span class="free"><span class="bound"><span class="entity">g_opr</span></span></span><span class="main">)</span> <span class="keyword1">then</span>
      Some <span class="main">(</span>wm_to_state <span class="main">(</span>apply_effect <span class="main">(</span>effect <span class="free"><span class="bound"><span class="entity">g_opr</span></span></span><span class="main">)</span> <span class="bound">M</span><span class="main">)</span><span class="main">)</span>
    <span class="keyword1">else</span>
      None<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted"><span class="quoted">"<span class="free">close_eq_M</span> <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="main">∩</span> <span class="main">{</span>Atom <span class="main">(</span>predAtm <span class="bound">p</span> <span class="bound">xs</span><span class="main">)</span> <span class="main">|</span> <span class="bound">p</span> <span class="bound">xs</span><span class="main">.</span> True <span class="main">}</span><span class="main">)</span> <span class="main">∪</span> <span class="main">{</span>Atom <span class="main">(</span>Eq <span class="bound">a</span> <span class="bound">a</span><span class="main">)</span> <span class="main">|</span> <span class="bound">a</span><span class="main">.</span> True<span class="main">}</span> <span class="main">∪</span> <span class="main">{</span><span class="main"><span class="hidden">❙</span><b>¬</b></span><span class="main">(</span>Atom <span class="main">(</span>Eq <span class="bound">a</span> <span class="bound">b</span><span class="main">)</span><span class="main">)</span> <span class="main">|</span> <span class="bound">a</span> <span class="bound">b</span><span class="main">.</span> <span class="bound">a</span><span class="main">≠</span><span class="bound">b</span><span class="main">}</span>"</span></span>

  <span class="keyword1" id="Lifschitz_Consistency-atom_in_wm_eq"><span class="command">lemma</span></span> atom_in_wm_eq<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">⊨<span class="hidden">⇩</span><sub>=</sub></span> <span class="main">(</span>formula.Atom <span class="free">atm</span><span class="main">)</span>
      <span class="main">⟷</span> <span class="main">(</span><span class="main">(</span>formula.Atom <span class="free">atm</span><span class="main">)</span> <span class="main">∈</span> close_eq_M <span class="main">(</span>state_to_wm <span class="free">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> wm_to_state_def
      state_to_wm_def image_def close_eq_M_def close_eq_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> atom.splits<span class="main">)</span>

<span class="keyword1" id="Lifschitz_Consistency-atom_in_wm_2_eq"><span class="command">lemma</span></span> atom_in_wm_2_eq<span class="main">:</span>
    <span class="quoted"><span class="quoted">"close_eq <span class="main">(</span>wm_to_state <span class="free">M</span><span class="main">)</span> <span class="main">⊨</span> <span class="main">(</span>formula.Atom <span class="free">atm</span><span class="main">)</span>
      <span class="main">⟷</span> <span class="main">(</span><span class="main">(</span>formula.Atom <span class="free">atm</span><span class="main">)</span> <span class="main">∈</span> close_eq_M <span class="free">M</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> wm_to_state_def
      state_to_wm_def image_def close_eq_def close_eq_M_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span>atom.splits<span class="main">)</span>

  <span class="keyword1" id="Lifschitz_Consistency-not_dels_preserved"><span class="command">lemma</span></span> not_dels_preserved<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">∉</span> <span class="main">(</span>set <span class="free">d</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">" <span class="free">f</span> <span class="main">∈</span> <span class="free">M</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">∈</span> apply_effect <span class="main">(</span>Effect <span class="free">a</span> <span class="free">d</span><span class="main">)</span> <span class="free">M</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1" id="Lifschitz_Consistency-adds_satisfied"><span class="command">lemma</span></span> adds_satisfied<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">∈</span> <span class="main">(</span>set <span class="free">a</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">∈</span> apply_effect <span class="main">(</span>Effect <span class="free">a</span> <span class="free">d</span><span class="main">)</span> <span class="free">M</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1" id="Lifschitz_Consistency-dels_unsatisfied"><span class="command">lemma</span></span> dels_unsatisfied<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">∈</span> <span class="main">(</span>set <span class="free">d</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">∉</span> set <span class="free">a</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">∉</span> apply_effect <span class="main">(</span>Effect <span class="free">a</span> <span class="free">d</span><span class="main">)</span> <span class="free">M</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1" id="Lifschitz_Consistency-dels_unsatisfied_2"><span class="command">lemma</span></span> dels_unsatisfied_2<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">∈</span> set <span class="main">(</span>dels <span class="free">eff</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">∉</span> set <span class="main">(</span>adds <span class="free">eff</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="main">∉</span> apply_effect <span class="free">eff</span> <span class="free">M</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">eff</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main">)</span>

  <span class="keyword1" id="Lifschitz_Consistency-wf_fmla_atm_is_atom"><span class="command">lemma</span></span> wf_fmla_atm_is_atom<span class="main">:</span> <span class="quoted"><span class="quoted">"wf_fmla_atom objT <span class="free">f</span> <span class="main">⟹</span> is_predAtom <span class="free">f</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">f</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> wf_fmla_atom.cases<span class="main">)</span> <span class="operator">auto</span>

  <span class="keyword1" id="Lifschitz_Consistency-wf_act_adds_are_atoms"><span class="command">lemma</span></span> wf_act_adds_are_atoms<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"wf_effect_inst <span class="free">effs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">ae</span> <span class="main">∈</span> set <span class="main">(</span>adds <span class="free">effs</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"is_predAtom <span class="free">ae</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">effs</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> wf_fmla_atom_alt<span class="main">)</span>

  <span class="keyword1" id="Lifschitz_Consistency-wf_act_adds_dels_atoms"><span class="command">lemma</span></span> wf_act_adds_dels_atoms<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"wf_effect_inst <span class="free">effs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">ae</span> <span class="main">∈</span> set <span class="main">(</span>dels <span class="free">effs</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"is_predAtom <span class="free">ae</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">effs</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> wf_fmla_atom_alt<span class="main">)</span>

  <span class="keyword1" id="Lifschitz_Consistency-to_state_close_from_state_eq"><span class="command">lemma</span></span> to_state_close_from_state_eq<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"wm_to_state <span class="main">(</span>close_world <span class="main">(</span>state_to_wm <span class="free">s</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">s</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> wm_to_state_def close_world_def
      state_to_wm_def image_def<span class="main">)</span>



<span class="keyword1" id="Lifschitz_Consistency-wf_eff_pddl_ground_act_is_sound_opr"><span class="command">lemma</span></span> wf_eff_pddl_ground_act_is_sound_opr<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"wf_effect_inst <span class="main">(</span>effect <span class="free">g_opr</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sound_opr <span class="free">g_opr</span> <span class="main">(</span><span class="main">(</span>pddl_opr_to_act <span class="free">g_opr</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> sound_opr_alt
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">g_opr</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">safe</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> pre eff s
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> exI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"wm_to_state<span class="main">(</span>apply_effect <span class="skolem">eff</span> <span class="main">(</span>state_to_wm <span class="skolem">s</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> pddl_opr_to_act_def Let_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span>if_splits<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> atm
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">eff</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">atm</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> close_eq_def wm_to_state_def state_to_wm_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> atom.splits<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> atm
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">eff</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">atm</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> close_eq_def wm_to_state_def state_to_wm_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> atom.splits<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> atm
      <span class="keyword1"><span class="command">using</span></span> assms
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">eff</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">atm</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> close_eq_def wm_to_state_def state_to_wm_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> atom.splits<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> fmla
      <span class="keyword1"><span class="command">using</span></span> assms
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">eff</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">fmla</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> wf_fmla_atom.cases<span class="main"><span class="keyword3">;</span></span> <span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> close_eq_def wm_to_state_def state_to_wm_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> atom.splits<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> pre eff fmla
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">eff</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">fmla</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> wf_fmla_atom.cases<span class="main"><span class="keyword3">;</span></span> <span class="operator">force</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>



  <span class="keyword1" id="Lifschitz_Consistency-wf_eff_impt_wf_eff_inst"><span class="command">lemma</span></span> wf_eff_impt_wf_eff_inst<span class="main">:</span> <span class="quoted"><span class="quoted">"wf_effect objT <span class="free">eff</span> <span class="main">⟹</span> wf_effect_inst <span class="free">eff</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">eff</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> wf_fmla_atom_alt<span class="main">)</span>

  <span class="keyword1" id="Lifschitz_Consistency-wf_pddl_ground_act_is_sound_opr"><span class="command">lemma</span></span> wf_pddl_ground_act_is_sound_opr<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"wf_ground_action <span class="free">g_opr</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sound_opr <span class="free">g_opr</span> <span class="main">(</span>pddl_opr_to_act <span class="free">g_opr</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> wf_eff_impt_wf_eff_inst wf_eff_pddl_ground_act_is_sound_opr assms
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">g_opr</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main">)</span>

  <span class="keyword1" id="Lifschitz_Consistency-wf_action_schema_sound_inst"><span class="command">lemma</span></span> wf_action_schema_sound_inst<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"action_params_match <span class="free">act</span> <span class="free">args</span>"</span></span> <span class="quoted"><span class="quoted">"wf_action_schema <span class="free">act</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sound_opr
      <span class="main">(</span>instantiate_action_schema <span class="free">act</span> <span class="free">args</span><span class="main">)</span>
      <span class="main">(</span><span class="main">(</span>pddl_opr_to_act <span class="main">(</span>instantiate_action_schema <span class="free">act</span> <span class="free">args</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span>
      wf_pddl_ground_act_is_sound_opr<span class="main">[</span>
        <span class="operator">OF</span> wf_instantiate_action_schema<span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

  <span class="keyword1" id="Lifschitz_Consistency-wf_plan_act_is_sound"><span class="command">lemma</span></span> wf_plan_act_is_sound<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"wf_plan_action <span class="main">(</span>PAction <span class="free">n</span> <span class="free">args</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sound_opr
      <span class="main">(</span>instantiate_action_schema <span class="main">(</span>the <span class="main">(</span>resolve_action_schema <span class="free">n</span><span class="main">)</span><span class="main">)</span> <span class="free">args</span><span class="main">)</span>
      <span class="main">(</span><span class="main">(</span>pddl_opr_to_act
        <span class="main">(</span>instantiate_action_schema <span class="main">(</span>the <span class="main">(</span>resolve_action_schema <span class="free">n</span><span class="main">)</span><span class="main">)</span> <span class="free">args</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">using</span></span> wf_action_schema_sound_inst wf_eff_pddl_ground_act_is_sound_opr
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.splits<span class="main">)</span>

  <span class="keyword1" id="Lifschitz_Consistency-wf_plan_act_is_sound'"><span class="command">lemma</span></span> wf_plan_act_is_sound'<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"wf_plan_action <span class="free">π</span>"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sound_opr
      <span class="main">(</span>resolve_instantiate <span class="free">π</span><span class="main">)</span>
      <span class="main">(</span><span class="main">(</span>pddl_opr_to_act <span class="main">(</span>resolve_instantiate <span class="free">π</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms wf_plan_act_is_sound
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">π</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> <span class="main">)</span>

  <span class="keyword1" id="Lifschitz_Consistency-wf_world_model_has_atoms"><span class="command">lemma</span></span> wf_world_model_has_atoms<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span><span class="main">∈</span><span class="free">M</span> <span class="main">⟹</span> wf_world_model <span class="free">M</span> <span class="main">⟹</span> is_predAtom <span class="free">f</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> wf_fmla_atm_is_atom
    <span class="keyword1"><span class="command">unfolding</span></span> wf_world_model_def
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1" id="Lifschitz_Consistency-wm_to_state_works_for_wf_wm_closed"><span class="command">lemma</span></span> wm_to_state_works_for_wf_wm_closed<span class="main">:</span>
    <span class="quoted"><span class="quoted">"wf_world_model <span class="free">M</span> <span class="main">⟹</span> <span class="free">fmla</span><span class="main">∈</span>close_world <span class="free">M</span> <span class="main">⟹</span> close_eq <span class="main">(</span>wm_to_state <span class="free">M</span><span class="main">)</span> <span class="main">⊨</span> <span class="free">fmla</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">fmla</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> wf_fmla_atom.cases<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> wf_world_model_def close_eq_def wm_to_state_def close_world_def<span class="main">)</span>

  <span class="keyword1" id="Lifschitz_Consistency-wm_to_state_works_for_wf_wm"><span class="command">lemma</span></span> wm_to_state_works_for_wf_wm<span class="main">:</span> <span class="quoted"><span class="quoted">"wf_world_model <span class="free">M</span> <span class="main">⟹</span> <span class="free">fmla</span><span class="main">∈</span><span class="free">M</span> <span class="main">⟹</span> close_eq <span class="main">(</span>wm_to_state <span class="free">M</span><span class="main">)</span> <span class="main">⊨</span> <span class="free">fmla</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">fmla</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> wf_fmla_atom.cases<span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> wf_world_model_def close_eq_def wm_to_state_def<span class="main">)</span>



  <span class="keyword1" id="Lifschitz_Consistency-wm_to_state_works_for_I_closed"><span class="command">lemma</span></span> wm_to_state_works_for_I_closed<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> close_world I"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"close_eq <span class="main">(</span>wm_to_state I<span class="main">)</span> <span class="main">⊨</span> <span class="free">x</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> wm_to_state_works_for_wf_wm_closed<span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> assms wf_I <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>


  <span class="keyword1" id="Lifschitz_Consistency-wf_wm_imp_basic"><span class="command">lemma</span></span> wf_wm_imp_basic<span class="main">:</span> <span class="quoted"><span class="quoted">"wf_world_model <span class="free">M</span> <span class="main">⟹</span> wm_basic <span class="free">M</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> wf_world_model_def wm_basic_def wf_fmla_atm_is_atom<span class="main">)</span>

<span class="keyword1"><span class="command">theorem</span></span> wf_plan_sound_system<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">π</span><span class="main">∈</span> set <span class="free">πs</span><span class="main">.</span> wf_plan_action <span class="bound">π</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sound_system
      <span class="main">(</span>set <span class="main">(</span>map resolve_instantiate <span class="free">πs</span><span class="main">)</span><span class="main">)</span>
      I
      <span class="main">(</span>wm_to_state I<span class="main">)</span>
      <span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">α</span><span class="main">.</span> pddl_opr_to_act <span class="bound">α</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> sound_system_def
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">intro</span> conjI ballI<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"close_eq<span class="main">(</span>wm_to_state I<span class="main">)</span> <span class="main">⊨</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> close_world I"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span>
    <span class="keyword1"><span class="command">using</span></span> that<span class="main">[</span><span class="operator">unfolded</span> in_close_world_conv<span class="main">]</span>
      wm_to_state_works_for_I_closed wm_to_state_works_for_wf_wm
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> wf_I<span class="main">)</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"wm_basic I"</span></span> <span class="keyword1"><span class="command">using</span></span> wf_wm_imp_basic<span class="main">[</span><span class="operator">OF</span> wf_I<span class="main">]</span> <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"sound_opr <span class="skolem">α</span> <span class="main">(</span>pddl_opr_to_act <span class="skolem">α</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">α</span> <span class="main">∈</span> set <span class="main">(</span>map resolve_instantiate <span class="free">πs</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">α</span>
    <span class="keyword1"><span class="command">using</span></span> that
    <span class="keyword1"><span class="command">using</span></span> wf_plan_act_is_sound' assms
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> wf_plan_soundness_theorem<span class="main">:</span>
    <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"plan_action_path I <span class="free">πs</span> <span class="free">M</span>"</span></span>
    <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">αs</span> <span class="main">≡</span> map <span class="main">(</span>pddl_opr_to_act <span class="main">∘</span> resolve_instantiate<span class="main">)</span> <span class="free">πs</span>"</span></span>
    <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">s<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">≡</span> wm_to_state I"</span></span>
    <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">s'</span><span class="main">.</span> compose_actions <span class="free">αs</span> <span class="free">s<span class="hidden">⇩</span><sub>0</sub></span> <span class="main">=</span> Some <span class="bound">s'</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">φ</span><span class="main">∈</span>close_world <span class="free">M</span><span class="main">.</span> <span class="bound">s'</span> <span class="main">⊨<span class="hidden">⇩</span><sub>=</sub></span> <span class="bound">φ</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> STRIPS_sema_sound<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> wf_plan_sound_system<span class="main">)</span>
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">unfolding</span></span> plan_action_path_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> image_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹Context of <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>wf_ast_problem›</span></span>›</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div>